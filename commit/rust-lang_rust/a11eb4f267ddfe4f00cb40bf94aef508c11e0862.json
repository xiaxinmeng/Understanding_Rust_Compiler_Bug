{"sha": "a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "node_id": "C_kwDOAAsO6NoAKGExMWViNGYyNjdkZGZlNGYwMGNiNDBiZjk0YWVmNTA4YzExZTA4NjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-13T21:25:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-13T21:25:50Z"}, "message": "Auto merge of #106822 - matthiaskrgr:rollup-46bi4pi, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #104645 (Add log-backtrace option to show backtraces along with logging)\n - #106465 (Bump `IMPLIED_BOUNDS_ENTAILMENT` to Deny + ReportNow)\n - #106489 (Fix linker detection for linker (drivers) with a version postfix (e.g. clang-12 instead of clang))\n - #106585 (When suggesting writing a fully qualified path probe for appropriate types)\n - #106641 (Provide help on closures capturing self causing borrow checker errors)\n - #106678 (Warn when using panic-strategy abort for proc-macro crates)\n - #106701 (Fix `mpsc::SyncSender` spinning behavior)\n - #106793 (Normalize test output more thoroughly)\n - #106797 (riscv: Fix ELF header flags)\n - #106813 (Remove redundant session field)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0cd26953eeeccf097f1448f09912abe8c6cbeab2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd26953eeeccf097f1448f09912abe8c6cbeab2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "html_url": "https://github.com/rust-lang/rust/commit/a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b90256ada21c6a81b4c18f2c7a23151ab5fc232", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b90256ada21c6a81b4c18f2c7a23151ab5fc232", "html_url": "https://github.com/rust-lang/rust/commit/0b90256ada21c6a81b4c18f2c7a23151ab5fc232"}, {"sha": "f7093826a4f3bdd69cdec0171baf78a99bc94675", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7093826a4f3bdd69cdec0171baf78a99bc94675", "html_url": "https://github.com/rust-lang/rust/commit/f7093826a4f3bdd69cdec0171baf78a99bc94675"}], "stats": {"total": 1176, "additions": 1011, "deletions": 165}, "files": [{"sha": "9b3b3951888a543f56e0fa6639fefc5e2bd28ffa", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -4273,6 +4273,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"rustc_span\",\n  \"tracing\",\n+ \"tracing-core\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n ]"}, {"sha": "968c1f49b95c00ccec072fc253421936dc258f90", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 144, "deletions": 4, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -6,6 +6,7 @@ use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n+use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -20,7 +21,7 @@ use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n@@ -29,6 +30,7 @@ use crate::borrowck_errors;\n \n use crate::diagnostics::conflict_errors::StorageDeadOrDrop::LocalStorageDead;\n use crate::diagnostics::find_all_local_uses;\n+use crate::diagnostics::mutability_errors::mut_borrow_of_mutable_ref;\n use crate::{\n     borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n     InitializationRequiringAction, MirBorrowckCtxt, PrefixSet, WriteKind,\n@@ -356,7 +358,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(hir::Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(_, _, body_id),\n             ..\n-        })) = hir.find(hir.local_def_id_to_hir_id(self.mir_def_id()))\n+        })) = hir.find(self.mir_hir_id())\n             && let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id)\n         {\n             let place = &self.move_data.move_paths[mpi].place;\n@@ -948,7 +950,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             (BorrowKind::Mut { .. }, BorrowKind::Shared) => {\n                 first_borrow_desc = \"immutable \";\n-                self.cannot_reborrow_already_borrowed(\n+                let mut err = self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n@@ -958,7 +960,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"immutable\",\n                     &msg_borrow,\n                     None,\n-                )\n+                );\n+                self.suggest_binding_for_closure_capture_self(\n+                    &mut err,\n+                    issued_borrow.borrowed_place,\n+                    &issued_spans,\n+                );\n+                err\n             }\n \n             (BorrowKind::Mut { .. }, BorrowKind::Mut { .. }) => {\n@@ -1240,6 +1248,138 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_binding_for_closure_capture_self(\n+        &self,\n+        err: &mut Diagnostic,\n+        borrowed_place: Place<'tcx>,\n+        issued_spans: &UseSpans<'tcx>,\n+    ) {\n+        let UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let hir = self.infcx.tcx.hir();\n+\n+        // check whether the borrowed place is capturing `self` by mut reference\n+        let local = borrowed_place.local;\n+        let Some(_) = self\n+            .body\n+            .local_decls\n+            .get(local)\n+            .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local])) else { return };\n+\n+        struct ExpressionFinder<'hir> {\n+            capture_span: Span,\n+            closure_change_spans: Vec<Span>,\n+            closure_arg_span: Option<Span>,\n+            in_closure: bool,\n+            suggest_arg: String,\n+            hir: rustc_middle::hir::map::Map<'hir>,\n+            closure_local_id: Option<hir::HirId>,\n+            closure_call_changes: Vec<(Span, String)>,\n+        }\n+        impl<'hir> Visitor<'hir> for ExpressionFinder<'hir> {\n+            fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n+                if e.span.contains(self.capture_span) {\n+                    if let hir::ExprKind::Closure(&hir::Closure {\n+                            movability: None,\n+                            body,\n+                            fn_arg_span,\n+                            fn_decl: hir::FnDecl{ inputs, .. },\n+                            ..\n+                        }) = e.kind &&\n+                        let Some(hir::Node::Expr(body )) = self.hir.find(body.hir_id) {\n+                            self.suggest_arg = \"this: &Self\".to_string();\n+                            if inputs.len() > 0 {\n+                                self.suggest_arg.push_str(\", \");\n+                            }\n+                            self.in_closure = true;\n+                            self.closure_arg_span = fn_arg_span;\n+                            self.visit_expr(body);\n+                            self.in_closure = false;\n+                    }\n+                }\n+                if let hir::Expr { kind: hir::ExprKind::Path(path), .. } = e {\n+                    if let hir::QPath::Resolved(_, hir::Path { segments: [seg], ..}) = path &&\n+                        seg.ident.name == kw::SelfLower && self.in_closure {\n+                            self.closure_change_spans.push(e.span);\n+                    }\n+                }\n+                hir::intravisit::walk_expr(self, e);\n+            }\n+\n+            fn visit_local(&mut self, local: &'hir hir::Local<'hir>) {\n+                if let hir::Pat { kind: hir::PatKind::Binding(_, hir_id, _ident, _), .. } = local.pat &&\n+                    let Some(init) = local.init\n+                {\n+                    if let hir::Expr { kind: hir::ExprKind::Closure(&hir::Closure {\n+                            movability: None,\n+                            ..\n+                        }), .. } = init &&\n+                        init.span.contains(self.capture_span) {\n+                            self.closure_local_id = Some(*hir_id);\n+                    }\n+                }\n+                hir::intravisit::walk_local(self, local);\n+            }\n+\n+            fn visit_stmt(&mut self, s: &'hir hir::Stmt<'hir>) {\n+                if let hir::StmtKind::Semi(e) = s.kind &&\n+                    let hir::ExprKind::Call(hir::Expr { kind: hir::ExprKind::Path(path), ..}, args) = e.kind &&\n+                    let hir::QPath::Resolved(_, hir::Path { segments: [seg], ..}) = path &&\n+                    let Res::Local(hir_id) = seg.res &&\n+                        Some(hir_id) == self.closure_local_id {\n+                        let (span, arg_str) = if args.len() > 0 {\n+                            (args[0].span.shrink_to_lo(), \"self, \".to_string())\n+                        } else {\n+                            let span = e.span.trim_start(seg.ident.span).unwrap_or(e.span);\n+                            (span, \"(self)\".to_string())\n+                        };\n+                        self.closure_call_changes.push((span, arg_str));\n+                }\n+                hir::intravisit::walk_stmt(self, s);\n+            }\n+        }\n+\n+        if let Some(hir::Node::ImplItem(\n+                    hir::ImplItem { kind: hir::ImplItemKind::Fn(_fn_sig, body_id), .. }\n+                )) = hir.find(self.mir_hir_id()) &&\n+            let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id) {\n+            let mut finder = ExpressionFinder {\n+                capture_span: *capture_kind_span,\n+                closure_change_spans: vec![],\n+                closure_arg_span: None,\n+                in_closure: false,\n+                suggest_arg: String::new(),\n+                closure_local_id: None,\n+                closure_call_changes: vec![],\n+                hir,\n+            };\n+            finder.visit_expr(expr);\n+\n+            if finder.closure_change_spans.is_empty() || finder.closure_call_changes.is_empty() {\n+                return;\n+            }\n+\n+            let mut sugg = vec![];\n+            let sm = self.infcx.tcx.sess.source_map();\n+\n+            if let Some(span) = finder.closure_arg_span {\n+                sugg.push((sm.next_point(span.shrink_to_lo()).shrink_to_hi(), finder.suggest_arg));\n+            }\n+            for span in finder.closure_change_spans {\n+                sugg.push((span, \"this\".to_string()));\n+            }\n+\n+            for (span, suggest) in finder.closure_call_changes {\n+                sugg.push((span, suggest));\n+            }\n+\n+            err.multipart_suggestion_verbose(\n+                \"try explicitly pass `&Self` into the Closure as an argument\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n     /// Returns the description of the root place for a conflicting borrow and the full\n     /// descriptions of the places that caused the conflict.\n     ///"}, {"sha": "45b15c2c5bd7062451a9b947584ecacb2f504d0f", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1094,7 +1094,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n+pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n     debug!(\"local_info: {:?}, ty.kind(): {:?}\", local_decl.local_info, local_decl.ty.kind());\n \n     match local_decl.local_info.as_deref() {"}, {"sha": "342abf81f6a7c0d6b465ce23375dcecd80868297", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1231,12 +1231,21 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                     sess.emit_fatal(errors::LinkerFileStem);\n                 });\n \n+                // Remove any version postfix.\n+                let stem = stem\n+                    .rsplit_once('-')\n+                    .and_then(|(lhs, rhs)| rhs.chars().all(char::is_numeric).then_some(lhs))\n+                    .unwrap_or(stem);\n+\n+                // GCC can have an optional target prefix.\n                 let flavor = if stem == \"emcc\" {\n                     LinkerFlavor::EmCc\n                 } else if stem == \"gcc\"\n                     || stem.ends_with(\"-gcc\")\n+                    || stem == \"g++\"\n+                    || stem.ends_with(\"-g++\")\n                     || stem == \"clang\"\n-                    || stem.ends_with(\"-clang\")\n+                    || stem == \"clang++\"\n                 {\n                     LinkerFlavor::from_cli(LinkerFlavorCli::Gcc, &sess.target)\n                 } else if stem == \"wasm-ld\" || stem.ends_with(\"-wasm-ld\") {"}, {"sha": "5ad2744f61deedb63d57205724628e54e2267b0a", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -165,11 +165,23 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n                 };\n             e_flags\n         }\n-        Architecture::Riscv64 if sess.target.options.features.contains(\"+d\") => {\n-            // copied from `riscv64-linux-gnu-gcc foo.c -c`, note though\n-            // that the `+d` target feature represents whether the double\n-            // float abi is enabled.\n-            let e_flags = elf::EF_RISCV_RVC | elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n+        Architecture::Riscv32 | Architecture::Riscv64 => {\n+            // Source: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/079772828bd10933d34121117a222b4cc0ee2200/riscv-elf.adoc\n+            let mut e_flags: u32 = 0x0;\n+            let features = &sess.target.options.features;\n+            // Check if compressed is enabled\n+            if features.contains(\"+c\") {\n+                e_flags |= elf::EF_RISCV_RVC;\n+            }\n+\n+            // Select the appropriate floating-point ABI\n+            if features.contains(\"+d\") {\n+                e_flags |= elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n+            } else if features.contains(\"+f\") {\n+                e_flags |= elf::EF_RISCV_FLOAT_ABI_SINGLE;\n+            } else {\n+                e_flags |= elf::EF_RISCV_FLOAT_ABI_SOFT;\n+            }\n             e_flags\n         }\n         _ => 0,"}, {"sha": "a62e5dec4b8643aba7ebc69ff4ffc5c6e67e1db5", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -231,6 +231,10 @@ fn run_compiler(\n         registry: diagnostics_registry(),\n     };\n \n+    if !tracing::dispatcher::has_been_set() {\n+        init_rustc_env_logger_with_backtrace_option(&config.opts.unstable_opts.log_backtrace);\n+    }\n+\n     match make_input(config.opts.error_format, &matches.free) {\n         Err(reported) => return Err(reported),\n         Ok(Some((input, input_file_path))) => {\n@@ -1300,7 +1304,14 @@ pub fn install_ice_hook() {\n /// This allows tools to enable rust logging without having to magically match rustc's\n /// tracing crate version.\n pub fn init_rustc_env_logger() {\n-    if let Err(error) = rustc_log::init_rustc_env_logger() {\n+    init_rustc_env_logger_with_backtrace_option(&None);\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to\n+/// choose a target module you wish to show backtraces along with its logging.\n+pub fn init_rustc_env_logger_with_backtrace_option(backtrace_target: &Option<String>) {\n+    if let Err(error) = rustc_log::init_rustc_env_logger_with_backtrace_option(backtrace_target) {\n         early_error(ErrorOutputType::default(), &error.to_string());\n     }\n }\n@@ -1366,7 +1377,6 @@ mod signal_handler {\n pub fn main() -> ! {\n     let start_time = Instant::now();\n     let start_rss = get_resident_set_size();\n-    init_rustc_env_logger();\n     signal_handler::install();\n     let mut callbacks = TimePassesCallbacks::default();\n     install_ice_hook();"}, {"sha": "688b044722260ce0dc7070b425cd43e79f22aaf1", "filename": "compiler/rustc_error_messages/locales/en-US/interface.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -41,3 +41,6 @@ interface_rustc_error_unexpected_annotation =\n \n interface_failed_writing_file =\n     failed to write file {$path}: {$error}\"\n+\n+interface_proc_macro_crate_panic_abort =\n+    building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic"}, {"sha": "3521911b05527b23cda94b14211e018a0985bb32", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 157, "deletions": 17, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -27,6 +27,7 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n@@ -1643,8 +1644,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn report_ambiguous_associated_type(\n         &self,\n         span: Span,\n-        type_str: &str,\n-        trait_str: &str,\n+        types: &[String],\n+        traits: &[String],\n         name: Symbol,\n     ) -> ErrorGuaranteed {\n         let mut err = struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\");\n@@ -1655,19 +1656,92 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .keys()\n             .any(|full_span| full_span.contains(span))\n         {\n-            err.span_suggestion(\n+            err.span_suggestion_verbose(\n                 span.shrink_to_lo(),\n                 \"you are looking for the module in `std`, not the primitive type\",\n                 \"std::\",\n                 Applicability::MachineApplicable,\n             );\n         } else {\n-            err.span_suggestion(\n-                span,\n-                \"use fully-qualified syntax\",\n-                format!(\"<{} as {}>::{}\", type_str, trait_str, name),\n-                Applicability::HasPlaceholders,\n-            );\n+            match (types, traits) {\n+                ([], []) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Type` that implements a trait named \\\n+                             `Trait` with associated type `{name}`, you could use the \\\n+                             fully-qualified path\",\n+                        ),\n+                        format!(\"<Type as Trait>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([], [trait_str]) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Example` that implemented `{trait_str}`, \\\n+                             you could use the fully-qualified path\",\n+                        ),\n+                        format!(\"<Example as {trait_str}>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([], traits) => {\n+                    err.span_suggestions(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Example` that implemented one of the \\\n+                             traits with associated type `{name}`, you could use the \\\n+                             fully-qualified path\",\n+                        ),\n+                        traits\n+                            .iter()\n+                            .map(|trait_str| format!(\"<Example as {trait_str}>::{name}\"))\n+                            .collect::<Vec<_>>(),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([type_str], []) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a trait named `Example` with associated type `{name}` \\\n+                             implemented for `{type_str}`, you could use the fully-qualified path\",\n+                        ),\n+                        format!(\"<{type_str} as Example>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                (types, []) => {\n+                    err.span_suggestions(\n+                        span,\n+                        &format!(\n+                            \"if there were a trait named `Example` with associated type `{name}` \\\n+                             implemented for one of the types, you could use the fully-qualified \\\n+                             path\",\n+                        ),\n+                        types\n+                            .into_iter()\n+                            .map(|type_str| format!(\"<{type_str} as Example>::{name}\")),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                (types, traits) => {\n+                    let mut suggestions = vec![];\n+                    for type_str in types {\n+                        for trait_str in traits {\n+                            suggestions.push(format!(\"<{type_str} as {trait_str}>::{name}\"));\n+                        }\n+                    }\n+                    err.span_suggestions(\n+                        span,\n+                        \"use the fully-qualified path\",\n+                        suggestions,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n         }\n         err.emit()\n     }\n@@ -2050,12 +2124,64 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     err.emit()\n                 } else if let Err(reported) = qself_ty.error_reported() {\n                     reported\n+                } else if let ty::Alias(ty::Opaque, alias_ty) = qself_ty.kind() {\n+                    // `<impl Trait as OtherTrait>::Assoc` makes no sense.\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        tcx.def_span(alias_ty.def_id),\n+                        E0667,\n+                        \"`impl Trait` is not allowed in path parameters\"\n+                    )\n+                    .emit() // Already reported in an earlier stage.\n                 } else {\n+                    // Find all the `impl`s that `qself_ty` has for any trait that has the\n+                    // associated type, so that we suggest the right one.\n+                    let infcx = tcx.infer_ctxt().build();\n+                    // We create a fresh `ty::ParamEnv` instead of the one for `self.item_def_id()`\n+                    // to avoid a cycle error in `src/test/ui/resolve/issue-102946.rs`.\n+                    let param_env = ty::ParamEnv::empty();\n+                    let traits: Vec<_> = self\n+                        .tcx()\n+                        .all_traits()\n+                        .filter(|trait_def_id| {\n+                            // Consider only traits with the associated type\n+                            tcx.associated_items(*trait_def_id)\n+                                .in_definition_order()\n+                                .any(|i| {\n+                                    i.kind.namespace() == Namespace::TypeNS\n+                                        && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n+                                        && matches!(i.kind, ty::AssocKind::Type)\n+                                })\n+                            // Consider only accessible traits\n+                            && tcx.visibility(*trait_def_id)\n+                                .is_accessible_from(self.item_def_id(), tcx)\n+                            && tcx.all_impls(*trait_def_id)\n+                                .any(|impl_def_id| {\n+                                    let trait_ref = tcx.bound_impl_trait_ref(impl_def_id);\n+                                    trait_ref.map_or(false, |trait_ref| {\n+                                        let impl_ = trait_ref.subst(\n+                                            tcx,\n+                                            infcx.fresh_substs_for_item(span, impl_def_id),\n+                                        );\n+                                        infcx\n+                                            .can_eq(\n+                                                param_env,\n+                                                tcx.erase_regions(impl_.self_ty()),\n+                                                tcx.erase_regions(qself_ty),\n+                                            )\n+                                            .is_ok()\n+                                    })\n+                                    && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                                })\n+                        })\n+                        .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n+                        .collect();\n+\n                     // Don't print `TyErr` to the user.\n                     self.report_ambiguous_associated_type(\n                         span,\n-                        &qself_ty.to_string(),\n-                        \"Trait\",\n+                        &[qself_ty.to_string()],\n+                        &traits,\n                         assoc_ident.name,\n                     )\n                 };\n@@ -2173,16 +2299,30 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let is_part_of_self_trait_constraints = def_id == trait_def_id;\n             let is_part_of_fn_in_self_trait = parent_def_id == Some(trait_def_id);\n \n-            let type_name = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {\n-                \"Self\"\n+            let type_names = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {\n+                vec![\"Self\".to_string()]\n             } else {\n-                \"Type\"\n+                // Find all the types that have an `impl` for the trait.\n+                tcx.all_impls(trait_def_id)\n+                    .filter(|impl_def_id| {\n+                        // Consider only accessible traits\n+                        tcx.visibility(*impl_def_id).is_accessible_from(self.item_def_id(), tcx)\n+                            && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                    })\n+                    .filter_map(|impl_def_id| tcx.impl_trait_ref(impl_def_id))\n+                    .map(|impl_| impl_.self_ty())\n+                    // We don't care about blanket impls.\n+                    .filter(|self_ty| !self_ty.has_non_region_param())\n+                    .map(|self_ty| tcx.erase_regions(self_ty).to_string())\n+                    .collect()\n             };\n-\n+            // FIXME: also look at `tcx.generics_of(self.item_def_id()).params` any that\n+            // references the trait. Relevant for the first case in\n+            // `src/test/ui/associated-types/associated-types-in-ambiguous-context.rs`\n             let reported = self.report_ambiguous_associated_type(\n                 span,\n-                type_name,\n-                &path_str,\n+                &type_names,\n+                &[path_str],\n                 item_segment.ident.name,\n             );\n             return tcx.ty_error_with_guaranteed(reported)"}, {"sha": "2cdf75794713fe67666bc377a607976422e188ba", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 148, "deletions": 12, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -2,7 +2,9 @@ use super::potentially_plural_count;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use hir::def_id::{DefId, LocalDefId};\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n@@ -320,15 +322,6 @@ fn compare_method_predicate_entailment<'tcx>(\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n         ));\n     }\n-    let emit_implied_wf_lint = || {\n-        infcx.tcx.struct_span_lint_hir(\n-            rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n-            impl_m_hir_id,\n-            infcx.tcx.def_span(impl_m.def_id),\n-            \"impl method assumes more implied bounds than the corresponding trait method\",\n-            |lint| lint,\n-        );\n-    };\n \n     // Check that all obligations are satisfied by the implementation's\n     // version.\n@@ -346,7 +339,7 @@ fn compare_method_predicate_entailment<'tcx>(\n                 )\n                 .map(|()| {\n                     // If the skip-mode was successful, emit a lint.\n-                    emit_implied_wf_lint();\n+                    emit_implied_wf_lint(infcx.tcx, impl_m, impl_m_hir_id, vec![]);\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n@@ -382,8 +375,16 @@ fn compare_method_predicate_entailment<'tcx>(\n                     CheckImpliedWfMode::Skip,\n                 )\n                 .map(|()| {\n+                    let bad_args = extract_bad_args_for_implies_lint(\n+                        tcx,\n+                        &errors,\n+                        (trait_m, trait_sig),\n+                        // Unnormalized impl sig corresponds to the HIR types written\n+                        (impl_m, unnormalized_impl_sig),\n+                        impl_m_hir_id,\n+                    );\n                     // If the skip-mode was successful, emit a lint.\n-                    emit_implied_wf_lint();\n+                    emit_implied_wf_lint(tcx, impl_m, impl_m_hir_id, bad_args);\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n@@ -400,6 +401,141 @@ fn compare_method_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+fn extract_bad_args_for_implies_lint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    errors: &[infer::RegionResolutionError<'tcx>],\n+    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    hir_id: hir::HirId,\n+) -> Vec<(Span, Option<String>)> {\n+    let mut blame_generics = vec![];\n+    for error in errors {\n+        // Look for the subregion origin that contains an input/output type\n+        let origin = match error {\n+            infer::RegionResolutionError::ConcreteFailure(o, ..) => o,\n+            infer::RegionResolutionError::GenericBoundFailure(o, ..) => o,\n+            infer::RegionResolutionError::SubSupConflict(_, _, o, ..) => o,\n+            infer::RegionResolutionError::UpperBoundUniverseConflict(.., o, _) => o,\n+        };\n+        // Extract (possible) input/output types from origin\n+        match origin {\n+            infer::SubregionOrigin::Subtype(trace) => {\n+                if let Some((a, b)) = trace.values.ty() {\n+                    blame_generics.extend([a, b]);\n+                }\n+            }\n+            infer::SubregionOrigin::RelateParamBound(_, ty, _) => blame_generics.push(*ty),\n+            infer::SubregionOrigin::ReferenceOutlivesReferent(ty, _) => blame_generics.push(*ty),\n+            _ => {}\n+        }\n+    }\n+\n+    let fn_decl = tcx.hir().fn_decl_by_hir_id(hir_id).unwrap();\n+    let opt_ret_ty = match fn_decl.output {\n+        hir::FnRetTy::DefaultReturn(_) => None,\n+        hir::FnRetTy::Return(ty) => Some(ty),\n+    };\n+\n+    // Map late-bound regions from trait to impl, so the names are right.\n+    let mapping = std::iter::zip(\n+        tcx.fn_sig(trait_m.def_id).bound_vars(),\n+        tcx.fn_sig(impl_m.def_id).bound_vars(),\n+    )\n+    .filter_map(|(impl_bv, trait_bv)| {\n+        if let ty::BoundVariableKind::Region(impl_bv) = impl_bv\n+            && let ty::BoundVariableKind::Region(trait_bv) = trait_bv\n+        {\n+            Some((impl_bv, trait_bv))\n+        } else {\n+            None\n+        }\n+    })\n+    .collect();\n+\n+    // For each arg, see if it was in the \"blame\" of any of the region errors.\n+    // If so, then try to produce a suggestion to replace the argument type with\n+    // one from the trait.\n+    let mut bad_args = vec![];\n+    for (idx, (ty, hir_ty)) in\n+        std::iter::zip(impl_sig.inputs_and_output, fn_decl.inputs.iter().chain(opt_ret_ty))\n+            .enumerate()\n+    {\n+        let expected_ty = trait_sig.inputs_and_output[idx]\n+            .fold_with(&mut RemapLateBound { tcx, mapping: &mapping });\n+        if blame_generics.iter().any(|blame| ty.contains(*blame)) {\n+            let expected_ty_sugg = expected_ty.to_string();\n+            bad_args.push((\n+                hir_ty.span,\n+                // Only suggest something if it actually changed.\n+                (expected_ty_sugg != ty.to_string()).then_some(expected_ty_sugg),\n+            ));\n+        }\n+    }\n+\n+    bad_args\n+}\n+\n+struct RemapLateBound<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    mapping: &'a FxHashMap<ty::BoundRegionKind, ty::BoundRegionKind>,\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for RemapLateBound<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        if let ty::ReFree(fr) = *r {\n+            self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                bound_region: self\n+                    .mapping\n+                    .get(&fr.bound_region)\n+                    .copied()\n+                    .unwrap_or(fr.bound_region),\n+                ..fr\n+            }))\n+        } else {\n+            r\n+        }\n+    }\n+}\n+\n+fn emit_implied_wf_lint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_m: &ty::AssocItem,\n+    hir_id: hir::HirId,\n+    bad_args: Vec<(Span, Option<String>)>,\n+) {\n+    let span: MultiSpan = if bad_args.is_empty() {\n+        tcx.def_span(impl_m.def_id).into()\n+    } else {\n+        bad_args.iter().map(|(span, _)| *span).collect::<Vec<_>>().into()\n+    };\n+    tcx.struct_span_lint_hir(\n+        rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n+        hir_id,\n+        span,\n+        \"impl method assumes more implied bounds than the corresponding trait method\",\n+        |lint| {\n+            let bad_args: Vec<_> =\n+                bad_args.into_iter().filter_map(|(span, sugg)| Some((span, sugg?))).collect();\n+            if !bad_args.is_empty() {\n+                lint.multipart_suggestion(\n+                    format!(\n+                        \"replace {} type{} to make the impl signature compatible\",\n+                        pluralize!(\"this\", bad_args.len()),\n+                        pluralize!(bad_args.len())\n+                    ),\n+                    bad_args,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            lint\n+        },\n+    );\n+}\n+\n #[derive(Debug, PartialEq, Eq)]\n enum CheckImpliedWfMode {\n     /// Checks implied well-formedness of the impl method. If it fails, we will"}, {"sha": "f817c5bc1cd73fd08a6440c0abf4df017a13bb53", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -45,6 +45,7 @@ rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n rustc_privacy = { path = \"../rustc_privacy\" }\n rustc_query_impl = { path = \"../rustc_query_impl\" }\n rustc_resolve = { path = \"../rustc_resolve\" }\n+rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n "}, {"sha": "15d7e977bbe881511d6c68a1798b5a70be164608", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -87,3 +87,7 @@ pub struct FailedWritingFile<'a> {\n     pub path: &'a Path,\n     pub error: io::Error,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_proc_macro_crate_panic_abort)]\n+pub struct ProcMacroCratePanicAbort;"}, {"sha": "50c40206d8026f66626a3ac07b9c1e0c117dbc3d", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1,7 +1,8 @@\n use crate::errors::{\n     CantEmitMIR, EmojiIdentifier, ErrorWritingDependencies, FerrisIdentifier,\n     GeneratedFileConflictsWithDirectory, InputFileWouldBeOverWritten, MixedBinCrate,\n-    MixedProcMacroCrate, OutDirError, ProcMacroDocWithoutArg, TempsDirError,\n+    MixedProcMacroCrate, OutDirError, ProcMacroCratePanicAbort, ProcMacroDocWithoutArg,\n+    TempsDirError,\n };\n use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n@@ -36,6 +37,7 @@ use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::FileName;\n+use rustc_target::spec::PanicStrategy;\n use rustc_trait_selection::traits;\n \n use std::any::Any;\n@@ -380,6 +382,10 @@ pub fn configure_and_expand(\n         }\n     }\n \n+    if is_proc_macro_crate && sess.panic_strategy() == PanicStrategy::Abort {\n+        sess.emit_warning(ProcMacroCratePanicAbort);\n+    }\n+\n     // For backwards compatibility, we don't try to run proc macro injection\n     // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being\n     // specified. This should only affect users who manually invoke 'rustdoc', as"}, {"sha": "07b28cc86cee1c95601f320e5ead863001913ab7", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -748,6 +748,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(link_only, true);\n     tracked!(llvm_plugins, vec![String::from(\"plugin_name\")]);\n     tracked!(location_detail, LocationDetail { file: true, line: false, column: false });\n+    tracked!(log_backtrace, Some(\"filter\".to_string()));\n     tracked!(maximal_hir_to_mir_coverage, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));\n     tracked!(mir_emit_retag, true);"}, {"sha": "6cdf50970836a99ab5a7c73033a5d68ff202c0bd", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -4033,10 +4033,10 @@ declare_lint! {\n     ///\n     /// This can be used to implement an unsound API if used incorrectly.\n     pub IMPLIED_BOUNDS_ENTAILMENT,\n-    Warn,\n+    Deny,\n     \"impl method assumes more implied bounds than its corresponding trait method\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #105572 <https://github.com/rust-lang/rust/issues/105572>\",\n-        reason: FutureIncompatibilityReason::FutureReleaseError,\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }"}, {"sha": "7f955b0a75090ee7234784612bdd1a316a80f47b", "filename": "compiler/rustc_log/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_log%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_log%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2FCargo.toml?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n tracing = \"0.1.28\"\n tracing-subscriber = { version = \"0.3.3\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n tracing-tree = \"0.2.0\"\n+tracing-core = \"0.1.28\"\n \n [dev-dependencies]\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "fc1cabd2de95134ab892f7e9f06b8b09d90e2fa2", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -45,16 +45,34 @@\n use std::env::{self, VarError};\n use std::fmt::{self, Display};\n use std::io::{self, IsTerminal};\n+use tracing_core::{Event, Subscriber};\n use tracing_subscriber::filter::{Directive, EnvFilter, LevelFilter};\n+use tracing_subscriber::fmt::{\n+    format::{self, FormatEvent, FormatFields},\n+    FmtContext,\n+};\n use tracing_subscriber::layer::SubscriberExt;\n \n pub fn init_rustc_env_logger() -> Result<(), Error> {\n-    init_env_logger(\"RUSTC_LOG\")\n+    init_rustc_env_logger_with_backtrace_option(&None)\n+}\n+\n+pub fn init_rustc_env_logger_with_backtrace_option(\n+    backtrace_target: &Option<String>,\n+) -> Result<(), Error> {\n+    init_env_logger_with_backtrace_option(\"RUSTC_LOG\", backtrace_target)\n }\n \n /// In contrast to `init_rustc_env_logger` this allows you to choose an env var\n /// other than `RUSTC_LOG`.\n pub fn init_env_logger(env: &str) -> Result<(), Error> {\n+    init_env_logger_with_backtrace_option(env, &None)\n+}\n+\n+pub fn init_env_logger_with_backtrace_option(\n+    env: &str,\n+    backtrace_target: &Option<String>,\n+) -> Result<(), Error> {\n     let filter = match env::var(env) {\n         Ok(env) => EnvFilter::new(env),\n         _ => EnvFilter::default().add_directive(Directive::from(LevelFilter::WARN)),\n@@ -88,11 +106,47 @@ pub fn init_env_logger(env: &str) -> Result<(), Error> {\n     let layer = layer.with_thread_ids(true).with_thread_names(true);\n \n     let subscriber = tracing_subscriber::Registry::default().with(filter).with(layer);\n-    tracing::subscriber::set_global_default(subscriber).unwrap();\n+    match backtrace_target {\n+        Some(str) => {\n+            let fmt_layer = tracing_subscriber::fmt::layer()\n+                .with_writer(io::stderr)\n+                .without_time()\n+                .event_format(BacktraceFormatter { backtrace_target: str.to_string() });\n+            let subscriber = subscriber.with(fmt_layer);\n+            tracing::subscriber::set_global_default(subscriber).unwrap();\n+        }\n+        None => {\n+            tracing::subscriber::set_global_default(subscriber).unwrap();\n+        }\n+    };\n \n     Ok(())\n }\n \n+struct BacktraceFormatter {\n+    backtrace_target: String,\n+}\n+\n+impl<S, N> FormatEvent<S, N> for BacktraceFormatter\n+where\n+    S: Subscriber + for<'a> tracing_subscriber::registry::LookupSpan<'a>,\n+    N: for<'a> FormatFields<'a> + 'static,\n+{\n+    fn format_event(\n+        &self,\n+        _ctx: &FmtContext<'_, S, N>,\n+        mut writer: format::Writer<'_>,\n+        event: &Event<'_>,\n+    ) -> fmt::Result {\n+        let target = event.metadata().target();\n+        if !target.contains(&self.backtrace_target) {\n+            return Ok(());\n+        }\n+        let backtrace = std::backtrace::Backtrace::capture();\n+        writeln!(writer, \"stack backtrace: \\n{:?}\", backtrace)\n+    }\n+}\n+\n pub fn stdout_isatty() -> bool {\n     io::stdout().is_terminal()\n }"}, {"sha": "f950e4a9bee65282e8ae37a9358f1d408191e00d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1137,7 +1137,7 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     }\n }\n \n-impl Resolver<'_> {\n+impl<'a> Resolver<'a> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()\n     }\n@@ -1194,6 +1194,10 @@ impl Resolver<'_> {\n             self.cstore().item_generics_num_lifetimes(def_id, self.session)\n         }\n     }\n+\n+    pub fn sess(&self) -> &'a Session {\n+        self.session\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "7b5fd6cc2a81d9a0c3bc45c660b34f3c7ec7fec3", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1411,6 +1411,8 @@ options! {\n         \"what location details should be tracked when using caller_location, either \\\n         `none`, or a comma separated list of location details, for which \\\n         valid options are `file`, `line`, and `column` (default: `file,line,column`)\"),\n+    log_backtrace: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"add a backtrace along with logging\"),\n     ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate (default: no)\"),\n     macro_backtrace: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "c1e3e48b04468c8c501d45392b3c06b35fa34ac8", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -168,7 +168,7 @@ impl<T> Channel<T> {\n                         return true;\n                     }\n                     Err(_) => {\n-                        backoff.spin();\n+                        backoff.spin_light();\n                         tail = self.tail.load(Ordering::Relaxed);\n                     }\n                 }\n@@ -182,11 +182,11 @@ impl<T> Channel<T> {\n                     return false;\n                 }\n \n-                backoff.spin();\n+                backoff.spin_light();\n                 tail = self.tail.load(Ordering::Relaxed);\n             } else {\n                 // Snooze because we need to wait for the stamp to get updated.\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 tail = self.tail.load(Ordering::Relaxed);\n             }\n         }\n@@ -251,7 +251,7 @@ impl<T> Channel<T> {\n                         return true;\n                     }\n                     Err(_) => {\n-                        backoff.spin();\n+                        backoff.spin_light();\n                         head = self.head.load(Ordering::Relaxed);\n                     }\n                 }\n@@ -273,11 +273,11 @@ impl<T> Channel<T> {\n                     }\n                 }\n \n-                backoff.spin();\n+                backoff.spin_light();\n                 head = self.head.load(Ordering::Relaxed);\n             } else {\n                 // Snooze because we need to wait for the stamp to get updated.\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.load(Ordering::Relaxed);\n             }\n         }\n@@ -330,7 +330,7 @@ impl<T> Channel<T> {\n                 if backoff.is_completed() {\n                     break;\n                 } else {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                 }\n             }\n "}, {"sha": "ec6c0726ac790304403e374be47c6246c50f66dc", "filename": "library/std/src/sync/mpmc/list.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -46,7 +46,7 @@ impl<T> Slot<T> {\n     fn wait_write(&self) {\n         let backoff = Backoff::new();\n         while self.state.load(Ordering::Acquire) & WRITE == 0 {\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n }\n@@ -82,7 +82,7 @@ impl<T> Block<T> {\n             if !next.is_null() {\n                 return next;\n             }\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n \n@@ -191,7 +191,7 @@ impl<T> Channel<T> {\n \n             // If we reached the end of the block, wait until the next one is installed.\n             if offset == BLOCK_CAP {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 tail = self.tail.index.load(Ordering::Acquire);\n                 block = self.tail.block.load(Ordering::Acquire);\n                 continue;\n@@ -247,7 +247,7 @@ impl<T> Channel<T> {\n                     return true;\n                 },\n                 Err(_) => {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                     tail = self.tail.index.load(Ordering::Acquire);\n                     block = self.tail.block.load(Ordering::Acquire);\n                 }\n@@ -286,7 +286,7 @@ impl<T> Channel<T> {\n \n             // If we reached the end of the block, wait until the next one is installed.\n             if offset == BLOCK_CAP {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.index.load(Ordering::Acquire);\n                 block = self.head.block.load(Ordering::Acquire);\n                 continue;\n@@ -320,7 +320,7 @@ impl<T> Channel<T> {\n             // The block can be null here only if the first message is being sent into the channel.\n             // In that case, just wait until it gets initialized.\n             if block.is_null() {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.index.load(Ordering::Acquire);\n                 block = self.head.block.load(Ordering::Acquire);\n                 continue;\n@@ -351,7 +351,7 @@ impl<T> Channel<T> {\n                     return true;\n                 },\n                 Err(_) => {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                     head = self.head.index.load(Ordering::Acquire);\n                     block = self.head.block.load(Ordering::Acquire);\n                 }\n@@ -542,7 +542,7 @@ impl<T> Channel<T> {\n             // New updates to tail will be rejected by MARK_BIT and aborted unless it's\n             // at boundary. We need to wait for the updates take affect otherwise there\n             // can be memory leaks.\n-            backoff.snooze();\n+            backoff.spin_heavy();\n             tail = self.tail.index.load(Ordering::Acquire);\n         }\n "}, {"sha": "7a602cecd3b896455a8882b66a9517b3885670ca", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -43,7 +43,7 @@ mod zero;\n use crate::fmt;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n use crate::time::{Duration, Instant};\n-use error::*;\n+pub use error::*;\n \n /// Creates a channel of unbounded capacity.\n ///"}, {"sha": "cfe42750d5239a6a46ab629027581df795c12129", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -91,9 +91,8 @@ impl<T> DerefMut for CachePadded<T> {\n }\n \n const SPIN_LIMIT: u32 = 6;\n-const YIELD_LIMIT: u32 = 10;\n \n-/// Performs exponential backoff in spin loops.\n+/// Performs quadratic backoff in spin loops.\n pub struct Backoff {\n     step: Cell<u32>,\n }\n@@ -104,25 +103,27 @@ impl Backoff {\n         Backoff { step: Cell::new(0) }\n     }\n \n-    /// Backs off in a lock-free loop.\n+    /// Backs off using lightweight spinning.\n     ///\n-    /// This method should be used when we need to retry an operation because another thread made\n-    /// progress.\n+    /// This method should be used for:\n+    ///     - Retrying an operation because another thread made progress. i.e. on CAS failure.\n+    ///     - Waiting for an operation to complete by spinning optimistically for a few iterations\n+    ///     before falling back to parking the thread (see `Backoff::is_completed`).\n     #[inline]\n-    pub fn spin(&self) {\n+    pub fn spin_light(&self) {\n         let step = self.step.get().min(SPIN_LIMIT);\n         for _ in 0..step.pow(2) {\n             crate::hint::spin_loop();\n         }\n \n-        if self.step.get() <= SPIN_LIMIT {\n-            self.step.set(self.step.get() + 1);\n-        }\n+        self.step.set(self.step.get() + 1);\n     }\n \n-    /// Backs off in a blocking loop.\n+    /// Backs off using heavyweight spinning.\n+    ///\n+    /// This method should be used in blocking loops where parking the thread is not an option.\n     #[inline]\n-    pub fn snooze(&self) {\n+    pub fn spin_heavy(&self) {\n         if self.step.get() <= SPIN_LIMIT {\n             for _ in 0..self.step.get().pow(2) {\n                 crate::hint::spin_loop()\n@@ -131,14 +132,12 @@ impl Backoff {\n             crate::thread::yield_now();\n         }\n \n-        if self.step.get() <= YIELD_LIMIT {\n-            self.step.set(self.step.get() + 1);\n-        }\n+        self.step.set(self.step.get() + 1);\n     }\n \n-    /// Returns `true` if quadratic backoff has completed and blocking the thread is advised.\n+    /// Returns `true` if quadratic backoff has completed and parking the thread is advised.\n     #[inline]\n     pub fn is_completed(&self) -> bool {\n-        self.step.get() > YIELD_LIMIT\n+        self.step.get() > SPIN_LIMIT\n     }\n }"}, {"sha": "33f768dcbe90296d9a98cbc191ad65adc4ce01aa", "filename": "library/std/src/sync/mpmc/zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -57,7 +57,7 @@ impl<T> Packet<T> {\n     fn wait_ready(&self) {\n         let backoff = Backoff::new();\n         while !self.ready.load(Ordering::Acquire) {\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n }"}, {"sha": "6e3c28f10bb1ba9e31298fa90d34b54029ae32bd", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -738,6 +738,15 @@ impl<T> SyncSender<T> {\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         self.inner.try_send(t)\n     }\n+\n+    // Attempts to send for a value on this receiver, returning an error if the\n+    // corresponding channel has hung up, or if it waits more than `timeout`.\n+    //\n+    // This method is currently private and only used for tests.\n+    #[allow(unused)]\n+    fn send_timeout(&self, t: T, timeout: Duration) -> Result<(), mpmc::SendTimeoutError<T>> {\n+        self.inner.send_timeout(t, timeout)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9d2f92ffc9b1415ec6e93a93189f10f64ed35042", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::env;\n+use crate::sync::mpmc::SendTimeoutError;\n use crate::thread;\n use crate::time::Duration;\n \n@@ -41,6 +42,13 @@ fn recv_timeout() {\n     assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Ok(1));\n }\n \n+#[test]\n+fn send_timeout() {\n+    let (tx, _rx) = sync_channel::<i32>(1);\n+    assert_eq!(tx.send_timeout(1, Duration::from_millis(1)), Ok(()));\n+    assert_eq!(tx.send_timeout(1, Duration::from_millis(1)), Err(SendTimeoutError::Timeout(1)));\n+}\n+\n #[test]\n fn smoke_threads() {\n     let (tx, rx) = sync_channel::<i32>(0);"}, {"sha": "86454e1f2eb7316d239d4544c3adeec49e917e89", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -772,7 +772,6 @@ fn main_args(at_args: &[String]) -> MainResult {\n     let crate_version = options.crate_version.clone();\n \n     let output_format = options.output_format;\n-    let externs = options.externs.clone();\n     let scrape_examples_options = options.scrape_examples_options.clone();\n     let bin_crate = options.bin_crate;\n \n@@ -805,9 +804,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n                 let resolver_caches = resolver.borrow_mut().access(|resolver| {\n                     collect_intra_doc_links::early_resolve_intra_doc_links(\n                         resolver,\n-                        sess,\n                         krate,\n-                        externs,\n                         render_options.document_private,\n                     )\n                 });"}, {"sha": "42677bd8497483cce642162000a7ffc4848b07e8", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -12,8 +12,6 @@ use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, CRATE_DEF_ID};\n use rustc_hir::TraitCandidate;\n use rustc_middle::ty::{DefIdTree, Visibility};\n use rustc_resolve::{ParentScope, Resolver};\n-use rustc_session::config::Externs;\n-use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::{Symbol, SyntaxContext};\n \n@@ -22,16 +20,13 @@ use std::mem;\n \n pub(crate) fn early_resolve_intra_doc_links(\n     resolver: &mut Resolver<'_>,\n-    sess: &Session,\n     krate: &ast::Crate,\n-    externs: Externs,\n     document_private_items: bool,\n ) -> ResolverCaches {\n     let parent_scope =\n         ParentScope::module(resolver.expect_module(CRATE_DEF_ID.to_def_id()), resolver);\n     let mut link_resolver = EarlyDocLinkResolver {\n         resolver,\n-        sess,\n         parent_scope,\n         visited_mods: Default::default(),\n         markdown_links: Default::default(),\n@@ -52,7 +47,9 @@ pub(crate) fn early_resolve_intra_doc_links(\n     // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n     // DO NOT REMOVE THIS without first testing on the reproducer in\n     // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n-    for (extern_name, _) in externs.iter().filter(|(_, entry)| entry.add_prelude) {\n+    for (extern_name, _) in\n+        link_resolver.resolver.sess().opts.externs.iter().filter(|(_, entry)| entry.add_prelude)\n+    {\n         link_resolver.resolver.resolve_rustdoc_path(extern_name, TypeNS, parent_scope);\n     }\n \n@@ -73,7 +70,6 @@ fn doc_attrs<'a>(attrs: impl Iterator<Item = &'a ast::Attribute>) -> Attributes\n \n struct EarlyDocLinkResolver<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n-    sess: &'r Session,\n     parent_scope: ParentScope<'ra>,\n     visited_mods: DefIdSet,\n     markdown_links: FxHashMap<String, Vec<PreprocessedMarkdownLink>>,\n@@ -166,7 +162,7 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n     fn resolve_doc_links_extern_impl(&mut self, def_id: DefId, is_inherent: bool) {\n         self.resolve_doc_links_extern_outer_fixme(def_id, def_id);\n         let assoc_item_def_ids = Vec::from_iter(\n-            self.resolver.cstore().associated_item_def_ids_untracked(def_id, self.sess),\n+            self.resolver.cstore().associated_item_def_ids_untracked(def_id, self.resolver.sess()),\n         );\n         for assoc_def_id in assoc_item_def_ids {\n             if !is_inherent || self.resolver.cstore().visibility_untracked(assoc_def_id).is_public()\n@@ -191,7 +187,9 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n             return;\n         }\n-        let attrs = Vec::from_iter(self.resolver.cstore().item_attrs_untracked(def_id, self.sess));\n+        let attrs = Vec::from_iter(\n+            self.resolver.cstore().item_attrs_untracked(def_id, self.resolver.sess()),\n+        );\n         let parent_scope = ParentScope::module(\n             self.resolver.get_nearest_non_block_module(\n                 self.resolver.opt_parent(scope_id).unwrap_or(scope_id),\n@@ -205,7 +203,9 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n             return;\n         }\n-        let attrs = Vec::from_iter(self.resolver.cstore().item_attrs_untracked(def_id, self.sess));\n+        let attrs = Vec::from_iter(\n+            self.resolver.cstore().item_attrs_untracked(def_id, self.resolver.sess()),\n+        );\n         let parent_scope = ParentScope::module(self.resolver.expect_module(def_id), self.resolver);\n         self.resolve_doc_links(doc_attrs(attrs.iter()), parent_scope);\n     }\n@@ -321,7 +321,7 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                         let field_def_ids = Vec::from_iter(\n                             self.resolver\n                                 .cstore()\n-                                .associated_item_def_ids_untracked(def_id, self.sess),\n+                                .associated_item_def_ids_untracked(def_id, self.resolver.sess()),\n                         );\n                         for field_def_id in field_def_ids {\n                             self.resolve_doc_links_extern_outer(field_def_id, scope_id);"}, {"sha": "4bdecdc1b79446302261626e67df86d9c77e6ad0", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -76,6 +76,7 @@\n     -Z                            llvm-plugins=val -- a list LLVM plugins to enable (space separated)\n     -Z                         llvm-time-trace=val -- generate JSON tracing data file from LLVM data (default: no)\n     -Z                         location-detail=val -- what location details should be tracked when using caller_location, either `none`, or a comma separated list of location details, for which valid options are `file`, `line`, and `column` (default: `file,line,column`)\n+    -Z                           log-backtrace=val -- add a backtrace along with logging\n     -Z                                      ls=val -- list the symbols defined by a library crate (default: no)\n     -Z                         macro-backtrace=val -- show macro backtraces (default: no)\n     -Z             maximal-hir-to-mir-coverage=val -- save as much information as possible about the correspondence between MIR and HIR as source scopes (default: no)"}, {"sha": "23f71520040080f22287b09941da4d838d3846a1", "filename": "tests/ui/associated-item/ambiguous-associated-type-with-generics.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.fixed?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+trait Trait<A> {}\n+\n+trait Assoc {\n+    type Ty;\n+}\n+\n+impl<A> Assoc for dyn Trait<A> {\n+    type Ty = i32;\n+}\n+\n+fn main() {\n+    let _x: <dyn Trait<i32> as Assoc>::Ty; //~ ERROR ambiguous associated type\n+}"}, {"sha": "9c26e339a449b59bf66560b5d7d5ddbe5f11d05a", "filename": "tests/ui/associated-item/ambiguous-associated-type-with-generics.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+trait Trait<A> {}\n+\n+trait Assoc {\n+    type Ty;\n+}\n+\n+impl<A> Assoc for dyn Trait<A> {\n+    type Ty = i32;\n+}\n+\n+fn main() {\n+    let _x: <dyn Trait<i32>>::Ty; //~ ERROR ambiguous associated type\n+}"}, {"sha": "97088b79fd67128a1f2e428d38ee290ce6061c9c", "filename": "tests/ui/associated-item/ambiguous-associated-type-with-generics.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fambiguous-associated-type-with-generics.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,9 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/ambiguous-associated-type-with-generics.rs:13:13\n+   |\n+LL |     let _x: <dyn Trait<i32>>::Ty;\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: use the fully-qualified path: `<dyn Trait<i32> as Assoc>::Ty`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0223`."}, {"sha": "d0c170620766c4d19a983e0f7dc8fa75d8a77e51", "filename": "tests/ui/associated-item/associated-item-duplicate-names-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -13,7 +13,7 @@ error[E0223]: ambiguous associated type\n   --> $DIR/associated-item-duplicate-names-3.rs:18:12\n    |\n LL |     let x: Baz::Bar = 5;\n-   |            ^^^^^^^^ help: use fully-qualified syntax: `<Baz as Trait>::Bar`\n+   |            ^^^^^^^^ help: use the fully-qualified path: `<Baz as Foo>::Bar`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "00856b55df5ece3ba2e995e921b61b1c3ad93d36", "filename": "tests/ui/associated-types/associated-types-in-ambiguous-context.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -2,31 +2,46 @@ error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:6:36\n    |\n LL | fn get<T:Get,U:Get>(x: T, y: U) -> Get::Value {}\n-   |                                    ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Get>::Value`\n+   |                                    ^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Get`, you could use the fully-qualified path\n+   |\n+LL | fn get<T:Get,U:Get>(x: T, y: U) -> <Example as Get>::Value {}\n+   |                                    ~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:20:17\n    |\n LL | trait Foo where Foo::Assoc: Bar {\n-   |                 ^^^^^^^^^^ help: use fully-qualified syntax: `<Self as Foo>::Assoc`\n+   |                 ^^^^^^^^^^ help: use the fully-qualified path: `<Self as Foo>::Assoc`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:25:10\n    |\n LL | type X = std::ops::Deref::Target;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Deref>::Target`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Deref`, you could use the fully-qualified path\n+   |\n+LL | type X = <Example as Deref>::Target;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:11:23\n    |\n LL |     fn grab(&self) -> Grab::Value;\n-   |                       ^^^^^^^^^^^ help: use fully-qualified syntax: `<Self as Grab>::Value`\n+   |                       ^^^^^^^^^^^ help: use the fully-qualified path: `<Self as Grab>::Value`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:14:22\n    |\n LL |     fn get(&self) -> Get::Value;\n-   |                      ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Get>::Value`\n+   |                      ^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Get`, you could use the fully-qualified path\n+   |\n+LL |     fn get(&self) -> <Example as Get>::Value;\n+   |                      ~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to 5 previous errors\n "}, {"sha": "3979d2001fc5957ae109d6e4bdd9f8b672a6b8b9", "filename": "tests/ui/attributes/log-backtrace.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fattributes%2Flog-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fattributes%2Flog-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Flog-backtrace.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,9 @@\n+// run-pass\n+//\n+// This test makes sure that log-backtrace option doesn't give a compilation error.\n+//\n+// dont-check-compiler-stdout\n+// dont-check-compiler-stderr\n+// rustc-env:RUSTC_LOG=info\n+// compile-flags: -Zlog-backtrace=rustc_metadata::creader\n+fn main() {}"}, {"sha": "1c69b07e3d4af0859656946d6094f3c2bb07e173", "filename": "tests/ui/chalkify/bugs/async.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -2,12 +2,21 @@\n // known-bug\n // unset-rustc-env:RUST_BACKTRACE\n // compile-flags:-Z trait-solver=chalk --edition=2021\n-// error-pattern:stack backtrace:\n+// error-pattern:internal compiler error\n // failure-status:101\n-// normalize-stderr-test \"note: .*\" -> \"\"\n-// normalize-stderr-test \"thread 'rustc' .*\" -> \"\"\n-// normalize-stderr-test \"  .*\\n\" -> \"\"\n // normalize-stderr-test \"DefId([^)]*)\" -> \"...\"\n+// normalize-stderr-test \"\\nerror: internal compiler error.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note:.*unexpectedly panicked.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"thread.*panicked.*\\n\" -> \"\"\n+// normalize-stderr-test \"stack backtrace:\\n\" -> \"\"\n+// normalize-stderr-test \"\\s\\d{1,}: .*\\n\" -> \"\"\n+// normalize-stderr-test \"\\s at .*\\n\" -> \"\"\n+// normalize-stderr-test \".*note: Some details.*\\n\" -> \"\"\n+// normalize-stderr-test \"\\n\\n[ ]*\\n\" -> \"\"\n+// normalize-stderr-test \"compiler/.*: projection\" -> \"projection\"\n \n fn main() -> () {}\n "}, {"sha": "d1508cb17001b4cf807bc3dcb3a0449f2854dd98", "filename": "tests/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1,29 +1,47 @@\n-error[E0277]: `[async fn body@$DIR/async.rs:14:29: 16:2]` is not a future\n-LL |LL | |LL | | }\n-\n-\n-error[E0277]: the size for values of type `<[async fn body@$DIR/async.rs:14:29: 16:2] as Future>::Output` cannot be known at compilation time\n-LL |LL | |LL | | }\n-\n-\n-error[E0277]: `[async fn body@$DIR/async.rs:14:29: 16:2]` is not a future\n+error[E0277]: `[async fn body@$DIR/async.rs:23:29: 25:2]` is not a future\n+  --> $DIR/async.rs:23:29\n+   |\n+LL |   async fn foo(x: u32) -> u32 {\n+   |  _____________________________-\n+LL | |     x\n+LL | | }\n+   | | ^\n+   | | |\n+   | |_`[async fn body@$DIR/async.rs:23:29: 25:2]` is not a future\n+   |   required by a bound introduced by this call\n+   |\n+   = help: the trait `Future` is not implemented for `[async fn body@$DIR/async.rs:23:29: 25:2]`\n+   = note: [async fn body@$DIR/async.rs:23:29: 25:2] must be a future or must implement `IntoFuture` to be awaited\n+note: required by a bound in `identity_future`\n+  --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n+\n+error[E0277]: the size for values of type `<[async fn body@$DIR/async.rs:23:29: 25:2] as Future>::Output` cannot be known at compilation time\n+  --> $DIR/async.rs:23:29\n+   |\n+LL |   async fn foo(x: u32) -> u32 {\n+   |  _____________________________^\n+LL | |     x\n+LL | | }\n+   | |_^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `<[async fn body@$DIR/async.rs:23:29: 25:2] as Future>::Output`\n+note: required by a bound in `identity_future`\n+  --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n+\n+error[E0277]: `[async fn body@$DIR/async.rs:23:29: 25:2]` is not a future\n+  --> $DIR/async.rs:23:25\n+   |\n LL | async fn foo(x: u32) -> u32 {\n-\n-error: internal compiler error: compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs:1114:25: projection clauses should be implied from elsewhere. obligation: `Obligation(predicate=Binder(ProjectionPredicate(AliasTy { substs: [[async fn body@$DIR/async.rs:14:29: 16:2]], def_id: ...), _use_mk_alias_ty_instead: () }, Term::Ty(u32)), []), depth=0)`\n+   |                         ^^^ `[async fn body@$DIR/async.rs:23:29: 25:2]` is not a future\n+   |\n+   = help: the trait `Future` is not implemented for `[async fn body@$DIR/async.rs:23:29: 25:2]`\n+   = note: [async fn body@$DIR/async.rs:23:29: 25:2] must be a future or must implement `IntoFuture` to be awaited\n+\n+error: internal compiler error: projection clauses should be implied from elsewhere. obligation: `Obligation(predicate=Binder(ProjectionPredicate(AliasTy { substs: [[async fn body@$DIR/async.rs:23:29: 25:2]], def_id: ...), _use_mk_alias_ty_instead: () }, Term::Ty(u32)), []), depth=0)`\n+  --> $DIR/async.rs:23:25\n+   |\n LL | async fn foo(x: u32) -> u32 {\n-\n-\n-stack backtrace:\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-query stack during panic:\n+   |                         ^^^query stack during panic:\n #0 [typeck] type-checking `foo`\n #1 [thir_body] building THIR for `foo`\n #2 [mir_built] building MIR for `foo`"}, {"sha": "55096e95df7e06cee280a39f5f477cf81a108c06", "filename": "tests/ui/did_you_mean/bad-assoc-ty.stderr", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -61,25 +61,45 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:1:10\n    |\n LL | type A = [u8; 4]::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<[u8; 4] as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `[u8; 4]`, you could use the fully-qualified path\n+   |\n+LL | type A = <[u8; 4] as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:5:10\n    |\n LL | type B = [u8]::AssocTy;\n-   |          ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<[u8] as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `[u8]`, you could use the fully-qualified path\n+   |\n+LL | type B = <[u8] as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:9:10\n    |\n LL | type C = (u8)::AssocTy;\n-   |          ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type C = <u8 as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:13:10\n    |\n LL | type D = (u8, u8)::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(u8, u8) as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `(u8, u8)`, you could use the fully-qualified path\n+   |\n+LL | type D = <(u8, u8) as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for type aliases\n   --> $DIR/bad-assoc-ty.rs:17:10\n@@ -91,13 +111,23 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:21:19\n    |\n LL | type F = &'static (u8)::AssocTy;\n-   |                   ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |                   ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type F = &'static <u8 as Example>::AssocTy;\n+   |                   ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:27:10\n    |\n LL | type G = dyn 'static + (Send)::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(dyn Send + 'static) as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `(dyn Send + 'static)`, you could use the fully-qualified path\n+   |\n+LL | type G = <(dyn Send + 'static) as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n warning: trait objects without an explicit `dyn` are deprecated\n   --> $DIR/bad-assoc-ty.rs:33:10\n@@ -117,24 +147,33 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:33:10\n    |\n LL | type H = Fn(u8) -> (u8)::Output;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(dyn Fn(u8) -> u8 + 'static) as Trait>::Output`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^ help: use the fully-qualified path: `<(dyn Fn(u8) -> u8 + 'static) as IntoFuture>::Output`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:39:19\n    |\n LL |     ($ty: ty) => ($ty::AssocTy);\n-   |                   ^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |                   ^^^^^^^^^^^^\n ...\n LL | type J = ty!(u8);\n    |          ------- in this macro invocation\n    |\n    = note: this error originates in the macro `ty` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL |     ($ty: ty) => (<u8 as Example>::AssocTy);\n+   |                   ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:46:10\n    |\n LL | type I = ty!()::AssocTy;\n-   |          ^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type I = <u8 as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/bad-assoc-ty.rs:51:13"}, {"sha": "2fe252de256650cf5b67b00bd1e0a28c7557572d", "filename": "tests/ui/error-codes/E0223.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Ferror-codes%2FE0223.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Ferror-codes%2FE0223.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0223.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1,4 +1,8 @@\n trait MyTrait { type X; }\n+struct MyStruct;\n+impl MyTrait for MyStruct {\n+    type X = ();\n+}\n \n fn main() {\n     let foo: MyTrait::X;"}, {"sha": "42945e42f6ea1c682884a60c3e92c671964a0dcc", "filename": "tests/ui/error-codes/E0223.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Ferror-codes%2FE0223.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Ferror-codes%2FE0223.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0223.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1,8 +1,8 @@\n error[E0223]: ambiguous associated type\n-  --> $DIR/E0223.rs:4:14\n+  --> $DIR/E0223.rs:8:14\n    |\n LL |     let foo: MyTrait::X;\n-   |              ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as MyTrait>::X`\n+   |              ^^^^^^^^^^ help: use the fully-qualified path: `<MyStruct as MyTrait>::X`\n \n error: aborting due to previous error\n "}, {"sha": "b3ff2ce5a7bfada2b3b20cdadd9dd86f013a2729", "filename": "tests/ui/impl-trait/impl_trait_projections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -11,7 +11,7 @@ fn path_parametrized_type_is_allowed() -> option::Option<impl Debug> {\n \n fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n //~^ ERROR `impl Trait` is not allowed in path parameters\n-//~^^ ERROR ambiguous associated type\n+//~| ERROR `impl Trait` is not allowed in path parameters\n     x.next().unwrap()\n }\n "}, {"sha": "4deb24731bc030b12c8ca24dc088ee11b3c13297", "filename": "tests/ui/impl-trait/impl_trait_projections.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -22,13 +22,12 @@ error[E0667]: `impl Trait` is not allowed in path parameters\n LL |     -> <dyn Iterator<Item = impl Debug> as Iterator>::Item\n    |                             ^^^^^^^^^^\n \n-error[E0223]: ambiguous associated type\n-  --> $DIR/impl_trait_projections.rs:12:50\n+error[E0667]: `impl Trait` is not allowed in path parameters\n+  --> $DIR/impl_trait_projections.rs:12:51\n    |\n LL | fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n-   |                                                  ^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<impl Iterator as Trait>::Item`\n+   |                                                   ^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0223, E0667.\n-For more information about an error, try `rustc --explain E0223`.\n+For more information about this error, try `rustc --explain E0667`."}, {"sha": "ebe07027d2fa1ba036fd2a950a02b388863f6699", "filename": "tests/ui/implied-bounds/impl-implied-bounds-compatibility-unnormalized.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1,8 +1,8 @@\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:5\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:31\n    |\n LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `()`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n@@ -14,3 +14,18 @@ LL | #![deny(implied_bounds_entailment)]\n \n error: aborting due to previous error\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:31\n+   |\n+LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `()`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:1:9\n+   |\n+LL | #![deny(implied_bounds_entailment)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "43d3e058ffeb3f10adc89c2b7a1968f9b781aff1", "filename": "tests/ui/implied-bounds/impl-implied-bounds-compatibility.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -1,8 +1,8 @@\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility.rs:14:5\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:35\n    |\n LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `&'b MessageListeners<'b>`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n@@ -14,3 +14,18 @@ LL | #![deny(implied_bounds_entailment)]\n \n error: aborting due to previous error\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:35\n+   |\n+LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `&'b MessageListeners<'b>`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/impl-implied-bounds-compatibility.rs:1:9\n+   |\n+LL | #![deny(implied_bounds_entailment)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "3a9f49ef167d692d6fe7feed84623e5c1b3a8f9e", "filename": "tests/ui/issues/issue-23073.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fissues%2Fissue-23073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fissues%2Fissue-23073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-23073.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/issue-23073.rs:6:17\n    |\n LL |     type FooT = <<Self as Bar>::Foo>::T;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<Self as Bar>::Foo as Trait>::T`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `T` implemented for `<Self as Bar>::Foo`, you could use the fully-qualified path\n+   |\n+LL |     type FooT = <<Self as Bar>::Foo as Example>::T;\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "70daf8a2f1a6475b2ed53dbaf7fba87283829b8d", "filename": "tests/ui/issues/issue-78622.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fissues%2Fissue-78622.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fissues%2Fissue-78622.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-78622.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/issue-78622.rs:5:5\n    |\n LL |     S::A::<f> {}\n-   |     ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |     ^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `A` implemented for `S`, you could use the fully-qualified path\n+   |\n+LL |     <S as Example>::A::<f> {}\n+   |     ~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "a19f4963c239bc6ef90f601ee534cf35ed31ef8b", "filename": "tests/ui/lint/bare-trait-objects-path.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Flint%2Fbare-trait-objects-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Flint%2Fbare-trait-objects-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fbare-trait-objects-path.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -16,7 +16,7 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bare-trait-objects-path.rs:23:12\n    |\n LL |     let _: Dyn::Ty;\n-   |            ^^^^^^^ help: use fully-qualified syntax: `<dyn Dyn as Trait>::Ty`\n+   |            ^^^^^^^ help: use the fully-qualified path: `<dyn Dyn as Assoc>::Ty`\n \n warning: trait objects without an explicit `dyn` are deprecated\n   --> $DIR/bare-trait-objects-path.rs:14:5"}, {"sha": "ad312a875e3961c30a606fd3696683f72fd4c322", "filename": "tests/ui/proc-macro/panic-abort.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fproc-macro%2Fpanic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fproc-macro%2Fpanic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fpanic-abort.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,4 @@\n+// error-pattern: building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic\n+// compile-flags: --crate-type proc-macro -Cpanic=abort\n+// force-host\n+// check-pass"}, {"sha": "a6e18614f8f06039991fc63bdb2affc6ceeaf5d1", "filename": "tests/ui/proc-macro/panic-abort.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fproc-macro%2Fpanic-abort.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fproc-macro%2Fpanic-abort.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fpanic-abort.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,4 @@\n+warning: building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic\n+\n+warning: 1 warning emitted\n+"}, {"sha": "b6cf19b8286cca19fd31427caa3ca5e6ce691a52", "filename": "tests/ui/qualified/qualified-path-params-2.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fqualified%2Fqualified-path-params-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fqualified%2Fqualified-path-params-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fqualified%2Fqualified-path-params-2.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/qualified-path-params-2.rs:18:10\n    |\n LL | type A = <S as Tr>::A::f<u8>;\n-   |          ^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<S as Tr>::A as Trait>::f`\n+   |          ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `f` implemented for `<S as Tr>::A`, you could use the fully-qualified path\n+   |\n+LL | type A = <<S as Tr>::A as Example>::f;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "d4d141fb06f39e600e0a8417d694d7ec2931323f", "filename": "tests/ui/resolve/issue-103202.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fresolve%2Fissue-103202.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fresolve%2Fissue-103202.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fissue-103202.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/issue-103202.rs:4:17\n    |\n LL |     fn f(self: &S::x) {}\n-   |                 ^^^^ help: use fully-qualified syntax: `<S as Trait>::x`\n+   |                 ^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `x` implemented for `S`, you could use the fully-qualified path\n+   |\n+LL |     fn f(self: &<S as Example>::x) {}\n+   |                 ~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "36372b644d6e171a18f033f6a74b0bc2d96fa247", "filename": "tests/ui/self/self-impl.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fself%2Fself-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fself%2Fself-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Fself-impl.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -2,13 +2,13 @@ error[E0223]: ambiguous associated type\n   --> $DIR/self-impl.rs:23:16\n    |\n LL |         let _: <Self>::Baz = true;\n-   |                ^^^^^^^^^^^ help: use fully-qualified syntax: `<Bar as Trait>::Baz`\n+   |                ^^^^^^^^^^^ help: use the fully-qualified path: `<Bar as Foo>::Baz`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/self-impl.rs:25:16\n    |\n LL |         let _: Self::Baz = true;\n-   |                ^^^^^^^^^ help: use fully-qualified syntax: `<Bar as Trait>::Baz`\n+   |                ^^^^^^^^^ help: use the fully-qualified path: `<Bar as Foo>::Baz`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ca5f0b7e21e7d4fb37c3e31d17f748305b63a0d2", "filename": "tests/ui/structs/struct-path-associated-type.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -48,19 +48,19 @@ error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:32:13\n    |\n LL |     let s = S::A {};\n-   |             ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |             ^^^^ help: use the fully-qualified path: `<S as Tr>::A`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:33:13\n    |\n LL |     let z = S::A::<u8> {};\n-   |             ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |             ^^^^ help: use the fully-qualified path: `<S as Tr>::A`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:35:9\n    |\n LL |         S::A {} => {}\n-   |         ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |         ^^^^ help: use the fully-qualified path: `<S as Tr>::A`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "78e48364bba001ec5bf7f1a4ba78dd9a444fa424", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,28 @@\n+//run-rustfix\n+#![allow(unused)]\n+\n+struct S;\n+impl S {\n+    fn foo(&mut self) {\n+        let x = |this: &Self, v: i32| {\n+            this.bar();\n+            this.hel();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        x(self, 1);\n+        x(self, 3);\n+    }\n+    fn bar(&self) {}\n+    fn hel(&self) {}\n+    fn qux(&mut self) {}\n+\n+    fn hello(&mut self) {\n+        let y = |this: &Self| {\n+            this.bar();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        y(self);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6d8a9ffc12d3938e7a04772f9a8df1897137b5bb", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,28 @@\n+//run-rustfix\n+#![allow(unused)]\n+\n+struct S;\n+impl S {\n+    fn foo(&mut self) {\n+        let x = |v: i32| {\n+            self.bar();\n+            self.hel();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        x(1);\n+        x(3);\n+    }\n+    fn bar(&self) {}\n+    fn hel(&self) {}\n+    fn qux(&mut self) {}\n+\n+    fn hello(&mut self) {\n+        let y = || {\n+            self.bar();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        y();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bc97d32ebb6e52e8a76347bc15a4cef75b17749a", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -0,0 +1,49 @@\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/issue-105761-suggest-self-for-closure.rs:11:9\n+   |\n+LL |         let x = |v: i32| {\n+   |                 -------- immutable borrow occurs here\n+LL |             self.bar();\n+   |             ---- first borrow occurs due to use of `self` in closure\n+...\n+LL |         self.qux();\n+   |         ^^^^^^^^^^ mutable borrow occurs here\n+LL |         x(1);\n+   |         - immutable borrow later used here\n+   |\n+help: try explicitly pass `&Self` into the Closure as an argument\n+   |\n+LL ~         let x = |this: &Self, v: i32| {\n+LL ~             this.bar();\n+LL ~             this.hel();\n+LL |         };\n+LL |         self.qux();\n+LL ~         x(self, 1);\n+LL ~         x(self, 3);\n+   |\n+\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/issue-105761-suggest-self-for-closure.rs:23:9\n+   |\n+LL |         let y = || {\n+   |                 -- immutable borrow occurs here\n+LL |             self.bar();\n+   |             ---- first borrow occurs due to use of `self` in closure\n+LL |         };\n+LL |         self.qux();\n+   |         ^^^^^^^^^^ mutable borrow occurs here\n+LL |         y();\n+   |         - immutable borrow later used here\n+   |\n+help: try explicitly pass `&Self` into the Closure as an argument\n+   |\n+LL ~         let y = |this: &Self| {\n+LL ~             this.bar();\n+LL |         };\n+LL |         self.qux();\n+LL ~         y(self);\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "b90ae051fb77675f1847cb8063b674661f8965fc", "filename": "tests/ui/suggestions/let-binding-init-expr-as-ty.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -21,7 +21,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/let-binding-init-expr-as-ty.rs:2:14\n    |\n LL |     let foo: i32::from_be(num);\n-   |              ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<i32 as Trait>::from_be`\n+   |              ^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `from_be` implemented for `i32`, you could use the fully-qualified path\n+   |\n+LL |     let foo: <i32 as Example>::from_be;\n+   |              ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to 3 previous errors\n "}, {"sha": "293cfbda86c4925b680463596a809cb5226438cc", "filename": "tests/ui/traits/item-privacy.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Ftraits%2Fitem-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Ftraits%2Fitem-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fitem-privacy.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -148,19 +148,24 @@ error[E0223]: ambiguous associated type\n   --> $DIR/item-privacy.rs:115:12\n    |\n LL |     let _: S::A;\n-   |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |            ^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `A` implemented for `S`, you could use the fully-qualified path\n+   |\n+LL |     let _: <S as Example>::A;\n+   |            ~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/item-privacy.rs:116:12\n    |\n LL |     let _: S::B;\n-   |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::B`\n+   |            ^^^^ help: use the fully-qualified path: `<S as assoc_ty::B>::B`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/item-privacy.rs:117:12\n    |\n LL |     let _: S::C;\n-   |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::C`\n+   |            ^^^^ help: use the fully-qualified path: `<S as assoc_ty::C>::C`\n \n error[E0624]: associated type `A` is private\n   --> $DIR/item-privacy.rs:119:12"}, {"sha": "72fccea8ae399f1b763a23756c0169210cdad7ed", "filename": "tests/ui/ufcs/ufcs-partially-resolved.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a11eb4f267ddfe4f00cb40bf94aef508c11e0862/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr?ref=a11eb4f267ddfe4f00cb40bf94aef508c11e0862", "patch": "@@ -205,7 +205,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/ufcs-partially-resolved.rs:36:12\n    |\n LL |     let _: <u8 as Tr>::Y::NN;\n-   |            ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<u8 as Tr>::Y as Trait>::NN`\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `NN` implemented for `<u8 as Tr>::Y`, you could use the fully-qualified path\n+   |\n+LL |     let _: <<u8 as Tr>::Y as Example>::NN;\n+   |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0599]: no associated item named `NN` found for type `u16` in the current scope\n   --> $DIR/ufcs-partially-resolved.rs:38:20"}]}