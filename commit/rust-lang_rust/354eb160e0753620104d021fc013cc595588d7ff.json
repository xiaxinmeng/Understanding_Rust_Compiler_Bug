{"sha": "354eb160e0753620104d021fc013cc595588d7ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NGViMTYwZTA3NTM2MjAxMDRkMDIxZmMwMTNjYzU5NTU4OGQ3ZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-20T02:27:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-20T02:27:16Z"}, "message": "Auto merge of #45312 - theotherjimmy:refactor-ensure, r=michaelwoerister\n\nRefactor `ensure` and `try_get_with`\n\nThere was a bit of code shared between `try_get_with` and `ensure`, after I\nadded `ensure`. I refactored that shared code into a query-agnostic method\ncalled `read_node_index`.\n\nThe new method `read_node_index` will attempt to find the node\nindex (`DepNodeIndex`) of a query. When `read_node_index` finds the\n`DepNodeIndex`, it marks the current query as a reader of the node it's\nrequesting the index of.\n\nThis is used by `try_get_with` and `ensure` as it elides the unimportant (to\nthem) details of if the query is invalidated by previous changed computation (Red)\nor new and if they had to mark the query green. For both `try_get_with` and\n`ensure`, they just need to know if they can lookup the results or have to\nreevaluate.\n\n@nikomatsakis this is the [refactor we discussed](https://github.com/rust-lang/rust/pull/45228#discussion_r144577392) in the comment thread of #45228", "tree": {"sha": "b1950288a3f5b435bf15a6d32280d82f843c9147", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1950288a3f5b435bf15a6d32280d82f843c9147"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/354eb160e0753620104d021fc013cc595588d7ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/354eb160e0753620104d021fc013cc595588d7ff", "html_url": "https://github.com/rust-lang/rust/commit/354eb160e0753620104d021fc013cc595588d7ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/354eb160e0753620104d021fc013cc595588d7ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a651106ad0c8395fcfbd62ef58de9e36376252e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a651106ad0c8395fcfbd62ef58de9e36376252e0", "html_url": "https://github.com/rust-lang/rust/commit/a651106ad0c8395fcfbd62ef58de9e36376252e0"}, {"sha": "229bee3c38376b99d7d483e20fa97ec774e8a2bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/229bee3c38376b99d7d483e20fa97ec774e8a2bd", "html_url": "https://github.com/rust-lang/rust/commit/229bee3c38376b99d7d483e20fa97ec774e8a2bd"}], "stats": {"total": 93, "additions": 44, "deletions": 49}, "files": [{"sha": "5f93c3de336cc47b7b1626b4e333d82079b622e9", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 44, "deletions": 49, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/354eb160e0753620104d021fc013cc595588d7ff/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354eb160e0753620104d021fc013cc595588d7ff/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=354eb160e0753620104d021fc013cc595588d7ff", "patch": "@@ -12,7 +12,7 @@\n //! that generate the actual methods on tcx which find and execute the\n //! provider, manage the caches, and so forth.\n \n-use dep_graph::{DepNodeIndex, DepNode, DepKind};\n+use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::{Diagnostic, DiagnosticBuilder};\n use ty::{TyCtxt};\n use ty::maps::Query; // NB: actually generated by the macros in this file\n@@ -133,6 +133,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         Ok(result)\n     }\n+\n+    /// Try to read a node index for the node dep_node.\n+    /// A node will have an index, when it's already been marked green, or when we can mark it\n+    /// green. This function will mark the current task as a reader of the specified node, when\n+    /// the a node index can be found for that node.\n+    pub(super) fn try_mark_green_and_read(self, dep_node: &DepNode) -> Option<DepNodeIndex> {\n+        match self.dep_graph.node_color(dep_node) {\n+            Some(DepNodeColor::Green(dep_node_index)) => {\n+                self.dep_graph.read_index(dep_node_index);\n+                Some(dep_node_index)\n+            }\n+            Some(DepNodeColor::Red) => {\n+                None\n+            }\n+            None => {\n+                // try_mark_green (called below) will panic when full incremental\n+                // compilation is disabled. If that's the case, we can't try to mark nodes\n+                // as green anyway, so we can safely return None here.\n+                if !self.dep_graph.is_fully_enabled() {\n+                    return None;\n+                }\n+                match self.dep_graph.try_mark_green(self, &dep_node) {\n+                    Some(dep_node_index) => {\n+                        debug_assert!(self.dep_graph.is_green(dep_node_index));\n+                        self.dep_graph.read_index(dep_node_index);\n+                        Some(dep_node_index)\n+                    }\n+                    None => {\n+                        None\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n // If enabled, send a message to the profile-queries thread\n@@ -309,25 +343,8 @@ macro_rules! define_maps {\n                 }\n \n                 if !dep_node.kind.is_input() {\n-                    use dep_graph::DepNodeColor;\n-                    if let Some(DepNodeColor::Green(dep_node_index)) = tcx.dep_graph\n-                                                                          .node_color(&dep_node) {\n+                    if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n                         profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                        return Self::load_from_disk_and_cache_in_memory(tcx,\n-                                                                        key,\n-                                                                        span,\n-                                                                        dep_node_index)\n-                    }\n-\n-                    debug!(\"ty::queries::{}::try_get_with(key={:?}) - running try_mark_green\",\n-                           stringify!($name),\n-                           key);\n-\n-                    if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n-                        debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n-                        profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        tcx.dep_graph.read_index(dep_node_index);\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n                                                                         key,\n                                                                         span,\n@@ -357,36 +374,14 @@ macro_rules! define_maps {\n                 // Ensuring an \"input\" or anonymous query makes no sense\n                 assert!(!dep_node.kind.is_anon());\n                 assert!(!dep_node.kind.is_input());\n-                use dep_graph::DepNodeColor;\n-                match tcx.dep_graph.node_color(&dep_node) {\n-                    Some(DepNodeColor::Green(dep_node_index)) => {\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                    }\n-                    Some(DepNodeColor::Red) => {\n-                        // A DepNodeColor::Red DepNode means that this query was executed\n-                        // before. We can not call `dep_graph.read()` here as we don't have\n-                        // the DepNodeIndex. Instead, We call the query again to issue the\n-                        // appropriate `dep_graph.read()` call. The performance cost this\n-                        // introduces should be negligible as we'll immediately hit the\n-                        // in-memory cache.\n-                        let _ = tcx.$name(key);\n-                    }\n-                    None => {\n-                        // Huh\n-                        if !tcx.dep_graph.is_fully_enabled() {\n-                            let _ = tcx.$name(key);\n-                            return;\n-                        }\n-                        match tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n-                            Some(dep_node_index) => {\n-                                debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n-                                tcx.dep_graph.read_index(dep_node_index);\n-                            }\n-                            None => {\n-                                let _ = tcx.$name(key);\n-                            }\n-                        }\n-                    }\n+                if tcx.try_mark_green_and_read(&dep_node).is_none() {\n+                    // A None return from `try_mark_green_and_read` means that this is either\n+                    // a new dep node or that the dep node has already been marked red.\n+                    // Either way, we can't call `dep_graph.read()` as we don't have the\n+                    // DepNodeIndex. We must invoke the query itself. The performance cost\n+                    // this introduces should be negligible as we'll immediately hit the\n+                    // in-memory cache, or another query down the line will.\n+                    let _ = tcx.$name(key);\n                 }\n             }\n "}]}