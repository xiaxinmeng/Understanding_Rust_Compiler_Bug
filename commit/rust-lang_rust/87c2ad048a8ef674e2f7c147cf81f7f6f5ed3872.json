{"sha": "87c2ad048a8ef674e2f7c147cf81f7f6f5ed3872", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YzJhZDA0OGE4ZWY2NzRlMmY3YzE0N2NmODFmN2Y2ZjVlZDM4NzI=", "commit": {"author": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2017-12-21T13:25:32Z"}, "committer": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2018-02-28T15:33:14Z"}, "message": "default WF: Leverage type substitution, less workarounding\n\n`Predicate` is `TypeFoldable`, use that. Be less clever with the\nworkaround.", "tree": {"sha": "501749b798d975cb32bbd17ae65cff27277a7aca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/501749b798d975cb32bbd17ae65cff27277a7aca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87c2ad048a8ef674e2f7c147cf81f7f6f5ed3872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87c2ad048a8ef674e2f7c147cf81f7f6f5ed3872", "html_url": "https://github.com/rust-lang/rust/commit/87c2ad048a8ef674e2f7c147cf81f7f6f5ed3872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87c2ad048a8ef674e2f7c147cf81f7f6f5ed3872/comments", "author": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6bb32c9cc95a21835c81baa6f531ce38d67fbde", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6bb32c9cc95a21835c81baa6f531ce38d67fbde", "html_url": "https://github.com/rust-lang/rust/commit/a6bb32c9cc95a21835c81baa6f531ce38d67fbde"}], "stats": {"total": 111, "additions": 31, "deletions": 80}, "files": [{"sha": "2b004eb53c81e536e93989cf01cc3c245d6c1e5a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 31, "deletions": 80, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/87c2ad048a8ef674e2f7c147cf81f7f6f5ed3872/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c2ad048a8ef674e2f7c147cf81f7f6f5ed3872/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=87c2ad048a8ef674e2f7c147cf81f7f6f5ed3872", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let trait_def_id = self.tcx.hir.local_def_id(item.id);\n         \n         self.for_item(item).with_fcx(|fcx, _| {\n-            self.check_where_clauses(fcx, item.span, trait_def_id);\n+            self.check_trait_where_clauses(fcx, item.span, trait_def_id);\n             vec![]\n         });\n     }\n@@ -350,41 +350,46 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         });\n     }\n \n-    /// Checks where clauses and inline bounds.\n+    /// Checks where clauses and inline bounds that are declared on def_id.\n     fn check_where_clauses<'fcx, 'tcx>(&mut self,\n                                        fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                        span: Span,\n-                                       def_id: DefId)\n+                                       def_id: DefId) {\n+        self.inner_check_where_clauses(fcx, span, def_id, false)\n+    }\n+\n+    fn check_trait_where_clauses<'fcx, 'tcx>(&mut self,\n+                                       fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                       span: Span,\n+                                       def_id: DefId) {\n+        self.inner_check_where_clauses(fcx, span, def_id, true)\n+    }\n+\n+    /// Checks where clauses and inline bounds that are declared on def_id.\n+    fn inner_check_where_clauses<'fcx, 'tcx>(&mut self,\n+                                       fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                       span: Span,\n+                                       def_id: DefId,\n+                                       is_trait: bool)\n     {\n         use ty::subst::Subst;\n-        use ty::Predicate;\n+        use rustc::ty::TypeFoldable;\n \n         let generics = self.tcx.generics_of(def_id);\n-        let defaults = generics.types.iter().filter_map(|p| match p.has_default {\n-                                                                true => Some(p.def_id),\n-                                                                false => None,\n-                                                        });\n+        let defaulted_params = generics.types.iter()\n+                                             .filter(|def| def.has_default &&\n+                                                     def.index >= generics.parent_count() as u32);\n         // Defaults must be well-formed.\n-        for d in defaults {\n+        for d in defaulted_params.map(|p| p.def_id) {\n             fcx.register_wf_obligation(fcx.tcx.type_of(d), fcx.tcx.def_span(d), self.code.clone());\n         }\n-\n         // Check that each default fulfills the bounds on it's parameter.\n         // We go over each predicate and duplicate it, substituting defaults in the self type.\n         let mut predicates = fcx.tcx.predicates_of(def_id);\n         let mut default_predicates = Vec::new();\n-        for pred in &predicates.predicates {\n-            let mut self_ty = match pred {\n-                Predicate::Trait(trait_pred) => trait_pred.skip_binder().self_ty(),\n-                Predicate::TypeOutlives(outlives_pred) => (outlives_pred.0).0,\n-                Predicate::Projection(proj_pred) => {\n-                    fcx.tcx.mk_ty(ty::TyProjection(proj_pred.skip_binder().projection_ty))\n-                }\n-                // Lifetime params can't have defaults.\n-                Predicate::RegionOutlives(..) => continue,\n-                _ => bug!(\"Predicate {:?} not supported in where clauses.\", pred)\n-            };\n-\n+        // In `trait Trait : Super` predicates as `Self: Trait` and `Self: Super` are a problem.\n+        // Therefore we skip such predicates. This means we check less than we could.\n+        for pred in predicates.predicates.iter().filter(|p| !(is_trait && p.has_self_ty())) {\n             let mut skip = false;\n             let mut no_default = true;\n             let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n@@ -398,42 +403,11 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                     no_default = false;\n                     // Has a default, use it in the substitution.\n                     let default_ty = fcx.tcx.type_of(def.def_id);\n-                    // Skip `Self : Self` in traits, it's problematic.\n-                    // This means we probably check less than we could.\n-                    let should_skip = match self_ty.sty {\n-                        ty::TyParam(ref p) => {\n-                            // lhs is Self && rhs is Self\n-                            p.is_self() && match pred {\n-                                Predicate::Trait(p) => p.def_id() == def_id,\n-                                Predicate::TypeOutlives(_) => false,\n-                                _ => bug!(\"Unexpected predicate {:?}\", pred)\n-                            }\n-                        }\n-                        ty::TyProjection(ref proj) => {\n-                            let mut projection = proj;\n-                            let mut next_typ = &projection.substs[0].as_type().unwrap().sty;\n-                            // Dig through projections.\n-                            while let ty::TyProjection(ref proj) = next_typ {\n-                                projection = proj;\n-                                next_typ = &projection.substs[0].as_type().unwrap().sty;\n-                            }\n-                            let lhs_is_self = match next_typ {\n-                                ty::TyParam(ref p) => p.is_self(),\n-                                _ => false\n-                            };\n-                            let rhs = fcx.tcx.associated_item(projection.item_def_id)\n-                                                     .container\n-                                                     .assert_trait();\n-                            lhs_is_self && rhs == def_id\n-                        }\n-                        _ => false\n-                    };\n-                    skip = skip || should_skip;\n \n-                   match default_ty.sty {\n+                    match default_ty.sty {\n                         // Skip `Self: Sized` when `Self` is the default. Needed in traits.\n-                        ty::TyParam(ref p) if p.is_self() => {\n-                            if let Predicate::Trait(p) = pred {\n+                        ty::TyParam(ref p) if is_trait && p.is_self() => {\n+                            if let ty::Predicate::Trait(p) = pred {\n                                 if Some(p.def_id()) == fcx.tcx.lang_items().sized_trait() {\n                                     skip = true;\n                                 }\n@@ -449,30 +423,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 continue;\n             }\n \n-            self_ty = self_ty.subst(fcx.tcx, substs);\n-            default_predicates.push(match pred {\n-                Predicate::Trait(trait_pred) => {\n-                    let mut substs = trait_pred.skip_binder().trait_ref.substs.to_vec();\n-                    substs[0] = self_ty.into();\n-                    let substs = fcx.tcx.intern_substs(&substs);\n-                    let trait_ref = ty::Binder(ty::TraitRef::new(trait_pred.def_id(), substs));\n-                    Predicate::Trait(trait_ref.to_poly_trait_predicate())\n-                }\n-                Predicate::TypeOutlives(pred) => {\n-                    Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(self_ty, (pred.0).1)))\n-                }\n-                Predicate::Projection(proj_pred) => {\n-                    let projection_ty = match self_ty.sty {\n-                        ty::TyProjection(proj_ty) => proj_ty,\n-                        _ => bug!(\"self_ty not projection for projection predicate.\")\n-                    };\n-                    Predicate::Projection(ty::Binder(ty::ProjectionPredicate {\n-                                                        projection_ty,\n-                                                        ty: proj_pred.ty().skip_binder()\n-                                                    }))\n-                }\n-                _ => bug!(\"Predicate {:?} not supported for type params.\", pred)\n-            });\n+            default_predicates.push(pred.subst(fcx.tcx, substs));\n         }\n \n         predicates.predicates.extend(default_predicates);"}]}