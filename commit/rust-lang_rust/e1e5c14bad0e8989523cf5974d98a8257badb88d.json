{"sha": "e1e5c14bad0e8989523cf5974d98a8257badb88d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZTVjMTRiYWQwZTg5ODk1MjNjZjU5NzRkOThhODI1N2JhZGI4OGQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-31T09:02:45Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-05T04:52:48Z"}, "message": "In `Parser` and `ExtCtxt`, replace fields `filename` and `mod_path_stack`\nwith a single field `directory: PathBuf`.", "tree": {"sha": "9bebb99dc8f3063baa1b085a035fe4b057866753", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bebb99dc8f3063baa1b085a035fe4b057866753"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1e5c14bad0e8989523cf5974d98a8257badb88d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1e5c14bad0e8989523cf5974d98a8257badb88d", "html_url": "https://github.com/rust-lang/rust/commit/e1e5c14bad0e8989523cf5974d98a8257badb88d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1e5c14bad0e8989523cf5974d98a8257badb88d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86995dc8c56b3c2923dff8a4bb79fed7c60a4396", "url": "https://api.github.com/repos/rust-lang/rust/commits/86995dc8c56b3c2923dff8a4bb79fed7c60a4396", "html_url": "https://github.com/rust-lang/rust/commit/86995dc8c56b3c2923dff8a4bb79fed7c60a4396"}], "stats": {"total": 95, "additions": 38, "deletions": 57}, "files": [{"sha": "b2e4aeabd9531662d610e7908d12a44033e63e9c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1e5c14bad0e8989523cf5974d98a8257badb88d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1e5c14bad0e8989523cf5974d98a8257badb88d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e1e5c14bad0e8989523cf5974d98a8257badb88d", "patch": "@@ -30,6 +30,7 @@ use fold::Folder;\n use feature_gate;\n \n use std::collections::{HashMap, HashSet};\n+use std::path::PathBuf;\n use std::rc::Rc;\n use tokenstream;\n \n@@ -602,8 +603,7 @@ pub struct ExtCtxt<'a> {\n     pub derive_modes: HashMap<InternedString, Box<MultiItemModifier>>,\n     pub recursion_count: usize,\n \n-    pub filename: Option<String>,\n-    pub mod_path_stack: Vec<InternedString>,\n+    pub directory: PathBuf,\n     pub in_block: bool,\n }\n \n@@ -626,8 +626,7 @@ impl<'a> ExtCtxt<'a> {\n             derive_modes: HashMap::new(),\n             recursion_count: 0,\n \n-            filename: None,\n-            mod_path_stack: Vec::new(),\n+            directory: PathBuf::new(),\n             in_block: false,\n         }\n     }"}, {"sha": "5c548533e937f6f12c7dd4c6d458fd9e779ddaec", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e1e5c14bad0e8989523cf5974d98a8257badb88d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1e5c14bad0e8989523cf5974d98a8257badb88d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e1e5c14bad0e8989523cf5974d98a8257badb88d", "patch": "@@ -28,6 +28,8 @@ use visit;\n use visit::Visitor;\n use std_inject;\n \n+use std::path::PathBuf;\n+\n // A trait for AST nodes and AST node lists into which macro invocations may expand.\n trait MacroGenerable: Sized {\n     // Expand the given MacResult using its appropriate `make_*` method.\n@@ -566,7 +568,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_crate(&mut self, c: Crate) -> Crate {\n-        self.cx.filename = Some(self.cx.parse_sess.codemap().span_to_filename(c.span));\n+        let mut directory = PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(c.span));\n+        directory.pop();\n+        self.cx.directory = directory;\n         noop_fold_crate(c, self)\n     }\n \n@@ -591,18 +595,22 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         let result;\n         if let ast::ItemKind::Mod(ast::Mod { inner, .. }) = item.node {\n             if item.span.contains(inner) {\n-                self.push_mod_path(item.ident, &item.attrs);\n+                let directory = self.cx.directory.clone();\n+                self.cx.directory.push(&*{\n+                    ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n+                        .unwrap_or(item.ident.name.as_str())\n+                });\n                 result = expand_item(item, self);\n-                self.pop_mod_path();\n+                self.cx.directory = directory;\n             } else {\n-                let filename = if inner != syntax_pos::DUMMY_SP {\n-                    Some(self.cx.parse_sess.codemap().span_to_filename(inner))\n-                } else { None };\n-                let orig_filename = replace(&mut self.cx.filename, filename);\n-                let orig_mod_path_stack = replace(&mut self.cx.mod_path_stack, Vec::new());\n+                let mut directory = match inner {\n+                    syntax_pos::DUMMY_SP => PathBuf::new(),\n+                    _ => PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner)),\n+                };\n+                directory.pop();\n+                let directory = replace(&mut self.cx.directory, directory);\n                 result = expand_item(item, self);\n-                self.cx.filename = orig_filename;\n-                self.cx.mod_path_stack = orig_mod_path_stack;\n+                self.cx.directory = directory;\n             }\n         } else {\n             result = expand_item(item, self);\n@@ -636,21 +644,6 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> MacroExpander<'a, 'b> {\n-    fn push_mod_path(&mut self, id: Ident, attrs: &[ast::Attribute]) {\n-        let default_path = id.name.as_str();\n-        let file_path = match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            Some(d) => d,\n-            None => default_path,\n-        };\n-        self.cx.mod_path_stack.push(file_path)\n-    }\n-\n-    fn pop_mod_path(&mut self) {\n-        self.cx.mod_path_stack.pop().unwrap();\n-    }\n-}\n-\n pub struct ExpansionConfig<'feat> {\n     pub crate_name: String,\n     pub features: Option<&'feat Features>,"}, {"sha": "a4be84dfbf02f44e9bfc54ca553c99c3a7db84b8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1e5c14bad0e8989523cf5974d98a8257badb88d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1e5c14bad0e8989523cf5974d98a8257badb88d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e1e5c14bad0e8989523cf5974d98a8257badb88d", "patch": "@@ -211,8 +211,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            imported_from,\n                                            rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n-                p.filename = cx.filename.clone();\n-                p.mod_path_stack = cx.mod_path_stack.clone();\n+                p.directory = cx.directory.clone();\n                 p.restrictions = match cx.in_block {\n                     true => Restrictions::NO_NONINLINE_MOD,\n                     false => Restrictions::empty(),"}, {"sha": "6a0e40edded59ab09bc935239209db5c1a64872f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e1e5c14bad0e8989523cf5974d98a8257badb88d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1e5c14bad0e8989523cf5974d98a8257badb88d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e1e5c14bad0e8989523cf5974d98a8257badb88d", "patch": "@@ -264,8 +264,7 @@ pub struct Parser<'a> {\n     /// extra detail when the same error is seen twice\n     pub obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    pub filename: Option<String>,\n-    pub mod_path_stack: Vec<InternedString>,\n+    pub directory: PathBuf,\n     /// Stack of open delimiters and their spans. Used for error message.\n     pub open_braces: Vec<(token::DelimToken, Span)>,\n     /// Flag if this parser \"owns\" the directory that it is currently parsing\n@@ -346,9 +345,11 @@ impl<'a> Parser<'a> {\n     {\n         let tok0 = rdr.real_token();\n         let span = tok0.sp;\n-        let filename = if span != syntax_pos::DUMMY_SP {\n-            Some(sess.codemap().span_to_filename(span))\n-        } else { None };\n+        let mut directory = match span {\n+            syntax_pos::DUMMY_SP => PathBuf::new(),\n+            _ => PathBuf::from(sess.codemap().span_to_filename(span)),\n+        };\n+        directory.pop();\n         let placeholder = TokenAndSpan {\n             tok: token::Underscore,\n             sp: span,\n@@ -377,8 +378,7 @@ impl<'a> Parser<'a> {\n             quote_depth: 0,\n             parsing_token_tree: false,\n             obsolete_set: HashSet::new(),\n-            mod_path_stack: Vec::new(),\n-            filename: filename,\n+            directory: directory,\n             open_braces: Vec::new(),\n             owns_directory: true,\n             root_module_name: None,\n@@ -5306,27 +5306,24 @@ impl<'a> Parser<'a> {\n             let (m, attrs) = self.eval_src_mod(id, &outer_attrs, id_span)?;\n             Ok((id, m, Some(attrs)))\n         } else {\n-            self.push_mod_path(id, &outer_attrs);\n+            let directory = self.directory.clone();\n+            self.push_directory(id, &outer_attrs);\n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mod_inner_lo = self.span.lo;\n             let attrs = self.parse_inner_attributes()?;\n             let m = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n-            self.pop_mod_path();\n+            self.directory = directory;\n             Ok((id, ItemKind::Mod(m), Some(attrs)))\n         }\n     }\n \n-    fn push_mod_path(&mut self, id: Ident, attrs: &[Attribute]) {\n+    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n         let default_path = self.id_to_interned_str(id);\n         let file_path = match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n             Some(d) => d,\n             None => default_path,\n         };\n-        self.mod_path_stack.push(file_path)\n-    }\n-\n-    fn pop_mod_path(&mut self) {\n-        self.mod_path_stack.pop().unwrap();\n+        self.directory.push(&*file_path)\n     }\n \n     pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n@@ -5374,18 +5371,11 @@ impl<'a> Parser<'a> {\n                    id: ast::Ident,\n                    outer_attrs: &[ast::Attribute],\n                    id_sp: Span) -> PResult<'a, ModulePathSuccess> {\n-        let mut prefix = PathBuf::from(self.filename.as_ref().unwrap());\n-        prefix.pop();\n-        let mut dir_path = prefix;\n-        for part in &self.mod_path_stack {\n-            dir_path.push(&**part);\n-        }\n-\n-        if let Some(p) = Parser::submod_path_from_attr(outer_attrs, &dir_path) {\n+        if let Some(p) = Parser::submod_path_from_attr(outer_attrs, &self.directory) {\n             return Ok(ModulePathSuccess { path: p, owns_directory: true });\n         }\n \n-        let paths = Parser::default_submod_path(id, &dir_path, self.sess.codemap());\n+        let paths = Parser::default_submod_path(id, &self.directory, self.sess.codemap());\n \n         if self.restrictions.contains(Restrictions::NO_NONINLINE_MOD) {\n             let msg =\n@@ -5400,8 +5390,8 @@ impl<'a> Parser<'a> {\n         } else if !self.owns_directory {\n             let mut err = self.diagnostic().struct_span_err(id_sp,\n                 \"cannot declare a new module at this location\");\n-            let this_module = match self.mod_path_stack.last() {\n-                Some(name) => name.to_string(),\n+            let this_module = match self.directory.file_name() {\n+                Some(file_name) => file_name.to_str().unwrap().to_owned(),\n                 None => self.root_module_name.as_ref().unwrap().clone(),\n             };\n             err.span_note(id_sp,"}]}