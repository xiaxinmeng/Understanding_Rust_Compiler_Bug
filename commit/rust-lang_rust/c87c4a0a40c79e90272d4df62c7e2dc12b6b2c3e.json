{"sha": "c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4N2M0YTBhNDBjNzllOTAyNzJkNGRmNjJjN2UyZGMxMmI2YjJjM2U=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-13T12:02:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-13T12:02:59Z"}, "message": "Merge #4700\n\n4700: Add top level keywords completion r=matklad a=mcrakhman\n\nThis fixes the following issue: https://github.com/rust-analyzer/rust-analyzer/issues/4566. \r\n\r\nAlso added simple logic which filters the keywords which can be used with unsafe on the top level.   \n\nCo-authored-by: Mikhail Rakhmanov <rakhmanov.m@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "183636906100ec281f502a328a93558244ae3988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/183636906100ec281f502a328a93558244ae3988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe5MBzCRBK7hj4Ov3rIwAAdHIIACH/G742vkCKUyeo7LvHRt8t\nJK51vvKOsGTzf40UAQAz82F4ZPbamHg1RqmOqCtApjqP4zK1yrHLmZm63e+e9ZY1\n7fKNqGTiJv8Zz17mCAbVnfgGTkFjVtuMEnO9eFmyVYR4ATKnPpHWGEImk6BqLHpT\nfJt1BJL1JNxbVq5E5YfFupCrAJHO/gN9S8QwVBP6MDM+CyepXKskdR18owlMNbps\nBpLL2qwGgiJRKCHzifBef+RpjUka2P+axMRxz00fyTPceDs5fijGh5e+Tw4WQPLy\ntO3gjB0V016y2xv1RLBkuJdPWJLA4VPbqSqEDMZd4OOmE5+Hrxk21B5jXDe77lk=\n=EJj1\n-----END PGP SIGNATURE-----\n", "payload": "tree 183636906100ec281f502a328a93558244ae3988\nparent 1c841c8a98040867edbb0a7d41381db9378ee3c2\nparent b99b4953c9a4791f7f39ab208a1842086ad0f04c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592049779 +0000\ncommitter GitHub <noreply@github.com> 1592049779 +0000\n\nMerge #4700\n\n4700: Add top level keywords completion r=matklad a=mcrakhman\n\nThis fixes the following issue: https://github.com/rust-analyzer/rust-analyzer/issues/4566. \r\n\r\nAlso added simple logic which filters the keywords which can be used with unsafe on the top level.   \n\nCo-authored-by: Mikhail Rakhmanov <rakhmanov.m@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "html_url": "https://github.com/rust-lang/rust/commit/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c841c8a98040867edbb0a7d41381db9378ee3c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c841c8a98040867edbb0a7d41381db9378ee3c2", "html_url": "https://github.com/rust-lang/rust/commit/1c841c8a98040867edbb0a7d41381db9378ee3c2"}, {"sha": "b99b4953c9a4791f7f39ab208a1842086ad0f04c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b99b4953c9a4791f7f39ab208a1842086ad0f04c", "html_url": "https://github.com/rust-lang/rust/commit/b99b4953c9a4791f7f39ab208a1842086ad0f04c"}], "stats": {"total": 1258, "additions": 618, "deletions": 640}, "files": [{"sha": "e1fcf379d76e54829d09c164e0dffe9deff6bcfb", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "patch": "@@ -15,6 +15,7 @@ mod complete_unqualified_path;\n mod complete_postfix;\n mod complete_macro_in_item_position;\n mod complete_trait_impl;\n+mod patterns;\n #[cfg(test)]\n mod test_utils;\n "}, {"sha": "b2f621a119c7e01578f333c9f568c73ab65fda68", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 306, "deletions": 634, "changes": 940, "blob_url": "https://github.com/rust-lang/rust/blob/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "patch": "@@ -1,11 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::{\n-    ast::{self, LoopBodyOwner},\n-    match_ast, AstNode,\n-    SyntaxKind::*,\n-    SyntaxToken,\n-};\n+use ra_syntax::ast;\n \n use crate::completion::{\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n@@ -41,68 +36,122 @@ pub(super) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n     }\n }\n \n-fn keyword(ctx: &CompletionContext, kw: &str, snippet: &str) -> CompletionItem {\n-    let res = CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), kw)\n-        .kind(CompletionItemKind::Keyword);\n-\n-    match ctx.config.snippet_cap {\n-        Some(cap) => res.insert_snippet(cap, snippet),\n-        _ => res.insert_text(if snippet.contains('$') { kw } else { snippet }),\n+pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n+    let has_trait_or_impl_parent = ctx.has_impl_parent || ctx.has_trait_parent;\n+    if ctx.trait_as_prev_sibling || ctx.impl_as_prev_sibling {\n+        add_keyword(ctx, acc, \"where\", \"where \");\n+        return;\n     }\n-    .build()\n-}\n+    if ctx.unsafe_is_prev {\n+        if ctx.has_item_list_or_source_file_parent || ctx.block_expr_parent {\n+            add_keyword(ctx, acc, \"fn\", \"fn $0() {}\")\n+        }\n+\n+        if (ctx.has_item_list_or_source_file_parent && !has_trait_or_impl_parent)\n+            || ctx.block_expr_parent\n+        {\n+            add_keyword(ctx, acc, \"trait\", \"trait $0 {}\");\n+            add_keyword(ctx, acc, \"impl\", \"impl $0 {}\");\n+        }\n \n-pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_trivial_path {\n         return;\n     }\n+    if ctx.has_item_list_or_source_file_parent || ctx.block_expr_parent {\n+        add_keyword(ctx, acc, \"fn\", \"fn $0() {}\");\n+    }\n+    if (ctx.has_item_list_or_source_file_parent && !has_trait_or_impl_parent)\n+        || ctx.block_expr_parent\n+    {\n+        add_keyword(ctx, acc, \"use\", \"use \");\n+        add_keyword(ctx, acc, \"impl\", \"impl $0 {}\");\n+        add_keyword(ctx, acc, \"trait\", \"trait $0 {}\");\n+    }\n \n-    let fn_def = match &ctx.function_syntax {\n-        Some(it) => it,\n-        None => return,\n-    };\n-    acc.add(keyword(ctx, \"if\", \"if $0 {}\"));\n-    acc.add(keyword(ctx, \"match\", \"match $0 {}\"));\n-    acc.add(keyword(ctx, \"while\", \"while $0 {}\"));\n-    acc.add(keyword(ctx, \"loop\", \"loop {$0}\"));\n+    if ctx.has_item_list_or_source_file_parent && !has_trait_or_impl_parent {\n+        add_keyword(ctx, acc, \"enum\", \"enum $0 {}\");\n+        add_keyword(ctx, acc, \"struct\", \"struct $0 {}\");\n+        add_keyword(ctx, acc, \"union\", \"union $0 {}\");\n+    }\n \n+    if ctx.block_expr_parent || ctx.is_match_arm {\n+        add_keyword(ctx, acc, \"match\", \"match $0 {}\");\n+        add_keyword(ctx, acc, \"loop\", \"loop {$0}\");\n+    }\n+    if ctx.block_expr_parent {\n+        add_keyword(ctx, acc, \"while\", \"while $0 {}\");\n+    }\n+    if ctx.if_is_prev || ctx.block_expr_parent {\n+        add_keyword(ctx, acc, \"let\", \"let \");\n+    }\n+    if ctx.if_is_prev || ctx.block_expr_parent || ctx.is_match_arm {\n+        add_keyword(ctx, acc, \"if\", \"if \");\n+        add_keyword(ctx, acc, \"if let\", \"if let \");\n+    }\n     if ctx.after_if {\n-        acc.add(keyword(ctx, \"else\", \"else {$0}\"));\n-        acc.add(keyword(ctx, \"else if\", \"else if $0 {}\"));\n+        add_keyword(ctx, acc, \"else\", \"else {$0}\");\n+        add_keyword(ctx, acc, \"else if\", \"else if $0 {}\");\n+    }\n+    if (ctx.has_item_list_or_source_file_parent && !has_trait_or_impl_parent)\n+        || ctx.block_expr_parent\n+    {\n+        add_keyword(ctx, acc, \"mod\", \"mod $0 {}\");\n+    }\n+    if ctx.bind_pat_parent || ctx.ref_pat_parent {\n+        add_keyword(ctx, acc, \"mut\", \"mut \");\n     }\n-    if is_in_loop_body(&ctx.token) {\n+    if ctx.has_item_list_or_source_file_parent || ctx.block_expr_parent {\n+        add_keyword(ctx, acc, \"const\", \"const \");\n+        add_keyword(ctx, acc, \"type\", \"type \");\n+    }\n+    if (ctx.has_item_list_or_source_file_parent && !has_trait_or_impl_parent)\n+        || ctx.block_expr_parent\n+    {\n+        add_keyword(ctx, acc, \"static\", \"static \");\n+    };\n+    if (ctx.has_item_list_or_source_file_parent && !has_trait_or_impl_parent)\n+        || ctx.block_expr_parent\n+    {\n+        add_keyword(ctx, acc, \"extern\", \"extern \");\n+    }\n+    if ctx.has_item_list_or_source_file_parent || ctx.block_expr_parent || ctx.is_match_arm {\n+        add_keyword(ctx, acc, \"unsafe\", \"unsafe \");\n+    }\n+    if ctx.in_loop_body {\n         if ctx.can_be_stmt {\n-            acc.add(keyword(ctx, \"continue\", \"continue;\"));\n-            acc.add(keyword(ctx, \"break\", \"break;\"));\n+            add_keyword(ctx, acc, \"continue\", \"continue;\");\n+            add_keyword(ctx, acc, \"break\", \"break;\");\n         } else {\n-            acc.add(keyword(ctx, \"continue\", \"continue\"));\n-            acc.add(keyword(ctx, \"break\", \"break\"));\n+            add_keyword(ctx, acc, \"continue\", \"continue\");\n+            add_keyword(ctx, acc, \"break\", \"break\");\n         }\n     }\n+    if ctx.has_item_list_or_source_file_parent && !ctx.has_trait_parent {\n+        add_keyword(ctx, acc, \"pub\", \"pub \")\n+    }\n+\n+    if !ctx.is_trivial_path {\n+        return;\n+    }\n+    let fn_def = match &ctx.function_syntax {\n+        Some(it) => it,\n+        None => return,\n+    };\n     acc.add_all(complete_return(ctx, &fn_def, ctx.can_be_stmt));\n }\n \n-fn is_in_loop_body(leaf: &SyntaxToken) -> bool {\n-    // FIXME move this to CompletionContext and make it handle macros\n-    for node in leaf.parent().ancestors() {\n-        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n-            break;\n-        }\n-        let loop_body = match_ast! {\n-            match node {\n-                ast::ForExpr(it) => it.loop_body(),\n-                ast::WhileExpr(it) => it.loop_body(),\n-                ast::LoopExpr(it) => it.loop_body(),\n-                _ => None,\n-            }\n-        };\n-        if let Some(body) = loop_body {\n-            if body.syntax().text_range().contains_range(leaf.text_range()) {\n-                return true;\n-            }\n-        }\n+fn keyword(ctx: &CompletionContext, kw: &str, snippet: &str) -> CompletionItem {\n+    let res = CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), kw)\n+        .kind(CompletionItemKind::Keyword);\n+\n+    match ctx.config.snippet_cap {\n+        Some(cap) => res.insert_snippet(cap, snippet),\n+        _ => res.insert_text(if snippet.contains('$') { kw } else { snippet }),\n     }\n-    false\n+    .build()\n+}\n+\n+fn add_keyword(ctx: &CompletionContext, acc: &mut Completions, kw: &str, snippet: &str) {\n+    acc.add(keyword(ctx, kw, snippet));\n }\n \n fn complete_return(\n@@ -121,327 +170,156 @@ fn complete_return(\n \n #[cfg(test)]\n mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n-    use insta::assert_debug_snapshot;\n+    use crate::completion::{test_utils::completion_list, CompletionKind};\n+    use insta::assert_snapshot;\n \n-    fn do_keyword_completion(code: &str) -> Vec<CompletionItem> {\n-        do_completion(code, CompletionKind::Keyword)\n+    fn get_keyword_completions(code: &str) -> String {\n+        completion_list(code, CompletionKind::Keyword)\n     }\n \n     #[test]\n-    fn completes_keywords_in_use_stmt() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                use <|>\n-                \",\n-            ),\n+    fn test_keywords_in_use_stmt() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"use <|>\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"crate\",\n-                source_range: 21..21,\n-                delete: 21..21,\n-                insert: \"crate::\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"self\",\n-                source_range: 21..21,\n-                delete: 21..21,\n-                insert: \"self\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"super\",\n-                source_range: 21..21,\n-                delete: 21..21,\n-                insert: \"super::\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw crate\n+            kw self\n+            kw super\n         \"###\n         );\n \n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                use a::<|>\n-                \",\n-            ),\n+        assert_snapshot!(\n+            get_keyword_completions(r\"use a::<|>\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"self\",\n-                source_range: 24..24,\n-                delete: 24..24,\n-                insert: \"self\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"super\",\n-                source_range: 24..24,\n-                delete: 24..24,\n-                insert: \"super::\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw self\n+            kw super\n         \"###\n         );\n \n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                use a::{b, <|>}\n-                \",\n-            ),\n+        assert_snapshot!(\n+            get_keyword_completions(r\"use a::{b, <|>}\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"self\",\n-                source_range: 28..28,\n-                delete: 28..28,\n-                insert: \"self\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"super\",\n-                source_range: 28..28,\n-                delete: 28..28,\n-                insert: \"super::\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw self\n+            kw super\n         \"###\n         );\n     }\n \n     #[test]\n-    fn completes_various_keywords_in_function() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                fn quux() {\n-                    <|>\n-                }\n-                \",\n-            ),\n+    fn test_keywords_at_source_file_level() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"m<|>\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"return;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw const\n+            kw enum\n+            kw extern\n+            kw fn\n+            kw impl\n+            kw mod\n+            kw pub\n+            kw static\n+            kw struct\n+            kw trait\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n         \"###\n         );\n     }\n \n     #[test]\n-    fn completes_else_after_if() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                fn quux() {\n-                    if true {\n-                        ()\n-                    } <|>\n-                }\n-                \",\n-            ),\n+    fn test_keywords_in_function() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"fn quux() { <|> }\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"else\",\n-                source_range: 108..108,\n-                delete: 108..108,\n-                insert: \"else {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"else if\",\n-                source_range: 108..108,\n-                delete: 108..108,\n-                insert: \"else if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 108..108,\n-                delete: 108..108,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 108..108,\n-                delete: 108..108,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 108..108,\n-                delete: 108..108,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 108..108,\n-                delete: 108..108,\n-                insert: \"return;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 108..108,\n-                delete: 108..108,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw const\n+            kw extern\n+            kw fn\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw static\n+            kw trait\n+            kw type\n+            kw unsafe\n+            kw use\n+            kw while\n         \"###\n         );\n     }\n \n     #[test]\n-    fn test_completion_return_value() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                fn quux() -> i32 {\n-                    <|>\n-                    92\n-                }\n-                \",\n-            ),\n+    fn test_keywords_inside_block() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"fn quux() { if true { <|> } }\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 56..56,\n-                delete: 56..56,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 56..56,\n-                delete: 56..56,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 56..56,\n-                delete: 56..56,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 56..56,\n-                delete: 56..56,\n-                insert: \"return $0;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 56..56,\n-                delete: 56..56,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw const\n+            kw extern\n+            kw fn\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw static\n+            kw trait\n+            kw type\n+            kw unsafe\n+            kw use\n+            kw while\n         \"###\n         );\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n+    }\n+\n+    #[test]\n+    fn test_keywords_after_if() {\n+        assert_snapshot!(\n+            get_keyword_completions(\n                 r\"\n                 fn quux() {\n-                    <|>\n-                    92\n+                    if true {\n+                        ()\n+                    } <|>\n                 }\n                 \",\n             ),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"return;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 49..49,\n-                delete: 49..49,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw const\n+            kw else\n+            kw else if\n+            kw extern\n+            kw fn\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw static\n+            kw trait\n+            kw type\n+            kw unsafe\n+            kw use\n+            kw while\n         \"###\n         );\n     }\n \n     #[test]\n-    fn dont_add_semi_after_return_if_not_a_statement() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n+    fn test_keywords_in_match_arm() {\n+        assert_snapshot!(\n+            get_keyword_completions(\n                 r\"\n                 fn quux() -> i32 {\n                     match () {\n@@ -451,336 +329,130 @@ mod tests {\n                 \",\n             ),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 97..97,\n-                delete: 97..97,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 97..97,\n-                delete: 97..97,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 97..97,\n-                delete: 97..97,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 97..97,\n-                delete: 97..97,\n-                insert: \"return $0\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 97..97,\n-                delete: 97..97,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw unsafe\n         \"###\n         );\n     }\n \n     #[test]\n-    fn last_return_in_block_has_semi() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                fn quux() -> i32 {\n-                    if condition {\n-                        <|>\n-                    }\n-                }\n-                \",\n-            ),\n+    fn test_keywords_in_trait_def() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"trait My { <|> }\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"return $0;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw const\n+            kw fn\n+            kw type\n+            kw unsafe\n         \"###\n         );\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                fn quux() -> i32 {\n-                    if condition {\n-                        <|>\n-                    }\n-                    let x = 92;\n-                    x\n-                }\n-                \",\n-            ),\n+    }\n+\n+    #[test]\n+    fn test_keywords_in_impl_def() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"impl My { <|> }\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"return $0;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 95..95,\n-                delete: 95..95,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw const\n+            kw fn\n+            kw pub\n+            kw type\n+            kw unsafe\n         \"###\n         );\n     }\n \n     #[test]\n-    fn completes_break_and_continue_in_loops() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                fn quux() -> i32 {\n-                    loop { <|> }\n-                }\n-                \",\n-            ),\n+    fn test_keywords_in_loop() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"fn my() { loop { <|> } }\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"break\",\n-                source_range: 63..63,\n-                delete: 63..63,\n-                insert: \"break;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"continue\",\n-                source_range: 63..63,\n-                delete: 63..63,\n-                insert: \"continue;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 63..63,\n-                delete: 63..63,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 63..63,\n-                delete: 63..63,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 63..63,\n-                delete: 63..63,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 63..63,\n-                delete: 63..63,\n-                insert: \"return $0;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 63..63,\n-                delete: 63..63,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw break\n+            kw const\n+            kw continue\n+            kw extern\n+            kw fn\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw static\n+            kw trait\n+            kw type\n+            kw unsafe\n+            kw use\n+            kw while\n         \"###\n         );\n+    }\n \n-        // No completion: lambda isolates control flow\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                fn quux() -> i32 {\n-                    loop { || { <|> } }\n-                }\n-                \",\n-            ),\n+    #[test]\n+    fn test_keywords_after_unsafe_in_item_list() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"unsafe <|>\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 68..68,\n-                delete: 68..68,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 68..68,\n-                delete: 68..68,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 68..68,\n-                delete: 68..68,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 68..68,\n-                delete: 68..68,\n-                insert: \"return $0;\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 68..68,\n-                delete: 68..68,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw fn\n+            kw impl\n+            kw trait\n         \"###\n         );\n     }\n \n     #[test]\n-    fn no_semi_after_break_continue_in_expr() {\n-        assert_debug_snapshot!(\n-            do_keyword_completion(\n-                r\"\n-                fn f() {\n-                    loop {\n-                        match () {\n-                            () => br<|>\n-                        }\n-                    }\n-                }\n-                \",\n-            ),\n+    fn test_keywords_after_unsafe_in_block_expr() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"fn my_fn() { unsafe <|> }\"),\n             @r###\"\n-        [\n-            CompletionItem {\n-                label: \"break\",\n-                source_range: 122..124,\n-                delete: 122..124,\n-                insert: \"break\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"continue\",\n-                source_range: 122..124,\n-                delete: 122..124,\n-                insert: \"continue\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"if\",\n-                source_range: 122..124,\n-                delete: 122..124,\n-                insert: \"if $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"loop\",\n-                source_range: 122..124,\n-                delete: 122..124,\n-                insert: \"loop {$0}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"match\",\n-                source_range: 122..124,\n-                delete: 122..124,\n-                insert: \"match $0 {}\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"return\",\n-                source_range: 122..124,\n-                delete: 122..124,\n-                insert: \"return\",\n-                kind: Keyword,\n-            },\n-            CompletionItem {\n-                label: \"while\",\n-                source_range: 122..124,\n-                delete: 122..124,\n-                insert: \"while $0 {}\",\n-                kind: Keyword,\n-            },\n-        ]\n+            kw fn\n+            kw impl\n+            kw trait\n         \"###\n-        )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_mut_in_ref_and_in_fn_parameters_list() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"fn my_fn(&<|>) {}\"),\n+            @r###\"\n+            kw mut\n+        \"###\n+        );\n+        assert_snapshot!(\n+            get_keyword_completions(r\"fn my_fn(<|>) {}\"),\n+            @r###\"\n+            kw mut\n+        \"###\n+        );\n+        assert_snapshot!(\n+            get_keyword_completions(r\"fn my_fn() { let &<|> }\"),\n+            @r###\"\n+            kw mut\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_where_keyword() {\n+        assert_snapshot!(\n+            get_keyword_completions(r\"trait A <|>\"),\n+            @r###\"\n+            kw where\n+        \"###\n+        );\n+        assert_snapshot!(\n+            get_keyword_completions(r\"impl A <|>\"),\n+            @r###\"\n+            kw where\n+        \"###\n+        );\n     }\n }"}, {"sha": "9f4c582d08380d4035fe5bd286b07fb065c0a6b0", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "patch": "@@ -5,12 +5,17 @@ use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n-    ast, match_ast, AstNode,\n+    ast, match_ast, AstNode, NodeOrToken,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n use ra_text_edit::Indel;\n \n+use super::patterns::{\n+    has_bind_pat_parent, has_block_expr_parent, has_impl_as_prev_sibling, has_impl_parent,\n+    has_item_list_or_source_file_parent, has_ref_parent, has_trait_as_prev_sibling,\n+    has_trait_parent, if_is_prev, is_in_loop_body, is_match_arm, unsafe_is_prev,\n+};\n use crate::{call_info::ActiveParameter, completion::CompletionConfig, FilePosition};\n use test_utils::mark;\n \n@@ -60,6 +65,18 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_path_type: bool,\n     pub(super) has_type_args: bool,\n     pub(super) attribute_under_caret: Option<ast::Attr>,\n+    pub(super) unsafe_is_prev: bool,\n+    pub(super) if_is_prev: bool,\n+    pub(super) block_expr_parent: bool,\n+    pub(super) bind_pat_parent: bool,\n+    pub(super) ref_pat_parent: bool,\n+    pub(super) in_loop_body: bool,\n+    pub(super) has_trait_parent: bool,\n+    pub(super) has_impl_parent: bool,\n+    pub(super) trait_as_prev_sibling: bool,\n+    pub(super) impl_as_prev_sibling: bool,\n+    pub(super) is_match_arm: bool,\n+    pub(super) has_item_list_or_source_file_parent: bool,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -118,6 +135,18 @@ impl<'a> CompletionContext<'a> {\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n             attribute_under_caret: None,\n+            unsafe_is_prev: false,\n+            in_loop_body: false,\n+            ref_pat_parent: false,\n+            bind_pat_parent: false,\n+            block_expr_parent: false,\n+            has_trait_parent: false,\n+            has_impl_parent: false,\n+            trait_as_prev_sibling: false,\n+            impl_as_prev_sibling: false,\n+            if_is_prev: false,\n+            is_match_arm: false,\n+            has_item_list_or_source_file_parent: false,\n         };\n \n         let mut original_file = original_file.syntax().clone();\n@@ -159,7 +188,7 @@ impl<'a> CompletionContext<'a> {\n                 break;\n             }\n         }\n-\n+        ctx.fill_keyword_patterns(&hypothetical_file, offset);\n         ctx.fill(&original_file, hypothetical_file, offset);\n         Some(ctx)\n     }\n@@ -188,6 +217,24 @@ impl<'a> CompletionContext<'a> {\n         self.sema.scope_at_offset(&self.token.parent(), self.offset)\n     }\n \n+    fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n+        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n+        let syntax_element = NodeOrToken::Token(fake_ident_token.clone());\n+        self.block_expr_parent = has_block_expr_parent(syntax_element.clone());\n+        self.unsafe_is_prev = unsafe_is_prev(syntax_element.clone());\n+        self.if_is_prev = if_is_prev(syntax_element.clone());\n+        self.bind_pat_parent = has_bind_pat_parent(syntax_element.clone());\n+        self.ref_pat_parent = has_ref_parent(syntax_element.clone());\n+        self.in_loop_body = is_in_loop_body(syntax_element.clone());\n+        self.has_trait_parent = has_trait_parent(syntax_element.clone());\n+        self.has_impl_parent = has_impl_parent(syntax_element.clone());\n+        self.impl_as_prev_sibling = has_impl_as_prev_sibling(syntax_element.clone());\n+        self.trait_as_prev_sibling = has_trait_as_prev_sibling(syntax_element.clone());\n+        self.is_match_arm = is_match_arm(syntax_element.clone());\n+        self.has_item_list_or_source_file_parent =\n+            has_item_list_or_source_file_parent(syntax_element.clone());\n+    }\n+\n     fn fill(\n         &mut self,\n         original_file: &SyntaxNode,"}, {"sha": "98348b34924d593d94669ff1ccdd222f7fe6d111", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "patch": "@@ -125,6 +125,32 @@ pub enum CompletionItemKind {\n     Attribute,\n }\n \n+impl CompletionItemKind {\n+    #[cfg(test)]\n+    pub(crate) fn tag(&self) -> &'static str {\n+        match self {\n+            CompletionItemKind::Snippet => \"sn\",\n+            CompletionItemKind::Keyword => \"kw\",\n+            CompletionItemKind::Module => \"md\",\n+            CompletionItemKind::Function => \"fn\",\n+            CompletionItemKind::BuiltinType => \"bt\",\n+            CompletionItemKind::Struct => \"st\",\n+            CompletionItemKind::Enum => \"en\",\n+            CompletionItemKind::EnumVariant => \"ev\",\n+            CompletionItemKind::Binding => \"bn\",\n+            CompletionItemKind::Field => \"fd\",\n+            CompletionItemKind::Static => \"sc\",\n+            CompletionItemKind::Const => \"ct\",\n+            CompletionItemKind::Trait => \"tt\",\n+            CompletionItemKind::TypeAlias => \"ta\",\n+            CompletionItemKind::Method => \"me\",\n+            CompletionItemKind::TypeParam => \"tp\",\n+            CompletionItemKind::Macro => \"ma\",\n+            CompletionItemKind::Attribute => \"at\",\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub(crate) enum CompletionKind {\n     /// Parser-based keyword completion."}, {"sha": "b2fe13280a88d9b403fd7ae6aacee06e2b84a72c", "filename": "crates/ra_ide/src/completion/patterns.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs?ref=c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "patch": "@@ -0,0 +1,194 @@\n+//! Patterns telling us certain facts about current syntax element, they are used in completion context\n+\n+use ra_syntax::{\n+    algo::non_trivia_sibling,\n+    ast::{self, LoopBodyOwner},\n+    match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n+    SyntaxKind::*,\n+    SyntaxNode, SyntaxToken,\n+};\n+\n+#[cfg(test)]\n+use crate::completion::test_utils::check_pattern_is_applicable;\n+\n+pub(crate) fn has_trait_parent(element: SyntaxElement) -> bool {\n+    not_same_range_ancestor(element)\n+        .filter(|it| it.kind() == ITEM_LIST)\n+        .and_then(|it| it.parent())\n+        .filter(|it| it.kind() == TRAIT_DEF)\n+        .is_some()\n+}\n+#[test]\n+fn test_has_trait_parent() {\n+    check_pattern_is_applicable(r\"trait A { f<|> }\", has_trait_parent);\n+}\n+\n+pub(crate) fn has_impl_parent(element: SyntaxElement) -> bool {\n+    not_same_range_ancestor(element)\n+        .filter(|it| it.kind() == ITEM_LIST)\n+        .and_then(|it| it.parent())\n+        .filter(|it| it.kind() == IMPL_DEF)\n+        .is_some()\n+}\n+#[test]\n+fn test_has_impl_parent() {\n+    check_pattern_is_applicable(r\"impl A { f<|> }\", has_impl_parent);\n+}\n+\n+pub(crate) fn has_block_expr_parent(element: SyntaxElement) -> bool {\n+    not_same_range_ancestor(element).filter(|it| it.kind() == BLOCK_EXPR).is_some()\n+}\n+#[test]\n+fn test_has_block_expr_parent() {\n+    check_pattern_is_applicable(r\"fn my_fn() { let a = 2; f<|> }\", has_block_expr_parent);\n+}\n+\n+pub(crate) fn has_bind_pat_parent(element: SyntaxElement) -> bool {\n+    element.ancestors().find(|it| it.kind() == BIND_PAT).is_some()\n+}\n+#[test]\n+fn test_has_bind_pat_parent() {\n+    check_pattern_is_applicable(r\"fn my_fn(m<|>) {}\", has_bind_pat_parent);\n+    check_pattern_is_applicable(r\"fn my_fn() { let m<|> }\", has_bind_pat_parent);\n+}\n+\n+pub(crate) fn has_ref_parent(element: SyntaxElement) -> bool {\n+    not_same_range_ancestor(element)\n+        .filter(|it| it.kind() == REF_PAT || it.kind() == REF_EXPR)\n+        .is_some()\n+}\n+#[test]\n+fn test_has_ref_parent() {\n+    check_pattern_is_applicable(r\"fn my_fn(&m<|>) {}\", has_ref_parent);\n+    check_pattern_is_applicable(r\"fn my() { let &m<|> }\", has_ref_parent);\n+}\n+\n+pub(crate) fn has_item_list_or_source_file_parent(element: SyntaxElement) -> bool {\n+    let ancestor = not_same_range_ancestor(element);\n+    if !ancestor.is_some() {\n+        return true;\n+    }\n+    ancestor.filter(|it| it.kind() == SOURCE_FILE || it.kind() == ITEM_LIST).is_some()\n+}\n+#[test]\n+fn test_has_item_list_or_source_file_parent() {\n+    check_pattern_is_applicable(r\"i<|>\", has_item_list_or_source_file_parent);\n+    check_pattern_is_applicable(r\"impl { f<|> }\", has_item_list_or_source_file_parent);\n+}\n+\n+pub(crate) fn is_match_arm(element: SyntaxElement) -> bool {\n+    not_same_range_ancestor(element.clone()).filter(|it| it.kind() == MATCH_ARM).is_some()\n+        && previous_sibling_or_ancestor_sibling(element)\n+            .and_then(|it| it.into_token())\n+            .filter(|it| it.kind() == FAT_ARROW)\n+            .is_some()\n+}\n+#[test]\n+fn test_is_match_arm() {\n+    check_pattern_is_applicable(r\"fn my_fn() { match () { () => m<|> } }\", is_match_arm);\n+}\n+\n+pub(crate) fn unsafe_is_prev(element: SyntaxElement) -> bool {\n+    element\n+        .into_token()\n+        .and_then(|it| previous_non_trivia_token(it))\n+        .filter(|it| it.kind() == UNSAFE_KW)\n+        .is_some()\n+}\n+#[test]\n+fn test_unsafe_is_prev() {\n+    check_pattern_is_applicable(r\"unsafe i<|>\", unsafe_is_prev);\n+}\n+\n+pub(crate) fn if_is_prev(element: SyntaxElement) -> bool {\n+    element\n+        .into_token()\n+        .and_then(|it| previous_non_trivia_token(it))\n+        .filter(|it| it.kind() == IF_KW)\n+        .is_some()\n+}\n+#[test]\n+fn test_if_is_prev() {\n+    check_pattern_is_applicable(r\"if l<|>\", if_is_prev);\n+}\n+\n+pub(crate) fn has_trait_as_prev_sibling(element: SyntaxElement) -> bool {\n+    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == TRAIT_DEF).is_some()\n+}\n+#[test]\n+fn test_has_trait_as_prev_sibling() {\n+    check_pattern_is_applicable(r\"trait A w<|> {}\", has_trait_as_prev_sibling);\n+}\n+\n+pub(crate) fn has_impl_as_prev_sibling(element: SyntaxElement) -> bool {\n+    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == IMPL_DEF).is_some()\n+}\n+#[test]\n+fn test_has_impl_as_prev_sibling() {\n+    check_pattern_is_applicable(r\"impl A w<|> {}\", has_impl_as_prev_sibling);\n+}\n+\n+pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n+    let leaf = match element {\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+    for node in leaf.ancestors() {\n+        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n+            break;\n+        }\n+        let loop_body = match_ast! {\n+            match node {\n+                ast::ForExpr(it) => it.loop_body(),\n+                ast::WhileExpr(it) => it.loop_body(),\n+                ast::LoopExpr(it) => it.loop_body(),\n+                _ => None,\n+            }\n+        };\n+        if let Some(body) = loop_body {\n+            if body.syntax().text_range().contains_range(leaf.text_range()) {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn not_same_range_ancestor(element: SyntaxElement) -> Option<SyntaxNode> {\n+    element\n+        .ancestors()\n+        .take_while(|it| it.text_range() == element.text_range())\n+        .last()\n+        .and_then(|it| it.parent())\n+}\n+\n+fn previous_non_trivia_token(token: SyntaxToken) -> Option<SyntaxToken> {\n+    let mut token = token.prev_token();\n+    while let Some(inner) = token.clone() {\n+        if !inner.kind().is_trivia() {\n+            return Some(inner);\n+        } else {\n+            token = inner.prev_token();\n+        }\n+    }\n+    None\n+}\n+\n+fn previous_sibling_or_ancestor_sibling(element: SyntaxElement) -> Option<SyntaxElement> {\n+    let token_sibling = non_trivia_sibling(element.clone(), Direction::Prev);\n+    if let Some(sibling) = token_sibling {\n+        Some(sibling)\n+    } else {\n+        // if not trying to find first ancestor which has such a sibling\n+        let node = match element {\n+            NodeOrToken::Node(node) => node,\n+            NodeOrToken::Token(token) => token.parent(),\n+        };\n+        let range = node.text_range();\n+        let top_node = node.ancestors().take_while(|it| it.text_range() == range).last()?;\n+        let prev_sibling_node = top_node.ancestors().find(|it| {\n+            non_trivia_sibling(NodeOrToken::Node(it.to_owned()), Direction::Prev).is_some()\n+        })?;\n+        non_trivia_sibling(NodeOrToken::Node(prev_sibling_node), Direction::Prev)\n+    }\n+}"}, {"sha": "1e16a43cabe81bd676fcea5bb65f8e9a3780d7b7", "filename": "crates/ra_ide/src/completion/test_utils.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs?ref=c87c4a0a40c79e90272d4df62c7e2dc12b6b2c3e", "patch": "@@ -5,25 +5,63 @@ use crate::{\n     mock_analysis::{analysis_and_position, single_file_with_position},\n     CompletionItem,\n };\n+use hir::Semantics;\n+use ra_syntax::{AstNode, NodeOrToken, SyntaxElement};\n \n pub(crate) fn do_completion(code: &str, kind: CompletionKind) -> Vec<CompletionItem> {\n     do_completion_with_options(code, kind, &CompletionConfig::default())\n }\n \n+pub(crate) fn completion_list(code: &str, kind: CompletionKind) -> String {\n+    completion_list_with_options(code, kind, &CompletionConfig::default())\n+}\n+\n pub(crate) fn do_completion_with_options(\n     code: &str,\n     kind: CompletionKind,\n     options: &CompletionConfig,\n ) -> Vec<CompletionItem> {\n+    let mut kind_completions: Vec<CompletionItem> = get_all_completion_items(code, options)\n+        .into_iter()\n+        .filter(|c| c.completion_kind == kind)\n+        .collect();\n+    kind_completions.sort_by(|l, r| l.label().cmp(r.label()));\n+    kind_completions\n+}\n+\n+fn get_all_completion_items(code: &str, options: &CompletionConfig) -> Vec<CompletionItem> {\n     let (analysis, position) = if code.contains(\"//-\") {\n         analysis_and_position(code)\n     } else {\n         single_file_with_position(code)\n     };\n-    let completions = analysis.completions(options, position).unwrap().unwrap();\n-    let completion_items: Vec<CompletionItem> = completions.into();\n-    let mut kind_completions: Vec<CompletionItem> =\n-        completion_items.into_iter().filter(|c| c.completion_kind == kind).collect();\n+    analysis.completions(options, position).unwrap().unwrap().into()\n+}\n+\n+pub(crate) fn completion_list_with_options(\n+    code: &str,\n+    kind: CompletionKind,\n+    options: &CompletionConfig,\n+) -> String {\n+    let mut kind_completions: Vec<CompletionItem> = get_all_completion_items(code, options)\n+        .into_iter()\n+        .filter(|c| c.completion_kind == kind)\n+        .collect();\n     kind_completions.sort_by_key(|c| c.label().to_owned());\n     kind_completions\n+        .into_iter()\n+        .map(|it| format!(\"{} {}\\n\", it.kind().unwrap().tag(), it.label()))\n+        .collect()\n+}\n+\n+pub(crate) fn check_pattern_is_applicable(code: &str, check: fn(SyntaxElement) -> bool) {\n+    let (analysis, pos) = single_file_with_position(code);\n+    analysis\n+        .with_db(|db| {\n+            let sema = Semantics::new(db);\n+            let original_file = sema.parse(pos.file_id);\n+            let token = original_file.syntax().token_at_offset(pos.offset).left_biased().unwrap();\n+            assert!(check(NodeOrToken::Token(token)));\n+        })\n+        .unwrap();\n }"}]}