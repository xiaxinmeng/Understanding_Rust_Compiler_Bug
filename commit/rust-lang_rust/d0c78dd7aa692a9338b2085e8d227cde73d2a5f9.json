{"sha": "d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYzc4ZGQ3YWE2OTJhOTMzOGIyMDg1ZThkMjI3Y2RlNzNkMmE1Zjk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-29T01:10:49Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-06-03T09:20:35Z"}, "message": "syntax: revert `ast::AsyncArgument` and associated changes.\n\nHere follows the main reverts applied in order to make this commit:\n\nRevert \"Rollup merge of #60676 - davidtwco:issue-60674, r=cramertj\"\n\nThis reverts commit 45b09453dbf120cc23d889435aac3ed7d2ec8eb7, reversing\nchanges made to f6df1f6c30b469cb9e65c5453a0efa03cbb6005e.\n\nRevert \"Rollup merge of #60437 - davidtwco:issue-60236, r=nikomatsakis\"\n\nThis reverts commit 16939a50ea440e72cb6ecefdaabb988addb1ec0e, reversing\nchanges made to 12bf98155249783583a91863c5dccf9e346f1226.\n\nRevert \"Rollup merge of #59823 - davidtwco:issue-54716, r=cramertj\"\n\nThis reverts commit 62d1574876f5531bce1b267e62dff520d7adcbbb, reversing\nchanges made to 4eff8526a789e0dfa8b97f7dec91b7b5c18e8544.", "tree": {"sha": "1290fd73b61126610fbfa497888549feea6ba00f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1290fd73b61126610fbfa497888549feea6ba00f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlz05mMACgkQAXYLT59T\n8VTPBhAAkeJOiGUMNNhoM32figKg//O0FJcCo5co+uny6AIhIYRW8qc1XZL2efwQ\nBv1AS+JCuZcXRXlo68UhsxTpwcpJQ9pArOMXzAV7yqMOXLyiyhJi4e6MjtHq9bQr\n+Ouh6jda2tRCaLa69Q3nNaIEoI/4l2shPq1VvGiqWyX12UtBkBS2OKE2z86yKk1z\nkkUmnRGssijY8FtkA/ywWHEc7bPWHE78vsDBXJPqMGtC3ZsPNKMOEBNoAynpt8vK\n7O7IIQiCynIMwVczZb7WsWpySkatE0iEon7DBIVJFFQw1ymkkcNHWB0hb7d7tUeL\nG2vPnbFBezyeqUB8tjjhRO1oM4r+pU710+vtAYaOnFsF/K/KzL/BBx7X10ReW6ja\nTcNly3JVdcD0x43a/8SRD9fhanqNCxS7sZxuRFJddhUL6coC8t+mhf+GJzlHbKyW\nSDdbR5rAAtR+MU8Aca/qxXWFlqOAeFtTN7m9nZn7CW10btVqgfTN8nGyjaA5qVEm\noGXGHq/aHNwHj97uGqy05tNHuOLr4CVr+QVoY2kbAW86IXt5Erc6Phrhxq9MBHMR\naCsa5yczfB3b415zWb/NsTXpuSTFuXlzruTpKRhE0kE68JnZB2H+uyVKg2g0RY4A\nj4FrTeh8GhcJc/KFpxbQJR74sTntTFJ/vhO14oO2vB+gjIe3nEQ=\n=woqp\n-----END PGP SIGNATURE-----", "payload": "tree 1290fd73b61126610fbfa497888549feea6ba00f\nparent c57ed9d9478dcd12c854a0ef4e83c7f384ade060\nauthor Eduard-Mihai Burtescu <edy.burt@gmail.com> 1559092249 +0300\ncommitter David Wood <david@davidtw.co> 1559553635 +0100\n\nsyntax: revert `ast::AsyncArgument` and associated changes.\n\nHere follows the main reverts applied in order to make this commit:\n\nRevert \"Rollup merge of #60676 - davidtwco:issue-60674, r=cramertj\"\n\nThis reverts commit 45b09453dbf120cc23d889435aac3ed7d2ec8eb7, reversing\nchanges made to f6df1f6c30b469cb9e65c5453a0efa03cbb6005e.\n\nRevert \"Rollup merge of #60437 - davidtwco:issue-60236, r=nikomatsakis\"\n\nThis reverts commit 16939a50ea440e72cb6ecefdaabb988addb1ec0e, reversing\nchanges made to 12bf98155249783583a91863c5dccf9e346f1226.\n\nRevert \"Rollup merge of #59823 - davidtwco:issue-54716, r=cramertj\"\n\nThis reverts commit 62d1574876f5531bce1b267e62dff520d7adcbbb, reversing\nchanges made to 4eff8526a789e0dfa8b97f7dec91b7b5c18e8544.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "html_url": "https://github.com/rust-lang/rust/commit/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c57ed9d9478dcd12c854a0ef4e83c7f384ade060", "url": "https://api.github.com/repos/rust-lang/rust/commits/c57ed9d9478dcd12c854a0ef4e83c7f384ade060", "html_url": "https://github.com/rust-lang/rust/commit/c57ed9d9478dcd12c854a0ef4e83c7f384ade060"}], "stats": {"total": 628, "additions": 108, "deletions": 520}, "files": [{"sha": "a61bdeb82991569000eaa8a507d8dd74cd5d845c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 37, "deletions": 150, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -465,32 +465,6 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_pat(self, p)\n             }\n \n-            fn visit_fn(&mut self, fk: visit::FnKind<'lcx>, fd: &'lcx FnDecl, s: Span, _: NodeId) {\n-                if fk.header().map(|h| h.asyncness.node.is_async()).unwrap_or(false) {\n-                    // Don't visit the original pattern for async functions as it will be\n-                    // replaced.\n-                    for arg in &fd.inputs {\n-                        if let ArgSource::AsyncFn(pat) = &arg.source { self.visit_pat(pat); }\n-                        self.visit_ty(&arg.ty)\n-                    }\n-                    self.visit_fn_ret_ty(&fd.output);\n-\n-                    match fk {\n-                        visit::FnKind::ItemFn(_, decl, _, body) => {\n-                            self.visit_fn_header(decl);\n-                            self.visit_block(body)\n-                        },\n-                        visit::FnKind::Method(_, sig, _, body) => {\n-                            self.visit_fn_header(&sig.header);\n-                            self.visit_block(body)\n-                        },\n-                        visit::FnKind::Closure(body) => self.visit_expr(body),\n-                    }\n-                } else {\n-                    visit::walk_fn(self, fk, fd, s)\n-                }\n-            }\n-\n             fn visit_item(&mut self, item: &'lcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n@@ -2266,17 +2240,10 @@ impl<'a> LoweringContext<'a> {\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n-            source: self.lower_local_source(l.source),\n+            source: hir::LocalSource::Normal,\n         }, ids)\n     }\n \n-    fn lower_local_source(&mut self, ls: LocalSource) -> hir::LocalSource {\n-        match ls {\n-            LocalSource::Normal => hir::LocalSource::Normal,\n-            LocalSource::AsyncFn => hir::LocalSource::AsyncFn,\n-        }\n-    }\n-\n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n         match m {\n             Mutability::Mutable => hir::MutMutable,\n@@ -2292,14 +2259,7 @@ impl<'a> LoweringContext<'a> {\n         hir::Arg {\n             hir_id: self.lower_node_id(arg.id),\n             pat: self.lower_pat(&arg.pat),\n-            source: self.lower_arg_source(&arg.source),\n-        }\n-    }\n-\n-    fn lower_arg_source(&mut self, source: &ArgSource) -> hir::ArgSource {\n-        match source {\n-            ArgSource::Normal => hir::ArgSource::Normal,\n-            ArgSource::AsyncFn(pat) => hir::ArgSource::AsyncFn(self.lower_pat(pat)),\n+            source: hir::ArgSource::Normal,\n         }\n     }\n \n@@ -3028,44 +2988,13 @@ impl<'a> LoweringContext<'a> {\n     fn lower_async_body(\n         &mut self,\n         decl: &FnDecl,\n-        asyncness: &IsAsync,\n+        asyncness: IsAsync,\n         body: &Block,\n     ) -> hir::BodyId {\n         self.lower_body(Some(&decl), |this| {\n-            if let IsAsync::Async { closure_id, ref arguments, .. } = asyncness {\n-                let mut body = body.clone();\n-\n-                // Async function arguments are lowered into the closure body so that they are\n-                // captured and so that the drop order matches the equivalent non-async functions.\n-                //\n-                //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n-                //       async move {\n-                //       }\n-                //     }\n-                //\n-                //     // ...becomes...\n-                //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n-                //       async move {\n-                //         let __arg2 = __arg2;\n-                //         let <pattern> = __arg2;\n-                //         let __arg1 = __arg1;\n-                //         let <pattern> = __arg1;\n-                //         let __arg0 = __arg0;\n-                //         let <pattern> = __arg0;\n-                //       }\n-                //     }\n-                //\n-                // If `<pattern>` is a simple ident, then it is lowered to a single\n-                // `let <pattern> = <pattern>;` statement as an optimization.\n-                for a in arguments.iter().rev() {\n-                    if let Some(pat_stmt) = a.pat_stmt.clone() {\n-                        body.stmts.insert(0, pat_stmt);\n-                    }\n-                    body.stmts.insert(0, a.move_stmt.clone());\n-                }\n-\n+            if let IsAsync::Async { closure_id, .. } = asyncness {\n                 let async_expr = this.make_async_expr(\n-                    CaptureBy::Value, *closure_id, None, body.span,\n+                    CaptureBy::Value, closure_id, None, body.span,\n                     |this| {\n                         let body = this.lower_block(&body, false);\n                         this.expr_block(body, ThinVec::new())\n@@ -3126,47 +3055,26 @@ impl<'a> LoweringContext<'a> {\n                     value\n                 )\n             }\n-            ItemKind::Fn(ref decl, ref header, ref generics, ref body) => {\n+            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n+                    // Note: we don't need to change the return type from `T` to\n+                    // `impl Future<Output = T>` here because lower_body\n+                    // only cares about the input argument patterns in the function\n+                    // declaration (decl), not the return types.\n+                    let body_id = this.lower_async_body(decl, header.asyncness.node, body);\n+                    let (generics, fn_decl) = this.add_in_band_defs(\n+                        generics,\n+                        fn_def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, idty| this.lower_fn_decl(\n+                            decl,\n+                            Some((fn_def_id, idty)),\n+                            true,\n+                            header.asyncness.node.opt_return_id()\n+                        ),\n+                    );\n                     this.current_item = Some(ident.span);\n-                    let mut lower_fn = |decl: &FnDecl| {\n-                        // Note: we don't need to change the return type from `T` to\n-                        // `impl Future<Output = T>` here because lower_body\n-                        // only cares about the input argument patterns in the function\n-                        // declaration (decl), not the return types.\n-                        let body_id = this.lower_async_body(&decl, &header.asyncness.node, body);\n-\n-                        let (generics, fn_decl) = this.add_in_band_defs(\n-                            generics,\n-                            fn_def_id,\n-                            AnonymousLifetimeMode::PassThrough,\n-                            |this, idty| this.lower_fn_decl(\n-                                &decl,\n-                                Some((fn_def_id, idty)),\n-                                true,\n-                                header.asyncness.node.opt_return_id()\n-                            ),\n-                        );\n-\n-                        (body_id, generics, fn_decl)\n-                    };\n-\n-                    let (body_id, generics, fn_decl) = if let IsAsync::Async {\n-                        arguments, ..\n-                    } = &header.asyncness.node {\n-                        let mut decl = decl.clone();\n-                        // Replace the arguments of this async function with the generated\n-                        // arguments that will be moved into the closure.\n-                        for (i, a) in arguments.clone().drain(..).enumerate() {\n-                            if let Some(arg) = a.arg {\n-                                decl.inputs[i] = arg;\n-                            }\n-                        }\n-                        lower_fn(&decl)\n-                    } else {\n-                        lower_fn(decl)\n-                    };\n \n                     hir::ItemKind::Fn(\n                         fn_decl,\n@@ -3638,36 +3546,15 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n-                let mut lower_method = |sig: &MethodSig| {\n-                    let body_id = self.lower_async_body(\n-                        &sig.decl, &sig.header.asyncness.node, body\n-                    );\n-                    let impl_trait_return_allow = !self.is_in_trait_impl;\n-                    let (generics, sig) = self.lower_method_sig(\n-                        &i.generics,\n-                        sig,\n-                        impl_item_def_id,\n-                        impl_trait_return_allow,\n-                        sig.header.asyncness.node.opt_return_id(),\n-                    );\n-                    (body_id, generics, sig)\n-                };\n-\n-                let (body_id, generics, sig) = if let IsAsync::Async {\n-                    ref arguments, ..\n-                } = sig.header.asyncness.node {\n-                    let mut sig = sig.clone();\n-                    // Replace the arguments of this async function with the generated\n-                    // arguments that will be moved into the closure.\n-                    for (i, a) in arguments.clone().drain(..).enumerate() {\n-                        if let Some(arg) = a.arg {\n-                            sig.decl.inputs[i] = arg;\n-                        }\n-                    }\n-                    lower_method(&sig)\n-                } else {\n-                    lower_method(sig)\n-                };\n+                let body_id = self.lower_async_body(&sig.decl, sig.header.asyncness.node, body);\n+                let impl_trait_return_allow = !self.is_in_trait_impl;\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    impl_item_def_id,\n+                    impl_trait_return_allow,\n+                    sig.header.asyncness.node.opt_return_id(),\n+                );\n                 self.current_item = Some(i.span);\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n@@ -3860,7 +3747,7 @@ impl<'a> LoweringContext<'a> {\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n     ) -> (hir::Generics, hir::MethodSig) {\n-        let header = self.lower_fn_header(&sig.header);\n+        let header = self.lower_fn_header(sig.header);\n         let (generics, decl) = self.add_in_band_defs(\n             generics,\n             fn_def_id,\n@@ -3882,10 +3769,10 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_header(&mut self, h: &FnHeader) -> hir::FnHeader {\n+    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n         hir::FnHeader {\n             unsafety: self.lower_unsafety(h.unsafety),\n-            asyncness: self.lower_asyncness(&h.asyncness.node),\n+            asyncness: self.lower_asyncness(h.asyncness.node),\n             constness: self.lower_constness(h.constness),\n             abi: h.abi,\n         }\n@@ -3905,7 +3792,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_asyncness(&mut self, a: &IsAsync) -> hir::IsAsync {\n+    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n         match a {\n             IsAsync::Async { .. } => hir::IsAsync::Async,\n             IsAsync::NotAsync => hir::IsAsync::NotAsync,\n@@ -4222,7 +4109,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::Await(_origin, ref expr) => self.lower_await(e.span, expr),\n             ExprKind::Closure(\n-                capture_clause, ref asyncness, movability, ref decl, ref body, fn_decl_span\n+                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n                     let outer_decl = FnDecl {\n@@ -4260,7 +4147,7 @@ impl<'a> LoweringContext<'a> {\n                                 Some(&**ty)\n                             } else { None };\n                             let async_body = this.make_async_expr(\n-                                capture_clause, *closure_id, async_ret_ty, body.span,\n+                                capture_clause, closure_id, async_ret_ty, body.span,\n                                 |this| {\n                                     this.with_new_scopes(|this| this.lower_expr(body))\n                                 });"}, {"sha": "a4484c81738983c53d434ec3be8086d6c5f78ec4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -64,17 +64,16 @@ impl<'a> DefCollector<'a> {\n         id: NodeId,\n         name: Name,\n         span: Span,\n-        header: &'a FnHeader,\n+        header: &FnHeader,\n         generics: &'a Generics,\n         decl: &'a FnDecl,\n         body: &'a Block,\n     ) {\n-        let (closure_id, return_impl_trait_id, arguments) = match &header.asyncness.node {\n+        let (closure_id, return_impl_trait_id) = match header.asyncness.node {\n             IsAsync::Async {\n                 closure_id,\n                 return_impl_trait_id,\n-                arguments,\n-            } => (closure_id, return_impl_trait_id, arguments),\n+            } => (closure_id, return_impl_trait_id),\n             _ => unreachable!(),\n         };\n \n@@ -83,38 +82,16 @@ impl<'a> DefCollector<'a> {\n         let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n         let fn_def = self.create_def(id, fn_def_data, span);\n         return self.with_parent(fn_def, |this| {\n-            this.create_def(*return_impl_trait_id, DefPathData::ImplTrait, span);\n+            this.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n \n             visit::walk_generics(this, generics);\n-\n-            // Walk the generated arguments for the `async fn`.\n-            for (i, a) in arguments.iter().enumerate() {\n-                use visit::Visitor;\n-                if let Some(arg) = &a.arg {\n-                    this.visit_ty(&arg.ty);\n-                } else {\n-                    this.visit_ty(&decl.inputs[i].ty);\n-                }\n-            }\n-\n-            // We do not invoke `walk_fn_decl` as this will walk the arguments that are being\n-            // replaced.\n-            visit::walk_fn_ret_ty(this, &decl.output);\n+            visit::walk_fn_decl(this, decl);\n \n             let closure_def = this.create_def(\n-                *closure_id, DefPathData::ClosureExpr, span,\n+                closure_id, DefPathData::ClosureExpr, span,\n             );\n             this.with_parent(closure_def, |this| {\n-                use visit::Visitor;\n-                // Walk each of the generated statements before the regular block body.\n-                for a in arguments {\n-                    this.visit_stmt(&a.move_stmt);\n-                    if let Some(pat_stmt) = &a.pat_stmt {\n-                        this.visit_stmt(&pat_stmt);\n-                    }\n-                }\n-\n-                visit::walk_block(this, &body);\n+                visit::walk_block(this, body);\n             })\n         })\n     }\n@@ -302,7 +279,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         match expr.node {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n-            ExprKind::Closure(_, ref asyncness, ..) => {\n+            ExprKind::Closure(_, asyncness, ..) => {\n                 let closure_def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n                                           expr.span);\n@@ -311,7 +288,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 // Async closures desugar to closures inside of closures, so\n                 // we must create two defs.\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n-                    let async_def = self.create_def(*closure_id,\n+                    let async_def = self.create_def(closure_id,\n                                                     DefPathData::ClosureExpr,\n                                                     expr.span);\n                     self.parent_def = Some(async_def);"}, {"sha": "c5c6c4b944700c0fdef79fb6a6a9debda17d9528", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -1335,30 +1335,6 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n         run_early_pass!(self, check_mac, mac);\n     }\n-\n-    fn visit_fn_header(&mut self, header: &'a ast::FnHeader) {\n-        // Unlike in HIR lowering and name resolution, the `AsyncArgument` statements are not added\n-        // to the function body and the arguments do not replace those in the declaration. They are\n-        // still visited manually here so that buffered lints can be emitted.\n-        if let ast::IsAsync::Async { ref arguments, .. } = header.asyncness.node {\n-            for a in arguments {\n-                // Visit the argument..\n-                if let Some(arg) = &a.arg {\n-                    self.visit_pat(&arg.pat);\n-                    if let ast::ArgSource::AsyncFn(pat) = &arg.source {\n-                        self.visit_pat(pat);\n-                    }\n-                    self.visit_ty(&arg.ty);\n-                }\n-\n-                // ..and the statement.\n-                self.visit_stmt(&a.move_stmt);\n-                if let Some(pat_stmt) = &a.pat_stmt {\n-                    self.visit_stmt(&pat_stmt);\n-                }\n-            }\n-        }\n-    }\n }\n \n struct LateLintPassObjects<'a> {"}, {"sha": "89c4a9106a4773a7dbc593b8d2842b87b58a74b6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -222,7 +222,7 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_trait_fn_not_async(&self, span: Span, asyncness: &IsAsync) {\n+    fn check_trait_fn_not_async(&self, span: Span, asyncness: IsAsync) {\n         if asyncness.is_async() {\n             struct_span_err!(self.session, span, E0706,\n                              \"trait fns cannot be declared `async`\").emit()\n@@ -561,7 +561,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.invalid_visibility(&impl_item.vis, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.header.constness);\n-                        self.check_trait_fn_not_async(impl_item.span, &sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n                     }\n                 }\n             }\n@@ -633,7 +633,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n-                        self.check_trait_fn_not_async(trait_item.span, &sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness.node);\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, mut_ident| {"}, {"sha": "99abe69017da729245d96620c4576ded94a23c87", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 52, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -855,15 +855,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 _: NodeId)\n     {\n         debug!(\"(resolving function) entering function\");\n-        let (rib_kind, asyncness) = match function_kind {\n-            FnKind::ItemFn(_, ref header, ..) =>\n-                (FnItemRibKind, &header.asyncness.node),\n-            FnKind::Method(_, ref sig, _, _) =>\n-                (AssocItemRibKind, &sig.header.asyncness.node),\n-            FnKind::Closure(_) =>\n-                // Async closures aren't resolved through `visit_fn`-- they're\n-                // processed separately\n-                (NormalRibKind, &IsAsync::NotAsync),\n+        let rib_kind = match function_kind {\n+            FnKind::ItemFn(..) => FnItemRibKind,\n+            FnKind::Method(..) => AssocItemRibKind,\n+            FnKind::Closure(_) => NormalRibKind,\n         };\n \n         // Create a value rib for the function.\n@@ -874,45 +869,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n \n         // Add each argument to the rib.\n         let mut bindings_list = FxHashMap::default();\n-        let mut add_argument = |argument: &ast::Arg| {\n+        for argument in &declaration.inputs {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+\n             self.visit_ty(&argument.ty);\n-            debug!(\"(resolving function) recorded argument\");\n-        };\n \n-        // Walk the generated async arguments if this is an `async fn`, otherwise walk the\n-        // normal arguments.\n-        if let IsAsync::Async { ref arguments, .. } = asyncness {\n-            for (i, a) in arguments.iter().enumerate() {\n-                if let Some(arg) = &a.arg {\n-                    add_argument(&arg);\n-                } else {\n-                    add_argument(&declaration.inputs[i]);\n-                }\n-            }\n-        } else {\n-            for a in &declaration.inputs { add_argument(a); }\n+            debug!(\"(resolving function) recorded argument\");\n         }\n-\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n         match function_kind {\n-            FnKind::ItemFn(.., body) | FnKind::Method(.., body) => {\n-                if let IsAsync::Async { ref arguments, .. } = asyncness {\n-                    let mut body = body.clone();\n-                    // Insert the generated statements into the body before attempting to\n-                    // resolve names.\n-                    for a in arguments.iter().rev() {\n-                        if let Some(pat_stmt) = a.pat_stmt.clone() {\n-                            body.stmts.insert(0, pat_stmt);\n-                        }\n-                        body.stmts.insert(0, a.move_stmt.clone());\n-                    }\n-                    self.visit_block(&body);\n-                } else {\n-                    self.visit_block(body);\n-                }\n+            FnKind::ItemFn(.., body) |\n+            FnKind::Method(.., body) => {\n+                self.visit_block(body);\n             }\n             FnKind::Closure(body) => {\n                 self.visit_expr(body);\n@@ -4178,7 +4148,7 @@ impl<'a> Resolver<'a> {\n         let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n-                    if !ident.is_gensymed() && filter_fn(binding.res()) {\n+                    if filter_fn(binding.res()) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: binding.res().article(),\n@@ -4196,7 +4166,7 @@ impl<'a> Resolver<'a> {\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n-                    if !ident.is_gensymed() && filter_fn(res) {\n+                    if filter_fn(res) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: res.article(),\n@@ -4226,7 +4196,7 @@ impl<'a> Resolver<'a> {\n                                             },\n                                         );\n \n-                                        if !ident.is_gensymed() && filter_fn(crate_mod) {\n+                                        if filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n                                                 candidate: ident.name,\n                                                 article: \"a\",\n@@ -4249,15 +4219,13 @@ impl<'a> Resolver<'a> {\n             // Add primitive types to the mix\n             if filter_fn(Res::PrimTy(Bool)) {\n                 names.extend(\n-                    self.primitive_type_table.primitive_types\n-                        .iter()\n-                        .map(|(name, _)| {\n-                            TypoSuggestion {\n-                                candidate: *name,\n-                                article: \"a\",\n-                                kind: \"primitive type\",\n-                            }\n-                        })\n+                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n+                        TypoSuggestion {\n+                            candidate: *name,\n+                            article: \"a\",\n+                            kind: \"primitive type\",\n+                        }\n+                    })\n                 )\n             }\n         } else {"}, {"sha": "db8b5eacd94d9321f2f7e7b9b1175f927590e693", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -374,7 +374,7 @@ impl Sig for ast::Item {\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Fn(ref decl, ref header, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, header, ref generics, _) => {\n                 let mut text = String::new();\n                 if header.constness.node == ast::Constness::Const {\n                     text.push_str(\"const \");"}, {"sha": "b8a10d90c3c0afe10974137fa06b5238d4a5e05a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -879,17 +879,6 @@ pub struct Local {\n     pub id: NodeId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n-    /// Origin of this local variable.\n-    pub source: LocalSource,\n-}\n-\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n-pub enum LocalSource {\n-    /// Local was parsed from source.\n-    Normal,\n-    /// Within `ast::IsAsync::Async`, a local is generated that will contain the moved arguments\n-    /// of an `async fn`.\n-    AsyncFn,\n }\n \n /// An arm of a 'match'.\n@@ -1770,16 +1759,6 @@ pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n-    pub source: ArgSource,\n-}\n-\n-/// The source of an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ArgSource {\n-    /// Argument as written by the user.\n-    Normal,\n-    /// Argument from `async fn` lowering, contains the original binding pattern.\n-    AsyncFn(P<Pat>),\n }\n \n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n@@ -1839,7 +1818,6 @@ impl Arg {\n             }),\n             ty,\n             id: DUMMY_NODE_ID,\n-            source: ArgSource::Normal,\n         };\n         match eself.node {\n             SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n@@ -1894,52 +1872,31 @@ pub enum Unsafety {\n     Normal,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct AsyncArgument {\n-    /// `__arg0`\n-    pub ident: Ident,\n-    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`. Only if\n-    /// argument is not a simple binding.\n-    pub arg: Option<Arg>,\n-    /// `let __arg0 = __arg0;` statement to be inserted at the start of the block.\n-    pub move_stmt: Stmt,\n-    /// `let <pat> = __arg0;` statement to be inserted at the start of the block, after matching\n-    /// move statement. Only if argument is not a simple binding.\n-    pub pat_stmt: Option<Stmt>,\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAsync {\n     Async {\n         closure_id: NodeId,\n         return_impl_trait_id: NodeId,\n-        /// This field stores the arguments and statements that are used in HIR lowering to\n-        /// ensure that `async fn` arguments are dropped at the correct time.\n-        ///\n-        /// The argument and statements here are generated at parse time as they are required in\n-        /// both the hir lowering, def collection and name resolution and this stops them needing\n-        /// to be created in each place.\n-        arguments: Vec<AsyncArgument>,\n     },\n     NotAsync,\n }\n \n impl IsAsync {\n-    pub fn is_async(&self) -> bool {\n-        if let IsAsync::Async { .. } = *self {\n+    pub fn is_async(self) -> bool {\n+        if let IsAsync::Async { .. } = self {\n             true\n         } else {\n             false\n         }\n     }\n \n     /// In ths case this is an `async` return, the `NodeId` for the generated `impl Trait` item.\n-    pub fn opt_return_id(&self) -> Option<NodeId> {\n+    pub fn opt_return_id(self) -> Option<NodeId> {\n         match self {\n             IsAsync::Async {\n                 return_impl_trait_id,\n                 ..\n-            } => Some(*return_impl_trait_id),\n+            } => Some(return_impl_trait_id),\n             IsAsync::NotAsync => None,\n         }\n     }\n@@ -2279,7 +2236,7 @@ impl Item {\n ///\n /// All the information between the visibility and the name of the function is\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub asyncness: Spanned<IsAsync>,"}, {"sha": "47c79f8466a95c486983fc5f1b33a4409865a562", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -516,7 +516,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -545,7 +544,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -563,7 +561,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -971,8 +968,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::Arg {\n             ty,\n             pat: arg_pat,\n-            id: ast::DUMMY_NODE_ID,\n-            source: ast::ArgSource::Normal,\n+            id: ast::DUMMY_NODE_ID\n         }\n     }\n "}, {"sha": "c56c156182bd66089c3202bc7aa72d41003ae508", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -101,13 +101,6 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     fn remove(&mut self, id: ast::NodeId) -> AstFragment {\n         self.expanded_fragments.remove(&id).unwrap()\n     }\n-\n-    fn next_id(&mut self, id: &mut ast::NodeId) {\n-        if self.monotonic {\n-            assert_eq!(*id, ast::DUMMY_NODE_ID);\n-            *id = self.cx.resolver.next_node_id()\n-        }\n-    }\n }\n \n impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n@@ -189,19 +182,9 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n         noop_visit_block(block, self);\n \n         for stmt in block.stmts.iter_mut() {\n-            self.next_id(&mut stmt.id);\n-        }\n-    }\n-\n-    fn visit_asyncness(&mut self, a: &mut ast::IsAsync) {\n-        noop_visit_asyncness(a, self);\n-\n-        if let ast::IsAsync::Async { ref mut arguments, .. } = a {\n-            for argument in arguments.iter_mut() {\n-                self.next_id(&mut argument.move_stmt.id);\n-                if let Some(ref mut pat_stmt) = &mut argument.pat_stmt {\n-                    self.next_id(&mut pat_stmt.id);\n-                }\n+            if self.monotonic {\n+                assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                stmt.id = self.cx.resolver.next_node_id();\n             }\n         }\n     }"}, {"sha": "757513098995be60379061d73adeb29c129ba635", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -207,10 +207,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_local(l, self);\n     }\n \n-    fn visit_local_source(&mut self, l: &mut LocalSource) {\n-        noop_visit_local_source(l, self);\n-    }\n-\n     fn visit_mac(&mut self, _mac: &mut Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // N.B., see note about macros above. If you really want a visitor that\n@@ -234,10 +230,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_arg(a, self);\n     }\n \n-    fn visit_arg_source(&mut self, a: &mut ArgSource) {\n-        noop_visit_arg_source(a, self);\n-    }\n-\n     fn visit_generics(&mut self, generics: &mut Generics) {\n         noop_visit_generics(generics, self);\n     }\n@@ -522,17 +514,13 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(args: &mut Parenth\n }\n \n pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n-    let Local { id, pat, ty, init, span, attrs, source } = local.deref_mut();\n+    let Local { id, pat, ty, init, span, attrs } = local.deref_mut();\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(ty, |ty| vis.visit_ty(ty));\n     visit_opt(init, |init| vis.visit_expr(init));\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n-    vis.visit_local_source(source);\n-}\n-\n-pub fn noop_visit_local_source<T: MutVisitor>(_local_source: &mut LocalSource, _vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n@@ -571,18 +559,10 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty, source }: &mut Arg, vis: &mut T) {\n+pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty }: &mut Arg, vis: &mut T) {\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     vis.visit_ty(ty);\n-    vis.visit_arg_source(source);\n-}\n-\n-pub fn noop_visit_arg_source<T: MutVisitor>(source: &mut ArgSource, vis: &mut T) {\n-    match source {\n-        ArgSource::Normal => {},\n-        ArgSource::AsyncFn(pat) => vis.visit_pat(pat),\n-    }\n }\n \n pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n@@ -690,25 +670,9 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n \n pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T) {\n     match asyncness {\n-        IsAsync::Async { closure_id, return_impl_trait_id, ref mut arguments } => {\n+        IsAsync::Async { closure_id, return_impl_trait_id } => {\n             vis.visit_id(closure_id);\n             vis.visit_id(return_impl_trait_id);\n-            for AsyncArgument { ident, arg, pat_stmt, move_stmt } in arguments.iter_mut() {\n-                vis.visit_ident(ident);\n-                if let Some(arg) = arg {\n-                    vis.visit_arg(arg);\n-                }\n-                visit_clobber(move_stmt, |stmt| {\n-                    vis.flat_map_stmt(stmt)\n-                        .expect_one(\"expected visitor to produce exactly one item\")\n-                });\n-                visit_opt(pat_stmt, |stmt| {\n-                    visit_clobber(stmt, |stmt| {\n-                        vis.flat_map_stmt(stmt)\n-                            .expect_one(\"expected visitor to produce exactly one item\")\n-                    })\n-                });\n-            }\n         }\n         IsAsync::NotAsync => {}\n     }"}, {"sha": "5df22f28797a4813a49d7530e517e1f2f123de3d", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -27,7 +27,7 @@ crate fn dummy_arg(ident: Ident) -> Arg {\n         span: ident.span,\n         id: ast::DUMMY_NODE_ID\n     };\n-    Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal }\n+    Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID }\n }\n \n pub enum Error {"}, {"sha": "d8891816c9e9c4e8825a3e29643bddc6b5325fa2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 129, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -1,9 +1,9 @@\n // ignore-tidy-filelength\n \n-use crate::ast::{AngleBracketedArgs, AsyncArgument, ParenthesizedArgs, AttrStyle, BareFnTy};\n+use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n use crate::ast::{GenericBound, TraitBoundModifier};\n use crate::ast::Unsafety;\n-use crate::ast::{Mod, AnonConst, Arg, ArgSource, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n+use crate::ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n use crate::ast::Block;\n use crate::ast::{BlockCheckMode, CaptureBy, Movability};\n use crate::ast::{Constness, Crate};\n@@ -16,7 +16,7 @@ use crate::ast::{GenericParam, GenericParamKind};\n use crate::ast::GenericArg;\n use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n use crate::ast::{Label, Lifetime};\n-use crate::ast::{Local, LocalSource};\n+use crate::ast::Local;\n use crate::ast::MacStmtStyle;\n use crate::ast::{Mac, Mac_, MacDelimiter};\n use crate::ast::{MutTy, Mutability};\n@@ -51,7 +51,7 @@ use crate::parse::diagnostics::{Error, dummy_arg};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n-use syntax_pos::{Span, BytePos, DUMMY_SP, FileName, hygiene::CompilerDesugaringKind};\n+use syntax_pos::{Span, BytePos, DUMMY_SP, FileName};\n use log::debug;\n \n use std::borrow::Cow;\n@@ -1126,7 +1126,6 @@ impl<'a> Parser<'a> {\n             IsAsync::Async {\n                 closure_id: ast::DUMMY_NODE_ID,\n                 return_impl_trait_id: ast::DUMMY_NODE_ID,\n-                arguments: Vec::new(),\n             }\n         } else {\n             IsAsync::NotAsync\n@@ -1185,12 +1184,12 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n         } else {\n-            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n \n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n \n-            let mut decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n+            let decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n                 // This is somewhat dubious; We don't want to allow\n                 // argument names to be left off if there is a\n                 // definition...\n@@ -1199,7 +1198,6 @@ impl<'a> Parser<'a> {\n                 p.parse_arg_general(p.span.rust_2018(), true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n-            self.construct_async_arguments(&mut asyncness, &mut decl);\n \n             let sig = ast::MethodSig {\n                 header: FnHeader {\n@@ -1563,7 +1561,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal })\n+        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n     }\n \n     /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n@@ -1581,8 +1579,7 @@ impl<'a> Parser<'a> {\n         Ok(Arg {\n             ty: t,\n             pat,\n-            id: ast::DUMMY_NODE_ID,\n-            source: ast::ArgSource::Normal,\n+            id: ast::DUMMY_NODE_ID\n         })\n     }\n \n@@ -4213,7 +4210,6 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: lo.to(hi),\n             attrs,\n-            source: LocalSource::Normal,\n         }))\n     }\n \n@@ -5660,16 +5656,15 @@ impl<'a> Parser<'a> {\n     /// Parses an item-position function declaration.\n     fn parse_item_fn(&mut self,\n                      unsafety: Unsafety,\n-                     mut asyncness: Spanned<IsAsync>,\n+                     asyncness: Spanned<IsAsync>,\n                      constness: Spanned<Constness>,\n                      abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n         let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n-        let mut decl = self.parse_fn_decl(allow_c_variadic)?;\n+        let decl = self.parse_fn_decl(allow_c_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        self.construct_async_arguments(&mut asyncness, &mut decl);\n         let header = FnHeader { unsafety, asyncness, constness, abi };\n         Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n     }\n@@ -5849,14 +5844,13 @@ impl<'a> Parser<'a> {\n             Ok((Ident::invalid(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n-            let mut decl = self.parse_fn_decl_with_self(|p| {\n+            let decl = self.parse_fn_decl_with_self(|p| {\n                 p.parse_arg_general(true, true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n-            self.construct_async_arguments(&mut asyncness, &mut decl);\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n@@ -7218,7 +7212,6 @@ impl<'a> Parser<'a> {\n                                     respan(async_span, IsAsync::Async {\n                                         closure_id: ast::DUMMY_NODE_ID,\n                                         return_impl_trait_id: ast::DUMMY_NODE_ID,\n-                                        arguments: Vec::new(),\n                                     }),\n                                     respan(fn_span, Constness::NotConst),\n                                     Abi::Rust)?;\n@@ -7849,116 +7842,6 @@ impl<'a> Parser<'a> {\n             Applicability::MaybeIncorrect,\n         ).emit();\n     }\n-\n-    /// When lowering a `async fn` to the HIR, we need to move all of the arguments of the function\n-    /// into the generated closure so that they are dropped when the future is polled and not when\n-    /// it is created.\n-    ///\n-    /// The arguments of the function are replaced in HIR lowering with the arguments created by\n-    /// this function and the statements created here are inserted at the top of the closure body.\n-    fn construct_async_arguments(&mut self, asyncness: &mut Spanned<IsAsync>, decl: &mut FnDecl) {\n-        // FIXME(davidtwco): This function should really live in the HIR lowering but because\n-        // the types constructed here need to be used in parts of resolve so that the correct\n-        // locals are considered upvars, it is currently easier for it to live here in the parser,\n-        // where it can be constructed once.\n-        if let IsAsync::Async { ref mut arguments, .. } = asyncness.node {\n-            for (index, input) in decl.inputs.iter_mut().enumerate() {\n-                let id = ast::DUMMY_NODE_ID;\n-                let span = input.pat.span;\n-                let desugared_span = self.sess.source_map()\n-                    .mark_span_with_reason(CompilerDesugaringKind::Async, span, None);\n-\n-                // Construct a name for our temporary argument.\n-                let name = format!(\"__arg{}\", index);\n-                let ident = Ident::from_str(&name).gensym();\n-\n-                // Check if this is a ident pattern, if so, we can optimize and avoid adding a\n-                // `let <pat> = __argN;` statement, instead just adding a `let <pat> = <pat>;`\n-                // statement.\n-                let (binding_mode, ident, is_simple_pattern) = match input.pat.node {\n-                    PatKind::Ident(binding_mode @ BindingMode::ByValue(_), ident, _) => {\n-                        // Simple patterns like this don't have a generated argument, but they are\n-                        // moved into the closure with a statement, so any `mut` bindings on the\n-                        // argument will be unused. This binding mode can't be removed, because\n-                        // this would affect the input to procedural macros, but they can have\n-                        // their span marked as being the result of a compiler desugaring so\n-                        // that they aren't linted against.\n-                        input.pat.span = desugared_span;\n-\n-                        (binding_mode, ident, true)\n-                    }\n-                    _ => (BindingMode::ByValue(Mutability::Mutable), ident, false),\n-                };\n-\n-                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n-                // async function if it isn't a simple pattern.\n-                let arg = if is_simple_pattern {\n-                    None\n-                } else {\n-                    Some(Arg {\n-                        ty: input.ty.clone(),\n-                        id,\n-                        pat: P(Pat {\n-                            id,\n-                            node: PatKind::Ident(\n-                                BindingMode::ByValue(Mutability::Immutable), ident, None,\n-                            ),\n-                            span: desugared_span,\n-                        }),\n-                        source: ArgSource::AsyncFn(input.pat.clone()),\n-                    })\n-                };\n-\n-                // Construct a `let __argN = __argN;` statement to insert at the top of the\n-                // async closure. This makes sure that the argument is captured by the closure and\n-                // that the drop order is correct.\n-                let move_local = Local {\n-                    pat: P(Pat {\n-                        id,\n-                        node: PatKind::Ident(binding_mode, ident, None),\n-                        span: desugared_span,\n-                    }),\n-                    // We explicitly do not specify the type for this statement. When the user's\n-                    // argument type is `impl Trait` then this would require the\n-                    // `impl_trait_in_bindings` feature to also be present for that same type to\n-                    // be valid in this binding. At the time of writing (13 Mar 19),\n-                    // `impl_trait_in_bindings` is not stable.\n-                    ty: None,\n-                    init: Some(P(Expr {\n-                        id,\n-                        node: ExprKind::Path(None, ast::Path {\n-                            span,\n-                            segments: vec![PathSegment { ident, id, args: None }],\n-                        }),\n-                        span,\n-                        attrs: ThinVec::new(),\n-                    })),\n-                    id,\n-                    span,\n-                    attrs: ThinVec::new(),\n-                    source: LocalSource::AsyncFn,\n-                };\n-\n-                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n-                // async closure if this isn't a simple pattern.\n-                let pat_stmt = if is_simple_pattern {\n-                    None\n-                } else {\n-                    Some(Stmt {\n-                        id,\n-                        node: StmtKind::Local(P(Local {\n-                            pat: input.pat.clone(),\n-                            ..move_local.clone()\n-                        })),\n-                        span,\n-                    })\n-                };\n-\n-                let move_stmt = Stmt { id, node: StmtKind::Local(P(move_local)), span };\n-                arguments.push(AsyncArgument { ident, arg, pat_stmt, move_stmt });\n-            }\n-        }\n-    }\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, handler: &errors::Handler) {"}, {"sha": "b81dc53ef6836061b2a5b107b4da3cf994e00534", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -357,7 +357,7 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl,\n-                     header: &ast::FnHeader,\n+                     header: ast::FnHeader,\n                      name: ast::Ident,\n                      generics: &ast::Generics)\n                      -> String {\n@@ -1040,7 +1040,7 @@ impl<'a> State<'a> {\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 self.head(\"\")?;\n-                self.print_fn(decl, &ast::FnHeader::default(),\n+                self.print_fn(decl, ast::FnHeader::default(),\n                               Some(item.ident),\n                               generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n@@ -1170,7 +1170,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            ast::ItemKind::Fn(ref decl, ref header, ref param_names, ref body) => {\n+            ast::ItemKind::Fn(ref decl, header, ref param_names, ref body) => {\n                 self.head(\"\")?;\n                 self.print_fn(\n                     decl,\n@@ -1522,7 +1522,7 @@ impl<'a> State<'a> {\n                             vis: &ast::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n-                      &m.header,\n+                      m.header,\n                       Some(ident),\n                       &generics,\n                       vis)\n@@ -2113,7 +2113,7 @@ impl<'a> State<'a> {\n                 self.bclose_(expr.span, INDENT_UNIT)?;\n             }\n             ast::ExprKind::Closure(\n-                capture_clause, ref asyncness, movability, ref decl, ref body, _) => {\n+                capture_clause, asyncness, movability, ref decl, ref body, _) => {\n                 self.print_movability(movability)?;\n                 self.print_asyncness(asyncness)?;\n                 self.print_capture_clause(capture_clause)?;\n@@ -2710,7 +2710,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    header: &ast::FnHeader,\n+                    header: ast::FnHeader,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     vis: &ast::Visibility) -> io::Result<()> {\n@@ -2765,7 +2765,8 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_asyncness(&mut self, asyncness: &ast::IsAsync) -> io::Result<()> {\n+    pub fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n+                                -> io::Result<()> {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\")?;\n         }\n@@ -3037,7 +3038,7 @@ impl<'a> State<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n-                      &ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n+                      ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n                       name,\n                       &generics,\n                       &source_map::dummy_spanned(ast::VisibilityKind::Inherited))?;\n@@ -3100,7 +3101,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                header: &ast::FnHeader,\n+                                header: ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n         self.s.word(visibility_qualified(vis, \"\"))?;\n \n@@ -3109,7 +3110,7 @@ impl<'a> State<'a> {\n             ast::Constness::Const => self.word_nbsp(\"const\")?\n         }\n \n-        self.print_asyncness(&header.asyncness.node)?;\n+        self.print_asyncness(header.asyncness.node)?;\n         self.print_unsafety(header.unsafety)?;\n \n         if header.abi != Abi::Rust {\n@@ -3158,7 +3159,7 @@ mod tests {\n             assert_eq!(\n                 fun_to_string(\n                     &decl,\n-                    &ast::FnHeader {\n+                    ast::FnHeader {\n                         unsafety: ast::Unsafety::Normal,\n                         constness: source_map::dummy_spanned(ast::Constness::NotConst),\n                         asyncness: source_map::dummy_spanned(ast::IsAsync::NotAsync),"}, {"sha": "eb516b5c7c62fd7e5e07fcb865a1a206187ca509", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -544,9 +544,6 @@ pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FunctionR\n pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) {\n     for argument in &function_declaration.inputs {\n         visitor.visit_pat(&argument.pat);\n-        if let ArgSource::AsyncFn(pat) = &argument.source {\n-            visitor.visit_pat(pat);\n-        }\n         visitor.visit_ty(&argument.ty)\n     }\n     visitor.visit_fn_ret_ty(&function_declaration.output)"}, {"sha": "44ddbb98809b4f0d217bc234df31b15071520e35", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c78dd7aa692a9338b2085e8d227cde73d2a5f9/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=d0c78dd7aa692a9338b2085e8d227cde73d2a5f9", "patch": "@@ -129,7 +129,6 @@ fn stmt_let_undescore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n         attrs: ThinVec::new(),\n-        source: ast::LocalSource::Normal,\n     });\n     ast::Stmt {\n         id: ast::DUMMY_NODE_ID,"}]}