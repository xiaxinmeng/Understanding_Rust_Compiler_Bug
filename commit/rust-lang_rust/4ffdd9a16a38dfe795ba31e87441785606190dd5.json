{"sha": "4ffdd9a16a38dfe795ba31e87441785606190dd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZmRkOWExNmEzOGRmZTc5NWJhMzFlODc0NDE3ODU2MDYxOTBkZDU=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-22T21:20:46Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-26T11:11:12Z"}, "message": "Move function definitions before their first use", "tree": {"sha": "e9ed45e66bb0fb42db956bbcf6ff854157c2dd26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9ed45e66bb0fb42db956bbcf6ff854157c2dd26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ffdd9a16a38dfe795ba31e87441785606190dd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ffdd9a16a38dfe795ba31e87441785606190dd5", "html_url": "https://github.com/rust-lang/rust/commit/4ffdd9a16a38dfe795ba31e87441785606190dd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ffdd9a16a38dfe795ba31e87441785606190dd5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9", "html_url": "https://github.com/rust-lang/rust/commit/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9"}], "stats": {"total": 276, "additions": 138, "deletions": 138}, "files": [{"sha": "2aeb6df6dd6b9ec5141a9b8deb1ecb74aeb6853a", "filename": "src/librustc_mir/const_eval/query.rs", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/4ffdd9a16a38dfe795ba31e87441785606190dd5/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ffdd9a16a38dfe795ba31e87441785606190dd5/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs?ref=4ffdd9a16a38dfe795ba31e87441785606190dd5", "patch": "@@ -21,6 +21,144 @@ pub fn note_on_undefined_behavior_error() -> &'static str {\n      repository if you believe it should not be considered undefined behavior.\"\n }\n \n+// Returns a pointer to where the result lives\n+fn eval_body_using_ecx<'mir, 'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n+    cid: GlobalId<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n+) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n+    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n+    let tcx = ecx.tcx.tcx;\n+    let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n+    assert!(!layout.is_unsized());\n+    let ret = ecx.allocate(layout, MemoryKind::Stack);\n+\n+    let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n+    let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n+    trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n+\n+    // Assert all args (if any) are zero-sized types; `eval_body_using_ecx` doesn't\n+    // make sense if the body is expecting nontrivial arguments.\n+    // (The alternative would be to use `eval_fn_call` with an args slice.)\n+    for arg in body.args_iter() {\n+        let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n+        let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n+        assert!(layout.is_zst())\n+    }\n+\n+    ecx.push_stack_frame(\n+        cid.instance,\n+        body.span,\n+        body,\n+        Some(ret.into()),\n+        StackPopCleanup::None { cleanup: false },\n+    )?;\n+\n+    // The main interpreter loop.\n+    ecx.run()?;\n+\n+    // Intern the result\n+    intern_const_alloc_recursive(ecx, tcx.static_mutability(cid.instance.def_id()), ret)?;\n+\n+    debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n+    Ok(ret)\n+}\n+\n+/// The `InterpCx` is only meant to be used to do field and index projections into constants for\n+/// `simd_shuffle` and const patterns in match arms.\n+///\n+/// The function containing the `match` that is currently being analyzed may have generic bounds\n+/// that inform us about the generic bounds of the constant. E.g., using an associated constant\n+/// of a function's generic parameter will require knowledge about the bounds on the generic\n+/// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n+pub(super) fn mk_eval_cx<'mir, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n+    can_access_statics: bool,\n+) -> CompileTimeEvalContext<'mir, 'tcx> {\n+    debug!(\"mk_eval_cx: {:?}\", param_env);\n+    InterpCx::new(\n+        tcx.at(span),\n+        param_env,\n+        CompileTimeInterpreter::new(),\n+        MemoryExtra { can_access_statics },\n+    )\n+}\n+\n+pub(super) fn op_to_const<'tcx>(\n+    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n+    op: OpTy<'tcx>,\n+) -> &'tcx ty::Const<'tcx> {\n+    // We do not have value optimizations for everything.\n+    // Only scalars and slices, since they are very common.\n+    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n+    // from scalar unions that are initialized with one of their zero sized variants. We could\n+    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n+    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n+    // `Undef` situation.\n+    let try_as_immediate = match op.layout.abi {\n+        layout::Abi::Scalar(..) => true,\n+        layout::Abi::ScalarPair(..) => match op.layout.ty.kind {\n+            ty::Ref(_, inner, _) => match inner.kind {\n+                ty::Slice(elem) => elem == ecx.tcx.types.u8,\n+                ty::Str => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        },\n+        _ => false,\n+    };\n+    let immediate = if try_as_immediate {\n+        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n+    } else {\n+        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n+        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n+        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n+        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n+        // structs containing such.\n+        op.try_as_mplace()\n+    };\n+    let val = match immediate {\n+        Ok(mplace) => {\n+            let ptr = mplace.ptr.to_ptr().unwrap();\n+            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            ConstValue::ByRef { alloc, offset: ptr.offset }\n+        }\n+        // see comment on `let try_as_immediate` above\n+        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n+            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n+            ScalarMaybeUndef::Undef => {\n+                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n+                // argument and we will not need this. The only way we can already have an\n+                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n+                // comes from a constant so it can happen have `Undef`, because the indirect\n+                // memory that was read had undefined bytes.\n+                let mplace = op.assert_mem_place();\n+                let ptr = mplace.ptr.to_ptr().unwrap();\n+                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+                ConstValue::ByRef { alloc, offset: ptr.offset }\n+            }\n+        },\n+        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n+            let (data, start) = match a.not_undef().unwrap() {\n+                Scalar::Ptr(ptr) => {\n+                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n+                }\n+                Scalar::Raw { .. } => (\n+                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n+                    0,\n+                ),\n+            };\n+            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+            let start = start.try_into().unwrap();\n+            let len: usize = len.try_into().unwrap();\n+            ConstValue::Slice { data, start, end: start + len }\n+        }\n+    };\n+    ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n+}\n+\n fn validate_and_turn_into_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: RawConst<'tcx>,\n@@ -219,141 +357,3 @@ pub fn const_eval_raw_provider<'tcx>(\n             }\n         })\n }\n-\n-// Returns a pointer to where the result lives\n-fn eval_body_using_ecx<'mir, 'tcx>(\n-    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n-    cid: GlobalId<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n-    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n-    let tcx = ecx.tcx.tcx;\n-    let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n-    assert!(!layout.is_unsized());\n-    let ret = ecx.allocate(layout, MemoryKind::Stack);\n-\n-    let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n-    let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n-    trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n-\n-    // Assert all args (if any) are zero-sized types; `eval_body_using_ecx` doesn't\n-    // make sense if the body is expecting nontrivial arguments.\n-    // (The alternative would be to use `eval_fn_call` with an args slice.)\n-    for arg in body.args_iter() {\n-        let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n-        let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n-        assert!(layout.is_zst())\n-    }\n-\n-    ecx.push_stack_frame(\n-        cid.instance,\n-        body.span,\n-        body,\n-        Some(ret.into()),\n-        StackPopCleanup::None { cleanup: false },\n-    )?;\n-\n-    // The main interpreter loop.\n-    ecx.run()?;\n-\n-    // Intern the result\n-    intern_const_alloc_recursive(ecx, tcx.static_mutability(cid.instance.def_id()), ret)?;\n-\n-    debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n-    Ok(ret)\n-}\n-\n-/// The `InterpCx` is only meant to be used to do field and index projections into constants for\n-/// `simd_shuffle` and const patterns in match arms.\n-///\n-/// The function containing the `match` that is currently being analyzed may have generic bounds\n-/// that inform us about the generic bounds of the constant. E.g., using an associated constant\n-/// of a function's generic parameter will require knowledge about the bounds on the generic\n-/// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-pub(super) fn mk_eval_cx<'mir, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    param_env: ty::ParamEnv<'tcx>,\n-    can_access_statics: bool,\n-) -> CompileTimeEvalContext<'mir, 'tcx> {\n-    debug!(\"mk_eval_cx: {:?}\", param_env);\n-    InterpCx::new(\n-        tcx.at(span),\n-        param_env,\n-        CompileTimeInterpreter::new(),\n-        MemoryExtra { can_access_statics },\n-    )\n-}\n-\n-pub(super) fn op_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n-    op: OpTy<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n-    // We do not have value optimizations for everything.\n-    // Only scalars and slices, since they are very common.\n-    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n-    // from scalar unions that are initialized with one of their zero sized variants. We could\n-    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n-    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n-    // `Undef` situation.\n-    let try_as_immediate = match op.layout.abi {\n-        layout::Abi::Scalar(..) => true,\n-        layout::Abi::ScalarPair(..) => match op.layout.ty.kind {\n-            ty::Ref(_, inner, _) => match inner.kind {\n-                ty::Slice(elem) => elem == ecx.tcx.types.u8,\n-                ty::Str => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        },\n-        _ => false,\n-    };\n-    let immediate = if try_as_immediate {\n-        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n-    } else {\n-        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n-        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n-        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n-        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n-        // structs containing such.\n-        op.try_as_mplace()\n-    };\n-    let val = match immediate {\n-        Ok(mplace) => {\n-            let ptr = mplace.ptr.to_ptr().unwrap();\n-            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-            ConstValue::ByRef { alloc, offset: ptr.offset }\n-        }\n-        // see comment on `let try_as_immediate` above\n-        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n-            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n-            ScalarMaybeUndef::Undef => {\n-                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n-                // argument and we will not need this. The only way we can already have an\n-                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n-                // comes from a constant so it can happen have `Undef`, because the indirect\n-                // memory that was read had undefined bytes.\n-                let mplace = op.assert_mem_place();\n-                let ptr = mplace.ptr.to_ptr().unwrap();\n-                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                ConstValue::ByRef { alloc, offset: ptr.offset }\n-            }\n-        },\n-        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n-            let (data, start) = match a.not_undef().unwrap() {\n-                Scalar::Ptr(ptr) => {\n-                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n-                }\n-                Scalar::Raw { .. } => (\n-                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n-                    0,\n-                ),\n-            };\n-            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n-            let start = start.try_into().unwrap();\n-            let len: usize = len.try_into().unwrap();\n-            ConstValue::Slice { data, start, end: start + len }\n-        }\n-    };\n-    ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n-}"}]}