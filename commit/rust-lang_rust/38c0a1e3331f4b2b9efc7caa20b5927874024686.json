{"sha": "38c0a1e3331f4b2b9efc7caa20b5927874024686", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YzBhMWUzMzMxZjRiMmI5ZWZjN2NhYTIwYjU5Mjc4NzQwMjQ2ODY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-22T10:08:18Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-22T10:08:18Z"}, "message": "Merge #1184\n\n1184: Start structured editing API r=matklad a=matklad\n\nI think I finally understand how to provide nice, mutable structured editing API on top of red-green trees.\r\n\r\nThe problem I am trying to solve is that any modification to a particular `SyntaxNode` returns an independent new file. So, if you are editing a struct literal, and add a field, you get back a SourceFile, and you have to find the struct literal inside it yourself! This happens because our trees are immutable, but have parent pointers. \r\n\r\nThe main idea here is to introduce `AstEditor<T>` type, which abstracts away that API. So, you create an `AstEditor` for node you want to edit and call various `&mut` taking methods on it. Internally, `AstEditor` stores both the original node and the current node. All edits are applied to the current node, which is replaced by the corresponding node in the new file. In the end, `AstEditor` computes a text edit between old and new nodes.\r\n\r\nNote that this also should sole a problem when you create an anchor pointing to a subnode and mutate the parent node, invalidating anchor. Because mutation needs `&mut`, all anchors must be killed before modification. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "321dd22a931c2ca11d2e207d734f283844af656d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/321dd22a931c2ca11d2e207d734f283844af656d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38c0a1e3331f4b2b9efc7caa20b5927874024686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38c0a1e3331f4b2b9efc7caa20b5927874024686", "html_url": "https://github.com/rust-lang/rust/commit/38c0a1e3331f4b2b9efc7caa20b5927874024686", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38c0a1e3331f4b2b9efc7caa20b5927874024686/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "76e0129a21661029dc6cdbea2412ab53efe33aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/76e0129a21661029dc6cdbea2412ab53efe33aa1", "html_url": "https://github.com/rust-lang/rust/commit/76e0129a21661029dc6cdbea2412ab53efe33aa1"}, {"sha": "b73a978b95810b188090a37e002a22403a9067bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b73a978b95810b188090a37e002a22403a9067bd", "html_url": "https://github.com/rust-lang/rust/commit/b73a978b95810b188090a37e002a22403a9067bd"}], "stats": {"total": 765, "additions": 569, "deletions": 196}, "files": [{"sha": "3be73d66d8dfe137c04961b5c47d7113d0f9aaec", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -903,8 +903,10 @@ version = \"0.1.0\"\n name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n+ \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\",\n  \"ra_hir 0.1.0\","}, {"sha": "29d9ceb59c2816e1ffb40a818b6410234b211c87", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -5,8 +5,10 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n+lazy_static = \"1.3.0\"\n join_to_string = \"0.1.3\"\n itertools = \"0.8.0\"\n+arrayvec = \"0.4.10\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "17c2af89987d55aa5cb11f06ce76d52f34183554", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 38, "deletions": 111, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -1,14 +1,9 @@\n-use std::fmt::Write;\n-\n-use crate::{Assist, AssistId, AssistCtx};\n+use crate::{Assist, AssistId, AssistCtx, ast_editor::{AstEditor, AstBuilder}};\n \n use hir::db::HirDatabase;\n-use ra_syntax::{SmolStr, SyntaxKind, TextRange, TextUnit, TreeArc};\n-use ra_syntax::ast::{self, AstNode, AstToken, FnDef, ImplItem, ImplItemKind, NameOwner};\n+use ra_syntax::{SmolStr, TreeArc};\n+use ra_syntax::ast::{self, AstNode, FnDef, ImplItem, ImplItemKind, NameOwner};\n use ra_db::FilePosition;\n-use ra_fmt::{leading_indent, reindent};\n-\n-use itertools::Itertools;\n \n enum AddMissingImplMembersMode {\n     DefaultMethodsOnly,\n@@ -76,48 +71,35 @@ fn add_missing_impl_members_inner(\n     }\n \n     ctx.add_action(AssistId(assist_id), label, |edit| {\n-        let (parent_indent, indent) = {\n-            // FIXME: Find a way to get the indent already used in the file.\n-            // Now, we copy the indent of first item or indent with 4 spaces relative to impl block\n-            const DEFAULT_INDENT: &str = \"    \";\n-            let first_item = impl_item_list.impl_items().next();\n-            let first_item_indent =\n-                first_item.and_then(|i| leading_indent(i.syntax())).map(ToOwned::to_owned);\n-            let impl_block_indent = leading_indent(impl_node.syntax()).unwrap_or_default();\n-\n-            (\n-                impl_block_indent.to_owned(),\n-                first_item_indent.unwrap_or_else(|| impl_block_indent.to_owned() + DEFAULT_INDENT),\n-            )\n-        };\n-\n-        let changed_range = {\n-            let children = impl_item_list.syntax().children_with_tokens();\n-            let last_whitespace =\n-                children.filter_map(|it| ast::Whitespace::cast(it.as_token()?)).last();\n-\n-            last_whitespace.map(|w| w.syntax().range()).unwrap_or_else(|| {\n-                let in_brackets = impl_item_list.syntax().range().end() - TextUnit::of_str(\"}\");\n-                TextRange::from_to(in_brackets, in_brackets)\n-            })\n-        };\n-\n-        let func_bodies = format!(\"\\n{}\", missing_fns.into_iter().map(build_func_body).join(\"\\n\"));\n-        let trailing_whitespace = format!(\"\\n{}\", parent_indent);\n-        let func_bodies = reindent(&func_bodies, &indent) + &trailing_whitespace;\n-\n-        let replaced_text_range = TextUnit::of_str(&func_bodies);\n-\n-        edit.replace(changed_range, func_bodies);\n-        // FIXME: place the cursor on the first unimplemented?\n-        edit.set_cursor(\n-            changed_range.start() + replaced_text_range - TextUnit::of_str(&trailing_whitespace),\n-        );\n+        let n_existing_items = impl_item_list.impl_items().count();\n+        let fns = missing_fns.into_iter().map(add_body_and_strip_docstring).collect::<Vec<_>>();\n+\n+        let mut ast_editor = AstEditor::new(impl_item_list);\n+        if n_existing_items == 0 {\n+            ast_editor.make_multiline();\n+        }\n+        ast_editor.append_functions(fns.iter().map(|it| &**it));\n+        let first_new_item = ast_editor.ast().impl_items().nth(n_existing_items).unwrap();\n+        let cursor_poisition = first_new_item.syntax().range().start();\n+        ast_editor.into_text_edit(edit.text_edit_builder());\n+\n+        edit.set_cursor(cursor_poisition);\n     });\n \n     ctx.build()\n }\n \n+fn add_body_and_strip_docstring(fn_def: &ast::FnDef) -> TreeArc<ast::FnDef> {\n+    let mut ast_editor = AstEditor::new(fn_def);\n+    if fn_def.body().is_none() {\n+        ast_editor.set_body(&AstBuilder::<ast::Block>::single_expr(\n+            &AstBuilder::<ast::Expr>::unimplemented(),\n+        ));\n+    }\n+    ast_editor.strip_attrs_and_docs();\n+    ast_editor.ast().to_owned()\n+}\n+\n /// Given an `ast::ImplBlock`, resolves the target trait (the one being\n /// implemented) to a `ast::TraitDef`.\n fn resolve_target_trait_def(\n@@ -134,22 +116,6 @@ fn resolve_target_trait_def(\n     }\n }\n \n-fn build_func_body(def: &ast::FnDef) -> String {\n-    let mut buf = String::new();\n-\n-    for child in def.syntax().children_with_tokens() {\n-        match (child.prev_sibling_or_token().map(|c| c.kind()), child.kind()) {\n-            (_, SyntaxKind::SEMI) => buf.push_str(\" {\\n    unimplemented!()\\n}\"),\n-            (_, SyntaxKind::ATTR) | (_, SyntaxKind::COMMENT) => {}\n-            (Some(SyntaxKind::ATTR), SyntaxKind::WHITESPACE)\n-            | (Some(SyntaxKind::COMMENT), SyntaxKind::WHITESPACE) => {}\n-            _ => write!(buf, \"{}\", child).unwrap(),\n-        };\n-    }\n-\n-    buf.trim_end().to_string()\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -170,7 +136,7 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    <|>\n+<|>\n }\",\n             \"\n trait Foo {\n@@ -183,12 +149,9 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    fn foo(&self) {\n-        unimplemented!()\n-    }\n-    fn baz(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n+    fn baz(&self) { unimplemented!() }\n+\n }\",\n         );\n     }\n@@ -208,7 +171,7 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    <|>\n+<|>\n }\",\n             \"\n trait Foo {\n@@ -221,9 +184,8 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    fn foo(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n+\n }\",\n         );\n     }\n@@ -240,9 +202,7 @@ impl Foo for S { <|> }\",\n trait Foo { fn foo(&self); }\n struct S;\n impl Foo for S {\n-    fn foo(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n }\",\n         );\n     }\n@@ -259,9 +219,7 @@ impl Foo for S {}<|>\",\n trait Foo { fn foo(&self); }\n struct S;\n impl Foo for S {\n-    fn foo(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n }\",\n         )\n     }\n@@ -291,35 +249,6 @@ impl Foo for S { <|> }\",\n         )\n     }\n \n-    #[test]\n-    fn test_indented_impl_block() {\n-        check_assist(\n-            add_missing_impl_members,\n-            \"\n-trait Foo {\n-    fn valid(some: u32) -> bool;\n-}\n-struct S;\n-\n-mod my_mod {\n-    impl crate::Foo for S { <|> }\n-}\",\n-            \"\n-trait Foo {\n-    fn valid(some: u32) -> bool;\n-}\n-struct S;\n-\n-mod my_mod {\n-    impl crate::Foo for S {\n-        fn valid(some: u32) -> bool {\n-            unimplemented!()\n-        }<|>\n-    }\n-}\",\n-        )\n-    }\n-\n     #[test]\n     fn test_with_docstring_and_attrs() {\n         check_assist(\n@@ -342,9 +271,7 @@ trait Foo {\n }\n struct S;\n impl Foo for S {\n-    fn foo(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n }\"#,\n         )\n     }\n@@ -367,7 +294,7 @@ trait Foo {\n }\n struct S;\n impl Foo for S {\n-    fn valid(some: u32) -> bool { false }<|>\n+    <|>fn valid(some: u32) -> bool { false }\n }\",\n         )\n     }"}, {"sha": "f46de61eb6a3c2308ad24f8752feb08b87900721", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -161,6 +161,10 @@ impl AssistBuilder {\n         self.target = Some(target)\n     }\n \n+    pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n+        &mut self.edit\n+    }\n+\n     fn build(self) -> AssistAction {\n         AssistAction {\n             edit: self.edit.finish(),"}, {"sha": "6854294ae9e4db1bcf831cff7c8b122041ff5b5a", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -0,0 +1,333 @@\n+use std::{iter, ops::RangeInclusive};\n+\n+use arrayvec::ArrayVec;\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::{AstNode, TreeArc, ast, SyntaxKind::*, SyntaxElement, SourceFile, InsertPosition, Direction};\n+use ra_fmt::leading_indent;\n+\n+pub struct AstEditor<N: AstNode> {\n+    original_ast: TreeArc<N>,\n+    ast: TreeArc<N>,\n+}\n+\n+impl<N: AstNode> AstEditor<N> {\n+    pub fn new(node: &N) -> AstEditor<N> {\n+        AstEditor { original_ast: node.to_owned(), ast: node.to_owned() }\n+    }\n+\n+    pub fn into_text_edit(self, builder: &mut TextEditBuilder) {\n+        // FIXME: compute a more fine-grained diff here.\n+        // If *you* know a nice algorithm to compute diff between two syntax\n+        // tree, tell me about it!\n+        builder.replace(self.original_ast.syntax().range(), self.ast().syntax().text().to_string());\n+    }\n+\n+    pub fn ast(&self) -> &N {\n+        &*self.ast\n+    }\n+\n+    #[must_use]\n+    fn insert_children<'a>(\n+        &self,\n+        position: InsertPosition<SyntaxElement<'_>>,\n+        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+    ) -> TreeArc<N> {\n+        let new_syntax = self.ast().syntax().insert_children(position, to_insert);\n+        N::cast(&new_syntax).unwrap().to_owned()\n+    }\n+\n+    #[must_use]\n+    fn replace_children<'a>(\n+        &self,\n+        to_delete: RangeInclusive<SyntaxElement<'_>>,\n+        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+    ) -> TreeArc<N> {\n+        let new_syntax = self.ast().syntax().replace_children(to_delete, to_insert);\n+        N::cast(&new_syntax).unwrap().to_owned()\n+    }\n+\n+    fn do_make_multiline(&mut self) {\n+        let l_curly =\n+            match self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY) {\n+                Some(it) => it,\n+                None => return,\n+            };\n+        let sibling = match l_curly.next_sibling_or_token() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        let existing_ws = match sibling.as_token() {\n+            None => None,\n+            Some(tok) if tok.kind() != WHITESPACE => None,\n+            Some(ws) => {\n+                if ws.text().contains('\\n') {\n+                    return;\n+                }\n+                Some(ws)\n+            }\n+        };\n+\n+        let indent = leading_indent(self.ast().syntax()).unwrap_or(\"\");\n+        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+        let to_insert = iter::once(ws.ws().into());\n+        self.ast = match existing_ws {\n+            None => self.insert_children(InsertPosition::After(l_curly), to_insert),\n+            Some(ws) => self.replace_children(RangeInclusive::new(ws.into(), ws.into()), to_insert),\n+        };\n+    }\n+}\n+\n+impl AstEditor<ast::NamedFieldList> {\n+    pub fn append_field(&mut self, field: &ast::NamedField) {\n+        self.insert_field(InsertPosition::Last, field)\n+    }\n+\n+    pub fn make_multiline(&mut self) {\n+        self.do_make_multiline()\n+    }\n+\n+    pub fn insert_field(\n+        &mut self,\n+        position: InsertPosition<&'_ ast::NamedField>,\n+        field: &ast::NamedField,\n+    ) {\n+        let is_multiline = self.ast().syntax().text().contains('\\n');\n+        let ws;\n+        let space = if is_multiline {\n+            ws = tokens::WsBuilder::new(&format!(\n+                \"\\n{}    \",\n+                leading_indent(self.ast().syntax()).unwrap_or(\"\")\n+            ));\n+            ws.ws()\n+        } else {\n+            tokens::single_space()\n+        };\n+\n+        let mut to_insert: ArrayVec<[SyntaxElement; 4]> = ArrayVec::new();\n+        to_insert.push(space.into());\n+        to_insert.push(field.syntax().into());\n+        to_insert.push(tokens::comma().into());\n+\n+        macro_rules! after_l_curly {\n+            () => {{\n+                let anchor = match self.l_curly() {\n+                    Some(it) => it,\n+                    None => return,\n+                };\n+                InsertPosition::After(anchor)\n+            }};\n+        }\n+\n+        macro_rules! after_field {\n+            ($anchor:expr) => {\n+                if let Some(comma) = $anchor\n+                    .syntax()\n+                    .siblings_with_tokens(Direction::Next)\n+                    .find(|it| it.kind() == COMMA)\n+                {\n+                    InsertPosition::After(comma)\n+                } else {\n+                    to_insert.insert(0, tokens::comma().into());\n+                    InsertPosition::After($anchor.syntax().into())\n+                }\n+            };\n+        };\n+\n+        let position = match position {\n+            InsertPosition::First => after_l_curly!(),\n+            InsertPosition::Last => {\n+                if !is_multiline {\n+                    // don't insert comma before curly\n+                    to_insert.pop();\n+                }\n+                match self.ast().fields().last() {\n+                    Some(it) => after_field!(it),\n+                    None => after_l_curly!(),\n+                }\n+            }\n+            InsertPosition::Before(anchor) => InsertPosition::Before(anchor.syntax().into()),\n+            InsertPosition::After(anchor) => after_field!(anchor),\n+        };\n+\n+        self.ast = self.insert_children(position, to_insert.iter().cloned());\n+    }\n+\n+    fn l_curly(&self) -> Option<SyntaxElement> {\n+        self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY)\n+    }\n+}\n+\n+impl AstEditor<ast::ItemList> {\n+    pub fn make_multiline(&mut self) {\n+        self.do_make_multiline()\n+    }\n+\n+    pub fn append_functions<'a>(&mut self, fns: impl Iterator<Item = &'a ast::FnDef>) {\n+        fns.for_each(|it| self.append_function(it))\n+    }\n+\n+    pub fn append_function(&mut self, fn_def: &ast::FnDef) {\n+        let (indent, position) = match self.ast().impl_items().last() {\n+            Some(it) => (\n+                leading_indent(it.syntax()).unwrap_or(\"\").to_string(),\n+                InsertPosition::After(it.syntax().into()),\n+            ),\n+            None => match self.l_curly() {\n+                Some(it) => (\n+                    \"    \".to_string() + leading_indent(self.ast().syntax()).unwrap_or(\"\"),\n+                    InsertPosition::After(it),\n+                ),\n+                None => return,\n+            },\n+        };\n+        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+        let to_insert: ArrayVec<[SyntaxElement; 2]> =\n+            [ws.ws().into(), fn_def.syntax().into()].into();\n+        self.ast = self.insert_children(position, to_insert.into_iter());\n+    }\n+\n+    fn l_curly(&self) -> Option<SyntaxElement> {\n+        self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY)\n+    }\n+}\n+\n+impl AstEditor<ast::FnDef> {\n+    pub fn set_body(&mut self, body: &ast::Block) {\n+        let mut to_insert: ArrayVec<[SyntaxElement; 2]> = ArrayVec::new();\n+        let old_body_or_semi: SyntaxElement = if let Some(old_body) = self.ast().body() {\n+            old_body.syntax().into()\n+        } else if let Some(semi) = self.ast().semicolon_token() {\n+            to_insert.push(tokens::single_space().into());\n+            semi.into()\n+        } else {\n+            to_insert.push(tokens::single_space().into());\n+            to_insert.push(body.syntax().into());\n+            self.ast = self.insert_children(InsertPosition::Last, to_insert.into_iter());\n+            return;\n+        };\n+        to_insert.push(body.syntax().into());\n+        let replace_range = RangeInclusive::new(old_body_or_semi, old_body_or_semi);\n+        self.ast = self.replace_children(replace_range, to_insert.into_iter())\n+    }\n+\n+    pub fn strip_attrs_and_docs(&mut self) {\n+        loop {\n+            if let Some(start) = self\n+                .ast()\n+                .syntax()\n+                .children_with_tokens()\n+                .find(|it| it.kind() == ATTR || it.kind() == COMMENT)\n+            {\n+                let end = match start.next_sibling_or_token() {\n+                    Some(el) if el.kind() == WHITESPACE => el,\n+                    Some(_) | None => start,\n+                };\n+                self.ast = self.replace_children(RangeInclusive::new(start, end), iter::empty());\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AstBuilder<N: AstNode> {\n+    _phantom: std::marker::PhantomData<N>,\n+}\n+\n+impl AstBuilder<ast::NamedField> {\n+    fn from_text(text: &str) -> TreeArc<ast::NamedField> {\n+        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n+    }\n+\n+    pub fn from_pieces(name: &ast::NameRef, expr: Option<&ast::Expr>) -> TreeArc<ast::NamedField> {\n+        match expr {\n+            Some(expr) => Self::from_text(&format!(\"{}: {}\", name.syntax(), expr.syntax())),\n+            None => Self::from_text(&name.syntax().to_string()),\n+        }\n+    }\n+}\n+\n+impl AstBuilder<ast::Block> {\n+    fn from_text(text: &str) -> TreeArc<ast::Block> {\n+        ast_node_from_file_text(&format!(\"fn f() {}\", text))\n+    }\n+\n+    pub fn single_expr(e: &ast::Expr) -> TreeArc<ast::Block> {\n+        Self::from_text(&format!(\"{{ {} }}\", e.syntax()))\n+    }\n+}\n+\n+impl AstBuilder<ast::Expr> {\n+    fn from_text(text: &str) -> TreeArc<ast::Expr> {\n+        ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n+    }\n+\n+    pub fn unit() -> TreeArc<ast::Expr> {\n+        Self::from_text(\"()\")\n+    }\n+\n+    pub fn unimplemented() -> TreeArc<ast::Expr> {\n+        Self::from_text(\"unimplemented!()\")\n+    }\n+}\n+\n+impl AstBuilder<ast::NameRef> {\n+    pub fn new(text: &str) -> TreeArc<ast::NameRef> {\n+        ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n+    }\n+}\n+\n+fn ast_node_from_file_text<N: AstNode>(text: &str) -> TreeArc<N> {\n+    let file = SourceFile::parse(text);\n+    let res = file.syntax().descendants().find_map(N::cast).unwrap().to_owned();\n+    res\n+}\n+\n+mod tokens {\n+    use lazy_static::lazy_static;\n+    use ra_syntax::{AstNode, SourceFile, TreeArc, SyntaxToken, SyntaxKind::*};\n+\n+    lazy_static! {\n+        static ref SOURCE_FILE: TreeArc<SourceFile> = SourceFile::parse(\",\\n; ;\");\n+    }\n+\n+    pub(crate) fn comma() -> SyntaxToken<'static> {\n+        SOURCE_FILE\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == COMMA)\n+            .unwrap()\n+    }\n+\n+    pub(crate) fn single_space() -> SyntaxToken<'static> {\n+        SOURCE_FILE\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \" \")\n+            .unwrap()\n+    }\n+\n+    #[allow(unused)]\n+    pub(crate) fn single_newline() -> SyntaxToken<'static> {\n+        SOURCE_FILE\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\")\n+            .unwrap()\n+    }\n+\n+    pub(crate) struct WsBuilder(TreeArc<SourceFile>);\n+\n+    impl WsBuilder {\n+        pub(crate) fn new(text: &str) -> WsBuilder {\n+            WsBuilder(SourceFile::parse(text))\n+        }\n+        pub(crate) fn ws(&self) -> SyntaxToken<'_> {\n+            self.0.syntax().first_child_or_token().unwrap().as_token().unwrap()\n+        }\n+    }\n+\n+}"}, {"sha": "54b70e17dd54c38c3fd5059470680ceba2a385f8", "filename": "crates/ra_assists/src/fill_struct_fields.rs", "status": "modified", "additions": 65, "deletions": 77, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -1,94 +1,55 @@\n-use std::fmt::Write;\n-\n use hir::{AdtDef, db::HirDatabase};\n \n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{AssistCtx, Assist, AssistId};\n+use crate::{AssistCtx, Assist, AssistId, ast_editor::{AstEditor, AstBuilder}};\n \n pub(crate) fn fill_struct_fields(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let struct_lit = ctx.node_at_offset::<ast::StructLit>()?;\n-    let mut fsf = FillStructFields {\n-        ctx: &mut ctx,\n-        named_field_list: struct_lit.named_field_list()?,\n-        struct_fields: vec![],\n-        struct_lit,\n-    };\n-    fsf.evaluate_struct_def_fields()?;\n-    if fsf.struct_lit_and_def_have_the_same_number_of_fields() {\n-        return None;\n-    }\n-    fsf.remove_already_included_fields()?;\n-    fsf.add_action()?;\n-    ctx.build()\n-}\n+    let named_field_list = struct_lit.named_field_list()?;\n \n-struct FillStructFields<'a, 'b: 'a, DB> {\n-    ctx: &'a mut AssistCtx<'b, DB>,\n-    named_field_list: &'a ast::NamedFieldList,\n-    struct_fields: Vec<(String, String)>,\n-    struct_lit: &'a ast::StructLit,\n-}\n-\n-impl<DB> FillStructFields<'_, '_, DB>\n-where\n-    DB: HirDatabase,\n-{\n-    fn add_action(&mut self) -> Option<()> {\n-        let named_field_list = self.named_field_list;\n-        let struct_fields_string = self.struct_fields_string()?;\n-        let struct_lit = self.struct_lit;\n-        self.ctx.add_action(AssistId(\"fill_struct_fields\"), \"fill struct fields\", |edit| {\n-            edit.target(struct_lit.syntax().range());\n-            edit.set_cursor(struct_lit.syntax().range().start());\n-            edit.replace_node_and_indent(named_field_list.syntax(), struct_fields_string);\n-        });\n-        Some(())\n-    }\n-\n-    fn struct_lit_and_def_have_the_same_number_of_fields(&self) -> bool {\n-        self.named_field_list.fields().count() == self.struct_fields.len()\n-    }\n-\n-    fn evaluate_struct_def_fields(&mut self) -> Option<()> {\n-        let analyzer = hir::SourceAnalyzer::new(\n-            self.ctx.db,\n-            self.ctx.frange.file_id,\n-            self.struct_lit.syntax(),\n-            None,\n-        );\n-        let struct_lit_ty = analyzer.type_of(self.ctx.db, self.struct_lit.into())?;\n+    // Collect all fields from struct definition\n+    let mut fields = {\n+        let analyzer =\n+            hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, struct_lit.syntax(), None);\n+        let struct_lit_ty = analyzer.type_of(ctx.db, struct_lit.into())?;\n         let struct_def = match struct_lit_ty.as_adt() {\n             Some((AdtDef::Struct(s), _)) => s,\n             _ => return None,\n         };\n-        self.struct_fields = struct_def\n-            .fields(self.ctx.db)\n-            .into_iter()\n-            .map(|f| (f.name(self.ctx.db).to_string(), \"()\".into()))\n-            .collect();\n-        Some(())\n-    }\n+        struct_def.fields(ctx.db)\n+    };\n \n-    fn remove_already_included_fields(&mut self) -> Option<()> {\n-        for ast_field in self.named_field_list.fields() {\n-            let expr = ast_field.expr()?.syntax().text().to_string();\n-            let name_from_ast = ast_field.name_ref()?.text().to_string();\n-            if let Some(idx) = self.struct_fields.iter().position(|(n, _)| n == &name_from_ast) {\n-                self.struct_fields[idx] = (name_from_ast, expr);\n-            }\n-        }\n-        Some(())\n+    // Filter out existing fields\n+    for ast_field in named_field_list.fields() {\n+        let name_from_ast = ast_field.name_ref()?.text().to_string();\n+        fields.retain(|field| field.name(ctx.db).to_string() != name_from_ast);\n+    }\n+    if fields.is_empty() {\n+        return None;\n     }\n \n-    fn struct_fields_string(&mut self) -> Option<String> {\n-        let mut buf = String::from(\"{\\n\");\n-        for (name, expr) in &self.struct_fields {\n-            write!(&mut buf, \"    {}: {},\\n\", name, expr).unwrap();\n+    let db = ctx.db;\n+    ctx.add_action(AssistId(\"fill_struct_fields\"), \"fill struct fields\", |edit| {\n+        let mut ast_editor = AstEditor::new(named_field_list);\n+        if named_field_list.fields().count() == 0 && fields.len() > 2 {\n+            ast_editor.make_multiline();\n+        };\n+\n+        for field in fields {\n+            let field = AstBuilder::<ast::NamedField>::from_pieces(\n+                &AstBuilder::<ast::NameRef>::new(&field.name(db).to_string()),\n+                Some(&AstBuilder::<ast::Expr>::unit()),\n+            );\n+            ast_editor.append_field(&field);\n         }\n-        buf.push_str(\"}\");\n-        Some(buf)\n-    }\n+\n+        edit.target(struct_lit.syntax().range());\n+        edit.set_cursor(struct_lit.syntax().range().start());\n+\n+        ast_editor.into_text_edit(edit.text_edit_builder());\n+    });\n+    ctx.build()\n }\n \n #[cfg(test)]\n@@ -225,14 +186,41 @@ mod tests {\n \n             fn main() {\n                 let s = <|>S {\n+                    c: (1, 2),\n+                    e: \"foo\",\n                     a: (),\n                     b: (),\n-                    c: (1, 2),\n                     d: (),\n-                    e: \"foo\",\n                 }\n             }\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn fill_struct_short() {\n+        check_assist(\n+            fill_struct_fields,\n+            r#\"\n+            struct S {\n+                foo: u32,\n+                bar: String,\n+            }\n+\n+            fn main() {\n+                let s = S {<|> };\n+            }\n+            \"#,\n+            r#\"\n+            struct S {\n+                foo: u32,\n+                bar: String,\n+            }\n+\n+            fn main() {\n+                let s = <|>S { foo: (), bar: () };\n+            }\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "60b4d5c6390f112aaee3af5b4fc18f54f1cd039e", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -7,6 +7,7 @@\n \n mod assist_ctx;\n mod marks;\n+pub mod ast_editor;\n \n use itertools::Itertools;\n \n@@ -36,7 +37,7 @@ pub struct AssistAction {\n     pub target: Option<TextRange>,\n }\n \n-/// Return all the assists applicable at the given position.\n+/// Return all the assists eapplicable at the given position.\n ///\n /// Assists are returned in the \"unresolved\" state, that is only labels are\n /// returned, without actual edits."}, {"sha": "278b1b797df5a46fe3731e53e5ecabda77baeba9", "filename": "crates/ra_ide_api/src/completion/complete_postfix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -40,7 +40,7 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n             ctx,\n             \"match\",\n             \"match expr {}\",\n-            &format!(\"match {} {{\\n${{1:_}} => {{$0\\\\}},\\n}}\", receiver_text),\n+            &format!(\"match {} {{\\n    ${{1:_}} => {{$0\\\\}},\\n}}\", receiver_text),\n         )\n         .add_to(acc);\n         postfix_snippet("}, {"sha": "3bbc9e3c414f2c0cd44b7f8be6c5b80b474910a4", "filename": "crates/ra_ide_api/src/completion/snapshots/completion_item__postfix_completion_works_for_trivial_path_expression.snap", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__postfix_completion_works_for_trivial_path_expression.snap", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__postfix_completion_works_for_trivial_path_expression.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__postfix_completion_works_for_trivial_path_expression.snap?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -1,6 +1,6 @@\n ---\n-created: \"2019-02-18T09:22:24.127119709Z\"\n-creator: insta@0.6.2\n+created: \"2019-04-22T07:37:13.981826301Z\"\n+creator: insta@0.7.4\n source: crates/ra_ide_api/src/completion/completion_item.rs\n expression: kind_completions\n ---\n@@ -23,7 +23,7 @@ expression: kind_completions\n         label: \"match\",\n         source_range: [76; 76),\n         delete: [72; 76),\n-        insert: \"match bar {\\n${1:_} => {$0\\\\},\\n}\",\n+        insert: \"match bar {\\n    ${1:_} => {$0\\\\},\\n}\",\n         detail: \"match expr {}\"\n     },\n     CompletionItem {"}, {"sha": "9cbd2c6b8132e60977195d9e4023aaeb4a81d8b7", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -210,6 +210,15 @@ impl ast::EnumVariant {\n     }\n }\n \n+impl ast::FnDef {\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken<'_>> {\n+        self.syntax()\n+            .last_child_or_token()\n+            .and_then(|it| it.as_token())\n+            .filter(|it| it.kind() == SEMI)\n+    }\n+}\n+\n impl ast::LetStmt {\n     pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child_or_token() {"}, {"sha": "9cb66b76b3b378d067d5e9ae281de80fea0452af", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -38,7 +38,7 @@ pub use crate::{\n     ast::AstNode,\n     syntax_error::{SyntaxError, SyntaxErrorKind, Location},\n     syntax_text::SyntaxText,\n-    syntax_node::{Direction,  SyntaxNode, WalkEvent, TreeArc, SyntaxTreeBuilder, SyntaxElement, SyntaxToken},\n+    syntax_node::{Direction,  SyntaxNode, WalkEvent, TreeArc, SyntaxTreeBuilder, SyntaxElement, SyntaxToken, InsertPosition},\n     ptr::{SyntaxNodePtr, AstPtr},\n     parsing::{tokenize, classify_literal, Token},\n };"}, {"sha": "b0816b13523341c2bbd641413fa1503c319b6101", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -10,7 +10,7 @@ use crate::{\n /// specific node across reparses of the same file.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct SyntaxNodePtr {\n-    range: TextRange,\n+    pub(crate) range: TextRange,\n     kind: SyntaxKind,\n }\n "}, {"sha": "92c15234e650a81b6b4c579508a6e469299e3655", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c0a1e3331f4b2b9efc7caa20b5927874024686/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=38c0a1e3331f4b2b9efc7caa20b5927874024686", "patch": "@@ -7,6 +7,7 @@\n //! modules just wraps its API.\n \n use std::{\n+    ops::RangeInclusive,\n     fmt::{self, Write},\n     any::Any,\n     borrow::Borrow,\n@@ -17,13 +18,21 @@ use ra_parser::ParseError;\n use rowan::{TransparentNewType, GreenNodeBuilder};\n \n use crate::{\n-    SmolStr, SyntaxKind, TextUnit, TextRange, SyntaxText, SourceFile, AstNode,\n+    SmolStr, SyntaxKind, TextUnit, TextRange, SyntaxText, SourceFile, AstNode, SyntaxNodePtr,\n     syntax_error::{SyntaxError, SyntaxErrorKind},\n };\n \n pub use rowan::WalkEvent;\n pub(crate) use rowan::{GreenNode, GreenToken};\n \n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum InsertPosition<T> {\n+    First,\n+    Last,\n+    Before(T),\n+    After(T),\n+}\n+\n /// Marker trait for CST and AST nodes\n pub trait SyntaxNodeWrapper: TransparentNewType<Repr = rowan::SyntaxNode> {}\n impl<T: TransparentNewType<Repr = rowan::SyntaxNode>> SyntaxNodeWrapper for T {}\n@@ -309,6 +318,97 @@ impl SyntaxNode {\n     pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n         self.0.replace_with(replacement)\n     }\n+\n+    /// Adds specified children (tokens or nodes) to the current node at the\n+    /// specific position.\n+    ///\n+    /// This is a type-unsafe low-level editing API, if you need to use it,\n+    /// prefer to create a type-safe abstraction on top of it instead.\n+    pub fn insert_children<'a>(\n+        &self,\n+        position: InsertPosition<SyntaxElement<'_>>,\n+        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+    ) -> TreeArc<SyntaxNode> {\n+        let mut delta = TextUnit::default();\n+        let to_insert = to_insert.map(|element| {\n+            delta += element.text_len();\n+            to_green_element(element)\n+        });\n+\n+        let old_children = self.0.green().children();\n+\n+        let new_children = match position {\n+            InsertPosition::First => {\n+                to_insert.chain(old_children.iter().cloned()).collect::<Box<[_]>>()\n+            }\n+            InsertPosition::Last => {\n+                old_children.iter().cloned().chain(to_insert).collect::<Box<[_]>>()\n+            }\n+            InsertPosition::Before(anchor) | InsertPosition::After(anchor) => {\n+                let take_anchor = if let InsertPosition::After(_) = position { 1 } else { 0 };\n+                let split_at = self.position_of_child(anchor) + take_anchor;\n+                let (before, after) = old_children.split_at(split_at);\n+                before\n+                    .iter()\n+                    .cloned()\n+                    .chain(to_insert)\n+                    .chain(after.iter().cloned())\n+                    .collect::<Box<[_]>>()\n+            }\n+        };\n+\n+        self.with_children(new_children)\n+    }\n+\n+    /// Replaces all nodes in `to_delete` with nodes from `to_insert`\n+    ///\n+    /// This is a type-unsafe low-level editing API, if you need to use it,\n+    /// prefer to create a type-safe abstraction on top of it instead.\n+    pub fn replace_children<'a>(\n+        &self,\n+        to_delete: RangeInclusive<SyntaxElement<'_>>,\n+        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+    ) -> TreeArc<SyntaxNode> {\n+        let start = self.position_of_child(*to_delete.start());\n+        let end = self.position_of_child(*to_delete.end());\n+        let old_children = self.0.green().children();\n+\n+        let new_children = old_children[..start]\n+            .iter()\n+            .cloned()\n+            .chain(to_insert.map(to_green_element))\n+            .chain(old_children[end + 1..].iter().cloned())\n+            .collect::<Box<[_]>>();\n+        self.with_children(new_children)\n+    }\n+\n+    fn with_children(&self, new_children: Box<[rowan::GreenElement]>) -> TreeArc<SyntaxNode> {\n+        let len = new_children.iter().map(|it| it.text_len()).sum::<TextUnit>();\n+        let new_node = GreenNode::new(rowan::SyntaxKind(self.kind() as u16), new_children);\n+        let new_file_node = self.replace_with(new_node);\n+        let file = SourceFile::new(new_file_node, Vec::new());\n+\n+        // FIXME: use a more elegant way to re-fetch the node (#1185), make\n+        // `range` private afterwards\n+        let mut ptr = SyntaxNodePtr::new(self);\n+        ptr.range = TextRange::offset_len(ptr.range().start(), len);\n+        return ptr.to_node(&file).to_owned();\n+    }\n+\n+    fn position_of_child(&self, child: SyntaxElement) -> usize {\n+        self.children_with_tokens()\n+            .position(|it| it == child)\n+            .expect(\"elemetn is not a child of current element\")\n+    }\n+}\n+\n+fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n+    match element {\n+        SyntaxElement::Node(node) => node.0.green().clone().into(),\n+        SyntaxElement::Token(tok) => {\n+            GreenToken::new(rowan::SyntaxKind(tok.kind() as u16), tok.text().clone()).into()\n+        }\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n@@ -451,6 +551,13 @@ impl<'a> SyntaxElement<'a> {\n         }\n         .ancestors()\n     }\n+\n+    fn text_len(&self) -> TextUnit {\n+        match self {\n+            SyntaxElement::Node(node) => node.0.green().text_len(),\n+            SyntaxElement::Token(token) => TextUnit::of_str(token.0.text()),\n+        }\n+    }\n }\n \n impl<'a> From<rowan::SyntaxElement<'a>> for SyntaxElement<'a> {"}]}