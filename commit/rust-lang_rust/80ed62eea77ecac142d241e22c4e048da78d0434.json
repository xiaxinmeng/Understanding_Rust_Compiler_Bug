{"sha": "80ed62eea77ecac142d241e22c4e048da78d0434", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZWQ2MmVlYTc3ZWNhYzE0MmQyNDFlMjJjNGUwNDhkYTc4ZDA0MzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-12T18:47:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:30:54Z"}, "message": "regionck: rustfmt", "tree": {"sha": "1ca73d9842690b28123afce828aa74d4523da5a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ca73d9842690b28123afce828aa74d4523da5a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80ed62eea77ecac142d241e22c4e048da78d0434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80ed62eea77ecac142d241e22c4e048da78d0434", "html_url": "https://github.com/rust-lang/rust/commit/80ed62eea77ecac142d241e22c4e048da78d0434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80ed62eea77ecac142d241e22c4e048da78d0434/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a1a0d3400bbbcac194efb6ef2b14eef9be5149", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a1a0d3400bbbcac194efb6ef2b14eef9be5149", "html_url": "https://github.com/rust-lang/rust/commit/c3a1a0d3400bbbcac194efb6ef2b14eef9be5149"}], "stats": {"total": 695, "additions": 388, "deletions": 307}, "files": [{"sha": "e3f9d6cd97ca8b42a6a2299e3c29b4510f0fd7ee", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 388, "deletions": 307, "changes": 695, "blob_url": "https://github.com/rust-lang/rust/blob/80ed62eea77ecac142d241e22c4e048da78d0434/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ed62eea77ecac142d241e22c4e048da78d0434/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=80ed62eea77ecac142d241e22c4e048da78d0434", "patch": "@@ -88,27 +88,32 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::region;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty};\n use rustc::infer;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::ty::adjustment;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, Ty};\n \n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::{self, PatKind};\n+use rustc_data_structures::sync::Lrc;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n-use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, PatKind};\n \n // a variation on try that just returns unit\n macro_rules! ignore_err {\n-    ($e:expr) => (match $e { Ok(e) => e, Err(_) => {\n-        debug!(\"ignoring mem-categorization error!\");\n-        return ()\n-    }})\n+    ($e:expr) => {\n+        match $e {\n+            Ok(e) => e,\n+            Err(_) => {\n+                debug!(\"ignoring mem-categorization error!\");\n+                return ();\n+            }\n+        }\n+    };\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -118,11 +123,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(id),\n-                                      id,\n-                                      Subject(subject),\n-                                      self.param_env);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(id),\n+            id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_body(body);\n@@ -136,18 +143,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n     /// types from which we should derive implied bounds, if any.\n-    pub fn regionck_item(&self,\n-                         item_id: ast::NodeId,\n-                         span: Span,\n-                         wf_tys: &[Ty<'tcx>]) {\n+    pub fn regionck_item(&self, item_id: ast::NodeId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n         let subject = self.tcx.hir.local_def_id(item_id);\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(item_id),\n-                                      item_id,\n-                                      Subject(subject),\n-                                      self.param_env);\n-        rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(item_id),\n+            item_id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n+        rcx.outlives_environment\n+            .add_implied_bounds(self, wf_tys, item_id, span);\n         rcx.visit_region_obligations(item_id);\n         rcx.resolve_regions_and_report_errors();\n     }\n@@ -160,17 +167,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// rest of type check and because sometimes we need type\n     /// inference to have completed before we can determine which\n     /// constraints to add.\n-    pub fn regionck_fn(&self,\n-                       fn_id: ast::NodeId,\n-                       body: &'gcx hir::Body) {\n+    pub fn regionck_fn(&self, fn_id: ast::NodeId, body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let node_id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(node_id),\n-                                      node_id,\n-                                      Subject(subject),\n-                                      self.param_env);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(node_id),\n+            node_id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n@@ -190,7 +197,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct RegionCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n     pub region_scope_tree: Lrc<region::ScopeTree>,\n@@ -208,7 +215,6 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject_def_id: DefId,\n-\n }\n \n impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n@@ -222,12 +228,13 @@ pub struct RepeatingScope(ast::NodeId);\n pub struct Subject(DefId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n-    pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-               RepeatingScope(initial_repeating_scope): RepeatingScope,\n-               initial_body_id: ast::NodeId,\n-               Subject(subject): Subject,\n-               param_env: ty::ParamEnv<'tcx>)\n-               -> RegionCtxt<'a, 'gcx, 'tcx> {\n+    pub fn new(\n+        fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+        RepeatingScope(initial_repeating_scope): RepeatingScope,\n+        initial_body_id: ast::NodeId,\n+        Subject(subject): Subject,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> RegionCtxt<'a, 'gcx, 'tcx> {\n         let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n         let outlives_environment = OutlivesEnvironment::new(param_env);\n         RegionCtxt {\n@@ -296,11 +303,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// closures, however, we save and restore any \"scoped state\"\n     /// before we invoke this function. (See `visit_fn` in the\n     /// `intravisit::Visitor` impl below.)\n-    fn visit_fn_body(&mut self,\n-                     id: ast::NodeId, // the id of the fn itself\n-                     body: &'gcx hir::Body,\n-                     span: Span)\n-    {\n+    fn visit_fn_body(\n+        &mut self,\n+        id: ast::NodeId, // the id of the fn itself\n+        body: &'gcx hir::Body,\n+        span: Span,\n+    ) {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n@@ -309,7 +317,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let call_site = region::Scope {\n             id: body.value.hir_id.local_id,\n-            data: region::ScopeData::CallSite\n+            data: region::ScopeData::CallSite,\n         };\n         self.call_site_scope = Some(call_site);\n \n@@ -328,41 +336,47 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // because it will have no effect.\n         //\n         // FIXME(#27579) return types should not be implied bounds\n-        let fn_sig_tys: Vec<_> =\n-            fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n+        let fn_sig_tys: Vec<_> = fn_sig\n+            .inputs()\n+            .iter()\n+            .cloned()\n+            .chain(Some(fn_sig.output()))\n+            .collect();\n \n         self.outlives_environment.add_implied_bounds(\n             self.fcx,\n             &fn_sig_tys[..],\n             body_id.node_id,\n-            span);\n+            span,\n+        );\n         self.link_fn_args(\n             region::Scope {\n                 id: body.value.hir_id.local_id,\n-                data: region::ScopeData::Node\n+                data: region::ScopeData::Node,\n             },\n-            &body.arguments);\n+            &body.arguments,\n+        );\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n-        debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n-               body.id(), call_site_scope);\n+        debug!(\n+            \"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n+            body.id(),\n+            call_site_scope\n+        );\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n \n         let body_hir_id = self.tcx.hir.node_to_hir_id(body_id.node_id);\n-        self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body_hir_id,\n-                                       call_site_region);\n+        self.type_of_node_must_outlive(infer::CallReturn(span), body_hir_id, call_site_region);\n \n         self.constrain_opaque_types(\n             &self.fcx.opaque_types.borrow(),\n             self.outlives_environment.free_region_map(),\n         );\n     }\n \n-    fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n-    {\n+    fn visit_region_obligations(&mut self, node_id: ast::NodeId) {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n \n         // region checking can introduce new pending obligations\n@@ -374,19 +388,24 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.outlives_environment.region_bound_pairs(),\n             self.implicit_region_bound,\n             self.param_env,\n-            self.body_id);\n+            self.body_id,\n+        );\n     }\n \n     fn resolve_regions_and_report_errors(&self) {\n-        self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n-                                                   &self.region_scope_tree,\n-                                                   &self.outlives_environment);\n+        self.fcx.resolve_regions_and_report_errors(\n+            self.subject_def_id,\n+            &self.region_scope_tree,\n+            &self.outlives_environment,\n+        );\n     }\n \n     fn resolve_regions_and_report_errors_unless_nll(&self) {\n-        self.fcx.resolve_regions_and_report_errors_unless_nll(self.subject_def_id,\n-                                                              &self.region_scope_tree,\n-                                                              &self.outlives_environment);\n+        self.fcx.resolve_regions_and_report_errors_unless_nll(\n+            self.subject_def_id,\n+            &self.region_scope_tree,\n+            &self.outlives_environment,\n+        );\n     }\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n@@ -423,7 +442,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let typ = self.resolve_node_type(hir_id);\n             let body_id = self.body_id;\n             let _ = dropck::check_safety_of_destructor_if_necessary(\n-                self, typ, span, body_id, var_scope);\n+                self, typ, span, body_id, var_scope,\n+            );\n         })\n     }\n }\n@@ -441,14 +461,21 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self,\n-                fk: intravisit::FnKind<'gcx>,\n-                _: &'gcx hir::FnDecl,\n-                body_id: hir::BodyId,\n-                span: Span,\n-                id: ast::NodeId) {\n-        assert!(match fk { intravisit::FnKind::Closure(..) => true, _ => false },\n-                \"visit_fn invoked for something other than a closure\");\n+    fn visit_fn(\n+        &mut self,\n+        fk: intravisit::FnKind<'gcx>,\n+        _: &'gcx hir::FnDecl,\n+        body_id: hir::BodyId,\n+        span: Span,\n+        id: ast::NodeId,\n+    ) {\n+        assert!(\n+            match fk {\n+                intravisit::FnKind::Closure(..) => true,\n+                _ => false,\n+            },\n+            \"visit_fn invoked for something other than a closure\"\n+        );\n \n         // Save state of current function before invoking\n         // `visit_fn_body`.  We will restore afterwards.\n@@ -460,7 +487,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         self.visit_fn_body(id, body, span);\n \n         // Restore state from previous function.\n-        self.outlives_environment.pop_snapshot_post_closure(env_snapshot);\n+        self.outlives_environment\n+            .pop_snapshot_post_closure(env_snapshot);\n         self.call_site_scope = old_call_site_scope;\n         self.body_id = old_body_id;\n     }\n@@ -483,20 +511,24 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n-        debug!(\"regionck::visit_expr(e={:?}, repeating_scope={})\",\n-               expr, self.repeating_scope);\n+        debug!(\n+            \"regionck::visit_expr(e={:?}, repeating_scope={})\",\n+            expr, self.repeating_scope\n+        );\n \n         // No matter what, the type of each expression must outlive the\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n-        let expr_region = self.tcx.mk_region(ty::ReScope(\n-            region::Scope {\n-                id: expr.hir_id.local_id,\n-                data: region::ScopeData::Node\n-            }));\n-        self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-                               expr_ty, expr_region);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n+            id: expr.hir_id.local_id,\n+            data: region::ScopeData::Node,\n+        }));\n+        self.type_must_outlive(\n+            infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n+            expr_ty,\n+            expr_region,\n+        );\n \n         let is_method_call = self.tables.borrow().is_method_call(expr);\n \n@@ -506,12 +538,11 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // provided as arguments outlive the call.\n         if is_method_call {\n             let origin = match expr.node {\n-                hir::ExprKind::MethodCall(..) =>\n-                    infer::ParameterOrigin::MethodCall,\n-                hir::ExprKind::Unary(op, _) if op == hir::UnDeref =>\n-                    infer::ParameterOrigin::OverloadedDeref,\n-                _ =>\n-                    infer::ParameterOrigin::OverloadedOperator\n+                hir::ExprKind::MethodCall(..) => infer::ParameterOrigin::MethodCall,\n+                hir::ExprKind::Unary(op, _) if op == hir::UnDeref => {\n+                    infer::ParameterOrigin::OverloadedDeref\n+                }\n+                _ => infer::ParameterOrigin::OverloadedOperator,\n             };\n \n             let substs = self.tables.borrow().node_substs(expr.hir_id);\n@@ -533,8 +564,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n-               expr, self.repeating_scope);\n+        debug!(\n+            \"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n+            expr, self.repeating_scope\n+        );\n         match expr.node {\n             hir::ExprKind::Path(_) => {\n                 let substs = self.tables.borrow().node_substs(expr.hir_id);\n@@ -571,7 +604,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n-            },\n+            }\n \n             hir::ExprKind::Binary(_, ref lhs, ref rhs) if is_method_call => {\n                 // As `ExprKind::MethodCall`, but the call is via an overloaded op.\n@@ -586,8 +619,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 let lhs_ty = self.resolve_expr_type_adjusted(&lhs);\n                 let rhs_ty = self.resolve_expr_type_adjusted(&rhs);\n                 for &ty in &[lhs_ty, rhs_ty] {\n-                    self.type_must_outlive(infer::Operand(expr.span),\n-                                           ty, expr_region);\n+                    self.type_must_outlive(infer::Operand(expr.span), ty, expr_region);\n                 }\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -674,12 +706,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n-                debug!(\"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n-                       ret_expr.id, call_site_scope);\n+                debug!(\n+                    \"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n+                    ret_expr.id, call_site_scope\n+                );\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n-                self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n-                                               ret_expr.hir_id,\n-                                               call_site_region);\n+                self.type_of_node_must_outlive(\n+                    infer::CallReturn(ret_expr.span),\n+                    ret_expr.hir_id,\n+                    call_site_region,\n+                );\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -691,54 +727,47 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n-    fn constrain_cast(&mut self,\n-                      cast_expr: &hir::Expr,\n-                      source_expr: &hir::Expr)\n-    {\n-        debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n-               cast_expr,\n-               source_expr);\n+    fn constrain_cast(&mut self, cast_expr: &hir::Expr, source_expr: &hir::Expr) {\n+        debug!(\n+            \"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n+            cast_expr, source_expr\n+        );\n \n         let source_ty = self.resolve_node_type(source_expr.hir_id);\n         let target_ty = self.resolve_node_type(cast_expr.hir_id);\n \n         self.walk_cast(cast_expr, source_ty, target_ty);\n     }\n \n-    fn walk_cast(&mut self,\n-                 cast_expr: &hir::Expr,\n-                 from_ty: Ty<'tcx>,\n-                 to_ty: Ty<'tcx>) {\n-        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\",\n-               from_ty,\n-               to_ty);\n+    fn walk_cast(&mut self, cast_expr: &hir::Expr, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n+        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\", from_ty, to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n-            /*From:*/ (&ty::Ref(from_r, from_ty, _),\n-            /*To:  */  &ty::Ref(to_r, to_ty, _)) => {\n+            /*From:*/\n+            (&ty::Ref(from_r, from_ty, _), /*To:  */ &ty::Ref(to_r, to_ty, _)) => {\n                 // Target cannot outlive source, naturally.\n                 self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n                 self.walk_cast(cast_expr, from_ty, to_ty);\n             }\n \n-            /*From:*/ (_,\n-            /*To:  */  &ty::Dynamic(.., r)) => {\n+            /*From:*/\n+            (_, /*To:  */ &ty::Dynamic(.., r)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n             }\n \n-            /*From:*/ (&ty::Adt(from_def, _),\n-            /*To:  */  &ty::Adt(to_def, _)) if from_def.is_box() && to_def.is_box() => {\n+            /*From:*/\n+            (&ty::Adt(from_def, _), /*To:  */ &ty::Adt(to_def, _))\n+                if from_def.is_box() && to_def.is_box() =>\n+            {\n                 self.walk_cast(cast_expr, from_ty.boxed_ty(), to_ty.boxed_ty());\n             }\n \n-            _ => { }\n+            _ => {}\n         }\n     }\n \n-    fn check_expr_fn_block(&mut self,\n-                           expr: &'gcx hir::Expr,\n-                           body_id: hir::BodyId) {\n+    fn check_expr_fn_block(&mut self, expr: &'gcx hir::Expr, body_id: hir::BodyId) {\n         let repeating_scope = self.set_repeating_scope(body_id.node_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n@@ -747,7 +776,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n         let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.sty {\n-            ty::FnDef(..) | ty::FnPtr(_) => { }\n+            ty::FnDef(..) | ty::FnPtr(_) => {}\n             _ => {\n                 // this should not happen, but it does if the program is\n                 // erroneous\n@@ -760,26 +789,29 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn constrain_call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-                                                           call_expr: &hir::Expr,\n-                                                           receiver: Option<&hir::Expr>,\n-                                                           arg_exprs: I) {\n+    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        call_expr: &hir::Expr,\n+        receiver: Option<&hir::Expr>,\n+        arg_exprs: I,\n+    ) {\n         //! Invoked on every call site (i.e., normal calls, method calls,\n         //! and overloaded operators). Constrains the regions which appear\n         //! in the type of the function. Also constrains the regions that\n         //! appear in the arguments appropriately.\n \n-        debug!(\"constrain_call(call_expr={:?}, receiver={:?})\",\n-                call_expr,\n-                receiver);\n+        debug!(\n+            \"constrain_call(call_expr={:?}, receiver={:?})\",\n+            call_expr, receiver\n+        );\n \n         // `callee_region` is the scope representing the time in which the\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n         let callee_scope = region::Scope {\n             id: call_expr.hir_id.local_id,\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         };\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n@@ -790,27 +822,30 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n             // ensure that any regions appearing in the argument type are\n             // valid for at least the lifetime of the function:\n-            self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n-                                           arg_expr.hir_id,\n-                                           callee_region);\n+            self.type_of_node_must_outlive(\n+                infer::CallArg(arg_expr.span),\n+                arg_expr.hir_id,\n+                callee_region,\n+            );\n         }\n \n         // as loop above, but for receiver\n         if let Some(r) = receiver {\n             debug!(\"receiver: {:?}\", r);\n-            self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n-                                           r.hir_id,\n-                                           callee_region);\n+            self.type_of_node_must_outlive(infer::CallRcvr(r.span), r.hir_id, callee_region);\n         }\n     }\n \n     /// Create a temporary `MemCategorizationContext` and pass it to the closure.\n     fn with_mc<F, R>(&self, f: F) -> R\n-        where F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R,\n     {\n-        f(mc::MemCategorizationContext::with_infer(&self.infcx,\n-                                                   &self.region_scope_tree,\n-                                                   &self.tables.borrow()))\n+        f(mc::MemCategorizationContext::with_infer(\n+            &self.infcx,\n+            &self.region_scope_tree,\n+            &self.tables.borrow(),\n+        ))\n     }\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n@@ -832,37 +867,46 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // expression.\n         self.check_safety_of_rvalue_destructor_if_necessary(&cmt, expr.span);\n \n-        let expr_region = self.tcx.mk_region(ty::ReScope(\n-            region::Scope {\n-                id: expr.hir_id.local_id,\n-                data: region::ScopeData::Node\n-            }));\n+        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n+            id: expr.hir_id.local_id,\n+            data: region::ScopeData::Node,\n+        }));\n         for adjustment in adjustments {\n-            debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n-                   adjustment, cmt);\n+            debug!(\n+                \"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n+                adjustment, cmt\n+            );\n \n             if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n                 debug!(\"constrain_adjustments: overloaded deref: {:?}\", deref);\n \n                 // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                 // was applied on the base type, as that is always the case.\n-                let input = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n-                    ty: cmt.ty,\n-                    mutbl: deref.mutbl,\n-                });\n-                let output = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n-                    ty: adjustment.target,\n-                    mutbl: deref.mutbl,\n-                });\n-\n-                self.link_region(expr.span, deref.region,\n-                                 ty::BorrowKind::from_mutbl(deref.mutbl), &cmt);\n+                let input = self.tcx.mk_ref(\n+                    deref.region,\n+                    ty::TypeAndMut {\n+                        ty: cmt.ty,\n+                        mutbl: deref.mutbl,\n+                    },\n+                );\n+                let output = self.tcx.mk_ref(\n+                    deref.region,\n+                    ty::TypeAndMut {\n+                        ty: adjustment.target,\n+                        mutbl: deref.mutbl,\n+                    },\n+                );\n+\n+                self.link_region(\n+                    expr.span,\n+                    deref.region,\n+                    ty::BorrowKind::from_mutbl(deref.mutbl),\n+                    &cmt,\n+                );\n \n                 // Specialized version of constrain_call.\n-                self.type_must_outlive(infer::CallRcvr(expr.span),\n-                                       input, expr_region);\n-                self.type_must_outlive(infer::CallReturn(expr.span),\n-                                       output, expr_region);\n+                self.type_must_outlive(infer::CallRcvr(expr.span), input, expr_region);\n+                self.type_must_outlive(infer::CallReturn(expr.span), output, expr_region);\n             }\n \n             if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n@@ -872,73 +916,84 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 // the current node.\n                 //\n                 // FIXME(#6268) remove to support nested method calls\n-                self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n-                                               expr.hir_id,\n-                                               expr_region);\n+                self.type_of_node_must_outlive(\n+                    infer::AutoBorrow(expr.span),\n+                    expr.hir_id,\n+                    expr_region,\n+                );\n             }\n \n             cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n \n             if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n-                self.mk_subregion_due_to_dereference(expr.span,\n-                                                     expr_region, r_ptr);\n+                self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n             }\n         }\n \n         Ok(cmt)\n     }\n \n-    pub fn mk_subregion_due_to_dereference(&mut self,\n-                                           deref_span: Span,\n-                                           minimum_lifetime: ty::Region<'tcx>,\n-                                           maximum_lifetime: ty::Region<'tcx>) {\n-        self.sub_regions(infer::DerefPointer(deref_span),\n-                         minimum_lifetime, maximum_lifetime)\n+    pub fn mk_subregion_due_to_dereference(\n+        &mut self,\n+        deref_span: Span,\n+        minimum_lifetime: ty::Region<'tcx>,\n+        maximum_lifetime: ty::Region<'tcx>,\n+    ) {\n+        self.sub_regions(\n+            infer::DerefPointer(deref_span),\n+            minimum_lifetime,\n+            maximum_lifetime,\n+        )\n     }\n \n-    fn check_safety_of_rvalue_destructor_if_necessary(&mut self,\n-                                                     cmt: &mc::cmt_<'tcx>,\n-                                                     span: Span) {\n+    fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::cmt_<'tcx>, span: Span) {\n         match cmt.cat {\n-            Categorization::Rvalue(region) => {\n-                match *region {\n-                    ty::ReScope(rvalue_scope) => {\n-                        let typ = self.resolve_type(cmt.ty);\n-                        let body_id = self.body_id;\n-                        let _ = dropck::check_safety_of_destructor_if_necessary(\n-                            self, typ, span, body_id, rvalue_scope);\n-                    }\n-                    ty::ReStatic => {}\n-                    _ => {\n-                        span_bug!(span,\n-                                  \"unexpected rvalue region in rvalue \\\n-                                   destructor safety checking: `{:?}`\",\n-                                  region);\n-                    }\n+            Categorization::Rvalue(region) => match *region {\n+                ty::ReScope(rvalue_scope) => {\n+                    let typ = self.resolve_type(cmt.ty);\n+                    let body_id = self.body_id;\n+                    let _ = dropck::check_safety_of_destructor_if_necessary(\n+                        self,\n+                        typ,\n+                        span,\n+                        body_id,\n+                        rvalue_scope,\n+                    );\n                 }\n-            }\n+                ty::ReStatic => {}\n+                _ => {\n+                    span_bug!(\n+                        span,\n+                        \"unexpected rvalue region in rvalue \\\n+                         destructor safety checking: `{:?}`\",\n+                        region\n+                    );\n+                }\n+            },\n             _ => {}\n         }\n     }\n \n     /// Invoked on any index expression that occurs. Checks that if this is a slice\n     /// being indexed, the lifetime of the pointer includes the deref expr.\n-    fn constrain_index(&mut self,\n-                       index_expr: &hir::Expr,\n-                       indexed_ty: Ty<'tcx>)\n-    {\n-        debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n-               self.ty_to_string(indexed_ty));\n+    fn constrain_index(&mut self, index_expr: &hir::Expr, indexed_ty: Ty<'tcx>) {\n+        debug!(\n+            \"constrain_index(index_expr=?, indexed_ty={}\",\n+            self.ty_to_string(indexed_ty)\n+        );\n \n         let r_index_expr = ty::ReScope(region::Scope {\n             id: index_expr.hir_id.local_id,\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         });\n         if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.sty {\n             match r_ty.sty {\n                 ty::Slice(_) | ty::Str => {\n-                    self.sub_regions(infer::IndexSlice(index_expr.span),\n-                                     self.tcx.mk_region(r_index_expr), r_ptr);\n+                    self.sub_regions(\n+                        infer::IndexSlice(index_expr.span),\n+                        self.tcx.mk_region(r_index_expr),\n+                        r_ptr,\n+                    );\n                 }\n                 _ => {}\n             }\n@@ -947,27 +1002,29 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Guarantees that any lifetimes which appear in the type of the node `id` (after applying\n     /// adjustments) are valid for at least `minimum_lifetime`\n-    fn type_of_node_must_outlive(&mut self,\n+    fn type_of_node_must_outlive(\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         hir_id: hir::HirId,\n-        minimum_lifetime: ty::Region<'tcx>)\n-    {\n+        minimum_lifetime: ty::Region<'tcx>,\n+    ) {\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(hir_id);\n \n         let ty = self.tables\n-                     .borrow()\n-                     .adjustments()\n-                     .get(hir_id)\n-                     .and_then(|adj| adj.last())\n-                     .map_or(ty0, |adj| adj.target);\n+            .borrow()\n+            .adjustments()\n+            .get(hir_id)\n+            .and_then(|adj| adj.last())\n+            .map_or(ty0, |adj| adj.target);\n         let ty = self.resolve_type(ty);\n-        debug!(\"constrain_regions_in_type_of_node(\\\n-                ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n-                ty,  ty0,\n-                hir_id, minimum_lifetime);\n+        debug!(\n+            \"constrain_regions_in_type_of_node(\\\n+             ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n+            ty, ty0, hir_id, minimum_lifetime\n+        );\n         self.type_must_outlive(origin, ty, minimum_lifetime);\n     }\n \n@@ -979,23 +1036,25 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// - `origin`, the reason we need this constraint\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n-    pub fn type_must_outlive(&self,\n-                             origin: infer::SubregionOrigin<'tcx>,\n-                             ty: Ty<'tcx>,\n-                             region: ty::Region<'tcx>)\n-    {\n-        self.infcx.type_must_outlive(self.outlives_environment.region_bound_pairs(),\n-                                     self.implicit_region_bound,\n-                                     self.param_env,\n-                                     origin,\n-                                     ty,\n-                                     region);\n+    pub fn type_must_outlive(\n+        &self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        self.infcx.type_must_outlive(\n+            self.outlives_environment.region_bound_pairs(),\n+            self.implicit_region_bound,\n+            self.param_env,\n+            origin,\n+            ty,\n+            region,\n+        );\n     }\n \n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n     /// resulting pointer is linked to the lifetime of its guarantor (if any).\n-    fn link_addr_of(&mut self, expr: &hir::Expr,\n-                    mutability: hir::Mutability, base: &hir::Expr) {\n+    fn link_addr_of(&mut self, expr: &hir::Expr, mutability: hir::Mutability, base: &hir::Expr) {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n         let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n@@ -1011,7 +1070,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_local(&self, local: &hir::Local) {\n         debug!(\"regionck::for_local()\");\n         let init_expr = match local.init {\n-            None => { return; }\n+            None => {\n+                return;\n+            }\n             Some(ref expr) => &**expr,\n         };\n         let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr))));\n@@ -1043,32 +1104,36 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let arg_cmt = self.with_mc(|mc| {\n                 Rc::new(mc.cat_rvalue(arg.hir_id, arg.pat.span, re_scope, arg_ty))\n             });\n-            debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n-                   arg_ty,\n-                   arg_cmt,\n-                   arg);\n+            debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\", arg_ty, arg_cmt, arg);\n             self.link_pattern(arg_cmt, &arg.pat);\n         }\n     }\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n     fn link_pattern(&self, discr_cmt: mc::cmt<'tcx>, root_pat: &hir::Pat) {\n-        debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n-               discr_cmt,\n-               root_pat);\n+        debug!(\n+            \"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n+            discr_cmt, root_pat\n+        );\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(..) => {\n                         if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n                             if let ty::BindByReference(mutbl) = bm {\n-                                self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n-                                                                mutbl, &sub_cmt);\n+                                self.link_region_from_node_type(\n+                                    sub_pat.span,\n+                                    sub_pat.hir_id,\n+                                    mutbl,\n+                                    &sub_cmt,\n+                                );\n                             }\n                         } else {\n-                            self.tcx.sess.delay_span_bug(sub_pat.span, \"missing binding mode\");\n+                            self.tcx\n+                                .sess\n+                                .delay_span_bug(sub_pat.span, \"missing binding mode\");\n                         }\n                     }\n                     _ => {}\n@@ -1079,12 +1144,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Link lifetime of borrowed pointer resulting from autoref to lifetimes in the value being\n     /// autoref'd.\n-    fn link_autoref(&self,\n-                    expr: &hir::Expr,\n-                    expr_cmt: &mc::cmt_<'tcx>,\n-                    autoref: &adjustment::AutoBorrow<'tcx>)\n-    {\n-        debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n+    fn link_autoref(\n+        &self,\n+        expr: &hir::Expr,\n+        expr_cmt: &mc::cmt_<'tcx>,\n+        autoref: &adjustment::AutoBorrow<'tcx>,\n+    ) {\n+        debug!(\n+            \"link_autoref(autoref={:?}, expr_cmt={:?})\",\n+            autoref, expr_cmt\n+        );\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n@@ -1094,7 +1163,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             adjustment::AutoBorrow::RawPtr(m) => {\n                 let r = self.tcx.mk_region(ty::ReScope(region::Scope {\n                     id: expr.hir_id.local_id,\n-                    data: region::ScopeData::Node\n+                    data: region::ScopeData::Node,\n                 }));\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n@@ -1103,17 +1172,21 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Like `link_region()`, except that the region is extracted from the type of `id`,\n     /// which must be some reference (`&T`, `&str`, etc).\n-    fn link_region_from_node_type(&self,\n-                                  span: Span,\n-                                  id: hir::HirId,\n-                                  mutbl: hir::Mutability,\n-                                  cmt_borrowed: &mc::cmt_<'tcx>) {\n-        debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n-               id, mutbl, cmt_borrowed);\n+    fn link_region_from_node_type(\n+        &self,\n+        span: Span,\n+        id: hir::HirId,\n+        mutbl: hir::Mutability,\n+        cmt_borrowed: &mc::cmt_<'tcx>,\n+    ) {\n+        debug!(\n+            \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n+            id, mutbl, cmt_borrowed\n+        );\n \n         let rptr_ty = self.resolve_node_type(id);\n         if let ty::Ref(r, _, _) = rptr_ty.sty {\n-            debug!(\"rptr_ty={}\",  rptr_ty);\n+            debug!(\"rptr_ty={}\", rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }\n     }\n@@ -1122,28 +1195,35 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// kind `borrow_kind` and lifetime `borrow_region`.\n     /// In order to ensure borrowck is satisfied, this may create constraints\n     /// between regions, as explained in `link_reborrowed_region()`.\n-    fn link_region(&self,\n-                   span: Span,\n-                   borrow_region: ty::Region<'tcx>,\n-                   borrow_kind: ty::BorrowKind,\n-                   borrow_cmt: &mc::cmt_<'tcx>) {\n+    fn link_region(\n+        &self,\n+        span: Span,\n+        borrow_region: ty::Region<'tcx>,\n+        borrow_kind: ty::BorrowKind,\n+        borrow_cmt: &mc::cmt_<'tcx>,\n+    ) {\n         let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n         self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);\n \n         let mut borrow_kind = borrow_kind;\n         let mut borrow_cmt_cat = borrow_cmt.cat.clone();\n \n         loop {\n-            debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n-                   borrow_region,\n-                   borrow_kind,\n-                   borrow_cmt);\n+            debug!(\n+                \"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n+                borrow_region, borrow_kind, borrow_cmt\n+            );\n             match borrow_cmt_cat {\n                 Categorization::Deref(ref_cmt, mc::BorrowedPtr(ref_kind, ref_region)) => {\n-                    match self.link_reborrowed_region(span,\n-                                                      borrow_region, borrow_kind,\n-                                                      ref_cmt, ref_region, ref_kind,\n-                                                      borrow_cmt.note) {\n+                    match self.link_reborrowed_region(\n+                        span,\n+                        borrow_region,\n+                        borrow_kind,\n+                        ref_cmt,\n+                        ref_region,\n+                        ref_kind,\n+                        borrow_cmt.note,\n+                    ) {\n                         Some((c, k)) => {\n                             borrow_cmt_cat = c.cat.clone();\n                             borrow_kind = k;\n@@ -1154,20 +1234,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                Categorization::Downcast(cmt_base, _) |\n-                Categorization::Deref(cmt_base, mc::Unique) |\n-                Categorization::Interior(cmt_base, _) => {\n+                Categorization::Downcast(cmt_base, _)\n+                | Categorization::Deref(cmt_base, mc::Unique)\n+                | Categorization::Interior(cmt_base, _) => {\n                     // Borrowing interior or owned data requires the base\n                     // to be valid and borrowable in the same fashion.\n                     borrow_cmt_cat = cmt_base.cat.clone();\n                     borrow_kind = borrow_kind;\n                 }\n \n-                Categorization::Deref(_, mc::UnsafePtr(..)) |\n-                Categorization::StaticItem |\n-                Categorization::Upvar(..) |\n-                Categorization::Local(..) |\n-                Categorization::Rvalue(..) => {\n+                Categorization::Deref(_, mc::UnsafePtr(..))\n+                | Categorization::StaticItem\n+                | Categorization::Upvar(..)\n+                | Categorization::Local(..)\n+                | Categorization::Rvalue(..) => {\n                     // These are all \"base cases\" with independent lifetimes\n                     // that are not subject to inference\n                     return;\n@@ -1218,16 +1298,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// The return value of this function indicates whether we need to\n     /// recurse and process `ref_cmt` (see case 2 above).\n-    fn link_reborrowed_region(&self,\n-                              span: Span,\n-                              borrow_region: ty::Region<'tcx>,\n-                              borrow_kind: ty::BorrowKind,\n-                              ref_cmt: mc::cmt<'tcx>,\n-                              ref_region: ty::Region<'tcx>,\n-                              mut ref_kind: ty::BorrowKind,\n-                              note: mc::Note)\n-                              -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n-    {\n+    fn link_reborrowed_region(\n+        &self,\n+        span: Span,\n+        borrow_region: ty::Region<'tcx>,\n+        borrow_kind: ty::BorrowKind,\n+        ref_cmt: mc::cmt<'tcx>,\n+        ref_region: ty::Region<'tcx>,\n+        mut ref_kind: ty::BorrowKind,\n+        note: mc::Note,\n+    ) -> Option<(mc::cmt<'tcx>, ty::BorrowKind)> {\n         // Possible upvar ID we may need later to create an entry in the\n         // maybe link map.\n \n@@ -1243,7 +1323,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                         infer::ReborrowUpvar(span, *upvar_id)\n                     }\n                     _ => {\n-                        span_bug!( span, \"Illegal upvar id: {:?}\", upvar_id);\n+                        span_bug!(span, \"Illegal upvar id: {:?}\", upvar_id);\n                     }\n                 }\n             }\n@@ -1253,14 +1333,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 // link\n                 infer::ReborrowUpvar(span, *upvar_id)\n             }\n-            _ => {\n-                infer::Reborrow(span)\n-            }\n+            _ => infer::Reborrow(span),\n         };\n \n-        debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n-               borrow_region,\n-               ref_region);\n+        debug!(\n+            \"link_reborrowed_region: {:?} <= {:?}\",\n+            borrow_region, ref_region\n+        );\n         self.sub_regions(cause, borrow_region, ref_region);\n \n         // If we end up needing to recurse and establish a region link\n@@ -1272,10 +1351,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // borrowck requires a unique path to the `&mut` reference but not\n         // necessarily a *mutable* path.\n         let new_borrow_kind = match borrow_kind {\n-            ty::ImmBorrow =>\n-                ty::ImmBorrow,\n-            ty::MutBorrow | ty::UniqueImmBorrow =>\n-                ty::UniqueImmBorrow\n+            ty::ImmBorrow => ty::ImmBorrow,\n+            ty::MutBorrow | ty::UniqueImmBorrow => ty::UniqueImmBorrow,\n         };\n \n         // Decide whether we need to recurse and link any regions within\n@@ -1329,16 +1406,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Checks that the values provided for type/region arguments in a given\n     /// expression are well-formed and in-scope.\n-    fn substs_wf_in_scope(&mut self,\n-                          origin: infer::ParameterOrigin,\n-                          substs: &Substs<'tcx>,\n-                          expr_span: Span,\n-                          expr_region: ty::Region<'tcx>) {\n-        debug!(\"substs_wf_in_scope(substs={:?}, \\\n-                expr_region={:?}, \\\n-                origin={:?}, \\\n-                expr_span={:?})\",\n-               substs, expr_region, origin, expr_span);\n+    fn substs_wf_in_scope(\n+        &mut self,\n+        origin: infer::ParameterOrigin,\n+        substs: &Substs<'tcx>,\n+        expr_span: Span,\n+        expr_region: ty::Region<'tcx>,\n+    ) {\n+        debug!(\n+            \"substs_wf_in_scope(substs={:?}, \\\n+             expr_region={:?}, \\\n+             origin={:?}, \\\n+             expr_span={:?})\",\n+            substs, expr_region, origin, expr_span\n+        );\n \n         let origin = infer::ParameterInScope(origin, expr_span);\n "}]}