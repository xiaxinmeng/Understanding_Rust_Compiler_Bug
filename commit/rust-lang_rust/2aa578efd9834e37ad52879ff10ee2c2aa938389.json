{"sha": "2aa578efd9834e37ad52879ff10ee2c2aa938389", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYTU3OGVmZDk4MzRlMzdhZDUyODc5ZmYxMGVlMmMyYWE5MzgzODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-14T07:01:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-14T07:01:04Z"}, "message": "auto merge of #9115 : erickt/rust/master, r=erickt\n\nThis is a series of patches to modernize option and result. The highlights are:\r\n\r\n* rename `.unwrap_or_default(value)` and etc to `.unwrap_or(value)`\r\n* add `.unwrap_or_default()` that uses the `Default` trait\r\n* add `Default` implementations for vecs, HashMap, Option\r\n* add  `Option.and(T) -> Option<T>`, `Option.and_then(&fn() -> Option<T>) -> Option<T>`, `Option.or(T) -> Option<T>`, and `Option.or_else(&fn() -> Option<T>) -> Option<T>`\r\n* add `option::ToOption`, `option::IntoOption`, `option::AsOption`, `result::ToResult`, `result::IntoResult`, `result::AsResult`, `either::ToEither`, and `either::IntoEither`, `either::AsEither`\r\n* renamed `Option::chain*` and `Result::chain*` to `and_then` and `or_else` to avoid the eventual collision with `Iterator.chain`.\r\n* Added a bunch of impls of `Default`\r\n* Added a `#[deriving(Default)]` syntax extension\r\n* Removed impls of `Zero` for `Option<T>` and vecs.", "tree": {"sha": "aa459cb42c65433dfbddca28040db544aea89f59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa459cb42c65433dfbddca28040db544aea89f59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa578efd9834e37ad52879ff10ee2c2aa938389", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa578efd9834e37ad52879ff10ee2c2aa938389", "html_url": "https://github.com/rust-lang/rust/commit/2aa578efd9834e37ad52879ff10ee2c2aa938389", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa578efd9834e37ad52879ff10ee2c2aa938389/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ac10f8f6e8e07c70fadb676170c5402442e2243", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac10f8f6e8e07c70fadb676170c5402442e2243", "html_url": "https://github.com/rust-lang/rust/commit/4ac10f8f6e8e07c70fadb676170c5402442e2243"}, {"sha": "93683ae6da3a47f1cd0644a093cb4b1b0bee7faa", "url": "https://api.github.com/repos/rust-lang/rust/commits/93683ae6da3a47f1cd0644a093cb4b1b0bee7faa", "html_url": "https://github.com/rust-lang/rust/commit/93683ae6da3a47f1cd0644a093cb4b1b0bee7faa"}], "stats": {"total": 1326, "additions": 1099, "deletions": 227}, "files": [{"sha": "8e1028b472737d6399eb2e379b2a06c2708478a8", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -1717,7 +1717,8 @@ Supported traits for `deriving` are:\n * `Clone` and `DeepClone`, to perform (deep) copies.\n * `IterBytes`, to iterate over the bytes in a data type.\n * `Rand`, to create a random instance of a data type.\n-* `Zero`, to create an zero (or empty) instance of a data type.\n+* `Default`, to create an empty instance of a data type.\n+* `Zero`, to create an zero instance of a numeric data type.\n * `ToStr`, to convert to a string. For a type with this instance,\n   `obj.to_str()` has similar output as `fmt!(\"%?\", obj)`, but it differs in that\n   each constituent field of the type must also implement `ToStr` and will have"}, {"sha": "637dbb10c23559616db7121f659a5cd804356e0d", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -2249,7 +2249,7 @@ enum ABC { A, B, C }\n \n The full list of derivable traits is `Eq`, `TotalEq`, `Ord`,\n `TotalOrd`, `Encodable` `Decodable`, `Clone`, `DeepClone`,\n-`IterBytes`, `Rand`, `Zero`, and `ToStr`.\n+`IterBytes`, `Rand`, `Default`, `Zero`, and `ToStr`.\n \n # Crates and the module system\n "}, {"sha": "166638bc359bf98e4c560ad6d82187492b5cf4e3", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -309,7 +309,7 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n         let filename = path.filename();\n         let p = path.pop();\n         let dir = p.filename();\n-        fmt!(\"%s/%s\", dir.unwrap_or_default(\"\"), filename.unwrap_or_default(\"\"))\n+        fmt!(\"%s/%s\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n     test::DynTestName(fmt!(\"[%s] %s\","}, {"sha": "39a4ac618466cfebf469c2f830283821e63c6133", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -137,7 +137,17 @@ fn list_dir_sorted(path: &Path) -> ~[Path] {\n /**\n  * A compiled Unix shell style pattern.\n  */\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Zero)]\n+#[cfg(stage0)]\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes)]\n+pub struct Pattern {\n+    priv tokens: ~[PatternToken]\n+}\n+\n+/**\n+ * A compiled Unix shell style pattern.\n+ */\n+#[cfg(not(stage0))]\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Default)]\n pub struct Pattern {\n     priv tokens: ~[PatternToken]\n }\n@@ -312,7 +322,7 @@ impl Pattern {\n         let require_literal = |c| {\n             (options.require_literal_separator && is_sep(c)) ||\n             (options.require_literal_leading_dot && c == '.'\n-             && is_sep(prev_char.unwrap_or_default('/')))\n+             && is_sep(prev_char.unwrap_or('/')))\n         };\n \n         for (ti, token) in self.tokens.slice_from(i).iter().enumerate() {\n@@ -458,7 +468,37 @@ fn is_sep(c: char) -> bool {\n /**\n  * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n  */\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Zero)]\n+#[cfg(stage0)]\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes)]\n+pub struct MatchOptions {\n+\n+    /**\n+     * Whether or not patterns should be matched in a case-sensitive manner. This\n+     * currently only considers upper/lower case relationships between ASCII characters,\n+     * but in future this might be extended to work with Unicode.\n+     */\n+    case_sensitive: bool,\n+\n+    /**\n+     * If this is true then path-component separator characters (e.g. `/` on Posix)\n+     * must be matched by a literal `/`, rather than by `*` or `?` or `[...]`\n+     */\n+    require_literal_separator: bool,\n+\n+    /**\n+     * If this is true then paths that contain components that start with a `.` will\n+     * not match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\n+     * will not match. This is useful because such files are conventionally considered\n+     * hidden on Unix systems and it might be desirable to skip them when listing files.\n+     */\n+    require_literal_leading_dot: bool\n+}\n+\n+/**\n+ * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n+ */\n+#[cfg(not(stage0))]\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Default)]\n pub struct MatchOptions {\n \n     /**"}, {"sha": "24f44c8a2a8ec5ab7ca1b3e56ea727ffe1abb973", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -635,7 +635,7 @@ impl BigUint {\n \n     // Converts this BigUint into an int, unless it would overflow.\n     pub fn to_int_opt(&self) -> Option<int> {\n-        self.to_uint_opt().chain(|n| {\n+        self.to_uint_opt().and_then(|n| {\n             // If top bit of uint is set, it's too large to convert to\n             // int.\n             if (n >> (2*BigDigit::bits - 1) != 0) {\n@@ -1221,7 +1221,7 @@ impl BigInt {\n         match self.sign {\n             Plus  => self.data.to_int_opt(),\n             Zero  => Some(0),\n-            Minus => self.data.to_uint_opt().chain(|n| {\n+            Minus => self.data.to_uint_opt().and_then(|n| {\n                 let m: uint = 1 << (2*BigDigit::bits-1);\n                 if (n > m) {\n                     None"}, {"sha": "1991d9f1b5bbc7486e4c16be06e27c36eacd7884", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -273,9 +273,9 @@ impl<T: FromStr + Clone + Integer + Ord>\n             return None\n         }\n         let a_option: Option<T> = FromStr::from_str(split[0]);\n-        do a_option.chain |a| {\n+        do a_option.and_then |a| {\n             let b_option: Option<T> = FromStr::from_str(split[1]);\n-            do b_option.chain |b| {\n+            do b_option.and_then |b| {\n                 Some(Ratio::new(a.clone(), b.clone()))\n             }\n         }\n@@ -291,10 +291,10 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n         } else {\n             let a_option: Option<T> = FromStrRadix::from_str_radix(split[0],\n                                                                    radix);\n-            do a_option.chain |a| {\n+            do a_option.and_then |a| {\n                 let b_option: Option<T> =\n                     FromStrRadix::from_str_radix(split[1], radix);\n-                do b_option.chain |b| {\n+                do b_option.and_then |b| {\n                     Some(Ratio::new(a.clone(), b.clone()))\n                 }\n             }"}, {"sha": "d51d1c217857140565bb8b144e4817b3a15041c2", "filename": "src/libextra/time.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -442,21 +442,21 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           },\n           'c' => {\n             parse_type(s, pos, 'a', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'b', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'e', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'T', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'Y', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'b', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'e', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'T', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'Y', &mut *tm))\n           }\n           'D' | 'x' => {\n             parse_type(s, pos, 'm', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'd', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'y', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '/'))\n+                .and_then(|pos| parse_type(s, pos, 'd', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '/'))\n+                .and_then(|pos| parse_type(s, pos, 'y', &mut *tm))\n           }\n           'd' => match match_digits_in_range(s, pos, 2u, false, 1_i32,\n                                              31_i32) {\n@@ -475,10 +475,10 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           'F' => {\n             parse_type(s, pos, 'Y', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'm', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'd', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '-'))\n+                .and_then(|pos| parse_type(s, pos, 'm', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '-'))\n+                .and_then(|pos| parse_type(s, pos, 'd', &mut *tm))\n           }\n           'H' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 23_i32) {\n@@ -553,17 +553,17 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           },\n           'R' => {\n             parse_type(s, pos, 'H', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n           }\n           'r' => {\n             parse_type(s, pos, 'I', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'p', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'S', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'p', &mut *tm))\n           }\n           'S' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 60_i32) {\n@@ -578,10 +578,10 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           //'s' {}\n           'T' | 'X' => {\n             parse_type(s, pos, 'H', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'S', &mut *tm))\n           }\n           't' => parse_char(s, pos, '\\t'),\n           'u' => {\n@@ -596,10 +596,10 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           'v' => {\n             parse_type(s, pos, 'e', &mut *tm)\n-                .chain(|pos|  parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'b', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'Y', &mut *tm))\n+                .and_then(|pos|  parse_char(s, pos, '-'))\n+                .and_then(|pos| parse_type(s, pos, 'b', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '-'))\n+                .and_then(|pos| parse_type(s, pos, 'Y', &mut *tm))\n           }\n           //'W' {}\n           'w' => {"}, {"sha": "2641c1379e4f60d8528d86e9d47356e91c567def", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -417,6 +417,13 @@ impl Uuid {\n     }\n }\n \n+impl Default for Uuid {\n+    /// Returns the nil UUID, which is all zeroes\n+    fn default() -> Uuid {\n+        Uuid::new_nil()\n+    }\n+}\n+\n impl Zero for Uuid {\n     /// Returns the nil UUID, which is all zeroes\n     fn zero() -> Uuid {"}, {"sha": "5078d0ded18d129e225bf7d56ccf3031634d38e1", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -681,9 +681,9 @@ pub fn build_session_options(binary: @str,\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n     let sysroot_opt = getopts::opt_maybe_str(matches, \"sysroot\").map_move(|m| @Path(m));\n-    let target = getopts::opt_maybe_str(matches, \"target\").unwrap_or_default(host_triple());\n-    let target_cpu = getopts::opt_maybe_str(matches, \"target-cpu\").unwrap_or_default(~\"generic\");\n-    let target_feature = getopts::opt_maybe_str(matches, \"target-feature\").unwrap_or_default(~\"\");\n+    let target = getopts::opt_maybe_str(matches, \"target\").unwrap_or(host_triple());\n+    let target_cpu = getopts::opt_maybe_str(matches, \"target-cpu\").unwrap_or(~\"generic\");\n+    let target_feature = getopts::opt_maybe_str(matches, \"target-feature\").unwrap_or(~\"\");\n     let save_temps = getopts::opt_present(matches, \"save-temps\");\n     let opt_level = {\n         if (debugging_opts & session::no_opt) != 0 {\n@@ -961,7 +961,7 @@ pub fn build_output_filenames(input: &input,\n           if !linkage_metas.is_empty() {\n               // But if a linkage meta is present, that overrides\n               let maybe_name = linkage_metas.iter().find(|m| \"name\" == m.name());\n-              match maybe_name.chain(|m| m.value_str()) {\n+              match maybe_name.and_then(|m| m.value_str()) {\n                   Some(s) => stem = s,\n                   _ => ()\n               }"}, {"sha": "2c0068729a72e1ada4c46f16cee9587d56e59158", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -58,7 +58,7 @@ fn filter_view_item<'r>(cx: @Context, view_item: &'r ast::view_item)-> Option<&'\n \n fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n     let filtered_items = do  m.items.iter().filter_map |a| {\n-        filter_item(cx, *a).chain(|x| fld.fold_item(x))\n+        filter_item(cx, *a).and_then(|x| fld.fold_item(x))\n     }.collect();\n     let filtered_view_items = do m.view_items.iter().filter_map |a| {\n         do filter_view_item(cx, a).map_move |x| {\n@@ -139,7 +139,7 @@ fn fold_block(\n     fld: @fold::ast_fold\n ) -> ast::Block {\n     let resulting_stmts = do b.stmts.iter().filter_map |a| {\n-        filter_stmt(cx, *a).chain(|stmt| fld.fold_stmt(stmt))\n+        filter_stmt(cx, *a).and_then(|stmt| fld.fold_stmt(stmt))\n     }.collect();\n     let filtered_view_items = do b.view_items.iter().filter_map |a| {\n         filter_view_item(cx, a).map(|x| fld.fold_view_item(*x))"}, {"sha": "3b563e47426a3ce299763874430e05669a57331c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -184,7 +184,7 @@ fn visit_item(e: &Env, i: @ast::item) {\n             ast::named => {\n                 let link_name = i.attrs.iter()\n                     .find(|at| \"link_name\" == at.name())\n-                    .chain(|at| at.value_str());\n+                    .and_then(|at| at.value_str());\n \n                 let foreign_name = match link_name {\n                         Some(nn) => {"}, {"sha": "c94151095a442fafbe916130de919ab95a2db5d7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -210,7 +210,7 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n-    do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n+    do reader::maybe_get_doc(d, tag_disr_val).and_then |val_doc| {\n         do reader::with_doc_data(val_doc) |data| { u64::parse_bytes(data, 10u) }\n     }\n }"}, {"sha": "51fe2acc72ad45b79bbd0a99d07b6da3635d3ee0", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -221,8 +221,7 @@ impl PrivacyVisitor {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n-        let method_id = ty::method(self.tcx, method_id).provided_source\n-            .unwrap_or_default(method_id);\n+        let method_id = ty::method(self.tcx, method_id).provided_source.unwrap_or(method_id);\n \n         if method_id.crate == LOCAL_CRATE {\n             let is_private = self.method_is_private(span, method_id.node);"}, {"sha": "b75b06f42b64986fec003a549512b26b1a65d976", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -505,7 +505,7 @@ impl get_node_info for ast::Block {\n \n impl get_node_info for Option<@ast::Expr> {\n     fn info(&self) -> Option<NodeInfo> {\n-        self.chain_ref(|s| s.info())\n+        self.and_then_ref(|s| s.info())\n     }\n }\n "}, {"sha": "a33f2bd3a557ef9c5b891ff6cdaedb05c69fe804", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -50,9 +50,9 @@ impl Value {\n     /// must be the only user of this value, and there must not be any conditional\n     /// branches between the store and the given block.\n     pub fn get_dominating_store(self, bcx: @mut Block) -> Option<Value> {\n-        match self.get_single_user().chain(|user| user.as_store_inst()) {\n+        match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n-                do store.get_parent().chain |store_bb| {\n+                do store.get_parent().and_then |store_bb| {\n                     let mut bb = BasicBlock(bcx.llbb);\n                     let mut ret = Some(store);\n                     while *bb != *store_bb {\n@@ -150,7 +150,7 @@ impl Iterator<Value> for UserIterator {\n     fn next(&mut self) -> Option<Value> {\n         let current = self.next;\n \n-        self.next = do current.chain |u| { u.get_next_use() };\n+        self.next = do current.and_then |u| { u.get_next_use() };\n \n         do current.map |u| { u.get_user() }\n     }"}, {"sha": "36405136e630ffedc4a94503039cff61acdb86b4", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -745,7 +745,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n                           RegionParamNames(bound_lifetime_names.clone()));\n \n     let input_tys = do decl.inputs.iter().enumerate().map |(i, a)| {\n-        let expected_arg_ty = do expected_sig.chain_ref |e| {\n+        let expected_arg_ty = do expected_sig.and_then_ref |e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}"}, {"sha": "061921e60e1257602cc0b5fde6ea55c0fdd7dc21", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -173,7 +173,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n                     arg_types = (*subpats).clone()\n-                                          .unwrap_or_default(~[])\n+                                          .unwrap_or_default()\n                                           .map(|_| ty::mk_err());\n                 }\n             }\n@@ -222,7 +222,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n             arg_types = (*subpats).clone()\n-                                  .unwrap_or_default(~[])\n+                                  .unwrap_or_default()\n                                   .map(|_| ty::mk_err());\n         }\n     }"}, {"sha": "cdfb8732a38aaa29962c1b1b27a5274409bf912e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -15,7 +15,7 @@\n // the trait `Combine` and contains methods for combining two\n // instances of various things and yielding a new instance.  These\n // combiner methods always yield a `result<T>`---failure is propagated\n-// upward using `chain()` methods.  There is a lot of common code for\n+// upward using `and_then()` methods.  There is a lot of common code for\n // these operations, implemented as default methods on the `Combine`\n // trait.\n //\n@@ -108,7 +108,7 @@ pub trait Combine {\n             (Some(a), Some(b)) => {\n                 // FIXME(#5781) this should be eq_tys\n                 // eq_tys(self, a, b).then(|| Ok(Some(a)) )\n-                self.contratys(a, b).chain(|t| Ok(Some(t)))\n+                self.contratys(a, b).and_then(|t| Ok(Some(t)))\n             }\n             (None, Some(_)) |\n                 (Some(_), None) => {\n@@ -162,13 +162,13 @@ pub trait Combine {\n                                 }\n \n                                 ty::rv_covariant => {\n-                                    do this.regions(a_r, b_r).chain |r| {\n+                                    do this.regions(a_r, b_r).and_then |r| {\n                                         Ok(ty::NonerasedRegions(opt_vec::with(r)))\n                                     }\n                                 }\n \n                                 ty::rv_contravariant => {\n-                                    do this.contraregions(a_r, b_r).chain |r| {\n+                                    do this.contraregions(a_r, b_r).and_then |r| {\n                                         Ok(ty::NonerasedRegions(opt_vec::with(r)))\n                                     }\n                                 }\n@@ -179,12 +179,12 @@ pub trait Combine {\n             }\n         }\n \n-        do self.tps(as_.tps, bs.tps).chain |tps| {\n-            do self.self_tys(as_.self_ty, bs.self_ty).chain |self_ty| {\n+        do self.tps(as_.tps, bs.tps).and_then |tps| {\n+            do self.self_tys(as_.self_ty, bs.self_ty).and_then |self_ty| {\n                 do relate_region_params(self,\n                                         generics,\n                                         &as_.regions,\n-                                        &bs.regions).chain |regions| {\n+                                        &bs.regions).and_then |regions| {\n                     Ok(substs {\n                             regions: regions,\n                             self_ty: self_ty,\n@@ -227,8 +227,8 @@ pub trait Combine {\n     fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n         if a.ident == b.ident {\n             self.mts(&a.mt, &b.mt)\n-                .chain(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n-                .chain_err(|e| Err(ty::terr_in_field(@e, a.ident)) )\n+                .and_then(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n+                .or_else(|e| Err(ty::terr_in_field(@e, a.ident)) )\n         } else {\n             Err(ty::terr_record_fields(\n                                        expected_found(self,\n@@ -238,7 +238,7 @@ pub trait Combine {\n     }\n \n     fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        do self.contratys(a, b).chain |t| {\n+        do self.contratys(a, b).and_then |t| {\n             Ok(t)\n         }\n     }\n@@ -274,7 +274,7 @@ pub trait Combine {\n \n         match (a, b) {\n             (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n-                do self.contraregions(a_r, b_r).chain |r| {\n+                do self.contraregions(a_r, b_r).and_then |r| {\n                     Ok(ty::vstore_slice(r))\n                 }\n             }\n@@ -299,7 +299,7 @@ pub trait Combine {\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n-                do self.contraregions(a_r, b_r).chain |r| {\n+                do self.contraregions(a_r, b_r).and_then |r| {\n                     Ok(ty::RegionTraitStore(r))\n                 }\n             }\n@@ -357,7 +357,7 @@ pub fn expected_found<C:Combine,T>(\n pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n     let suber = this.sub();\n     do this.infcx().try {\n-        do suber.tys(a, b).chain |_ok| {\n+        do suber.tys(a, b).and_then |_ok| {\n             suber.contratys(a, b)\n         }.to_ures()\n     }\n@@ -371,10 +371,10 @@ pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n     let sub = this.sub();\n     do indent {\n         this.infcx().try(|| {\n-            do sub.regions(a, b).chain |_r| {\n+            do sub.regions(a, b).and_then |_r| {\n                 sub.contraregions(a, b)\n             }\n-        }).chain_err(|e| {\n+        }).or_else(|e| {\n             // substitute a better error, but use the regions\n             // found in the original error\n             match e {\n@@ -427,8 +427,8 @@ pub fn super_fn_sigs<C:Combine>(\n     }\n \n     do argvecs(this, a.inputs, b.inputs)\n-            .chain |inputs| {\n-        do this.tys(a.output, b.output).chain |output| {\n+            .and_then |inputs| {\n+        do this.tys(a.output, b.output).and_then |output| {\n             Ok(FnSig {bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n                       inputs: inputs.clone(),\n                       output: output})\n@@ -508,7 +508,7 @@ pub fn super_tys<C:Combine>(\n        &ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n           let type_def = ty::lookup_item_type(tcx, a_id);\n-          do this.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+          do this.substs(&type_def.generics, a_substs, b_substs).and_then |substs| {\n               Ok(ty::mk_enum(tcx, a_id, substs))\n           }\n       }\n@@ -517,9 +517,9 @@ pub fn super_tys<C:Combine>(\n        &ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl, b_bounds))\n       if a_id == b_id && a_mutbl == b_mutbl => {\n           let trait_def = ty::lookup_trait_def(tcx, a_id);\n-          do this.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n-              do this.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n-                  do this.bounds(a_bounds, b_bounds).chain |bounds| {\n+          do this.substs(&trait_def.generics, a_substs, b_substs).and_then |substs| {\n+              do this.trait_stores(ty::terr_trait, a_store, b_store).and_then |s| {\n+                  do this.bounds(a_bounds, b_bounds).and_then |bounds| {\n                     Ok(ty::mk_trait(tcx,\n                                     a_id,\n                                     substs.clone(),\n@@ -534,25 +534,25 @@ pub fn super_tys<C:Combine>(\n       (&ty::ty_struct(a_id, ref a_substs), &ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n           let type_def = ty::lookup_item_type(tcx, a_id);\n-          do this.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+          do this.substs(&type_def.generics, a_substs, b_substs).and_then |substs| {\n               Ok(ty::mk_struct(tcx, a_id, substs))\n           }\n       }\n \n       (&ty::ty_box(ref a_mt), &ty::ty_box(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).and_then |mt| {\n             Ok(ty::mk_box(tcx, mt))\n         }\n       }\n \n       (&ty::ty_uniq(ref a_mt), &ty::ty_uniq(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).and_then |mt| {\n             Ok(ty::mk_uniq(tcx, mt))\n         }\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).and_then |mt| {\n             Ok(ty::mk_ptr(tcx, mt))\n         }\n       }\n@@ -564,15 +564,15 @@ pub fn super_tys<C:Combine>(\n       }\n \n       (&ty::ty_evec(ref a_mt, vs_a), &ty::ty_evec(ref b_mt, vs_b)) => {\n-        do this.mts(a_mt, b_mt).chain |mt| {\n-            do this.vstores(ty::terr_vec, vs_a, vs_b).chain |vs| {\n+        do this.mts(a_mt, b_mt).and_then |mt| {\n+            do this.vstores(ty::terr_vec, vs_a, vs_b).and_then |vs| {\n                 Ok(ty::mk_evec(tcx, mt, vs))\n             }\n         }\n       }\n \n       (&ty::ty_estr(vs_a), &ty::ty_estr(vs_b)) => {\n-        do this.vstores(ty::terr_str, vs_a, vs_b).chain |vs| {\n+        do this.vstores(ty::terr_str, vs_a, vs_b).and_then |vs| {\n             Ok(ty::mk_estr(tcx,vs))\n         }\n       }\n@@ -581,21 +581,21 @@ pub fn super_tys<C:Combine>(\n         if as_.len() == bs.len() {\n             result::collect(as_.iter().zip(bs.iter())\n                             .map(|(a, b)| this.tys(*a, *b)))\n-                    .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n+                    .and_then(|ts| Ok(ty::mk_tup(tcx, ts)) )\n         } else {\n             Err(ty::terr_tuple_size(\n                 expected_found(this, as_.len(), bs.len())))\n         }\n       }\n \n       (&ty::ty_bare_fn(ref a_fty), &ty::ty_bare_fn(ref b_fty)) => {\n-        do this.bare_fn_tys(a_fty, b_fty).chain |fty| {\n+        do this.bare_fn_tys(a_fty, b_fty).and_then |fty| {\n             Ok(ty::mk_bare_fn(tcx, fty))\n         }\n       }\n \n       (&ty::ty_closure(ref a_fty), &ty::ty_closure(ref b_fty)) => {\n-        do this.closure_tys(a_fty, b_fty).chain |fty| {\n+        do this.closure_tys(a_fty, b_fty).and_then |fty| {\n             Ok(ty::mk_closure(tcx, fty))\n         }\n       }"}, {"sha": "af62da5fde03333fb5475c8af3150dffce26eae9", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -61,7 +61,7 @@ impl Combine for Glb {\n           // If one side or both is immutable, we can use the GLB of\n           // both sides but mutbl must be `MutImmutable`.\n           (MutImmutable, MutImmutable) => {\n-            self.tys(a.ty, b.ty).chain(|t| {\n+            self.tys(a.ty, b.ty).and_then(|t| {\n                 Ok(ty::mt {ty: t, mutbl: MutImmutable})\n             })\n           }"}, {"sha": "4cbdf9fa1fb8bc2f9ece3c7e890b00de63701a46", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -232,7 +232,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n             (&Some(_),       &None) => Ok((*a).clone()),\n             (&None,          &Some(_)) => Ok((*b).clone()),\n             (&Some(ref v_a), &Some(ref v_b)) => {\n-                do lattice_op(self, v_a, v_b).chain |v| {\n+                do lattice_op(self, v_a, v_b).and_then |v| {\n                     Ok(Some(v))\n                 }\n             }"}, {"sha": "260bc93611e963ffef7f42fd93e0d1e0235cd1b1", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -62,15 +62,15 @@ impl Combine for Lub {\n         let m = a.mutbl;\n         match m {\n           MutImmutable => {\n-            self.tys(a.ty, b.ty).chain(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n+            self.tys(a.ty, b.ty).and_then(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n           }\n \n           MutMutable => {\n             self.infcx.try(|| {\n                 eq_tys(self, a.ty, b.ty).then(|| {\n                     Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n-            }).chain_err(|e| Err(e))\n+            }).or_else(|e| Err(e))\n           }\n         }\n     }"}, {"sha": "e73a36de143cca925f318e91ddfbb7bc21121d85", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -451,7 +451,7 @@ trait then {\n impl then for ures {\n     fn then<T:Clone>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n-        self.chain(|_i| f())\n+        self.and_then(|_i| f())\n     }\n }\n \n@@ -474,7 +474,7 @@ trait CresCompare<T> {\n \n impl<T:Clone + Eq> CresCompare<T> for cres<T> {\n     fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n-        do (*self).clone().chain |s| {\n+        do (*self).clone().and_then |s| {\n             if s == t {\n                 (*self).clone()\n             } else {"}, {"sha": "57ebb2185d16587f3bb395423206342a8f22f10c", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -79,7 +79,7 @@ impl Combine for Sub {\n           }\n           MutImmutable => {\n             // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).chain(|_t| Ok(*a) )\n+            self.tys(a.ty, b.ty).and_then(|_t| Ok(*a) )\n           }\n         }\n     }"}, {"sha": "1967122745dad5ebfaa98895dbebd991fd0fa8fd", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -202,7 +202,7 @@ impl RegionScope for MethodRscope {\n         if !self.region_param_names.has_ident(id) {\n             return RegionParamNames::undeclared_name(None);\n         }\n-        do EmptyRscope.named_region(span, id).chain_err |_e| {\n+        do EmptyRscope.named_region(span, id).or_else |_e| {\n             result::Err(RegionError {\n                 msg: ~\"lifetime is not in scope\",\n                 replacement: ty::re_bound(ty::br_self)\n@@ -251,7 +251,7 @@ impl RegionScope for TypeRscope {\n     }\n     fn named_region(&self, span: Span, id: ast::Ident)\n                       -> Result<ty::Region, RegionError> {\n-        do EmptyRscope.named_region(span, id).chain_err |_e| {\n+        do EmptyRscope.named_region(span, id).or_else |_e| {\n             result::Err(RegionError {\n                 msg: ~\"only 'self is allowed as part of a type declaration\",\n                 replacement: self.replacement()\n@@ -310,7 +310,7 @@ impl RegionScope for BindingRscope {\n                     span: Span,\n                     id: ast::Ident) -> Result<ty::Region, RegionError>\n     {\n-        do self.base.named_region(span, id).chain_err |_e| {\n+        do self.base.named_region(span, id).or_else |_e| {\n             let result = ty::re_bound(ty::br_named(id));\n             if self.region_param_names.has_ident(id) {\n                 result::Ok(result)"}, {"sha": "bd8d9a65cd33d666037b54bcf1739ce88966777b", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -68,7 +68,7 @@ fn fold_crate(\n     doc::CrateDoc {\n         topmod: doc::ModDoc {\n             item: doc::ItemDoc {\n-                name: attrs.name.clone().unwrap_or_default(doc.topmod.name_()),\n+                name: attrs.name.clone().unwrap_or(doc.topmod.name_()),\n                 .. doc.topmod.item.clone()\n             },\n             .. doc.topmod.clone()"}, {"sha": "ff6401456b6b9965d37616b3d870ce698544606a", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -138,30 +138,30 @@ fn config_from_opts(\n \n     let config = default_config(input_crate);\n     let result = result::Ok(config);\n-    let result = do result.chain |config| {\n+    let result = do result.and_then |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = output_dir.map_move(|s| Path(s));\n         result::Ok(Config {\n-            output_dir: output_dir.unwrap_or_default(config.output_dir.clone()),\n+            output_dir: output_dir.unwrap_or(config.output_dir.clone()),\n             .. config\n         })\n     };\n-    let result = do result.chain |config| {\n+    let result = do result.and_then |config| {\n         let output_format = getopts::opt_maybe_str(matches, opt_output_format());\n         do output_format.map_move_default(result::Ok(config.clone())) |output_format| {\n-            do parse_output_format(output_format).chain |output_format| {\n+            do parse_output_format(output_format).and_then |output_format| {\n                 result::Ok(Config {\n                     output_format: output_format,\n                     .. config.clone()\n                 })\n             }\n         }\n     };\n-    let result = do result.chain |config| {\n+    let result = do result.and_then |config| {\n         let output_style =\n             getopts::opt_maybe_str(matches, opt_output_style());\n         do output_style.map_move_default(result::Ok(config.clone())) |output_style| {\n-            do parse_output_style(output_style).chain |output_style| {\n+            do parse_output_style(output_style).and_then |output_style| {\n                 result::Ok(Config {\n                     output_style: output_style,\n                     .. config.clone()\n@@ -170,11 +170,11 @@ fn config_from_opts(\n         }\n     };\n     let process_output = Cell::new(process_output);\n-    let result = do result.chain |config| {\n+    let result = do result.and_then |config| {\n         let pandoc_cmd = getopts::opt_maybe_str(matches, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n             &config, pandoc_cmd, process_output.take());\n-        do pandoc_cmd.chain |pandoc_cmd| {\n+        do pandoc_cmd.and_then |pandoc_cmd| {\n             result::Ok(Config {\n                 pandoc_cmd: pandoc_cmd,\n                 .. config.clone()"}, {"sha": "6eb4cc56a2bdde1cd322831a7804f17a8f7d1e5e", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -118,7 +118,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n         if !l.is_whitespace() {\n             output = Some(l);\n         }\n-        match output.chain(try_parsing_version) {\n+        match output.and_then(try_parsing_version) {\n             Some(v) => return Some(v),\n             None    => ()\n         }\n@@ -158,7 +158,7 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n                 }\n             }\n \n-            output.chain(try_parsing_version)\n+            output.and_then(try_parsing_version)\n         }\n         else {\n             None"}, {"sha": "ce8e90e1a4324395f823a02201d7e223563b957c", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -45,7 +45,7 @@ pub fn capacity<T>(v: @[T]) -> uint {\n #[inline]\n pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> @[A] {\n     let mut vec = @[];\n-    unsafe { raw::reserve(&mut vec, size.unwrap_or_default(4)); }\n+    unsafe { raw::reserve(&mut vec, size.unwrap_or(4)); }\n     builder(|x| unsafe { raw::push(&mut vec, x) });\n     vec\n }"}, {"sha": "4ef50094139aa749bc5fe244bbefae4a9cde4fa9", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -24,6 +24,7 @@ Implementations of the following traits:\n * `Ord`\n * `TotalOrd`\n * `Eq`\n+* `Default`\n * `Zero`\n \n ## Various functions to compare `bool`s\n@@ -43,6 +44,7 @@ use to_str::ToStr;\n \n #[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering};\n #[cfg(not(test))] use ops::Not;\n+#[cfg(not(test))] use default::Default;\n #[cfg(not(test))] use num::Zero;\n \n /**\n@@ -323,6 +325,11 @@ impl Eq for bool {\n     fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n }\n \n+#[cfg(not(test))]\n+impl Default for bool {\n+    fn default() -> bool { false }\n+}\n+\n #[cfg(not(test))]\n impl Zero for bool {\n     fn zero() -> bool { false }"}, {"sha": "3a01e5908d9db821f5f99275e26a9700611cba01", "filename": "src/libstd/char.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -21,6 +21,7 @@ use str;\n #[cfg(test)] use str::OwnedStr;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use default::Default;\n #[cfg(not(test))] use num::Zero;\n \n // UTF-8 ranges and tags for encoding characters\n@@ -434,9 +435,18 @@ impl Ord for char {\n     fn lt(&self, other: &char) -> bool { *self < *other }\n }\n \n+#[cfg(not(test))]\n+impl Default for char {\n+    #[inline]\n+    fn default() -> char { '\\x00' }\n+}\n+\n #[cfg(not(test))]\n impl Zero for char {\n+    #[inline]\n     fn zero() -> char { '\\x00' }\n+\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == '\\x00' }\n }\n "}, {"sha": "120cf3fa8013bbb4e3bd50df1bbc655165ef33c7", "filename": "src/libstd/default.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdefault.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -15,3 +15,15 @@ pub trait Default {\n     /// Return the \"default value\" for a type.\n     fn default() -> Self;\n }\n+\n+impl<T: Default + 'static> Default for @mut T {\n+    fn default() -> @mut T { @mut Default::default() }\n+}\n+\n+impl<T: Default + 'static> Default for @T {\n+    fn default() -> @T { @Default::default() }\n+}\n+\n+impl<T: Default> Default for ~T {\n+    fn default() -> ~T { ~Default::default() }\n+}"}, {"sha": "27381f64ad4a6b05a996e9e932ca35b9d9ff45a0", "filename": "src/libstd/either.rs", "status": "modified", "additions": 184, "deletions": 12, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -13,6 +13,7 @@\n #[allow(missing_doc)];\n \n use option::{Some, None};\n+use option;\n use clone::Clone;\n use container::Container;\n use cmp::Eq;\n@@ -53,18 +54,6 @@ impl<L, R> Either<L, R> {\n         }\n     }\n \n-    /// Converts a `Either` to a `Result`\n-    ///\n-    /// Converts an `Either` type to a `Result` type, making the \"right\" choice\n-    /// an `Ok` result, and the \"left\" choice a `Err`\n-    #[inline]\n-    pub fn to_result(self) -> Result<R, L> {\n-        match self {\n-            Right(r) => result::Ok(r),\n-            Left(l) => result::Err(l)\n-        }\n-    }\n-\n     /// Checks whether the given value is a `Left`\n     #[inline]\n     pub fn is_left(&self) -> bool {\n@@ -116,6 +105,101 @@ impl<L, R> Either<L, R> {\n     }\n }\n \n+/// A generic trait for converting a value to a `Either`\n+pub trait ToEither<L, R> {\n+    /// Convert to the `either` type\n+    fn to_either(&self) -> Either<L, R>;\n+}\n+\n+/// A generic trait for converting a value to a `Either`\n+pub trait IntoEither<L, R> {\n+    /// Convert to the `either` type\n+    fn into_either(self) -> Either<L, R>;\n+}\n+\n+/// A generic trait for converting a value to a `Either`\n+pub trait AsEither<L, R> {\n+    /// Convert to the `either` type\n+    fn as_either<'a>(&'a self) -> Either<&'a L, &'a R>;\n+}\n+\n+impl<L, R: Clone> option::ToOption<R> for Either<L, R> {\n+    #[inline]\n+    fn to_option(&self)-> option::Option<R> {\n+        match *self {\n+            Left(_) => None,\n+            Right(ref r) => Some(r.clone()),\n+        }\n+    }\n+}\n+\n+impl<L, R> option::IntoOption<R> for Either<L, R> {\n+    #[inline]\n+    fn into_option(self)-> option::Option<R> {\n+        match self {\n+            Left(_) => None,\n+            Right(r) => Some(r),\n+        }\n+    }\n+}\n+\n+impl<L, R> option::AsOption<R> for Either<L, R> {\n+    #[inline]\n+    fn as_option<'a>(&'a self) -> option::Option<&'a R> {\n+        match *self {\n+            Left(_) => None,\n+            Right(ref r) => Some(r),\n+        }\n+    }\n+}\n+\n+impl<L: Clone, R: Clone> result::ToResult<R, L> for Either<L, R> {\n+    #[inline]\n+    fn to_result(&self)-> result::Result<R, L> {\n+        match *self {\n+            Left(ref l) => result::Err(l.clone()),\n+            Right(ref r) => result::Ok(r.clone()),\n+        }\n+    }\n+}\n+\n+impl<L, R> result::IntoResult<R, L> for Either<L, R> {\n+    #[inline]\n+    fn into_result(self)-> result::Result<R, L> {\n+        match self {\n+            Left(l) => result::Err(l),\n+            Right(r) => result::Ok(r),\n+        }\n+    }\n+}\n+\n+impl<L, R> result::AsResult<R, L> for Either<L, R> {\n+    #[inline]\n+    fn as_result<'a>(&'a self) -> result::Result<&'a R, &'a L> {\n+        match *self {\n+            Left(ref l) => result::Err(l),\n+            Right(ref r) => result::Ok(r),\n+        }\n+    }\n+}\n+\n+impl<L: Clone, R: Clone> ToEither<L, R> for Either<L, R> {\n+    fn to_either(&self) -> Either<L, R> { self.clone() }\n+}\n+\n+impl<L, R> IntoEither<L, R> for Either<L, R> {\n+    fn into_either(self) -> Either<L, R> { self }\n+}\n+\n+impl<L, R> AsEither<L, R> for Either<L, R> {\n+    fn as_either<'a>(&'a self) -> Either<&'a L, &'a R> {\n+        match *self {\n+            Left(ref l) => Left(l),\n+            Right(ref r) => Right(r),\n+        }\n+    }\n+}\n+\n /// An iterator yielding the `Left` values of its source\n pub type Lefts<L, R, Iter> = FilterMap<'static, Either<L, R>, L, Iter>;\n \n@@ -167,6 +251,11 @@ pub fn partition<L, R>(eithers: ~[Either<L, R>]) -> (~[L], ~[R]) {\n mod tests {\n     use super::*;\n \n+    use option::{IntoOption, ToOption, AsOption};\n+    use option;\n+    use result::{IntoResult, ToResult, AsResult};\n+    use result;\n+\n     #[test]\n     fn test_either_left() {\n         let val = Left(10);\n@@ -260,4 +349,87 @@ mod tests {\n         assert_eq!(rights.len(), 0u);\n     }\n \n+    #[test]\n+    pub fn test_to_option() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.to_option(), option::Some(100));\n+        assert_eq!(left.to_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_into_option() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.into_option(), option::Some(100));\n+        assert_eq!(left.into_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_as_option() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.as_option().unwrap(), &100);\n+        assert_eq!(left.as_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_to_result() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.to_result(), result::Ok(100));\n+        assert_eq!(left.to_result(), result::Err(404));\n+    }\n+\n+    #[test]\n+    pub fn test_into_result() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.into_result(), result::Ok(100));\n+        assert_eq!(left.into_result(), result::Err(404));\n+    }\n+\n+    #[test]\n+    pub fn test_as_result() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        let x = 100;\n+        assert_eq!(right.as_result(), result::Ok(&x));\n+\n+        let x = 404;\n+        assert_eq!(left.as_result(), result::Err(&x));\n+    }\n+\n+    #[test]\n+    pub fn test_to_either() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.to_either(), Right(100));\n+        assert_eq!(left.to_either(), Left(404));\n+    }\n+\n+    #[test]\n+    pub fn test_into_either() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.into_either(), Right(100));\n+        assert_eq!(left.into_either(), Left(404));\n+    }\n+\n+    #[test]\n+    pub fn test_as_either() {\n+        let right: Either<int, int> = Right(100);\n+        let left: Either<int, int> = Left(404);\n+\n+        assert_eq!(right.as_either().unwrap_right(), &100);\n+        assert_eq!(left.as_either().unwrap_left(), &404);\n+    }\n }"}, {"sha": "6c0a6a4ea0a157b9b62624ddacbdafcc7a8ef8fe", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -18,6 +18,7 @@\n use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n+use default::Default;\n use hash::Hash;\n use iter::{Iterator, FromIterator, Extendable};\n use iter::{FilterMap, Chain, Repeat, Zip};\n@@ -622,6 +623,10 @@ impl<K: Eq + Hash, V> Extendable<(K, V)> for HashMap<K, V> {\n     }\n }\n \n+impl<K: Eq + Hash, V> Default for HashMap<K, V> {\n+    fn default() -> HashMap<K, V> { HashMap::new() }\n+}\n+\n /// An implementation of a hash set using the underlying representation of a\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n /// requires that the elements implement the `Eq` and `Hash` traits.\n@@ -781,6 +786,10 @@ impl<K: Eq + Hash> Extendable<K> for HashSet<K> {\n     }\n }\n \n+impl<K: Eq + Hash> Default for HashSet<K> {\n+    fn default() -> HashSet<K> { HashSet::new() }\n+}\n+\n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n /// Set operations iterator"}, {"sha": "2ca36de4f49cce83a79c69e1736c49027abfca25", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -1618,7 +1618,7 @@ impl<T:Writer> WriterUtil for T {\n }\n \n pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n-    mk_file_writer(path, flags).chain(|w| Ok(w))\n+    mk_file_writer(path, flags).and_then(|w| Ok(w))\n }\n \n \n@@ -1779,7 +1779,7 @@ pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n }\n \n pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n-    do read_whole_file(file).chain |bytes| {\n+    do read_whole_file(file).and_then |bytes| {\n         if str::is_utf8(bytes) {\n             Ok(str::from_utf8(bytes))\n         } else {\n@@ -1791,7 +1791,7 @@ pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n-    do file_reader(file).chain |rdr| {\n+    do file_reader(file).and_then |rdr| {\n         Ok(rdr.read_whole_stream())\n     }\n }"}, {"sha": "ec3c02a31f2f57cf7004774917eb689582bbaa76", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -1474,7 +1474,7 @@ pub struct Scan<'self, A, B, T, St> {\n impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'self, A, B, T, St> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.iter.next().chain(|a| (self.f)(&mut self.state, a))\n+        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n     }\n \n     #[inline]\n@@ -1494,8 +1494,7 @@ pub struct FlatMap<'self, A, T, U> {\n     priv backiter: Option<U>,\n }\n \n-impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n-    FlatMap<'self, A, T, U> {\n+impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'self, A, T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n@@ -1505,7 +1504,7 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n                 }\n             }\n             match self.iter.next().map_move(|x| (self.f)(x)) {\n-                None => return self.backiter.chain_mut_ref(|it| it.next()),\n+                None => return self.backiter.and_then_mut_ref(|it| it.next()),\n                 next => self.frontiter = next,\n             }\n         }\n@@ -1537,7 +1536,7 @@ impl<'self,\n                 }\n             }\n             match self.iter.next_back().map_move(|x| (self.f)(x)) {\n-                None => return self.frontiter.chain_mut_ref(|it| it.next_back()),\n+                None => return self.frontiter.and_then_mut_ref(|it| it.next_back()),\n                 next => self.backiter = next,\n             }\n         }"}, {"sha": "0addcce3eb608657b6a50ae2c438cee6d8f946f1", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -12,6 +12,7 @@\n #[allow(missing_doc)];\n #[allow(non_uppercase_statics)];\n \n+use default::Default;\n use libc::c_int;\n use num::{Zero, One, strconv};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n@@ -237,6 +238,11 @@ impl Orderable for f32 {\n     }\n }\n \n+impl Default for f32 {\n+    #[inline]\n+    fn default() -> f32 { 0.0 }\n+}\n+\n impl Zero for f32 {\n     #[inline]\n     fn zero() -> f32 { 0.0 }"}, {"sha": "b0675278238e4c0e8fe92751cdd48e06c5bc9dbd", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -13,6 +13,7 @@\n #[allow(missing_doc)];\n #[allow(non_uppercase_statics)];\n \n+use default::Default;\n use libc::c_int;\n use num::{Zero, One, strconv};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n@@ -260,6 +261,11 @@ impl Orderable for f64 {\n     }\n }\n \n+impl Default for f64 {\n+    #[inline]\n+    fn default() -> f64 { 0.0 }\n+}\n+\n impl Zero for f64 {\n     #[inline]\n     fn zero() -> f64 { 0.0 }"}, {"sha": "3952f5478f7fdb956963edddae97a2fe71c3f2e2", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -23,6 +23,7 @@\n #[allow(missing_doc)];\n #[allow(non_uppercase_statics)];\n \n+use default::Default;\n use num::{Zero, One, strconv};\n use num::FPCategory;\n use num;\n@@ -382,6 +383,11 @@ impl Orderable for float {\n     }\n }\n \n+impl Default for float {\n+    #[inline]\n+    fn default() -> float { 0.0 }\n+}\n+\n impl Zero for float {\n     #[inline]\n     fn zero() -> float { 0.0 }"}, {"sha": "ae2a56b835dd2707f2ee5a817c5a399f61b10913", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -16,6 +16,7 @@ macro_rules! int_module (($T:ty, $bits:expr) => (mod generated {\n \n #[allow(non_uppercase_statics)];\n \n+use default::Default;\n use num::{ToStrRadix, FromStrRadix};\n use num::{CheckedDiv, Zero, One, strconv};\n use prelude::*;\n@@ -167,6 +168,11 @@ impl Orderable for $T {\n     }\n }\n \n+impl Default for $T {\n+    #[inline]\n+    fn default() -> $T { 0 }\n+}\n+\n impl Zero for $T {\n     #[inline]\n     fn zero() -> $T { 0 }"}, {"sha": "3deb7312b04f1da08a29d4f92c163ef1d6f44f17", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -16,6 +16,7 @@ macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (mod generated {\n \n #[allow(non_uppercase_statics)];\n \n+use default::Default;\n use num::BitCount;\n use num::{ToStrRadix, FromStrRadix};\n use num::{CheckedDiv, Zero, One, strconv};\n@@ -172,6 +173,11 @@ impl Orderable for $T {\n     }\n }\n \n+impl Default for $T {\n+    #[inline]\n+    fn default() -> $T { 0 }\n+}\n+\n impl Zero for $T {\n     #[inline]\n     fn zero() -> $T { 0 }"}, {"sha": "ce725257dfff03a4fefba00aa2df45b5172d15d5", "filename": "src/libstd/option.rs", "status": "modified", "additions": 300, "deletions": 21, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -43,10 +43,13 @@ let unwrapped_msg = match msg {\n \n use clone::Clone;\n use cmp::{Eq,Ord};\n+use default::Default;\n+use either;\n use util;\n use num::Zero;\n use iter;\n use iter::{Iterator, DoubleEndedIterator, ExactSize};\n+use result;\n use str::{StrSlice, OwnedStr};\n use to_str::ToStr;\n use clone::DeepClone;\n@@ -126,45 +129,64 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn is_some(&self) -> bool { !self.is_none() }\n \n-    /// Update an optional value by optionally running its content through a\n-    /// function that returns an option.\n+    /// Returns `None` if the option is `None`, otherwise returns `optb`.\n     #[inline]\n-    pub fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n+    pub fn and(self, optb: Option<T>) -> Option<T> {\n         match self {\n-            Some(t) => f(t),\n-            None => None\n+            Some(_) => optb,\n+            None => None,\n         }\n     }\n \n-    /// Returns the leftmost Some() value, or None if both are None.\n+    /// Returns `None` if the option is `None`, otherwise calls `f` with the\n+    /// wrapped value and returns the result.\n     #[inline]\n-    pub fn or(self, optb: Option<T>) -> Option<T> {\n+    pub fn and_then<U>(self, f: &fn(T) -> Option<U>) -> Option<U> {\n         match self {\n-            Some(opta) => Some(opta),\n-            _ => optb\n+            Some(x) => f(x),\n+            None => None,\n         }\n     }\n \n-    /// Update an optional value by optionally running its content by reference\n-    /// through a function that returns an option.\n+    /// Returns `None` if the option is `None`, otherwise calls `f` with a\n+    /// reference to the wrapped value and returns the result.\n     #[inline]\n-    pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n+    pub fn and_then_ref<'a, U>(&'a self, f: &fn(&'a T) -> Option<U>) -> Option<U> {\n         match *self {\n             Some(ref x) => f(x),\n             None => None\n         }\n     }\n \n-    /// Update an optional value by optionally running its content by mut reference\n-    /// through a function that returns an option.\n+    /// Returns `None` if the option is `None`, otherwise calls `f` with a\n+    /// mutable reference to the wrapped value and returns the result.\n     #[inline]\n-    pub fn chain_mut_ref<'a, U>(&'a mut self, f: &fn(x: &'a mut T) -> Option<U>) -> Option<U> {\n+    pub fn and_then_mut_ref<'a, U>(&'a mut self, f: &fn(&'a mut T) -> Option<U>) -> Option<U> {\n         match *self {\n             Some(ref mut x) => f(x),\n             None => None\n         }\n     }\n \n+    /// Returns the option if it contains a value, otherwise returns `optb`.\n+    #[inline]\n+    pub fn or(self, optb: Option<T>) -> Option<T> {\n+        match self {\n+            Some(_) => self,\n+            None => optb\n+        }\n+    }\n+\n+    /// Returns the option if it contains a value, otherwise calls `f` and\n+    /// returns the result.\n+    #[inline]\n+    pub fn or_else(self, f: &fn() -> Option<T>) -> Option<T> {\n+        match self {\n+            Some(_) => self,\n+            None => f(),\n+        }\n+    }\n+\n     /// Filters an optional value using given function.\n     #[inline(always)]\n     pub fn filtered(self, f: &fn(t: &T) -> bool) -> Option<T> {\n@@ -332,13 +354,22 @@ impl<T> Option<T> {\n \n     /// Returns the contained value or a default\n     #[inline]\n-    pub fn unwrap_or_default(self, def: T) -> T {\n+    pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n             None => def\n         }\n     }\n \n+    /// Returns the contained value or computes it from a closure\n+    #[inline]\n+    pub fn unwrap_or_else(self, f: &fn() -> T) -> T {\n+        match self {\n+            Some(x) => x,\n+            None => f()\n+        }\n+    }\n+\n     /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n     pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n@@ -349,6 +380,109 @@ impl<T> Option<T> {\n     }\n }\n \n+/// A generic trait for converting a value to a `Option`\n+pub trait ToOption<T> {\n+    /// Convert to the `option` type\n+    fn to_option(&self) -> Option<T>;\n+}\n+\n+/// A generic trait for converting a value to a `Option`\n+pub trait IntoOption<T> {\n+    /// Convert to the `option` type\n+    fn into_option(self) -> Option<T>;\n+}\n+\n+/// A generic trait for converting a value to a `Option`\n+pub trait AsOption<T> {\n+    /// Convert to the `option` type\n+    fn as_option<'a>(&'a self) -> Option<&'a T>;\n+}\n+\n+impl<T: Clone> ToOption<T> for Option<T> {\n+    #[inline]\n+    fn to_option(&self) -> Option<T> { self.clone() }\n+}\n+\n+impl<T> IntoOption<T> for Option<T> {\n+    #[inline]\n+    fn into_option(self) -> Option<T> { self }\n+}\n+\n+impl<T> AsOption<T> for Option<T> {\n+    #[inline]\n+    fn as_option<'a>(&'a self) -> Option<&'a T> {\n+        match *self {\n+            Some(ref x) => Some(x),\n+            None => None,\n+        }\n+    }\n+}\n+\n+impl<T: Clone> result::ToResult<T, ()> for Option<T> {\n+    #[inline]\n+    fn to_result(&self) -> result::Result<T, ()> {\n+        match *self {\n+            Some(ref x) => result::Ok(x.clone()),\n+            None => result::Err(()),\n+        }\n+    }\n+}\n+\n+impl<T> result::IntoResult<T, ()> for Option<T> {\n+    #[inline]\n+    fn into_result(self) -> result::Result<T, ()> {\n+        match self {\n+            Some(x) => result::Ok(x),\n+            None => result::Err(()),\n+        }\n+    }\n+}\n+\n+impl<T: Clone> either::ToEither<(), T> for Option<T> {\n+    #[inline]\n+    fn to_either(&self) -> either::Either<(), T> {\n+        match *self {\n+            Some(ref x) => either::Right(x.clone()),\n+            None => either::Left(()),\n+        }\n+    }\n+}\n+\n+impl<T> either::IntoEither<(), T> for Option<T> {\n+    #[inline]\n+    fn into_either(self) -> either::Either<(), T> {\n+        match self {\n+            Some(x) => either::Right(x),\n+            None => either::Left(()),\n+        }\n+    }\n+}\n+\n+impl<T: Default> Option<T> {\n+    /// Returns the contained value or default (for this type)\n+    #[inline]\n+    pub fn unwrap_or_default(self) -> T {\n+        match self {\n+            Some(x) => x,\n+            None => Default::default()\n+        }\n+    }\n+\n+    /// Returns self or `Some`-wrapped default value\n+    #[inline]\n+    pub fn or_default(self) -> Option<T> {\n+        match self {\n+            None => Some(Default::default()),\n+            x => x,\n+        }\n+    }\n+}\n+\n+impl<T> Default for Option<T> {\n+    #[inline]\n+    fn default() -> Option<T> { None }\n+}\n+\n impl<T:Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n     #[inline]\n@@ -369,11 +503,6 @@ impl<T:Zero> Option<T> {\n     }\n }\n \n-impl<T> Zero for Option<T> {\n-    fn zero() -> Option<T> { None }\n-    fn is_zero(&self) -> bool { self.is_none() }\n-}\n-\n /// An iterator that yields either one or zero elements\n #[deriving(Clone, DeepClone)]\n pub struct OptionIterator<A> {\n@@ -407,6 +536,11 @@ impl<A> ExactSize<A> for OptionIterator<A> {}\n #[cfg(test)]\n mod tests {\n     use super::*;\n+\n+    use either::{IntoEither, ToEither};\n+    use either;\n+    use result::{IntoResult, ToResult};\n+    use result;\n     use util;\n \n     #[test]\n@@ -475,6 +609,50 @@ mod tests {\n         let _y3 = y.take_unwrap();\n     }\n \n+    #[test]\n+    fn test_and() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.and(Some(2)), Some(2));\n+        assert_eq!(x.and(None), None);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.and(Some(2)), None);\n+        assert_eq!(x.and(None), None);\n+    }\n+\n+    #[test]\n+    fn test_and_then() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n+        assert_eq!(x.and_then(|_| None::<int>), None);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.and_then(|x| Some(x + 1)), None);\n+        assert_eq!(x.and_then(|_| None::<int>), None);\n+    }\n+\n+    #[test]\n+    fn test_or() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.or(Some(2)), Some(1));\n+        assert_eq!(x.or(None), Some(1));\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.or(Some(2)), Some(2));\n+        assert_eq!(x.or(None), None);\n+    }\n+\n+    #[test]\n+    fn test_or_else() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.or_else(|| Some(2)), Some(1));\n+        assert_eq!(x.or_else(|| None), Some(1));\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.or_else(|| Some(2)), Some(2));\n+        assert_eq!(x.or_else(|| None), None);\n+    }\n+\n     #[test]\n     fn test_option_while_some() {\n         let mut i = 0;\n@@ -489,6 +667,44 @@ mod tests {\n         assert_eq!(i, 11);\n     }\n \n+    #[test]\n+    fn test_unwrap() {\n+        assert_eq!(Some(1).unwrap(), 1);\n+        assert_eq!(Some(~\"hello\").unwrap(), ~\"hello\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_unwrap_fail1() {\n+        let x: Option<int> = None;\n+        x.unwrap();\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_unwrap_fail2() {\n+        let x: Option<~str> = None;\n+        x.unwrap();\n+    }\n+\n+    #[test]\n+    fn test_unwrap_or() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.unwrap_or(2), 1);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.unwrap_or(2), 2);\n+    }\n+\n+    #[test]\n+    fn test_unwrap_or_else() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.unwrap_or_else(|| 2), 1);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.unwrap_or_else(|| 2), 2);\n+    }\n+\n     #[test]\n     fn test_unwrap_or_zero() {\n         let some_stuff = Some(42);\n@@ -566,4 +782,67 @@ mod tests {\n         assert!(!x.mutate_default(0i, |i| i+1));\n         assert_eq!(x, Some(0i));\n     }\n+\n+    #[test]\n+    pub fn test_to_option() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.to_option(), Some(100));\n+        assert_eq!(none.to_option(), None);\n+    }\n+\n+    #[test]\n+    pub fn test_into_option() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.into_option(), Some(100));\n+        assert_eq!(none.into_option(), None);\n+    }\n+\n+    #[test]\n+    pub fn test_as_option() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.as_option().unwrap(), &100);\n+        assert_eq!(none.as_option(), None);\n+    }\n+\n+    #[test]\n+    pub fn test_to_result() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.to_result(), result::Ok(100));\n+        assert_eq!(none.to_result(), result::Err(()));\n+    }\n+\n+    #[test]\n+    pub fn test_into_result() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.into_result(), result::Ok(100));\n+        assert_eq!(none.into_result(), result::Err(()));\n+    }\n+\n+    #[test]\n+    pub fn test_to_either() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.to_either(), either::Right(100));\n+        assert_eq!(none.to_either(), either::Left(()));\n+    }\n+\n+    #[test]\n+    pub fn test_into_either() {\n+        let some: Option<int> = Some(100);\n+        let none: Option<int> = None;\n+\n+        assert_eq!(some.into_either(), either::Right(100));\n+        assert_eq!(none.into_either(), either::Left(()));\n+    }\n }"}, {"sha": "aeeae20720415172fe715a66e060edf9ba48561c", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -569,7 +569,7 @@ pub fn homedir() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn secondary() -> Option<Path> {\n-        do getenv(\"USERPROFILE\").chain |p| {\n+        do getenv(\"USERPROFILE\").and_then |p| {\n             if !p.is_empty() {\n                 Some(Path(p))\n             } else {\n@@ -611,7 +611,7 @@ pub fn tmpdir() -> Path {\n         if cfg!(target_os = \"android\") {\n             Path(\"/data/tmp\")\n         } else {\n-            getenv_nonempty(\"TMPDIR\").unwrap_or_default(Path(\"/tmp\"))\n+            getenv_nonempty(\"TMPDIR\").unwrap_or(Path(\"/tmp\"))\n         }\n     }\n \n@@ -620,7 +620,7 @@ pub fn tmpdir() -> Path {\n         getenv_nonempty(\"TMP\").or(\n             getenv_nonempty(\"TEMP\").or(\n                 getenv_nonempty(\"USERPROFILE\").or(\n-                   getenv_nonempty(\"WINDIR\")))).unwrap_or_default(Path(\"C:\\\\Windows\"))\n+                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path(\"C:\\\\Windows\"))\n     }\n }\n "}, {"sha": "3811f34cec43c1d5f0d4ebe32501dfdfd5eaa18b", "filename": "src/libstd/result.rs", "status": "modified", "additions": 241, "deletions": 31, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -17,6 +17,7 @@ use cmp::Eq;\n use either;\n use iter::Iterator;\n use option::{None, Option, Some, OptionIterator};\n+use option;\n use vec;\n use vec::OwnedVector;\n use to_str::ToStr;\n@@ -36,18 +37,6 @@ pub enum Result<T, E> {\n }\n \n impl<T, E: ToStr> Result<T, E> {\n-    /// Convert to the `either` type\n-    ///\n-    /// `Ok` result variants are converted to `either::Right` variants, `Err`\n-    /// result variants are converted to `either::Left`.\n-    #[inline]\n-    pub fn to_either(self)-> either::Either<E, T>{\n-        match self {\n-            Ok(t) => either::Right(t),\n-            Err(e) => either::Left(e),\n-        }\n-    }\n-\n     /// Get a reference to the value out of a successful result\n     ///\n     /// # Failure\n@@ -182,10 +171,22 @@ impl<T, E: ToStr> Result<T, E> {\n         }\n     }\n \n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok`, then `res` it is returned. If `self` is `Err`,\n+    /// then `self` is returned.\n+    #[inline]\n+    pub fn and(self, res: Result<T, E>) -> Result<T, E> {\n+        match self {\n+            Ok(_) => res,\n+            Err(_) => self,\n+        }\n+    }\n+\n     /// Call a method based on a previous result\n     ///\n     /// If `self` is `Ok` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is returned. if `self` is `Err` then it is\n+    /// whereupon `op`s result is returned. If `self` is `Err` then it is\n     /// immediately returned. This function can be used to compose the results\n     /// of two functions.\n     ///\n@@ -195,21 +196,33 @@ impl<T, E: ToStr> Result<T, E> {\n     ///         Ok(parse_bytes(buf))\n     ///     };\n     #[inline]\n-    pub fn chain<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n+    pub fn and_then<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n             Err(e) => Err(e),\n         }\n     }\n \n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok`, then `self` is returned. If `self` is `Err`\n+    /// then `res` is returned.\n+    #[inline]\n+    pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n+        match self {\n+            Ok(_) => self,\n+            Err(_) => res,\n+        }\n+    }\n+\n     /// Call a function based on a previous result\n     ///\n     /// If `self` is `Err` then the value is extracted and passed to `op`\n     /// whereupon `op`s result is returned. if `self` is `Ok` then it is\n     /// immediately returned.  This function can be used to pass through a\n     /// successful result while handling an error.\n     #[inline]\n-    pub fn chain_err<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n+    pub fn or_else<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n             Err(e) => op(e),\n@@ -255,6 +268,104 @@ impl<T, E: Clone + ToStr> Result<T, E> {\n     }\n }\n \n+/// A generic trait for converting a value to a `Result`\n+pub trait ToResult<T, E> {\n+    /// Convert to the `result` type\n+    fn to_result(&self) -> Result<T, E>;\n+}\n+\n+/// A generic trait for converting a value to a `Result`\n+pub trait IntoResult<T, E> {\n+    /// Convert to the `result` type\n+    fn into_result(self) -> Result<T, E>;\n+}\n+\n+/// A generic trait for converting a value to a `Result`\n+pub trait AsResult<T, E> {\n+    /// Convert to the `result` type\n+    fn as_result<'a>(&'a self) -> Result<&'a T, &'a E>;\n+}\n+\n+impl<T: Clone, E> option::ToOption<T> for Result<T, E> {\n+    #[inline]\n+    fn to_option(&self)-> Option<T> {\n+        match *self {\n+            Ok(ref t) => Some(t.clone()),\n+            Err(_) => None,\n+        }\n+    }\n+}\n+\n+impl<T, E> option::IntoOption<T> for Result<T, E> {\n+    #[inline]\n+    fn into_option(self)-> Option<T> {\n+        match self {\n+            Ok(t) => Some(t),\n+            Err(_) => None,\n+        }\n+    }\n+}\n+\n+impl<T, E> option::AsOption<T> for Result<T, E> {\n+    #[inline]\n+    fn as_option<'a>(&'a self)-> Option<&'a T> {\n+        match *self {\n+            Ok(ref t) => Some(t),\n+            Err(_) => None,\n+        }\n+    }\n+}\n+\n+impl<T: Clone, E: Clone> ToResult<T, E> for Result<T, E> {\n+    #[inline]\n+    fn to_result(&self) -> Result<T, E> { self.clone() }\n+}\n+\n+impl<T, E> IntoResult<T, E> for Result<T, E> {\n+    #[inline]\n+    fn into_result(self) -> Result<T, E> { self }\n+}\n+\n+impl<T, E> AsResult<T, E> for Result<T, E> {\n+    #[inline]\n+    fn as_result<'a>(&'a self) -> Result<&'a T, &'a E> {\n+        match *self {\n+            Ok(ref t) => Ok(t),\n+            Err(ref e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl<T: Clone, E: Clone> either::ToEither<E, T> for Result<T, E> {\n+    #[inline]\n+    fn to_either(&self)-> either::Either<E, T> {\n+        match *self {\n+            Ok(ref t) => either::Right(t.clone()),\n+            Err(ref e) => either::Left(e.clone()),\n+        }\n+    }\n+}\n+\n+impl<T, E> either::IntoEither<E, T> for Result<T, E> {\n+    #[inline]\n+    fn into_either(self)-> either::Either<E, T> {\n+        match self {\n+            Ok(t) => either::Right(t),\n+            Err(e) => either::Left(e),\n+        }\n+    }\n+}\n+\n+impl<T, E> either::AsEither<E, T> for Result<T, E> {\n+    #[inline]\n+    fn as_either<'a>(&'a self)-> either::Either<&'a E, &'a T> {\n+        match *self {\n+            Ok(ref t) => either::Right(t),\n+            Err(ref e) => either::Left(e),\n+        }\n+    }\n+}\n+\n #[inline]\n #[allow(missing_doc)]\n pub fn map_opt<T, U: ToStr, V>(o_t: &Option<T>,\n@@ -334,27 +445,51 @@ pub fn fold_<T, E, Iter: Iterator<Result<T, E>>>(\n mod tests {\n     use super::*;\n \n+    use either::{IntoEither, ToEither, AsEither};\n     use either;\n     use iter::range;\n+    use option::{IntoOption, ToOption, AsOption};\n+    use option;\n     use str::OwnedStr;\n     use vec::ImmutableVector;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n+    pub fn op2() -> Result<int, ~str> { Err(~\"sadface\") }\n+\n+    #[test]\n+    pub fn test_and() {\n+        assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n+        assert_eq!(op1().and(Err(~\"bad\")).unwrap_err(), ~\"bad\");\n \n-    pub fn op2(i: int) -> Result<uint, ~str> {\n-        Ok(i as uint + 1u)\n+        assert_eq!(op2().and(Ok(667)).unwrap_err(), ~\"sadface\");\n+        assert_eq!(op2().and(Err(~\"bad\")).unwrap_err(), ~\"sadface\");\n     }\n \n-    pub fn op3() -> Result<int, ~str> { Err(~\"sadface\") }\n+    #[test]\n+    pub fn test_and_then() {\n+        assert_eq!(op1().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap(), 667);\n+        assert_eq!(op1().and_then(|_| Err::<int, ~str>(~\"bad\")).unwrap_err(), ~\"bad\");\n+\n+        assert_eq!(op2().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap_err(), ~\"sadface\");\n+        assert_eq!(op2().and_then(|_| Err::<int, ~str>(~\"bad\")).unwrap_err(), ~\"sadface\");\n+    }\n \n     #[test]\n-    pub fn chain_success() {\n-        assert_eq!(op1().chain(op2).unwrap(), 667u);\n+    pub fn test_or() {\n+        assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n+        assert_eq!(op1().or(Err(~\"bad\")).unwrap(), 666);\n+\n+        assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n+        assert_eq!(op2().or(Err(~\"bad\")).unwrap_err(), ~\"bad\");\n     }\n \n     #[test]\n-    pub fn chain_failure() {\n-        assert_eq!(op3().chain( op2).unwrap_err(), ~\"sadface\");\n+    pub fn test_or_else() {\n+        assert_eq!(op1().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 666);\n+        assert_eq!(op1().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap(), 666);\n+\n+        assert_eq!(op2().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 667);\n+        assert_eq!(op2().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap_err(), ~\"sadface!\");\n     }\n \n     #[test]\n@@ -412,15 +547,6 @@ mod tests {\n         assert_eq!(*foo.get_ref(), 100);\n     }\n \n-    #[test]\n-    pub fn test_to_either() {\n-        let r: Result<int, ()> = Ok(100);\n-        let err: Result<(), int> = Err(404);\n-\n-        assert_eq!(r.to_either(), either::Right(100));\n-        assert_eq!(err.to_either(), either::Left(404));\n-    }\n-\n     #[test]\n     fn test_collect() {\n         assert_eq!(collect(range(0, 0)\n@@ -460,4 +586,88 @@ mod tests {\n                         .map(|f| (*f)())),\n                    Err(1));\n     }\n+\n+    #[test]\n+    pub fn test_to_option() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.to_option(), option::Some(100));\n+        assert_eq!(err.to_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_into_option() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.into_option(), option::Some(100));\n+        assert_eq!(err.into_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_as_option() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.as_option().unwrap(), &100);\n+        assert_eq!(err.as_option(), option::None);\n+    }\n+\n+    #[test]\n+    pub fn test_to_result() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.to_result(), Ok(100));\n+        assert_eq!(err.to_result(), Err(404));\n+    }\n+\n+    #[test]\n+    pub fn test_into_result() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.into_result(), Ok(100));\n+        assert_eq!(err.into_result(), Err(404));\n+    }\n+\n+    #[test]\n+    pub fn test_as_result() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        let x = 100;\n+        assert_eq!(ok.as_result(), Ok(&x));\n+\n+        let x = 404;\n+        assert_eq!(err.as_result(), Err(&x));\n+    }\n+\n+    #[test]\n+    pub fn test_to_either() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.to_either(), either::Right(100));\n+        assert_eq!(err.to_either(), either::Left(404));\n+    }\n+\n+    #[test]\n+    pub fn test_into_either() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.into_either(), either::Right(100));\n+        assert_eq!(err.into_either(), either::Left(404));\n+    }\n+\n+    #[test]\n+    pub fn test_as_either() {\n+        let ok: Result<int, int> = Ok(100);\n+        let err: Result<int, int> = Err(404);\n+\n+        assert_eq!(ok.as_either().unwrap_right(), &100);\n+        assert_eq!(err.as_either().unwrap_left(), &404);\n+    }\n }"}, {"sha": "041253455f01a48cad69e6defa0159dc04bf57cb", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -177,7 +177,7 @@ impl<'self> Parser<'self> {\n         }\n \n         do self.read_atomically |p| {\n-            p.read_char().chain(|c| parse_digit(c, radix))\n+            p.read_char().and_then(|c| parse_digit(c, radix))\n         }\n     }\n "}, {"sha": "f47468e1ef8ca4dc73cc45efa23b5c34c4aab658", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -383,5 +383,5 @@ mod test {\n     #[test] fn iterbytes_compiles () {\n         takes_iterbytes((3,4,5,false));\n     }\n-    fn takes_iterbytes<T : IterBytes>(x : T) {}\n+    fn takes_iterbytes<T : IterBytes>(_x : T) {}\n }"}, {"sha": "2591131f21521e5020ac05aef287f63f07852bc9", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -89,6 +89,7 @@ macro_rules! tuple_impls {\n         pub mod inner {\n             use clone::Clone;\n             #[cfg(not(test))] use cmp::*;\n+            #[cfg(not(test))] use default::Default;\n             #[cfg(not(test))] use num::Zero;\n \n             $(\n@@ -172,6 +173,14 @@ macro_rules! tuple_impls {\n                     }\n                 }\n \n+                #[cfg(not(test))]\n+                impl<$($T:Default),+> Default for ($($T,)+) {\n+                    #[inline]\n+                    fn default() -> ($($T,)+) {\n+                        ($({ let x: $T = Default::default(); x},)+)\n+                    }\n+                }\n+\n                 #[cfg(not(test))]\n                 impl<$($T:Zero),+> Zero for ($($T,)+) {\n                     #[inline]"}, {"sha": "dfe4abe54e5b5c236d337bb82e9fd8494064c5fe", "filename": "src/libstd/unit.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -45,15 +45,16 @@ impl TotalEq for () {\n     fn equals(&self, _other: &()) -> bool { true }\n }\n \n+#[cfg(not(test))]\n+impl Default for () {\n+    #[inline]\n+    fn default() -> () { () }\n+}\n+\n #[cfg(not(test))]\n impl Zero for () {\n     #[inline]\n     fn zero() -> () { () }\n     #[inline]\n     fn is_zero(&self) -> bool { true }\n }\n-\n-#[cfg(not(test))]\n-impl Default for () {\n-    fn default() -> () { () }\n-}"}, {"sha": "47c3a07961444b90a20af13de4b8cb0533fcaa27", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -104,9 +104,10 @@ use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n use cmp;\n+use default::Default;\n use iter::*;\n use libc::c_void;\n-use num::{Integer, Zero, CheckedAdd, Saturating};\n+use num::{Integer, CheckedAdd, Saturating};\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n@@ -205,7 +206,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n  */\n #[inline]\n pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> ~[A] {\n-    let mut vec = with_capacity(size.unwrap_or_default(4));\n+    let mut vec = with_capacity(size.unwrap_or(4));\n     builder(|x| vec.push(x));\n     vec\n }\n@@ -2237,19 +2238,16 @@ impl<A: DeepClone> DeepClone for ~[A] {\n }\n \n // This works because every lifetime is a sub-lifetime of 'static\n-impl<'self, A> Zero for &'self [A] {\n-    fn zero() -> &'self [A] { &'self [] }\n-    fn is_zero(&self) -> bool { self.is_empty() }\n+impl<'self, A> Default for &'self [A] {\n+    fn default() -> &'self [A] { &'self [] }\n }\n \n-impl<A> Zero for ~[A] {\n-    fn zero() -> ~[A] { ~[] }\n-    fn is_zero(&self) -> bool { self.len() == 0 }\n+impl<A> Default for ~[A] {\n+    fn default() -> ~[A] { ~[] }\n }\n \n-impl<A> Zero for @[A] {\n-    fn zero() -> @[A] { @[] }\n-    fn is_zero(&self) -> bool { self.len() == 0 }\n+impl<A> Default for @[A] {\n+    fn default() -> @[A] { @[] }\n }\n \n macro_rules! iterator {\n@@ -3588,13 +3586,12 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_vec_zero() {\n-        use num::Zero;\n+    fn test_vec_default() {\n+        use default::Default;\n         macro_rules! t (\n             ($ty:ty) => {{\n-                let v: $ty = Zero::zero();\n+                let v: $ty = Default::default();\n                 assert!(v.is_empty());\n-                assert!(v.is_zero());\n             }}\n         );\n "}, {"sha": "295485d6f6efaa7a30a4e29a3baaafedec2e3e66", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -187,12 +187,12 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n                                  -> Option<@str> {\n     attrs.iter()\n         .find(|at| name == at.name())\n-        .chain(|at| at.value_str())\n+        .and_then(|at| at.value_str())\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<@str> {\n-    items.rev_iter().find(|mi| name == mi.name()).chain(|i| i.value_str())\n+    items.rev_iter().find(|mi| name == mi.name()).and_then(|i| i.value_str())\n }\n \n /* Higher-level applications */"}, {"sha": "0c7bbefc690157138e7173f0222baa09a241d178", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{MetaItem, item, Expr};\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+\n+use std::vec;\n+\n+pub fn expand_deriving_default(cx: @ExtCtxt,\n+                            span: Span,\n+                            mitem: @MetaItem,\n+                            in_items: ~[@item])\n+    -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[\"std\", \"default\", \"Default\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: \"default\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[],\n+                ret_ty: Self,\n+                const_nonmatching: false,\n+                combine_substructure: default_substructure\n+            },\n+        ]\n+    };\n+    trait_def.expand(cx, span, mitem, in_items)\n+}\n+\n+fn default_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    let default_ident = ~[\n+        cx.ident_of(\"std\"),\n+        cx.ident_of(\"default\"),\n+        cx.ident_of(\"Default\"),\n+        cx.ident_of(\"default\")\n+    ];\n+    let default_call = || {\n+        cx.expr_call_global(span, default_ident.clone(), ~[])\n+    };\n+\n+    return match *substr.fields {\n+        StaticStruct(_, ref summary) => {\n+            match *summary {\n+                Left(count) => {\n+                    if count == 0 {\n+                        cx.expr_ident(span, substr.type_ident)\n+                    } else {\n+                        let exprs = vec::from_fn(count, |_| default_call());\n+                        cx.expr_call_ident(span, substr.type_ident, exprs)\n+                    }\n+                }\n+                Right(ref fields) => {\n+                    let default_fields = do fields.map |ident| {\n+                        cx.field_imm(span, *ident, default_call())\n+                    };\n+                    cx.expr_struct_ident(span, substr.type_ident, default_fields)\n+                }\n+            }\n+        }\n+        StaticEnum(*) => {\n+            cx.span_fatal(span, \"`Default` cannot be derived for enums, \\\n+                                 only structs\")\n+        }\n+        _ => cx.bug(\"Non-static method in `deriving(Default)`\")\n+    };\n+}"}, {"sha": "dfd4f79cd9e3e5a2c5055853230556a080a1ef45", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -31,6 +31,7 @@ pub mod decodable;\n pub mod rand;\n pub mod to_str;\n pub mod zero;\n+pub mod default;\n \n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n@@ -97,6 +98,7 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n \n                             \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n                             \"Zero\" => expand!(zero::expand_deriving_zero),\n+                            \"Default\" => expand!(default::expand_deriving_default),\n \n                             ref tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\"}, {"sha": "4d62285cf6ee8e5a5c58982a684ce83a0b6c005e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -331,11 +331,18 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n     };\n \n     let maybe_it = match expanded {\n-        MRItem(it) => mark_item(it,fm).chain(|i| {fld.fold_item(i)}),\n-        MRExpr(_) => cx.span_fatal(pth.span,\n-                                   fmt!(\"expr macro in item position: %s\", extnamestr)),\n-        MRAny(_, item_maker, _) => item_maker().chain(|i| {mark_item(i,fm)})\n-                                      .chain(|i| {fld.fold_item(i)}),\n+        MRItem(it) => {\n+            mark_item(it,fm)\n+                .and_then(|i| fld.fold_item(i))\n+        }\n+        MRExpr(_) => {\n+            cx.span_fatal(pth.span, fmt!(\"expr macro in item position: %s\", extnamestr))\n+        }\n+        MRAny(_, item_maker, _) => {\n+            item_maker()\n+                .and_then(|i| mark_item(i,fm))\n+                .and_then(|i| fld.fold_item(i))\n+        }\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one."}, {"sha": "46940d2d4daed1ebd843ececc3bbc8970b068534", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -140,6 +140,10 @@ impl<A:Eq> Eq for OptVec<A> {\n     }\n }\n \n+impl<T> Default for OptVec<T> {\n+    fn default() -> OptVec<T> { Empty }\n+}\n+\n pub struct OptVecIterator<'self, T> {\n     priv iter: Option<VecIterator<'self, T>>\n }"}, {"sha": "6a15641430fb91646b37b6f70802d011534c4f62", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -802,7 +802,7 @@ impl Parser {\n         */\n \n         let opt_abis = self.parse_opt_abis();\n-        let abis = opt_abis.unwrap_or_default(AbiSet::Rust());\n+        let abis = opt_abis.unwrap_or(AbiSet::Rust());\n         let purity = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl();\n@@ -3461,7 +3461,7 @@ impl Parser {\n         let ident = self.parse_ident();\n         let opt_bounds = self.parse_optional_ty_param_bounds();\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n-        let bounds = opt_bounds.unwrap_or_default(opt_vec::Empty);\n+        let bounds = opt_bounds.unwrap_or_default();\n         ast::TyParam { ident: ident, id: ast::DUMMY_NODE_ID, bounds: bounds }\n     }\n \n@@ -4363,7 +4363,7 @@ impl Parser {\n                 self.obsolete(*self.last_span, ObsoleteExternVisibility);\n             }\n \n-            let abis = opt_abis.unwrap_or_default(AbiSet::C());\n+            let abis = opt_abis.unwrap_or(AbiSet::C());\n \n             let (inner, next) = self.parse_inner_attrs_and_next();\n             let m = self.parse_foreign_mod_items(sort, abis, next);\n@@ -4640,7 +4640,7 @@ impl Parser {\n \n             if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n-                let abis = opt_abis.unwrap_or_default(AbiSet::C());\n+                let abis = opt_abis.unwrap_or(AbiSet::C());\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn, abis);\n                 return iovi_item(self.mk_item(lo, self.last_span.hi, ident,"}, {"sha": "fb4ffb2c3c15db232790e0af30e9b6f3f771fda7", "filename": "src/test/run-pass/deriving-zero.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa578efd9834e37ad52879ff10ee2c2aa938389/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=2aa578efd9834e37ad52879ff10ee2c2aa938389", "patch": "@@ -24,15 +24,13 @@ struct E { a: int, b: int }\n \n #[deriving(Zero)]\n struct Lots {\n-    c: Option<util::NonCopyable>,\n     d: u8,\n     e: char,\n     f: float,\n     g: (f32, char),\n-    h: ~[util::NonCopyable],\n-    i: @mut (int, int),\n-    j: bool,\n-    k: (),\n+    h: @mut (int, int),\n+    i: bool,\n+    j: (),\n }\n \n fn main() {"}]}