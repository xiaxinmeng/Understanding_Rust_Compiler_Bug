{"sha": "ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "node_id": "C_kwDOAAsO6NoAKGVhN2Y3ZjdjNGM1Y2JiMDM2NDQ0ZjE4ZTk3YTQ0ZTUxMTIwZWU2MDk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-21T18:36:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-21T18:36:48Z"}, "message": "Rollup merge of #94143 - est31:let_else_const_eval, r=lcnr\n\nrustc_const_eval: adopt let else in more places\n\nContinuation of #89933, #91018, #91481, #93046, #93590, #94011.\n\nI have extended my clippy lint to also recognize tuple passing and match statements. The diff caused by fixing it is way above 1 thousand lines. Thus, I split it up into multiple pull requests to make reviewing easier. This PR handles rustc_const_eval.", "tree": {"sha": "e73a4419dd43c1299cabf9bf50d410fdff9cacc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e73a4419dd43c1299cabf9bf50d410fdff9cacc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiE9vACRBK7hj4Ov3rIwAAEA4IAAr+4HZPfbDkcTxhzsHR/OCW\n2yl7eGEnPd3NfWPZ0BHmd02UDGHObcrw9Y0t7qytO0L6Z6UwxKCIB6QB9MVeTTsh\nifdefy9CiAUVlXH99N7kq/nFqhv7DXRh8TRNXKNrk2nxgjp+ULgzE7SFH2OMMdx1\nAaeCNHY8PDzb6qf6PsCrqPIgY+rnuoWDGhJsrYE0zStmhu/WFJ9uePG5LtWpn6sD\nA0Rs1/Unt3wSI7BNPA2uwtm+KICmYXGbf8wPM5tuTOONzmddmawV5TIiwHNWoUKJ\nu1jX8vj2aIuHDLXRl9HQ52N1HgXfTpREh1vukmt0BERI30afTc1kskbgSDnvWOM=\n=Qlqe\n-----END PGP SIGNATURE-----\n", "payload": "tree e73a4419dd43c1299cabf9bf50d410fdff9cacc3\nparent 12705b47007f3244ef9d06d2281e1b20cb1dd0f1\nparent 413f3f787c9e8e4c2cb8abd73cdc16cb8d175590\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645468608 +0100\ncommitter GitHub <noreply@github.com> 1645468608 +0100\n\nRollup merge of #94143 - est31:let_else_const_eval, r=lcnr\n\nrustc_const_eval: adopt let else in more places\n\nContinuation of #89933, #91018, #91481, #93046, #93590, #94011.\n\nI have extended my clippy lint to also recognize tuple passing and match statements. The diff caused by fixing it is way above 1 thousand lines. Thus, I split it up into multiple pull requests to make reviewing easier. This PR handles rustc_const_eval.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "html_url": "https://github.com/rust-lang/rust/commit/ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12705b47007f3244ef9d06d2281e1b20cb1dd0f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/12705b47007f3244ef9d06d2281e1b20cb1dd0f1", "html_url": "https://github.com/rust-lang/rust/commit/12705b47007f3244ef9d06d2281e1b20cb1dd0f1"}, {"sha": "413f3f787c9e8e4c2cb8abd73cdc16cb8d175590", "url": "https://api.github.com/repos/rust-lang/rust/commits/413f3f787c9e8e4c2cb8abd73cdc16cb8d175590", "html_url": "https://github.com/rust-lang/rust/commit/413f3f787c9e8e4c2cb8abd73cdc16cb8d175590"}], "stats": {"total": 209, "additions": 86, "deletions": 123}, "files": [{"sha": "533c32f807df6d5fbb1325a21401f6f63bb4fc88", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -231,9 +231,8 @@ pub fn eval_to_const_value_raw_provider<'tcx>(\n     // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n     if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n         let ty = key.value.instance.ty(tcx, key.param_env);\n-        let substs = match ty.kind() {\n-            ty::FnDef(_, substs) => substs,\n-            _ => bug!(\"intrinsic with type {:?}\", ty),\n+        let ty::FnDef(_, substs) = ty.kind() else {\n+            bug!(\"intrinsic with type {:?}\", ty);\n         };\n         return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n             let span = tcx.def_span(def_id);"}, {"sha": "b2019ce40c3eaa2d2889d70ab2568b07d99d148b", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -318,15 +318,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n \n         // CTFE-specific intrinsics.\n-        let (dest, ret) = match ret {\n-            None => {\n-                return Err(ConstEvalErrKind::NeedsRfc(format!(\n-                    \"calling intrinsic `{}`\",\n-                    intrinsic_name\n-                ))\n-                .into());\n-            }\n-            Some(p) => p,\n+        let Some((dest, ret)) = ret else {\n+            return Err(ConstEvalErrKind::NeedsRfc(format!(\n+                \"calling intrinsic `{}`\",\n+                intrinsic_name\n+            ))\n+            .into());\n         };\n         match intrinsic_name {\n             sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {"}, {"sha": "ab50c709143fd0dc0590f086fd1c491bc145f82d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -631,15 +631,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1);\n-                let (unsized_size, unsized_align) =\n-                    match self.size_and_align_of(metadata, &field)? {\n-                        Some(size_and_align) => size_and_align,\n-                        None => {\n-                            // A field with an extern type. We don't know the actual dynamic size\n-                            // or the alignment.\n-                            return Ok(None);\n-                        }\n-                    };\n+                let Some((unsized_size, unsized_align)) = self.size_and_align_of(metadata, &field)? else {\n+                    // A field with an extern type. We don't know the actual dynamic size\n+                    // or the alignment.\n+                    return Ok(None);\n+                };\n \n                 // FIXME (#26403, #27023): We should be adding padding\n                 // to `sized_size` (to accommodate the `unsized_align`"}, {"sha": "b1f50bc56c908c88a2c5d5afa682692b04d8e0a7", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -84,22 +84,19 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     trace!(\"intern_shallow {:?} with {:?}\", alloc_id, mode);\n     // remove allocation\n     let tcx = ecx.tcx;\n-    let (kind, mut alloc) = match ecx.memory.alloc_map.remove(&alloc_id) {\n-        Some(entry) => entry,\n-        None => {\n-            // Pointer not found in local memory map. It is either a pointer to the global\n-            // map, or dangling.\n-            // If the pointer is dangling (neither in local nor global memory), we leave it\n-            // to validation to error -- it has the much better error messages, pointing out where\n-            // in the value the dangling reference lies.\n-            // The `delay_span_bug` ensures that we don't forget such a check in validation.\n-            if tcx.get_global_alloc(alloc_id).is_none() {\n-                tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n-            }\n-            // treat dangling pointers like other statics\n-            // just to stop trying to recurse into them\n-            return Some(IsStaticOrFn);\n+    let Some((kind, mut alloc)) = ecx.memory.alloc_map.remove(&alloc_id) else {\n+        // Pointer not found in local memory map. It is either a pointer to the global\n+        // map, or dangling.\n+        // If the pointer is dangling (neither in local nor global memory), we leave it\n+        // to validation to error -- it has the much better error messages, pointing out where\n+        // in the value the dangling reference lies.\n+        // The `delay_span_bug` ensures that we don't forget such a check in validation.\n+        if tcx.get_global_alloc(alloc_id).is_none() {\n+            tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n         }\n+        // treat dangling pointers like other statics\n+        // just to stop trying to recurse into them\n+        return Some(IsStaticOrFn);\n     };\n     // This match is just a canary for future changes to `MemoryKind`, which most likely need\n     // changes in this function."}, {"sha": "73e7d862ad64186cacb0a7d6f22b4c167f79d600", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -291,21 +291,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             );\n         }\n \n-        let (alloc_kind, mut alloc) = match self.alloc_map.remove(&alloc_id) {\n-            Some(alloc) => alloc,\n-            None => {\n-                // Deallocating global memory -- always an error\n-                return Err(match self.tcx.get_global_alloc(alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => {\n-                        err_ub_format!(\"deallocating {}, which is a function\", alloc_id)\n-                    }\n-                    Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                        err_ub_format!(\"deallocating {}, which is static memory\", alloc_id)\n-                    }\n-                    None => err_ub!(PointerUseAfterFree(alloc_id)),\n+        let Some((alloc_kind, mut alloc)) = self.alloc_map.remove(&alloc_id) else {\n+            // Deallocating global memory -- always an error\n+            return Err(match self.tcx.get_global_alloc(alloc_id) {\n+                Some(GlobalAlloc::Function(..)) => {\n+                    err_ub_format!(\"deallocating {}, which is a function\", alloc_id)\n                 }\n-                .into());\n+                Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n+                    err_ub_format!(\"deallocating {}, which is static memory\", alloc_id)\n+                }\n+                None => err_ub!(PointerUseAfterFree(alloc_id)),\n             }\n+            .into());\n         };\n \n         if alloc.mutability == Mutability::Not {\n@@ -957,9 +954,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        let alloc_ref = match self.get(ptr, size, Align::ONE)? {\n-            Some(a) => a,\n-            None => return Ok(&[]), // zero-sized access\n+        let Some(alloc_ref) = self.get(ptr, size, Align::ONE)? else {\n+            // zero-sized access\n+            return Ok(&[]);\n         };\n         // Side-step AllocRef and directly access the underlying bytes more efficiently.\n         // (We are staying inside the bounds here so all is good.)\n@@ -983,17 +980,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n \n         let size = Size::from_bytes(len);\n-        let alloc_ref = match self.get_mut(ptr, size, Align::ONE)? {\n-            Some(alloc_ref) => alloc_ref,\n-            None => {\n-                // zero-sized access\n-                assert_matches!(\n-                    src.next(),\n-                    None,\n-                    \"iterator said it was empty but returned an element\"\n-                );\n-                return Ok(());\n-            }\n+        let Some(alloc_ref) = self.get_mut(ptr, size, Align::ONE)? else {\n+            // zero-sized access\n+            assert_matches!(\n+                src.next(),\n+                None,\n+                \"iterator said it was empty but returned an element\"\n+            );\n+            return Ok(());\n         };\n \n         // Side-step AllocRef and directly access the underlying bytes more efficiently.\n@@ -1043,18 +1037,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // and once below to get the underlying `&[mut] Allocation`.\n \n         // Source alloc preparations and access hooks.\n-        let (src_alloc_id, src_offset, src) = match src_parts {\n-            None => return Ok(()), // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n-            Some(src_ptr) => src_ptr,\n+        let Some((src_alloc_id, src_offset, src)) = src_parts else {\n+            // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n+            return Ok(());\n         };\n         let src_alloc = self.get_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n         M::memory_read(&self.extra, &src_alloc.extra, src.provenance, src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n-        let (dest_alloc_id, dest_offset, dest) = match dest_parts {\n-            None => return Ok(()), // Zero-sized *destiantion*.\n-            Some(dest_ptr) => dest_ptr,\n+        let Some((dest_alloc_id, dest_offset, dest)) = dest_parts else {\n+            // Zero-sized *destination*.\n+            return Ok(());\n         };\n \n         // This checks relocation edges on the src, which needs to happen before"}, {"sha": "60e915a7eee113ae26becdc2e30edc132c209a8a", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -258,15 +258,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let alloc = match self.get_alloc(mplace)? {\n-            Some(ptr) => ptr,\n-            None => {\n-                return Ok(Some(ImmTy {\n-                    // zero-sized type\n-                    imm: Scalar::ZST.into(),\n-                    layout: mplace.layout,\n-                }));\n-            }\n+        let Some(alloc) = self.get_alloc(mplace)? else {\n+            return Ok(Some(ImmTy {\n+                // zero-sized type\n+                imm: Scalar::ZST.into(),\n+                layout: mplace.layout,\n+            }));\n         };\n \n         match mplace.layout.abi {"}, {"sha": "e9b2df53a331370f1a42ccc1f24b3766eda0b044", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -420,9 +420,8 @@ where\n     ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n-        let stride = match base.layout.fields {\n-            FieldsShape::Array { stride, .. } => stride,\n-            _ => span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\"),\n+        let FieldsShape::Array { stride, .. } = base.layout.fields else {\n+            span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\");\n         };\n         let layout = base.layout.field(self, 0);\n         let dl = &self.tcx.data_layout;\n@@ -747,9 +746,9 @@ where\n \n         // Invalid places are a thing: the return place of a diverging function\n         let tcx = *self.tcx;\n-        let mut alloc = match self.get_alloc_mut(dest)? {\n-            Some(a) => a,\n-            None => return Ok(()), // zero-sized access\n+        let Some(mut alloc) = self.get_alloc_mut(dest)? else {\n+            // zero-sized access\n+            return Ok(());\n         };\n \n         // FIXME: We should check that there are dest.layout.size many bytes available in"}, {"sha": "0701e0ded9703f89a2af1cb0fd746fe192168f77", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -46,15 +46,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n \n-        let loc = match self.frame().loc {\n-            Ok(loc) => loc,\n-            Err(_) => {\n-                // We are unwinding and this fn has no cleanup code.\n-                // Just go on unwinding.\n-                trace!(\"unwinding: skipping frame\");\n-                self.pop_stack_frame(/* unwinding */ true)?;\n-                return Ok(true);\n-            }\n+        let Ok(loc) = self.frame().loc else {\n+            // We are unwinding and this fn has no cleanup code.\n+            // Just go on unwinding.\n+            trace!(\"unwinding: skipping frame\");\n+            self.pop_stack_frame(/* unwinding */ true)?;\n+            return Ok(true);\n         };\n         let basic_block = &self.body().basic_blocks()[loc.block];\n "}, {"sha": "8094bf0cf2e2f7361ec1819a40ce85e74dc09641", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -321,10 +321,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::CloneShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let (body, instance) =\n-                    match M::find_mir_or_eval_fn(self, instance, caller_abi, args, ret, unwind)? {\n-                        Some(body) => body,\n-                        None => return Ok(()),\n+                let Some((body, instance)) =\n+                    M::find_mir_or_eval_fn(self, instance, caller_abi, args, ret, unwind)? else {\n+                        return Ok(());\n                     };\n \n                 // Compute callee information using the `instance` returned by"}, {"sha": "5fec8963a2c45e43406d8813baf8aa6505cae3ab", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -851,12 +851,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept uninit, for consistency with the slow path.\n-                let alloc = match self.ecx.memory.get(mplace.ptr, size, mplace.align)? {\n-                    Some(a) => a,\n-                    None => {\n-                        // Size 0, nothing more to check.\n-                        return Ok(());\n-                    }\n+                let Some(alloc) = self.ecx.memory.get(mplace.ptr, size, mplace.align)? else {\n+                    // Size 0, nothing more to check.\n+                    return Ok(());\n                 };\n \n                 let allow_uninit_and_ptr = !M::enforce_number_validity(self.ecx);"}, {"sha": "652f1c94a6149f06d406a512c1cab6b9c9834e49", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -134,11 +134,8 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n             .find(|(_, block)| matches!(block.terminator().kind, TerminatorKind::Return))\n             .map(|(bb, _)| bb);\n \n-        let return_block = match return_block {\n-            None => {\n-                return qualifs::in_any_value_of_ty(ccx, ccx.body.return_ty(), tainted_by_errors);\n-            }\n-            Some(bb) => bb,\n+        let Some(return_block) = return_block else {\n+            return qualifs::in_any_value_of_ty(ccx, ccx.body.return_ty(), tainted_by_errors);\n         };\n \n         let return_loc = ccx.body.terminator_loc(return_block);"}, {"sha": "30764f689c95c379df9a00ac94c4027044c56c1a", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -747,15 +747,12 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n-                let rhs = match statement.kind {\n-                    StatementKind::Assign(box (_, ref mut rhs)) => rhs,\n-                    _ => {\n-                        span_bug!(\n-                            statement.source_info.span,\n-                            \"{:?} is not an assignment\",\n-                            statement\n-                        );\n-                    }\n+                let StatementKind::Assign(box (_, ref mut rhs)) = statement.kind else {\n+                    span_bug!(\n+                        statement.source_info.span,\n+                        \"{:?} is not an assignment\",\n+                        statement\n+                    );\n                 };\n \n                 ("}, {"sha": "e4528b68907838120b98a9909ce029bb42cda750", "filename": "compiler/rustc_const_eval/src/util/alignment.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7f7f7c4c5cbb036444f18e97a44e51120ee609/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Falignment.rs?ref=ea7f7f7c4c5cbb036444f18e97a44e51120ee609", "patch": "@@ -15,12 +15,9 @@ where\n     L: HasLocalDecls<'tcx>,\n {\n     debug!(\"is_disaligned({:?})\", place);\n-    let pack = match is_within_packed(tcx, local_decls, place) {\n-        None => {\n-            debug!(\"is_disaligned({:?}) - not within packed\", place);\n-            return false;\n-        }\n-        Some(pack) => pack,\n+    let Some(pack) = is_within_packed(tcx, local_decls, place) else {\n+        debug!(\"is_disaligned({:?}) - not within packed\", place);\n+        return false;\n     };\n \n     let ty = place.ty(local_decls, tcx).ty;"}]}