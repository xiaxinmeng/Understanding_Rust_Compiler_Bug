{"sha": "e26f992d5e199a1ff8c26733650d254d63be066a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNmY5OTJkNWUxOTlhMWZmOGMyNjczMzY1MGQyNTRkNjNiZTA2NmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-24T13:48:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-24T13:48:50Z"}, "message": "auto merge of #6036 : huonw/rust/core-less-at, r=nikomatsakis\n\nFrom a cursory `git grep` this removes the last part of `core` that requires on `@` (other than `io` and the task local data section).\r\n\r\nIt renames `RandRes` to ~~StdRng~~ `IsaacRng` and `XorShiftState` to `XorShiftRng` as well as moving their constructors to static methods. To go with this, it adds `rng()` which is designed to be used when the programmer just wants a random number generator, without caring about which exact algorithm is being used.\r\n\r\nIt also removes all the `gen_int`, `gen_uint`, `gen_char` (etc) methods on `RngUtil` (by moving the defintions to the actual `Rand` instances). The replacement is using `RngUtil::gen`, either type-inferred or with an annotation (`rng.gen::<uint>()`).\r\n\r\nI tried to have the `Rng` and `RngUtil` traits exported by `core::prelude` (since `core::rand` (except for `random()`) is useless without them), but this caused [an explosion of (seemingly unrelated) `error: unresolved import`'s](https://gist.github.com/5451839).", "tree": {"sha": "c1aa3ef0f5e49f777912683ae95144541dd07cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1aa3ef0f5e49f777912683ae95144541dd07cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e26f992d5e199a1ff8c26733650d254d63be066a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e26f992d5e199a1ff8c26733650d254d63be066a", "html_url": "https://github.com/rust-lang/rust/commit/e26f992d5e199a1ff8c26733650d254d63be066a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e26f992d5e199a1ff8c26733650d254d63be066a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8ac057545f7b2edf1e488aa4562138a6ed7a096", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ac057545f7b2edf1e488aa4562138a6ed7a096", "html_url": "https://github.com/rust-lang/rust/commit/c8ac057545f7b2edf1e488aa4562138a6ed7a096"}, {"sha": "9860fe10a19cc4997e58861df905f8dbe4de3c5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9860fe10a19cc4997e58861df905f8dbe4de3c5b", "html_url": "https://github.com/rust-lang/rust/commit/9860fe10a19cc4997e58861df905f8dbe4de3c5b"}], "stats": {"total": 935, "additions": 397, "deletions": 538}, "files": [{"sha": "5c4181c10cf3b42f40af7725627ae8b9645e2249", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -85,7 +85,7 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n #[test]\n #[allow(non_implicitly_copyable_typarams)]\n fn test_flate_round_trip() {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n     let mut words = ~[];\n     for 20.times {\n         words.push(r.gen_bytes(r.gen_uint_range(1, 10)));"}, {"sha": "d2be0416371befb23665478bc867dfee58dab2f3", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -56,7 +56,7 @@ fn resize_at(capacity: uint) -> uint {\n pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n     initial_capacity: uint) -> HashMap<K, V> {\n     let r = rand::task_rng();\n-    linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n+    linear_map_with_capacity_and_keys(r.gen(), r.gen(),\n                                       initial_capacity)\n }\n "}, {"sha": "1000fd88b524639c9828a125d1d7a5d71f7ee010", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -1259,7 +1259,7 @@ mod tests {\n     }\n \n     fn make_rand_name() -> ~str {\n-        let rng: @rand::Rng = rand::Rng();\n+        let rng = rand::rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert!(getenv(n).is_none());\n         n"}, {"sha": "cdf6a5bb63ded98573bc3601151b69bbaaa82b0e", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 228, "deletions": 323, "changes": 551, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -8,7 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Random number generation\n+/*!\n+Random number generation.\n+\n+The key functions are `random()` and `RngUtil::gen()`. These are polymorphic\n+and so can be used to generate any type that implements `Rand`. Type inference\n+means that often a simple call to `rand::random()` or `rng.gen()` will\n+suffice, but sometimes an annotation is required, e.g. `rand::random::<float>()`.\n+\n+# Examples\n+~~~\n+use core::rand::RngUtil;\n+\n+fn main() {\n+    let rng = rand::rng();\n+    if rng.gen() { // bool\n+        println(fmt!(\"int: %d, uint: %u\", rng.gen(), rng.gen()))\n+    }\n+}\n+~~~\n+\n+~~~\n+fn main () {\n+    let tuple_ptr = rand::random::<~(f64, char)>();\n+    println(fmt!(\"%?\", tuple_ptr))\n+}\n+~~~\n+*/\n+\n \n use int;\n use prelude::*;\n@@ -20,98 +47,111 @@ use util;\n use vec;\n use libc::size_t;\n \n-/// A type that can be randomly generated using an RNG\n+/// A type that can be randomly generated using an Rng\n pub trait Rand {\n-    fn rand(rng: @rand::Rng) -> Self;\n+    fn rand<R: Rng>(rng: &R) -> Self;\n }\n \n impl Rand for int {\n-    fn rand(rng: @rand::Rng) -> int {\n-        rng.gen_int()\n+    fn rand<R: Rng>(rng: &R) -> int {\n+        if int::bits == 32 {\n+            rng.next() as int\n+        } else {\n+            rng.gen::<i64>() as int\n+        }\n     }\n }\n \n impl Rand for i8 {\n-    fn rand(rng: @rand::Rng) -> i8 {\n-        rng.gen_i8()\n+    fn rand<R: Rng>(rng: &R) -> i8 {\n+        rng.next() as i8\n     }\n }\n \n impl Rand for i16 {\n-    fn rand(rng: @rand::Rng) -> i16 {\n-        rng.gen_i16()\n+    fn rand<R: Rng>(rng: &R) -> i16 {\n+        rng.next() as i16\n     }\n }\n \n impl Rand for i32 {\n-    fn rand(rng: @rand::Rng) -> i32 {\n-        rng.gen_i32()\n+    fn rand<R: Rng>(rng: &R) -> i32 {\n+        rng.next() as i32\n     }\n }\n \n impl Rand for i64 {\n-    fn rand(rng: @rand::Rng) -> i64 {\n-        rng.gen_i64()\n+    fn rand<R: Rng>(rng: &R) -> i64 {\n+        (rng.next() as i64 << 32) | rng.next() as i64\n     }\n }\n \n impl Rand for uint {\n-    fn rand(rng: @rand::Rng) -> uint {\n-        rng.gen_uint()\n+    fn rand<R: Rng>(rng: &R) -> uint {\n+        if uint::bits == 32 {\n+            rng.next() as uint\n+        } else {\n+            rng.gen::<u64>() as uint\n+        }\n     }\n }\n \n impl Rand for u8 {\n-    fn rand(rng: @rand::Rng) -> u8 {\n-        rng.gen_u8()\n+    fn rand<R: Rng>(rng: &R) -> u8 {\n+        rng.next() as u8\n     }\n }\n \n impl Rand for u16 {\n-    fn rand(rng: @rand::Rng) -> u16 {\n-        rng.gen_u16()\n+    fn rand<R: Rng>(rng: &R) -> u16 {\n+        rng.next() as u16\n     }\n }\n \n impl Rand for u32 {\n-    fn rand(rng: @rand::Rng) -> u32 {\n-        rng.gen_u32()\n+    fn rand<R: Rng>(rng: &R) -> u32 {\n+        rng.next()\n     }\n }\n \n impl Rand for u64 {\n-    fn rand(rng: @rand::Rng) -> u64 {\n-        rng.gen_u64()\n+    fn rand<R: Rng>(rng: &R) -> u64 {\n+        (rng.next() as u64 << 32) | rng.next() as u64\n     }\n }\n \n impl Rand for float {\n-    fn rand(rng: @rand::Rng) -> float {\n-        rng.gen_float()\n+    fn rand<R: Rng>(rng: &R) -> float {\n+        rng.gen::<f64>() as float\n     }\n }\n \n impl Rand for f32 {\n-    fn rand(rng: @rand::Rng) -> f32 {\n-        rng.gen_f32()\n+    fn rand<R: Rng>(rng: &R) -> f32 {\n+        rng.gen::<f64>() as f32\n     }\n }\n \n+static scale : f64 = (u32::max_value as f64) + 1.0f64;\n impl Rand for f64 {\n-    fn rand(rng: @rand::Rng) -> f64 {\n-        rng.gen_f64()\n+    fn rand<R: Rng>(rng: &R) -> f64 {\n+        let u1 = rng.next() as f64;\n+        let u2 = rng.next() as f64;\n+        let u3 = rng.next() as f64;\n+\n+        ((u1 / scale + u2) / scale + u3) / scale\n     }\n }\n \n impl Rand for char {\n-    fn rand(rng: @rand::Rng) -> char {\n-        rng.gen_char()\n+    fn rand<R: Rng>(rng: &R) -> char {\n+        rng.next() as char\n     }\n }\n \n impl Rand for bool {\n-    fn rand(rng: @rand::Rng) -> bool {\n-        rng.gen_bool()\n+    fn rand<R: Rng>(rng: &R) -> bool {\n+        rng.next() & 1u32 == 1u32\n     }\n }\n \n@@ -123,10 +163,10 @@ macro_rules! tuple_impl {\n             $( $tyvar : Rand ),*\n             > Rand for ( $( $tyvar ),* , ) {\n \n-            fn rand (_rng: @Rng) -> ( $( $tyvar ),* , ) {\n+            fn rand<R: Rng>(_rng: &R) -> ( $( $tyvar ),* , ) {\n                 (\n-                    // use the $var's to get the appropriate number of repeats\n-                    // (they're not actually needed)\n+                    // use the $tyvar's to get the appropriate number of\n+                    // repeats (they're not actually needed)\n                     $(\n                         _rng.gen::<$tyvar>()\n                     ),*\n@@ -137,7 +177,7 @@ macro_rules! tuple_impl {\n     }\n }\n \n-impl Rand for () { fn rand(_: @Rng) -> () { () } }\n+impl Rand for () { fn rand<R: Rng>(_: &R) -> () { () } }\n tuple_impl!{A}\n tuple_impl!{A, B}\n tuple_impl!{A, B, C}\n@@ -150,21 +190,21 @@ tuple_impl!{A, B, C, D, E, F, G, H, I}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n \n impl<T:Rand> Rand for Option<T> {\n-    fn rand(rng: @rand::Rng) -> Option<T> {\n-        if rng.gen_bool() {\n-            Some(Rand::rand(rng))\n+    fn rand<R: Rng>(rng: &R) -> Option<T> {\n+        if rng.gen() {\n+            Some(rng.gen())\n         } else {\n             None\n         }\n     }\n }\n \n impl<T: Rand> Rand for ~T {\n-    fn rand(rng: @Rng) -> ~T { ~rng.gen() }\n+    fn rand<R: Rng>(rng: &R) -> ~T { ~rng.gen() }\n }\n \n impl<T: Rand> Rand for @T {\n-    fn rand(rng: @Rng) -> @T { @rng.gen() }\n+    fn rand<R: Rng>(rng: &R) -> @T { @rng.gen() }\n }\n \n #[allow(non_camel_case_types)] // runtime type\n@@ -173,7 +213,7 @@ pub enum rust_rng {}\n #[abi = \"cdecl\"]\n pub mod rustrt {\n     use libc::size_t;\n-    use rand::rust_rng;\n+    use super::rust_rng;\n \n     pub extern {\n         unsafe fn rand_seed_size() -> size_t;\n@@ -187,7 +227,7 @@ pub mod rustrt {\n /// A random number generator\n pub trait Rng {\n     /// Return the next random integer\n-    fn next(&self) -> u32;\n+    pub fn next(&self) -> u32;\n }\n \n /// A value with a particular weight compared to other values\n@@ -197,90 +237,22 @@ pub struct Weighted<T> {\n }\n \n pub trait RngUtil {\n-    /// Return a random value for a Rand type\n+    /// Return a random value of a Rand type\n     fn gen<T:Rand>(&self) -> T;\n     /**\n-     * Return a random int\n-     *\n-     * *Example*\n-     *\n-     * ~~~\n-     *\n-     * use core::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     rng = rand::Rng();\n-     *     println(fmt!(\"%d\",rng.gen_int()));\n-     * }\n-     * ~~~\n+     * Return a int randomly chosen from the range [start, end),\n+     * failing if start >= end\n      */\n-    fn gen_int(&self) -> int;\n     fn gen_int_range(&self, start: int, end: int) -> int;\n-    /// Return a random i8\n-    fn gen_i8(&self) -> i8;\n-    /// Return a random i16\n-    fn gen_i16(&self) -> i16;\n-    /// Return a random i32\n-    fn gen_i32(&self) -> i32;\n-    /// Return a random i64\n-    fn gen_i64(&self) -> i64;\n-    /// Return a random uint\n-    fn gen_uint(&self) -> uint;\n     /**\n      * Return a uint randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n     fn gen_uint_range(&self, start: uint, end: uint) -> uint;\n-    /// Return a random u8\n-    fn gen_u8(&self) -> u8;\n-    /// Return a random u16\n-    fn gen_u16(&self) -> u16;\n-    /// Return a random u32\n-    fn gen_u32(&self) -> u32;\n-    /// Return a random u64\n-    fn gen_u64(&self) -> u64;\n-    /**\n-     * Return random float in the interval [0,1]\n-     *\n-     * *Example*\n-     *\n-     * ~~~\n-     *\n-     * use core::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     rng = rand::Rng();\n-     *     println(fmt!(\"%f\",rng.gen_float()));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_float(&self) -> float;\n-    /// Return a random f32 in the interval [0,1]\n-    fn gen_f32(&self) -> f32;\n-    /// Return a random f64 in the interval [0,1]\n-    fn gen_f64(&self) -> f64;\n-    /// Return a random char\n-    fn gen_char(&self) -> char;\n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n     fn gen_char_from(&self, chars: &str) -> char;\n-    /**\n-     * Return a random bool\n-     *\n-     * *Example*\n-     *\n-     * ~~~\n-     *\n-     * use core::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     rng = rand::Rng();\n-     *     println(fmt!(\"%b\",rng.gen_bool()));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_bool(&self) -> bool;\n     /**\n      * Return a bool with a 1 in n chance of true\n      *\n@@ -291,7 +263,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%b\",rng.gen_weighted_bool(3)));\n      * }\n      * ~~~\n@@ -307,7 +279,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(rng.gen_str(8));\n      * }\n      * ~~~\n@@ -323,13 +295,12 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%?\",rng.gen_bytes(8)));\n      * }\n      * ~~~\n      */\n     fn gen_bytes(&self, len: uint) -> ~[u8];\n-    ///\n     /**\n      * Choose an item randomly, failing if values is empty\n      *\n@@ -340,7 +311,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%d\",rng.choose([1,2,4,8,16,32])));\n      * }\n      * ~~~\n@@ -359,7 +330,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     let x = [rand::Weighted {weight: 4, item: 'a'},\n      *              rand::Weighted {weight: 2, item: 'b'},\n      *              rand::Weighted {weight: 2, item: 'c'}];\n@@ -379,7 +350,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     let x = [rand::Weighted {weight: 4, item: 'a'},\n      *              rand::Weighted {weight: 2, item: 'b'},\n      *              rand::Weighted {weight: 2, item: 'c'}];\n@@ -399,7 +370,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     let x = [rand::Weighted {weight: 4, item: 'a'},\n      *              rand::Weighted {weight: 2, item: 'b'},\n      *              rand::Weighted {weight: 2, item: 'c'}];\n@@ -418,7 +389,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     println(fmt!(\"%?\",rng.shuffle([1,2,3])));\n      * }\n      * ~~~\n@@ -434,7 +405,7 @@ pub trait RngUtil {\n      * use core::rand::RngUtil;\n      *\n      * fn main() {\n-     *     rng = rand::Rng();\n+     *     rng = rand::rng();\n      *     let mut y = [1,2,3];\n      *     rng.shuffle_mut(y);\n      *     println(fmt!(\"%?\",y));\n@@ -447,15 +418,10 @@ pub trait RngUtil {\n }\n \n /// Extension methods for random number generators\n-impl RngUtil for @Rng {\n+impl<R: Rng> RngUtil for R {\n     /// Return a random value for a Rand type\n-    fn gen<T:Rand>(&self) -> T {\n-        Rand::rand(*self)\n-    }\n-\n-    /// Return a random int\n-    fn gen_int(&self) -> int {\n-        self.gen_i64() as int\n+    fn gen<T: Rand>(&self) -> T {\n+        Rand::rand(self)\n     }\n \n     /**\n@@ -464,32 +430,7 @@ impl RngUtil for @Rng {\n      */\n     fn gen_int_range(&self, start: int, end: int) -> int {\n         assert!(start < end);\n-        start + int::abs(self.gen_int() % (end - start))\n-    }\n-\n-    /// Return a random i8\n-    fn gen_i8(&self) -> i8 {\n-        self.next() as i8\n-    }\n-\n-    /// Return a random i16\n-    fn gen_i16(&self) -> i16 {\n-        self.next() as i16\n-    }\n-\n-    /// Return a random i32\n-    fn gen_i32(&self) -> i32 {\n-        self.next() as i32\n-    }\n-\n-    /// Return a random i64\n-    fn gen_i64(&self) -> i64 {\n-        (self.next() as i64 << 32) | self.next() as i64\n-    }\n-\n-    /// Return a random uint\n-    fn gen_uint(&self) -> uint {\n-        self.gen_u64() as uint\n+        start + int::abs(self.gen::<int>() % (end - start))\n     }\n \n     /**\n@@ -498,51 +439,7 @@ impl RngUtil for @Rng {\n      */\n     fn gen_uint_range(&self, start: uint, end: uint) -> uint {\n         assert!(start < end);\n-        start + (self.gen_uint() % (end - start))\n-    }\n-\n-    /// Return a random u8\n-    fn gen_u8(&self) -> u8 {\n-        self.next() as u8\n-    }\n-\n-    /// Return a random u16\n-    fn gen_u16(&self) -> u16 {\n-        self.next() as u16\n-    }\n-\n-    /// Return a random u32\n-    fn gen_u32(&self) -> u32 {\n-        self.next()\n-    }\n-\n-    /// Return a random u64\n-    fn gen_u64(&self) -> u64 {\n-        (self.next() as u64 << 32) | self.next() as u64\n-    }\n-\n-    /// Return a random float in the interval [0,1]\n-    fn gen_float(&self) -> float {\n-        self.gen_f64() as float\n-    }\n-\n-    /// Return a random f32 in the interval [0,1]\n-    fn gen_f32(&self) -> f32 {\n-        self.gen_f64() as f32\n-    }\n-\n-    /// Return a random f64 in the interval [0,1]\n-    fn gen_f64(&self) -> f64 {\n-        let u1 = self.next() as f64;\n-        let u2 = self.next() as f64;\n-        let u3 = self.next() as f64;\n-        static scale : f64 = (u32::max_value as f64) + 1.0f64;\n-        return ((u1 / scale + u2) / scale + u3) / scale;\n-    }\n-\n-    /// Return a random char\n-    fn gen_char(&self) -> char {\n-        self.next() as char\n+        start + (self.gen::<uint>() % (end - start))\n     }\n \n     /**\n@@ -555,11 +452,6 @@ impl RngUtil for @Rng {\n         self.choose(cs)\n     }\n \n-    /// Return a random bool\n-    fn gen_bool(&self) -> bool {\n-        self.next() & 1u32 == 1u32\n-    }\n-\n     /// Return a bool with a 1-in-n chance of true\n     fn gen_weighted_bool(&self, n: uint) -> bool {\n         if n == 0u {\n@@ -588,7 +480,7 @@ impl RngUtil for @Rng {\n     /// Return a random byte string of the specified length\n     fn gen_bytes(&self, len: uint) -> ~[u8] {\n         do vec::from_fn(len) |_i| {\n-            self.gen_u8()\n+            self.gen()\n         }\n     }\n \n@@ -605,7 +497,6 @@ impl RngUtil for @Rng {\n             Some(values[self.gen_uint_range(0u, values.len())])\n         }\n     }\n-\n     /**\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n@@ -668,36 +559,61 @@ impl RngUtil for @Rng {\n             vec::swap(values, i, self.gen_uint_range(0u, i + 1u));\n         }\n     }\n+}\n \n+/// Create a random number generator with a default algorithm and seed.\n+pub fn rng() -> IsaacRng {\n+    IsaacRng::new()\n }\n \n-struct RandRes {\n-    rng: *rust_rng,\n+pub struct IsaacRng {\n+    priv rng: *rust_rng,\n }\n \n-impl Drop for RandRes {\n+impl Drop for IsaacRng {\n     fn finalize(&self) {\n         unsafe {\n             rustrt::rand_free(self.rng);\n         }\n     }\n }\n \n-fn RandRes(rng: *rust_rng) -> RandRes {\n-    RandRes {\n-        rng: rng\n+pub impl IsaacRng {\n+    priv fn from_rust_rng(rng: *rust_rng) -> IsaacRng {\n+        IsaacRng {\n+            rng: rng\n+        }\n+    }\n+\n+    /// Create an ISAAC random number generator with a system specified seed\n+    fn new() -> IsaacRng {\n+        IsaacRng::new_seeded(seed())\n+    }\n+\n+    /**\n+     * Create a random number generator using the specified seed. A generator\n+     * constructed with a given seed will generate the same sequence of values as\n+     * all other generators constructed with the same seed. The seed may be any\n+     * length.\n+     */\n+    fn new_seeded(seed: &[u8]) -> IsaacRng {\n+        unsafe {\n+            do vec::as_imm_buf(seed) |p, sz| {\n+                IsaacRng::from_rust_rng(rustrt::rand_new_seeded(p, sz as size_t))\n+            }\n+        }\n     }\n }\n \n-impl Rng for @RandRes {\n-    fn next(&self) -> u32 {\n+impl Rng for IsaacRng {\n+    pub fn next(&self) -> u32 {\n         unsafe {\n-            return rustrt::rand_next((*self).rng);\n+            return rustrt::rand_next(self.rng);\n         }\n     }\n }\n \n-/// Create a new random seed for seeded_rng\n+/// Create a new random seed for IsaacRng::new_seeded\n pub fn seed() -> ~[u8] {\n     unsafe {\n         let n = rustrt::rand_seed_size() as uint;\n@@ -709,38 +625,15 @@ pub fn seed() -> ~[u8] {\n     }\n }\n \n-/// Create a random number generator with a system specified seed\n-pub fn Rng() -> @Rng {\n-    seeded_rng(seed())\n-}\n-\n-/**\n- * Create a random number generator using the specified seed. A generator\n- * constructed with a given seed will generate the same sequence of values as\n- * all other generators constructed with the same seed. The seed may be any\n- * length.\n- */\n-pub fn seeded_rng(seed: &[u8]) -> @Rng {\n-    @seeded_randres(seed) as @Rng\n-}\n-\n-fn seeded_randres(seed: &[u8]) -> @RandRes {\n-    unsafe {\n-        do vec::as_imm_buf(seed) |p, sz| {\n-            @RandRes(rustrt::rand_new_seeded(p, sz as size_t))\n-        }\n-    }\n-}\n-\n-struct XorShiftState {\n-    mut x: u32,\n-    mut y: u32,\n-    mut z: u32,\n-    mut w: u32,\n+struct XorShiftRng {\n+    priv mut x: u32,\n+    priv mut y: u32,\n+    priv mut z: u32,\n+    priv mut w: u32,\n }\n \n-impl Rng for XorShiftState {\n-    fn next(&self) -> u32 {\n+impl Rng for XorShiftRng {\n+    pub fn next(&self) -> u32 {\n         let x = self.x;\n         let t = x ^ (x << 11);\n         self.x = self.y;\n@@ -752,41 +645,54 @@ impl Rng for XorShiftState {\n     }\n }\n \n-pub fn xorshift() -> @Rng {\n-    // constants taken from http://en.wikipedia.org/wiki/Xorshift\n-    seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n-}\n+pub impl XorShiftRng {\n+    /// Create an xor shift random number generator with a default seed.\n+    fn new() -> XorShiftRng {\n+        // constants taken from http://en.wikipedia.org/wiki/Xorshift\n+        XorShiftRng::new_seeded(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n+    }\n \n-pub fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> @Rng {\n-    @XorShiftState { x: x, y: y, z: z, w: w } as @Rng\n-}\n+    /**\n+     * Create a random number generator using the specified seed. A generator\n+     * constructed with a given seed will generate the same sequence of values as\n+     * all other generators constructed with the same seed.\n+     */\n+    fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n+        XorShiftRng { x: x, y: y, z: z, w: w }\n+    }\n \n+}\n \n // used to make space in TLS for a random number generator\n-fn tls_rng_state(_v: @RandRes) {}\n+fn tls_rng_state(_v: @IsaacRng) {}\n \n /**\n  * Gives back a lazily initialized task-local random number generator,\n  * seeded by the system. Intended to be used in method chaining style, ie\n- * task_rng().gen_int().\n+ * `task_rng().gen::<int>()`.\n  */\n-pub fn task_rng() -> @Rng {\n-    let r : Option<@RandRes>;\n+pub fn task_rng() -> @IsaacRng {\n+    let r : Option<@IsaacRng>;\n     unsafe {\n         r = task::local_data::local_data_get(tls_rng_state);\n     }\n     match r {\n         None => {\n             unsafe {\n-                let rng = seeded_randres(seed());\n+                let rng = @IsaacRng::new_seeded(seed());\n                 task::local_data::local_data_set(tls_rng_state, rng);\n-                @rng as @Rng\n+                rng\n             }\n         }\n-        Some(rng) => @rng as @Rng\n+        Some(rng) => rng\n     }\n }\n \n+// Allow direct chaining with `task_rng`\n+impl<R: Rng> Rng for @R {\n+    fn next(&self) -> u32 { (*self).next() }\n+}\n+\n /**\n  * Returns a random value of a Rand type, using the task's random number\n  * generator.\n@@ -795,33 +701,32 @@ pub fn random<T: Rand>() -> T {\n     task_rng().gen()\n }\n \n-\n #[cfg(test)]\n mod tests {\n     use option::{Option, Some};\n-    use rand;\n+    use super::*;\n \n     #[test]\n-    fn rng_seeded() {\n-        let seed = rand::seed();\n-        let ra = rand::seeded_rng(seed);\n-        let rb = rand::seeded_rng(seed);\n+    fn test_rng_seeded() {\n+        let seed = seed();\n+        let ra = IsaacRng::new_seeded(seed);\n+        let rb = IsaacRng::new_seeded(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n-    fn rng_seeded_custom_seed() {\n+    fn test_rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = rand::seeded_rng(seed);\n-        let rb = rand::seeded_rng(seed);\n+        let ra = IsaacRng::new_seeded(seed);\n+        let rb = IsaacRng::new_seeded(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n-    fn rng_seeded_custom_seed2() {\n+    fn test_rng_seeded_custom_seed2() {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = rand::seeded_rng(seed);\n+        let ra = IsaacRng::new_seeded(seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n         error!(\"%?\", r);\n@@ -830,8 +735,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn gen_int_range() {\n-        let r = rand::Rng();\n+    fn test_gen_int_range() {\n+        let r = rng();\n         let a = r.gen_int_range(-3, 42);\n         assert!(a >= -3 && a < 42);\n         assert!(r.gen_int_range(0, 1) == 0);\n@@ -841,13 +746,13 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn gen_int_from_fail() {\n-        rand::Rng().gen_int_range(5, -2);\n+    fn test_gen_int_from_fail() {\n+        rng().gen_int_range(5, -2);\n     }\n \n     #[test]\n-    fn gen_uint_range() {\n-        let r = rand::Rng();\n+    fn test_gen_uint_range() {\n+        let r = rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert!(a >= 3u && a < 42u);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n@@ -857,28 +762,28 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn gen_uint_range_fail() {\n-        rand::Rng().gen_uint_range(5u, 2u);\n+    fn test_gen_uint_range_fail() {\n+        rng().gen_uint_range(5u, 2u);\n     }\n \n     #[test]\n-    fn gen_float() {\n-        let r = rand::Rng();\n-        let a = r.gen_float();\n-        let b = r.gen_float();\n+    fn test_gen_float() {\n+        let r = rng();\n+        let a = r.gen::<float>();\n+        let b = r.gen::<float>();\n         debug!((a, b));\n     }\n \n     #[test]\n-    fn gen_weighted_bool() {\n-        let r = rand::Rng();\n+    fn test_gen_weighted_bool() {\n+        let r = rng();\n         assert!(r.gen_weighted_bool(0u) == true);\n         assert!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n-    fn gen_str() {\n-        let r = rand::Rng();\n+    fn test_gen_str() {\n+        let r = rng();\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n@@ -888,91 +793,91 @@ mod tests {\n     }\n \n     #[test]\n-    fn gen_bytes() {\n-        let r = rand::Rng();\n+    fn test_gen_bytes() {\n+        let r = rng();\n         assert!(r.gen_bytes(0u).len() == 0u);\n         assert!(r.gen_bytes(10u).len() == 10u);\n         assert!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n-    fn choose() {\n-        let r = rand::Rng();\n+    fn test_choose() {\n+        let r = rng();\n         assert!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n-    fn choose_option() {\n-        let r = rand::Rng();\n+    fn test_choose_option() {\n+        let r = rng();\n         let x: Option<int> = r.choose_option([]);\n         assert!(x.is_none());\n         assert!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n-    fn choose_weighted() {\n-        let r = rand::Rng();\n+    fn test_choose_weighted() {\n+        let r = rng();\n         assert!(r.choose_weighted(~[\n-            rand::Weighted { weight: 1u, item: 42 },\n+            Weighted { weight: 1u, item: 42 },\n         ]) == 42);\n         assert!(r.choose_weighted(~[\n-            rand::Weighted { weight: 0u, item: 42 },\n-            rand::Weighted { weight: 1u, item: 43 },\n+            Weighted { weight: 0u, item: 42 },\n+            Weighted { weight: 1u, item: 43 },\n         ]) == 43);\n     }\n \n     #[test]\n-    fn choose_weighted_option() {\n-        let r = rand::Rng();\n+    fn test_choose_weighted_option() {\n+        let r = rng();\n         assert!(r.choose_weighted_option(~[\n-            rand::Weighted { weight: 1u, item: 42 },\n+            Weighted { weight: 1u, item: 42 },\n         ]) == Some(42));\n         assert!(r.choose_weighted_option(~[\n-            rand::Weighted { weight: 0u, item: 42 },\n-            rand::Weighted { weight: 1u, item: 43 },\n+            Weighted { weight: 0u, item: 42 },\n+            Weighted { weight: 1u, item: 43 },\n         ]) == Some(43));\n         let v: Option<int> = r.choose_weighted_option([]);\n         assert!(v.is_none());\n     }\n \n     #[test]\n-    fn weighted_vec() {\n-        let r = rand::Rng();\n+    fn test_weighted_vec() {\n+        let r = rng();\n         let empty: ~[int] = ~[];\n         assert!(r.weighted_vec(~[]) == empty);\n         assert!(r.weighted_vec(~[\n-            rand::Weighted { weight: 0u, item: 3u },\n-            rand::Weighted { weight: 1u, item: 2u },\n-            rand::Weighted { weight: 2u, item: 1u },\n+            Weighted { weight: 0u, item: 3u },\n+            Weighted { weight: 1u, item: 2u },\n+            Weighted { weight: 2u, item: 1u },\n         ]) == ~[2u, 1u, 1u]);\n     }\n \n     #[test]\n-    fn shuffle() {\n-        let r = rand::Rng();\n+    fn test_shuffle() {\n+        let r = rng();\n         let empty: ~[int] = ~[];\n         assert!(r.shuffle(~[]) == empty);\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n-    fn task_rng() {\n-        let r = rand::task_rng();\n-        r.gen_int();\n+    fn test_task_rng() {\n+        let r = task_rng();\n+        r.gen::<int>();\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n     }\n \n     #[test]\n-    fn random() {\n+    fn test_random() {\n         // not sure how to test this aside from just getting some values\n-        let _n : uint = rand::random();\n-        let _f : f32 = rand::random();\n-        let _o : Option<Option<i8>> = rand::random();\n+        let _n : uint = random();\n+        let _f : f32 = random();\n+        let _o : Option<Option<i8>> = random();\n         let _many : ((),\n                      (~uint, @int, ~Option<~(@char, ~(@bool,))>),\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n-                     (f32, (f64, (float,)))) = rand::random();\n+                     (f32, (f64, (float,)))) = random();\n     }\n }\n "}, {"sha": "e7df95e20c80b205b773470bafd309d7c0568bc2", "filename": "src/libcore/run.rs", "status": "modified", "additions": 104, "deletions": 114, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -47,28 +47,117 @@ pub struct RunProgramResult {\n     handle: *(),\n }\n \n+struct ProgRepr {\n+    pid: pid_t,\n+    handle: *(),\n+    in_fd: c_int,\n+    out_file: *libc::FILE,\n+    err_file: *libc::FILE,\n+    finished: bool,\n+}\n+\n+impl ProgRepr {\n+    fn close_input(&mut self) {\n+        let invalid_fd = -1i32;\n+        if self.in_fd != invalid_fd {\n+            unsafe {\n+                libc::close(self.in_fd);\n+            }\n+            self.in_fd = invalid_fd;\n+        }\n+    }\n+\n+    fn close_outputs(&mut self) {\n+        unsafe {\n+            fclose_and_null(&mut self.out_file);\n+            fclose_and_null(&mut self.err_file);\n+        }\n+    }\n+\n+    fn finish(&mut self) -> int {\n+        if self.finished { return 0; }\n+        self.finished = true;\n+        self.close_input();\n+        return waitpid(self.pid);\n+    }\n+\n+    fn destroy(&mut self, force: bool) {\n+        killpid(self.pid, force);\n+        self.finish();\n+        self.close_outputs();\n+\n+        #[cfg(windows)]\n+        fn killpid(pid: pid_t, _force: bool) {\n+            unsafe {\n+                libc::funcs::extra::kernel32::TerminateProcess(\n+                    cast::transmute(pid), 1);\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn killpid(pid: pid_t, force: bool) {\n+            let signal = if force {\n+                libc::consts::os::posix88::SIGKILL\n+            } else {\n+                libc::consts::os::posix88::SIGTERM\n+            };\n+\n+            unsafe {\n+                libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+            }\n+        }\n+    }\n+}\n+\n /// A value representing a child process\n-pub trait Program {\n+pub struct Program {\n+    priv r: ProgRepr,\n+}\n+\n+impl Drop for Program {\n+    fn finalize(&self) {\n+        // FIXME #4943: transmute is bad.\n+        let selfr: &mut ProgRepr = unsafe { cast::transmute(&self.r) };\n+\n+        selfr.finish();\n+        selfr.close_outputs();\n+        free_handle(self.r.handle);\n+    }\n+}\n+\n+pub impl Program {\n+    priv fn new(r: ProgRepr) -> Program {\n+        Program {\n+            r: r\n+        }\n+    }\n+\n     /// Returns the process id of the program\n-    fn get_id(&mut self) -> pid_t;\n+    fn get_id(&mut self) -> pid_t { self.r.pid }\n \n     /// Returns an io::Writer that can be used to write to stdin\n-    fn input(&mut self) -> @io::Writer;\n+    fn input(&mut self) -> @io::Writer {\n+        io::fd_writer(self.r.in_fd, false)\n+    }\n \n     /// Returns an io::Reader that can be used to read from stdout\n-    fn output(&mut self) -> @io::Reader;\n+    fn output(&mut self) -> @io::Reader {\n+        io::FILE_reader(self.r.out_file, false)\n+    }\n \n     /// Returns an io::Reader that can be used to read from stderr\n-    fn err(&mut self) -> @io::Reader;\n+    fn err(&mut self) -> @io::Reader {\n+        io::FILE_reader(self.r.err_file, false)\n+    }\n \n     /// Closes the handle to the child processes standard input\n-    fn close_input(&mut self);\n+    fn close_input(&mut self) { self.r.close_input(); }\n \n     /**\n      * Waits for the child process to terminate. Closes the handle\n      * to stdin if necessary.\n      */\n-    fn finish(&mut self) -> int;\n+    fn finish(&mut self) -> int { self.r.finish() }\n \n     /**\n      * Terminate the program, giving it a chance to clean itself up if\n@@ -77,7 +166,7 @@ pub trait Program {\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    fn destroy(&mut self);\n+    fn destroy(&mut self) { self.r.destroy(false); }\n \n     /**\n      * Terminate the program as soon as possible without giving it a\n@@ -86,7 +175,7 @@ pub trait Program {\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    fn force_destroy(&mut self);\n+    fn force_destroy(&mut self) { self.r.destroy(true); }\n }\n \n \n@@ -248,9 +337,9 @@ pub fn run_program(prog: &str, args: &[~str]) -> int {\n /**\n  * Spawns a process and returns a Program\n  *\n- * The returned value is a boxed class containing a <Program> object that can\n- * be used for sending and receiving data over the standard file descriptors.\n- * The class will ensure that file descriptors are closed properly.\n+ * The returned value is a <Program> object that can be used for sending and\n+ * receiving data over the standard file descriptors.  The class will ensure\n+ * that file descriptors are closed properly.\n  *\n  * # Arguments\n  *\n@@ -259,9 +348,9 @@ pub fn run_program(prog: &str, args: &[~str]) -> int {\n  *\n  * # Return value\n  *\n- * A class with a <program> field\n+ * A <Program> object\n  */\n-pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n+pub fn start_program(prog: &str, args: &[~str]) -> Program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n@@ -277,105 +366,6 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n         libc::close(pipe_err.out);\n     }\n \n-    struct ProgRepr {\n-        pid: pid_t,\n-        handle: *(),\n-        in_fd: c_int,\n-        out_file: *libc::FILE,\n-        err_file: *libc::FILE,\n-        finished: bool,\n-    }\n-\n-    fn close_repr_input(r: &mut ProgRepr) {\n-        let invalid_fd = -1i32;\n-        if r.in_fd != invalid_fd {\n-            unsafe {\n-                libc::close(r.in_fd);\n-            }\n-            r.in_fd = invalid_fd;\n-        }\n-    }\n-\n-    fn close_repr_outputs(r: &mut ProgRepr) {\n-        unsafe {\n-            fclose_and_null(&mut r.out_file);\n-            fclose_and_null(&mut r.err_file);\n-        }\n-    }\n-\n-    fn finish_repr(r: &mut ProgRepr) -> int {\n-        if r.finished { return 0; }\n-        r.finished = true;\n-        close_repr_input(&mut *r);\n-        return waitpid(r.pid);\n-    }\n-\n-    fn destroy_repr(r: &mut ProgRepr, force: bool) {\n-        killpid(r.pid, force);\n-        finish_repr(&mut *r);\n-        close_repr_outputs(&mut *r);\n-\n-        #[cfg(windows)]\n-        fn killpid(pid: pid_t, _force: bool) {\n-            unsafe {\n-                libc::funcs::extra::kernel32::TerminateProcess(\n-                    cast::transmute(pid), 1);\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn killpid(pid: pid_t, force: bool) {\n-\n-            let signal = if force {\n-                libc::consts::os::posix88::SIGKILL\n-            } else {\n-                libc::consts::os::posix88::SIGTERM\n-            };\n-\n-            unsafe {\n-                libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-            }\n-        }\n-    }\n-\n-    struct ProgRes {\n-        r: ProgRepr,\n-    }\n-\n-    impl Drop for ProgRes {\n-        fn finalize(&self) {\n-            unsafe {\n-                // FIXME #4943: transmute is bad.\n-                finish_repr(cast::transmute(&self.r));\n-                close_repr_outputs(cast::transmute(&self.r));\n-            }\n-            free_handle(self.r.handle);\n-        }\n-    }\n-\n-    fn ProgRes(r: ProgRepr) -> ProgRes {\n-        ProgRes {\n-            r: r\n-        }\n-    }\n-\n-    impl Program for ProgRes {\n-        fn get_id(&mut self) -> pid_t { return self.r.pid; }\n-        fn input(&mut self) -> @io::Writer {\n-            io::fd_writer(self.r.in_fd, false)\n-        }\n-        fn output(&mut self) -> @io::Reader {\n-            io::FILE_reader(self.r.out_file, false)\n-        }\n-        fn err(&mut self) -> @io::Reader {\n-            io::FILE_reader(self.r.err_file, false)\n-        }\n-        fn close_input(&mut self) { close_repr_input(&mut self.r); }\n-        fn finish(&mut self) -> int { finish_repr(&mut self.r) }\n-        fn destroy(&mut self) { destroy_repr(&mut self.r, false); }\n-        fn force_destroy(&mut self) { destroy_repr(&mut self.r, true); }\n-    }\n-\n     let repr = ProgRepr {\n         pid: res.pid,\n         handle: res.handle,\n@@ -385,7 +375,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n         finished: false,\n     };\n \n-    @ProgRes(repr) as @Program\n+    Program::new(repr)\n }\n \n fn read_all(rd: @io::Reader) -> ~str {"}, {"sha": "bc4ec620aa86ad47441a0d94628e8b11f0b348e9", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -62,7 +62,7 @@ fn exit_runner(exit_fns: *ExitFunctions) {\n     // give us ownership of the array of functions\n     let mut exit_fns_vec = unsafe { vec::from_buf(start, count as uint) };\n     // Let's not make any promises about execution order\n-    rand::Rng().shuffle_mut(exit_fns_vec);\n+    rand::rng().shuffle_mut(exit_fns_vec);\n \n     debug!(\"running %u exit functions\", exit_fns_vec.len());\n "}, {"sha": "cd9b44c278e46b6cf1e80c641e4ac811230632bf", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -73,12 +73,12 @@ pub fn normalize(p: ~Path) -> ~Path {\n mod test {\n     use core::{os, rand};\n     use core::path::Path;\n-    use core::rand::RngUtil;\n     use path_util::*;\n+    use core::rand::RngUtil;\n \n     // Helper function to create a directory name that doesn't exist\n     pub fn mk_nonexistent(tmpdir: &Path, suffix: &str) -> Path {\n-        let r = rand::Rng();\n+        let r = rand::rng();\n         for 1000.times {\n             let p = tmpdir.push(r.gen_str(16) + suffix);\n             if !os::path_exists(&p) {"}, {"sha": "8bfa2013950692bf0641a372708bbf6926977645", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -876,6 +876,7 @@ mod tests {\n     use core::uint;\n     use core::vec;\n     use core::rand;\n+    use core::rand::Rng;\n \n     static bench_bits : uint = 1 << 14;\n \n@@ -1424,9 +1425,9 @@ mod tests {\n         assert!(a.capacity() == uint::bits);\n     }\n \n-    fn rng() -> @rand::Rng {\n+    fn rng() -> rand::IsaacRng {\n         let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::seeded_rng(seed)\n+        rand::IsaacRng::new_seeded(seed)\n     }\n \n     #[bench]"}, {"sha": "db6efdf3f52aaf75160196a9eddbc7028e73cee8", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -902,21 +902,17 @@ mod tests {\n #[cfg(test)]\n mod test_tim_sort {\n     use core::prelude::*;\n-\n     use sort::tim_sort;\n-\n     use core::rand::RngUtil;\n-    use core::rand;\n-    use core::vec;\n \n     struct CVal {\n         val: float,\n     }\n \n     impl Ord for CVal {\n         fn lt(&self, other: &CVal) -> bool {\n-            let rng = rand::Rng();\n-            if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n+            let rng = rand::rng();\n+            if rng.gen::<float>() > 0.995 { fail!(~\"It's happening!!!\"); }\n             (*self).val < other.val\n         }\n         fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n@@ -964,10 +960,9 @@ mod test_tim_sort {\n     #[should_fail]\n     #[cfg(unix)]\n     fn crash_test() {\n-        let rng = rand::Rng();\n+        let rng = rand::rng();\n         let mut arr = do vec::from_fn(1000) |_i| {\n-            let randVal = rng.gen_float();\n-            CVal { val: randVal }\n+            CVal { val: rng.gen() }\n         };\n \n         tim_sort(arr);\n@@ -985,10 +980,9 @@ mod test_tim_sort {\n \n     #[test]\n     fn test_bad_Ord_impl() {\n-        let rng = rand::Rng();\n+        let rng = rand::rng();\n         let mut arr = do vec::from_fn(500) |_i| {\n-            let randVal = rng.gen_uint();\n-            DVal { val: randVal }\n+            DVal { val: rng.gen() }\n         };\n \n         tim_sort(arr);\n@@ -998,14 +992,8 @@ mod test_tim_sort {\n #[cfg(test)]\n mod big_tests {\n     use core::prelude::*;\n-\n     use sort::*;\n-\n     use core::rand::RngUtil;\n-    use core::rand;\n-    use core::task;\n-    use core::uint;\n-    use core::vec;\n \n     #[test]\n     fn test_unique() {\n@@ -1045,14 +1033,13 @@ mod big_tests {\n             }\n         }\n \n-        let rng = rand::Rng();\n+        let rng = rand::rng();\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;\n-            let arr = do vec::from_fn(n) |_i| {\n-                rng.gen_float()\n+            let mut arr: ~[float] = do vec::from_fn(n) |_i| {\n+                rng.gen()\n             };\n-            let mut arr = arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1076,7 +1063,7 @@ mod big_tests {\n                 let size = arr.len();\n                 let mut idx = 1;\n                 while idx <= 10 {\n-                    arr[size-idx] = rng.gen_float();\n+                    arr[size-idx] = rng.gen();\n                     idx += 1;\n                 }\n             }\n@@ -1085,7 +1072,7 @@ mod big_tests {\n \n             for (n/100).times {\n                 let idx = rng.gen_uint_range(0, n);\n-                arr[idx] = rng.gen_float();\n+                arr[idx] = rng.gen();\n             }\n             tim_sort(arr);\n             isSorted(arr);\n@@ -1117,12 +1104,12 @@ mod big_tests {\n             }\n         }\n \n-        let rng = rand::Rng();\n+        let rng = rand::rng();\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;\n-            let arr = do vec::from_fn(n) |_i| {\n-                @rng.gen_float()\n+            let arr: ~[@float] = do vec::from_fn(n) |_i| {\n+                @rng.gen()\n             };\n             let mut arr = arr;\n \n@@ -1148,7 +1135,7 @@ mod big_tests {\n                 let size = arr.len();\n                 let mut idx = 1;\n                 while idx <= 10 {\n-                    arr[size-idx] = @rng.gen_float();\n+                    arr[size-idx] = @rng.gen();\n                     idx += 1;\n                 }\n             }\n@@ -1157,7 +1144,7 @@ mod big_tests {\n \n             for (n/100).times {\n                 let idx = rng.gen_uint_range(0, n);\n-                arr[idx] = @rng.gen_float();\n+                arr[idx] = @rng.gen();\n             }\n             tim_sort(arr);\n             isSorted(arr);"}, {"sha": "c9bcb3b8952be306571317bdc4f0e56161ecf9b9", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -10,13 +10,11 @@\n \n //! Temporary files and directories\n \n-use core::os;\n use core::prelude::*;\n use core::rand::RngUtil;\n-use core::rand;\n \n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n     for 1000.times {\n         let p = tmpdir.push(r.gen_str(16) + suffix);\n         if os::make_dir(&p, 0x1c0) { // 700"}, {"sha": "f82cc25e0f618e6a657369b0f073d1cd5c56c7d5", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -19,20 +19,9 @@ use getopts;\n use sort;\n use term;\n \n-use core::cmp::Eq;\n-\n use core::to_str::ToStr;\n-use core::either::Either;\n-use core::either;\n-use core::io::WriterUtil;\n-use core::io;\n use core::comm::{stream, SharedChan};\n-use core::option;\n use core::prelude::*;\n-use core::result;\n-use core::str;\n-use core::task;\n-use core::vec;\n \n pub mod rustrt {\n     use core::libc::size_t;\n@@ -608,12 +597,8 @@ pub mod bench {\n     use time::precise_time_ns;\n     use test::{BenchHarness, BenchSamples};\n     use stats::Stats;\n-\n-    use core::num;\n+    use core::prelude::*;\n     use core::rand::RngUtil;\n-    use core::rand;\n-    use core::u64;\n-    use core::vec;\n \n     pub impl BenchHarness {\n \n@@ -705,7 +690,7 @@ pub mod bench {\n         // not met, it may run as long as the Go algorithm.\n         pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n \n-            let rng = rand::Rng();\n+            let rng = rand::rng();\n             let mut magnitude = 10;\n             let mut prev_madp = 0.0;\n "}, {"sha": "1e48ce5aa6f2eb65ba82dca9e1681f08148cfe96", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -175,11 +175,7 @@ mod test {\n \n     use timer::*;\n     use uv;\n-\n-    use core::iter;\n     use core::rand::RngUtil;\n-    use core::rand;\n-    use core::task;\n     use core::pipes::{stream, SharedChan};\n \n     #[test]\n@@ -220,7 +216,7 @@ mod test {\n                 let hl_loop_clone = hl_loop.clone();\n                 do task::spawn {\n                     use core::rand::*;\n-                    let rng = Rng();\n+                    let rng = rng();\n                     for iter::repeat(times) {\n                         sleep(&hl_loop_clone, rng.next() as uint % maxms);\n                     }\n@@ -277,7 +273,7 @@ mod test {\n         let hl_loop = uv::global_loop::get();\n \n         for iter::repeat(times as uint) {\n-            let expected = rand::Rng().gen_str(16u);\n+            let expected = rand::rng().gen_str(16u);\n             let (test_po, test_ch) = stream::<~str>();\n             let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {"}, {"sha": "020f4daefd9d672612a1cbd4787a299aedff4dab", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -698,7 +698,6 @@ mod test_treemap {\n     use core::iterator::*;\n     use super::*;\n     use core::rand::RngUtil;\n-    use core::rand;\n \n     #[test]\n     fn find_empty() {\n@@ -835,12 +834,12 @@ mod test_treemap {\n         check_equal(ctrl, &map);\n         assert!(map.find(&5).is_none());\n \n-        let rng = rand::seeded_rng(&[42]);\n+        let rng = rand::IsaacRng::new_seeded(&[42]);\n \n         for 3.times {\n             for 90.times {\n-                let k = rng.gen_int();\n-                let v = rng.gen_int();\n+                let k = rng.gen();\n+                let v = rng.gen();\n                 if !ctrl.contains(&(k, v)) {\n                     assert!(map.insert(k, v));\n                     ctrl.push((k, v));"}, {"sha": "e216215ace7f9a6266c8c9b1292af7eda8f691e1", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -15,6 +15,7 @@ use std::time;\n use std::treemap::TreeMap;\n use core::hashmap::{HashMap, HashSet};\n use core::trie::TrieMap;\n+use core::rand::Rng;\n \n fn timed(label: &str, f: &fn()) {\n     let start = time::precise_time_s();\n@@ -102,7 +103,7 @@ fn main() {\n     let mut rand = vec::with_capacity(n_keys);\n \n     {\n-        let rng = core::rand::seeded_rng([1, 1, 1, 1, 1, 1, 1]);\n+        let rng = core::rand::IsaacRng::new_seeded([1, 1, 1, 1, 1, 1, 1]);\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n             let next = rng.next() as uint;"}, {"sha": "b3e3d295c0fad596d86aba2d4c559c7aa11f70df", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -12,7 +12,6 @@ extern mod std;\n use core::hashmap::HashSet;\n use std::bitv::BitvSet;\n use std::treemap::TreeSet;\n-use core::io::WriterUtil;\n \n struct Results {\n     sequential_ints: float,\n@@ -32,7 +31,7 @@ fn timed(result: &mut float, op: &fn()) {\n }\n \n pub impl Results {\n-    fn bench_int<T:Set<uint>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+    fn bench_int<T:Set<uint>, R: rand::Rng>(&mut self, rng: &R, num_keys: uint,\n                                rand_cap: uint, f: &fn() -> T) {\n         {\n             let mut set = f();\n@@ -70,8 +69,8 @@ pub impl Results {\n         }\n     }\n \n-    fn bench_str<T:Set<~str>>(&mut self, rng: @rand::Rng, num_keys: uint,\n-                               f: &fn() -> T) {\n+    fn bench_str<T:Set<~str>, R: rand::Rng>(&mut self, rng: &R, num_keys: uint,\n+                                            f: &fn() -> T) {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_strings) {\n@@ -156,25 +155,25 @@ fn main() {\n     let max = 200000;\n \n     {\n-        let rng = rand::seeded_rng(seed);\n+        let rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(rng, num_keys, max, || HashSet::new::<uint>());\n-        results.bench_str(rng, num_keys, || HashSet::new::<~str>());\n+        results.bench_int(&rng, num_keys, max, || HashSet::new::<uint>());\n+        results.bench_str(&rng, num_keys, || HashSet::new::<~str>());\n         write_results(\"core::hashmap::HashSet\", &results);\n     }\n \n     {\n-        let rng = rand::seeded_rng(seed);\n+        let rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(rng, num_keys, max, || TreeSet::new::<uint>());\n-        results.bench_str(rng, num_keys, || TreeSet::new::<~str>());\n+        results.bench_int(&rng, num_keys, max, || TreeSet::new::<uint>());\n+        results.bench_str(&rng, num_keys, || TreeSet::new::<~str>());\n         write_results(\"std::treemap::TreeSet\", &results);\n     }\n \n     {\n-        let rng = rand::seeded_rng(seed);\n+        let rng = rand::IsaacRng::new_seeded(seed);\n         let mut results = empty_results();\n-        results.bench_int(rng, num_keys, max, || BitvSet::new());\n+        results.bench_int(&rng, num_keys, max, || BitvSet::new());\n         write_results(\"std::bitv::BitvSet\", &results);\n     }\n }"}, {"sha": "1af3538a0219d1e2abf19afb459f82041705c816", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -13,8 +13,6 @@\n extern mod std;\n \n use std::time::precise_time_s;\n-\n-use core::io::{Reader, ReaderUtil};\n use core::rand::RngUtil;\n \n macro_rules! bench (\n@@ -71,13 +69,13 @@ fn read_line() {\n }\n \n fn vec_plus() {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n \n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n         let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n-        if r.gen_bool() {\n+        if r.gen() {\n             v += rv;\n         }\n         else {\n@@ -88,13 +86,13 @@ fn vec_plus() {\n }\n \n fn vec_append() {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n \n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n         let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n-        if r.gen_bool() {\n+        if r.gen() {\n             v = vec::append(v, rv);\n         }\n         else {\n@@ -105,12 +103,12 @@ fn vec_append() {\n }\n \n fn vec_push_all() {\n-    let r = rand::Rng();\n+    let r = rand::rng();\n \n     let mut v = ~[];\n     for uint::range(0, 1500) |i| {\n         let mut rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n-        if r.gen_bool() {\n+        if r.gen() {\n             v.push_all(rv);\n         }\n         else {"}, {"sha": "bd3de4a1b8aba7aa6af14dc7ef8d6d32a371a36d", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -25,7 +25,6 @@ use std::time;\n use std::deque::Deque;\n use std::par;\n use core::hashmap::{HashMap, HashSet};\n-use core::io::WriterUtil;\n use core::int::abs;\n use core::rand::RngUtil;\n \n@@ -34,9 +33,9 @@ type graph = ~[~[node_id]];\n type bfs_result = ~[node_id];\n \n fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n-    let r = rand::xorshift();\n+    let r = rand::XorShiftRng::new();\n \n-    fn choose_edge(i: node_id, j: node_id, scale: uint, r: @rand::Rng)\n+    fn choose_edge<R: rand::Rng>(i: node_id, j: node_id, scale: uint, r: &R)\n         -> (node_id, node_id) {\n \n         let A = 0.57;\n@@ -51,7 +50,7 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n             let j = j * 2i64;\n             let scale = scale - 1u;\n \n-            let x = r.gen_float();\n+            let x = r.gen::<float>();\n \n             if x < A {\n                 choose_edge(i, j, scale, r)\n@@ -75,7 +74,7 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n     }\n \n     do vec::from_fn((1u << scale) * edgefactor) |_i| {\n-        choose_edge(0i64, 0i64, scale, r)\n+        choose_edge(0i64, 0i64, scale, &r)\n     }\n }\n \n@@ -105,7 +104,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n \n fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n     let mut keys = HashSet::new();\n-    let r = rand::Rng();\n+    let r = rand::rng();\n \n     while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());"}, {"sha": "0da3a2e5d68d06fdd7d175d09df14459069983fa", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -13,8 +13,8 @@ fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n #[inline(always)]\n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n \n-fn random_gradient(r: @Rng) -> Vec2 {\n-    let v = r.gen_float() * float::consts::pi * 2.0;\n+fn random_gradient<R:Rng>(r: &R) -> Vec2 {\n+    let v = 2.0 * float::consts::pi * r.gen();\n     Vec2 {\n         x: float::cos(v) as f32,\n         y: float::sin(v) as f32,\n@@ -33,9 +33,9 @@ struct Noise2DContext {\n \n pub impl Noise2DContext {\n     fn new() -> Noise2DContext {\n-        let r = rand::Rng();\n+        let r = rand::rng();\n         let mut rgradients = [ Vec2 { x: 0.0, y: 0.0 }, ..256 ];\n-        for int::range(0, 256) |i| { rgradients[i] = random_gradient(r); }\n+        for int::range(0, 256) |i| { rgradients[i] = random_gradient(&r); }\n         let mut permutations = [ 0, ..256 ];\n         for int::range(0, 256) |i| { permutations[i] = i; }\n         r.shuffle_mut(permutations);"}, {"sha": "0fcf8341ac8524b1534ddba9a94ca34a6f0c5bc8", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -16,7 +16,7 @@\n  * http://shootout.alioth.debian.org/\n  */\n extern mod std;\n-use core::io::WriterUtil;\n+use core::rand::Rng;\n \n fn LINE_LENGTH() -> uint { return 60u; }\n \n@@ -63,7 +63,7 @@ fn make_random_fasta(wr: @io::Writer,\n                      genelist: ~[AminoAcids],\n                      n: int) {\n     wr.write_line(~\">\" + id + ~\" \" + desc);\n-    let rng = @mut MyRandom {last: rand::Rng().next()};\n+    let rng = @mut MyRandom {last: rand::rng().next()};\n     let mut op: ~str = ~\"\";\n     for uint::range(0u, n as uint) |_i| {\n         str::push_char(&mut op, select_random(myrandom_next(rng, 100u32),"}, {"sha": "1f908936aef471195c6f0c84d6ba744651e5694a", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26f992d5e199a1ff8c26733650d254d63be066a/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=e26f992d5e199a1ff8c26733650d254d63be066a", "patch": "@@ -54,14 +54,15 @@ fn runtest2(f: extern fn(), frame_backoff: u32, last_stk: *u8) -> u32 {\n }\n \n pub fn main() {\n+    use core::rand::Rng;\n     let fns = ~[\n         calllink01,\n         calllink02,\n         calllink08,\n         calllink09,\n         calllink10\n     ];\n-    let rng = rand::Rng();\n+    let rng = rand::rng();\n     for fns.each |f| {\n         let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;"}]}