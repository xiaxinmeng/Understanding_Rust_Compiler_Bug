{"sha": "8958ed672298148841b3b8d6371ce301e1cbbac1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NThlZDY3MjI5ODE0ODg0MWIzYjhkNjM3MWNlMzAxZTFjYmJhYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-09T19:05:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-09T19:05:14Z"}, "message": "Auto merge of #53216 - kennytm:rollup, r=kennytm\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #52773 (Avoid unnecessary pattern matching against Option and Result)\n - #53082 (Fix doc link (again))\n - #53094 (Automatically expand section if url id point to one of its component)\n - #53106 (atomic ordering docs)\n - #53110 (Account for --remap-path-prefix in save-analysis)\n - #53116 (NetBSD: fix signedess of char)\n - #53179 (Whitelist wasm32 simd128 target feature)\n - #53183 (Suggest comma when missing in macro call)\n - #53207 (Add individual docs for rotate_{left, right})\n - #53211 ([nll] enable feature(nll) on various crates for bootstrap)\n - #53214 ([nll] enable feature(nll) on various crates for bootstrap: part 2)\n - #53215 (Slightly refactor syntax_ext/format)\n - #53217 (inline some short functions)\n - #53219 ([nll] enable feature(nll) on various crates for bootstrap: part 3)\n - #53222 (A few cleanups for rustc_target)", "tree": {"sha": "7f51966483dbc2f13ef51cb6c244f11c8a31dd52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f51966483dbc2f13ef51cb6c244f11c8a31dd52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8958ed672298148841b3b8d6371ce301e1cbbac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8958ed672298148841b3b8d6371ce301e1cbbac1", "html_url": "https://github.com/rust-lang/rust/commit/8958ed672298148841b3b8d6371ce301e1cbbac1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8958ed672298148841b3b8d6371ce301e1cbbac1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b73535f1e9c46a698527fab51b1cc9fad3f53412", "url": "https://api.github.com/repos/rust-lang/rust/commits/b73535f1e9c46a698527fab51b1cc9fad3f53412", "html_url": "https://github.com/rust-lang/rust/commit/b73535f1e9c46a698527fab51b1cc9fad3f53412"}, {"sha": "9f55705a24fa3a9f3977f1f95bc37143b2d857a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f55705a24fa3a9f3977f1f95bc37143b2d857a0", "html_url": "https://github.com/rust-lang/rust/commit/9f55705a24fa3a9f3977f1f95bc37143b2d857a0"}], "stats": {"total": 1200, "additions": 791, "deletions": 409}, "files": [{"sha": "bcdfd8c9aa5d54b00eba93d67eb8a7d027d174e7", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -76,6 +76,7 @@\n \n #![cfg_attr(not(test), feature(fn_traits))]\n #![cfg_attr(not(test), feature(generator_trait))]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![cfg_attr(test, feature(test))]\n \n #![feature(allocator_api)]"}, {"sha": "480a24b9bd1f258ef94e1f8e04393384f3192e3a", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -16,6 +16,7 @@\n #![feature(core_intrinsics)]\n #![feature(libc)]\n #![feature(linkage)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]\n #![cfg_attr(dummy_jemalloc, allow(dead_code, unused_extern_crates))]"}, {"sha": "c5e056f6b12bec1533cb698d450c72114b041a7f", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -14,8 +14,10 @@\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"32838\")]\n+\n #![feature(allocator_api)]\n #![feature(core_intrinsics)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]\n #![cfg_attr(any(unix, target_os = \"cloudabi\", target_os = \"redox\"), feature(libc))]"}, {"sha": "265721c749755628f4f1f0b262f6bbf7e3c7bea4", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -26,6 +26,7 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(raw_vec_internals)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "58d6c4f5e09236640c8be496f352e6797c84c5ef", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -469,6 +469,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(2, 2.max(2));\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n+    #[inline]\n     fn max(self, other: Self) -> Self\n     where Self: Sized {\n         if other >= self { other } else { self }\n@@ -485,6 +486,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(2, 2.min(2));\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n+    #[inline]\n     fn min(self, other: Self) -> Self\n     where Self: Sized {\n         if self <= other { self } else { other }"}, {"sha": "d18e167fc3fa4dcd02c1f6234b973ea9b8e793ed", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -95,7 +95,7 @@ impl<T: ?Sized> !Send for *mut T { }\n     message=\"the size for values of type `{Self}` cannot be known at compilation time\",\n     label=\"doesn't have a size known at compile-time\",\n     note=\"to learn more, visit <https://doc.rust-lang.org/book/second-edition/\\\n-          ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\",\n+          ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\",\n )]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n pub trait Sized {"}, {"sha": "960853333f6c7179b7a2a9c37f3abfc8ae1ed361", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 115, "deletions": 113, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -188,7 +188,7 @@ mod wrapping;\n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n     ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr, $Feature:expr,\n-     $EndFeature:expr) => {\n+     $EndFeature:expr, $rot:expr, $rot_op:expr, $rot_result:expr) => {\n         doc_comment! {\n             concat!(\"Returns the smallest value that can be represented by this integer type.\n \n@@ -334,55 +334,52 @@ $EndFeature, \"\n             }\n         }\n \n-        /// Shifts the bits to the left by a specified amount, `n`,\n-        /// wrapping the truncated bits to the end of the resulting integer.\n-        ///\n-        /// Please note this isn't the same operation as `<<`!\n-        ///\n-        /// # Examples\n-        ///\n-        /// Please note that this example is shared between integer types.\n-        /// Which explains why `i64` is used here.\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFi64;\n-        /// let m = -0x76543210FEDCBA99i64;\n-        ///\n-        /// assert_eq!(n.rotate_left(32), m);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn rotate_left(self, n: u32) -> Self {\n-            (self as $UnsignedT).rotate_left(n) as Self\n-        }\n+        doc_comment! {\n+            concat!(\"Shifts the bits to the left by a specified amount, `n`,\n+wrapping the truncated bits to the end of the resulting integer.\n \n-        /// Shifts the bits to the right by a specified amount, `n`,\n-        /// wrapping the truncated bits to the beginning of the resulting\n-        /// integer.\n-        ///\n-        /// Please note this isn't the same operation as `>>`!\n-        ///\n-        /// # Examples\n-        ///\n-        /// Please note that this example is shared between integer types.\n-        /// Which explains why `i64` is used here.\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFi64;\n-        /// let m = -0xFEDCBA987654322i64;\n-        ///\n-        /// assert_eq!(n.rotate_right(4), m);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn rotate_right(self, n: u32) -> Self {\n-            (self as $UnsignedT).rotate_right(n) as Self\n+Please note this isn't the same operation as `<<`!\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $rot_op, stringify!($SelfT), \";\n+let m = \", $rot_result, \";\n+\n+assert_eq!(n.rotate_left(\", $rot, \"), m);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn rotate_left(self, n: u32) -> Self {\n+                (self as $UnsignedT).rotate_left(n) as Self\n+            }\n         }\n \n+        doc_comment! {\n+            concat!(\"Shifts the bits to the right by a specified amount, `n`,\n+wrapping the truncated bits to the beginning of the resulting\n+integer.\n+\n+Please note this isn't the same operation as `>>`!\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $rot_result, stringify!($SelfT), \";\n+let m = \", $rot_op, \";\n+\n+assert_eq!(n.rotate_right(\", $rot, \"), m);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn rotate_right(self, n: u32) -> Self {\n+                (self as $UnsignedT).rotate_right(n) as Self\n+            }\n+        }\n         /// Reverses the byte order of the integer.\n         ///\n         /// # Examples\n@@ -2012,46 +2009,50 @@ $EndFeature, \"\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\" }\n+    int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\", 2, \"-0x7e\", \"0xa\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16, i16, u16, 16, -32768, 32767, \"\", \"\" }\n+    int_impl! { i16, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, \"\", \"\" }\n+    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\" }\n+    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\", 12,\n+                \"0xaa00000000006e1\", \"0x6e10aa\" }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n     int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n-        170141183460469231731687303715884105727, \"\", \"\" }\n+        170141183460469231731687303715884105727, \"\", \"\", 16,\n+        \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\"\n+    }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i16, u16, 16, -32768, 32767, \"\", \"\" }\n+    int_impl! { isize, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\" }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i32, u32, 32, -2147483648, 2147483647, \"\", \"\" }\n+    int_impl! { isize, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\" }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\" }\n+    int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\",\n+        12, \"0xaa00000000006e1\", \"0x6e10aa\" }\n }\n \n // Emits the correct `cttz` call, depending on the size of the type.\n@@ -2069,7 +2070,8 @@ macro_rules! uint_cttz_call {\n \n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n-    ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr) => {\n+    ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n+        $rot:expr, $rot_op:expr, $rot_result:expr) => {\n         doc_comment! {\n             concat!(\"Returns the smallest value that can be represented by this integer type.\n \n@@ -2210,57 +2212,55 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             }\n         }\n \n-        /// Shifts the bits to the left by a specified amount, `n`,\n-        /// wrapping the truncated bits to the end of the resulting integer.\n-        ///\n-        /// Please note this isn't the same operation as `<<`!\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// Please note that this example is shared between integer types.\n-        /// Which explains why `u64` is used here.\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        /// let m = 0x3456789ABCDEF012u64;\n-        ///\n-        /// assert_eq!(n.rotate_left(12), m);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn rotate_left(self, n: u32) -> Self {\n-            // Protect against undefined behaviour for over-long bit shifts\n-            let n = n % $BITS;\n-            (self << n) | (self >> (($BITS - n) % $BITS))\n+        doc_comment! {\n+            concat!(\"Shifts the bits to the left by a specified amount, `n`,\n+wrapping the truncated bits to the end of the resulting integer.\n+\n+Please note this isn't the same operation as `<<`!\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $rot_op, stringify!($SelfT), \";\n+let m = \", $rot_result, \";\n+\n+assert_eq!(n.rotate_left(\", $rot, \"), m);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn rotate_left(self, n: u32) -> Self {\n+                // Protect against undefined behaviour for over-long bit shifts\n+                let n = n % $BITS;\n+                (self << n) | (self >> (($BITS - n) % $BITS))\n+            }\n         }\n \n-        /// Shifts the bits to the right by a specified amount, `n`,\n-        /// wrapping the truncated bits to the beginning of the resulting\n-        /// integer.\n-        ///\n-        /// Please note this isn't the same operation as `>>`!\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// Please note that this example is shared between integer types.\n-        /// Which explains why `u64` is used here.\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        /// let m = 0xDEF0123456789ABCu64;\n-        ///\n-        /// assert_eq!(n.rotate_right(12), m);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn rotate_right(self, n: u32) -> Self {\n-            // Protect against undefined behaviour for over-long bit shifts\n-            let n = n % $BITS;\n-            (self >> n) | (self << (($BITS - n) % $BITS))\n+        doc_comment! {\n+            concat!(\"Shifts the bits to the right by a specified amount, `n`,\n+wrapping the truncated bits to the beginning of the resulting\n+integer.\n+\n+Please note this isn't the same operation as `>>`!\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $rot_result, stringify!($SelfT), \";\n+let m = \", $rot_op, \";\n+\n+assert_eq!(n.rotate_right(\", $rot, \"), m);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn rotate_right(self, n: u32) -> Self {\n+                // Protect against undefined behaviour for over-long bit shifts\n+                let n = n % $BITS;\n+                (self >> n) | (self << (($BITS - n) % $BITS))\n+            }\n         }\n \n         /// Reverses the byte order of the integer.\n@@ -3621,7 +3621,7 @@ $EndFeature, \"\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, u8, 8, 255, \"\", \"\" }\n+    uint_impl! { u8, u8, 8, 255, \"\", \"\", 2, \"0x82\", \"0xa\" }\n \n \n     /// Checks if the value is within the ASCII range.\n@@ -4147,39 +4147,41 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, u16, 16, 65535, \"\", \"\" }\n+    uint_impl! { u16, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, u32, 32, 4294967295, \"\", \"\" }\n+    uint_impl! { u32, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, u64, 64, 18446744073709551615, \"\", \"\" }\n+    uint_impl! { u64, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\" }\n }\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\" }\n+    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\", 16,\n+        \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u16, 16, 65536, \"\", \"\" }\n+    uint_impl! { usize, u16, 16, 65536, \"\", \"\", 4, \"0xa003\", \"0x3a\" }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u32, 32, 4294967295, \"\", \"\" }\n+    uint_impl! { usize, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\" }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u64, 64, 18446744073709551615, \"\", \"\" }\n+    uint_impl! { usize, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\",\n+        \"0x6e10aa\" }\n }\n \n /// A classification of floating point numbers."}, {"sha": "f743fbfd0752b6931151abf9c54146d64141e2d1", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -1141,6 +1141,7 @@ unsafe impl<'a, A> TrustedLen for Iter<'a, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Clone for Iter<'a, A> {\n+    #[inline]\n     fn clone(&self) -> Iter<'a, A> {\n         Iter { inner: self.inner.clone() }\n     }\n@@ -1307,14 +1308,17 @@ impl<T> ops::Try for Option<T> {\n     type Ok = T;\n     type Error = NoneError;\n \n+    #[inline]\n     fn into_result(self) -> Result<T, NoneError> {\n         self.ok_or(NoneError)\n     }\n \n+    #[inline]\n     fn from_ok(v: T) -> Self {\n         Some(v)\n     }\n \n+    #[inline]\n     fn from_error(_: NoneError) -> Self {\n         None\n     }"}, {"sha": "ac908342655b6ea88229c123dd63a05e72f407c2", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -1084,6 +1084,7 @@ unsafe impl<'a, A> TrustedLen for Iter<'a, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n+    #[inline]\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n }\n \n@@ -1235,14 +1236,17 @@ impl<T,E> ops::Try for Result<T, E> {\n     type Ok = T;\n     type Error = E;\n \n+    #[inline]\n     fn into_result(self) -> Self {\n         self\n     }\n \n+    #[inline]\n     fn from_ok(v: T) -> Self {\n         Ok(v)\n     }\n \n+    #[inline]\n     fn from_error(v: E) -> Self {\n         Err(v)\n     }"}, {"sha": "5bb713f5767411022c1c18a4f119512241f34aec", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 327, "deletions": 74, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -29,7 +29,7 @@\n //!\n //! [`Ordering`]: enum.Ordering.html\n //!\n-//! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n+//! [1]: https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n //! [2]: ../../../nomicon/atomics.html\n //!\n //! Atomic variables are safe to share between threads (they implement [`Sync`])\n@@ -178,7 +178,7 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// \"relaxed\" atomics allow all reorderings.\n ///\n /// Rust's memory orderings are [the same as\n-/// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n+/// LLVM's](https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n ///\n /// For more information see the [nomicon].\n ///\n@@ -190,35 +190,70 @@ pub enum Ordering {\n     ///\n     /// Corresponds to LLVM's [`Monotonic`] ordering.\n     ///\n-    /// [`Monotonic`]: http://llvm.org/docs/Atomics.html#monotonic\n+    /// [`Monotonic`]: https://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n-    /// When coupled with a store, all previous writes become visible\n-    /// to the other threads that perform a load with [`Acquire`] ordering\n-    /// on the same value.\n+    /// When coupled with a store, all previous operations become ordered\n+    /// before any load of this value with [`Acquire`] (or stronger) ordering.\n+    /// In particular, all previous writes become visible to all threads\n+    /// that perform an [`Acquire`] (or stronger) load of this value.\n     ///\n-    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n+    /// Notice that using this ordering for an operation that combines loads\n+    /// and stores leads to a [`Relaxed`] load operation!\n+    ///\n+    /// This ordering is only applicable for operations that can perform a store.\n+    ///\n+    /// Corresponds to LLVM's [`Release`] ordering.\n+    ///\n+    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n+    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n+    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n-    /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with [`Release`] ordering on the same value\n-    /// in other threads.\n+    /// When coupled with a load, if the loaded value was written by a store operation with\n+    /// [`Release`] (or stronger) ordering, then all subsequent operations\n+    /// become ordered after that store. In particular, all subsequent loads will see data\n+    /// written before the store.\n+    ///\n+    /// Notice that using this ordering for an operation that combines loads\n+    /// and stores leads to a [`Relaxed`] store operation!\n+    ///\n+    /// This ordering is only applicable for operations that can perform a load.\n     ///\n-    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n+    /// Corresponds to LLVM's [`Acquire`] ordering.\n+    ///\n+    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n+    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n-    /// Has the effects of both [`Acquire`] and [`Release`] together.\n+    /// Has the effects of both [`Acquire`] and [`Release`] together:\n+    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n+    ///\n+    /// Notice that in the case of `compare_and_swap`, it is possible that the operation ends up\n+    /// not performing any store and hence it has just `Acquire` ordering. However,\n+    /// `AcqRel` will never perform [`Relaxed`] accesses.\n     ///\n     /// This ordering is only applicable for operations that combine both loads and stores.\n     ///\n-    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n+    /// Corresponds to LLVM's [`AcquireRelease`] ordering.\n     ///\n-    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n+    /// [`AcquireRelease`]: https://llvm.org/docs/Atomics.html#acquirerelease\n+    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n+    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n-    /// Like `AcqRel` with the additional guarantee that all threads see all\n+    /// Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n+    /// operations, respectively) with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n+    ///\n+    /// Corresponds to LLVM's [`SequentiallyConsistent`] ordering.\n+    ///\n+    /// [`SequentiallyConsistent`]: https://llvm.org/docs/Atomics.html#sequentiallyconsistent\n+    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n+    /// [`AcqRel`]: https://llvm.org/docs/Atomics.html#acquirerelease\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n     // Prevent exhaustive matching to allow for future extension\n@@ -297,15 +332,18 @@ impl AtomicBool {\n     /// Loads a value from the bool.\n     ///\n     /// `load` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is [`Release`] or [`AcqRel`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -325,9 +363,18 @@ impl AtomicBool {\n     /// Stores a value into the bool.\n     ///\n     /// `store` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -339,13 +386,6 @@ impl AtomicBool {\n     /// some_bool.store(false, Ordering::Relaxed);\n     /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n     /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n-    ///\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n@@ -357,9 +397,14 @@ impl AtomicBool {\n     /// Stores a value into the bool, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     ///\n     /// # Examples\n     ///\n@@ -384,9 +429,16 @@ impl AtomicBool {\n     /// was updated.\n     ///\n     /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-    /// ordering of this operation.\n+    /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n+    /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n+    /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n+    /// happens, and using [`Release`] makes the load part [`Relaxed`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     /// [`bool`]: ../../../std/primitive.bool.html\n     ///\n     /// # Examples\n@@ -420,13 +472,18 @@ impl AtomicBool {\n     /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the\n     /// operation succeeds while the second describes the required ordering when the\n-    /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n-    /// be equivalent or weaker than the success ordering.\n+    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+    /// and must be equivalent to or weaker than the success ordering.\n+    ///\n     ///\n     /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -473,16 +530,20 @@ impl AtomicBool {\n     /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the operation\n-    /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n-    /// weaker than the success ordering.\n+    /// ordering of this operation. The first describes the required ordering if the\n+    /// operation succeeds while the second describes the required ordering when the\n+    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+    /// and must be equivalent to or weaker than the success ordering.\n     ///\n     /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -523,6 +584,16 @@ impl AtomicBool {\n     ///\n     /// Returns the previous value.\n     ///\n+    /// `fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -554,6 +625,16 @@ impl AtomicBool {\n     ///\n     /// Returns the previous value.\n     ///\n+    /// `fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -598,6 +679,16 @@ impl AtomicBool {\n     ///\n     /// Returns the previous value.\n     ///\n+    /// `fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -629,6 +720,16 @@ impl AtomicBool {\n     ///\n     /// Returns the previous value.\n     ///\n+    /// `fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -714,15 +815,18 @@ impl<T> AtomicPtr<T> {\n     /// Loads a value from the pointer.\n     ///\n     /// `load` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is [`Release`] or [`AcqRel`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -743,9 +847,18 @@ impl<T> AtomicPtr<T> {\n     /// Stores a value into the pointer.\n     ///\n     /// `store` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -759,13 +872,6 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// some_ptr.store(other_ptr, Ordering::Relaxed);\n     /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n-    ///\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n@@ -777,9 +883,14 @@ impl<T> AtomicPtr<T> {\n     /// Stores a value into the pointer, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     ///\n     /// # Examples\n     ///\n@@ -806,9 +917,16 @@ impl<T> AtomicPtr<T> {\n     /// was updated.\n     ///\n     /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-    /// ordering of this operation.\n+    /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n+    /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n+    /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n+    /// happens, and using [`Release`] makes the load part [`Relaxed`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -839,14 +957,18 @@ impl<T> AtomicPtr<T> {\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n     /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if\n-    /// the operation succeeds while the second describes the required ordering when\n-    /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`]\n-    /// and must be equivalent or weaker than the success ordering.\n+    /// ordering of this operation. The first describes the required ordering if the\n+    /// operation succeeds while the second describes the required ordering when the\n+    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+    /// and must be equivalent to or weaker than the success ordering.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -892,15 +1014,19 @@ impl<T> AtomicPtr<T> {\n     /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the operation\n-    /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n-    /// weaker than the success ordering.\n+    /// ordering of this operation. The first describes the required ordering if the\n+    /// operation succeeds while the second describes the required ordering when the\n+    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+    /// and must be equivalent to or weaker than the success ordering.\n     ///\n     /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -1077,14 +1203,18 @@ assert_eq!(some_var.into_inner(), 5);\n                 concat!(\"Loads a value from the atomic integer.\n \n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n \n # Panics\n \n Panics if `order` is [`Release`] or [`AcqRel`].\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n # Examples\n \n@@ -1106,8 +1236,18 @@ assert_eq!(some_var.load(Ordering::Relaxed), 5);\n                 concat!(\"Stores a value into the atomic integer.\n \n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+ Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n+\n+# Panics\n+\n+Panics if `order` is [`Acquire`] or [`AcqRel`].\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n # Examples\n \n@@ -1118,14 +1258,7 @@ let some_var = \", stringify!($atomic_type), \"::new(5);\n \n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n-```\n-\n-# Panics\n-\n-Panics if `order` is [`Acquire`] or [`AcqRel`].\n-\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\"),\n+```\"),\n                 #[inline]\n                 #[$stable]\n                 pub fn store(&self, val: $int_type, order: Ordering) {\n@@ -1136,9 +1269,15 @@ Panics if `order` is [`Acquire`] or [`AcqRel`].\n             doc_comment! {\n                 concat!(\"Stores a value into the atomic integer, returning the previous value.\n \n-`swap` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+`swap` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n \n # Examples\n \n@@ -1165,9 +1304,16 @@ The return value is always the previous value. If it is equal to `current`, then\n value was updated.\n \n `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-ordering of this operation.\n+ordering of this operation. Notice that even when using [`AcqRel`], the operation\n+might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n+Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n+happens, and using [`Release`] makes the load part [`Relaxed`].\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n \n # Examples\n \n@@ -1208,14 +1354,18 @@ containing the previous value. On success this value is guaranteed to be equal t\n `current`.\n \n `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. The first describes the required ordering if\n-the operation succeeds while the second describes the required ordering when\n-the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-must be equivalent or weaker than the success ordering.\n+ordering of this operation. The first describes the required ordering if the\n+operation succeeds while the second describes the required ordering when the\n+operation fails. Using [`Acquire`] as success ordering makes the store part\n+of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+and must be equivalent to or weaker than the success ordering.\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n # Examples\n \n@@ -1260,13 +1410,17 @@ written and containing the previous value.\n `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n ordering of this operation. The first describes the required ordering if the\n operation succeeds while the second describes the required ordering when the\n-operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-must be equivalent or weaker than the success ordering.\n+operation fails. Using [`Acquire`] as success ordering makes the store part\n+of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+and must be equivalent to or weaker than the success ordering.\n \n [`compare_exchange`]: #method.compare_exchange\n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n # Examples\n \n@@ -1302,6 +1456,16 @@ loop {\n \n This operation wraps around on overflow.\n \n+`fetch_add` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1323,6 +1487,16 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n \n This operation wraps around on overflow.\n \n+`fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1347,6 +1521,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1371,6 +1555,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1396,6 +1590,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1420,6 +1624,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1445,6 +1659,25 @@ Note: This may call the function multiple times if the value has been changed fr\n the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n but once to the stored value.\n \n+`fetch_update` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering for loads\n+and failed updates while the second describes the required ordering when the\n+operation finally succeeds. Beware that this is different from the two\n+modes in [`compare_exchange`]!\n+\n+Using [`Acquire`] as success ordering makes the store part\n+of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n+[`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+and must be equivalent to or weaker than the success ordering.\n+\n+[`bool`]: ../../../std/primitive.bool.html\n+[`compare_exchange`]: #method.compare_exchange\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n+\n # Examples\n \n ```rust\n@@ -1485,6 +1718,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_max` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1524,6 +1767,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_min` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```"}, {"sha": "d2209da0ca30c0084fac0d602e3e7be36dc9b1ba", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -20,6 +20,8 @@\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(deny(warnings))))]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n+\n pub use self::Piece::*;\n pub use self::Position::*;\n pub use self::Alignment::*;"}, {"sha": "a8eea18e46461984368a86788372d570d7140150", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -288,6 +288,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(str_escape)]\n \n use self::LabelText::*;"}, {"sha": "da568fae70e146e908326a17f13bbe0eaefb4ed2", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -24,6 +24,7 @@\n \n #![feature(core_intrinsics)]\n #![feature(libc)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(panic_runtime)]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]"}, {"sha": "a61b2c1f06394aaabfb1775b09abe902f99c6d21", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -34,6 +34,7 @@\n #![feature(core_intrinsics)]\n #![feature(lang_items)]\n #![feature(libc)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(panic_unwind)]\n #![feature(raw)]\n #![feature(staged_api)]"}, {"sha": "1ffe8157a0fb43a764ef0918940e325d36ffee6a", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -681,10 +681,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     }\n                 }\n                 &ty::Predicate::RegionOutlives(ref binder) => {\n-                    if let Err(_) = select\n-                        .infcx()\n-                        .region_outlives_predicate(&dummy_cause, binder)\n-                    {\n+                    if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }"}, {"sha": "a02b63755dc129cee8fe0bf8aae8cbe19df3067e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n                 let param_env = ty::ParamEnv::empty();\n-                if let Ok(_) = self.can_sub(param_env, error, implication) {\n+                if self.can_sub(param_env, error, implication).is_ok() {\n                     debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n                     return true\n                 }"}, {"sha": "0127ae423da54fcba742953751d8894feb9901b9", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -137,7 +137,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // variables. Process these constraints.\n         let mut fulfill_cx = FulfillmentContext::new();\n         fulfill_cx.register_predicate_obligations(self, result.obligations);\n-        if let Err(_) = fulfill_cx.select_all_or_error(self) {\n+        if fulfill_cx.select_all_or_error(self).is_err() {\n             self.tcx.sess.delay_span_bug(\n                 span,\n                 \"implied_outlives_bounds failed to solve obligations from instantiation\""}, {"sha": "1e3fe70535bcc591e4206a1c7d678d317a91aaec", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -1587,8 +1587,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        if let Err(_) = self.infcx.at(&obligation.cause, obligation.param_env)\n-                                  .sup(ty::Binder::dummy(skol_trait_ref), trait_bound) {\n+        if self.infcx.at(&obligation.cause, obligation.param_env)\n+                     .sup(ty::Binder::dummy(skol_trait_ref), trait_bound).is_err() {\n             return false;\n         }\n "}, {"sha": "7329f4832f2e27022ce4fd8d57bc3bb5d5db22f9", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -294,7 +294,7 @@ fn resolve_associated_item<'a, 'tcx>(\n             })\n         }\n         traits::VtableBuiltin(..) => {\n-            if let Some(_) = tcx.lang_items().clone_trait() {\n+            if tcx.lang_items().clone_trait().is_some() {\n                 Some(Instance {\n                     def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n                     substs: rcvr_substs"}, {"sha": "d6e821d427d0580f45266e98cce22d40be793747", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -45,6 +45,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![forbid(unsafe_code)]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(try_from)]\n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]"}, {"sha": "b3ba86ad8a4b32af8f7f6629cca53f8891221b8f", "filename": "src/librustc_asan/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_asan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_asan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -10,6 +10,7 @@\n \n #![sanitizer_runtime]\n #![feature(alloc_system)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]"}, {"sha": "aa85582432b75f5e12b1a6557377a8eeede61667", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -14,6 +14,7 @@\n \n #![allow(non_camel_case_types)]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(quote)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "ff26e0f35f00f085bdc595522e3169fef4c55ff4", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -169,6 +169,10 @@ const MIPS_WHITELIST: &[(&str, Option<&str>)] = &[\n     (\"msa\", Some(\"mips_target_feature\")),\n ];\n \n+const WASM_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"simd128\", Some(\"wasm_target_feature\")),\n+];\n+\n /// When rustdoc is running, provide a list of all known features so that all their respective\n /// primtives may be documented.\n ///\n@@ -181,6 +185,7 @@ pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<&'static\n         .chain(HEXAGON_WHITELIST.iter().cloned())\n         .chain(POWERPC_WHITELIST.iter().cloned())\n         .chain(MIPS_WHITELIST.iter().cloned())\n+        .chain(WASM_WHITELIST.iter().cloned())\n }\n \n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n@@ -228,6 +233,7 @@ pub fn target_feature_whitelist(sess: &Session)\n         \"hexagon\" => HEXAGON_WHITELIST,\n         \"mips\" | \"mips64\" => MIPS_WHITELIST,\n         \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n+        \"wasm32\" => WASM_WHITELIST,\n         _ => &[],\n     }\n }"}, {"sha": "39087c5f74616bfb3cadafbc8339f99aa49f8af2", "filename": "src/librustc_cratesio_shim/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_cratesio_shim%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_cratesio_shim%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_cratesio_shim%2Fsrc%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -11,5 +11,7 @@\n // See Cargo.toml for a comment explaining this crate.\n #![allow(unused_extern_crates)]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n+\n extern crate bitflags;\n extern crate log;"}, {"sha": "c3bdf07cd20794cc1094a5af4d6373abf81b3ffb", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -20,6 +20,7 @@\n \n #![feature(box_syntax)]\n #![cfg_attr(unix, feature(libc))]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(option_replace)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "6b1298750fba0533fd44735d8dc0688a3972e32f", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -1295,7 +1295,7 @@ impl EmitterWriter {\n                 }\n \n                 // if we elided some lines, add an ellipsis\n-                if let Some(_) = lines.next() {\n+                if lines.next().is_some() {\n                     buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n                 } else if !show_underline {\n                     draw_col_separator_no_space(&mut buffer, row_num, max_line_num_len + 1);"}, {"sha": "1666369e422cadc5c7a02c06ddf31771fde237a2", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -16,6 +16,7 @@\n #![allow(unused_attributes)]\n #![feature(range_contains)]\n #![cfg_attr(unix, feature(libc))]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(optin_builtin_traits)]\n \n extern crate atty;"}, {"sha": "22b260642e42482f19f1aa3aab452b2c314c1d3d", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -14,6 +14,7 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(specialization)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "801604d1379e33f4244b34b5dce8daca9b8e3f8e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -27,6 +27,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(macro_vis_matcher)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(macro_at_most_once_rep)]"}, {"sha": "a3591b2415a8959df8867845bdffb4ba16d4ae98", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(libc)]\n #![feature(macro_at_most_once_rep)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![feature(quote)]"}, {"sha": "67b92d92a343d4264c685bdddfac0b9875231ca5", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -138,7 +138,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         let tables = self.tcx.typeck_tables_of(id);\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n-                        if let Some(_) = tables.closure_kind_origins().get(hir_id) {\n+                        if tables.closure_kind_origins().get(hir_id).is_some() {\n                             false\n                         } else {\n                             true\n@@ -735,7 +735,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             &including_downcast,\n                         )?;\n                         buf.push_str(\"[\");\n-                        if let Err(_) = self.append_local_to_string(index, buf) {\n+                        if self.append_local_to_string(index, buf).is_err() {\n                             buf.push_str(\"..\");\n                         }\n                         buf.push_str(\"]\");"}, {"sha": "d62cb00923f7047411ff3a17d5da3886d33d6ea9", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -18,6 +18,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(rustc_diagnostic_macros)]\n \n #[macro_use]"}, {"sha": "67f53a67313f798f1f9d2979d9f57e0a949095af", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -64,6 +64,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(rustc_diagnostic_macros)]\n \n #[macro_use] extern crate syntax;"}, {"sha": "fcb1b65014be0afb476066aaf991b7e98948d1b5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -12,6 +12,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "8ff44834929064e7661e9a69382caa98caffb4f9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -13,6 +13,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(crate_visibility_modifier)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n \n@@ -2698,7 +2699,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             self.label_ribs.pop();\n         }\n         self.ribs[ValueNS].pop();\n-        if let Some(_) = anonymous_module {\n+        if anonymous_module.is_some() {\n             self.ribs[TypeNS].pop();\n         }\n         debug!(\"(resolving block) leaving block\");\n@@ -4256,7 +4257,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         while let Some((in_module, path_segments)) = worklist.pop() {\n             // abort if the module is already found\n-            if let Some(_) = result { break; }\n+            if result.is_some() { break; }\n \n             self.populate_module_if_necessary(in_module);\n "}, {"sha": "d2e52f98238dd99012e429bbce818df934744e78", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -39,7 +39,7 @@ pub struct WriteOutput<'b, W: Write + 'b> {\n \n impl<'b, W: Write> DumpOutput for WriteOutput<'b, W> {\n     fn dump(&mut self, result: &Analysis) {\n-        if let Err(_) = write!(self.output, \"{}\", as_json(&result)) {\n+        if write!(self.output, \"{}\", as_json(&result)).is_err() {\n             error!(\"Error writing output\");\n         }\n     }"}, {"sha": "50aa48e8c5249801eee25eeb1613ea76e058db45", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -12,6 +12,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(custom_attribute)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![allow(unused_attributes)]\n \n #![recursion_limit=\"256\"]\n@@ -125,7 +126,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             result.push(ExternalCrateData {\n                 // FIXME: change file_name field to PathBuf in rls-data\n                 // https://github.com/nrc/rls-data/issues/7\n-                file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n+                file_name: self.span_utils.make_path_string(&lo_loc.file.name),\n                 num: n.as_u32(),\n                 id: GlobalCrateId {\n                     name: self.tcx.crate_name(n).to_string(),"}, {"sha": "85dd2a3a20683e79dfe13a1ce40566c046bbc739", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -13,7 +13,6 @@ use rustc::session::Session;\n use generated_code;\n \n use std::cell::Cell;\n-use std::env;\n \n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, Token};\n@@ -36,11 +35,10 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn make_path_string(path: &FileName) -> String {\n+    pub fn make_path_string(&self, path: &FileName) -> String {\n         match *path {\n             FileName::Real(ref path) if !path.is_absolute() =>\n-                env::current_dir()\n-                    .unwrap()\n+                self.sess.working_dir.0\n                     .join(&path)\n                     .display()\n                     .to_string(),"}, {"sha": "8e2dd99696e176d3e78c1833cdce0ef1189a7bea", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -145,7 +145,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n     // Extract first 8 chunks as the prefix\n     let rest_size = size - Size::from_bytes(8) * prefix_index as u64;\n     arg.cast_to(CastTarget {\n-        prefix: prefix,\n+        prefix,\n         prefix_chunk: Size::from_bytes(8),\n         rest: Uniform { unit: Reg::i64(), total: rest_size }\n     });"}, {"sha": "af874b1035b89a81cb2e265faf25bdcf65a27b45", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -90,7 +90,7 @@ impl ArgAttributes {\n     }\n \n     pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n-        self.regular = self.regular | attr;\n+        self.regular |= attr;\n         self\n     }\n \n@@ -229,7 +229,7 @@ impl CastTarget {\n \n     pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n         self.prefix.iter()\n-            .filter_map(|x| x.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.align(cx)))\n+            .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk }.align(cx)))\n             .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n                 |acc, align| acc.max(align))\n     }"}, {"sha": "eade086ec48eca0bfba54a6fecd70f8fab072476", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -199,10 +199,8 @@ pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n                         _ => {}\n                     }\n                 }\n-                if arg.layout.is_aggregate() {\n-                    if int_regs < needed_int || sse_regs < needed_sse {\n-                        cls_or_mem = Err(Memory);\n-                    }\n+                if arg.layout.is_aggregate() && (int_regs < needed_int || sse_regs < needed_sse) {\n+                    cls_or_mem = Err(Memory);\n                 }\n             }\n         }"}, {"sha": "4f25360d8eae226685c68817e472596c42019968", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -93,17 +93,17 @@ impl TargetDataLayout {\n         let mut dl = TargetDataLayout::default();\n         let mut i128_align_src = 64;\n         for spec in target.data_layout.split('-') {\n-            match &spec.split(':').collect::<Vec<_>>()[..] {\n-                &[\"e\"] => dl.endian = Endian::Little,\n-                &[\"E\"] => dl.endian = Endian::Big,\n-                &[\"a\", ref a..] => dl.aggregate_align = align(a, \"a\")?,\n-                &[\"f32\", ref a..] => dl.f32_align = align(a, \"f32\")?,\n-                &[\"f64\", ref a..] => dl.f64_align = align(a, \"f64\")?,\n-                &[p @ \"p\", s, ref a..] | &[p @ \"p0\", s, ref a..] => {\n+            match spec.split(':').collect::<Vec<_>>()[..] {\n+                [\"e\"] => dl.endian = Endian::Little,\n+                [\"E\"] => dl.endian = Endian::Big,\n+                [\"a\", ref a..] => dl.aggregate_align = align(a, \"a\")?,\n+                [\"f32\", ref a..] => dl.f32_align = align(a, \"f32\")?,\n+                [\"f64\", ref a..] => dl.f64_align = align(a, \"f64\")?,\n+                [p @ \"p\", s, ref a..] | [p @ \"p0\", s, ref a..] => {\n                     dl.pointer_size = size(s, p)?;\n                     dl.pointer_align = align(a, p)?;\n                 }\n-                &[s, ref a..] if s.starts_with(\"i\") => {\n+                [s, ref a..] if s.starts_with(\"i\") => {\n                     let bits = match s[1..].parse::<u64>() {\n                         Ok(bits) => bits,\n                         Err(_) => {\n@@ -127,7 +127,7 @@ impl TargetDataLayout {\n                         dl.i128_align = a;\n                     }\n                 }\n-                &[s, ref a..] if s.starts_with(\"v\") => {\n+                [s, ref a..] if s.starts_with(\"v\") => {\n                     let v_size = size(&s[1..], \"v\")?;\n                     let a = align(a, s)?;\n                     if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n@@ -429,8 +429,8 @@ pub enum Integer {\n }\n \n impl Integer {\n-    pub fn size(&self) -> Size {\n-        match *self {\n+    pub fn size(self) -> Size {\n+        match self {\n             I8 => Size::from_bytes(1),\n             I16 => Size::from_bytes(2),\n             I32 => Size::from_bytes(4),\n@@ -439,10 +439,10 @@ impl Integer {\n         }\n     }\n \n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: C) -> Align {\n         let dl = cx.data_layout();\n \n-        match *self {\n+        match self {\n             I8 => dl.i8_align,\n             I16 => dl.i16_align,\n             I32 => dl.i32_align,\n@@ -522,15 +522,15 @@ impl fmt::Display for FloatTy {\n }\n \n impl FloatTy {\n-    pub fn ty_to_string(&self) -> &'static str {\n-        match *self {\n+    pub fn ty_to_string(self) -> &'static str {\n+        match self {\n             FloatTy::F32 => \"f32\",\n             FloatTy::F64 => \"f64\",\n         }\n     }\n \n-    pub fn bit_width(&self) -> usize {\n-        match *self {\n+    pub fn bit_width(self) -> usize {\n+        match self {\n             FloatTy::F32 => 32,\n             FloatTy::F64 => 64,\n         }"}, {"sha": "5f5cc4c5ff7c856b5a493ed715847fd6dc100d33", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -23,6 +23,7 @@\n \n #![feature(box_syntax)]\n #![feature(const_fn)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(slice_patterns)]\n \n #[macro_use]"}, {"sha": "6d8c8eb19f057c25a87815f7c17655446309f4a1", "filename": "src/librustc_target/spec/abi.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fabi.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -51,7 +51,7 @@ pub struct AbiData {\n }\n \n #[allow(non_upper_case_globals)]\n-const AbiDatas: &'static [AbiData] = &[\n+const AbiDatas: &[AbiData] = &[\n     // Platform-specific ABIs\n     AbiData {abi: Abi::Cdecl, name: \"cdecl\", generic: false },\n     AbiData {abi: Abi::Stdcall, name: \"stdcall\", generic: false },\n@@ -87,20 +87,20 @@ pub fn all_names() -> Vec<&'static str> {\n \n impl Abi {\n     #[inline]\n-    pub fn index(&self) -> usize {\n-        *self as usize\n+    pub fn index(self) -> usize {\n+        self as usize\n     }\n \n     #[inline]\n-    pub fn data(&self) -> &'static AbiData {\n+    pub fn data(self) -> &'static AbiData {\n         &AbiDatas[self.index()]\n     }\n \n-    pub fn name(&self) -> &'static str {\n+    pub fn name(self) -> &'static str {\n         self.data().name\n     }\n \n-    pub fn generic(&self) -> bool {\n+    pub fn generic(self) -> bool {\n         self.data().generic\n     }\n }"}, {"sha": "38b3f2528fe8694bb922d8657760173a935444e7", "filename": "src/librustc_target/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_base.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -26,7 +26,7 @@ pub fn opts() -> TargetOptions {\n     // TLS is flagged as enabled if it looks to be supported.\n     let deployment_target = env::var(\"MACOSX_DEPLOYMENT_TARGET\").ok();\n     let version = deployment_target.as_ref().and_then(|s| {\n-        let mut i = s.splitn(2, \".\");\n+        let mut i = s.splitn(2, '.');\n         i.next().and_then(|a| i.next().map(|b| (a, b)))\n     }).and_then(|(a, b)| {\n         a.parse::<u32>().and_then(|a| b.parse::<u32>().map(|b| (a, b))).ok()"}, {"sha": "296eaca7c7df013dac7c7cd23cf7cc6a74a2484a", "filename": "src/librustc_target/spec/apple_ios_base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -25,13 +25,13 @@ pub enum Arch {\n }\n \n impl Arch {\n-    pub fn to_string(&self) -> &'static str {\n+    pub fn to_string(self) -> &'static str {\n         match self {\n-            &Armv7 => \"armv7\",\n-            &Armv7s => \"armv7s\",\n-            &Arm64 => \"arm64\",\n-            &I386 => \"i386\",\n-            &X86_64 => \"x86_64\"\n+            Armv7 => \"armv7\",\n+            Armv7s => \"armv7s\",\n+            Arm64 => \"arm64\",\n+            I386 => \"i386\",\n+            X86_64 => \"x86_64\"\n         }\n     }\n }"}, {"sha": "4945784659517b63537ed5d85ac08b9cb9edf120", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -747,7 +747,7 @@ impl Target {\n     /// Maximum integer size in bits that this target can perform atomic\n     /// operations on.\n     pub fn max_atomic_width(&self) -> u64 {\n-        self.options.max_atomic_width.unwrap_or(self.target_pointer_width.parse().unwrap())\n+        self.options.max_atomic_width.unwrap_or_else(|| self.target_pointer_width.parse().unwrap())\n     }\n \n     pub fn is_abi_supported(&self, abi: Abi) -> bool {\n@@ -777,7 +777,7 @@ impl Target {\n         let get_opt_field = |name: &str, default: &str| {\n             obj.find(name).and_then(|s| s.as_string())\n                .map(|s| s.to_string())\n-               .unwrap_or(default.to_string())\n+               .unwrap_or_else(|| default.to_string())\n         };\n \n         let mut base = Target {\n@@ -1007,7 +1007,6 @@ impl Target {\n     /// filesystem access and JSON decoding.\n     pub fn search(target_triple: &TargetTriple) -> Result<Target, String> {\n         use std::env;\n-        use std::ffi::OsString;\n         use std::fs;\n         use serialize::json;\n \n@@ -1018,8 +1017,8 @@ impl Target {\n             Target::from_json(obj)\n         }\n \n-        match target_triple {\n-            &TargetTriple::TargetTriple(ref target_triple) => {\n+        match *target_triple {\n+            TargetTriple::TargetTriple(ref target_triple) => {\n                 // check if triple is in list of supported targets\n                 if let Ok(t) = load_specific(target_triple) {\n                     return Ok(t)\n@@ -1032,8 +1031,7 @@ impl Target {\n                     PathBuf::from(target)\n                 };\n \n-                let target_path = env::var_os(\"RUST_TARGET_PATH\")\n-                                    .unwrap_or(OsString::new());\n+                let target_path = env::var_os(\"RUST_TARGET_PATH\").unwrap_or_default();\n \n                 // FIXME 16351: add a sane default search path?\n \n@@ -1045,7 +1043,7 @@ impl Target {\n                 }\n                 Err(format!(\"Could not find specification for target {:?}\", target_triple))\n             }\n-            &TargetTriple::TargetPath(ref target_path) => {\n+            TargetTriple::TargetPath(ref target_path) => {\n                 if target_path.is_file() {\n                     return load_file(&target_path);\n                 }\n@@ -1190,7 +1188,7 @@ impl ToJson for Target {\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()\n-                .map(Abi::name).map(|name| name.to_json())\n+                .map(|&name| Abi::name(name).to_json())\n                 .collect::<Vec<_>>().to_json());\n         }\n \n@@ -1229,9 +1227,9 @@ impl TargetTriple {\n     ///\n     /// If this target is a path, the file name (without extension) is returned.\n     pub fn triple(&self) -> &str {\n-        match self {\n-            &TargetTriple::TargetTriple(ref triple) => triple,\n-            &TargetTriple::TargetPath(ref path) => {\n+        match *self {\n+            TargetTriple::TargetTriple(ref triple) => triple,\n+            TargetTriple::TargetPath(ref path) => {\n                 path.file_stem().expect(\"target path must not be empty\").to_str()\n                     .expect(\"target path must be valid unicode\")\n             }\n@@ -1247,7 +1245,7 @@ impl TargetTriple {\n         use std::collections::hash_map::DefaultHasher;\n \n         let triple = self.triple();\n-        if let &TargetTriple::TargetPath(ref path) = self {\n+        if let TargetTriple::TargetPath(ref path) = *self {\n             let mut hasher = DefaultHasher::new();\n             path.hash(&mut hasher);\n             let hash = hasher.finish();"}, {"sha": "ba6b2c57bfac6a15f71b9058d578b75c90957e3b", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -16,6 +16,7 @@\n #![feature(extern_prelude)]\n #![feature(iterator_find_map)]\n #![feature(in_band_lifetimes)]\n+#![cfg_attr(not(stage0), feature(nll))]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "b3ba86ad8a4b32af8f7f6629cca53f8891221b8f", "filename": "src/librustc_tsan/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_tsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_tsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -10,6 +10,7 @@\n \n #![sanitizer_runtime]\n #![feature(alloc_system)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]"}, {"sha": "68e851446dc964014f96de7c533abef8e0659c4a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -758,8 +758,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                         self.span, infer::FnCall, &fty);\n \n                     if let Some(self_ty) = self_ty {\n-                        if let Err(_) = self.at(&ObligationCause::dummy(), self.param_env)\n-                            .sup(fty.inputs()[0], self_ty)\n+                        if self.at(&ObligationCause::dummy(), self.param_env)\n+                               .sup(fty.inputs()[0], self_ty)\n+                               .is_err()\n                         {\n                             return false\n                         }"}, {"sha": "9b6772e2dbb21b21ac0b2a7e5fc7695c9d3439c2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -3915,7 +3915,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             }\n             hir::ExprKind::Continue(destination) => {\n-                if let Ok(_) = destination.target_id {\n+                if destination.target_id.is_ok() {\n                     tcx.types.never\n                 } else {\n                     // There was an error, make typecheck fail"}, {"sha": "68e4618328077cc6030e309c031703c4ed14186b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -486,7 +486,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                         &name,\n                                                         &output_filenames,\n                                                         |tcx, analysis, _, result| {\n-            if let Err(_) = result {\n+            if result.is_err() {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n             }\n "}, {"sha": "ff2cc35fce807622012c1ddac4ef177d24704b62", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -44,7 +44,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>,\n     write_header(class, &mut out).unwrap();\n \n     let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.codemap());\n-    if let Err(_) = classifier.write_source(&mut out) {\n+    if classifier.write_source(&mut out).is_err() {\n         return format!(\"<pre>{}</pre>\", src);\n     }\n "}, {"sha": "c104b883340615d88948f4d1b48f464c42cd0abc", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -625,7 +625,7 @@ impl LangString {\n                     data.no_run = true;\n                 }\n                 x if allow_error_code_check && x.starts_with(\"E\") && x.len() == 5 => {\n-                    if let Ok(_) = x[1..].parse::<u32>() {\n+                    if x[1..].parse::<u32>().is_ok() {\n                         data.error_codes.push(x.to_owned());\n                         seen_rust_tags = !seen_other_tags || seen_rust_tags;\n                     } else {"}, {"sha": "07507047dc2c95c76039fcfe245a33a20cce7938", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -2208,6 +2208,25 @@\n     };\n \n     autoCollapse(getPageId(), getCurrentValue(\"rustdoc-collapse\") === \"true\");\n+\n+    if (window.location.hash && window.location.hash.length > 0) {\n+        var hash = getPageId();\n+        if (hash !== null) {\n+            var elem = document.getElementById(hash);\n+            if (elem && elem.offsetParent === null) {\n+                console.log(elem, elem.parentNode);\n+                if (elem.parentNode && elem.parentNode.previousSibling) {\n+                    var collapses = elem.parentNode\n+                                        .previousSibling\n+                                        .getElementsByClassName(\"collapse-toggle\");\n+                    if (collapses.length > 0) {\n+                        // The element is not visible, we need to make it appear!\n+                        collapseDocs(collapses[0], \"show\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n }());\n \n // Sets the focus on the search bar at the top of the page"}, {"sha": "4b8dda493b0979be056b3bb0ef3ab897b367f6b8", "filename": "src/libstd/os/raw/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw%2Fmod.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -29,6 +29,8 @@ use fmt;\n           all(target_os = \"android\", any(target_arch = \"aarch64\",\n                                          target_arch = \"arm\")),\n           all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+          all(target_os = \"netbsd\", any(target_arch = \"arm\",\n+                                        target_arch = \"powerpc\")),\n           all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n@@ -41,6 +43,8 @@ use fmt;\n               all(target_os = \"android\", any(target_arch = \"aarch64\",\n                                              target_arch = \"arm\")),\n               all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+              all(target_os = \"netbsd\", any(target_arch = \"arm\",\n+                                            target_arch = \"powerpc\")),\n               all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n               all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;"}, {"sha": "f51d079a6c058fca39408024557156c80a6634b0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -181,7 +181,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n         for lhs in lhses { // try each arm's matchers\n             let lhs_tt = match *lhs {\n                 quoted::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n-                _ => cx.span_bug(sp, \"malformed macro lhs\")\n+                _ => continue,\n             };\n             match TokenTree::parse(cx, lhs_tt, arg.clone()) {\n                 Success(_) => {\n@@ -191,7 +191,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                         err.span_suggestion_short(\n                             comma_span,\n                             \"missing comma here\",\n-                            \",\".to_string(),\n+                            \", \".to_string(),\n                         );\n                     }\n                 }"}, {"sha": "976708ae788161e97b4de6e18f81d9596b2ffbbf", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -452,6 +452,7 @@ declare_features! (\n     (active, mmx_target_feature, \"1.27.0\", Some(44839), None),\n     (active, sse4a_target_feature, \"1.27.0\", Some(44839), None),\n     (active, tbm_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, wasm_target_feature, \"1.30.0\", Some(44839), None),\n \n     // Allows macro invocations of the form `#[foo::bar]`\n     (active, proc_macro_path_invoc, \"1.27.0\", Some(38356), None),"}, {"sha": "62dd00387d3abbef747cef214d35793e5b1a52f4", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -631,7 +631,7 @@ fn path_name_i(idents: &[Ident]) -> String {\n     let mut idents_iter = idents.iter().peekable();\n     while let Some(ident) = idents_iter.next() {\n         path_name.push_str(&ident.as_str());\n-        if let Some(_) = idents_iter.peek() {\n+        if idents_iter.peek().is_some() {\n             path_name.push_str(\"::\")\n         }\n     }"}, {"sha": "fda975e6c456bdd16dbad09bba0d029c4e8f27cb", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -186,21 +186,43 @@ impl TokenStream {\n     /// Given a `TokenStream` with a `Stream` of only two arguments, return a new `TokenStream`\n     /// separating the two arguments with a comma for diagnostic suggestions.\n     pub(crate) fn add_comma(&self) -> Option<(TokenStream, Span)> {\n-        // Used to suggest if a user writes `println!(\"{}\" a);`\n+        // Used to suggest if a user writes `foo!(a b);`\n         if let TokenStreamKind::Stream(ref slice) = self.kind {\n-            if slice.len() == 2 {\n-                let comma_span = match slice[0] {\n-                    TokenStream { kind: TokenStreamKind::Tree(TokenTree::Token(sp, _)) } |\n-                    TokenStream { kind: TokenStreamKind::Tree(TokenTree::Delimited(sp, _)) } => {\n-                        sp.shrink_to_hi()\n+            let mut suggestion = None;\n+            let mut iter = slice.iter().enumerate().peekable();\n+            while let Some((pos, ts)) = iter.next() {\n+                if let Some((_, next)) = iter.peek() {\n+                    match (ts, next) {\n+                        (TokenStream {\n+                            kind: TokenStreamKind::Tree(TokenTree::Token(_, token::Token::Comma))\n+                        }, _) |\n+                        (_, TokenStream {\n+                            kind: TokenStreamKind::Tree(TokenTree::Token(_, token::Token::Comma))\n+                        }) => {}\n+                        (TokenStream {\n+                            kind: TokenStreamKind::Tree(TokenTree::Token(sp, _))\n+                        }, _) |\n+                        (TokenStream {\n+                            kind: TokenStreamKind::Tree(TokenTree::Delimited(sp, _))\n+                        }, _) => {\n+                            let sp = sp.shrink_to_hi();\n+                            let comma = TokenStream {\n+                                kind: TokenStreamKind::Tree(TokenTree::Token(sp, token::Comma)),\n+                            };\n+                            suggestion = Some((pos, comma, sp));\n+                        }\n+                        _ => {}\n                     }\n-                    _ => DUMMY_SP,\n-                };\n-                let comma = TokenStream {\n-                    kind: TokenStreamKind::Tree(TokenTree::Token(comma_span, token::Comma)),\n-                };\n-                let slice = RcSlice::new(vec![slice[0].clone(), comma, slice[1].clone()]);\n-                return Some((TokenStream { kind: TokenStreamKind::Stream(slice) }, comma_span));\n+                }\n+            }\n+            if let Some((pos, comma, sp)) = suggestion {\n+                let mut new_slice = vec![];\n+                let parts = slice.split_at(pos + 1);\n+                new_slice.extend_from_slice(parts.0);\n+                new_slice.push(comma);\n+                new_slice.extend_from_slice(parts.1);\n+                let slice = RcSlice::new(new_slice);\n+                return Some((TokenStream { kind: TokenStreamKind::Stream(slice) }, sp));\n             }\n         }\n         None"}, {"sha": "8f26b2402aadfce024d8e2067767414d47a5dbd7", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -81,7 +81,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n         }\n     };\n \n-    if let Some(_) = exprs.next() {\n+    if exprs.next().is_some() {\n         cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n         return DummyResult::expr(sp);\n     }"}, {"sha": "61f52194aad3e4a4e239362e37d6eae16322d540", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 70, "deletions": 61, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -14,8 +14,7 @@ use self::Position::*;\n use fmt_macros as parse;\n \n use syntax::ast;\n-use syntax::ext::base;\n-use syntax::ext::base::*;\n+use syntax::ext::base::{self, *};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::parse::token;\n@@ -24,6 +23,7 @@ use syntax::symbol::Symbol;\n use syntax::tokenstream;\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n+use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::collections::{HashMap, HashSet};\n \n@@ -143,8 +143,10 @@ fn parse_args(ecx: &mut ExtCtxt,\n         ecx.span_err(sp, \"requires at least a format string argument\");\n         return None;\n     }\n+\n     let fmtstr = panictry!(p.parse_expr());\n     let mut named = false;\n+\n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n             ecx.span_err(p.span, \"expected token: `,`\");\n@@ -264,11 +266,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn describe_num_args(&self) -> String {\n+    fn describe_num_args(&self) -> Cow<str> {\n         match self.args.len() {\n-            0 => \"no arguments were given\".to_string(),\n-            1 => \"there is 1 argument\".to_string(),\n-            x => format!(\"there are {} arguments\", x),\n+            0 => \"no arguments were given\".into(),\n+            1 => \"there is 1 argument\".into(),\n+            x => format!(\"there are {} arguments\", x).into(),\n         }\n     }\n \n@@ -772,8 +774,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     // `ArgumentType` does not derive `Clone`.\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n+\n     let mut macsp = ecx.call_site();\n     macsp = macsp.apply_mark(ecx.current_expansion.mark);\n+\n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;\n     let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n@@ -796,11 +800,46 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             return DummyResult::raw_expr(sp);\n         }\n     };\n+\n     let is_literal = match ecx.codemap().span_to_snippet(fmt_sp) {\n         Ok(ref s) if s.starts_with(\"\\\"\") || s.starts_with(\"r#\") => true,\n         _ => false,\n     };\n \n+    let fmt_str = &*fmt.node.0.as_str();\n+    let str_style = match fmt.node.1 {\n+        ast::StrStyle::Cooked => None,\n+        ast::StrStyle::Raw(raw) => Some(raw as usize),\n+    };\n+\n+    let mut parser = parse::Parser::new(fmt_str, str_style);\n+\n+    let mut unverified_pieces = Vec::new();\n+    while let Some(piece) = parser.next() {\n+        if !parser.errors.is_empty() {\n+            break;\n+        } else {\n+            unverified_pieces.push(piece);\n+        }\n+    }\n+\n+    if !parser.errors.is_empty() {\n+        let err = parser.errors.remove(0);\n+        let sp = fmt.span.from_inner_byte_pos(err.start, err.end);\n+        let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n+                                                        err.description));\n+        e.span_label(sp, err.label + \" in format string\");\n+        if let Some(note) = err.note {\n+            e.note(&note);\n+        }\n+        e.emit();\n+        return DummyResult::raw_expr(sp);\n+    }\n+\n+    let arg_spans = parser.arg_places.iter()\n+        .map(|&(start, end)| fmt.span.from_inner_byte_pos(start, end))\n+        .collect();\n+\n     let mut cx = Context {\n         ecx,\n         args,\n@@ -815,42 +854,22 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         count_positions_count: 0,\n         count_args_index_offset: 0,\n         literal: String::new(),\n-        pieces: Vec::new(),\n-        str_pieces: Vec::new(),\n+        pieces: Vec::with_capacity(unverified_pieces.len()),\n+        str_pieces: Vec::with_capacity(unverified_pieces.len()),\n         all_pieces_simple: true,\n         macsp,\n         fmtsp: fmt.span,\n         invalid_refs: Vec::new(),\n-        arg_spans: Vec::new(),\n+        arg_spans,\n         is_literal,\n     };\n \n-    let fmt_str = &*fmt.node.0.as_str();\n-    let str_style = match fmt.node.1 {\n-        ast::StrStyle::Cooked => None,\n-        ast::StrStyle::Raw(raw) => Some(raw as usize),\n-    };\n-    let mut parser = parse::Parser::new(fmt_str, str_style);\n-    let mut unverified_pieces = vec![];\n-    let mut pieces = vec![];\n-\n-    while let Some(piece) = parser.next() {\n-        if !parser.errors.is_empty() {\n-            break;\n-        }\n-        unverified_pieces.push(piece);\n-    }\n-\n-    cx.arg_spans = parser.arg_places.iter()\n-        .map(|&(start, end)| fmt.span.from_inner_byte_pos(start, end))\n-        .collect();\n-\n     // This needs to happen *after* the Parser has consumed all pieces to create all the spans\n-    for mut piece in unverified_pieces {\n+    let pieces = unverified_pieces.into_iter().map(|mut piece| {\n         cx.verify_piece(&piece);\n         cx.resolve_name_inplace(&mut piece);\n-        pieces.push(piece);\n-    }\n+        piece\n+    }).collect::<Vec<_>>();\n \n     let numbered_position_args = pieces.iter().any(|arg: &parse::Piece| {\n         match *arg {\n@@ -867,6 +886,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     cx.build_index_map();\n \n     let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n+\n     for piece in pieces {\n         if let Some(piece) = cx.build_piece(&piece, &mut arg_index_consumed) {\n             let s = cx.build_literal_string();\n@@ -875,18 +895,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         }\n     }\n \n-    if !parser.errors.is_empty() {\n-        let err = parser.errors.remove(0);\n-        let sp = cx.fmtsp.from_inner_byte_pos(err.start, err.end);\n-        let mut e = cx.ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n-                                                        err.description));\n-        e.span_label(sp, err.label + \" in format string\");\n-        if let Some(note) = err.note {\n-            e.note(&note);\n-        }\n-        e.emit();\n-        return DummyResult::raw_expr(sp);\n-    }\n     if !cx.literal.is_empty() {\n         let s = cx.build_literal_string();\n         cx.str_pieces.push(s);\n@@ -898,24 +906,25 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n \n     // Make sure that all arguments were used and all arguments have types.\n     let num_pos_args = cx.args.len() - cx.names.len();\n-    let mut errs = vec![];\n-    for (i, ty) in cx.arg_types.iter().enumerate() {\n-        if ty.len() == 0 {\n-            if cx.count_positions.contains_key(&i) {\n-                continue;\n-            }\n-            let msg = if i >= num_pos_args {\n-                // named argument\n-                \"named argument never used\"\n-            } else {\n-                // positional argument\n-                \"argument never used\"\n-            };\n-            errs.push((cx.args[i].span, msg));\n-        }\n-    }\n+\n+    let errs = cx.arg_types\n+                 .iter()\n+                 .enumerate()\n+                 .filter(|(i, ty)| ty.is_empty() && !cx.count_positions.contains_key(&i))\n+                 .map(|(i, _)| {\n+                    let msg = if i >= num_pos_args {\n+                        // named argument\n+                        \"named argument never used\"\n+                    } else {\n+                        // positional argument\n+                        \"argument never used\"\n+                    };\n+                    (cx.args[i].span, msg)\n+                 })\n+                 .collect::<Vec<_>>();\n+\n     let errs_len = errs.len();\n-    if errs_len > 0 {\n+    if !errs.is_empty() {\n         let args_used = cx.arg_types.len() - errs_len;\n         let args_unused = errs_len;\n "}, {"sha": "98d7d77308f89e78ce6204e777a8c1d232d78f12", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -21,6 +21,7 @@\n #![feature(const_fn)]\n #![feature(crate_visibility_modifier)]\n #![feature(custom_attribute)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n #![feature(specialization)]"}, {"sha": "a49fd67639dbe5210fe1118a2f1e672f8958f7b5", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -50,6 +50,7 @@\n #![cfg_attr(windows, feature(libc))]\n // Handle rustfmt skips\n #![feature(custom_attribute)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![allow(unused_attributes)]\n \n use std::io::prelude::*;"}, {"sha": "424a7e3d009ecaa6c930c200c7819552b7609e89", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -13,6 +13,7 @@\n \n #![feature(cfg_target_vendor)]\n #![feature(link_cfg)]\n+#![cfg_attr(not(stage0), feature(nll))]\n #![feature(staged_api)]\n #![feature(unwind_attributes)]\n #![feature(static_nobundle)]"}, {"sha": "83d23bcba0493fcad4c3b7b3b8a265b56741176c", "filename": "src/test/ui/const-unsized.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fconst-unsized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fconst-unsized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-unsized.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL | const CONST_0: Debug+Sync = *(&0 as &(Debug+Sync));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::fmt::Debug + std::marker::Sync + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: constant expressions must have a statically known size\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n@@ -15,7 +15,7 @@ LL | const CONST_FOO: str = *\"foo\";\n    |                        ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: constant expressions must have a statically known size\n \n error[E0277]: the size for values of type `(dyn std::fmt::Debug + std::marker::Sync + 'static)` cannot be known at compilation time\n@@ -25,7 +25,7 @@ LL | static STATIC_1: Debug+Sync = *(&1 as &(Debug+Sync));\n    |                               ^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::fmt::Debug + std::marker::Sync + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: constant expressions must have a statically known size\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n@@ -35,7 +35,7 @@ LL | static STATIC_BAR: str = *\"bar\";\n    |                          ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: constant expressions must have a statically known size\n \n error: aborting due to 4 previous errors"}, {"sha": "e4c2f1022679972c4f7fd2e2bafbe3bf12beed75", "filename": "src/test/ui/error-codes/E0277.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL | fn f(p: Path) { }\n    |      ^ doesn't have a size known at compile-time\n    |\n    = help: within `std::path::Path`, the trait `std::marker::Sized` is not implemented for `[u8]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `std::path::Path`\n    = note: all local variables must have a statically known size\n "}, {"sha": "f20c1ebb37aa9e9db60dbd40dea61e0b3e7a91e3", "filename": "src/test/ui/feature-gate-trivial_bounds.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ffeature-gate-trivial_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ffeature-gate-trivial_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-trivial_bounds.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -94,7 +94,7 @@ LL | struct TwoStrs(str, str) where str: Sized; //~ ERROR\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: see issue #48214\n    = help: add #![feature(trivial_bounds)] to the crate attributes to enable\n \n@@ -107,7 +107,7 @@ LL | | }\n    | |_^ doesn't have a size known at compile-time\n    |\n    = help: within `Dst<(dyn A + 'static)>`, the trait `std::marker::Sized` is not implemented for `(dyn A + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Dst<(dyn A + 'static)>`\n    = help: see issue #48214\n    = help: add #![feature(trivial_bounds)] to the crate attributes to enable\n@@ -121,7 +121,7 @@ LL | | }\n    | |_^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: see issue #48214\n    = help: add #![feature(trivial_bounds)] to the crate attributes to enable\n "}, {"sha": "d91db6763ab2490f09b5e8618be796dc425c7822", "filename": "src/test/ui/generator/sized-yield.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -9,7 +9,7 @@ LL | |    };\n    | |____^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: the yield type of a generator must have a statically known size\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n@@ -19,7 +19,7 @@ LL |    unsafe { gen.resume(); }\n    |                 ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3c3ecd23bef6eb43c2f8f55676bfd65ac26fd5c7", "filename": "src/test/ui/issue-14366.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-14366.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-14366.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-14366.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     let _x = \"test\" as &::std::any::Any;\n    |              ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required for the cast to the object type `dyn std::any::Any`\n \n error: aborting due to previous error"}, {"sha": "e142a504eb638071d1410d7edc777918f3b3d441", "filename": "src/test/ui/issue-15756.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-15756.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-15756.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-15756.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     &mut something\n    |          ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[T]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n \n error: aborting due to previous error"}, {"sha": "3e5679bdc3b3f2ecec8b7dc1ffe8df3fc74e5254", "filename": "src/test/ui/issue-17651.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-17651.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-17651.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-17651.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     (|| Box::new(*(&[0][..])))();\n    |         ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[{integer}]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required by `<std::boxed::Box<T>>::new`\n \n error: aborting due to previous error"}, {"sha": "c813e290b9e6a33646d963c7593c5817b02bf0f9", "filename": "src/test/ui/issue-18107.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-18107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-18107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-18107.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     AbstractRenderer\n    |     ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn AbstractRenderer + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error"}, {"sha": "0e71b0bbedde2961f70c7a45ee4b7d29a3205197", "filename": "src/test/ui/issue-18919.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-18919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-18919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-18919.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -7,7 +7,7 @@ LL | | }\n    | |_^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `dyn for<'r> std::ops::Fn(&'r isize) -> isize`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required by `std::option::Option`\n \n error: aborting due to previous error"}, {"sha": "b0b38c9746231365d2e2d5e9591236892fe2d584", "filename": "src/test/ui/issue-20005.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-20005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-20005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-20005.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -9,7 +9,7 @@ LL | |     }\n    | |_____^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Self`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where Self: std::marker::Sized` bound\n note: required by `From`\n   --> $DIR/issue-20005.rs:11:1"}, {"sha": "9800c9b3b58e1ee005d07be295caddfe6a656567", "filename": "src/test/ui/issue-20433.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-20433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-20433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-20433.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     fn iceman(c: Vec<[i32]>) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[i32]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required by `std::vec::Vec`\n \n error: aborting due to previous error"}, {"sha": "fb32283ddf7b929672e4c1680bce0a1112733eb3", "filename": "src/test/ui/issue-20605.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-20605.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-20605.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-20605.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     for item in *things { *item = 0 }\n    |                 ^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `dyn std::iter::Iterator<Item=&mut u8>`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required by `std::iter::IntoIterator::into_iter`\n \n error: aborting due to previous error"}, {"sha": "a69ee7c9ff01b2119e8e66f7857bebb1f6d5b192", "filename": "src/test/ui/issue-22874.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-22874.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-22874.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-22874.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     rows: [[String]],\n    |     ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[std::string::String]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: slice and array elements must have `Sized` type\n \n error: aborting due to previous error"}, {"sha": "78db19d6b06ff710835a75f954a118809aabc2d2", "filename": "src/test/ui/issue-23281.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-23281.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-23281.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23281.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     pub fn function(funs: Vec<Fn() -> ()>) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn() + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required by `std::vec::Vec`\n \n error: aborting due to previous error"}, {"sha": "3c42462743700a017e490b0ad02db4054b242def", "filename": "src/test/ui/issue-24446.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-24446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-24446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-24446.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -24,7 +24,7 @@ LL | |     };\n    | |_____^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn() -> u32 + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: constant expressions must have a statically known size\n \n error: aborting due to 2 previous errors"}, {"sha": "ed9db2ea55ed93f809d92ad75e9e64000f8c8dba", "filename": "src/test/ui/issue-27060-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-27060-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-27060-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27060-2.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     data: T, //~ ERROR the size for values of type\n    |     ^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where T: std::marker::Sized` bound\n    = note: only the last field of a struct may have a dynamically sized type\n "}, {"sha": "65b66997ee829c5cb35ce021a5e0ba52af337b95", "filename": "src/test/ui/issue-27078.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-27078.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-27078.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27078.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     fn foo(self) -> &'static i32 {\n    |            ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Self`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where Self: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n "}, {"sha": "0b9d84692479880acee78ce18aded650e755e796", "filename": "src/test/ui/issue-35988.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-35988.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-35988.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35988.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     V([Box<E>]),\n    |       ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[std::boxed::Box<E>]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error: aborting due to previous error"}, {"sha": "2f0e579378ffc1431a1f93a8cd26fcc31e503bb4", "filename": "src/test/ui/issue-38954.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-38954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-38954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38954.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL | fn _test(ref _p: str) {}\n    |                       ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n \n error: aborting due to previous error\n "}, {"sha": "effc5f6999e3642f9e26d96a02f01e8f919b5bf5", "filename": "src/test/ui/issue-41229-ref-str.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-41229-ref-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-41229-ref-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-41229-ref-str.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL | pub fn example(ref s: str) {}\n    |                            ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n \n error: aborting due to previous error\n "}, {"sha": "8c2a0987f2f3fdd2f8a3641785ee74fbbb9c2441", "filename": "src/test/ui/issue-42312.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-42312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-42312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-42312.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     fn baz(_: Self::Target) where Self: Deref {}\n    |                             ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `<Self as std::ops::Deref>::Target`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where <Self as std::ops::Deref>::Target: std::marker::Sized` bound\n \n error[E0277]: the size for values of type `(dyn std::string::ToString + 'static)` cannot be known at compilation time\n@@ -15,7 +15,7 @@ LL | pub fn f(_: ToString) {}\n    |                       ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::string::ToString + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6a321abeaed9c209e5330cde4dffa82d3d773220", "filename": "src/test/ui/issue-5883.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-5883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fissue-5883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-5883.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL | fn new_struct(r: A+'static)\n    |               ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn A + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n \n error[E0277]: the size for values of type `(dyn A + 'static)` cannot be known at compilation time\n@@ -15,7 +15,7 @@ LL |     -> Struct { //~^ ERROR the size for values of type\n    |        ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `Struct`, the trait `std::marker::Sized` is not implemented for `(dyn A + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Struct`\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "07e69b9619d1f9683c8d6aa2ba2281e795767c1e", "filename": "src/test/ui/macros/missing-comma.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -9,12 +9,22 @@\n // except according to those terms.\n \n macro_rules! foo {\n-    ($a:ident, $b:ident) => ()\n+    ($a:ident) => ();\n+    ($a:ident, $b:ident) => ();\n+    ($a:ident, $b:ident, $c:ident) => ();\n+    ($a:ident, $b:ident, $c:ident, $d:ident) => ();\n+    ($a:ident, $b:ident, $c:ident, $d:ident, $e:ident) => ();\n }\n \n fn main() {\n     println!(\"{}\" a);\n     //~^ ERROR expected token: `,`\n     foo!(a b);\n     //~^ ERROR no rules expected the token `b`\n+    foo!(a, b, c, d e);\n+    //~^ ERROR no rules expected the token `e`\n+    foo!(a, b, c d, e);\n+    //~^ ERROR no rules expected the token `d`\n+    foo!(a, b, c d e);\n+    //~^ ERROR no rules expected the token `d`\n }"}, {"sha": "9d8de87e5bb7f154237d97be5c51e0bf5d91c7ca", "filename": "src/test/ui/macros/missing-comma.stderr", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -1,16 +1,38 @@\n error: expected token: `,`\n-  --> $DIR/missing-comma.rs:16:19\n+  --> $DIR/missing-comma.rs:20:19\n    |\n LL |     println!(\"{}\" a);\n    |                   ^\n \n error: no rules expected the token `b`\n-  --> $DIR/missing-comma.rs:18:12\n+  --> $DIR/missing-comma.rs:22:12\n    |\n LL |     foo!(a b);\n    |           -^\n    |           |\n    |           help: missing comma here\n \n-error: aborting due to 2 previous errors\n+error: no rules expected the token `e`\n+  --> $DIR/missing-comma.rs:24:21\n+   |\n+LL |     foo!(a, b, c, d e);\n+   |                    -^\n+   |                    |\n+   |                    help: missing comma here\n+\n+error: no rules expected the token `d`\n+  --> $DIR/missing-comma.rs:26:18\n+   |\n+LL |     foo!(a, b, c d, e);\n+   |                 -^\n+   |                 |\n+   |                 help: missing comma here\n+\n+error: no rules expected the token `d`\n+  --> $DIR/missing-comma.rs:28:18\n+   |\n+LL |     foo!(a, b, c d e);\n+   |                  ^\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "81fe49328116dba7ebd5a4e982526abcf4c619dc", "filename": "src/test/ui/mismatched_types/cast-rfc0401.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -223,7 +223,7 @@ LL |     let _ = fat_v as *const Foo; //~ ERROR the size for values of type\n    |             ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required for the cast to the object type `dyn Foo`\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n@@ -233,7 +233,7 @@ LL |     let _ = a as *const Foo; //~ ERROR the size for values of type\n    |             ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required for the cast to the object type `dyn Foo`\n \n error[E0606]: casting `&{float}` as `f32` is invalid"}, {"sha": "10d7a52297f555b1d833f4fc33e09da2d5765ae5", "filename": "src/test/ui/resolve/issue-5035-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL | fn foo(_x: K) {}\n    |        ^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn I + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n \n error: aborting due to previous error"}, {"sha": "59521bd2e2fab8dc65b46c2525d3bc9898528cef", "filename": "src/test/ui/str-array-assignment.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fstr-array-assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Fstr-array-assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr-array-assignment.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -28,7 +28,7 @@ LL |   let v = s[..2];\n    |       doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n \n error[E0308]: mismatched types"}, {"sha": "8a045884cae315b495c2494ef7cd1bab06051f0f", "filename": "src/test/ui/target-feature-gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.rs?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -23,6 +23,7 @@\n // gate-test-hexagon_target_feature\n // gate-test-mips_target_feature\n // gate-test-mmx_target_feature\n+// gate-test-wasm_target_feature\n // min-llvm-version 6.0\n \n #[target_feature(enable = \"avx512bw\")]"}, {"sha": "f18bebc0c290dada8e67fd4444c6c4690c92373f", "filename": "src/test/ui/target-feature-gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: the target feature `avx512bw` is currently unstable (see issue #44839)\n-  --> $DIR/target-feature-gate.rs:28:18\n+  --> $DIR/target-feature-gate.rs:29:18\n    |\n LL | #[target_feature(enable = \"avx512bw\")]\n    |                  ^^^^^^^^^^^^^^^^^^^"}, {"sha": "3b33596086711cc45f8c771515aeb68ec263a126", "filename": "src/test/ui/trait-suggest-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ftrait-suggest-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ftrait-suggest-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-suggest-where-clause.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     mem::size_of::<U>();\n    |     ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `U`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where U: std::marker::Sized` bound\n    = note: required by `std::mem::size_of`\n \n@@ -16,7 +16,7 @@ LL |     mem::size_of::<Misc<U>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `Misc<U>`, the trait `std::marker::Sized` is not implemented for `U`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where U: std::marker::Sized` bound\n    = note: required because it appears within the type `Misc<U>`\n    = note: required by `std::mem::size_of`\n@@ -54,7 +54,7 @@ LL |     mem::size_of::<[T]>();\n    |     ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[T]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required by `std::mem::size_of`\n \n error[E0277]: the size for values of type `[&U]` cannot be known at compilation time\n@@ -64,7 +64,7 @@ LL |     mem::size_of::<[&U]>();\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[&U]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required by `std::mem::size_of`\n \n error: aborting due to 7 previous errors"}, {"sha": "984e492281fc5364194d7f2e1a4f7f27a2cfc71b", "filename": "src/test/ui/trivial-bounds-leak.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ftrivial-bounds-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Ftrivial-bounds-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds-leak.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL | fn cant_return_str() -> str { //~ ERROR\n    |                         ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: the return type of a function must have a statically known size\n \n error[E0599]: no method named `test` found for type `i32` in the current scope"}, {"sha": "85e9702a40ebfcce0fb379ef724501548ffd0806", "filename": "src/test/ui/union/union-sized-field.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     value: T,\n    |     ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where T: std::marker::Sized` bound\n    = note: no field of a union may have a dynamically sized type\n \n@@ -16,7 +16,7 @@ LL |     value: T,\n    |     ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where T: std::marker::Sized` bound\n    = note: only the last field of a struct may have a dynamically sized type\n \n@@ -27,7 +27,7 @@ LL |     Value(T),\n    |           ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where T: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n "}, {"sha": "ecaa01464690c38a3ea0bfe90f5d952f86ef905e", "filename": "src/test/ui/unsized-enum2.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Funsized-enum2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8958ed672298148841b3b8d6371ce301e1cbbac1/src%2Ftest%2Fui%2Funsized-enum2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-enum2.stderr?ref=8958ed672298148841b3b8d6371ce301e1cbbac1", "patch": "@@ -5,7 +5,7 @@ LL |     VA(W),\n    |        ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `W`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where W: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n@@ -16,7 +16,7 @@ LL |     VB{x: X},\n    |        ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n@@ -27,7 +27,7 @@ LL |     VC(isize, Y),\n    |               ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Y`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where Y: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n@@ -38,7 +38,7 @@ LL |     VD{u: isize, x: Z},\n    |                  ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Z`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where Z: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n@@ -49,7 +49,7 @@ LL |     VE([u8]),\n    |        ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n@@ -59,7 +59,7 @@ LL |     VF{x: str},\n    |        ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `[f32]` cannot be known at compilation time\n@@ -69,7 +69,7 @@ LL |     VG(isize, [f32]),\n    |               ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[f32]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `[u32]` cannot be known at compilation time\n@@ -79,7 +79,7 @@ LL |     VH{u: isize, x: [u32]},\n    |                  ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[u32]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `(dyn Foo + 'static)` cannot be known at compilation time\n@@ -89,7 +89,7 @@ LL |     VM(Foo),\n    |        ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn Foo + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `(dyn Bar + 'static)` cannot be known at compilation time\n@@ -99,7 +99,7 @@ LL |     VN{x: Bar},\n    |        ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn Bar + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `(dyn FooBar + 'static)` cannot be known at compilation time\n@@ -109,7 +109,7 @@ LL |     VO(isize, FooBar),\n    |               ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn FooBar + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `(dyn BarFoo + 'static)` cannot be known at compilation time\n@@ -119,7 +119,7 @@ LL |     VP{u: isize, x: BarFoo},\n    |                  ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn BarFoo + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `[i8]` cannot be known at compilation time\n@@ -129,7 +129,7 @@ LL |     VQ(<&'static [i8] as Deref>::Target),\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[i8]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `[char]` cannot be known at compilation time\n@@ -139,7 +139,7 @@ LL |     VR{x: <&'static [char] as Deref>::Target},\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[char]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `[f64]` cannot be known at compilation time\n@@ -149,7 +149,7 @@ LL |     VS(isize, <&'static [f64] as Deref>::Target),\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[f64]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `[i32]` cannot be known at compilation time\n@@ -159,7 +159,7 @@ LL |     VT{u: isize, x: <&'static [i32] as Deref>::Target},\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[i32]`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `(dyn PathHelper1 + 'static)` cannot be known at compilation time\n@@ -169,7 +169,7 @@ LL |     VI(Path1),\n    |        ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `Path1`, the trait `std::marker::Sized` is not implemented for `(dyn PathHelper1 + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Path1`\n    = note: no field of an enum variant may have a dynamically sized type\n \n@@ -180,7 +180,7 @@ LL |     VJ{x: Path2},\n    |        ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `Path2`, the trait `std::marker::Sized` is not implemented for `(dyn PathHelper2 + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Path2`\n    = note: no field of an enum variant may have a dynamically sized type\n \n@@ -191,7 +191,7 @@ LL |     VK(isize, Path3),\n    |               ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `Path3`, the trait `std::marker::Sized` is not implemented for `(dyn PathHelper3 + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Path3`\n    = note: no field of an enum variant may have a dynamically sized type\n \n@@ -202,7 +202,7 @@ LL |     VL{u: isize, x: Path4},\n    |                  ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `Path4`, the trait `std::marker::Sized` is not implemented for `(dyn PathHelper4 + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-sized>\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `Path4`\n    = note: no field of an enum variant may have a dynamically sized type\n "}]}