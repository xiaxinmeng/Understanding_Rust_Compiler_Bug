{"sha": "89aa04299451baf73750c8480d14471dfced44db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YWEwNDI5OTQ1MWJhZjczNzUwYzg0ODBkMTQ0NzFkZmNlZDQ0ZGI=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2016-05-03T17:15:59Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2016-05-06T06:19:31Z"}, "message": "rustdoc: add \"src\" links to individual impls\n\nSince these impls can be scattered around quite a bit, it is nice\nto be able to jump to the location where individual methods and\ntrait impls are defined.\n\nFixes: #30416", "tree": {"sha": "de7a1434908e4dd6f92e93aa46cf9e8912215188", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de7a1434908e4dd6f92e93aa46cf9e8912215188"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89aa04299451baf73750c8480d14471dfced44db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89aa04299451baf73750c8480d14471dfced44db", "html_url": "https://github.com/rust-lang/rust/commit/89aa04299451baf73750c8480d14471dfced44db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89aa04299451baf73750c8480d14471dfced44db/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3157691f963a86776cb7e6a7842f566032890aba", "url": "https://api.github.com/repos/rust-lang/rust/commits/3157691f963a86776cb7e6a7842f566032890aba", "html_url": "https://github.com/rust-lang/rust/commit/3157691f963a86776cb7e6a7842f566032890aba"}], "stats": {"total": 98, "additions": 59, "deletions": 39}, "files": [{"sha": "96a9315599f9aa3160a222b7aa7bbd810620c71f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/89aa04299451baf73750c8480d14471dfced44db/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89aa04299451baf73750c8480d14471dfced44db/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=89aa04299451baf73750c8480d14471dfced44db", "patch": "@@ -145,14 +145,19 @@ pub struct Implementor {\n /// Metadata about implementations for a type.\n #[derive(Clone)]\n pub struct Impl {\n-    pub impl_: clean::Impl,\n-    pub dox: Option<String>,\n-    pub stability: Option<clean::Stability>,\n+    pub impl_item: clean::Item,\n }\n \n impl Impl {\n+    fn inner_impl(&self) -> &clean::Impl {\n+        match self.impl_item.inner {\n+            clean::ImplItem(ref impl_) => impl_,\n+            _ => panic!(\"non-impl item found in impl\")\n+        }\n+    }\n+\n     fn trait_did(&self) -> Option<DefId> {\n-        self.impl_.trait_.def_id()\n+        self.inner_impl().trait_.def_id()\n     }\n }\n \n@@ -1189,31 +1194,34 @@ impl DocFolder for Cache {\n         // Once we've recursively found all the generics, then hoard off all the\n         // implementations elsewhere\n         let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { attrs, inner: clean::ImplItem(i), .. } = item {\n+            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n                 // Figure out the id of this impl. This may map to a\n                 // primitive rather than always to a struct/enum.\n-                let did = match i.for_ {\n-                    clean::ResolvedPath { did, .. } |\n-                    clean::BorrowedRef {\n-                        type_: box clean::ResolvedPath { did, .. }, ..\n-                    } => {\n-                        Some(did)\n-                    }\n-                    ref t => {\n-                        t.primitive_type().and_then(|t| {\n-                            self.primitive_locations.get(&t).map(|n| {\n-                                let id = t.to_def_index();\n-                                DefId { krate: *n, index: id }\n+                // Note: matching twice to restrict the lifetime of the `i` borrow.\n+                let did = if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. } |\n+                        clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            Some(did)\n+                        }\n+                        ref t => {\n+                            t.primitive_type().and_then(|t| {\n+                                self.primitive_locations.get(&t).map(|n| {\n+                                    let id = t.to_def_index();\n+                                    DefId { krate: *n, index: id }\n+                                })\n                             })\n-                        })\n+                        }\n                     }\n+                } else {\n+                    unreachable!()\n                 };\n                 if !self.seen_mod {\n                     if let Some(did) = did {\n                         self.impls.entry(did).or_insert(vec![]).push(Impl {\n-                            impl_: i,\n-                            dox: attrs.value(\"doc\").map(|s|s.to_owned()),\n-                            stability: item.stability.clone(),\n+                            impl_item: item,\n                         });\n                     }\n                 }\n@@ -1510,11 +1518,15 @@ impl<'a> Item<'a> {\n         // located, then we return `None`.\n         } else {\n             let cache = cache();\n-            let path = &cache.external_paths[&self.item.def_id];\n-            let root = match cache.extern_locations[&self.item.def_id.krate] {\n-                (_, Remote(ref s)) => s.to_string(),\n-                (_, Local) => self.cx.root_path.clone(),\n-                (_, Unknown) => return None,\n+            let path = match cache.external_paths.get(&self.item.def_id) {\n+                Some(path) => path,\n+                None => return None,\n+            };\n+            let root = match cache.extern_locations.get(&self.item.def_id.krate) {\n+                Some(&(_, Remote(ref s))) => s.to_string(),\n+                Some(&(_, Local)) => self.cx.root_path.clone(),\n+                Some(&(_, Unknown)) => return None,\n+                None => return None,\n             };\n             Some(format!(\"{root}{path}/{file}?gotosrc={goto}\",\n                          root = root,\n@@ -2449,7 +2461,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         None => return Ok(()),\n     };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| {\n-        i.impl_.trait_.is_none()\n+        i.inner_impl().trait_.is_none()\n     });\n     if !non_trait.is_empty() {\n         let render_header = match what {\n@@ -2473,19 +2485,19 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n     }\n     if !traits.is_empty() {\n         let deref_impl = traits.iter().find(|t| {\n-            t.impl_.trait_.def_id() == c.deref_trait_did\n+            t.inner_impl().trait_.def_id() == c.deref_trait_did\n         });\n         if let Some(impl_) = deref_impl {\n             render_deref_methods(w, cx, impl_, containing_item)?;\n         }\n         write!(w, \"<h2 id='implementations'>Trait \\\n                    Implementations</h2>\")?;\n         let (derived, manual): (Vec<_>, Vec<&Impl>) = traits.iter().partition(|i| {\n-            i.impl_.derived\n+            i.inner_impl().derived\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            let assoc_link = AssocItemLink::GotoSource(did, &i.impl_.provided_trait_methods);\n+            let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n             render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n         }\n         if !derived.is_empty() {\n@@ -2494,7 +2506,8 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n                        </h3>\")?;\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                let assoc_link = AssocItemLink::GotoSource(did, &i.impl_.provided_trait_methods);\n+                let assoc_link = AssocItemLink::GotoSource(did,\n+                                                           &i.inner_impl().provided_trait_methods);\n                 render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n             }\n         }\n@@ -2504,8 +2517,8 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n \n fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n                         container_item: &clean::Item) -> fmt::Result {\n-    let deref_type = impl_.impl_.trait_.as_ref().unwrap();\n-    let target = impl_.impl_.items.iter().filter_map(|item| {\n+    let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n+    let target = impl_.inner_impl().items.iter().filter_map(|item| {\n         match item.inner {\n             clean::TypedefItem(ref t, true) => Some(&t.type_),\n             _ => None,\n@@ -2531,11 +2544,18 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n                render_header: bool, outer_version: Option<&str>) -> fmt::Result {\n     if render_header {\n-        write!(w, \"<h3 class='impl'><code>{}</code>\", i.impl_)?;\n-        let since = i.stability.as_ref().map(|s| &s.since[..]);\n+        write!(w, \"<h3 class='impl'><span class='in-band'><code>{}</code>\", i.inner_impl())?;\n+        let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n         render_stability_since_raw(w, since, outer_version)?;\n-        write!(w, \"</h3>\")?;\n-        if let Some(ref dox) = i.dox {\n+        write!(w, \"</span><span class='out-of-band'>\")?;\n+        if let Some(l) = (Item { item: &i.impl_item, cx: cx }).href() {\n+            write!(w, \"<a id='src-{}' class='srclink' \\\n+                       href='{}' title='{}'>[src]</a>\",\n+                   i.impl_item.def_id.index.as_usize(), l, \"goto source code\")?;\n+        }\n+        write!(w, \"</span>\")?;\n+        write!(w, \"</h3>\\n\")?;\n+        if let Some(ref dox) = i.impl_item.attrs.value(\"doc\") {\n             write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n         }\n     }\n@@ -2601,7 +2621,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     }\n \n     write!(w, \"<div class='impl-items'>\")?;\n-    for trait_item in &i.impl_.items {\n+    for trait_item in &i.inner_impl().items {\n         doctraititem(w, cx, trait_item, link, render_header, false, outer_version)?;\n     }\n \n@@ -2629,7 +2649,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     // default items which weren't overridden in the implementation block.\n     if let Some(did) = i.trait_did() {\n         if let Some(t) = cache().traits.get(&did) {\n-            render_default_items(w, cx, t, &i.impl_, render_header, outer_version)?;\n+            render_default_items(w, cx, t, &i.inner_impl(), render_header, outer_version)?;\n         }\n     }\n     write!(w, \"</div>\")?;"}]}