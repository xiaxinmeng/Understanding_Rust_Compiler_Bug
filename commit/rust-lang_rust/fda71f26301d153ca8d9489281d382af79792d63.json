{"sha": "fda71f26301d153ca8d9489281d382af79792d63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYTcxZjI2MzAxZDE1M2NhOGQ5NDg5MjgxZDM4MmFmNzk3OTJkNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-08T12:26:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-08T12:26:36Z"}, "message": "auto merge of #11358 : pcwalton/rust/typed-arenas, r=alexcrichton\n\nA typed arena is a type of arena that can only allocate objects of one\r\ntype. It is 3x faster than the existing arena and 13x faster than malloc\r\non Mac.\r\n\r\nr? @brson", "tree": {"sha": "675e140b4be3c4a65ce272bdcd56cad6f1257630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/675e140b4be3c4a65ce272bdcd56cad6f1257630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fda71f26301d153ca8d9489281d382af79792d63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fda71f26301d153ca8d9489281d382af79792d63", "html_url": "https://github.com/rust-lang/rust/commit/fda71f26301d153ca8d9489281d382af79792d63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fda71f26301d153ca8d9489281d382af79792d63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "html_url": "https://github.com/rust-lang/rust/commit/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea"}, {"sha": "b7ff9c1a599eab76d25c476afc8097aab2a3d502", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ff9c1a599eab76d25c476afc8097aab2a3d502", "html_url": "https://github.com/rust-lang/rust/commit/b7ff9c1a599eab76d25c476afc8097aab2a3d502"}], "stats": {"total": 375, "additions": 331, "deletions": 44}, "files": [{"sha": "d004086322a6c0b682bb872bad22c982e80946a8", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 319, "deletions": 33, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/fda71f26301d153ca8d9489281d382af79792d63/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda71f26301d153ca8d9489281d382af79792d63/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=fda71f26301d153ca8d9489281d382af79792d63", "patch": "@@ -7,34 +7,16 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n-// Dynamic arenas.\n-\n-// Arenas are used to quickly allocate objects that share a\n-// lifetime. The arena uses ~[u8] vectors as a backing store to\n-// allocate objects from. For each allocated object, the arena stores\n-// a pointer to the type descriptor followed by the\n-// object. (Potentially with alignment padding after each of them.)\n-// When the arena is destroyed, it iterates through all of its chunks,\n-// and uses the tydesc information to trace through the objects,\n-// calling the destructors on them.\n-// One subtle point that needs to be addressed is how to handle\n-// failures while running the user provided initializer function. It\n-// is important to not run the destructor on uninitialized objects, but\n-// how to detect them is somewhat subtle. Since alloc() can be invoked\n-// recursively, it is not sufficient to simply exclude the most recent\n-// object. To solve this without requiring extra space, we use the low\n-// order bit of the tydesc pointer to encode whether the object it\n-// describes has been fully initialized.\n-\n-// As an optimization, objects with destructors are stored in\n-// different chunks than objects without destructors. This reduces\n-// overhead when initializing plain-old-data and means we don't need\n-// to waste time running the destructors of POD.\n+//\n+//! The arena, a fast but limited type of allocator.\n+//!\n+//! Arenas are a type of allocator that destroy the objects within, all at\n+//! once, once the arena itself is destroyed. They do not support deallocation\n+//! of individual objects while the arena itself is still alive. The benefit\n+//! of an arena is very fast allocation; just a pointer bump.\n \n #[allow(missing_doc)];\n \n-\n use list::{List, Cons, Nil};\n use list;\n \n@@ -45,9 +27,11 @@ use std::cell::{Cell, RefCell};\n use std::num;\n use std::ptr;\n use std::mem;\n+use std::rt::global_heap;\n use std::uint;\n-use std::unstable::intrinsics;\n use std::unstable::intrinsics::{TyDesc, get_tydesc};\n+use std::unstable::intrinsics;\n+use std::util;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n@@ -59,6 +43,27 @@ struct Chunk {\n     is_pod: Cell<bool>,\n }\n \n+// Arenas are used to quickly allocate objects that share a\n+// lifetime. The arena uses ~[u8] vectors as a backing store to\n+// allocate objects from. For each allocated object, the arena stores\n+// a pointer to the type descriptor followed by the\n+// object. (Potentially with alignment padding after each of them.)\n+// When the arena is destroyed, it iterates through all of its chunks,\n+// and uses the tydesc information to trace through the objects,\n+// calling the destructors on them.\n+// One subtle point that needs to be addressed is how to handle\n+// failures while running the user provided initializer function. It\n+// is important to not run the destructor on uninitialized objects, but\n+// how to detect them is somewhat subtle. Since alloc() can be invoked\n+// recursively, it is not sufficient to simply exclude the most recent\n+// object. To solve this without requiring extra space, we use the low\n+// order bit of the tydesc pointer to encode whether the object it\n+// describes has been fully initialized.\n+\n+// As an optimization, objects with destructors are stored in\n+// different chunks than objects without destructors. This reduces\n+// overhead when initializing plain-old-data and means we don't need\n+// to waste time running the destructors of POD.\n #[no_freeze]\n pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n@@ -110,8 +115,8 @@ impl Drop for Arena {\n }\n \n #[inline]\n-fn round_up_to(base: uint, align: uint) -> uint {\n-    (base + (align - 1)) & !(align - 1)\n+fn round_up(base: uint, align: uint) -> uint {\n+    (base.checked_add(&(align - 1))).unwrap() & !(&(align - 1))\n }\n \n // Walk down a chunk, running the destructors for any objects stored\n@@ -131,7 +136,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n \n         let after_tydesc = idx + mem::size_of::<*TyDesc>();\n \n-        let start = round_up_to(after_tydesc, align);\n+        let start = round_up(after_tydesc, align);\n \n         //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n@@ -140,7 +145,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         }\n \n         // Find where the next tydesc lives\n-        idx = round_up_to(start + size, mem::pref_align_of::<*TyDesc>());\n+        idx = round_up(start + size, mem::pref_align_of::<*TyDesc>());\n     }\n }\n \n@@ -175,7 +180,7 @@ impl Arena {\n     fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n             let this = transmute_mut_region(self);\n-            let start = round_up_to(this.pod_head.fill.get(), align);\n+            let start = round_up(this.pod_head.fill.get(), align);\n             let end = start + n_bytes;\n             if end > at_vec::capacity(this.pod_head.data.get()) {\n                 return this.alloc_pod_grow(n_bytes, align);\n@@ -227,7 +232,7 @@ impl Arena {\n \n                 tydesc_start = head.fill.get();\n                 after_tydesc = head.fill.get() + mem::size_of::<*TyDesc>();\n-                start = round_up_to(after_tydesc, align);\n+                start = round_up(after_tydesc, align);\n                 end = start + n_bytes;\n             }\n \n@@ -236,7 +241,7 @@ impl Arena {\n             }\n \n             let head = transmute_mut_region(&mut self.head);\n-            head.fill.set(round_up_to(end, mem::pref_align_of::<*TyDesc>()));\n+            head.fill.set(round_up(end, mem::pref_align_of::<*TyDesc>()));\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n@@ -314,3 +319,284 @@ fn test_arena_destructors_fail() {\n         fail!();\n     });\n }\n+\n+/// An arena that can hold objects of only one type.\n+///\n+/// Safety note: Modifying objects in the arena that have already had their\n+/// `drop` destructors run can cause leaks, because the destructor will not\n+/// run again for these objects.\n+pub struct TypedArena<T> {\n+    /// A pointer to the next object to be allocated.\n+    priv ptr: *T,\n+\n+    /// A pointer to the end of the allocated area. When this pointer is\n+    /// reached, a new chunk is allocated.\n+    priv end: *T,\n+\n+    /// The type descriptor of the objects in the arena. This should not be\n+    /// necessary, but is until generic destructors are supported.\n+    priv tydesc: *TyDesc,\n+\n+    /// A pointer to the first arena segment.\n+    priv first: Option<~TypedArenaChunk>,\n+}\n+\n+struct TypedArenaChunk {\n+    /// Pointer to the next arena segment.\n+    next: Option<~TypedArenaChunk>,\n+\n+    /// The number of elements that this chunk can hold.\n+    capacity: uint,\n+\n+    // Objects follow here, suitably aligned.\n+}\n+\n+impl TypedArenaChunk {\n+    #[inline]\n+    fn new<T>(next: Option<~TypedArenaChunk>, capacity: uint)\n+           -> ~TypedArenaChunk {\n+        let mut size = mem::size_of::<TypedArenaChunk>();\n+        size = round_up(size, mem::min_align_of::<T>());\n+        let elem_size = mem::size_of::<T>();\n+        let elems_size = elem_size.checked_mul(&capacity).unwrap();\n+        size = size.checked_add(&elems_size).unwrap();\n+\n+        let mut chunk = unsafe {\n+            let chunk = global_heap::exchange_malloc(size);\n+            let mut chunk: ~TypedArenaChunk = cast::transmute(chunk);\n+            intrinsics::move_val_init(&mut chunk.next, next);\n+            chunk\n+        };\n+\n+        chunk.capacity = capacity;\n+        chunk\n+    }\n+\n+    /// Destroys this arena chunk. If the type descriptor is supplied, the\n+    /// drop glue is called; otherwise, drop glue is not called.\n+    #[inline]\n+    unsafe fn destroy(&mut self, len: uint, opt_tydesc: Option<*TyDesc>) {\n+        // Destroy all the allocated objects.\n+        match opt_tydesc {\n+            None => {}\n+            Some(tydesc) => {\n+                let mut start = self.start(tydesc);\n+                for _ in range(0, len) {\n+                    ((*tydesc).drop_glue)(start as *i8);\n+                    start = start.offset((*tydesc).size as int)\n+                }\n+            }\n+        }\n+\n+        // Destroy the next chunk.\n+        let next_opt = util::replace(&mut self.next, None);\n+        match next_opt {\n+            None => {}\n+            Some(mut next) => {\n+                // We assume that the next chunk is completely filled.\n+                next.destroy(next.capacity, opt_tydesc)\n+            }\n+        }\n+    }\n+\n+    // Returns a pointer to the first allocated object.\n+    #[inline]\n+    fn start(&self, tydesc: *TyDesc) -> *u8 {\n+        let this: *TypedArenaChunk = self;\n+        unsafe {\n+            cast::transmute(round_up(this.offset(1) as uint, (*tydesc).align))\n+        }\n+    }\n+\n+    // Returns a pointer to the end of the allocated space.\n+    #[inline]\n+    fn end(&self, tydesc: *TyDesc) -> *u8 {\n+        unsafe {\n+            let size = (*tydesc).size.checked_mul(&self.capacity).unwrap();\n+            self.start(tydesc).offset(size as int)\n+        }\n+    }\n+}\n+\n+impl<T> TypedArena<T> {\n+    /// Creates a new arena with preallocated space for 8 objects.\n+    #[inline]\n+    pub fn new() -> TypedArena<T> {\n+        TypedArena::with_capacity(8)\n+    }\n+\n+    /// Creates a new arena with preallocated space for the given number of\n+    /// objects.\n+    #[inline]\n+    pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n+        let chunk = TypedArenaChunk::new::<T>(None, capacity);\n+        let tydesc = unsafe {\n+            intrinsics::get_tydesc::<T>()\n+        };\n+        TypedArena {\n+            ptr: chunk.start(tydesc) as *T,\n+            end: chunk.end(tydesc) as *T,\n+            tydesc: tydesc,\n+            first: Some(chunk),\n+        }\n+    }\n+\n+    /// Allocates an object into this arena.\n+    #[inline]\n+    pub fn alloc<'a>(&'a self, object: T) -> &'a T {\n+        unsafe {\n+            let this = cast::transmute_mut(self);\n+            if this.ptr == this.end {\n+                this.grow()\n+            }\n+\n+            let ptr: &'a mut T = cast::transmute(this.ptr);\n+            intrinsics::move_val_init(ptr, object);\n+            this.ptr = this.ptr.offset(1);\n+            let ptr: &'a T = ptr;\n+            ptr\n+        }\n+    }\n+\n+    /// Grows the arena.\n+    #[inline(never)]\n+    fn grow(&mut self) {\n+        let chunk = self.first.take_unwrap();\n+        let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n+        let chunk = TypedArenaChunk::new::<T>(Some(chunk), new_capacity);\n+        self.ptr = chunk.start(self.tydesc) as *T;\n+        self.end = chunk.end(self.tydesc) as *T;\n+        self.first = Some(chunk)\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for TypedArena<T> {\n+    fn drop(&mut self) {\n+        // Determine how much was filled.\n+        let start = self.first.get_ref().start(self.tydesc) as uint;\n+        let end = self.ptr as uint;\n+        let diff = (end - start) / mem::size_of::<T>();\n+\n+        // Pass that to the `destroy` method.\n+        unsafe {\n+            let opt_tydesc = if intrinsics::needs_drop::<T>() {\n+                Some(self.tydesc)\n+            } else {\n+                None\n+            };\n+            self.first.get_mut_ref().destroy(diff, opt_tydesc)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{Arena, TypedArena};\n+    use test::BenchHarness;\n+\n+    struct Point {\n+        x: int,\n+        y: int,\n+        z: int,\n+    }\n+\n+    #[test]\n+    pub fn test_pod() {\n+        let arena = TypedArena::new();\n+        for _ in range(0, 1000000) {\n+            arena.alloc(Point {\n+                x: 1,\n+                y: 2,\n+                z: 3,\n+            });\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_pod(bh: &mut BenchHarness) {\n+        let arena = TypedArena::new();\n+        bh.iter(|| {\n+            arena.alloc(Point {\n+                x: 1,\n+                y: 2,\n+                z: 3,\n+            });\n+        })\n+    }\n+\n+    #[bench]\n+    pub fn bench_pod_nonarena(bh: &mut BenchHarness) {\n+        bh.iter(|| {\n+            let _ = ~Point {\n+                x: 1,\n+                y: 2,\n+                z: 3,\n+            };\n+        })\n+    }\n+\n+    #[bench]\n+    pub fn bench_pod_old_arena(bh: &mut BenchHarness) {\n+        let arena = Arena::new();\n+        bh.iter(|| {\n+            arena.alloc(|| {\n+                Point {\n+                    x: 1,\n+                    y: 2,\n+                    z: 3,\n+                }\n+            });\n+        })\n+    }\n+\n+    struct Nonpod {\n+        string: ~str,\n+        array: ~[int],\n+    }\n+\n+    #[test]\n+    pub fn test_nonpod() {\n+        let arena = TypedArena::new();\n+        for _ in range(0, 1000000) {\n+            arena.alloc(Nonpod {\n+                string: ~\"hello world\",\n+                array: ~[ 1, 2, 3, 4, 5 ],\n+            });\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_nonpod(bh: &mut BenchHarness) {\n+        let arena = TypedArena::new();\n+        bh.iter(|| {\n+            arena.alloc(Nonpod {\n+                string: ~\"hello world\",\n+                array: ~[ 1, 2, 3, 4, 5 ],\n+            });\n+        })\n+    }\n+\n+    #[bench]\n+    pub fn bench_nonpod_nonarena(bh: &mut BenchHarness) {\n+        bh.iter(|| {\n+            let _ = ~Nonpod {\n+                string: ~\"hello world\",\n+                array: ~[ 1, 2, 3, 4, 5 ],\n+            };\n+        })\n+    }\n+\n+    #[bench]\n+    pub fn bench_nonpod_old_arena(bh: &mut BenchHarness) {\n+        let arena = Arena::new();\n+        bh.iter(|| {\n+            let _ = arena.alloc(|| Nonpod {\n+                string: ~\"hello world\",\n+                array: ~[ 1, 2, 3, 4, 5 ],\n+            });\n+        })\n+    }\n+}\n+\n+"}, {"sha": "9f4106340f1619d1fd6ada56e07f52d725cd97a4", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fda71f26301d153ca8d9489281d382af79792d63/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda71f26301d153ca8d9489281d382af79792d63/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=fda71f26301d153ca8d9489281d382af79792d63", "patch": "@@ -11,8 +11,8 @@\n extern mod extra;\n \n use std::iter::range_step;\n-use extra::arena::Arena;\n use extra::future::Future;\n+use extra::arena::TypedArena;\n \n enum Tree<'a> {\n     Nil,\n@@ -26,14 +26,15 @@ fn item_check(t: &Tree) -> int {\n     }\n }\n \n-fn bottom_up_tree<'r>(arena: &'r Arena, item: int, depth: int) -> &'r Tree<'r> {\n+fn bottom_up_tree<'r>(arena: &'r TypedArena<Tree<'r>>, item: int, depth: int)\n+                  -> &'r Tree<'r> {\n     if depth > 0 {\n-        arena.alloc(|| {\n-            Node(bottom_up_tree(arena, 2 * item - 1, depth - 1),\n-                 bottom_up_tree(arena, 2 * item, depth - 1),\n-                 item)\n-        })\n-    } else {arena.alloc(|| Nil)}\n+        arena.alloc(Node(bottom_up_tree(arena, 2 * item - 1, depth - 1),\n+                         bottom_up_tree(arena, 2 * item, depth - 1),\n+                         item))\n+    } else {\n+        arena.alloc(Nil)\n+    }\n }\n \n fn main() {\n@@ -49,15 +50,15 @@ fn main() {\n     let max_depth = if min_depth + 2 > n {min_depth + 2} else {n};\n \n     {\n-        let arena = Arena::new();\n+        let arena = TypedArena::new();\n         let depth = max_depth + 1;\n         let tree = bottom_up_tree(&arena, 0, depth);\n \n         println!(\"stretch tree of depth {}\\t check: {}\",\n                  depth, item_check(tree));\n     }\n \n-    let long_lived_arena = Arena::new();\n+    let long_lived_arena = TypedArena::new();\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n \n     let mut messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n@@ -66,7 +67,7 @@ fn main() {\n             do Future::spawn {\n                 let mut chk = 0;\n                 for i in range(1, iterations + 1) {\n-                    let arena = Arena::new();\n+                    let arena = TypedArena::new();\n                     let a = bottom_up_tree(&arena, i, depth);\n                     let b = bottom_up_tree(&arena, -i, depth);\n                     chk += item_check(a) + item_check(b);"}]}