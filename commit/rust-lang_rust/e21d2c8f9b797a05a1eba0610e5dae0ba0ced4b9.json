{"sha": "e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMWQyYzhmOWI3OTdhMDVhMWViYTA2MTBlNWRhZTBiYTBjZWQ0Yjk=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-25T00:15:26Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-26T11:11:12Z"}, "message": "Move all functions used by the queries to query.rs", "tree": {"sha": "3d0add3be1be52a55529ab56d3bbd99bd51df494", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d0add3be1be52a55529ab56d3bbd99bd51df494"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9", "html_url": "https://github.com/rust-lang/rust/commit/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43221a684db39d6f9b72db9f099c24e8e51f1dc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/43221a684db39d6f9b72db9f099c24e8e51f1dc4", "html_url": "https://github.com/rust-lang/rust/commit/43221a684db39d6f9b72db9f099c24e8e51f1dc4"}], "stats": {"total": 206, "additions": 98, "deletions": 108}, "files": [{"sha": "579b79d92f8dc94b86c677abfafba4be06021b66", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 108, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9", "patch": "@@ -1,124 +1,19 @@\n // Not in interpret to make sure we do not use private implementation details\n \n-use std::convert::TryInto;\n-use std::error::Error;\n-use std::fmt;\n-use std::hash::Hash;\n-\n use rustc::mir;\n-use rustc::ty::layout::{self, VariantIdx};\n+use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, TyCtxt};\n \n-use syntax::{\n-    source_map::{Span, DUMMY_SP},\n-    symbol::Symbol,\n-};\n+use syntax::{source_map::DUMMY_SP, symbol::Symbol};\n \n-use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstValue, ImmTy, Immediate, InterpCx, OpTy, Scalar,\n-};\n+use crate::interpret::{intern_const_alloc_recursive, ConstValue, InterpCx};\n \n mod error;\n mod query;\n \n pub use error::*;\n pub use query::*;\n \n-/// The `InterpCx` is only meant to be used to do field and index projections into constants for\n-/// `simd_shuffle` and const patterns in match arms.\n-///\n-/// The function containing the `match` that is currently being analyzed may have generic bounds\n-/// that inform us about the generic bounds of the constant. E.g., using an associated constant\n-/// of a function's generic parameter will require knowledge about the bounds on the generic\n-/// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-fn mk_eval_cx<'mir, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    param_env: ty::ParamEnv<'tcx>,\n-    can_access_statics: bool,\n-) -> CompileTimeEvalContext<'mir, 'tcx> {\n-    debug!(\"mk_eval_cx: {:?}\", param_env);\n-    InterpCx::new(\n-        tcx.at(span),\n-        param_env,\n-        CompileTimeInterpreter::new(),\n-        MemoryExtra { can_access_statics },\n-    )\n-}\n-\n-fn op_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n-    op: OpTy<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n-    // We do not have value optimizations for everything.\n-    // Only scalars and slices, since they are very common.\n-    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n-    // from scalar unions that are initialized with one of their zero sized variants. We could\n-    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n-    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n-    // `Undef` situation.\n-    let try_as_immediate = match op.layout.abi {\n-        layout::Abi::Scalar(..) => true,\n-        layout::Abi::ScalarPair(..) => match op.layout.ty.kind {\n-            ty::Ref(_, inner, _) => match inner.kind {\n-                ty::Slice(elem) => elem == ecx.tcx.types.u8,\n-                ty::Str => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        },\n-        _ => false,\n-    };\n-    let immediate = if try_as_immediate {\n-        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n-    } else {\n-        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n-        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n-        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n-        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n-        // structs containing such.\n-        op.try_as_mplace()\n-    };\n-    let val = match immediate {\n-        Ok(mplace) => {\n-            let ptr = mplace.ptr.to_ptr().unwrap();\n-            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-            ConstValue::ByRef { alloc, offset: ptr.offset }\n-        }\n-        // see comment on `let try_as_immediate` above\n-        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n-            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n-            ScalarMaybeUndef::Undef => {\n-                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n-                // argument and we will not need this. The only way we can already have an\n-                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n-                // comes from a constant so it can happen have `Undef`, because the indirect\n-                // memory that was read had undefined bytes.\n-                let mplace = op.assert_mem_place();\n-                let ptr = mplace.ptr.to_ptr().unwrap();\n-                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                ConstValue::ByRef { alloc, offset: ptr.offset }\n-            }\n-        },\n-        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n-            let (data, start) = match a.not_undef().unwrap() {\n-                Scalar::Ptr(ptr) => {\n-                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n-                }\n-                Scalar::Raw { .. } => (\n-                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n-                    0,\n-                ),\n-            };\n-            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n-            let start = start.try_into().unwrap();\n-            let len: usize = len.try_into().unwrap();\n-            ConstValue::Slice { data, start, end: start + len }\n-        }\n-    };\n-    ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n-}\n-\n /// Extracts a field of a (variant of a) const.\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs"}, {"sha": "f92475e0375b04e8d2df9ae2ac081e078c5cfd65", "filename": "src/librustc_mir/const_eval/query.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs?ref=e21d2c8f9b797a05a1eba0610e5dae0ba0ced4b9", "patch": "@@ -262,3 +262,98 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n }\n+\n+/// The `InterpCx` is only meant to be used to do field and index projections into constants for\n+/// `simd_shuffle` and const patterns in match arms.\n+///\n+/// The function containing the `match` that is currently being analyzed may have generic bounds\n+/// that inform us about the generic bounds of the constant. E.g., using an associated constant\n+/// of a function's generic parameter will require knowledge about the bounds on the generic\n+/// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n+pub(super) fn mk_eval_cx<'mir, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n+    can_access_statics: bool,\n+) -> CompileTimeEvalContext<'mir, 'tcx> {\n+    debug!(\"mk_eval_cx: {:?}\", param_env);\n+    InterpCx::new(\n+        tcx.at(span),\n+        param_env,\n+        CompileTimeInterpreter::new(),\n+        MemoryExtra { can_access_statics },\n+    )\n+}\n+\n+pub(super) fn op_to_const<'tcx>(\n+    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n+    op: OpTy<'tcx>,\n+) -> &'tcx ty::Const<'tcx> {\n+    // We do not have value optimizations for everything.\n+    // Only scalars and slices, since they are very common.\n+    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n+    // from scalar unions that are initialized with one of their zero sized variants. We could\n+    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n+    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n+    // `Undef` situation.\n+    let try_as_immediate = match op.layout.abi {\n+        layout::Abi::Scalar(..) => true,\n+        layout::Abi::ScalarPair(..) => match op.layout.ty.kind {\n+            ty::Ref(_, inner, _) => match inner.kind {\n+                ty::Slice(elem) => elem == ecx.tcx.types.u8,\n+                ty::Str => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        },\n+        _ => false,\n+    };\n+    let immediate = if try_as_immediate {\n+        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n+    } else {\n+        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n+        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n+        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n+        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n+        // structs containing such.\n+        op.try_as_mplace()\n+    };\n+    let val = match immediate {\n+        Ok(mplace) => {\n+            let ptr = mplace.ptr.to_ptr().unwrap();\n+            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            ConstValue::ByRef { alloc, offset: ptr.offset }\n+        }\n+        // see comment on `let try_as_immediate` above\n+        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n+            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n+            ScalarMaybeUndef::Undef => {\n+                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n+                // argument and we will not need this. The only way we can already have an\n+                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n+                // comes from a constant so it can happen have `Undef`, because the indirect\n+                // memory that was read had undefined bytes.\n+                let mplace = op.assert_mem_place();\n+                let ptr = mplace.ptr.to_ptr().unwrap();\n+                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+                ConstValue::ByRef { alloc, offset: ptr.offset }\n+            }\n+        },\n+        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n+            let (data, start) = match a.not_undef().unwrap() {\n+                Scalar::Ptr(ptr) => {\n+                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n+                }\n+                Scalar::Raw { .. } => (\n+                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n+                    0,\n+                ),\n+            };\n+            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+            let start = start.try_into().unwrap();\n+            let len: usize = len.try_into().unwrap();\n+            ConstValue::Slice { data, start, end: start + len }\n+        }\n+    };\n+    ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n+}"}]}