{"sha": "d71223a6c54cd80392c7141b0f081fffb8dee628", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MTIyM2E2YzU0Y2Q4MDM5MmM3MTQxYjBmMDgxZmZmYjhkZWU2Mjg=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-12T03:56:00Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-30T14:17:29Z"}, "message": "intrinsics: try to return everything via {u,i}128ret to match LLVM\n\non suggestion by nagisa.", "tree": {"sha": "9963e2d2aaf45862860048595475d52920dc946d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9963e2d2aaf45862860048595475d52920dc946d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d71223a6c54cd80392c7141b0f081fffb8dee628", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d71223a6c54cd80392c7141b0f081fffb8dee628", "html_url": "https://github.com/rust-lang/rust/commit/d71223a6c54cd80392c7141b0f081fffb8dee628", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d71223a6c54cd80392c7141b0f081fffb8dee628/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92163f1c5e73cd8430276ba738d2cc3bca116163", "url": "https://api.github.com/repos/rust-lang/rust/commits/92163f1c5e73cd8430276ba738d2cc3bca116163", "html_url": "https://github.com/rust-lang/rust/commit/92163f1c5e73cd8430276ba738d2cc3bca116163"}], "stats": {"total": 137, "additions": 99, "deletions": 38}, "files": [{"sha": "6d1c6046806784e6ef911e37df509a1e99533a3c", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 99, "deletions": 38, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/d71223a6c54cd80392c7141b0f081fffb8dee628/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d71223a6c54cd80392c7141b0f081fffb8dee628/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=d71223a6c54cd80392c7141b0f081fffb8dee628", "patch": "@@ -19,7 +19,7 @@\n #![feature(staged_api)]\n #![cfg_attr(any(target_pointer_width=\"32\", target_pointer_width=\"16\", target_os=\"windows\",\n             target_arch=\"mips64\"),\n-            feature(core_intrinsics, core_float))]\n+            feature(core_intrinsics, core_float, repr_simd))]\n #![feature(associated_consts)]\n #![cfg_attr(not(stage0), feature(i128_type))]\n \n@@ -46,6 +46,29 @@ pub mod reimpls {\n     #[cfg(not(stage0))]\n     type i128_ = i128;\n \n+    // Unfortunately, every tool on Windows expects different\n+    // calling conventions to be met for int128. We need to\n+    // match here what LLVM expects from us. This is only\n+    // required for the return type!\n+    #[cfg(not(stage0))]\n+    #[cfg(windows)]\n+    #[repr(simd)]\n+    pub struct u64x2(u64, u64);\n+\n+    #[cfg(not(stage0))]\n+    #[cfg(windows)]\n+    type u128ret = u64x2;\n+\n+    #[cfg(any(not(windows),stage0))]\n+    type u128ret = u128_;\n+\n+    #[cfg(not(stage0))]\n+    #[cfg(windows)]\n+    type i128ret = u64x2;\n+\n+    #[cfg(any(not(windows),stage0))]\n+    type i128ret = i128_;\n+\n     macro_rules! ashl {\n         ($a:expr, $b:expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n@@ -114,24 +137,27 @@ pub mod reimpls {\n \n \n     #[export_name=\"__lshrti3\"]\n-    pub extern \"C\" fn lshr(a: u128_, b: u128_) -> u128_ {\n-        lshr!(a, b, u128_)\n+    pub extern \"C\" fn lshr(a: u128_, b: u128_) -> u128ret {\n+        lshr!(a, b, u128_).to_ret()\n     }\n \n-    #[cfg(stage0)]\n     #[export_name=\"__udivmodti4\"]\n-    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+    pub extern \"C\" fn u128_div_mod_export(n: u128_, d: u128_, rem: *mut u128_) -> u128ret {\n+        u128_div_mod(n, d, rem).to_ret()\n+    }\n+\n+    #[cfg(stage0)]\n+    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128ret {\n         unsafe {\n         if !rem.is_null() {\n             *rem = unchecked_rem(n, d);\n         }\n-        unchecked_div(n, d)\n+        unchecked_div(n, d).to_ret()\n         }\n     }\n \n     #[cfg(not(stage0))]\n-    #[export_name=\"__udivmodti4\"]\n-    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128 {\n         // Translated from Figure 3-40 of The PowerPC Compiler Writer's Guide\n         unsafe {\n         // special cases, X is unknown, K != 0\n@@ -297,43 +323,50 @@ pub mod reimpls {\n     }\n \n     #[export_name=\"__umodti3\"]\n-    pub extern \"C\" fn u128_mod(a: u128_, b: u128_) -> u128_ {\n+    pub extern \"C\" fn u128_mod(a: u128_, b: u128_) -> u128ret {\n         unsafe {\n             let mut r = ::core::mem::zeroed();\n             u128_div_mod(a, b, &mut r);\n-            r\n+            r.to_ret()\n         }\n     }\n \n     #[export_name=\"__modti3\"]\n-    pub extern \"C\" fn i128_mod(a: i128_, b: i128_) -> i128_ {\n+    pub extern \"C\" fn i128_mod(a: i128_, b: i128_) -> i128ret {\n         let b = b.uabs();\n         let sa = a.signum();\n         let a = a.uabs();\n-        unsafe {\n+        (unsafe {\n             let mut r = ::core::mem::zeroed();\n             u128_div_mod(a, b, &mut r);\n             if sa == -1 { (r as i128_).unchecked_neg() } else { r as i128_ }\n-        }\n+        }).to_ret()\n     }\n \n     #[export_name=\"__divti3\"]\n-    pub extern \"C\" fn i128_div(a: i128_, b: i128_) -> i128_ {\n+    pub extern \"C\" fn i128_div(a: i128_, b: i128_) -> i128ret {\n         let sa = a.signum();\n         let sb = b.signum();\n         let a = a.uabs();\n         let b = b.uabs();\n         let sr = sa.wrapping_mul(sb); // sign of quotient\n-        if sr == -1 {\n+        (if sr == -1 {\n             (u128_div_mod(a, b, ptr::null_mut()) as i128_).unchecked_neg()\n         } else {\n             u128_div_mod(a, b, ptr::null_mut()) as i128_\n-        }\n+        }).to_ret()\n     }\n \n+    #[cfg(stage0)]\n+    #[export_name=\"__udivti3\"]\n+    pub extern \"C\" fn u128_div(a: u128_, b: u128_) -> u128ret {\n+        (a / b).to_ret()\n+    }\n+\n+    #[cfg(not(stage0))]\n     #[export_name=\"__udivti3\"]\n-    pub extern \"C\" fn u128_div(a: u128_, b: u128_) -> u128_ {\n-        u128_div_mod(a, b, ptr::null_mut())\n+    pub extern \"C\" fn u128_div(a: u128_, b: u128_) -> u128ret {\n+        u128_div_mod(a, b, ptr::null_mut()).to_ret()\n     }\n \n     macro_rules! mulo {\n@@ -345,21 +378,21 @@ pub mod reimpls {\n                 if b != 0 && b != 1 {\n                     *overflow = 1;\n                 }\n-                return result;\n+                return result.to_ret();\n             }\n             if b == <$ty>::min_value() {\n                 if a != 0 && a != 1 {\n                     *overflow = 1;\n                 }\n-                return result;\n+                return result.to_ret();\n             }\n \n             let sa = a.signum();\n             let abs_a = a.iabs();\n             let sb = b.signum();\n             let abs_b = b.iabs();\n             if abs_a < 2 || abs_b < 2 {\n-                return result;\n+                return result.to_ret();\n             }\n             unsafe {\n             if sa == sb {\n@@ -372,27 +405,30 @@ pub mod reimpls {\n                 }\n             }\n             }\n-            result\n+            result.to_ret()\n         }}\n     }\n \n     // FIXME: i32 here should be c_int.\n     #[export_name=\"__muloti4\"]\n-    pub extern \"C\" fn i128_mul_oflow(a: i128_, b: i128_, o: &mut i32) -> i128_ {\n+    pub extern \"C\" fn i128_mul_oflow(a: i128_, b: i128_, o: &mut i32) -> i128ret {\n         mulo!(a, b, o, i128_)\n     }\n \n     pub trait LargeInt {\n         type LowHalf;\n         type HighHalf;\n+        type Ret;\n \n         fn low(self) -> Self::LowHalf;\n         fn high(self) -> Self::HighHalf;\n         fn from_parts(low: Self::LowHalf, high: Self::HighHalf) -> Self;\n+        fn to_ret(self) -> Self::Ret;\n     }\n     impl LargeInt for u64 {\n         type LowHalf = u32;\n         type HighHalf = u32;\n+        type Ret = u64;\n \n         fn low(self) -> u32 {\n             self as u32\n@@ -403,10 +439,14 @@ pub mod reimpls {\n         fn from_parts(low: u32, high: u32) -> u64 {\n             low as u64 | (high as u64).wrapping_shl(32)\n         }\n+        fn to_ret(self) -> u64 {\n+            self\n+        }\n     }\n     impl LargeInt for i64 {\n         type LowHalf = u32;\n         type HighHalf = i32;\n+        type Ret = i64;\n \n         fn low(self) -> u32 {\n             self as u32\n@@ -417,11 +457,15 @@ pub mod reimpls {\n         fn from_parts(low: u32, high: i32) -> i64 {\n             low as i64 | (high as i64).wrapping_shl(32)\n         }\n+        fn to_ret(self) -> i64 {\n+            self\n+        }\n     }\n     #[cfg(not(stage0))]\n     impl LargeInt for u128 {\n         type LowHalf = u64;\n         type HighHalf = u64;\n+        type Ret = u128ret;\n \n         fn low(self) -> u64 {\n             self as u64\n@@ -433,11 +477,20 @@ pub mod reimpls {\n             #[repr(C, packed)] struct Parts(u64, u64);\n             unsafe { ::core::mem::transmute(Parts(low, high)) }\n         }\n+        #[cfg(not(windows))]\n+        fn to_ret(self) -> u128ret {\n+            self\n+        }\n+        #[cfg(windows)]\n+        fn to_ret(self) -> u128ret {\n+            u64x2(self.low(), self.high())\n+        }\n     }\n     #[cfg(not(stage0))]\n     impl LargeInt for i128 {\n         type LowHalf = u64;\n         type HighHalf = i64;\n+        type Ret = i128ret;\n \n         fn low(self) -> u64 {\n             self as u64\n@@ -448,6 +501,14 @@ pub mod reimpls {\n         fn from_parts(low: u64, high: i64) -> i128 {\n             u128::from_parts(low, high as u64) as i128\n         }\n+        #[cfg(not(windows))]\n+        fn to_ret(self) -> u128ret {\n+            self\n+        }\n+        #[cfg(windows)]\n+        fn to_ret(self) -> i128ret {\n+            u64x2(self.low(), self.high() as u64)\n+        }\n     }\n \n     macro_rules! mul {\n@@ -481,14 +542,14 @@ pub mod reimpls {\n \n     #[cfg(stage0)]\n     #[export_name=\"__multi3\"]\n-    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n-        (a as i64).wrapping_mul(b as i64) as i128_\n+    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128ret {\n+        ((a as i64).wrapping_mul(b as i64) as i128_).to_ret()\n     }\n \n     #[cfg(not(stage0))]\n     #[export_name=\"__multi3\"]\n-    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n-        mul!(a, b, i128_, i64)\n+    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128ret {\n+        mul!(a, b, i128_, i64).to_ret()\n     }\n \n     trait AbsExt: Sized {\n@@ -566,29 +627,29 @@ pub mod reimpls {\n             let exponent = $from.get_exponent();\n             let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n-            if sign == -1.0 || exponent < 0 { return 0; }\n+            if sign == -1.0 || exponent < 0 { return (0 as u128_).to_ret(); }\n             if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n-                return !0;\n+                return (!(0 as u128_)).to_ret();\n             }\n-            if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n+            (if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n                 (mantissa as $outty)\n                     .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32)\n                                   .wrapping_sub(exponent) as u32)\n             } else {\n                 (mantissa as $outty)\n                     .wrapping_shl(exponent.wrapping_sub(\n                         <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n-            }\n+            }).to_ret()\n         } }\n     }\n \n     #[export_name=\"__fixunsdfti\"]\n-    pub extern \"C\" fn f64_as_u128(a: f64) -> u128_ {\n+    pub extern \"C\" fn f64_as_u128(a: f64) -> u128ret {\n         float_as_unsigned!(a, f64, u128_)\n     }\n \n     #[export_name=\"__fixunssfti\"]\n-    pub extern \"C\" fn f32_as_u128(a: f32) -> u128_ {\n+    pub extern \"C\" fn f32_as_u128(a: f32) -> u128ret {\n         float_as_unsigned!(a, f32, u128_)\n     }\n \n@@ -601,9 +662,9 @@ pub mod reimpls {\n             let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n \n-            if exponent < 0 { return 0; }\n+            if exponent < 0 { return (0 as i128_).to_ret(); }\n             if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n-                return if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n+                return (if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() }).to_ret();\n             }\n             let r = if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n                 (mantissa as $outty)\n@@ -614,17 +675,17 @@ pub mod reimpls {\n                     .wrapping_shl(exponent.wrapping_sub(\n                         <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n             };\n-            if sign >= 0.0 { r } else { r.unchecked_neg() }\n+            (if sign >= 0.0 { r } else { r.unchecked_neg() }).to_ret()\n         }}\n     }\n \n     #[export_name=\"__fixdfti\"]\n-    pub extern \"C\" fn f64_as_i128(a: f64) -> i128_ {\n+    pub extern \"C\" fn f64_as_i128(a: f64) -> i128ret {\n         float_as_signed!(a, f64, i128_)\n     }\n \n     #[export_name=\"__fixsfti\"]\n-    pub extern \"C\" fn f32_as_i128(a: f32) -> i128_ {\n+    pub extern \"C\" fn f32_as_i128(a: f32) -> i128ret {\n         float_as_signed!(a, f32, i128_)\n     }\n "}]}