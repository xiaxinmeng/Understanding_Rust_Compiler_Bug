{"sha": "26b4cb48484382032522384318e70ceb0fbc4a41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YjRjYjQ4NDg0MzgyMDMyNTIyMzg0MzE4ZTcwY2ViMGZiYzRhNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-09T18:22:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-09T18:22:05Z"}, "message": "Auto merge of #59050 - Centril:rollup, r=Centril\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #58518 (Use early unwraps instead of bubbling up errors just to unwrap in the end)\n - #58626 (rustdoc: add option to calculate \"documentation coverage\")\n - #58629 (rust-lldb: fix crash when printing empty string)\n - #58660 (MaybeUninit: add read_initialized, add examples)\n - #58670 (fixes rust-lang#52482)\n - #58676 (look for python2 symlinks before bootstrap python)\n - #58679 (Refactor passes and pass execution to be more parallel)\n - #58750 (Make `Unique::as_ptr`, `NonNull::dangling` and `NonNull::cast` const)\n - #58762 (Mention `unwind(aborts)` in diagnostics for `#[unwind]`)\n - #58924 (Add as_slice() to slice::IterMut and vec::Drain)\n - #58990 (Actually publish miri in the manifest)\n - #59018 (std: Delete a by-definition spuriously failing test)\n - #59045 (Expose new_sub_parser_from_file)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "085b13b699ff67ecb9fb36598d652bb1f3f770ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/085b13b699ff67ecb9fb36598d652bb1f3f770ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26b4cb48484382032522384318e70ceb0fbc4a41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26b4cb48484382032522384318e70ceb0fbc4a41", "html_url": "https://github.com/rust-lang/rust/commit/26b4cb48484382032522384318e70ceb0fbc4a41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26b4cb48484382032522384318e70ceb0fbc4a41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "html_url": "https://github.com/rust-lang/rust/commit/e1b8898cfb0392f534cc25808a7f6caad36ebbb7"}, {"sha": "4eb762a0eada2d2789f9db6eabfe538e9b8ee41d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb762a0eada2d2789f9db6eabfe538e9b8ee41d", "html_url": "https://github.com/rust-lang/rust/commit/4eb762a0eada2d2789f9db6eabfe538e9b8ee41d"}], "stats": {"total": 1784, "additions": 1394, "deletions": 390}, "files": [{"sha": "9afbd937c422c187ce58113dd664b1748729708c", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -164,6 +164,9 @@\n # Python interpreter to use for various tasks throughout the build, notably\n # rustdoc tests, the lldb python interpreter, and some dist bits and pieces.\n # Note that Python 2 is currently required.\n+#\n+# Defaults to python2.7, then python2. If neither executable can be found, then\n+# it defaults to the Python interpreter used to execute x.py.\n #python = \"python2.7\"\n \n # Force Cargo to check that Cargo.lock describes the precise dependency"}, {"sha": "b9f456e91003843fe10655c6910220a3dcc098ae", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -34,15 +34,17 @@ impl Finder {\n \n     fn maybe_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> Option<PathBuf> {\n         let cmd: OsString = cmd.as_ref().into();\n-        let path = self.path.clone();\n+        let path = &self.path;\n         self.cache.entry(cmd.clone()).or_insert_with(|| {\n-            for path in env::split_paths(&path) {\n+            for path in env::split_paths(path) {\n                 let target = path.join(&cmd);\n-                let mut cmd_alt = cmd.clone();\n-                cmd_alt.push(\".exe\");\n-                if target.is_file() || // some/path/git\n-                target.with_extension(\"exe\").exists() || // some/path/git.exe\n-                target.join(&cmd_alt).exists() { // some/path/git/git.exe\n+                let mut cmd_exe = cmd.clone();\n+                cmd_exe.push(\".exe\");\n+\n+                if target.is_file()                   // some/path/git\n+                    || path.join(&cmd_exe).exists()   // some/path/git.exe\n+                    || target.join(&cmd_exe).exists() // some/path/git/git.exe\n+                {\n                     return Some(target);\n                 }\n             }\n@@ -107,9 +109,9 @@ pub fn check(build: &mut Build) {\n     }\n \n     build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n-        .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n         .or_else(|| cmd_finder.maybe_have(\"python2.7\"))\n         .or_else(|| cmd_finder.maybe_have(\"python2\"))\n+        .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n         .or_else(|| Some(cmd_finder.must_have(\"python\")));\n \n     build.config.nodejs = build.config.nodejs.take().map(|p| cmd_finder.must_have(p))"}, {"sha": "3938df1a6826743b089edef4ba533f99cd485090", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -53,7 +53,7 @@ For example, in the following code:\n ```rust\n /// Does the thing.\n pub fn do_the_thing(_: SomeType) {\n-\tprintln!(\"Let's do the thing!\");\n+    println!(\"Let's do the thing!\");\n }\n \n /// Token you use to [`do_the_thing`].\n@@ -66,15 +66,15 @@ target out also works:\n \n ```rust\n pub mod some_module {\n-\t/// Token you use to do the thing.\n-\tpub struct SomeStruct;\n+    /// Token you use to do the thing.\n+    pub struct SomeStruct;\n }\n \n /// Does the thing. Requires one [`SomeStruct`] for the thing to work.\n ///\n /// [`SomeStruct`]: some_module::SomeStruct\n pub fn do_the_thing(_: some_module::SomeStruct) {\n-\tprintln!(\"Let's do the thing!\");\n+    println!(\"Let's do the thing!\");\n }\n ```\n \n@@ -428,3 +428,30 @@ $ rustdoc src/lib.rs --test -Z unstable-options --persist-doctests target/rustdo\n This flag allows you to keep doctest executables around after they're compiled or run.\n Usually, rustdoc will immediately discard a compiled doctest after it's been tested, but\n with this option, you can keep those binaries around for farther testing.\n+\n+### `--show-coverage`: calculate the percentage of items with documentation\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --show-coverage\n+```\n+\n+If you want to determine how many items in your crate are documented, pass this flag to rustdoc.\n+When it receives this flag, it will count the public items in your crate that have documentation,\n+and print out the counts and a percentage instead of generating docs.\n+\n+Some methodology notes about what rustdoc counts in this metric:\n+\n+* Rustdoc will only count items from your crate (i.e. items re-exported from other crates don't\n+  count).\n+* Docs written directly onto inherent impl blocks are not counted, even though their doc comments\n+  are displayed, because the common pattern in Rust code is to write all inherent methods into the\n+  same impl block.\n+* Items in a trait implementation are not counted, as those impls will inherit any docs from the\n+  trait itself.\n+* By default, only public items are counted. To count private items as well, pass\n+  `--document-private-items` at the same time.\n+\n+Public items that are not documented can be seen with the built-in `missing_docs` lint. Private\n+items that are not documented can be seen with Clippy's `missing_docs_in_private_items` lint."}, {"sha": "fdc1c4fa0cc38d95d0f74e324b596dbcec729347", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -290,6 +290,8 @@ def render_element(i):\n \n \n def read_utf8_string(ptr_val, byte_count):\n+    if byte_count == 0:\n+        return '\"\"'\n     error = lldb.SBError()\n     process = ptr_val.get_wrapped_value().GetProcess()\n     data = process.ReadMemory(ptr_val.as_integer(), byte_count, error)"}, {"sha": "adcd3d84f4832ebd79d53578d6467b567ed3e479", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -2468,6 +2468,25 @@ impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n     }\n }\n \n+impl<'a, T> Drain<'a, T> {\n+    /// Returns the remaining items of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(vec_drain_as_slice)]\n+    /// let mut vec = vec!['a', 'b', 'c'];\n+    /// let mut drain = vec.drain(..);\n+    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n+    /// let _ = drain.next().unwrap();\n+    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n+    /// ```\n+    #[unstable(feature = \"vec_drain_as_slice\", reason = \"recently added\", issue = \"58957\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self.iter.as_slice()\n+    }\n+}\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]"}, {"sha": "edeb65afd67b2d89e336cbcbedae2a6ef3a8f9bf", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -15,6 +15,7 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter, num: &T,\n         // FIXME(#53491): Technically, this is calling `get_mut` on an uninitialized\n         // `MaybeUninit` (here and elsewhere in this file).  Revisit this once\n         // we decided whether that is valid or not.\n+        // Using `freeze` is *not enough*; `flt2dec::Part` is an enum!\n         let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n                                                     *num, sign, precision,\n                                                     false, buf.get_mut(), parts.get_mut());\n@@ -33,6 +34,7 @@ fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter, num: &T,\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n         let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n                                                  sign, precision, false, buf.get_mut(),\n                                                  parts.get_mut());\n@@ -71,6 +73,7 @@ fn float_to_exponential_common_exact<T>(fmt: &mut Formatter, num: &T,\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n                                                   *num, sign, precision,\n                                                   upper, buf.get_mut(), parts.get_mut());\n@@ -90,6 +93,7 @@ fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter,\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n         let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n                                                      *num, sign, (0, 0), upper,\n                                                      buf.get_mut(), parts.get_mut());"}, {"sha": "90e84d0b28c3b0bea5c8d0a0c3d315f74ab73148", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 224, "deletions": 29, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -1043,7 +1043,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     }\n }\n \n-/// A newtype to construct uninitialized instances of `T`.\n+/// A wrapper to construct uninitialized instances of `T`.\n ///\n /// The compiler, in general, assumes that variables are properly initialized\n /// at their respective type. For example, a variable of reference type must\n@@ -1057,41 +1057,51 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n-/// // equivalent code with `MaybeUninit`\n+/// // The equivalent code with `MaybeUninit<&i32>`:\n /// let x: &i32 = unsafe { MaybeUninit::zeroed().into_initialized() }; // undefined behavior!\n /// ```\n ///\n /// This is exploited by the compiler for various optimizations, such as eliding\n /// run-time checks and optimizing `enum` layout.\n ///\n-/// Not initializing memory at all (instead of zero-initializing it) causes the same\n-/// issue: after all, the initial value of the variable might just happen to be\n-/// one that violates the invariant. Moreover, uninitialized memory is special\n-/// in that the compiler knows that it does not have a fixed value. This makes\n-/// it undefined behavior to have uninitialized data in a variable even if that\n-/// variable has otherwise no restrictions about which values are valid:\n+/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n+/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n+///\n+/// ```rust,no_run\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<bool>`:\n+/// let b: bool = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// ```\n+///\n+/// Moreover, uninitialized memory is special in that the compiler knows that\n+/// it does not have a fixed value. This makes it undefined behavior to have\n+/// uninitialized data in a variable even if that variable has an integer type,\n+/// which otherwise can hold any bit pattern:\n ///\n /// ```rust,no_run\n /// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // equivalent code with `MaybeUninit`\n+/// // The equivalent code with `MaybeUninit<i32>`:\n /// let x: i32 = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n /// ```\n /// (Notice that the rules around uninitialized integers are not finalized yet, but\n /// until they are, it is advisable to avoid them.)\n ///\n-/// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n-/// it is a signal to the compiler indicating that the data here might *not*\n+/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n+/// It is a signal to the compiler indicating that the data here might *not*\n /// be initialized:\n ///\n /// ```rust\n /// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n /// // Create an explicitly uninitialized reference. The compiler knows that data inside\n-/// // a `MaybeUninit` may be invalid, and hence this is not UB:\n+/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninitialized();\n /// // Set it to a valid value.\n /// x.set(&0);\n@@ -1100,45 +1110,84 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// let x = unsafe { x.into_initialized() };\n /// ```\n ///\n-/// The compiler then knows to not optimize this code.\n+/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n // FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n+#[derive(Copy)]\n+// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n }\n \n+#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+impl<T: Copy> Clone for MaybeUninit<T> {\n+    #[inline(always)]\n+    fn clone(&self) -> Self {\n+        // Not calling T::clone(), we cannot know if we are initialized enough for that.\n+        *self\n+    }\n+}\n+\n impl<T> MaybeUninit<T> {\n-    /// Create a new `MaybeUninit` initialized with the given value.\n+    /// Create a new `MaybeUninit<T>` initialized with the given value.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub const fn new(val: T) -> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n     }\n \n-    /// Creates a new `MaybeUninit` in an uninitialized state.\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub const fn uninitialized() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n-    /// Creates a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n     /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n     /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n     /// be null.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// # Example\n+    ///\n+    /// Correct usage of this function: initializing a struct with zero, where all\n+    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n+    /// let x = unsafe { x.into_initialized() };\n+    /// assert_eq!(x, (0, false));\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n+    /// cannot hold 0 as a valid value.\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// enum NotZero { One = 1, Two = 2 };\n+    ///\n+    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n+    /// let x = unsafe { x.into_initialized() };\n+    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n+    /// // This is undefined behavior.\n+    /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline]\n     pub fn zeroed() -> MaybeUninit<T> {\n@@ -1149,9 +1198,10 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Sets the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n-    /// For your convenience, this also returns a mutable reference to the (now safely initialized)\n-    /// contents of `self`.\n+    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n+    /// without dropping it, so be careful not to use this twice unless you want to\n+    /// skip running the destructor. For your convenience, this also returns a mutable\n+    /// reference to the (now safely initialized) contents of `self`.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn set(&mut self, val: T) -> &mut T {\n@@ -1162,42 +1212,187 @@ impl<T> MaybeUninit<T> {\n     }\n \n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// assert_eq!(x_vec.len(), 3);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n     }\n \n     /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n+    /// // This is okay because we initialized it.\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// x_vec.push(3);\n+    /// assert_eq!(x_vec.len(), 4);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n     }\n \n-    /// Extracts the value from the `MaybeUninit` container. This is a great way\n+    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<bool>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(true); }\n+    /// let x_init = unsafe { x.into_initialized() };\n+    /// assert_eq!(x_init, true);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_init = unsafe { x.into_initialized() };\n+    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n+    /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn into_initialized(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n     }\n \n+    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n+    /// to the usual drop handling.\n+    ///\n+    /// Whenever possible, it is preferrable to use [`into_initialized`] instead, which\n+    /// prevents duplicating the content of the `MaybeUninit<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    ///\n+    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n+    /// multiple copies of the data (by calling `read_initialized` multiple times, or first\n+    /// calling `read_initialized` and then [`into_initialized`]), it is your responsibility\n+    /// to ensure that that data may indeed be duplicated.\n+    ///\n+    /// [`into_initialized`]: #method.into_initialized\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<u32>::uninitialized();\n+    /// x.set(13);\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// // `u32` is `Copy`, so we may read multiple times.\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// assert_eq!(x1, x2);\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninitialized();\n+    /// x.set(None);\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// // Duplicating a `None` value is okay, so we may read multiple times.\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// assert_eq!(x1, x2);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninitialized();\n+    /// x.set(Some(vec![0,1,2]));\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// // We now created two copies of the same vector, leading to a double-free when\n+    /// // they both get dropped!\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn read_initialized(&self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        self.as_ptr().read()\n+    }\n+\n     /// Gets a reference to the contained value.\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n@@ -1210,7 +1405,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references"}, {"sha": "53d41976030685c74620b76c1ee565b2dfef414c", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -301,7 +301,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Perform the swap\n     copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n     copy(y, x, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(tmp.get_ref(), y, 1);\n+    copy_nonoverlapping(tmp.as_ptr(), y, 1);\n }\n \n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n@@ -2790,7 +2790,7 @@ impl<T: ?Sized> Unique<T> {\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n-    pub fn as_ptr(self) -> *mut T {\n+    pub const fn as_ptr(self) -> *mut T {\n         self.pointer as *mut T\n     }\n \n@@ -2903,7 +2903,8 @@ impl<T: Sized> NonNull<T> {\n     /// some other means.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n-    pub fn dangling() -> Self {\n+    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_ptr_nonnull\"))]\n+    pub const fn dangling() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n             NonNull::new_unchecked(ptr)\n@@ -2966,7 +2967,8 @@ impl<T: ?Sized> NonNull<T> {\n     /// Cast to a pointer of another type\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n-    pub fn cast<U>(self) -> NonNull<U> {\n+    #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_ptr_nonnull\"))]\n+    pub const fn cast<U>(self) -> NonNull<U> {\n         unsafe {\n             NonNull::new_unchecked(self.as_ptr() as *mut U)\n         }"}, {"sha": "b3594f8a3858aec27cc66408fa1bb8ae41fe523f", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -3288,6 +3288,34 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn into_slice(self) -> &'a mut [T] {\n         unsafe { from_raw_parts_mut(self.ptr, len!(self)) }\n     }\n+\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// To avoid creating `&mut [T]` references that alias, the returned slice\n+    /// borrows its lifetime from the iterator the method is applied on.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// # #![feature(slice_iter_mut_as_slice)]\n+    /// let mut slice: &mut [usize] = &mut [1, 2, 3];\n+    ///\n+    /// // First, we get the iterator:\n+    /// let mut iter = slice.iter_mut();\n+    /// // So if we check what the `as_slice` method returns here, we have \"[1, 2, 3]\":\n+    /// assert_eq!(iter.as_slice(), &[1, 2, 3]);\n+    ///\n+    /// // Next, we move to the second element of the slice:\n+    /// iter.next();\n+    /// // Now `as_slice` returns \"[2, 3]\":\n+    /// assert_eq!(iter.as_slice(), &[2, 3]);\n+    /// ```\n+    #[unstable(feature = \"slice_iter_mut_as_slice\", reason = \"recently added\", issue = \"58957\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self.make_slice()\n+    }\n }\n \n iterator!{struct IterMut -> *mut T, &'a mut T, mut, {mut}, {}}"}, {"sha": "41a4a8031006f9d6ee354e6611a0ac7f92cbed0b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -456,6 +456,7 @@ define_dep_nodes!( <'tcx>\n     [eval_always] CoherenceInherentImplOverlapCheck,\n     [] CoherenceCheckTrait(DefId),\n     [eval_always] PrivacyAccessLevels(CrateNum),\n+    [eval_always] CheckPrivateInPublic(CrateNum),\n     [eval_always] Analysis(CrateNum),\n \n     // Represents the MIR for a fn; also used as the task node for"}, {"sha": "86f7e149964883d0b410dd039dcd1b1058759dc7", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -344,12 +344,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_attrs(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n fn is_c_like_enum(item: &hir::Item) -> bool {\n     if let hir::ItemKind::Enum(ref def, _) = item.node {\n         for variant in &def.variants {"}, {"sha": "e47bc3d1c253306819e5a2aae3972e872991b6a5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -30,7 +30,7 @@ use syntax::util::parser::ExprPrecedence;\n use crate::ty::AdtKind;\n use crate::ty::query::Providers;\n \n-use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync};\n+use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable;\n \n@@ -779,15 +779,15 @@ impl Crate {\n         where V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send\n     {\n         parallel!({\n-            par_iter(&self.items).for_each(|(_, item)| {\n+            par_for_each_in(&self.items, |(_, item)| {\n                 visitor.visit_item(item);\n             });\n         }, {\n-            par_iter(&self.trait_items).for_each(|(_, trait_item)| {\n+            par_for_each_in(&self.trait_items, |(_, trait_item)| {\n                 visitor.visit_trait_item(trait_item);\n             });\n         }, {\n-            par_iter(&self.impl_items).for_each(|(_, impl_item)| {\n+            par_for_each_in(&self.impl_items, |(_, impl_item)| {\n                 visitor.visit_impl_item(impl_item);\n             });\n         });"}, {"sha": "c4071e9f354b18e632c03e0aee8a0c039c4283a0", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -10,12 +10,6 @@ use syntax_pos::Span;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir;\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_intrinsics(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,"}, {"sha": "f5a95d7004bffdbdc2ad3097d65c5f489eda7573", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -185,12 +185,6 @@ fn check_mod_liveness<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut IrMaps::new(tcx).as_deep_visitor());\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_liveness(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         check_mod_liveness,"}, {"sha": "1677384059e09e276c351a8734c688a3f3ee83e1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -456,12 +456,6 @@ impl<'a, 'tcx> Index<'tcx> {\n     }\n }\n \n-pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_unstable_api_usage(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {"}, {"sha": "04d503d993db773e160b64cf9c8e8117bb0e3af4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -41,7 +41,7 @@ use crate::ty::steal::Steal;\n use crate::ty::subst::{UserSubsts, UnpackedKind};\n use crate::ty::{BoundVar, BindingMode};\n use crate::ty::CanonicalPolyFnSig;\n-use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::DiagnosticBuilder;\n use rustc_data_structures::interner::HashInterner;\n@@ -409,9 +409,9 @@ pub struct TypeckTables<'tcx> {\n     /// MIR construction and hence is not serialized to metadata.\n     fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n \n-    /// Maps a cast expression to its kind. This is keyed on the\n-    /// *from* expression of the cast, not the cast itself.\n-    cast_kinds: ItemLocalMap<ty::cast::CastKind>,\n+    /// For every coercion cast we add the HIR node ID of the cast\n+    /// expression to this set.\n+    coercion_casts: ItemLocalSet,\n \n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports. During type\n@@ -456,7 +456,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             closure_kind_origins: Default::default(),\n             liberated_fn_sigs: Default::default(),\n             fru_field_types: Default::default(),\n-            cast_kinds: Default::default(),\n+            coercion_casts: Default::default(),\n             used_trait_imports: Lrc::new(Default::default()),\n             tainted_by_errors: false,\n             free_region_map: Default::default(),\n@@ -718,19 +718,19 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n-    pub fn cast_kinds(&self) -> LocalTableInContext<'_, ty::cast::CastKind> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.cast_kinds\n-        }\n+    pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, hir_id, true);\n+        self.coercion_casts.contains(&hir_id.local_id)\n     }\n \n-    pub fn cast_kinds_mut(&mut self) -> LocalTableInContextMut<'_, ty::cast::CastKind> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.cast_kinds\n-        }\n+    pub fn set_coercion_cast(&mut self, id: ItemLocalId) {\n+        self.coercion_casts.insert(id);\n+    }\n+\n+    pub fn coercion_casts(&self) -> &ItemLocalSet {\n+        &self.coercion_casts\n     }\n+\n }\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n@@ -753,7 +753,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             ref liberated_fn_sigs,\n             ref fru_field_types,\n \n-            ref cast_kinds,\n+            ref coercion_casts,\n \n             ref used_trait_imports,\n             tainted_by_errors,\n@@ -798,7 +798,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             closure_kind_origins.hash_stable(hcx, hasher);\n             liberated_fn_sigs.hash_stable(hcx, hasher);\n             fru_field_types.hash_stable(hcx, hasher);\n-            cast_kinds.hash_stable(hcx, hasher);\n+            coercion_casts.hash_stable(hcx, hasher);\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             free_region_map.hash_stable(hcx, hasher);"}, {"sha": "6488c0db42bc571884599493cedb2fc3153c3dc2", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -369,6 +369,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::privacy_access_levels<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::check_private_in_public<'tcx> {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking for private elements in public interfaces\".into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::typeck_item_bodies<'tcx> {\n     fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"type-checking all item bodies\".into()"}, {"sha": "8804ed22264ce061e405563eb69314afba67b06b", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -350,8 +350,9 @@ define_queries! { <'tcx>\n         [] fn check_match: CheckMatch(DefId)\n             -> Result<(), ErrorReported>,\n \n-        /// Performs the privacy check and computes \"access levels\".\n+        /// Performs part of the privacy check and computes \"access levels\".\n         [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Lrc<AccessLevels>,\n+        [] fn check_private_in_public: CheckPrivateInPublic(CrateNum) -> (),\n     },\n \n     Other {"}, {"sha": "e3276ba0bea7bc17822dff9393eb40205f8bd5eb", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -1251,6 +1251,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n             force!(crate_inherent_impls_overlap_check, LOCAL_CRATE)\n         },\n         DepKind::PrivacyAccessLevels => { force!(privacy_access_levels, LOCAL_CRATE); }\n+        DepKind::CheckPrivateInPublic => { force!(check_private_in_public, LOCAL_CRATE); }\n         DepKind::MirBuilt => { force!(mir_built, def_id!()); }\n         DepKind::MirConstQualif => { force!(mir_const_qualif, def_id!()); }\n         DepKind::MirConst => { force!(mir_const, def_id!()); }"}, {"sha": "349c9132842b893947cd5434e4edc2f364d68d47", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -49,36 +49,36 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant: Result<ty::Const<'tcx>, ErrorHandled>,\n     ) -> (Bx::Value, Ty<'tcx>) {\n         constant\n-            .and_then(|c| {\n+            .map(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n                     ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n-                let values: Result<Vec<_>, ErrorHandled> = (0..fields).map(|field| {\n+                let values: Vec<_> = (0..fields).map(|field| {\n                     let field = const_field(\n                         bx.tcx(),\n                         ty::ParamEnv::reveal_all(),\n                         None,\n                         mir::Field::new(field as usize),\n                         c,\n-                    )?;\n+                    );\n                     if let Some(prim) = field.val.try_to_scalar() {\n                         let layout = bx.layout_of(field_ty);\n                         let scalar = match layout.abi {\n                             layout::Abi::Scalar(ref x) => x,\n                             _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                         };\n-                        Ok(bx.scalar_to_backend(\n+                        bx.scalar_to_backend(\n                             prim, scalar,\n                             bx.immediate_backend_type(layout),\n-                        ))\n+                        )\n                     } else {\n                         bug!(\"simd shuffle field {:?}\", field)\n                     }\n                 }).collect();\n-                let llval = bx.const_struct(&values?, false);\n-                Ok((llval, c.ty))\n+                let llval = bx.const_struct(&values, false);\n+                (llval, c.ty)\n             })\n             .unwrap_or_else(|_| {\n                 bx.tcx().sess.span_err("}, {"sha": "73247c1469efd78c0554a9e3c8ce8da82578a8af", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -65,6 +65,7 @@ cfg_if! {\n         }\n \n         use std::ops::Add;\n+        use std::panic::{resume_unwind, catch_unwind, AssertUnwindSafe};\n \n         #[derive(Debug)]\n         pub struct Atomic<T: Copy>(Cell<T>);\n@@ -130,7 +131,21 @@ cfg_if! {\n         #[macro_export]\n         macro_rules! parallel {\n             ($($blocks:tt),*) => {\n-                $($blocks)*;\n+                // We catch panics here ensuring that all the blocks execute.\n+                // This makes behavior consistent with the parallel compiler.\n+                let mut panic = None;\n+                $(\n+                    if let Err(p) = ::std::panic::catch_unwind(\n+                        ::std::panic::AssertUnwindSafe(|| $blocks)\n+                    ) {\n+                        if panic.is_none() {\n+                            panic = Some(p);\n+                        }\n+                    }\n+                )*\n+                if let Some(panic) = panic {\n+                    ::std::panic::resume_unwind(panic);\n+                }\n             }\n         }\n \n@@ -140,6 +155,26 @@ cfg_if! {\n             t.into_iter()\n         }\n \n+        pub fn par_for_each_in<T: IntoIterator>(\n+            t: T,\n+            for_each:\n+                impl Fn(<<T as IntoIterator>::IntoIter as Iterator>::Item) + Sync + Send\n+        ) {\n+            // We catch panics here ensuring that all the loop iterations execute.\n+            // This makes behavior consistent with the parallel compiler.\n+            let mut panic = None;\n+            t.into_iter().for_each(|i| {\n+                if let Err(p) = catch_unwind(AssertUnwindSafe(|| for_each(i))) {\n+                    if panic.is_none() {\n+                        panic = Some(p);\n+                    }\n+                }\n+            });\n+            if let Some(panic) = panic {\n+                resume_unwind(panic);\n+            }\n+        }\n+\n         pub type MetadataRef = OwningRef<Box<dyn Erased>, [u8]>;\n \n         pub use std::rc::Rc as Lrc;\n@@ -278,23 +313,26 @@ cfg_if! {\n         use std::thread;\n         pub use rayon::{join, scope};\n \n+        /// Runs a list of blocks in parallel. The first block is executed immediately on\n+        /// the current thread. Use that for the longest running block.\n         #[macro_export]\n         macro_rules! parallel {\n-            (impl [$($c:tt,)*] [$block:tt $(, $rest:tt)*]) => {\n-                parallel!(impl [$block, $($c,)*] [$($rest),*])\n+            (impl $fblock:tt [$($c:tt,)*] [$block:tt $(, $rest:tt)*]) => {\n+                parallel!(impl $fblock [$block, $($c,)*] [$($rest),*])\n             };\n-            (impl [$($blocks:tt,)*] []) => {\n+            (impl $fblock:tt [$($blocks:tt,)*] []) => {\n                 ::rustc_data_structures::sync::scope(|s| {\n                     $(\n                         s.spawn(|_| $blocks);\n                     )*\n+                    $fblock;\n                 })\n             };\n-            ($($blocks:tt),*) => {\n-                // Reverse the order of the blocks since Rayon executes them in reverse order\n+            ($fblock:tt, $($blocks:tt),*) => {\n+                // Reverse the order of the later blocks since Rayon executes them in reverse order\n                 // when using a single thread. This ensures the execution order matches that\n                 // of a single threaded rustc\n-                parallel!(impl [] [$($blocks),*]);\n+                parallel!(impl $fblock [] [$($blocks),*]);\n             };\n         }\n \n@@ -307,6 +345,15 @@ cfg_if! {\n             t.into_par_iter()\n         }\n \n+        pub fn par_for_each_in<T: IntoParallelIterator>(\n+            t: T,\n+            for_each: impl Fn(\n+                <<T as IntoParallelIterator>::Iter as ParallelIterator>::Item\n+            ) + Sync + Send\n+        ) {\n+            t.into_par_iter().for_each(for_each)\n+        }\n+\n         pub type MetadataRef = OwningRef<Box<dyn Erased + Send + Sync>, [u8]>;\n \n         /// This makes locks panic if they are already held."}, {"sha": "8277615b46502352e8bb1657273e015df053f921", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -21,7 +21,7 @@ use rustc_borrowck as borrowck;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n use rustc_incremental;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n@@ -191,51 +191,50 @@ fn analysis<'tcx>(\n \n     let sess = tcx.sess;\n \n-    parallel!({\n-        time(sess, \"looking for entry point\", || {\n-            middle::entry::find_entry_point(tcx)\n-        });\n+    time(sess, \"misc checking 1\", || {\n+        parallel!({\n+            time(sess, \"looking for entry point\", || {\n+                middle::entry::find_entry_point(tcx)\n+            });\n \n-        time(sess, \"looking for plugin registrar\", || {\n-            plugin::build::find_plugin_registrar(tcx)\n-        });\n+            time(sess, \"looking for plugin registrar\", || {\n+                plugin::build::find_plugin_registrar(tcx)\n+            });\n \n-        time(sess, \"looking for derive registrar\", || {\n-            proc_macro_decls::find(tcx)\n-        });\n-    }, {\n-        time(sess, \"loop checking\", || loops::check_crate(tcx));\n-    }, {\n-        time(sess, \"attribute checking\", || {\n-            hir::check_attr::check_crate(tcx)\n-        });\n-    }, {\n-        time(sess, \"stability checking\", || {\n-            stability::check_unstable_api_usage(tcx)\n+            time(sess, \"looking for derive registrar\", || {\n+                proc_macro_decls::find(tcx)\n+            });\n+        }, {\n+            par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n+                tcx.ensure().check_mod_loops(tcx.hir().local_def_id(module));\n+                tcx.ensure().check_mod_attrs(tcx.hir().local_def_id(module));\n+                tcx.ensure().check_mod_unstable_api_usage(tcx.hir().local_def_id(module));\n+            });\n         });\n     });\n \n     // passes are timed inside typeck\n     typeck::check_crate(tcx)?;\n \n-    time(sess, \"misc checking\", || {\n+    time(sess, \"misc checking 2\", || {\n         parallel!({\n-            time(sess, \"rvalue promotion\", || {\n-                rvalue_promotion::check_crate(tcx)\n-            });\n-        }, {\n-            time(sess, \"intrinsic checking\", || {\n-                middle::intrinsicck::check_crate(tcx)\n+            time(sess, \"rvalue promotion + match checking\", || {\n+                tcx.par_body_owners(|def_id| {\n+                    tcx.ensure().const_is_rvalue_promotable_to_static(def_id);\n+                    tcx.ensure().check_match(def_id);\n+                });\n             });\n         }, {\n-            time(sess, \"match checking\", || mir::matchck_crate(tcx));\n-        }, {\n-            // this must run before MIR dump, because\n-            // \"not all control paths return a value\" is reported here.\n-            //\n-            // maybe move the check to a MIR pass?\n-            time(sess, \"liveness checking\", || {\n-                middle::liveness::check_crate(tcx)\n+            time(sess, \"liveness checking + intrinsic checking\", || {\n+                par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n+                    // this must run before MIR dump, because\n+                    // \"not all control paths return a value\" is reported here.\n+                    //\n+                    // maybe move the check to a MIR pass?\n+                    tcx.ensure().check_mod_liveness(tcx.hir().local_def_id(module));\n+\n+                    tcx.ensure().check_mod_intrinsics(tcx.hir().local_def_id(module));\n+                });\n             });\n         });\n     });\n@@ -276,19 +275,30 @@ fn analysis<'tcx>(\n         return Err(ErrorReported);\n     }\n \n-    time(sess, \"misc checking\", || {\n+    time(sess, \"misc checking 3\", || {\n         parallel!({\n-            time(sess, \"privacy checking\", || {\n-                rustc_privacy::check_crate(tcx)\n+            time(sess, \"privacy access levels\", || {\n+                tcx.ensure().privacy_access_levels(LOCAL_CRATE);\n             });\n-        }, {\n-            time(sess, \"death checking\", || middle::dead::check_crate(tcx));\n-        },  {\n-            time(sess, \"unused lib feature checking\", || {\n-                stability::check_unused_or_stable_features(tcx)\n+            parallel!({\n+                time(sess, \"private in public\", || {\n+                    tcx.ensure().check_private_in_public(LOCAL_CRATE);\n+                });\n+            }, {\n+                time(sess, \"death checking\", || middle::dead::check_crate(tcx));\n+            },  {\n+                time(sess, \"unused lib feature checking\", || {\n+                    stability::check_unused_or_stable_features(tcx)\n+                });\n+            }, {\n+                time(sess, \"lint checking\", || lint::check_crate(tcx));\n             });\n         }, {\n-            time(sess, \"lint checking\", || lint::check_crate(tcx));\n+            time(sess, \"privacy checking modules\", || {\n+                par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n+                    tcx.ensure().check_mod_privacy(tcx.hir().local_def_id(module));\n+                });\n+            });\n         });\n     });\n "}, {"sha": "c8e48dea1f34c2cb04bad10d663d71728a97272b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -579,6 +579,10 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // Not callable from C, so we can safely unwind through these\n     if abi == Abi::Rust || abi == Abi::RustCall { return false; }\n \n+    // Validate `#[unwind]` syntax regardless of platform-specific panic strategy\n+    let attrs = &tcx.get_attrs(fn_def_id);\n+    let unwind_attr = attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs);\n+\n     // We never unwind, so it's not relevant to stop an unwind\n     if tcx.sess.panic_strategy() != PanicStrategy::Unwind { return false; }\n \n@@ -587,8 +591,7 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     // This is a special case: some functions have a C abi but are meant to\n     // unwind anyway. Don't stop them.\n-    let attrs = &tcx.get_attrs(fn_def_id);\n-    match attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs) {\n+    match unwind_attr {\n         None => true,\n         Some(UnwindAttr::Allowed) => false,\n         Some(UnwindAttr::Aborts) => true,"}, {"sha": "365cb508b09253958b0b4a1543735b7c9a285235", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -466,45 +466,42 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n }\n \n /// Projects to a field of a (variant of a) const.\n+// this function uses `unwrap` copiously, because an already validated constant must have valid\n+// fields and can thus never fail outside of compiler bugs\n pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n     value: ty::Const<'tcx>,\n-) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n+) -> ty::Const<'tcx> {\n     trace!(\"const_field: {:?}, {:?}\", field, value);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let result = (|| {\n-        // get the operand again\n-        let op = ecx.const_to_op(value, None)?;\n-        // downcast\n-        let down = match variant {\n-            None => op,\n-            Some(variant) => ecx.operand_downcast(op, variant)?\n-        };\n-        // then project\n-        let field = ecx.operand_field(down, field.index() as u64)?;\n-        // and finally move back to the const world, always normalizing because\n-        // this is not called for statics.\n-        op_to_const(&ecx, field)\n-    })();\n-    result.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error);\n-        err.report_as_error(ecx.tcx, \"could not access field of constant\");\n-        ErrorHandled::Reported\n-    })\n+    // get the operand again\n+    let op = ecx.const_to_op(value, None).unwrap();\n+    // downcast\n+    let down = match variant {\n+        None => op,\n+        Some(variant) => ecx.operand_downcast(op, variant).unwrap(),\n+    };\n+    // then project\n+    let field = ecx.operand_field(down, field.index() as u64).unwrap();\n+    // and finally move back to the const world, always normalizing because\n+    // this is not called for statics.\n+    op_to_const(&ecx, field).unwrap()\n }\n \n+// this function uses `unwrap` copiously, because an already validated constant must have valid\n+// fields and can thus never fail outside of compiler bugs\n pub fn const_variant_index<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: ty::Const<'tcx>,\n-) -> EvalResult<'tcx, VariantIdx> {\n+) -> VariantIdx {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let op = ecx.const_to_op(val, None)?;\n-    Ok(ecx.read_discriminant(op)?.1)\n+    let op = ecx.const_to_op(val, None).unwrap();\n+    ecx.read_discriminant(op).unwrap().1\n }\n \n pub fn error_to_const_error<'a, 'mir, 'tcx>("}, {"sha": "ad0a22cc7827c9f3e2163ebc2cdd8d63d5ca7586", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -8,7 +8,6 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::mir::interpret::{GlobalId, ErrorHandled, ConstValue};\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n-use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n@@ -655,11 +654,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            let cast = if let Some(&TyCastKind::CoercionCast) =\n-                cx.tables()\n-                .cast_kinds()\n-                .get(source.hir_id)\n-            {\n+            let cast = if cx.tables().is_coercion_cast(source.hir_id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n             } else {"}, {"sha": "586a3fdb907ee7a1c4841ed4324a20a9128ce4bf", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -440,13 +440,7 @@ impl<'tcx> Constructor<'tcx> {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            &ConstantValue(c) => {\n-                crate::const_eval::const_variant_index(\n-                    cx.tcx,\n-                    cx.param_env,\n-                    c,\n-                ).unwrap()\n-            },\n+            &ConstantValue(c) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }"}, {"sha": "41babc1ad12ef84af80e5a78a7a87f941f96793c", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -27,13 +27,6 @@ use std::slice;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for def_id in tcx.body_owners() {\n-        tcx.ensure().check_match(def_id);\n-    }\n-    tcx.sess.abort_if_errors();\n-}\n-\n pub(crate) fn check_match<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,"}, {"sha": "67d40197290f17bb600725413b2b63c494c5f05a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -3,7 +3,6 @@\n mod _match;\n mod check_match;\n \n-pub use self::check_match::check_crate;\n pub(crate) use self::check_match::check_match;\n \n use crate::const_eval::{const_field, const_variant_index};\n@@ -937,10 +936,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n         let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n-            let val = const_field(\n-                self.tcx, self.param_env,\n-                variant_opt, field, cv,\n-            ).expect(\"field access failed\");\n+            let val = const_field(self.tcx, self.param_env, variant_opt, field, cv);\n             self.const_to_pat(instance, val, id, span)\n         };\n         let adt_subpatterns = |n, variant_opt| {\n@@ -979,9 +975,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let variant_index = const_variant_index(\n-                    self.tcx, self.param_env, cv\n-                ).expect(\"const_variant_index failed\");\n+                let variant_index = const_variant_index(self.tcx, self.param_env, cv);\n                 let subpatterns = adt_subpatterns(\n                     adt_def.variants[variant_index].fields.len(),\n                     Some(variant_index),"}, {"sha": "0b735b4b39cf5057302fd4e104372643b353b6fe", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -54,7 +54,6 @@ pub mod interpret;\n pub mod monomorphize;\n pub mod const_eval;\n \n-pub use hair::pattern::check_crate as matchck_crate;\n use rustc::ty::query::Providers;\n \n pub fn provide(providers: &mut Providers<'_>) {"}, {"sha": "97bbb0adb2d79ed803e73a0f1619c364b48b04c5", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -45,12 +45,6 @@ struct CheckLoopVisitor<'a, 'hir: 'a> {\n     cx: Context,\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_loops(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n fn check_mod_loops<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckLoopVisitor {\n         sess: &tcx.sess,"}, {"sha": "6de98675a3dc8cfa3815b47340a312c13b0999a1", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -14,7 +14,7 @@\n // - It's not possible to take the address of a static item with unsafe interior. This is enforced\n // by borrowck::gather_loans\n \n-use rustc::ty::cast::CastKind;\n+use rustc::ty::cast::CastTy;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n@@ -39,13 +39,6 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &body_id in &tcx.hir().krate().body_ids {\n-        let def_id = tcx.hir().body_owner_def_id(body_id);\n-        tcx.const_is_rvalue_promotable_to_static(def_id);\n-    }\n-}\n-\n fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   def_id: DefId)\n                                                   -> bool\n@@ -318,15 +311,12 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Cast(ref from, _) => {\n             let expr_promotability = v.check_expr(from);\n             debug!(\"Checking const cast(id={})\", from.hir_id);\n-            match v.tables.cast_kinds().get(from.hir_id) {\n-                None => {\n-                    v.tcx.sess.delay_span_bug(e.span, \"no kind for cast\");\n-                    NotPromotable\n-                },\n-                Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n-                    NotPromotable\n-                }\n-                _ => expr_promotability\n+            let cast_in = CastTy::from_ty(v.tables.expr_ty(from));\n+            let cast_out = CastTy::from_ty(v.tables.expr_ty(e));\n+            match (cast_in, cast_out) {\n+                (Some(CastTy::FnPtr), Some(CastTy::Int(_))) |\n+                (Some(CastTy::Ptr(_)), Some(CastTy::Int(_))) => NotPromotable,\n+                (_, _) => expr_promotability\n             }\n         }\n         hir::ExprKind::Path(ref qpath) => {"}, {"sha": "52514a3ca97d67ab6a8eba9f555c2ff0a46ebcee", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -1766,19 +1766,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         privacy_access_levels,\n+        check_private_in_public,\n         check_mod_privacy,\n         ..*providers\n     };\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Lrc<AccessLevels> {\n-    tcx.privacy_access_levels(LOCAL_CRATE)\n-}\n-\n fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     let empty_tables = ty::TypeckTables::empty(None);\n \n-\n     // Check privacy of names not checked in previous compilation stages.\n     let mut visitor = NamePrivacyVisitor {\n         tcx,\n@@ -1809,18 +1805,6 @@ fn privacy_access_levels<'tcx>(\n ) -> Lrc<AccessLevels> {\n     assert_eq!(krate, LOCAL_CRATE);\n \n-    let krate = tcx.hir().krate();\n-\n-    for &module in krate.modules.keys() {\n-        tcx.ensure().check_mod_privacy(tcx.hir().local_def_id(module));\n-    }\n-\n-    let private_crates: FxHashSet<CrateNum> = tcx.sess.opts.extern_private.iter()\n-        .flat_map(|c| {\n-            tcx.crates().iter().find(|&&krate| &tcx.crate_name(krate) == c).cloned()\n-        }).collect();\n-\n-\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n@@ -1830,7 +1814,7 @@ fn privacy_access_levels<'tcx>(\n         changed: false,\n     };\n     loop {\n-        intravisit::walk_crate(&mut visitor, krate);\n+        intravisit::walk_crate(&mut visitor, tcx.hir().krate());\n         if visitor.changed {\n             visitor.changed = false;\n         } else {\n@@ -1839,36 +1823,46 @@ fn privacy_access_levels<'tcx>(\n     }\n     visitor.update(hir::CRATE_HIR_ID, Some(AccessLevel::Public));\n \n-    {\n-        let mut visitor = ObsoleteVisiblePrivateTypesVisitor {\n-            tcx,\n-            access_levels: &visitor.access_levels,\n-            in_variant: false,\n-            old_error_set: Default::default(),\n-        };\n-        intravisit::walk_crate(&mut visitor, krate);\n+    Lrc::new(visitor.access_levels)\n+}\n \n+fn check_private_in_public<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, krate: CrateNum) {\n+    assert_eq!(krate, LOCAL_CRATE);\n \n-        let has_pub_restricted = {\n-            let mut pub_restricted_visitor = PubRestrictedVisitor {\n-                tcx,\n-                has_pub_restricted: false\n-            };\n-            intravisit::walk_crate(&mut pub_restricted_visitor, krate);\n-            pub_restricted_visitor.has_pub_restricted\n-        };\n+    let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n \n-        // Check for private types and traits in public interfaces.\n-        let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+    let krate = tcx.hir().krate();\n+\n+    let mut visitor = ObsoleteVisiblePrivateTypesVisitor {\n+        tcx,\n+        access_levels: &access_levels,\n+        in_variant: false,\n+        old_error_set: Default::default(),\n+    };\n+    intravisit::walk_crate(&mut visitor, krate);\n+\n+    let has_pub_restricted = {\n+        let mut pub_restricted_visitor = PubRestrictedVisitor {\n             tcx,\n-            has_pub_restricted,\n-            old_error_set: &visitor.old_error_set,\n-            private_crates\n+            has_pub_restricted: false\n         };\n-        krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n-    }\n+        intravisit::walk_crate(&mut pub_restricted_visitor, krate);\n+        pub_restricted_visitor.has_pub_restricted\n+    };\n \n-    Lrc::new(visitor.access_levels)\n+    let private_crates: FxHashSet<CrateNum> = tcx.sess.opts.extern_private.iter()\n+        .flat_map(|c| {\n+            tcx.crates().iter().find(|&&krate| &tcx.crate_name(krate) == c).cloned()\n+        }).collect();\n+\n+    // Check for private types and traits in public interfaces.\n+    let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+        tcx,\n+        has_pub_restricted,\n+        old_error_set: &visitor.old_error_set,\n+        private_crates\n+    };\n+    krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n }\n \n __build_diagnostic_array! { librustc_privacy, DIAGNOSTICS }"}, {"sha": "cad9e73bd2ac99b01d49c21019fde19e44070975", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -428,13 +428,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n             debug!(\" -> CoercionCast\");\n-            fcx.tables.borrow_mut().cast_kinds_mut().insert(self.expr.hir_id,\n-                                                            CastKind::CoercionCast);\n+            fcx.tables.borrow_mut().set_coercion_cast(self.expr.hir_id.local_id);\n+\n         } else {\n             match self.do_check(fcx) {\n                 Ok(k) => {\n                     debug!(\" -> {:?}\", k);\n-                    fcx.tables.borrow_mut().cast_kinds_mut().insert(self.expr.hir_id, k);\n                 }\n                 Err(e) => self.report_cast_error(fcx, e),\n             };"}, {"sha": "28c79ce0c74e86c77ad9634838a21a9a9f8b061f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -694,26 +694,14 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n-        tcx.hir().krate().visit_all_item_likes(&mut visit);\n-    })\n-}\n-\n-pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n-    tcx.sess.track_errors(|| {\n-        for &module in tcx.hir().krate().modules.keys() {\n-            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n-        }\n+        tcx.hir().krate().par_visit_all_item_likes(&mut visit);\n     })\n }\n \n fn check_mod_item_types<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n }\n \n-pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n-    tcx.typeck_item_bodies(LOCAL_CRATE)\n-}\n-\n fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n                                 -> Result<(), ErrorReported>\n {"}, {"sha": "fde940eb2c111fe1f92384ae86d17a8da2117dc4", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -15,7 +15,7 @@ use syntax::feature_gate::{self, GateIssue};\n use syntax_pos::Span;\n use errors::{DiagnosticBuilder, DiagnosticId};\n \n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::itemlikevisit::ParItemLikeVisitor;\n use rustc::hir;\n \n /// Helper type of a temporary returned by `.for_item(...)`.\n@@ -1061,20 +1061,20 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n     }\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &'tcx hir::Item) {\n+impl<'a, 'tcx> ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n+    fn visit_item(&self, i: &'tcx hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(i.hir_id);\n         self.tcx.ensure().check_item_well_formed(def_id);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&self, trait_item: &'tcx hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n         self.tcx.ensure().check_trait_item_well_formed(def_id);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&self, impl_item: &'tcx hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n         self.tcx.ensure().check_impl_item_well_formed(def_id);"}, {"sha": "d001545d1d9152e345a6a9e5e2c9de4c7fb89b09", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n         wbcx.visit_opaque_types(body.value.span);\n-        wbcx.visit_cast_types();\n+        wbcx.visit_coercion_casts();\n         wbcx.visit_free_region_map();\n         wbcx.visit_user_provided_tys();\n         wbcx.visit_user_provided_sigs();\n@@ -355,19 +355,13 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_cast_types(&mut self) {\n+    fn visit_coercion_casts(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        let fcx_cast_kinds = fcx_tables.cast_kinds();\n+        let fcx_coercion_casts = fcx_tables.coercion_casts();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let mut self_cast_kinds = self.tables.cast_kinds_mut();\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n \n-        for (&local_id, &cast_kind) in fcx_cast_kinds.iter() {\n-            let hir_id = hir::HirId {\n-                owner: common_local_id_root.index,\n-                local_id,\n-            };\n-            self_cast_kinds.insert(hir_id, cast_kind);\n+        for local_id in fcx_coercion_casts {\n+            self.tables.set_coercion_cast(*local_id);\n         }\n     }\n "}, {"sha": "39a2f5d37bd7ab32b596562c0e057b5c0362d9a5", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -141,9 +141,7 @@ fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     for &impl_id in impls {\n         check_impl_overlap(tcx, impl_id);\n     }\n-    use rustc::util::common::time;\n-    time(tcx.sess, \"builtin::check_trait checking\", ||\n-          builtin::check_trait(tcx, def_id));\n+    builtin::check_trait(tcx, def_id);\n }\n \n pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "afe658767f327baca033a8e8e72eaa45c5f2b0a7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -56,12 +56,6 @@ struct OnlySelfBounds(bool);\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-pub fn collect_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id(module));\n-    }\n-}\n-\n fn collect_mod_item_types<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,"}, {"sha": "ebb617c23c6ca72ee85d3f84a411d3b8b2928b16", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -322,8 +322,11 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.track_errors(|| {\n-        time(tcx.sess, \"type collecting\", ||\n-             collect::collect_item_types(tcx));\n+        time(tcx.sess, \"type collecting\", || {\n+            for &module in tcx.hir().krate().modules.keys() {\n+                tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id(module));\n+            }\n+        });\n     })?;\n \n     if tcx.features().rustc_attrs {\n@@ -352,9 +355,15 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     time(tcx.sess, \"wf checking\", || check::check_wf_new(tcx))?;\n \n-    time(tcx.sess, \"item-types checking\", || check::check_item_types(tcx))?;\n+    time(tcx.sess, \"item-types checking\", || {\n+        tcx.sess.track_errors(|| {\n+            for &module in tcx.hir().krate().modules.keys() {\n+                tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n+            }\n+        })\n+    })?;\n \n-    time(tcx.sess, \"item-bodies checking\", || check::check_item_bodies(tcx))?;\n+    time(tcx.sess, \"item-bodies checking\", || tcx.typeck_item_bodies(LOCAL_CRATE))?;\n \n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);"}, {"sha": "aeff78350d37cadd4749b13fdf76bff89ac68290", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -85,6 +85,9 @@ pub struct Options {\n     /// Whether to display warnings during doc generation or while gathering doctests. By default,\n     /// all non-rustdoc-specific lints are allowed when generating docs.\n     pub display_warnings: bool,\n+    /// Whether to run the `calculate-doc-coverage` pass, which counts the number of public items\n+    /// with and without documentation.\n+    pub show_coverage: bool,\n \n     // Options that alter generated documentation pages\n \n@@ -128,6 +131,7 @@ impl fmt::Debug for Options {\n             .field(\"default_passes\", &self.default_passes)\n             .field(\"manual_passes\", &self.manual_passes)\n             .field(\"display_warnings\", &self.display_warnings)\n+            .field(\"show_coverage\", &self.show_coverage)\n             .field(\"crate_version\", &self.crate_version)\n             .field(\"render_options\", &self.render_options)\n             .finish()\n@@ -224,6 +228,18 @@ impl Options {\n             for &name in passes::DEFAULT_PRIVATE_PASSES {\n                 println!(\"{:>20}\", name);\n             }\n+\n+            if nightly_options::is_nightly_build() {\n+                println!(\"\\nPasses run with `--show-coverage`:\");\n+                for &name in passes::DEFAULT_COVERAGE_PASSES {\n+                    println!(\"{:>20}\", name);\n+                }\n+                println!(\"\\nPasses run with `--show-coverage --document-private-items`:\");\n+                for &name in passes::PRIVATE_COVERAGE_PASSES {\n+                    println!(\"{:>20}\", name);\n+                }\n+            }\n+\n             return Err(0);\n         }\n \n@@ -413,9 +429,16 @@ impl Options {\n             }\n         });\n \n+        let show_coverage = matches.opt_present(\"show-coverage\");\n+        let document_private = matches.opt_present(\"document-private-items\");\n+\n         let default_passes = if matches.opt_present(\"no-defaults\") {\n             passes::DefaultPassOption::None\n-        } else if matches.opt_present(\"document-private-items\") {\n+        } else if show_coverage && document_private {\n+            passes::DefaultPassOption::PrivateCoverage\n+        } else if show_coverage {\n+            passes::DefaultPassOption::Coverage\n+        } else if document_private {\n             passes::DefaultPassOption::Private\n         } else {\n             passes::DefaultPassOption::Default\n@@ -463,6 +486,7 @@ impl Options {\n             default_passes,\n             manual_passes,\n             display_warnings,\n+            show_coverage,\n             crate_version,\n             persist_doctests,\n             render_options: RenderOptions {"}, {"sha": "373856319f1f32a8945f80dbdf2b542e6387ade5", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -617,10 +617,13 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n             info!(\"Executing passes\");\n \n-            for pass in &passes {\n-                match passes::find_pass(pass).map(|p| p.pass) {\n-                    Some(pass) => krate = pass(krate, &ctxt),\n-                    None => error!(\"unknown pass {}, skipping\", *pass),\n+            for pass_name in &passes {\n+                match passes::find_pass(pass_name).map(|p| p.pass) {\n+                    Some(pass) => {\n+                        debug!(\"running pass {}\", pass_name);\n+                        krate = pass(krate, &ctxt);\n+                    }\n+                    None => error!(\"unknown pass {}, skipping\", *pass_name),\n                 }\n             }\n "}, {"sha": "366e60b3ad9206e89282d7806dfcd69ee3cc7852", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -15,7 +15,7 @@ use crate::clean;\n /// module headings. If you are adding to this enum and want to ensure that the sidebar also prints\n /// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n /// ordering based on a helper function inside `item_module`, in the same file.\n-#[derive(Copy, PartialEq, Clone, Debug)]\n+#[derive(Copy, PartialEq, Eq, Clone, Debug, PartialOrd, Ord)]\n pub enum ItemType {\n     Module          = 0,\n     ExternCrate     = 1,"}, {"sha": "2a0ef3222ab8eff56b878dee1551e42c460f4ba8", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -348,6 +348,11 @@ fn opts() -> Vec<RustcOptGroup> {\n                       \"generate-redirect-pages\",\n                       \"Generate extra pages to support legacy URLs and tool links\")\n         }),\n+        unstable(\"show-coverage\", |o| {\n+            o.optflag(\"\",\n+                      \"show-coverage\",\n+                      \"calculate percentage of public items with documentation\")\n+        }),\n     ]\n }\n \n@@ -392,7 +397,14 @@ fn main_args(args: &[String]) -> isize {\n     let diag_opts = (options.error_format,\n                      options.debugging_options.treat_err_as_bug,\n                      options.debugging_options.ui_testing);\n+    let show_coverage = options.show_coverage;\n     rust_input(options, move |out| {\n+        if show_coverage {\n+            // if we ran coverage, bail early, we don't need to also generate docs at this point\n+            // (also we didn't load in any of the useful passes)\n+            return rustc_driver::EXIT_SUCCESS;\n+        }\n+\n         let Output { krate, passes, renderinfo, renderopts } = out;\n         info!(\"going to format\");\n         let (error_format, treat_err_as_bug, ui_testing) = diag_opts;"}, {"sha": "04f403888c1fbaab783208057e1a6c6fa96653ed", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,166 @@\n+use crate::clean;\n+use crate::core::DocContext;\n+use crate::fold::{self, DocFolder};\n+use crate::passes::Pass;\n+\n+use syntax::attr;\n+use syntax_pos::FileName;\n+\n+use std::collections::BTreeMap;\n+use std::ops;\n+\n+pub const CALCULATE_DOC_COVERAGE: Pass = Pass {\n+    name: \"calculate-doc-coverage\",\n+    pass: calculate_doc_coverage,\n+    description: \"counts the number of items with and without documentation\",\n+};\n+\n+fn calculate_doc_coverage(krate: clean::Crate, _: &DocContext<'_, '_, '_>) -> clean::Crate {\n+    let mut calc = CoverageCalculator::default();\n+    let krate = calc.fold_crate(krate);\n+\n+    calc.print_results();\n+\n+    krate\n+}\n+\n+#[derive(Default, Copy, Clone)]\n+struct ItemCount {\n+    total: u64,\n+    with_docs: u64,\n+}\n+\n+impl ItemCount {\n+    fn count_item(&mut self, has_docs: bool) {\n+        self.total += 1;\n+\n+        if has_docs {\n+            self.with_docs += 1;\n+        }\n+    }\n+\n+    fn percentage(&self) -> Option<f64> {\n+        if self.total > 0 {\n+            Some((self.with_docs as f64 * 100.0) / self.total as f64)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl ops::Sub for ItemCount {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        ItemCount {\n+            total: self.total - rhs.total,\n+            with_docs: self.with_docs - rhs.with_docs,\n+        }\n+    }\n+}\n+\n+impl ops::AddAssign for ItemCount {\n+    fn add_assign(&mut self, rhs: Self) {\n+        self.total += rhs.total;\n+        self.with_docs += rhs.with_docs;\n+    }\n+}\n+\n+#[derive(Default)]\n+struct CoverageCalculator {\n+    items: BTreeMap<FileName, ItemCount>,\n+}\n+\n+impl CoverageCalculator {\n+    fn print_results(&self) {\n+        let mut total = ItemCount::default();\n+\n+        fn print_table_line() {\n+            println!(\"+-{0:->35}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n+        }\n+\n+        fn print_table_record(name: &str, count: ItemCount, percentage: f64) {\n+            println!(\"| {:<35} | {:>10} | {:>10} | {:>9.1}% |\",\n+                     name, count.with_docs, count.total, percentage);\n+        }\n+\n+        print_table_line();\n+        println!(\"| {:<35} | {:>10} | {:>10} | {:>10} |\",\n+                 \"File\", \"Documented\", \"Total\", \"Percentage\");\n+        print_table_line();\n+\n+        for (file, &count) in &self.items {\n+            if let Some(percentage) = count.percentage() {\n+                let mut name = file.to_string();\n+                // if a filename is too long, shorten it so we don't blow out the table\n+                // FIXME(misdreavus): this needs to count graphemes, and probably also track\n+                // double-wide characters...\n+                if name.len() > 35 {\n+                    name = \"...\".to_string() + &name[name.len()-32..];\n+                }\n+\n+                print_table_record(&name, count, percentage);\n+\n+                total += count;\n+            }\n+        }\n+\n+        print_table_line();\n+        print_table_record(\"Total\", total, total.percentage().unwrap_or(0.0));\n+        print_table_line();\n+    }\n+}\n+\n+impl fold::DocFolder for CoverageCalculator {\n+    fn fold_item(&mut self, i: clean::Item) -> Option<clean::Item> {\n+        let has_docs = !i.attrs.doc_strings.is_empty();\n+\n+        match i.inner {\n+            _ if !i.def_id.is_local() => {\n+                // non-local items are skipped because they can be out of the users control,\n+                // especially in the case of trait impls, which rustdoc eagerly inlines\n+                return Some(i);\n+            }\n+            clean::StrippedItem(..) => {\n+                // don't count items in stripped modules\n+                return Some(i);\n+            }\n+            clean::ImportItem(..) | clean::ExternCrateItem(..) => {\n+                // docs on `use` and `extern crate` statements are not displayed, so they're not\n+                // worth counting\n+                return Some(i);\n+            }\n+            clean::ImplItem(ref impl_)\n+                if attr::contains_name(&i.attrs.other_attrs, \"automatically_derived\")\n+                    || impl_.synthetic || impl_.blanket_impl.is_some() =>\n+            {\n+                // built-in derives get the `#[automatically_derived]` attribute, and\n+                // synthetic/blanket impls are made up by rustdoc and can't be documented\n+                // FIXME(misdreavus): need to also find items that came out of a derive macro\n+                return Some(i);\n+            }\n+            clean::ImplItem(ref impl_) => {\n+                if let Some(ref tr) = impl_.trait_ {\n+                    debug!(\"impl {:#} for {:#} in {}\", tr, impl_.for_, i.source.filename);\n+\n+                    // don't count trait impls, the missing-docs lint doesn't so we shouldn't\n+                    // either\n+                    return Some(i);\n+                } else {\n+                    // inherent impls *can* be documented, and those docs show up, but in most\n+                    // cases it doesn't make sense, as all methods on a type are in one single\n+                    // impl block\n+                    debug!(\"impl {:#} in {}\", impl_.for_, i.source.filename);\n+                }\n+            }\n+            _ => {\n+                debug!(\"counting {} {:?} in {}\", i.type_(), i.name, i.source.filename);\n+                self.items.entry(i.source.filename.clone())\n+                          .or_default()\n+                          .count_item(has_docs);\n+            }\n+        }\n+\n+        self.fold_item_recur(i)\n+    }\n+}"}, {"sha": "3b0aebe53f38fc69199c0a57ebd101d43d79b992", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -45,6 +45,9 @@ pub use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n mod check_code_block_syntax;\n pub use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n \n+mod calculate_doc_coverage;\n+pub use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n+\n /// A single pass over the cleaned documentation.\n ///\n /// Runs in the compiler context, so it has access to types and traits and the like.\n@@ -67,6 +70,7 @@ pub const PASSES: &'static [Pass] = &[\n     COLLECT_INTRA_DOC_LINKS,\n     CHECK_CODE_BLOCK_SYNTAX,\n     COLLECT_TRAIT_IMPLS,\n+    CALCULATE_DOC_COVERAGE,\n ];\n \n /// The list of passes run by default.\n@@ -94,12 +98,29 @@ pub const DEFAULT_PRIVATE_PASSES: &[&str] = &[\n     \"propagate-doc-cfg\",\n ];\n \n+/// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n+pub const DEFAULT_COVERAGE_PASSES: &'static [&'static str] = &[\n+    \"collect-trait-impls\",\n+    \"strip-hidden\",\n+    \"strip-private\",\n+    \"calculate-doc-coverage\",\n+];\n+\n+/// The list of default passes run when `--doc-coverage --document-private-items` is passed to\n+/// rustdoc.\n+pub const PRIVATE_COVERAGE_PASSES: &'static [&'static str] = &[\n+    \"collect-trait-impls\",\n+    \"calculate-doc-coverage\",\n+];\n+\n /// A shorthand way to refer to which set of passes to use, based on the presence of\n /// `--no-defaults` or `--document-private-items`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DefaultPassOption {\n     Default,\n     Private,\n+    Coverage,\n+    PrivateCoverage,\n     None,\n }\n \n@@ -108,6 +129,8 @@ pub fn defaults(default_set: DefaultPassOption) -> &'static [&'static str] {\n     match default_set {\n         DefaultPassOption::Default => DEFAULT_PASSES,\n         DefaultPassOption::Private => DEFAULT_PRIVATE_PASSES,\n+        DefaultPassOption::Coverage => DEFAULT_COVERAGE_PASSES,\n+        DefaultPassOption::PrivateCoverage => PRIVATE_COVERAGE_PASSES,\n         DefaultPassOption::None => &[],\n     }\n }"}, {"sha": "ce0c5c0bb0dc7d25dad48eaf0c3e83e763dc49fc", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -1742,21 +1742,6 @@ mod tests {\n         })\n     }\n \n-    #[test]\n-    fn connect_timeout_unbound() {\n-        // bind and drop a socket to track down a \"probably unassigned\" port\n-        let socket = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n-        let addr = socket.local_addr().unwrap();\n-        drop(socket);\n-\n-        let timeout = Duration::from_secs(1);\n-        let e = TcpStream::connect_timeout(&addr, timeout).unwrap_err();\n-        assert!(e.kind() == io::ErrorKind::ConnectionRefused ||\n-                e.kind() == io::ErrorKind::TimedOut ||\n-                e.kind() == io::ErrorKind::Other,\n-                \"bad error: {} {:?}\", e, e.kind());\n-    }\n-\n     #[test]\n     fn connect_timeout_valid() {\n         let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();"}, {"sha": "f7a000935caf0e05c7d7e71551a2efe7b9e8099c", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -7,7 +7,7 @@ use crate::parse::ParseSess;\n use errors::{Applicability, Handler};\n use syntax_pos::{symbol::Symbol, Span};\n \n-use super::{list_contains_name, mark_used, MetaItemKind};\n+use super::{mark_used, MetaItemKind};\n \n enum AttrError {\n     MultipleItem(Name),\n@@ -79,40 +79,26 @@ pub enum UnwindAttr {\n \n /// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n-    let syntax_error = |attr: &Attribute| {\n-        mark_used(attr);\n-        diagnostic.map(|d| {\n-            span_err!(d, attr.span, E0633, \"malformed `#[unwind]` attribute\");\n-        });\n-        None\n-    };\n-\n     attrs.iter().fold(None, |ia, attr| {\n-        if attr.path != \"unwind\" {\n-            return ia;\n-        }\n-        let meta = match attr.meta() {\n-            Some(meta) => meta.node,\n-            None => return ia,\n-        };\n-        match meta {\n-            MetaItemKind::Word => {\n-                syntax_error(attr)\n-            }\n-            MetaItemKind::List(ref items) => {\n-                mark_used(attr);\n-                if items.len() != 1 {\n-                    syntax_error(attr)\n-                } else if list_contains_name(&items[..], \"allowed\") {\n-                    Some(UnwindAttr::Allowed)\n-                } else if list_contains_name(&items[..], \"aborts\") {\n-                    Some(UnwindAttr::Aborts)\n-                } else {\n-                    syntax_error(attr)\n+        if attr.check_name(\"unwind\") {\n+            if let Some(meta) = attr.meta() {\n+                if let MetaItemKind::List(items) = meta.node {\n+                    if items.len() == 1 {\n+                        if items[0].check_name(\"allowed\") {\n+                            return Some(UnwindAttr::Allowed);\n+                        } else if items[0].check_name(\"aborts\") {\n+                            return Some(UnwindAttr::Aborts);\n+                        }\n+                    }\n+\n+                    diagnostic.map(|d| {\n+                        span_err!(d, attr.span, E0633, \"malformed `#[unwind]` attribute\");\n+                    });\n                 }\n             }\n-            _ => ia,\n         }\n+\n+        ia\n     })\n }\n "}, {"sha": "279e2089f5d71c121824434c36e279483400abb2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -1176,7 +1176,7 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n            \"dropck_eyepatch\",\n            \"may_dangle has unstable semantics and may be removed in the future\",\n            cfg_fn!(dropck_eyepatch))),\n-    (\"unwind\", Whitelisted, template!(List: \"allowed\"), Gated(Stability::Unstable,\n+    (\"unwind\", Whitelisted, template!(List: \"allowed|aborts\"), Gated(Stability::Unstable,\n                                   \"unwind_attributes\",\n                                   \"#[unwind] is experimental\",\n                                   cfg_fn!(unwind_attributes))),"}, {"sha": "371e8fe5cf66fd5c431fd6b95a55ad9f2dba98f5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -185,7 +185,7 @@ pub fn maybe_new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path)\n /// Given a session, a crate config, a path, and a span, add\n /// the file at the given path to the source_map, and return a parser.\n /// On an error, use the given span as the source of the problem.\n-crate fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n+pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n                                     path: &Path,\n                                     directory_ownership: DirectoryOwnership,\n                                     module_name: Option<String>,"}, {"sha": "8c5f67a66043e39fa454a3deda30176e908b9e36", "filename": "src/test/debuginfo/empty-string.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fdebuginfo%2Fempty-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fdebuginfo%2Fempty-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fempty-string.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,35 @@\n+// ignore-windows failing on win32 bot\n+// ignore-android: FIXME(#10381)\n+// compile-flags:-g\n+// min-gdb-version: 7.7\n+// min-lldb-version: 310\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command: run\n+\n+// gdb-command: print empty_string\n+// gdb-check:$1 = \"\"\n+\n+// gdb-command: print empty_str\n+// gdb-check:$2 = \"\"\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command: run\n+\n+// lldb-command: fr v empty_string\n+// lldb-check:[...]empty_string = \"\"\n+\n+// lldb-command: fr v empty_str\n+// lldb-check:[...]empty_str = \"\"\n+\n+fn main() {\n+    let empty_string = String::new();\n+\n+    let empty_str = \"\";\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {}"}, {"sha": "91624e92fbe753ad0801e589095e72f008ab8465", "filename": "src/test/run-pass/consts/const-ptr-nonnull.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-ptr-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-ptr-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-ptr-nonnull.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(const_ptr_nonnull)]\n+\n+use std::ptr::NonNull;\n+\n+const DANGLING: NonNull<u32> = NonNull::dangling();\n+const CASTED: NonNull<u32> = NonNull::cast(NonNull::<i32>::dangling());\n+\n+fn ident<T>(ident: T) -> T {\n+    ident\n+}\n+\n+pub fn main() {\n+    assert_eq!(DANGLING, ident(NonNull::dangling()));\n+    assert_eq!(CASTED, ident(NonNull::dangling()));\n+}"}, {"sha": "eb371ab184166491e039136ed2d4ae954be90c8d", "filename": "src/test/run-pass/consts/const-ptr-unique.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-ptr-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-ptr-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-ptr-unique.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(ptr_internals)]\n+\n+use std::ptr::Unique;\n+\n+const PTR: *mut u32 = Unique::empty().as_ptr();\n+\n+fn ident<T>(ident: T) -> T {\n+    ident\n+}\n+\n+pub fn main() {\n+    assert_eq!(PTR, ident(Unique::<u32>::empty().as_ptr()));\n+}"}, {"sha": "4247fdf989556ffaea6c2a30c51d5e16d394905a", "filename": "src/test/rustdoc-ui/coverage/basic.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,50 @@\n+// compile-flags:-Z unstable-options --show-coverage\n+// compile-pass\n+\n+#![feature(extern_types)]\n+\n+//! Make sure to have some docs on your crate root\n+\n+/// This struct is documented, but its fields are not.\n+///\n+/// However, one field is private, so it shouldn't show in the total.\n+pub struct SomeStruct {\n+    pub some_field: usize,\n+    other_field: usize,\n+}\n+\n+impl SomeStruct {\n+    /// Method with docs\n+    pub fn this_fn(&self) {}\n+\n+    // Method without docs\n+    pub fn other_method(&self) {}\n+}\n+\n+// struct without docs\n+pub struct OtherStruct;\n+\n+// function with no docs\n+pub fn some_fn() {}\n+\n+/// Function with docs\n+pub fn other_fn() {}\n+\n+pub enum SomeEnum {\n+    /// Some of these variants are documented...\n+    VarOne,\n+    /// ...but some of them are not.\n+    VarTwo,\n+    // (like this one)\n+    VarThree,\n+}\n+\n+/// There's a macro here, too\n+#[macro_export]\n+macro_rules! some_macro {\n+    () => {};\n+}\n+\n+extern {\n+    pub type ExternType;\n+}"}, {"sha": "3e916606316260bcb727f53bf3cb7b98a957d6ce", "filename": "src/test/rustdoc-ui/coverage/basic.stdout", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.stdout?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,7 @@\n++-------------------------------------+------------+------------+------------+\n+| File                                | Documented |      Total | Percentage |\n++-------------------------------------+------------+------------+------------+\n+| ...est/rustdoc-ui/coverage/basic.rs |          7 |         14 |      50.0% |\n++-------------------------------------+------------+------------+------------+\n+| Total                               |          7 |         14 |      50.0% |\n++-------------------------------------+------------+------------+------------+"}, {"sha": "463617a1143df4795a7829b884577fa2a5724fa8", "filename": "src/test/rustdoc-ui/coverage/empty.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags:-Z unstable-options --show-coverage\n+// compile-pass\n+\n+// an empty crate still has one item to document: the crate root"}, {"sha": "11b514fbfeaef524c8df4601a81f5b765b1238db", "filename": "src/test/rustdoc-ui/coverage/empty.stdout", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.stdout?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,7 @@\n++-------------------------------------+------------+------------+------------+\n+| File                                | Documented |      Total | Percentage |\n++-------------------------------------+------------+------------+------------+\n+| ...est/rustdoc-ui/coverage/empty.rs |          0 |          1 |       0.0% |\n++-------------------------------------+------------+------------+------------+\n+| Total                               |          0 |          1 |       0.0% |\n++-------------------------------------+------------+------------+------------+"}, {"sha": "5cd7f490d1a9a82c593d81cf4bf2fcbea7d60b02", "filename": "src/test/rustdoc-ui/coverage/enums.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags:-Z unstable-options --show-coverage\n+// compile-pass\n+\n+//! (remember the crate root is still a module)\n+\n+/// so check out this enum here\n+pub enum ThisEnum {\n+    /// this variant has some weird stuff going on\n+    VarOne {\n+        /// like, it has some named fields inside\n+        field_one: usize,\n+        // (these show up as struct fields)\n+        field_two: usize,\n+    },\n+    /// here's another variant for you\n+    VarTwo(String),\n+    // but not all of them need to be documented as thoroughly\n+    VarThree,\n+}\n+\n+/// uninhabited enums? sure, let's throw one of those around\n+pub enum OtherEnum {}"}, {"sha": "87e2ad9f20df68ed54b97aeecb32cbe19acfadce", "filename": "src/test/rustdoc-ui/coverage/enums.stdout", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.stdout?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,7 @@\n++-------------------------------------+------------+------------+------------+\n+| File                                | Documented |      Total | Percentage |\n++-------------------------------------+------------+------------+------------+\n+| ...est/rustdoc-ui/coverage/enums.rs |          6 |          8 |      75.0% |\n++-------------------------------------+------------+------------+------------+\n+| Total                               |          6 |          8 |      75.0% |\n++-------------------------------------+------------+------------+------------+"}, {"sha": "b4adf45b90b8af983caf762c7dc32142d62f4f21", "filename": "src/test/rustdoc-ui/coverage/exotic.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags:-Z unstable-options --show-coverage\n+// compile-pass\n+\n+#![feature(doc_keyword)]\n+\n+//! the features only used in std also have entries in the table, so make sure those get pulled out\n+//! properly as well\n+\n+/// woo, check it out, we can write our own primitive docs lol\n+#[doc(primitive=\"unit\")]\n+mod prim_unit {}\n+\n+/// keywords? sure, pile them on\n+#[doc(keyword=\"where\")]\n+mod where_keyword {}"}, {"sha": "2bacfcfcecabe497df43805f3fc59e44dabcb39f", "filename": "src/test/rustdoc-ui/coverage/exotic.stdout", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.stdout?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,8 @@\n++-------------------------------------+------------+------------+------------+\n+| File                                | Documented |      Total | Percentage |\n++-------------------------------------+------------+------------+------------+\n+| ...st/rustdoc-ui/coverage/exotic.rs |          1 |          1 |     100.0% |\n+| <anon>                              |          2 |          2 |     100.0% |\n++-------------------------------------+------------+------------+------------+\n+| Total                               |          3 |          3 |     100.0% |\n++-------------------------------------+------------+------------+------------+"}, {"sha": "9024185856daaec0fe9c91e31f1aed6d6f1d9610", "filename": "src/test/rustdoc-ui/coverage/private.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags:-Z unstable-options --show-coverage --document-private-items\n+// compile-pass\n+\n+#![allow(unused)]\n+\n+//! when `--document-private-items` is passed, nothing is safe. everything must have docs or your\n+//! score will suffer the consequences\n+\n+mod this_mod {\n+    fn private_fn() {}\n+}\n+\n+/// See, our public items have docs!\n+pub struct SomeStruct {\n+    /// Look, all perfectly documented!\n+    pub field: usize,\n+    other: usize,\n+}\n+\n+/// Nothing shady going on here. Just a bunch of well-documented code. (cough)\n+pub fn public_fn() {}"}, {"sha": "0d4c7c68fd05e0b8eb93702a70fc04324e855c05", "filename": "src/test/rustdoc-ui/coverage/private.stdout", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.stdout?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,7 @@\n++-------------------------------------+------------+------------+------------+\n+| File                                | Documented |      Total | Percentage |\n++-------------------------------------+------------+------------+------------+\n+| ...t/rustdoc-ui/coverage/private.rs |          4 |          7 |      57.1% |\n++-------------------------------------+------------+------------+------------+\n+| Total                               |          4 |          7 |      57.1% |\n++-------------------------------------+------------+------------+------------+"}, {"sha": "3c1dd35dfe1ab8a66a59c7e9b783d496c10e24e1", "filename": "src/test/rustdoc-ui/coverage/statics-consts.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,23 @@\n+// compile-flags:-Z unstable-options --show-coverage\n+// compile-pass\n+\n+//! gotta make sure we can count statics and consts correctly, too\n+\n+/// static like electricity, right?\n+pub static THIS_STATIC: usize = 0;\n+\n+/// (it's not electricity, is it)\n+pub const THIS_CONST: usize = 1;\n+\n+/// associated consts show up separately, but let's throw them in as well\n+pub trait SomeTrait {\n+    /// just like that, yeah\n+    const ASSOC_CONST: usize;\n+}\n+\n+pub struct SomeStruct;\n+\n+impl SomeStruct {\n+    /// wait, structs can have them too, can't forget those\n+    pub const ASSOC_CONST: usize = 100;\n+}"}, {"sha": "8459f90ae7b31674cda8c58603f4b2bd4aa58b8b", "filename": "src/test/rustdoc-ui/coverage/statics-consts.stdout", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.stdout?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,7 @@\n++-------------------------------------+------------+------------+------------+\n+| File                                | Documented |      Total | Percentage |\n++-------------------------------------+------------+------------+------------+\n+| ...oc-ui/coverage/statics-consts.rs |          6 |          7 |      85.7% |\n++-------------------------------------+------------+------------+------------+\n+| Total                               |          6 |          7 |      85.7% |\n++-------------------------------------+------------+------------+------------+"}, {"sha": "5f32d5b0cccc7933d4fcbc14f6e36031aa2a0aa6", "filename": "src/test/rustdoc-ui/coverage/traits.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,37 @@\n+// compile-flags:-Z unstable-options --show-coverage\n+// compile-pass\n+\n+#![feature(trait_alias)]\n+\n+/// look at this trait right here\n+pub trait ThisTrait {\n+    /// that's a trait all right\n+    fn right_here(&self);\n+\n+    /// even the provided functions show up as trait methods\n+    fn aww_yeah(&self) {}\n+\n+    /// gotta check those associated types, they're slippery\n+    type SomeType;\n+}\n+\n+/// so what happens if we take some struct...\n+pub struct SomeStruct;\n+\n+/// ...and slap this trait on it?\n+impl ThisTrait for SomeStruct {\n+    /// nothing! trait impls are totally ignored in this calculation, sorry.\n+    fn right_here(&self) {}\n+\n+    type SomeType = String;\n+}\n+\n+/// but what about those aliases? i hear they're pretty exotic\n+pub trait MyAlias = ThisTrait + Send + Sync;\n+\n+// FIXME(58624): once rustdoc can process existential types, we need to make sure they're counted\n+// /// woah, getting all existential in here\n+// pub existential type ThisExists: ThisTrait;\n+//\n+// /// why don't we get a little more concrete\n+// pub fn defines() -> ThisExists { SomeStruct {} }"}, {"sha": "e347a4da0b97829bad77162765ad7e08952f61e1", "filename": "src/test/rustdoc-ui/coverage/traits.stdout", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.stdout?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,7 @@\n++-------------------------------------+------------+------------+------------+\n+| File                                | Documented |      Total | Percentage |\n++-------------------------------------+------------+------------+------------+\n+| ...st/rustdoc-ui/coverage/traits.rs |          6 |          7 |      85.7% |\n++-------------------------------------+------------+------------+------------+\n+| Total                               |          6 |          7 |      85.7% |\n++-------------------------------------+------------+------------+------------+"}, {"sha": "6977e7fdc11837d6a841b33a306f2994c1088e39", "filename": "src/test/ui/consts/const-ptr-nonnull.nll.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.nll.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,25 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/const-ptr-nonnull.rs:4:37\n+   |\n+LL |     let x: &'static NonNull<u32> = &(NonNull::dangling());\n+   |            ---------------------    ^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+   |            |\n+   |            type annotation requires that borrow lasts for `'static`\n+...\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/const-ptr-nonnull.rs:9:37\n+   |\n+LL |     let x: &'static NonNull<u32> = &(non_null.cast());\n+   |            ---------------------    ^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+   |            |\n+   |            type annotation requires that borrow lasts for `'static`\n+LL |     //~^ ERROR borrowed value does not live long enough\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0716`."}, {"sha": "54e743aa32e232d4d421f9c85e6f819214277e80", "filename": "src/test/ui/consts/const-ptr-nonnull.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,11 @@\n+use std::ptr::NonNull;\n+\n+fn main() {\n+    let x: &'static NonNull<u32> = &(NonNull::dangling());\n+    //~^ ERROR borrowed value does not live long enough\n+\n+    let mut i: i32 = 10;\n+    let non_null = NonNull::new(&mut i).unwrap();\n+    let x: &'static NonNull<u32> = &(non_null.cast());\n+    //~^ ERROR borrowed value does not live long enough\n+}"}, {"sha": "a9476dda6d3203308f97073d0f78413b04fa58eb", "filename": "src/test/ui/consts/const-ptr-nonnull.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-nonnull.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,25 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-ptr-nonnull.rs:4:37\n+   |\n+LL |     let x: &'static NonNull<u32> = &(NonNull::dangling());\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-ptr-nonnull.rs:9:37\n+   |\n+LL |     let x: &'static NonNull<u32> = &(non_null.cast());\n+   |                                     ^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL |     //~^ ERROR borrowed value does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "b201994c894e4d2d9277f6784ccbf4923453a9e3", "filename": "src/test/ui/consts/const-ptr-unique.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.nll.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,14 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/const-ptr-unique.rs:8:33\n+   |\n+LL |     let x: &'static *mut u32 = &(unique.as_ptr());\n+   |            -----------------    ^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+   |            |\n+   |            type annotation requires that borrow lasts for `'static`\n+LL |     //~^ ERROR borrowed value does not live long enough\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0716`."}, {"sha": "be44a24181606d30baf6d8fade61e3ad9f3c9d1c", "filename": "src/test/ui/consts/const-ptr-unique.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,10 @@\n+#![feature(ptr_internals)]\n+\n+use std::ptr::Unique;\n+\n+fn main() {\n+    let mut i: u32 = 10;\n+    let unique = Unique::new(&mut i).unwrap();\n+    let x: &'static *mut u32 = &(unique.as_ptr());\n+    //~^ ERROR borrowed value does not live long enough\n+}"}, {"sha": "141465bf184d0ef7ce6e309a522d2690c448700b", "filename": "src/test/ui/consts/const-ptr-unique.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-ptr-unique.rs:8:33\n+   |\n+LL |     let x: &'static *mut u32 = &(unique.as_ptr());\n+   |                                 ^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL |     //~^ ERROR borrowed value does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "7eb6d5c0ecbaa30519b25a2535aef4c8027949ef", "filename": "src/test/ui/issues/issue-20413.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-20413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-20413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20413.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -8,6 +8,7 @@ struct NoData<T>;\n impl<T> Foo for T where NoData<T>: Foo {\n //~^ ERROR: overflow evaluating the requirement\n   fn answer(self) {\n+  //~^ ERROR: overflow evaluating the requirement\n     let val: NoData<T> = NoData;\n   }\n }"}, {"sha": "db746bebbe273553a0455583840c7da562fa88bd", "filename": "src/test/ui/issues/issue-20413.stderr", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -12,6 +12,7 @@ error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<N\n LL | / impl<T> Foo for T where NoData<T>: Foo {\n LL | | //~^ ERROR: overflow evaluating the requirement\n LL | |   fn answer(self) {\n+LL | |   //~^ ERROR: overflow evaluating the requirement\n LL | |     let val: NoData<T> = NoData;\n LL | |   }\n LL | | }\n@@ -87,7 +88,86 @@ note: required by `Foo`\n LL | trait Foo {\n    | ^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n+  --> $DIR/issue-20413.rs:10:3\n+   |\n+LL | /   fn answer(self) {\n+LL | |   //~^ ERROR: overflow evaluating the requirement\n+LL | |     let val: NoData<T> = NoData;\n+LL | |   }\n+   | |___^\n+   |\n+   = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<T>>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<T>>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<T>>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<T>>`\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<T>`\n+note: required by `Foo`\n+  --> $DIR/issue-20413.rs:1:1\n+   |\n+LL | trait Foo {\n+   | ^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n Some errors occurred: E0275, E0392.\n For more information about an error, try `rustc --explain E0275`."}, {"sha": "2d99769cfa31c56e9acc692e09def2fde2b20e5d", "filename": "src/test/ui/issues/issue-21946.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-21946.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-21946.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21946.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -7,6 +7,7 @@ struct FooStruct;\n impl Foo for FooStruct {\n //~^ ERROR overflow evaluating the requirement `<FooStruct as Foo>::A`\n     type A = <FooStruct as Foo>::A;\n+    //~^ ERROR overflow evaluating the requirement `<FooStruct as Foo>::A`\n }\n \n fn main() {}"}, {"sha": "5ac49f61543e45c61b601c12836d5b21419722d4", "filename": "src/test/ui/issues/issue-21946.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-21946.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-21946.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21946.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -4,6 +4,12 @@ error[E0275]: overflow evaluating the requirement `<FooStruct as Foo>::A`\n LL | impl Foo for FooStruct {\n    |      ^^^\n \n-error: aborting due to previous error\n+error[E0275]: overflow evaluating the requirement `<FooStruct as Foo>::A`\n+  --> $DIR/issue-21946.rs:9:5\n+   |\n+LL |     type A = <FooStruct as Foo>::A;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0275`."}, {"sha": "d6f64650f36bb6332ce22692af622c369a93afd3", "filename": "src/test/ui/issues/issue-23122-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -7,6 +7,7 @@ struct GetNext<T: Next> { t: T }\n impl<T: Next> Next for GetNext<T> {\n     //~^ ERROR overflow evaluating the requirement\n     type Next = <GetNext<T> as Next>::Next;\n+    //~^ ERROR overflow evaluating the requirement\n }\n \n fn main() {}"}, {"sha": "1b752b7afe2e62b4b68f8d1f8c8949bff32c2b05", "filename": "src/test/ui/issues/issue-23122-1.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -4,6 +4,12 @@ error[E0275]: overflow evaluating the requirement `<GetNext<T> as Next>::Next`\n LL | impl<T: Next> Next for GetNext<T> {\n    |               ^^^^\n \n-error: aborting due to previous error\n+error[E0275]: overflow evaluating the requirement `<GetNext<T> as Next>::Next`\n+  --> $DIR/issue-23122-1.rs:9:5\n+   |\n+LL |     type Next = <GetNext<T> as Next>::Next;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0275`."}, {"sha": "695712d2cc929aea4a9466660cf9708ccf8f0be4", "filename": "src/test/ui/issues/issue-23122-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -7,6 +7,7 @@ struct GetNext<T: Next> { t: T }\n impl<T: Next> Next for GetNext<T> {\n     //~^ ERROR overflow evaluating the requirement\n     type Next = <GetNext<T::Next> as Next>::Next;\n+    //~^ ERROR overflow evaluating the requirement\n }\n \n fn main() {}"}, {"sha": "b122dd42373c8cd7708739444cdb185f27f808ea", "filename": "src/test/ui/issues/issue-23122-2.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -7,6 +7,15 @@ LL | impl<T: Next> Next for GetNext<T> {\n    = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n    = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n \n-error: aborting due to previous error\n+error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: std::marker::Sized`\n+  --> $DIR/issue-23122-2.rs:9:5\n+   |\n+LL |     type Next = <GetNext<T::Next> as Next>::Next;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n+   = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0275`."}, {"sha": "e34c288c027c22f04b8740437a6b38cbefe3e122", "filename": "src/test/ui/malformed/malformed-unwind-1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,11 @@\n+#![feature(unwind_attributes)]\n+\n+#[unwind]\n+//~^ ERROR attribute must be of the form\n+extern \"C\" fn f1() {}\n+\n+#[unwind = \"\"]\n+//~^ ERROR attribute must be of the form\n+extern \"C\" fn f2() {}\n+\n+fn main() {}"}, {"sha": "852136eed91bde56a9e74a5c7e14f0bab2181614", "filename": "src/test/ui/malformed/malformed-unwind-1.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,14 @@\n+error: attribute must be of the form `#[unwind(allowed|aborts)]`\n+  --> $DIR/malformed-unwind-1.rs:3:1\n+   |\n+LL | #[unwind]\n+   | ^^^^^^^^^\n+\n+error: attribute must be of the form `#[unwind(allowed|aborts)]`\n+  --> $DIR/malformed-unwind-1.rs:7:1\n+   |\n+LL | #[unwind = \"\"]\n+   | ^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d4955b43309308020e177cbe64c8c369c110d3de", "filename": "src/test/ui/malformed/malformed-unwind-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,11 @@\n+#![feature(unwind_attributes)]\n+\n+#[unwind(allowed, aborts)]\n+//~^ ERROR malformed `#[unwind]` attribute\n+extern \"C\" fn f1() {}\n+\n+#[unwind(unsupported)]\n+//~^ ERROR malformed `#[unwind]` attribute\n+extern \"C\" fn f2() {}\n+\n+fn main() {}"}, {"sha": "88fc4e00a2fd3dbd0d521b56141889890f056b59", "filename": "src/test/ui/malformed/malformed-unwind-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -0,0 +1,15 @@\n+error[E0633]: malformed `#[unwind]` attribute\n+  --> $DIR/malformed-unwind-2.rs:3:1\n+   |\n+LL | #[unwind(allowed, aborts)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0633]: malformed `#[unwind]` attribute\n+  --> $DIR/malformed-unwind-2.rs:7:1\n+   |\n+LL | #[unwind(unsupported)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0633`."}, {"sha": "568d4dadc8cc47e0c983ae66ccc1c08bb82b6029", "filename": "src/test/ui/privacy/private-inferred-type.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -1,3 +1,21 @@\n+error[E0446]: private type `m::Priv` in public interface\n+  --> $DIR/private-inferred-type.rs:61:36\n+   |\n+LL |     struct Priv;\n+   |     - `m::Priv` declared as private\n+...\n+LL |     impl TraitWithAssocTy for u8 { type AssocTy = Priv; }\n+   |                                    ^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+\n+error[E0446]: private type `adjust::S2` in public interface\n+  --> $DIR/private-inferred-type.rs:83:9\n+   |\n+LL |     struct S2;\n+   |     - `adjust::S2` declared as private\n+...\n+LL |         type Target = S2Alias; //~ ERROR private type `adjust::S2` in public interface\n+   |         ^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+\n error: type `m::Priv` is private\n   --> $DIR/private-inferred-type.rs:97:9\n    |\n@@ -202,24 +220,6 @@ error: type `m::Priv` is private\n LL |     match a { //~ ERROR type `m::Priv` is private\n    |           ^\n \n-error[E0446]: private type `m::Priv` in public interface\n-  --> $DIR/private-inferred-type.rs:61:36\n-   |\n-LL |     struct Priv;\n-   |     - `m::Priv` declared as private\n-...\n-LL |     impl TraitWithAssocTy for u8 { type AssocTy = Priv; }\n-   |                                    ^^^^^^^^^^^^^^^^^^^^ can't leak private type\n-\n-error[E0446]: private type `adjust::S2` in public interface\n-  --> $DIR/private-inferred-type.rs:83:9\n-   |\n-LL |     struct S2;\n-   |     - `adjust::S2` declared as private\n-...\n-LL |         type Target = S2Alias; //~ ERROR private type `adjust::S2` in public interface\n-   |         ^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n-\n error: aborting due to 33 previous errors\n \n For more information about this error, try `rustc --explain E0446`."}, {"sha": "d44a51a9635e969c84b8bf63ed92b62a7ea2c28e", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -358,6 +358,7 @@ impl Builder {\n         self.package(\"rust-src\", &mut manifest.pkg, &[\"*\"]);\n         self.package(\"rls-preview\", &mut manifest.pkg, HOSTS);\n         self.package(\"clippy-preview\", &mut manifest.pkg, HOSTS);\n+        self.package(\"miri\", &mut manifest.pkg, HOSTS);\n         self.package(\"rustfmt-preview\", &mut manifest.pkg, HOSTS);\n         self.package(\"rust-analysis\", &mut manifest.pkg, TARGETS);\n         self.package(\"llvm-tools-preview\", &mut manifest.pkg, TARGETS);\n@@ -375,7 +376,7 @@ impl Builder {\n                      &[\"rustc\", \"cargo\", \"rust-std\", \"rust-mingw\",\n                        \"rust-docs\", \"rustfmt-preview\", \"clippy-preview\",\n                        \"rls-preview\", \"rust-src\", \"llvm-tools-preview\",\n-                       \"lldb-preview\", \"rust-analysis\"]);\n+                       \"lldb-preview\", \"rust-analysis\", \"miri\"]);\n \n         manifest.renames.insert(\"rls\".to_owned(), Rename { to: \"rls-preview\".to_owned() });\n         manifest.renames.insert(\"rustfmt\".to_owned(), Rename { to: \"rustfmt-preview\".to_owned() });\n@@ -422,6 +423,7 @@ impl Builder {\n             // weren't built\n             extensions.extend(vec![\n                 Component { pkg: \"clippy-preview\".to_string(), target: host.to_string() },\n+                Component { pkg: \"miri\".to_string(), target: host.to_string() },\n                 Component { pkg: \"rls-preview\".to_string(), target: host.to_string() },\n                 Component { pkg: \"rustfmt-preview\".to_string(), target: host.to_string() },\n                 Component { pkg: \"llvm-tools-preview\".to_string(), target: host.to_string() },"}]}