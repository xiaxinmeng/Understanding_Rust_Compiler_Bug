{"sha": "9fc5cf902f9613f40ce4d4346d1ae98a0904e67a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYzVjZjkwMmY5NjEzZjQwY2U0ZDQzNDZkMWFlOThhMDkwNGU2N2E=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-15T00:27:28Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-21T17:59:58Z"}, "message": "Refine the tooling, handle comments", "tree": {"sha": "88766d3b418bfa584426da7344bed3c5a37f4c36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88766d3b418bfa584426da7344bed3c5a37f4c36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fc5cf902f9613f40ce4d4346d1ae98a0904e67a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fc5cf902f9613f40ce4d4346d1ae98a0904e67a", "html_url": "https://github.com/rust-lang/rust/commit/9fc5cf902f9613f40ce4d4346d1ae98a0904e67a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fc5cf902f9613f40ce4d4346d1ae98a0904e67a/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76a15520212b1b9a72c099e0a163a31c102fcde4", "url": "https://api.github.com/repos/rust-lang/rust/commits/76a15520212b1b9a72c099e0a163a31c102fcde4", "html_url": "https://github.com/rust-lang/rust/commit/76a15520212b1b9a72c099e0a163a31c102fcde4"}], "stats": {"total": 99, "additions": 68, "deletions": 31}, "files": [{"sha": "e4640ccfb164e1541be84e5b4f120bd3b9f31dd9", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5cf902f9613f40ce4d4346d1ae98a0904e67a/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5cf902f9613f40ce4d4346d1ae98a0904e67a/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=9fc5cf902f9613f40ce4d4346d1ae98a0904e67a", "patch": "@@ -153,28 +153,13 @@ LIFETIME : '\\'' IDENT ;\n \n WHITESPACE : [ \\r\\n\\t]+ ;\n \n-LINE_COMMENT_NOT_A_TOKEN : '//' -> more, pushMode(LINE_COMMENT) ;\n-\n+UNDOC_COMMENT     : '////' ~[\\r\\n]* -> type(COMMENT) ;\n+YESDOC_COMMENT    : '///' ~[\\r\\n]* -> type(DOC_COMMENT) ;\n+OUTER_DOC_COMMENT : '//!' ~[\\r\\n]* -> type(DOC_COMMENT) ;\n+LINE_COMMENT      : '//' ~[\\r\\n]* -> type(COMMENT) ;\n \n DOC_BLOCK_COMMENT\n   : ('/**' | '/*!') (DOC_BLOCK_COMMENT | .)*? '*/' -> type(DOC_COMMENT)\n   ;\n \n BLOCK_COMMENT : '/*' (BLOCK_COMMENT | .)*? '*/' -> type(COMMENT) ;\n-\n-mode LINE_COMMENT;\n-\n-MAYBE_DOC_COMMENT\n-  : '/' -> more, pushMode(LINE_DOC_COMMENT)\n-  ;\n-\n-MAYBE_OUTER_DOC_COMMENT\n-  : '!' ~[\\r\\n]* -> type(LINE_DOC_COMMENT), popMode\n-  ;\n-\n-COMMENT : ~[\\r\\n]* -> popMode ;\n-\n-mode LINE_DOC_COMMENT;\n-\n-ACTUALLY_A_COMMENT : '/' ~[\\r\\n]* -> type(COMMENT), popMode ;\n-REALLY_A_DOC_COMMENT : ~[\\r\\n]* -> type(DOC_COMMENT), popMode ;"}, {"sha": "38dd86e077291aed09eea616268c6c24dc30ce2f", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5cf902f9613f40ce4d4346d1ae98a0904e67a/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5cf902f9613f40ce4d4346d1ae98a0904e67a/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=9fc5cf902f9613f40ce4d4346d1ae98a0904e67a", "patch": "@@ -108,13 +108,10 @@ fn parse_token_list(file: &str) -> HashMap<String, Token> {\n     res\n }\n \n-fn str_to_binop(mut s: &str) -> BinOp {\n-    if s.ends_with(\"'\") {\n-        s = s.slice_to(s.len() - 1);\n-    }\n-\n+fn str_to_binop(s: &str) -> BinOp {\n     match s {\n         \"+\" => PLUS,\n+        \"/\" => SLASH,\n         \"-\" => MINUS,\n         \"*\" => STAR,\n         \"%\" => PERCENT,\n@@ -123,12 +120,35 @@ fn str_to_binop(mut s: &str) -> BinOp {\n         \"|\" => OR,\n         \"<<\" => SHL,\n         \">>\" => SHR,\n-        _ => fail!(\"Bad binop str {}\", s)\n+        _ => fail!(\"Bad binop str `{}`\", s)\n+    }\n+}\n+\n+/// Assuming a raw string/binary literal, strip out the leading/trailing\n+/// hashes and surrounding quotes/raw/binary prefix.\n+fn fix(mut lit: &str) -> ast::Name {\n+    if lit.char_at(0) == 'r' {\n+        if lit.char_at(1) == 'b' {\n+            lit = lit.slice_from(2)\n+        } else {\n+            lit = lit.slice_from(1);\n+        }\n+    } else if lit.char_at(0) == 'b' {\n+        lit = lit.slice_from(1);\n     }\n+\n+    let leading_hashes = count(lit);\n+\n+    // +1/-1 to adjust for single quotes\n+    parse::token::intern(lit.slice(leading_hashes + 1, lit.len() - leading_hashes - 1))\n+}\n+\n+fn count(lit: &str) -> uint {\n+    lit.chars().take_while(|c| *c == '#').count()\n }\n \n fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n-    let re = regex!(r\"\\[@(?P<seq>\\d+),(?P<start>\\d+):(?P<end>\\d+)='(?P<content>.+?),<(?P<toknum>-?\\d+)>,\\d+:\\d+]\");\n+    let re = regex!(r\"\\[@(?P<seq>\\d+),(?P<start>\\d+):(?P<end>\\d+)='(?P<content>.+?)',<(?P<toknum>-?\\d+)>,\\d+:\\d+]\");\n \n     let m = re.captures(s).expect(format!(\"The regex didn't match {}\", s).as_slice());\n     let start = m.name(\"start\");\n@@ -137,9 +157,24 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n     let content = m.name(\"content\");\n \n     let proto_tok = tokens.find_equiv(&toknum).expect(format!(\"didn't find token {} in the map\", toknum).as_slice());\n+\n+    let nm = parse::token::intern(content);\n+\n+    debug!(\"What we got: content (`{}`), proto: {}\", content, proto_tok);\n+\n     let real_tok = match *proto_tok {\n-        BINOP(PLUS) => BINOP(str_to_binop(content)),\n-        BINOPEQ(PLUS) => BINOPEQ(str_to_binop(content.slice_to(content.len() - 2))),\n+        BINOP(..) => BINOP(str_to_binop(content)),\n+        BINOPEQ(..) => BINOPEQ(str_to_binop(content.slice_to(content.len() - 1))),\n+        LIT_STR(..) => LIT_STR(fix(content)),\n+        LIT_STR_RAW(..) => LIT_STR_RAW(fix(content), count(content)),\n+        LIT_CHAR(..) => LIT_CHAR(nm),\n+        DOC_COMMENT(..) => DOC_COMMENT(nm),\n+        LIT_INTEGER(..) => LIT_INTEGER(nm),\n+        LIT_FLOAT(..) => LIT_FLOAT(nm),\n+        LIT_BINARY(..) => LIT_BINARY(nm),\n+        LIT_BINARY_RAW(..) => LIT_BINARY_RAW(fix(content), count(content)),\n+        IDENT(..) => IDENT(ast::Ident { name: nm, ctxt: 0 }, true),\n+        LIFETIME(..) => LIFETIME(ast::Ident { name: nm, ctxt: 0 }),\n         ref t => t.clone()\n     };\n \n@@ -161,6 +196,16 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n     }\n }\n \n+fn tok_cmp(a: &Token, b: &Token) -> bool {\n+    match a {\n+        &IDENT(id, _) => match b {\n+                &IDENT(id2, _) => id == id2,\n+                _ => false\n+        },\n+        _ => a == b\n+    }\n+}\n+\n fn main() {\n     fn next(r: &mut lexer::StringReader) -> TokenAndSpan {\n         use syntax::parse::lexer::Reader;\n@@ -173,7 +218,8 @@ fn main() {\n \n     let code = File::open(&Path::new(std::os::args().get(1).as_slice())).unwrap().read_to_string().unwrap();\n     let options = config::basic_options();\n-    let session = session::build_session(options, None);\n+    let session = session::build_session(options, None,\n+                                         syntax::diagnostics::registry::Registry::new([]));\n     let filemap = parse::string_to_filemap(&session.parse_sess,\n                                            code,\n                                            String::from_str(\"<n/a>\"));\n@@ -191,10 +237,16 @@ fn main() {\n             ( $($x:pat),+ ) => (\n                 match rustc_tok.tok {\n                     $($x => match antlr_tok.tok {\n-                        $x => (),\n+                        $x => {\n+                            if !tok_cmp(&rustc_tok.tok, &antlr_tok.tok) {\n+                                // FIXME #15677: needs more robust escaping in\n+                                // antlr\n+                                warn!(\"Different names for {} and {}\", rustc_tok, antlr_tok);\n+                            }\n+                        }\n                         _ => fail!(\"{} is not {}\", antlr_tok, rustc_tok)\n                     },)*\n-                    ref c => assert!(c == antlr_tok.tok, \"{} is not {}\", rustc_tok, antlr_tok)\n+                    ref c => assert!(c == &antlr_tok.tok, \"{} is not {}\", rustc_tok, antlr_tok)\n                 }\n             )\n         )"}]}