{"sha": "19485cc10173cb72e24813ce95b65c8f3cf92326", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NDg1Y2MxMDE3M2NiNzJlMjQ4MTNjZTk1YjY1YzhmM2NmOTIzMjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-15T08:05:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-16T21:35:39Z"}, "message": "Miri: refactor new allocation tagging", "tree": {"sha": "502212fd200a2c1094b074aa3eca287fbe253045", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/502212fd200a2c1094b074aa3eca287fbe253045"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19485cc10173cb72e24813ce95b65c8f3cf92326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19485cc10173cb72e24813ce95b65c8f3cf92326", "html_url": "https://github.com/rust-lang/rust/commit/19485cc10173cb72e24813ce95b65c8f3cf92326", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19485cc10173cb72e24813ce95b65c8f3cf92326/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee621f42329069c296b4c2066b3743cc4ff0f369", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee621f42329069c296b4c2066b3743cc4ff0f369", "html_url": "https://github.com/rust-lang/rust/commit/ee621f42329069c296b4c2066b3743cc4ff0f369"}], "stats": {"total": 263, "additions": 99, "deletions": 164}, "files": [{"sha": "ca5feaee12ee4f6f903a6bdb0091de76a18a1231", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 20, "deletions": 53, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -45,12 +45,10 @@ pub struct Allocation<Tag=(),Extra=()> {\n }\n \n \n-pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n-    /// Hook to initialize the extra data when an allocation gets created.\n-    fn memory_allocated(\n-        _size: Size,\n-        _memory_extra: &MemoryExtra\n-    ) -> Self;\n+pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n+    // There is no constructor in here because the constructor's type depends\n+    // on `MemoryKind`, and making things sufficiently generic leads to painful\n+    // inference failure.\n \n     /// Hook for performing extra checks on a memory read access.\n     ///\n@@ -88,15 +86,8 @@ pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n     }\n }\n \n-impl AllocationExtra<(), ()> for () {\n-    #[inline(always)]\n-    fn memory_allocated(\n-        _size: Size,\n-        _memory_extra: &()\n-    ) -> Self {\n-        ()\n-    }\n-}\n+// For Tag=() and no extra state, we have is a trivial implementation.\n+impl AllocationExtra<()> for () { }\n \n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a read-only allocation initialized by the given bytes\n@@ -159,23 +150,21 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Byte accessors\n-impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n     /// on that.\n-    fn get_bytes_internal<MemoryExtra>(\n+    fn get_bytes_internal(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         check_defined_and_ptr: bool,\n     ) -> EvalResult<'tcx, &[u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         self.check_bounds(cx, ptr, size)?;\n \n@@ -196,43 +185,37 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     }\n \n     #[inline]\n-    pub fn get_bytes<MemoryExtra>(\n+    pub fn get_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx, &[u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n     #[inline]\n-    pub fn get_bytes_with_undef_and_ptr<MemoryExtra>(\n+    pub fn get_bytes_with_undef_and_ptr(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx, &[u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         self.get_bytes_internal(cx, ptr, size, false)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n     /// so be sure to actually put data there!\n-    pub fn get_bytes_mut<MemoryExtra>(\n+    pub fn get_bytes_mut(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx, &mut [u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_bounds(cx, ptr, size)?;\n@@ -250,16 +233,14 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n }\n \n /// Reading and writing\n-impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n-    pub fn read_c_str<MemoryExtra>(\n+    pub fn read_c_str(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n     ) -> EvalResult<'tcx, &[u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -278,15 +259,13 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor undef bytes.\n-    pub fn check_bytes<MemoryExtra>(\n+    pub fn check_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         allow_ptr_and_undef: bool,\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         // Check bounds and relocations on the edges\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n@@ -301,30 +280,26 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n     /// Will do bounds checks on the allocation.\n-    pub fn write_bytes<MemoryExtra>(\n+    pub fn write_bytes(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         src: &[u8],\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n-    pub fn write_repeat<MemoryExtra>(\n+    pub fn write_repeat(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: u8,\n         count: Size\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let bytes = self.get_bytes_mut(cx, ptr, count)?;\n         for b in bytes {\n@@ -341,14 +316,12 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     ///   being valid for ZSTs\n     ///\n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn read_scalar<MemoryExtra>(\n+    pub fn read_scalar(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         // get_bytes_unchecked tests relocation edges\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n@@ -379,13 +352,11 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn read_ptr_sized<MemoryExtra>(\n+    pub fn read_ptr_sized(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n@@ -398,15 +369,13 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     ///   being valid for ZSTs\n     ///\n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn write_scalar<MemoryExtra>(\n+    pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>,\n         type_size: Size,\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n@@ -446,14 +415,12 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn write_ptr_sized<MemoryExtra>(\n+    pub fn write_ptr_sized(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let ptr_size = cx.data_layout().pointer_size;\n         self.write_scalar(cx, ptr.into(), val, ptr_size)"}, {"sha": "75e0f704a58545e239e05f14ba0ad9990cf8bb46", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -94,11 +94,17 @@ impl<'tcx> Pointer<()> {\n         Pointer { alloc_id, offset, tag: () }\n     }\n \n+    #[inline(always)]\n+    pub fn with_tag<Tag>(self, tag: Tag) -> Pointer<Tag>\n+    {\n+        Pointer::new_with_tag(self.alloc_id, self.offset, tag)\n+    }\n+\n     #[inline(always)]\n     pub fn with_default_tag<Tag>(self) -> Pointer<Tag>\n         where Tag: Default\n     {\n-        Pointer::new_with_tag(self.alloc_id, self.offset, Default::default())\n+        self.with_tag(Tag::default())\n     }\n }\n "}, {"sha": "18c82ecd38edc20ce250d39fd10a4b70cd7bada2", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -119,14 +119,19 @@ impl<Tag> fmt::Display for Scalar<Tag> {\n \n impl<'tcx> Scalar<()> {\n     #[inline]\n-    pub fn with_default_tag<Tag>(self) -> Scalar<Tag>\n-        where Tag: Default\n-    {\n+    pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_default_tag()),\n+            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n             Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n         }\n     }\n+\n+    #[inline(always)]\n+    pub fn with_default_tag<Tag>(self) -> Scalar<Tag>\n+        where Tag: Default\n+    {\n+        self.with_tag(Tag::default())\n+    }\n }\n \n impl<'tcx, Tag> Scalar<Tag> {\n@@ -138,14 +143,6 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n-    #[inline]\n-    pub fn with_tag(self, new_tag: Tag) -> Self {\n-        match self {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(Pointer { tag: new_tag, ..ptr }),\n-            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n-        }\n-    }\n-\n     #[inline]\n     pub fn ptr_null(cx: &impl HasDataLayout) -> Self {\n         Scalar::Bits {\n@@ -434,14 +431,19 @@ impl<Tag> fmt::Display for ScalarMaybeUndef<Tag> {\n \n impl<'tcx> ScalarMaybeUndef<()> {\n     #[inline]\n-    pub fn with_default_tag<Tag>(self) -> ScalarMaybeUndef<Tag>\n-        where Tag: Default\n-    {\n+    pub fn with_tag<Tag>(self, new_tag: Tag) -> ScalarMaybeUndef<Tag> {\n         match self {\n-            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.with_default_tag()),\n+            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.with_tag(new_tag)),\n             ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n         }\n     }\n+\n+    #[inline(always)]\n+    pub fn with_default_tag<Tag>(self) -> ScalarMaybeUndef<Tag>\n+        where Tag: Default\n+    {\n+        self.with_tag(Tag::default())\n+    }\n }\n \n impl<'tcx, Tag> ScalarMaybeUndef<Tag> {"}, {"sha": "09c50d4f81f494e17c01636371fffbc21027ae39", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -11,7 +11,7 @@ use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n+use rustc::ty::layout::{self, LayoutOf, VariantIdx, Size};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n@@ -21,7 +21,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar, Pointer,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n     EvalResult, EvalError, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n@@ -406,6 +406,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         Cow::Borrowed(alloc)\n     }\n \n+    #[inline(always)]\n+    fn new_allocation(\n+        _size: Size,\n+        _extra: &Self::MemoryExtra,\n+        _kind: MemoryKind<!>,\n+    ) -> (Self::AllocExtra, Self::PointerTag) {\n+        ((), ())\n+    }\n+\n     fn box_alloc(\n         _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n@@ -439,15 +448,6 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         )\n     }\n \n-    #[inline(always)]\n-    fn tag_new_allocation(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer,\n-        _kind: MemoryKind<Self::MemoryKinds>,\n-    ) -> Pointer {\n-        ptr\n-    }\n-\n     #[inline(always)]\n     fn stack_push(\n         _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,"}, {"sha": "288ffbf3cd616f57839f8858a17fa1cea76c6674", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -7,11 +7,11 @@ use std::hash::Hash;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n-use rustc::ty::{self, query::TyCtxtAt};\n+use rustc::ty::{self, query::TyCtxtAt, layout::Size};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    InterpretCx, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n+    InterpretCx, PlaceTy, MPlaceTy, OpTy, ImmTy, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -76,7 +76,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     type MemoryExtra: Default;\n \n     /// Extra data stored in every allocation.\n-    type AllocExtra: AllocationExtra<Self::PointerTag, Self::MemoryExtra> + 'static;\n+    type AllocExtra: AllocationExtra<Self::PointerTag> + 'static;\n \n     /// Memory's allocation map\n     type MemoryMap:\n@@ -139,18 +139,6 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         memory_extra: &Self::MemoryExtra,\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n \n-    /// Called to turn an allocation obtained from the `tcx` into one that has\n-    /// the right type for this machine.\n-    ///\n-    /// This should avoid copying if no work has to be done! If this returns an owned\n-    /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n-    /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n-    /// owned allocation to the map even when the map is shared.)\n-    fn adjust_static_allocation<'b>(\n-        alloc: &'b Allocation,\n-        memory_extra: &Self::MemoryExtra,\n-    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n-\n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n     ///\n@@ -168,12 +156,24 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n-    /// Adds the tag for a newly allocated pointer.\n-    fn tag_new_allocation(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer,\n+    /// Called to turn an allocation obtained from the `tcx` into one that has\n+    /// the right type for this machine.\n+    ///\n+    /// This should avoid copying if no work has to be done! If this returns an owned\n+    /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n+    /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n+    /// owned allocation to the map even when the map is shared.)\n+    fn adjust_static_allocation<'b>(\n+        alloc: &'b Allocation,\n+        memory_extra: &Self::MemoryExtra,\n+    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n+\n+    /// Computes the extra state and the tag for a new allocation.\n+    fn new_allocation(\n+        size: Size,\n+        extra: &Self::MemoryExtra,\n         kind: MemoryKind<Self::MemoryKinds>,\n-    ) -> Pointer<Self::PointerTag>;\n+    ) -> (Self::AllocExtra, Self::PointerTag);\n \n     /// Executed when evaluating the `*` operator: Following a reference.\n     /// This has the chance to adjust the tag. It should not change anything else!"}, {"sha": "117bd15399cde336807be187951da319842a3d9d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -132,9 +132,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> Pointer {\n-        let extra = AllocationExtra::memory_allocated(size, &self.extra);\n-        Pointer::from(self.allocate_with(Allocation::undef(size, align, extra), kind))\n+    ) -> Pointer<M::PointerTag> {\n+        let (extra, tag) = M::new_allocation(size, &self.extra, kind);\n+        Pointer::from(self.allocate_with(Allocation::undef(size, align, extra), kind)).with_tag(tag)\n     }\n \n     pub fn reallocate(\n@@ -145,7 +145,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n@@ -156,7 +156,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.copy(\n             ptr.into(),\n             old_align,\n-            new_ptr.with_default_tag().into(),\n+            new_ptr.into(),\n             new_align,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,"}, {"sha": "55c1bfb17dec31a18f2eea1123bc06f312998729", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -31,19 +31,6 @@ pub enum Immediate<Tag=(), Id=AllocId> {\n     ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n }\n \n-impl Immediate {\n-    #[inline]\n-    pub fn with_default_tag<Tag>(self) -> Immediate<Tag>\n-        where Tag: Default\n-    {\n-        match self {\n-            Immediate::Scalar(x) => Immediate::Scalar(x.with_default_tag()),\n-            Immediate::ScalarPair(x, y) =>\n-                Immediate::ScalarPair(x.with_default_tag(), y.with_default_tag()),\n-        }\n-    }\n-}\n-\n impl<'tcx, Tag> Immediate<Tag> {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>) -> Self {\n@@ -142,18 +129,6 @@ pub enum Operand<Tag=(), Id=AllocId> {\n     Indirect(MemPlace<Tag, Id>),\n }\n \n-impl Operand {\n-    #[inline]\n-    pub fn with_default_tag<Tag>(self) -> Operand<Tag>\n-        where Tag: Default\n-    {\n-        match self {\n-            Operand::Immediate(x) => Operand::Immediate(x.with_default_tag()),\n-            Operand::Indirect(x) => Operand::Indirect(x.with_default_tag()),\n-        }\n-    }\n-}\n-\n impl<Tag> Operand<Tag> {\n     #[inline]\n     pub fn erase_tag(self) -> Operand\n@@ -554,16 +529,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway.\n                 Operand::Indirect(\n-                    MemPlace::from_ptr(ptr, alloc.align)\n-                ).with_default_tag()\n+                    MemPlace::from_ptr(ptr.with_default_tag(), alloc.align)\n+                )\n             },\n             ConstValue::Slice(a, b) =>\n                 Operand::Immediate(Immediate::ScalarPair(\n-                    a.into(),\n-                    Scalar::from_uint(b, self.tcx.data_layout.pointer_size).into(),\n-                )).with_default_tag(),\n+                    a.with_default_tag().into(),\n+                    Scalar::from_uint(b, self.tcx.data_layout.pointer_size)\n+                        .with_default_tag().into(),\n+                )),\n             ConstValue::Scalar(x) =>\n-                Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag(),\n+                Operand::Immediate(Immediate::Scalar(x.with_default_tag().into())),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {"}, {"sha": "8239337796e9a57faeaaca129f1e30e2a02cdd6c", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -83,40 +83,26 @@ impl<'tcx, Tag> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     }\n }\n \n-impl MemPlace {\n+impl<Tag> MemPlace<Tag> {\n+    /// Replace ptr tag, maintain vtable tag (if any)\n     #[inline]\n-    pub fn with_default_tag<Tag>(self) -> MemPlace<Tag>\n-        where Tag: Default\n-    {\n+    pub fn replace_tag(self, new_tag: Tag) -> Self {\n         MemPlace {\n-            ptr: self.ptr.with_default_tag(),\n+            ptr: self.ptr.erase_tag().with_tag(new_tag),\n             align: self.align,\n-            meta: self.meta.map(Scalar::with_default_tag),\n+            meta: self.meta,\n         }\n     }\n-}\n \n-impl<Tag> MemPlace<Tag> {\n     #[inline]\n-    pub fn erase_tag(self) -> MemPlace\n-    {\n+    pub fn erase_tag(self) -> MemPlace {\n         MemPlace {\n             ptr: self.ptr.erase_tag(),\n             align: self.align,\n             meta: self.meta.map(Scalar::erase_tag),\n         }\n     }\n \n-    #[inline]\n-    pub fn with_tag(self, new_tag: Tag) -> Self\n-    {\n-        MemPlace {\n-            ptr: self.ptr.with_tag(new_tag),\n-            align: self.align,\n-            meta: self.meta,\n-        }\n-    }\n-\n     #[inline(always)]\n     pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n         MemPlace {\n@@ -189,11 +175,11 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         }\n     }\n \n+    /// Replace ptr tag, maintain vtable tag (if any)\n     #[inline]\n-    pub fn with_tag(self, new_tag: Tag) -> Self\n-    {\n+    pub fn replace_tag(self, new_tag: Tag) -> Self {\n         MPlaceTy {\n-            mplace: self.mplace.with_tag(new_tag),\n+            mplace: self.mplace.replace_tag(new_tag),\n             layout: self.layout,\n         }\n     }\n@@ -312,7 +298,7 @@ where\n     M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n-    M::AllocExtra: AllocationExtra<Tag, M::MemoryExtra>,\n+    M::AllocExtra: AllocationExtra<Tag>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n@@ -943,7 +929,6 @@ where\n                         let (size, align) = self.size_and_align_of(meta, local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n                         let ptr = self.memory.allocate(size, align, MemoryKind::Stack);\n-                        let ptr = M::tag_new_allocation(self, ptr, MemoryKind::Stack);\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n                         if let Some(value) = old_val {\n                             // Preserve old value.\n@@ -981,7 +966,6 @@ where\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n-        let ptr = M::tag_new_allocation(self, ptr, kind);\n         MPlaceTy::from_aligned_ptr(ptr, layout)\n     }\n "}, {"sha": "0bed62ccf500a227688af85362de56d46797d910", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19485cc10173cb72e24813ce95b65c8f3cf92326/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=19485cc10173cb72e24813ce95b65c8f3cf92326", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n             MemoryKind::Vtable,\n-        ).with_default_tag();\n+        );\n         let tcx = &*self.tcx;\n \n         let drop = crate::monomorphize::resolve_drop_in_place(*tcx, ty);"}]}