{"sha": "cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMWU4M2I2ZGNjOTEyMjY5MTMyNTY4MTAyOGJhNmUxM2E3YzJlNmI=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-10-14T10:22:57Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-10-14T10:22:57Z"}, "message": "Merged #365", "tree": {"sha": "fdfed7c478b354b6880e416ba9167a4e67037665", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdfed7c478b354b6880e416ba9167a4e67037665"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "html_url": "https://github.com/rust-lang/rust/commit/cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "949c3545ce6c8662d384d625db7bfeae388f21d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/949c3545ce6c8662d384d625db7bfeae388f21d6", "html_url": "https://github.com/rust-lang/rust/commit/949c3545ce6c8662d384d625db7bfeae388f21d6"}, {"sha": "b48db27152caf31c892312bc8a8ea8db7418e157", "url": "https://api.github.com/repos/rust-lang/rust/commits/b48db27152caf31c892312bc8a8ea8db7418e157", "html_url": "https://github.com/rust-lang/rust/commit/b48db27152caf31c892312bc8a8ea8db7418e157"}], "stats": {"total": 154, "additions": 146, "deletions": 8}, "files": [{"sha": "e57ca8d1e024e80fb83a941c0db93b678aa8d5d2", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 62 lints included in this crate:\n+There are 64 lints included in this crate:\n \n name                                                                                                   | default | meaning\n -------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -38,6 +38,8 @@ name\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                     | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                               | warn    | taking a number modulo 1, which always returns 0\n [mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                     | allow   | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n+[mutex_atomic](https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic)                           | warn    | using a Mutex where an atomic value could be used instead\n+[mutex_integer](https://github.com/Manishearth/rust-clippy/wiki#mutex_integer)                         | allow   | using a Mutex for an integer type\n [needless_bool](https://github.com/Manishearth/rust-clippy/wiki#needless_bool)                         | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n [needless_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes)               | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n [needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)             | warn    | for-looping over a range of indices where an iterator over items would do"}, {"sha": "5276ad711c0911dae678ecd252f6a4281b88920b", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "patch": "@@ -47,6 +47,7 @@ pub mod loops;\n pub mod ranges;\n pub mod matches;\n pub mod precedence;\n+pub mod mutex_atomic;\n pub mod zero_div_zero;\n pub mod open_options;\n \n@@ -92,12 +93,14 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box minmax::MinMaxPass);\n     reg.register_late_lint_pass(box open_options::NonSensicalOpenOptions);\n     reg.register_late_lint_pass(box zero_div_zero::ZeroDivZeroPass);\n+    reg.register_late_lint_pass(box mutex_atomic::MutexAtomic);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::WRONG_PUB_SELF_CONVENTION,\n         mut_mut::MUT_MUT,\n+        mutex_atomic::MUTEX_INTEGER,\n         ptr_arg::PTR_ARG,\n         shadow::SHADOW_REUSE,\n         shadow::SHADOW_SAME,\n@@ -146,6 +149,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::REDUNDANT_PATTERN,\n         misc::TOPLEVEL_REF_ARG,\n         mut_reference::UNNECESSARY_MUT_PASSED,\n+        mutex_atomic::MUTEX_ATOMIC,\n         needless_bool::NEEDLESS_BOOL,\n         open_options::NONSENSICAL_OPEN_OPTIONS,\n         precedence::PRECEDENCE,"}, {"sha": "9c10a062419b398d8b4a065b84665245c1a888ac", "filename": "src/mutex_atomic.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "patch": "@@ -0,0 +1,67 @@\n+//! Checks for uses of Mutex where an atomic value could be used\n+//!\n+//! This lint is **warn** by default\n+\n+use rustc::lint::{LintPass, LintArray, LateLintPass, LateContext};\n+use rustc_front::hir::Expr;\n+\n+use syntax::ast;\n+use rustc::middle::ty;\n+use rustc::middle::subst::ParamSpace;\n+\n+use utils::{span_lint, MUTEX_PATH, match_type};\n+\n+declare_lint! {\n+    pub MUTEX_ATOMIC,\n+    Warn,\n+    \"using a Mutex where an atomic value could be used instead\"\n+}\n+\n+declare_lint! {\n+    pub MUTEX_INTEGER,\n+    Allow,\n+    \"using a Mutex for an integer type\"\n+}\n+\n+impl LintPass for MutexAtomic {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MUTEX_ATOMIC, MUTEX_INTEGER)\n+    }\n+}\n+\n+pub struct MutexAtomic;\n+\n+impl LateLintPass for MutexAtomic {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        let ty = cx.tcx.expr_ty(expr);\n+        if let &ty::TyStruct(_, subst) = &ty.sty {\n+            if match_type(cx, ty, &MUTEX_PATH) {\n+                let mutex_param = &subst.types.get(ParamSpace::TypeSpace, 0).sty;\n+                if let Some(atomic_name) = get_atomic_name(mutex_param) {\n+                    let msg = format!(\"Consider using an {} instead of a \\\n+                                       Mutex here. If you just want the \\\n+                                       locking behaviour and not the internal \\\n+                                       type, consider using Mutex<()>.\",\n+                                      atomic_name);\n+                    match *mutex_param {\n+                        ty::TyUint(t) if t != ast::TyUs =>\n+                            span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        ty::TyInt(t) if t != ast::TyIs =>\n+                            span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn get_atomic_name(ty: &ty::TypeVariants) -> Option<(&'static str)> {\n+    match *ty {\n+        ty::TyBool => Some(\"AtomicBool\"),\n+        ty::TyUint(_) => Some(\"AtomicUsize\"),\n+        ty::TyInt(_) => Some(\"AtomicIsize\"),\n+        ty::TyRawPtr(_) => Some(\"AtomicPtr\"),\n+        _ => None\n+    }\n+}"}, {"sha": "1ba6029ebe6339eb6f42ed15df1a76d142be653e", "filename": "src/utils.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "patch": "@@ -10,12 +10,13 @@ use syntax::ast::Lit_::*;\n use syntax::ast;\n \n // module DefPaths for certain structs/enums we check for\n-pub const OPTION_PATH:       [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const RESULT_PATH:       [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n-pub const STRING_PATH:       [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n-pub const VEC_PATH:          [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n-pub const LL_PATH:           [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n+pub const MUTEX_PATH:  [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n@@ -78,8 +79,8 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n             if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n-                // these are all plugins\n-                return true;\n+                    // these are all plugins\n+                    return true;\n             }\n             // no span for the callee = external macro\n             info.callee.span.map_or(true, |span| {\n@@ -322,3 +323,49 @@ pub fn is_integer_literal(expr: &Expr, value: u64) -> bool\n     }\n     false\n }\n+\n+/// Produce a nested chain of if-lets and ifs from the patterns:\n+///\n+///     if_let_chain! {\n+///         [\n+///             Some(y) = x,\n+///             y.len() == 2,\n+///             Some(z) = y,\n+///         ],\n+///         {\n+///             block\n+///         }\n+///     }\n+///\n+/// becomes\n+///\n+///     if let Some(y) = x {\n+///         if y.len() == 2 {\n+///             if let Some(z) = y {\n+///                 block\n+///             }\n+///         }\n+///     }\n+#[macro_export]\n+macro_rules! if_let_chain {\n+    ([let $pat:pat = $expr:expr, $($tt:tt)+], $block:block) => {\n+        if let $pat = $expr {\n+           if_let_chain!{ [$($tt)+], $block }\n+        }\n+    };\n+    ([let $pat:pat = $expr:expr], $block:block) => {\n+        if let $pat = $expr {\n+           $block\n+        }\n+    };\n+    ([$expr:expr, $($tt:tt)+], $block:block) => {\n+        if $expr {\n+           if_let_chain!{ [$($tt)+], $block }\n+        }\n+    };\n+    ([$expr:expr], $block:block) => {\n+        if $expr {\n+           $block\n+        }\n+    };\n+}"}, {"sha": "20a34ba5547c3a6e5c2d7311e6796a7d273dc23c", "filename": "tests/compile-fail/mutex_atomic.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/tests%2Fcompile-fail%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1e83b6dcc9122691325681028ba6e13a7c2e6b/tests%2Fcompile-fail%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmutex_atomic.rs?ref=cf1e83b6dcc9122691325681028ba6e13a7c2e6b", "patch": "@@ -0,0 +1,18 @@\n+#![feature(plugin)]\n+\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+#![deny(mutex_integer)]\n+\n+fn main() {\n+    use std::sync::Mutex;\n+    Mutex::new(true); //~ERROR Consider using an AtomicBool instead of a Mutex here.\n+    Mutex::new(5usize); //~ERROR Consider using an AtomicUsize instead of a Mutex here.\n+    Mutex::new(9isize); //~ERROR Consider using an AtomicIsize instead of a Mutex here.\n+    let mut x = 4u32;\n+    Mutex::new(&x as *const u32); //~ERROR Consider using an AtomicPtr instead of a Mutex here.\n+    Mutex::new(&mut x as *mut u32); //~ERROR Consider using an AtomicPtr instead of a Mutex here.\n+    Mutex::new(0u32); //~ERROR Consider using an AtomicUsize instead of a Mutex here.\n+    Mutex::new(0i32); //~ERROR Consider using an AtomicIsize instead of a Mutex here.\n+    Mutex::new(0f32); // there are no float atomics, so this should not lint\n+}"}]}