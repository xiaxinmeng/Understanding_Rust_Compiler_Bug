{"sha": "1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYzZjM2M0YWQyZDA4Y2M4ZDhkNDE0Y2QwNGNiZjAzNTBlMmJiMTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-19T12:29:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T12:29:20Z"}, "message": "Rollup merge of #73011 - richkadel:llvm-count-from-mir-pass, r=tmandry\n\nfirst stage of implementing LLVM code coverage\n\nThis PR replaces #70680 (WIP toward LLVM Code Coverage for Rust) since I am re-implementing the Rust LLVM code coverage feature in a different part of the compiler (in MIR pass(es) vs AST).\n\nThis PR updates rustc with `-Zinstrument-coverage` option that injects the llvm intrinsic `instrprof.increment()` for code generation.\n\nThis initial version only injects counters at the top of each function, and does not yet implement the required coverage map.\n\nUpcoming PRs will add the coverage map, and add more counters and/or counter expressions for each conditional code branch.\n\nRust compiler MCP https://github.com/rust-lang/compiler-team/issues/278\nRelevant issue: #34701 - Implement support for LLVMs code coverage instrumentation\n\n***[I put together some development notes here, under a separate branch.](https://github.com/richkadel/rust/blob/cfa0b21d34ee64e4ebee226101bd2ef0c6757865/src/test/codegen/coverage-experiments/README-THIS-IS-TEMPORARY.md)***", "tree": {"sha": "38f8f485a73ff92ce90afeb89552b67929d33bb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38f8f485a73ff92ce90afeb89552b67929d33bb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7K+gCRBK7hj4Ov3rIwAAdHIIAH4Fnm2rHVLP9jAZjDT30NbF\nGxqvjThZ0bL3qJj1MH5FLddCszTsQRHxZTh11/IWuGOiCmxfXqfMnYQhtIBxlRBY\nICwlHGey1CdNnwjCseDTnq3c9W8Aw2BLV9sMkWQ06xXlzEWpS82gltid+HLovaho\nvfLEp89z5fI7Djqt0JZMNZ1HQXT0uajyb0WL0UWMzx4+oJUoKxsP08dd5dBYjm0C\nxCYQ+lvarL9cPow2d4BW4ukzKs0QcAWQFigcB8WbkJ4P29Di7ZhfFiOKKvx61bI4\nqH9UBgRbjm3mqykCi8RRrkYDBBxMaoMpNbp66AHMPF+7txow8JIt+WkcMo7bsiU=\n=OsbY\n-----END PGP SIGNATURE-----\n", "payload": "tree 38f8f485a73ff92ce90afeb89552b67929d33bb4\nparent 7cc45183cac5a4cfea21ecf94aa397781b969ea4\nparent 36c9014ddd3e2ac6b6a0e9f623e791281c40473d\nauthor Ralf Jung <post@ralfj.de> 1592569760 +0200\ncommitter GitHub <noreply@github.com> 1592569760 +0200\n\nRollup merge of #73011 - richkadel:llvm-count-from-mir-pass, r=tmandry\n\nfirst stage of implementing LLVM code coverage\n\nThis PR replaces #70680 (WIP toward LLVM Code Coverage for Rust) since I am re-implementing the Rust LLVM code coverage feature in a different part of the compiler (in MIR pass(es) vs AST).\n\nThis PR updates rustc with `-Zinstrument-coverage` option that injects the llvm intrinsic `instrprof.increment()` for code generation.\n\nThis initial version only injects counters at the top of each function, and does not yet implement the required coverage map.\n\nUpcoming PRs will add the coverage map, and add more counters and/or counter expressions for each conditional code branch.\n\nRust compiler MCP https://github.com/rust-lang/compiler-team/issues/278\nRelevant issue: #34701 - Implement support for LLVMs code coverage instrumentation\n\n***[I put together some development notes here, under a separate branch.](https://github.com/richkadel/rust/blob/cfa0b21d34ee64e4ebee226101bd2ef0c6757865/src/test/codegen/coverage-experiments/README-THIS-IS-TEMPORARY.md)***\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "html_url": "https://github.com/rust-lang/rust/commit/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cc45183cac5a4cfea21ecf94aa397781b969ea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cc45183cac5a4cfea21ecf94aa397781b969ea4", "html_url": "https://github.com/rust-lang/rust/commit/7cc45183cac5a4cfea21ecf94aa397781b969ea4"}, {"sha": "36c9014ddd3e2ac6b6a0e9f623e791281c40473d", "url": "https://api.github.com/repos/rust-lang/rust/commits/36c9014ddd3e2ac6b6a0e9f623e791281c40473d", "html_url": "https://github.com/rust-lang/rust/commit/36c9014ddd3e2ac6b6a0e9f623e791281c40473d"}], "stats": {"total": 387, "additions": 383, "deletions": 4}, "files": [{"sha": "bc6760334170b5bd1bc63cdb1f507e2ab1acb5bb", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -209,7 +209,8 @@\n # Build the sanitizer runtimes\n #sanitizers = false\n \n-# Build the profiler runtime\n+# Build the profiler runtime (required when compiling with options that depend\n+# on this runtime, such as `-C profile-generate` or `-Z instrument-coverage`).\n #profiler = false\n \n # Indicates whether the native libraries linked into Cargo will be statically"}, {"sha": "2d3e18146610510bf927e58282075901699dc119", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -1941,6 +1941,13 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Perma-unstable: do not use.\n     pub fn miri_start_panic(payload: *mut u8) -> !;\n+\n+    /// Internal placeholder for injecting code coverage counters when the \"instrument-coverage\"\n+    /// option is enabled. The placeholder is replaced with `llvm.instrprof.increment` during code\n+    /// generation.\n+    #[cfg(not(bootstrap))]\n+    #[lang = \"count_code_region\"]\n+    pub fn count_code_region(index: u32);\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "ba285b5ef38d12efa9c72d75794080ef9848fa49", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -997,6 +997,33 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end.p0i8\", ptr, size);\n     }\n \n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: &'ll Value,\n+        hash: &'ll Value,\n+        num_counters: &'ll Value,\n+        index: &'ll Value,\n+    ) -> &'ll Value {\n+        debug!(\n+            \"instrprof_increment() with args ({:?}, {:?}, {:?}, {:?})\",\n+            fn_name, hash, num_counters, index\n+        );\n+\n+        let llfn = unsafe { llvm::LLVMRustGetInstrprofIncrementIntrinsic(self.cx().llmod) };\n+        let args = &[fn_name, hash, num_counters, index];\n+        let args = self.check_call(\"call\", llfn, args);\n+\n+        unsafe {\n+            llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                None,\n+            )\n+        }\n+    }\n+\n     fn call(\n         &mut self,\n         llfn: &'ll Value,"}, {"sha": "7ff5ac5cbdc10082bbdc7b54d1115784fd20addf", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -749,6 +749,8 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.lifetime.start.p0i8\", fn(t_i64, i8p) -> void);\n         ifn!(\"llvm.lifetime.end.p0i8\", fn(t_i64, i8p) -> void);\n \n+        ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n+\n         ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n         ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n         ifn!(\"llvm.localescape\", fn(...) -> void);"}, {"sha": "95465939070a0e62a6e8a9749df0386fa67fc890", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -7,6 +7,8 @@ use crate::type_of::LayoutLlvmExt;\n use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n+use log::debug;\n+\n use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n@@ -21,6 +23,7 @@ use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::Span;\n+use rustc_span::Symbol;\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n \n@@ -86,6 +89,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n+        caller_instance: ty::Instance<'tcx>,\n     ) {\n         let tcx = self.tcx;\n         let callee_ty = instance.monomorphic_ty(tcx);\n@@ -136,6 +140,28 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n+            \"count_code_region\" => {\n+                if let ty::InstanceDef::Item(fn_def_id) = caller_instance.def {\n+                    let caller_fn_path = tcx.def_path_str(fn_def_id);\n+                    debug!(\n+                        \"count_code_region to llvm.instrprof.increment(fn_name={})\",\n+                        caller_fn_path\n+                    );\n+\n+                    // FIXME(richkadel): (1) Replace raw function name with mangled function name;\n+                    // (2) Replace hardcoded `1234` in `hash` with a computed hash (as discussed in)\n+                    // the MCP (compiler-team/issues/278); and replace the hardcoded `1` for\n+                    // `num_counters` with the actual number of counters per function (when the\n+                    // changes are made to inject more than one counter per function).\n+                    let (fn_name, _len_val) = self.const_str(Symbol::intern(&caller_fn_path));\n+                    let index = args[0].immediate();\n+                    let hash = self.const_u64(1234);\n+                    let num_counters = self.const_u32(1);\n+                    self.instrprof_increment(fn_name, hash, num_counters, index)\n+                } else {\n+                    bug!(\"intrinsic count_code_region: no src.instance\");\n+                }\n+            }\n             \"va_start\" => self.va_start(args[0].immediate()),\n             \"va_end\" => self.va_end(args[0].immediate()),\n             \"va_copy\" => {"}, {"sha": "372fb17573a4bd8069cb6577980168226e7a5efa", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -1360,6 +1360,7 @@ extern \"C\" {\n \n     // Miscellaneous instructions\n     pub fn LLVMBuildPhi(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustGetInstrprofIncrementIntrinsic(M: &Module) -> &'a Value;\n     pub fn LLVMRustBuildCall(\n         B: &Builder<'a>,\n         Fn: &'a Value,"}, {"sha": "49054765b9dae73e92aabe78e976b50cd98f41a4", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -175,6 +175,12 @@ impl ModuleConfig {\n                     if sess.opts.debugging_opts.profile && !is_compiler_builtins {\n                         passes.push(\"insert-gcov-profiling\".to_owned());\n                     }\n+\n+                    // The rustc option `-Zinstrument_coverage` injects intrinsic calls to\n+                    // `llvm.instrprof.increment()`, which requires the LLVM `instrprof` pass.\n+                    if sess.opts.debugging_opts.instrument_coverage {\n+                        passes.push(\"instrprof\".to_owned());\n+                    }\n                     passes\n                 },\n                 vec![]"}, {"sha": "d56c816811b3c46d68056e7b662ddba6c08724db", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -693,6 +693,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 &args,\n                 dest,\n                 terminator.source_info.span,\n+                self.instance,\n             );\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {"}, {"sha": "7ffc9f15bffdc59fb6d529834ab7244b1fee5c06", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -260,6 +260,14 @@ pub trait BuilderMethods<'a, 'tcx>:\n     /// Called for `StorageDead`\n     fn lifetime_end(&mut self, ptr: Self::Value, size: Size);\n \n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: Self::Value,\n+        hash: Self::Value,\n+        num_counters: Self::Value,\n+        index: Self::Value,\n+    ) -> Self::Value;\n+\n     fn call(\n         &mut self,\n         llfn: Self::Value,"}, {"sha": "f62019498511c48c166b9280c277948444965811", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -15,6 +15,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,\n         span: Span,\n+        caller_instance: ty::Instance<'tcx>,\n     );\n \n     fn abort(&mut self);"}, {"sha": "091ded6d74d0feb291a9a06bdb03f894cac21fc3", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -242,6 +242,8 @@ language_item_table! {\n \n     StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n \n+    CountCodeRegionFnLangItem,   \"count_code_region\",  count_code_region_fn,    Target::Fn;\n+\n     EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n     EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n "}, {"sha": "c2a7d1a4a6102739589de9e3921dc4c277df6c72", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -548,6 +548,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(human_readable_cgu_names, true);\n     tracked!(inline_in_all_cgus, Some(true));\n     tracked!(insert_sideeffect, true);\n+    tracked!(instrument_coverage, true);\n     tracked!(instrument_mcount, true);\n     tracked!(link_only, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));"}, {"sha": "0dc007bbfd72f8db4fa5acdea855178381a6cd7d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -706,7 +706,9 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn inject_profiler_runtime(&mut self) {\n-        if (self.sess.opts.debugging_opts.profile || self.sess.opts.cg.profile_generate.enabled())\n+        if (self.sess.opts.debugging_opts.instrument_coverage\n+            || self.sess.opts.debugging_opts.profile\n+            || self.sess.opts.cg.profile_generate.enabled())\n             && !self.sess.opts.debugging_opts.no_profiler_runtime\n         {\n             info!(\"loading profiler\");"}, {"sha": "3381b95c2a38e1fd9946c29d088ae2c1a6a06a5a", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -29,6 +29,7 @@ use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::abi;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n@@ -2218,6 +2219,33 @@ impl<'tcx> Operand<'tcx> {\n         })\n     }\n \n+    /// Convenience helper to make a literal-like constant from a given scalar value.\n+    /// Since this is used to synthesize MIR, assumes `user_ty` is None.\n+    pub fn const_from_scalar(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        val: Scalar,\n+        span: Span,\n+    ) -> Operand<'tcx> {\n+        debug_assert!({\n+            let param_env_and_ty = ty::ParamEnv::empty().and(ty);\n+            let type_size = tcx\n+                .layout_of(param_env_and_ty)\n+                .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n+                .size;\n+            let scalar_size = abi::Size::from_bytes(match val {\n+                Scalar::Raw { size, .. } => size,\n+                _ => panic!(\"Invalid scalar type {:?}\", val),\n+            });\n+            scalar_size == type_size\n+        });\n+        Operand::Constant(box Constant {\n+            span,\n+            user_ty: None,\n+            literal: ty::Const::from_scalar(tcx, val, ty),\n+        })\n+    }\n+\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),"}, {"sha": "ac28ccd181520f7092cb546e3fb83b014ef5f39e", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -389,6 +389,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n                 self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n+            // FIXME(#73156): Handle source code coverage in const eval\n+            sym::count_code_region => (),\n             _ => return Ok(false),\n         }\n "}, {"sha": "c36614938e10f9ab8b9a006faae3becece49105b", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -0,0 +1,92 @@\n+use crate::transform::{MirPass, MirSource};\n+use crate::util::patch::MirPatch;\n+use rustc_hir::lang_items;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n+\n+/// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n+/// the intrinsic llvm.instrprof.increment.\n+pub struct InstrumentCoverage;\n+\n+impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.instrument_coverage {\n+            debug!(\"instrumenting {:?}\", src.def_id());\n+            instrument_coverage(tcx, body);\n+        }\n+    }\n+}\n+\n+// The first counter (start of the function) is index zero.\n+const INIT_FUNCTION_COUNTER: u32 = 0;\n+\n+/// Injects calls to placeholder function `count_code_region()`.\n+// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n+// The complete solution will inject counters at each conditional code branch.\n+pub fn instrument_coverage<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let span = body.span.shrink_to_lo();\n+\n+    let count_code_region_fn = function_handle(\n+        tcx,\n+        tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n+        span,\n+    );\n+    let counter_index = Operand::const_from_scalar(\n+        tcx,\n+        tcx.types.u32,\n+        Scalar::from_u32(INIT_FUNCTION_COUNTER),\n+        span,\n+    );\n+\n+    let mut patch = MirPatch::new(body);\n+\n+    let new_block = patch.new_block(placeholder_block(SourceInfo::outermost(body.span)));\n+    let next_block = START_BLOCK;\n+\n+    let temp = patch.new_temp(tcx.mk_unit(), body.span);\n+    patch.patch_terminator(\n+        new_block,\n+        TerminatorKind::Call {\n+            func: count_code_region_fn,\n+            args: vec![counter_index],\n+            // new_block will swapped with the next_block, after applying patch\n+            destination: Some((Place::from(temp), new_block)),\n+            cleanup: None,\n+            from_hir_call: false,\n+            fn_span: span,\n+        },\n+    );\n+\n+    patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n+    patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n+\n+    patch.apply(body);\n+\n+    // To insert the `new_block` in front of the first block in the counted branch (for example,\n+    // the START_BLOCK, at the top of the function), just swap the indexes, leaving the rest of the\n+    // graph unchanged.\n+    body.basic_blocks_mut().swap(next_block, new_block);\n+}\n+\n+fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n+    let ret_ty = tcx.fn_sig(fn_def_id).output();\n+    let ret_ty = ret_ty.no_bound_vars().unwrap();\n+    let substs = tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(ret_ty)));\n+    Operand::function_handle(tcx, fn_def_id, substs, span)\n+}\n+\n+fn placeholder_block<'tcx>(source_info: SourceInfo) -> BasicBlockData<'tcx> {\n+    BasicBlockData {\n+        statements: vec![],\n+        terminator: Some(Terminator {\n+            source_info,\n+            // this gets overwritten by the counter Call\n+            kind: TerminatorKind::Unreachable,\n+        }),\n+        is_cleanup: false,\n+    }\n+}"}, {"sha": "846ed1f86d8d6ab996bd664edc191aaa460331f9", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -28,6 +28,7 @@ pub mod elaborate_drops;\n pub mod generator;\n pub mod inline;\n pub mod instcombine;\n+pub mod instrument_coverage;\n pub mod no_landing_pads;\n pub mod nrvo;\n pub mod promote_consts;\n@@ -288,6 +289,10 @@ fn mir_validated(\n             // What we need to run borrowck etc.\n             &promote_pass,\n             &simplify::SimplifyCfg::new(\"qualify-consts\"),\n+            // If the `instrument-coverage` option is enabled, analyze the CFG, identify each\n+            // conditional branch, construct a coverage map to be passed to LLVM, and inject counters\n+            // where needed.\n+            &instrument_coverage::InstrumentCoverage,\n         ]],\n     );\n "}, {"sha": "f2f07b5d4fb26fba2d7a8acf877d2136f734b2ff", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -5,10 +5,12 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::lang_items;\n+use rustc_hir::lang_items::ITEM_REFS;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::whitelisted;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n+use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n@@ -70,11 +72,21 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n }\n \n impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: Symbol, span: Span) {\n+    fn register(&mut self, name: Symbol, span: Span, hir_id: hir::HirId) {\n         if let Some(&item) = WEAK_ITEMS_REFS.get(&name) {\n             if self.items.require(item).is_err() {\n                 self.items.missing.push(item);\n             }\n+        } else if name == sym::count_code_region {\n+            // `core::intrinsics::code_count_region()` is (currently) the only `extern` lang item\n+            // that is never actually linked. It is not a `weak_lang_item` that can be registered\n+            // when used, and should be registered here instead.\n+            if let Some((item_index, _)) = ITEM_REFS.get(&*name.as_str()).cloned() {\n+                if self.items.items[item_index].is_none() {\n+                    let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n+                    self.items.items[item_index] = Some(item_def_id);\n+                }\n+            }\n         } else {\n             struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)\n                 .emit();\n@@ -91,7 +103,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n         if let Some((lang_item, _)) = hir::lang_items::extract(&i.attrs) {\n-            self.register(lang_item, i.span);\n+            self.register(lang_item, i.span, i.hir_id);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "2d231359057fd1669603e11f5337f6c21e74ba84", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -876,6 +876,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"fix undefined behavior when a thread doesn't eventually make progress \\\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n+    instrument_coverage: bool = (false, parse_bool, [TRACKED],\n+        \"instrument the generated code with LLVM code region counters to \\\n+        (in the future) generate coverage reports (experimental; default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "970a26325926cc13a5cdd391ada1b5fa1d3882c6", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -240,6 +240,7 @@ symbols! {\n         copy_closures,\n         core,\n         core_intrinsics,\n+        count_code_region,\n         crate_id,\n         crate_in_paths,\n         crate_local,"}, {"sha": "3ec6973a17d567fb704eb158d5605ce28d682c00", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -347,6 +347,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 return;\n             }\n \n+            \"count_code_region\" => (0, vec![tcx.types.u32], tcx.mk_unit()),\n+\n             ref other => {\n                 struct_span_err!(\n                     tcx.sess,"}, {"sha": "cdb3a157eab97bc408dceb86f44d79d923025db1", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -5,6 +5,7 @@\n #include \"llvm/IR/DiagnosticPrinter.h\"\n #include \"llvm/IR/GlobalVariable.h\"\n #include \"llvm/IR/Instructions.h\"\n+#include \"llvm/IR/Intrinsics.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Bitcode/BitcodeWriterPass.h\"\n@@ -1364,6 +1365,11 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n       unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n+extern \"C\" LLVMValueRef LLVMRustGetInstrprofIncrementIntrinsic(LLVMModuleRef M) {\n+  return wrap(llvm::Intrinsic::getDeclaration(unwrap(M),\n+              (llvm::Intrinsic::ID)llvm::Intrinsic::instrprof_increment));\n+}\n+\n extern \"C\" LLVMValueRef LLVMRustBuildMemCpy(LLVMBuilderRef B,\n                                             LLVMValueRef Dst, unsigned DstAlign,\n                                             LLVMValueRef Src, unsigned SrcAlign,"}, {"sha": "3fe010ef68fc351abe2709c2560fdcb5ddf5e3c3", "filename": "src/test/mir-opt/instrument_coverage.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -0,0 +1,20 @@\n+// Test that the initial version of Rust coverage injects count_code_region() placeholder calls,\n+// at the top of each function. The placeholders are later converted into LLVM instrprof.increment\n+// intrinsics, during codegen.\n+\n+// needs-profiler-support\n+// compile-flags: -Zinstrument-coverage\n+// EMIT_MIR rustc.main.InstrumentCoverage.diff\n+// EMIT_MIR rustc.bar.InstrumentCoverage.diff\n+fn main() {\n+    loop {\n+        if bar() {\n+            break;\n+        }\n+    }\n+}\n+\n+#[inline(never)]\n+fn bar() -> bool {\n+    true\n+}"}, {"sha": "1e64379aa0e4b6a311e2a3aed3bd63de11cacde0", "filename": "src/test/mir-opt/instrument_coverage/rustc.bar.InstrumentCoverage.diff", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -0,0 +1,41 @@\n+- // MIR for `bar` before InstrumentCoverage\n++ // MIR for `bar` after InstrumentCoverage\n+  \n+  fn bar() -> bool {\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/instrument_coverage.rs:18:13: 18:17\n++     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n+  \n+      bb0: {\n++         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         _1 = const std::intrinsics::count_code_region(const 0u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++                                          // ty::Const\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + val: Value(Scalar(<ZST>))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000000))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n++     }\n++ \n++     bb1 (cleanup): {\n++         resume;                          // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++     }\n++ \n++     bb2: {\n++         StorageDead(_1);                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n+          _0 = const true;                 // scope 0 at $DIR/instrument_coverage.rs:19:5: 19:9\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x01))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:19:5: 19:9\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          return;                          // scope 0 at $DIR/instrument_coverage.rs:20:2: 20:2\n+      }\n+  }\n+  "}, {"sha": "82d21467827ebbcb1f35adbf7a2e57b11b3caf39", "filename": "src/test/mir-opt/instrument_coverage/rustc.main.InstrumentCoverage.diff", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff?ref=1dc6c3c4ad2d08cc8d8d414cd04cbf0350e2bb14", "patch": "@@ -0,0 +1,82 @@\n+- // MIR for `main` before InstrumentCoverage\n++ // MIR for `main` after InstrumentCoverage\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n+      let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+      let mut _2: bool;                    // in scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+      let mut _3: !;                       // in scope 0 at $DIR/instrument_coverage.rs:11:18: 13:10\n++     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+  \n+      bb0: {\n+-         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n++         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++         _4 = const std::intrinsics::count_code_region(const 0u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++                                          // ty::Const\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + val: Value(Scalar(<ZST>))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000000))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n+      }\n+  \n+      bb1: {\n+          StorageLive(_2);                 // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+          _2 = const bar() -> [return: bb3, unwind: bb2]; // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+                                           // ty::Const\n+                                           // + ty: fn() -> bool {bar}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:11:12: 11:15\n+                                           // + literal: Const { ty: fn() -> bool {bar}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb2 (cleanup): {\n+          resume;                          // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n+      }\n+  \n+      bb3: {\n+          FakeRead(ForMatchedPlace, _2);   // scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n+          switchInt(_2) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+      }\n+  \n+      bb4: {\n+          falseEdge -> [real: bb6, imaginary: bb5]; // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+      }\n+  \n+      bb5: {\n+          _1 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:11:9: 13:10\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:11:9: 13:10\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n+          goto -> bb0;                     // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n+      }\n+  \n+      bb6: {\n+          _0 = const ();                   // scope 0 at $DIR/instrument_coverage.rs:12:13: 12:18\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/instrument_coverage.rs:12:13: 12:18\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/instrument_coverage.rs:14:5: 14:6\n+          return;                          // scope 0 at $DIR/instrument_coverage.rs:15:2: 15:2\n++     }\n++ \n++     bb7: {\n++         StorageDead(_4);                 // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n++         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n+      }\n+  }\n+  "}]}