{"sha": "f355aebf107bb4de078525bbafb16952cc9ecb34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNTVhZWJmMTA3YmI0ZGUwNzg1MjViYmFmYjE2OTUyY2M5ZWNiMzQ=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-05-19T20:27:06Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-05-21T15:24:52Z"}, "message": "Move `needless_borrow` to style", "tree": {"sha": "f8efaddfc9f6eb7b0875b9531691c50e07ca8406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8efaddfc9f6eb7b0875b9531691c50e07ca8406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f355aebf107bb4de078525bbafb16952cc9ecb34", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmCn0MwACgkQ2lnoZDo37QZ2tAD+OBrFJD7soovtuX0vQtGZ5m3f\nWngfnmfJvs0g9xrB8jcA/25h0tAcMsEewWL3okRJhBt+zXH3Jq4OdVZD2qjrmkgH\n=URoT\n-----END PGP SIGNATURE-----", "payload": "tree f8efaddfc9f6eb7b0875b9531691c50e07ca8406\nparent 029c3260585bbc16300ef572da439bbecd5c22da\nauthor Jason Newcomb <jsnewcomb@pm.me> 1621456026 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1621610692 -0400\n\nMove `needless_borrow` to style\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f355aebf107bb4de078525bbafb16952cc9ecb34", "html_url": "https://github.com/rust-lang/rust/commit/f355aebf107bb4de078525bbafb16952cc9ecb34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f355aebf107bb4de078525bbafb16952cc9ecb34/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "029c3260585bbc16300ef572da439bbecd5c22da", "url": "https://api.github.com/repos/rust-lang/rust/commits/029c3260585bbc16300ef572da439bbecd5c22da", "html_url": "https://github.com/rust-lang/rust/commit/029c3260585bbc16300ef572da439bbecd5c22da"}], "stats": {"total": 337, "additions": 164, "deletions": 173}, "files": [{"sha": "877d9054d7b230f0afd2442a16d259df10a67a01", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -1361,6 +1361,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n         LintId::of(needless_bool::BOOL_COMPARISON),\n         LintId::of(needless_bool::NEEDLESS_BOOL),\n+        LintId::of(needless_borrow::NEEDLESS_BORROW),\n         LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n         LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(needless_update::NEEDLESS_UPDATE),\n@@ -1544,6 +1545,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(misc_early::REDUNDANT_PATTERN),\n         LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n         LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n+        LintId::of(needless_borrow::NEEDLESS_BORROW),\n         LintId::of(neg_multiply::NEG_MULTIPLY),\n         LintId::of(new_without_default::NEW_WITHOUT_DEFAULT),\n         LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n@@ -1783,7 +1785,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n         LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n         LintId::of(mutex_atomic::MUTEX_INTEGER),\n-        LintId::of(needless_borrow::NEEDLESS_BORROW),\n         LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n         LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n         LintId::of(regex::TRIVIAL_REGEX),"}, {"sha": "bcedebfccc7fadc393d0e06f3d2aebec0b6c7a0b", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -34,7 +34,7 @@ declare_clippy_lint! {\n     /// let x: &i32 = &5;\n     /// ```\n     pub NEEDLESS_BORROW,\n-    nursery,\n+    style,\n     \"taking a reference that is going to be automatically dereferenced\"\n }\n "}, {"sha": "12c44436874e1dbdff49142e105f4ef49275f82a", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -211,7 +211,7 @@ fn check_invalid_ptr_usage<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     ];\n \n     if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Call(fun, args) = expr.kind;\n         if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         let fun_def_path = cx.get_def_path(fun_def_id).into_iter().map(Symbol::to_ident_string).collect::<Vec<_>>();"}, {"sha": "1eaad438237ec16f4831806b7f5588e527cc151e", "filename": "clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -70,7 +70,7 @@ fn check_mod(cx: &EarlyContext<'_>, items: &[P<Item>]) {\n     for item in items {\n         track_uses(\n             cx,\n-            &item,\n+            item,\n             &mut imports_reused_with_self,\n             &mut single_use_usages,\n             &mut macros,\n@@ -117,7 +117,7 @@ fn track_uses(\n \n     match &item.kind {\n         ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) => {\n-            check_mod(cx, &items);\n+            check_mod(cx, items);\n         },\n         ItemKind::MacroDef(MacroDef { macro_rules: true, .. }) => {\n             macros.push(item.ident.name);"}, {"sha": "ee082d30d936b11fa97d3252ed4b13ab820c3e23", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n \n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n-    while let hir::ExprKind::MethodCall(ref path, _, ref args, _) = call.kind {\n+    while let hir::ExprKind::MethodCall(path, _, args, _) = call.kind {\n         if matches!(&*path.ident.as_str(), \"or\" | \"or_else\" | \"ok\") {\n             call = &args[0];\n         } else {"}, {"sha": "a672af88271c3130fb5b6857f8cf39e140df9fc8", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -379,7 +379,7 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n     /// }\n     /// ```\n     fn check_item(&mut self, cx: &LateContext<'hir>, item: &'hir Item<'_>) {\n-        if let ItemKind::Static(ref ty, Mutability::Not, _) = item.kind {\n+        if let ItemKind::Static(ty, Mutability::Not, _) = item.kind {\n             // Normal lint\n             if_chain! {\n                 // item validation\n@@ -489,7 +489,7 @@ fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n         .hir()\n         .attrs(item.hir_id())\n         .iter()\n-        .filter_map(|ref x| x.doc_str().map(|sym| sym.as_str().to_string()))\n+        .filter_map(|x| x.doc_str().map(|sym| sym.as_str().to_string()))\n         .reduce(|mut acc, sym| {\n             acc.push_str(&sym);\n             acc.push('\\n');\n@@ -596,7 +596,7 @@ fn extract_emission_info<'hir>(\n     let mut multi_part = false;\n \n     for arg in args {\n-        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(&arg));\n+        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(arg));\n \n         if match_type(cx, arg_ty, &paths::LINT) {\n             // If we found the lint arg, extract the lint name\n@@ -671,7 +671,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for LintResolver<'a, 'hir> {\n             if let ExprKind::Path(qpath) = &expr.kind;\n             if let QPath::Resolved(_, path) = qpath;\n \n-            let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+            let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(expr));\n             if match_type(self.cx, expr_ty, &paths::LINT);\n             then {\n                 if let hir::def::Res::Def(DefKind::Static, _) = path.res {\n@@ -730,7 +730,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityResolver<'a, 'hir> {\n     }\n \n     fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n-        let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+        let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(expr));\n \n         if_chain! {\n             if match_type(self.cx, expr_ty, &paths::APPLICABILITY);"}, {"sha": "0d7fdeeb920f2c6897f172cf0f239fbf7d6c207b", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -229,25 +229,25 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n         match e.kind {\n             ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n-            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::Block(block, _) => self.block(block),\n             ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n-            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n-            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprKind::Repeat(ref value, _) => {\n+            ExprKind::Array(vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(value, _) => {\n                 let n = match self.typeck_results.expr_ty(e).kind() {\n                     ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n             },\n-            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+            ExprKind::Unary(op, operand) => self.expr(operand).and_then(|o| match op {\n                 UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n                 UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n                 UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n             }),\n-            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n-            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n-            ExprKind::Call(ref callee, ref args) => {\n+            ExprKind::If(cond, then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n+            ExprKind::Binary(op, left, right) => self.binop(op, left, right),\n+            ExprKind::Call(callee, args) => {\n                 // We only handle a few const functions for now.\n                 if_chain! {\n                     if args.is_empty();\n@@ -273,8 +273,8 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     }\n                 }\n             },\n-            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n-            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n+            ExprKind::Index(arr, index) => self.index(arr, index),\n+            ExprKind::AddrOf(_, _, inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n             // TODO: add other expressions.\n             _ => None,\n         }\n@@ -349,7 +349,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     )\n                     .ok()\n                     .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n-                let result = miri_to_const(&result);\n+                let result = miri_to_const(result);\n                 if result.is_some() {\n                     self.needed_resolution = true;\n                 }"}, {"sha": "8be36756b3332a295963c89aa3dace545fd5570d", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -58,7 +58,7 @@ pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n     }\n \n     match expr.kind {\n-        hir::ExprKind::Call(ref path, ref args)\n+        hir::ExprKind::Call(path, args)\n             if matches!(\n                 path.kind,\n                 hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n@@ -70,7 +70,7 @@ pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n                 limits: ast::RangeLimits::Closed,\n             })\n         },\n-        hir::ExprKind::Struct(path, ref fields, None) => match path {\n+        hir::ExprKind::Struct(path, fields, None) => match path {\n             hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n                 start: None,\n                 end: None,\n@@ -112,7 +112,7 @@ pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n     // }\n     // ```\n     if_chain! {\n-        if let Some(ref expr) = local.init;\n+        if let Some(expr) = local.init;\n         if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         then {\n             return true;\n@@ -140,14 +140,14 @@ pub fn for_loop<'tcx>(\n     expr: &'tcx hir::Expr<'tcx>,\n ) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>, Span)> {\n     if_chain! {\n-        if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n+        if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+        if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n         if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprKind::Loop(ref block, ..) = arms[0].body.kind;\n+        if let hir::ExprKind::Loop(block, ..) = arms[0].body.kind;\n         if block.expr.is_none();\n         if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-        if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n-        if let hir::StmtKind::Expr(ref expr) = body.kind;\n+        if let hir::StmtKind::Local(local) = let_stmt.kind;\n+        if let hir::StmtKind::Expr(expr) = body.kind;\n         then {\n             return Some((&*local.pat, &iterargs[0], expr, arms[0].span));\n         }\n@@ -182,7 +182,7 @@ pub enum VecArgs<'a> {\n /// from `vec!`.\n pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<VecArgs<'e>> {\n     if_chain! {\n-        if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let hir::ExprKind::Call(fun, args) = expr.kind;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if is_expn_of(fun.span, \"vec\").is_some();\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n@@ -194,8 +194,8 @@ pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<Ve\n             else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                 // `vec![a, b, c]` case\n                 if_chain! {\n-                    if let hir::ExprKind::Box(ref boxed) = args[0].kind;\n-                    if let hir::ExprKind::Array(ref args) = boxed.kind;\n+                    if let hir::ExprKind::Box(boxed) = args[0].kind;\n+                    if let hir::ExprKind::Array(args) = boxed.kind;\n                     then {\n                         return Some(VecArgs::Vec(&*args));\n                     }\n@@ -227,7 +227,7 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n     /// compared\n     fn ast_matchblock(matchblock_expr: &'tcx Expr<'tcx>) -> Option<Vec<&Expr<'_>>> {\n         if_chain! {\n-            if let ExprKind::Match(ref headerexpr, _, _) = &matchblock_expr.kind;\n+            if let ExprKind::Match(headerexpr, _, _) = &matchblock_expr.kind;\n             if let ExprKind::Tup([lhs, rhs]) = &headerexpr.kind;\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, lhs) = lhs.kind;\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, rhs) = rhs.kind;\n@@ -238,12 +238,12 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n         None\n     }\n \n-    if let ExprKind::Block(ref block, _) = e.kind {\n+    if let ExprKind::Block(block, _) = e.kind {\n         if block.stmts.len() == 1 {\n-            if let StmtKind::Semi(ref matchexpr) = block.stmts.get(0)?.kind {\n+            if let StmtKind::Semi(matchexpr) = block.stmts.get(0)?.kind {\n                 // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n                 if_chain! {\n-                    if let ExprKind::If(ref clause, _, _)  = matchexpr.kind;\n+                    if let ExprKind::If(clause, _, _)  = matchexpr.kind;\n                     if let ExprKind::Unary(UnOp::Not, condition) = clause.kind;\n                     then {\n                         return Some(vec![condition]);\n@@ -252,16 +252,16 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n \n                 // debug macros with two args: `debug_assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n                 if_chain! {\n-                    if let ExprKind::Block(ref matchblock,_) = matchexpr.kind;\n-                    if let Some(ref matchblock_expr) = matchblock.expr;\n+                    if let ExprKind::Block(matchblock,_) = matchexpr.kind;\n+                    if let Some(matchblock_expr) = matchblock.expr;\n                     then {\n                         return ast_matchblock(matchblock_expr);\n                     }\n                 }\n             }\n         } else if let Some(matchblock_expr) = block.expr {\n             // macros with two args: `assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n-            return ast_matchblock(&matchblock_expr);\n+            return ast_matchblock(matchblock_expr);\n         }\n     }\n     None"}, {"sha": "2fc12702f4829df8a311116adb96fa9b560e8517", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 78, "deletions": 85, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -95,12 +95,12 @@ pub struct HirEqInterExpr<'a, 'b, 'tcx> {\n impl HirEqInterExpr<'_, '_, '_> {\n     pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n-            (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n+            (&StmtKind::Local(l), &StmtKind::Local(r)) => {\n                 // This additional check ensures that the type of the locals are equivalent even if the init\n                 // expression or type have some inferred parts.\n                 if let Some(typeck) = self.inner.maybe_typeck_results {\n-                    let l_ty = typeck.pat_ty(&l.pat);\n-                    let r_ty = typeck.pat_ty(&r.pat);\n+                    let l_ty = typeck.pat_ty(l.pat);\n+                    let r_ty = typeck.pat_ty(r.pat);\n                     if !rustc_middle::ty::TyS::same_type(l_ty, r_ty) {\n                         return false;\n                     }\n@@ -110,11 +110,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 // these only get added if the init and type is equal.\n                 both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                     && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r))\n-                    && self.eq_pat(&l.pat, &r.pat)\n-            },\n-            (&StmtKind::Expr(ref l), &StmtKind::Expr(ref r)) | (&StmtKind::Semi(ref l), &StmtKind::Semi(ref r)) => {\n-                self.eq_expr(l, r)\n+                    && self.eq_pat(l.pat, r.pat)\n             },\n+            (&StmtKind::Expr(l), &StmtKind::Expr(r)) | (&StmtKind::Semi(l), &StmtKind::Semi(r)) => self.eq_expr(l, r),\n             _ => false,\n         }\n     }\n@@ -165,7 +163,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 left.eq(right)\n             },\n             _ => {\n-                over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n+                over(left.stmts, right.stmts, |l, r| self.eq_stmt(l, r))\n                     && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n             },\n         }\n@@ -192,20 +190,20 @@ impl HirEqInterExpr<'_, '_, '_> {\n             &reduce_exprkind(self.inner.cx, &left.kind),\n             &reduce_exprkind(self.inner.cx, &right.kind),\n         ) {\n-            (&ExprKind::AddrOf(lb, l_mut, ref le), &ExprKind::AddrOf(rb, r_mut, ref re)) => {\n+            (&ExprKind::AddrOf(lb, l_mut, le), &ExprKind::AddrOf(rb, r_mut, re)) => {\n                 lb == rb && l_mut == r_mut && self.eq_expr(le, re)\n             },\n             (&ExprKind::Continue(li), &ExprKind::Continue(ri)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n             },\n-            (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n+            (&ExprKind::Assign(ll, lr, _), &ExprKind::Assign(rl, rr, _)) => {\n                 self.inner.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n-            (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n+            (&ExprKind::AssignOp(ref lo, ll, lr), &ExprKind::AssignOp(ref ro, rl, rr)) => {\n                 self.inner.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n-            (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n-            (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n+            (&ExprKind::Block(l, _), &ExprKind::Block(r, _)) => self.eq_block(l, r),\n+            (&ExprKind::Binary(l_op, ll, lr), &ExprKind::Binary(r_op, rl, rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     || swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                         l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n@@ -215,40 +213,37 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n+            (&ExprKind::Box(l), &ExprKind::Box(r)) => self.eq_expr(l, r),\n             (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n                 self.inner.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n-            | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n+            (&ExprKind::Cast(lx, lt), &ExprKind::Cast(rx, rt)) | (&ExprKind::Type(lx, lt), &ExprKind::Type(rx, rt)) => {\n                 self.eq_expr(lx, rx) && self.eq_ty(lt, rt)\n             },\n-            (&ExprKind::Field(ref l_f_exp, ref l_f_ident), &ExprKind::Field(ref r_f_exp, ref r_f_ident)) => {\n+            (&ExprKind::Field(l_f_exp, ref l_f_ident), &ExprKind::Field(r_f_exp, ref r_f_ident)) => {\n                 l_f_ident.name == r_f_ident.name && self.eq_expr(l_f_exp, r_f_exp)\n             },\n-            (&ExprKind::Index(ref la, ref li), &ExprKind::Index(ref ra, ref ri)) => {\n-                self.eq_expr(la, ra) && self.eq_expr(li, ri)\n-            },\n-            (&ExprKind::If(ref lc, ref lt, ref le), &ExprKind::If(ref rc, ref rt, ref re)) => {\n+            (&ExprKind::Index(la, li), &ExprKind::Index(ra, ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n+            (&ExprKind::If(lc, lt, ref le), &ExprKind::If(rc, rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n-            (&ExprKind::Loop(ref lb, ref ll, ref lls, _), &ExprKind::Loop(ref rb, ref rl, ref rls, _)) => {\n+            (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n             },\n-            (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n+            (&ExprKind::Match(le, la, ref ls), &ExprKind::Match(re, ra, ref rs)) => {\n                 ls == rs\n                     && self.eq_expr(le, re)\n                     && over(la, ra, |l, r| {\n-                        self.eq_pat(&l.pat, &r.pat)\n+                        self.eq_pat(l.pat, r.pat)\n                             && both(&l.guard, &r.guard, |l, r| self.eq_guard(l, r))\n-                            && self.eq_expr(&l.body, &r.body)\n+                            && self.eq_expr(l.body, r.body)\n                     })\n             },\n             (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n                 self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n+            (&ExprKind::Repeat(le, ref ll_id), &ExprKind::Repeat(re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(ll_id.body));\n                 let ll = celcx.expr(&self.inner.cx.tcx.hir().body(ll_id.body).value);\n                 let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(rl_id.body));\n@@ -258,15 +253,15 @@ impl HirEqInterExpr<'_, '_, '_> {\n             },\n             (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n-            (&ExprKind::Struct(ref l_path, ref lf, ref lo), &ExprKind::Struct(ref r_path, ref rf, ref ro)) => {\n+            (&ExprKind::Struct(l_path, lf, ref lo), &ExprKind::Struct(r_path, rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path)\n                     && both(lo, ro, |l, r| self.eq_expr(l, r))\n                     && over(lf, rf, |l, r| self.eq_expr_field(l, r))\n             },\n             (&ExprKind::Tup(l_tup), &ExprKind::Tup(r_tup)) => self.eq_exprs(l_tup, r_tup),\n-            (&ExprKind::Unary(l_op, ref le), &ExprKind::Unary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n+            (&ExprKind::Unary(l_op, le), &ExprKind::Unary(r_op, re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprKind::Array(l), &ExprKind::Array(r)) => self.eq_exprs(l, r),\n-            (&ExprKind::DropTemps(ref le), &ExprKind::DropTemps(ref re)) => self.eq_expr(le, re),\n+            (&ExprKind::DropTemps(le), &ExprKind::DropTemps(re)) => self.eq_expr(le, re),\n             _ => false,\n         };\n         is_eq || self.inner.expr_fallback.as_mut().map_or(false, |f| f(left, right))\n@@ -277,7 +272,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     fn eq_expr_field(&mut self, left: &ExprField<'_>, right: &ExprField<'_>) -> bool {\n-        left.ident.name == right.ident.name && self.eq_expr(&left.expr, &right.expr)\n+        left.ident.name == right.ident.name && self.eq_expr(left.expr, right.expr)\n     }\n \n     fn eq_guard(&mut self, left: &Guard<'_>, right: &Guard<'_>) -> bool {\n@@ -308,11 +303,11 @@ impl HirEqInterExpr<'_, '_, '_> {\n     /// Checks whether two patterns are the same.\n     fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n-            (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n-            (&PatKind::Struct(ref lp, ref la, ..), &PatKind::Struct(ref rp, ref ra, ..)) => {\n+            (&PatKind::Box(l), &PatKind::Box(r)) => self.eq_pat(l, r),\n+            (&PatKind::Struct(ref lp, la, ..), &PatKind::Struct(ref rp, ra, ..)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat_field(l, r))\n             },\n-            (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n+            (&PatKind::TupleStruct(ref lp, la, ls), &PatKind::TupleStruct(ref rp, ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n             (&PatKind::Binding(lb, li, _, ref lp), &PatKind::Binding(rb, ri, _, ref rp)) => {\n@@ -323,15 +318,13 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 eq\n             },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n-            (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n-            (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n-                ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n-            },\n+            (&PatKind::Lit(l), &PatKind::Lit(r)) => self.eq_expr(l, r),\n+            (&PatKind::Tuple(l, ls), &PatKind::Tuple(r, rs)) => ls == rs && over(l, r, |l, r| self.eq_pat(l, r)),\n             (&PatKind::Range(ref ls, ref le, li), &PatKind::Range(ref rs, ref re, ri)) => {\n                 both(ls, rs, |a, b| self.eq_expr(a, b)) && both(le, re, |a, b| self.eq_expr(a, b)) && (li == ri)\n             },\n-            (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => lm == rm && self.eq_pat(le, re),\n-            (&PatKind::Slice(ref ls, ref li, ref le), &PatKind::Slice(ref rs, ref ri, ref re)) => {\n+            (&PatKind::Ref(le, ref lm), &PatKind::Ref(re, ref rm)) => lm == rm && self.eq_pat(le, re),\n+            (&PatKind::Slice(ls, ref li, le), &PatKind::Slice(rs, ref ri, re)) => {\n                 over(ls, rs, |l, r| self.eq_pat(l, r))\n                     && over(le, re, |l, r| self.eq_pat(l, r))\n                     && both(li, ri, |l, r| self.eq_pat(l, r))\n@@ -344,10 +337,10 @@ impl HirEqInterExpr<'_, '_, '_> {\n     #[allow(clippy::similar_names)]\n     fn eq_qpath(&mut self, left: &QPath<'_>, right: &QPath<'_>) -> bool {\n         match (left, right) {\n-            (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n+            (&QPath::Resolved(ref lty, lpath), &QPath::Resolved(ref rty, rpath)) => {\n                 both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n             },\n-            (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n+            (&QPath::TypeRelative(lty, lseg), &QPath::TypeRelative(rty, rseg)) => {\n                 self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n             },\n             (&QPath::LangItem(llang_item, _), &QPath::LangItem(rlang_item, _)) => llang_item == rlang_item,\n@@ -359,14 +352,14 @@ impl HirEqInterExpr<'_, '_, '_> {\n         match (left.res, right.res) {\n             (Res::Local(l), Res::Local(r)) => l == r || self.locals.get(&l) == Some(&r),\n             (Res::Local(_), _) | (_, Res::Local(_)) => false,\n-            _ => over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r)),\n+            _ => over(left.segments, right.segments, |l, r| self.eq_path_segment(l, r)),\n         }\n     }\n \n     fn eq_path_parameters(&mut self, left: &GenericArgs<'_>, right: &GenericArgs<'_>) -> bool {\n         if !(left.parenthesized || right.parenthesized) {\n-            over(&left.args, &right.args, |l, r| self.eq_generic_arg(l, r)) // FIXME(flip1995): may not work\n-                && over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n+            over(left.args, right.args, |l, r| self.eq_generic_arg(l, r)) // FIXME(flip1995): may not work\n+                && over(left.bindings, right.bindings, |l, r| self.eq_type_binding(l, r))\n         } else if left.parenthesized && right.parenthesized {\n             over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r))\n                 && both(&Some(&left.bindings[0].ty()), &Some(&right.bindings[0].ty()), |l, r| {\n@@ -390,8 +383,8 @@ impl HirEqInterExpr<'_, '_, '_> {\n     #[allow(clippy::similar_names)]\n     fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n-            (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n+            (&TyKind::Slice(l_vec), &TyKind::Slice(r_vec)) => self.eq_ty(l_vec, r_vec),\n+            (&TyKind::Array(lt, ref ll_id), &TyKind::Array(rt, ref rl_id)) => {\n                 let cx = self.inner.cx;\n                 let eval_const =\n                     |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n@@ -404,14 +397,14 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             },\n             (&TyKind::Path(ref l), &TyKind::Path(ref r)) => self.eq_qpath(l, r),\n-            (&TyKind::Tup(ref l), &TyKind::Tup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n+            (&TyKind::Tup(l), &TyKind::Tup(r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyKind::Infer, &TyKind::Infer) => true,\n             _ => false,\n         }\n     }\n \n     fn eq_type_binding(&mut self, left: &TypeBinding<'_>, right: &TypeBinding<'_>) -> bool {\n-        left.ident.name == right.ident.name && self.eq_ty(&left.ty(), &right.ty())\n+        left.ident.name == right.ident.name && self.eq_ty(left.ty(), right.ty())\n     }\n }\n \n@@ -540,7 +533,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             self.hash_stmt(s);\n         }\n \n-        if let Some(ref e) = b.expr {\n+        if let Some(e) = b.expr {\n             self.hash_expr(e);\n         }\n \n@@ -570,7 +563,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         std::mem::discriminant(&e.kind).hash(&mut self.s);\n \n         match e.kind {\n-            ExprKind::AddrOf(kind, m, ref e) => {\n+            ExprKind::AddrOf(kind, m, e) => {\n                 match kind {\n                     BorrowKind::Ref => 0,\n                     BorrowKind::Raw => 1,\n@@ -584,20 +577,20 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprKind::Assign(ref l, ref r, _) => {\n+            ExprKind::Assign(l, r, _) => {\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprKind::AssignOp(ref o, ref l, ref r) => {\n+            ExprKind::AssignOp(ref o, l, r) => {\n                 o.node\n                     .hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprKind::Block(ref b, _) => {\n+            ExprKind::Block(b, _) => {\n                 self.hash_block(b);\n             },\n-            ExprKind::Binary(op, ref l, ref r) => {\n+            ExprKind::Binary(op, l, r) => {\n                 op.node\n                     .hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n                 self.hash_expr(l);\n@@ -607,18 +600,18 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n-                if let Some(ref j) = *j {\n+                if let Some(j) = *j {\n                     self.hash_expr(&*j);\n                 }\n             },\n-            ExprKind::Box(ref e) | ExprKind::DropTemps(ref e) | ExprKind::Yield(ref e, _) => {\n+            ExprKind::Box(e) | ExprKind::DropTemps(e) | ExprKind::Yield(e, _) => {\n                 self.hash_expr(e);\n             },\n-            ExprKind::Call(ref fun, args) => {\n+            ExprKind::Call(fun, args) => {\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n-            ExprKind::Cast(ref e, ref ty) | ExprKind::Type(ref e, ref ty) => {\n+            ExprKind::Cast(e, ty) | ExprKind::Type(e, ty) => {\n                 self.hash_expr(e);\n                 self.hash_ty(ty);\n             },\n@@ -631,15 +624,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 // closures inherit TypeckResults\n                 self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n-            ExprKind::Field(ref e, ref f) => {\n+            ExprKind::Field(e, ref f) => {\n                 self.hash_expr(e);\n                 self.hash_name(f.name);\n             },\n-            ExprKind::Index(ref a, ref i) => {\n+            ExprKind::Index(a, i) => {\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n             },\n-            ExprKind::InlineAsm(ref asm) => {\n+            ExprKind::InlineAsm(asm) => {\n                 for piece in asm.template {\n                     match piece {\n                         InlineAsmTemplatePiece::String(s) => s.hash(&mut self.s),\n@@ -694,62 +687,62 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);\n             },\n-            ExprKind::Loop(ref b, ref i, ..) => {\n+            ExprKind::Loop(b, ref i, ..) => {\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprKind::If(ref cond, ref then, ref else_opt) => {\n+            ExprKind::If(cond, then, ref else_opt) => {\n                 let c: fn(_, _, _) -> _ = ExprKind::If;\n                 c.hash(&mut self.s);\n                 self.hash_expr(cond);\n-                self.hash_expr(&**then);\n-                if let Some(ref e) = *else_opt {\n+                self.hash_expr(then);\n+                if let Some(e) = *else_opt {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprKind::Match(ref e, arms, ref s) => {\n+            ExprKind::Match(e, arms, ref s) => {\n                 self.hash_expr(e);\n \n                 for arm in arms {\n                     self.hash_pat(arm.pat);\n                     if let Some(ref e) = arm.guard {\n                         self.hash_guard(e);\n                     }\n-                    self.hash_expr(&arm.body);\n+                    self.hash_expr(arm.body);\n                 }\n \n                 s.hash(&mut self.s);\n             },\n-            ExprKind::MethodCall(ref path, ref _tys, args, ref _fn_span) => {\n+            ExprKind::MethodCall(path, ref _tys, args, ref _fn_span) => {\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n             ExprKind::ConstBlock(ref l_id) => {\n                 self.hash_body(l_id.body);\n             },\n-            ExprKind::Repeat(ref e, ref l_id) => {\n+            ExprKind::Repeat(e, ref l_id) => {\n                 self.hash_expr(e);\n                 self.hash_body(l_id.body);\n             },\n             ExprKind::Ret(ref e) => {\n-                if let Some(ref e) = *e {\n+                if let Some(e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n             ExprKind::Path(ref qpath) => {\n                 self.hash_qpath(qpath);\n             },\n-            ExprKind::Struct(ref path, fields, ref expr) => {\n+            ExprKind::Struct(path, fields, ref expr) => {\n                 self.hash_qpath(path);\n \n                 for f in fields {\n                     self.hash_name(f.ident.name);\n-                    self.hash_expr(&f.expr);\n+                    self.hash_expr(f.expr);\n                 }\n \n-                if let Some(ref e) = *expr {\n+                if let Some(e) = *expr {\n                     self.hash_expr(e);\n                 }\n             },\n@@ -759,7 +752,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             ExprKind::Array(v) => {\n                 self.hash_exprs(v);\n             },\n-            ExprKind::Unary(lop, ref le) => {\n+            ExprKind::Unary(lop, le) => {\n                 lop.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n                 self.hash_expr(le);\n             },\n@@ -778,10 +771,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_qpath(&mut self, p: &QPath<'_>) {\n         match *p {\n-            QPath::Resolved(_, ref path) => {\n+            QPath::Resolved(_, path) => {\n                 self.hash_path(path);\n             },\n-            QPath::TypeRelative(_, ref path) => {\n+            QPath::TypeRelative(_, path) => {\n                 self.hash_name(path.ident.name);\n             },\n             QPath::LangItem(lang_item, ..) => {\n@@ -875,7 +868,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         match &b.kind {\n             StmtKind::Local(local) => {\n                 self.hash_pat(local.pat);\n-                if let Some(ref init) = local.init {\n+                if let Some(init) = local.init {\n                     self.hash_expr(init);\n                 }\n             },\n@@ -888,7 +881,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_guard(&mut self, g: &Guard<'_>) {\n         match g {\n-            Guard::If(ref expr) | Guard::IfLet(_, ref expr) => {\n+            Guard::If(expr) | Guard::IfLet(_, expr) => {\n                 self.hash_expr(expr);\n             },\n         }\n@@ -921,25 +914,25 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_body(anon_const.body);\n             },\n             TyKind::Ptr(ref mut_ty) => {\n-                self.hash_ty(&mut_ty.ty);\n+                self.hash_ty(mut_ty.ty);\n                 mut_ty.mutbl.hash(&mut self.s);\n             },\n             TyKind::Rptr(lifetime, ref mut_ty) => {\n                 self.hash_lifetime(lifetime);\n-                self.hash_ty(&mut_ty.ty);\n+                self.hash_ty(mut_ty.ty);\n                 mut_ty.mutbl.hash(&mut self.s);\n             },\n             TyKind::BareFn(bfn) => {\n                 bfn.unsafety.hash(&mut self.s);\n                 bfn.abi.hash(&mut self.s);\n                 for arg in bfn.decl.inputs {\n-                    self.hash_ty(&arg);\n+                    self.hash_ty(arg);\n                 }\n                 match bfn.decl.output {\n                     FnRetTy::DefaultReturn(_) => {\n                         ().hash(&mut self.s);\n                     },\n-                    FnRetTy::Return(ref ty) => {\n+                    FnRetTy::Return(ty) => {\n                         self.hash_ty(ty);\n                     },\n                 }\n@@ -951,16 +944,16 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 }\n             },\n             TyKind::Path(ref qpath) => match qpath {\n-                QPath::Resolved(ref maybe_ty, ref path) => {\n-                    if let Some(ref ty) = maybe_ty {\n+                QPath::Resolved(ref maybe_ty, path) => {\n+                    if let Some(ty) = maybe_ty {\n                         self.hash_ty(ty);\n                     }\n                     for segment in path.segments {\n                         segment.ident.name.hash(&mut self.s);\n                         self.hash_generic_args(segment.args().args);\n                     }\n                 },\n-                QPath::TypeRelative(ref ty, ref segment) => {\n+                QPath::TypeRelative(ty, segment) => {\n                     self.hash_ty(ty);\n                     segment.ident.name.hash(&mut self.s);\n                 },"}, {"sha": "610011af059284b0b9172a5cf8a9ebb9e78fbcfb", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -328,7 +328,7 @@ pub fn is_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol)\n \n /// Checks if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+    if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n         if let [p] = path.segments {\n             return p.ident.name == var;\n         }\n@@ -338,8 +338,8 @@ pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n \n pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     match *path {\n-        QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n-        QPath::TypeRelative(_, ref seg) => seg,\n+        QPath::Resolved(_, path) => path.segments.last().expect(\"A path must have at least one segment\"),\n+        QPath::TypeRelative(_, seg) => seg,\n         QPath::LangItem(..) => panic!(\"last_path_segment: lang item has no path segments\"),\n     }\n }\n@@ -367,8 +367,8 @@ pub fn get_qpath_generic_tys(path: &QPath<'tcx>) -> impl Iterator<Item = &'tcx h\n \n pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n     match *path {\n-        QPath::Resolved(_, ref path) => path.segments.get(0),\n-        QPath::TypeRelative(_, ref seg) => Some(seg),\n+        QPath::Resolved(_, path) => path.segments.get(0),\n+        QPath::TypeRelative(_, seg) => Some(seg),\n         QPath::LangItem(..) => None,\n     }\n }\n@@ -388,8 +388,8 @@ pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment\n /// ```\n pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n     match *path {\n-        QPath::Resolved(_, ref path) => match_path(path, segments),\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n+        QPath::Resolved(_, path) => match_path(path, segments),\n+        QPath::TypeRelative(ty, segment) => match ty.kind {\n             TyKind::Path(ref inner_path) => {\n                 if let [prefix @ .., end] = segments {\n                     if match_qpath(inner_path, prefix) {\n@@ -457,7 +457,7 @@ pub fn match_path(path: &Path<'_>, segments: &[&str]) -> bool {\n \n /// If the expression is a path to a local, returns the canonical `HirId` of the local.\n pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+    if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n         if let Res::Local(id) = path.res {\n             return Some(id);\n         }\n@@ -661,12 +661,12 @@ pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprKind::MethodCall(ref path, _, ref args, _) = current.kind {\n+        if let ExprKind::MethodCall(path, _, args, _) = current.kind {\n             if path.ident.name.as_str() == *method_name {\n                 if args.iter().any(|e| e.span.from_expansion()) {\n                     return None;\n                 }\n-                matched.push(&**args); // build up `matched` backwards\n+                matched.push(args); // build up `matched` backwards\n                 current = &args[0] // go to parent expression\n             } else {\n                 return None;\n@@ -712,7 +712,7 @@ pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n     match pat.kind {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n         PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        PatKind::Box(p) | PatKind::Ref(p, _) => get_pat_name(&*p),\n         _ => None,\n     }\n }\n@@ -854,7 +854,7 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n             kind: ImplItemKind::Fn(_, eid),\n             ..\n         }) => match cx.tcx.hir().body(eid).value.kind {\n-            ExprKind::Block(ref block, _) => Some(block),\n+            ExprKind::Block(block, _) => Some(block),\n             _ => None,\n         },\n         _ => None,\n@@ -1028,7 +1028,7 @@ pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx>\n \n /// Checks if an expression is constructing a tuple-like enum variant or struct\n pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Call(ref fun, _) = expr.kind {\n+    if let ExprKind::Call(fun, _) = expr.kind {\n         if let ExprKind::Path(ref qp) = fun.kind {\n             let res = cx.qpath_res(qp, fun.hir_id);\n             return match res {\n@@ -1058,21 +1058,21 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n     match pat.kind {\n         PatKind::Wild => false,\n         PatKind::Binding(_, _, _, pat) => pat.map_or(false, |pat| is_refutable(cx, pat)),\n-        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Box(pat) | PatKind::Ref(pat, _) => is_refutable(cx, pat),\n         PatKind::Lit(..) | PatKind::Range(..) => true,\n         PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n-        PatKind::Or(ref pats) => {\n+        PatKind::Or(pats) => {\n             // TODO: should be the honest check, that pats is exhaustive set\n             are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n-        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(ref qpath, ref fields, _) => {\n+        PatKind::Tuple(pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n+        PatKind::Struct(ref qpath, fields, _) => {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, fields.iter().map(|field| &*field.pat))\n         },\n-        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+        PatKind::TupleStruct(ref qpath, pats, _) => {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n-        PatKind::Slice(ref head, ref middle, ref tail) => {\n+        PatKind::Slice(head, ref middle, tail) => {\n             match &cx.typeck_results().node_type(pat.hir_id).kind() {\n                 rustc_ty::Slice(..) => {\n                     // [..] is the only irrefutable slice pattern.\n@@ -1111,7 +1111,7 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n /// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n /// themselves.\n pub fn remove_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n-    while let ExprKind::Block(ref block, ..) = expr.kind {\n+    while let ExprKind::Block(block, ..) = expr.kind {\n         match (block.stmts.is_empty(), block.expr.as_ref()) {\n             (true, Some(e)) => expr = e,\n             _ => break,\n@@ -1130,7 +1130,7 @@ pub fn is_self(slf: &Param<'_>) -> bool {\n \n pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n     if_chain! {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = slf.kind;\n+        if let TyKind::Path(QPath::Resolved(None, path)) = slf.kind;\n         if let Res::SelfTy(..) = path.res;\n         then {\n             return true\n@@ -1148,7 +1148,7 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl It\n pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     fn is_ok(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if_chain! {\n-            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n+            if let PatKind::TupleStruct(ref path, pat, None) = arm.pat.kind;\n             if is_lang_ctor(cx, path, ResultOk);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n             if path_to_local_id(arm.body, hir_id);\n@@ -1167,7 +1167,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n         }\n     }\n \n-    if let ExprKind::Match(_, ref arms, ref source) = expr.kind {\n+    if let ExprKind::Match(_, arms, ref source) = expr.kind {\n         // desugared from a `?` operator\n         if let MatchSource::TryDesugar = *source {\n             return Some(expr);\n@@ -1254,7 +1254,7 @@ pub fn match_function_call<'tcx>(\n     path: &[&str],\n ) -> Option<&'tcx [Expr<'tcx>]> {\n     if_chain! {\n-        if let ExprKind::Call(ref fun, args) = expr.kind;\n+        if let ExprKind::Call(fun, args) = expr.kind;\n         if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, fun_def_id, path);\n@@ -1316,15 +1316,15 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     let mut conds = Vec::new();\n     let mut blocks: Vec<&Block<'_>> = Vec::new();\n \n-    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.kind {\n-        conds.push(&**cond);\n-        if let ExprKind::Block(ref block, _) = then_expr.kind {\n+    while let ExprKind::If(cond, then_expr, ref else_expr) = expr.kind {\n+        conds.push(cond);\n+        if let ExprKind::Block(block, _) = then_expr.kind {\n             blocks.push(block);\n         } else {\n             panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n-        if let Some(ref else_expr) = *else_expr {\n+        if let Some(else_expr) = *else_expr {\n             expr = else_expr;\n         } else {\n             break;\n@@ -1333,8 +1333,8 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n \n     // final `else {..}`\n     if !blocks.is_empty() {\n-        if let ExprKind::Block(ref block, _) = expr.kind {\n-            blocks.push(&**block);\n+        if let ExprKind::Block(block, _) = expr.kind {\n+            blocks.push(block);\n         }\n     }\n \n@@ -1383,7 +1383,7 @@ pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n // check if expr is calling method or function with #[must_use] attribute\n pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let did = match expr.kind {\n-        ExprKind::Call(ref path, _) => if_chain! {\n+        ExprKind::Call(path, _) => if_chain! {\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if let def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id);\n             then {\n@@ -1396,7 +1396,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         _ => None,\n     };\n \n-    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n+    did.map_or(false, |did| must_use_attr(cx.tcx.get_attrs(did)).is_some())\n }\n \n /// Gets the node where an expression is either used, or it's type is unified with another branch."}, {"sha": "546706d51d7b597c3f6d03b90a1448152533d37b", "filename": "clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -52,7 +52,7 @@ impl<'a> NumericLiteral<'a> {\n \n     pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n         if lit_kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n-            let (unsuffixed, suffix) = split_suffix(&src, lit_kind);\n+            let (unsuffixed, suffix) = split_suffix(src, lit_kind);\n             let float = matches!(lit_kind, LitKind::Float(..));\n             Some(NumericLiteral::new(unsuffixed, suffix, float))\n         } else {"}, {"sha": "791688cd194a997a75461edc103998525e434df4", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprKind::MethodCall(ref seg, _, ref args, _) = expr.kind {\n+        if let ExprKind::MethodCall(seg, _, args, _) = expr.kind {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     self.abort = true;\n@@ -79,5 +79,5 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n }\n \n fn get_binding_name(arg: &Param<'_>) -> Option<Symbol> {\n-    get_pat_name(&arg.pat)\n+    get_pat_name(arg.pat)\n }"}, {"sha": "0e6ead675c24754d4515618e48c3ac8b11706acf", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -255,7 +255,7 @@ fn check_place(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'t\n         cursor = proj_base;\n         match elem {\n             ProjectionElem::Field(..) => {\n-                let base_ty = Place::ty_from(place.local, &proj_base, body, tcx).ty;\n+                let base_ty = Place::ty_from(place.local, proj_base, body, tcx).ty;\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     // No union field accesses in `const fn`\n                     if def.is_union() {"}, {"sha": "a92d3be5d3cf2b595d831769b6efbe142ccc15b6", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -142,21 +142,18 @@ pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // Returns whether the type has #[must_use] attribute\n pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n-        ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n-        ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n-        ty::Slice(ref ty)\n-        | ty::Array(ref ty, _)\n-        | ty::RawPtr(ty::TypeAndMut { ref ty, .. })\n-        | ty::Ref(_, ref ty, _) => {\n+        ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did)).is_some(),\n+        ty::Foreign(ref did) => must_use_attr(cx.tcx.get_attrs(*did)).is_some(),\n+        ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n         },\n-        ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n+        ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n+                    if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n                 }\n@@ -166,7 +163,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Dynamic(binder, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n+                    if must_use_attr(cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n                 }\n@@ -305,7 +302,7 @@ pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bo\n /// Returns the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n     match ty.kind {\n-        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n+        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(mut_ty.ty),\n         _ => ty,\n     }\n }"}, {"sha": "31d5a888c69d17cf7f1415e8e6d16336fc9d6b90", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f355aebf107bb4de078525bbafb16952cc9ecb34/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=f355aebf107bb4de078525bbafb16952cc9ecb34", "patch": "@@ -71,12 +71,12 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n \n     fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n-            self.update(&cmt)\n+            self.update(cmt)\n         }\n     }\n \n     fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId) {\n-        self.update(&cmt)\n+        self.update(cmt)\n     }\n \n     fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) {}"}]}