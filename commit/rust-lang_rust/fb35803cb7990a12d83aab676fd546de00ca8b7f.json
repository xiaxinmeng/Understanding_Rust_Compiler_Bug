{"sha": "fb35803cb7990a12d83aab676fd546de00ca8b7f", "node_id": "C_kwDOAAsO6NoAKGZiMzU4MDNjYjc5OTBhMTJkODNhYWI2NzZmZDU0NmRlMDBjYThiN2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T09:20:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T09:20:10Z"}, "message": "Auto merge of #2907 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "8b8d894852929620765acaed378351244dc30701", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b8d894852929620765acaed378351244dc30701"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb35803cb7990a12d83aab676fd546de00ca8b7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb35803cb7990a12d83aab676fd546de00ca8b7f", "html_url": "https://github.com/rust-lang/rust/commit/fb35803cb7990a12d83aab676fd546de00ca8b7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb35803cb7990a12d83aab676fd546de00ca8b7f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ac91624d13624c164800fcd28cb234149ce0f5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac91624d13624c164800fcd28cb234149ce0f5a", "html_url": "https://github.com/rust-lang/rust/commit/1ac91624d13624c164800fcd28cb234149ce0f5a"}, {"sha": "5304e40b93268fa8656945310a9b0c147e969519", "url": "https://api.github.com/repos/rust-lang/rust/commits/5304e40b93268fa8656945310a9b0c147e969519", "html_url": "https://github.com/rust-lang/rust/commit/5304e40b93268fa8656945310a9b0c147e969519"}], "stats": {"total": 6696, "additions": 3776, "deletions": 2920}, "files": [{"sha": "e7aa317ad7501f2f08904c14d469a5cf909bd5f2", "filename": "Cargo.lock", "status": "modified", "additions": 22, "deletions": 121, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -270,17 +270,6 @@ dependencies = [\n  \"generic-array\",\n ]\n \n-[[package]]\n-name = \"bstr\"\n-version = \"0.2.17\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ba3569f383e8f1598449f1a423e72e99569137b47740b1da11ef19af3d5c3223\"\n-dependencies = [\n- \"lazy_static\",\n- \"memchr\",\n- \"regex-automata 0.1.10\",\n-]\n-\n [[package]]\n name = \"bstr\"\n version = \"1.3.0\"\n@@ -417,9 +406,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.77\"\n+version = \"1.0.79\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9f73505338f7d905b19d18738976aae232eb46b8efc15554ffc56deb5d9ebe4\"\n+checksum = \"50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -666,16 +655,6 @@ dependencies = [\n  \"rustc-semver\",\n ]\n \n-[[package]]\n-name = \"codespan-reporting\"\n-version = \"0.11.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e\"\n-dependencies = [\n- \"termcolor\",\n- \"unicode-width\",\n-]\n-\n [[package]]\n name = \"collect-license-metadata\"\n version = \"0.1.0\"\n@@ -842,9 +821,9 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.6\"\n+version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c2dd04ddaf88237dc3b8d8f9a3c1004b506b54b3313403944054d23c0870c521\"\n+checksum = \"a33c2bf77f2df06183c3aa30d1e96c0695a313d4f9c453cc3762a6db39f99200\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils\",\n@@ -863,14 +842,14 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.9.13\"\n+version = \"0.9.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"01a9af1f4c2ef74bb8aa1f7e19706bc72d03598c8a570bb5de72243c7a9d9d5a\"\n+checksum = \"46bd5f3f85273295a9d14aedfb86f6aadbff6d8f5295c4a9edb08e819dcf5695\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n  \"crossbeam-utils\",\n- \"memoffset 0.7.1\",\n+ \"memoffset\",\n  \"scopeguard\",\n ]\n \n@@ -943,50 +922,6 @@ dependencies = [\n  \"winapi\",\n ]\n \n-[[package]]\n-name = \"cxx\"\n-version = \"1.0.94\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f61f1b6389c3fe1c316bf8a4dccc90a38208354b330925bce1f74a6c4756eb93\"\n-dependencies = [\n- \"cc\",\n- \"cxxbridge-flags\",\n- \"cxxbridge-macro\",\n- \"link-cplusplus\",\n-]\n-\n-[[package]]\n-name = \"cxx-build\"\n-version = \"1.0.94\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"12cee708e8962df2aeb38f594aae5d827c022b6460ac71a7a3e2c3c2aae5a07b\"\n-dependencies = [\n- \"cc\",\n- \"codespan-reporting\",\n- \"once_cell\",\n- \"proc-macro2\",\n- \"quote\",\n- \"scratch\",\n- \"syn 2.0.8\",\n-]\n-\n-[[package]]\n-name = \"cxxbridge-flags\"\n-version = \"1.0.94\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7944172ae7e4068c533afbb984114a56c46e9ccddda550499caa222902c7f7bb\"\n-\n-[[package]]\n-name = \"cxxbridge-macro\"\n-version = \"1.0.94\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2345488264226bf682893e25de0769f3360aac9957980ec49361b083ddaa5bc5\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 2.0.8\",\n-]\n-\n [[package]]\n name = \"datafrog\"\n version = \"2.0.1\"\n@@ -1273,7 +1208,7 @@ version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a3cf3a800ff6e860c863ca6d4b16fd999db8b752819c1606884047b73e468535\"\n dependencies = [\n- \"memoffset 0.8.0\",\n+ \"memoffset\",\n  \"rustc_version\",\n ]\n \n@@ -1548,12 +1483,12 @@ checksum = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n \n [[package]]\n name = \"globset\"\n-version = \"0.4.9\"\n+version = \"0.4.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0a1e17342619edbc21a964c2afbeb6c820c6a2560032872f397bb97ea127bd0a\"\n+checksum = \"029d74589adefde59de1a0c4f4732695c32805624aec7b68d91503d4dba79afc\"\n dependencies = [\n  \"aho-corasick\",\n- \"bstr 0.2.17\",\n+ \"bstr\",\n  \"fnv\",\n  \"log\",\n  \"regex\",\n@@ -1688,12 +1623,11 @@ dependencies = [\n \n [[package]]\n name = \"iana-time-zone-haiku\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0703ae284fc167426161c2e3f1da3ea71d94b21bedbcc9494e92b28e334e3dca\"\n+checksum = \"f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f\"\n dependencies = [\n- \"cxx\",\n- \"cxx-build\",\n+ \"cc\",\n ]\n \n [[package]]\n@@ -1780,11 +1714,10 @@ checksum = \"c3360c7b59e5ffa2653671fb74b4741a5d343c03f331c0a4aeda42b5c2b0ec7d\"\n \n [[package]]\n name = \"ignore\"\n-version = \"0.4.18\"\n+version = \"0.4.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"713f1b139373f96a2e0ce3ac931cd01ee973c3c5dd7c40c0c2efe96ad2b6751d\"\n+checksum = \"dbe7873dab538a9a44ad79ede1faf5f30d49f9a5c883ddbab48bce81b64b7492\"\n dependencies = [\n- \"crossbeam-utils\",\n  \"globset\",\n  \"lazy_static\",\n  \"log\",\n@@ -2035,15 +1968,6 @@ dependencies = [\n  \"vcpkg\",\n ]\n \n-[[package]]\n-name = \"link-cplusplus\"\n-version = \"1.0.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ecd207c9c713c34f95a097a5b029ac2ce6010530c7b49d7fea24d977dede04f5\"\n-dependencies = [\n- \"cc\",\n-]\n-\n [[package]]\n name = \"linkchecker\"\n version = \"0.1.0\"\n@@ -2224,24 +2148,6 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"memoffset\"\n-version = \"0.6.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n-dependencies = [\n- \"autocfg\",\n-]\n-\n-[[package]]\n-name = \"memoffset\"\n-version = \"0.7.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4\"\n-dependencies = [\n- \"autocfg\",\n-]\n-\n [[package]]\n name = \"memoffset\"\n version = \"0.8.0\"\n@@ -2439,11 +2345,11 @@ checksum = \"b7e5500299e16ebb147ae15a00a942af264cf3688f47923b8fc2cd5858f23ad3\"\n \n [[package]]\n name = \"opener\"\n-version = \"0.5.0\"\n+version = \"0.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ea3ebcd72a54701f56345f16785a6d3ac2df7e986d273eb4395c0b01db17952\"\n+checksum = \"293c15678e37254c15bd2f092314abb4e51d7fdde05c2021279c12631b54f005\"\n dependencies = [\n- \"bstr 0.2.17\",\n+ \"bstr\",\n  \"winapi\",\n ]\n \n@@ -4082,7 +3988,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"field-offset\",\n  \"measureme\",\n- \"memoffset 0.6.5\",\n+ \"memoffset\",\n  \"rustc-rayon-core\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n@@ -4383,6 +4289,7 @@ dependencies = [\n name = \"rustdoc-gui-test\"\n version = \"0.1.0\"\n dependencies = [\n+ \"build_helper\",\n  \"compiletest\",\n  \"getopts\",\n  \"walkdir\",\n@@ -4530,12 +4437,6 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n-[[package]]\n-name = \"scratch\"\n-version = \"1.0.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1792db035ce95be60c3f8853017b3999209281c24e2ba5bc8e59bf97a0c590c1\"\n-\n [[package]]\n name = \"self_cell\"\n version = \"0.10.2\"\n@@ -5234,7 +5135,7 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"191a442639ea102fa62671026047e51d574bfda44b7fdf32151d7314624c1cd2\"\n dependencies = [\n- \"bstr 1.3.0\",\n+ \"bstr\",\n  \"cargo-platform\",\n  \"cargo_metadata 0.15.3\",\n  \"color-eyre\","}, {"sha": "6e84df5c693b9732796e45a6ad47dbcb0bcb8671", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,4 +1,5 @@\n [workspace]\n+resolver = \"1\"\n members = [\n   \"compiler/rustc\",\n   \"library/std\","}, {"sha": "b719a610e07c78f41e289dcc1bc435e871ce51c4", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -50,7 +50,6 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::MutatingUse(MutatingUseContext::Borrow) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n \n         // `PlaceMention` and `AscribeUserType` both evaluate the place, which must not\n         // contain dangling references."}, {"sha": "cfcf31fce32bd128ad320aa6b8e96cc07c15f169", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -180,24 +180,25 @@ trait TypeOpInfo<'tcx> {\n             return;\n         };\n \n-        let placeholder_region = tcx.mk_re_placeholder(ty::Placeholder {\n-            universe: adjusted_universe.into(),\n-            bound: placeholder.bound,\n-        });\n-\n-        let error_region =\n-            if let RegionElement::PlaceholderRegion(error_placeholder) = error_element {\n-                let adjusted_universe =\n-                    error_placeholder.universe.as_u32().checked_sub(base_universe.as_u32());\n-                adjusted_universe.map(|adjusted| {\n-                    tcx.mk_re_placeholder(ty::Placeholder {\n-                        universe: adjusted.into(),\n-                        bound: error_placeholder.bound,\n-                    })\n-                })\n-            } else {\n-                None\n-            };\n+        let placeholder_region = ty::Region::new_placeholder(\n+            tcx,\n+            ty::Placeholder { universe: adjusted_universe.into(), bound: placeholder.bound },\n+        );\n+\n+        let error_region = if let RegionElement::PlaceholderRegion(error_placeholder) =\n+            error_element\n+        {\n+            let adjusted_universe =\n+                error_placeholder.universe.as_u32().checked_sub(base_universe.as_u32());\n+            adjusted_universe.map(|adjusted| {\n+                ty::Region::new_placeholder(\n+                    tcx,\n+                    ty::Placeholder { universe: adjusted.into(), bound: error_placeholder.bound },\n+                )\n+            })\n+        } else {\n+            None\n+        };\n \n         debug!(?placeholder_region);\n \n@@ -390,7 +391,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n         error_region,\n         &region_constraints,\n         |vid| ocx.infcx.region_var_origin(vid),\n-        |vid| ocx.infcx.universe_of_region(ocx.infcx.tcx.mk_re_var(vid)),\n+        |vid| ocx.infcx.universe_of_region(ty::Region::new_var(ocx.infcx.tcx, vid)),\n     )\n }\n \n@@ -411,7 +412,7 @@ fn try_extract_error_from_region_constraints<'tcx>(\n                 }\n                 // FIXME: Should this check the universe of the var?\n                 Constraint::VarSubReg(vid, sup) if sup == placeholder_region => {\n-                    Some((infcx.tcx.mk_re_var(vid), cause.clone()))\n+                    Some((ty::Region::new_var(infcx.tcx, vid), cause.clone()))\n                 }\n                 _ => None,\n             }"}, {"sha": "b5014a3f479c70a1dec9f6612cfb892b031da263", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -441,7 +441,7 @@ fn for_each_region_constraint<'tcx>(\n         let subject = match req.subject {\n             ClosureOutlivesSubject::Region(subject) => format!(\"{:?}\", subject),\n             ClosureOutlivesSubject::Ty(ty) => {\n-                format!(\"{:?}\", ty.instantiate(tcx, |vid| tcx.mk_re_var(vid)))\n+                format!(\"{:?}\", ty.instantiate(tcx, |vid| ty::Region::new_var(tcx, vid)))\n             }\n         };\n         with_msg(format!(\"where {}: {:?}\", subject, req.outlived_free_region,))?;"}, {"sha": "2a0cb49672b8359299a00cffeba0eacd9ee501c7", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1158,7 +1158,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .universal_regions_outlived_by(r_scc)\n                 .filter(|&u_r| !self.universal_regions.is_local_free_region(u_r))\n                 .find(|&u_r| self.eval_equal(u_r, r_vid))\n-                .map(|u_r| tcx.mk_re_var(u_r))\n+                .map(|u_r| ty::Region::new_var(tcx, u_r))\n                 // In the case of a failure, use `ReErased`. We will eventually\n                 // return `None` in this case.\n                 .unwrap_or(tcx.lifetimes.re_erased)\n@@ -1355,7 +1355,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let vid = self.to_region_vid(r);\n             let scc = self.constraint_sccs.scc(vid);\n             let repr = self.scc_representatives[scc];\n-            tcx.mk_re_var(repr)\n+            ty::Region::new_var(tcx, repr)\n         })\n     }\n \n@@ -1779,7 +1779,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             // If not, report an error.\n-            let member_region = infcx.tcx.mk_re_var(member_region_vid);\n+            let member_region = ty::Region::new_var(infcx.tcx, member_region_vid);\n             errors_buffer.push(RegionErrorKind::UnexpectedHiddenRegion {\n                 span: m_c.definition_span,\n                 hidden_ty: m_c.hidden_ty,"}, {"sha": "33f07c1d8fc419cf23fbfa7a3097e6c39c448ed8", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -92,7 +92,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                     None => {\n                         subst_regions.push(vid);\n-                        infcx.tcx.mk_re_error_with_message(\n+                        ty::Region::new_error_with_message(\n+                            infcx.tcx,\n                             concrete_type.span,\n                             \"opaque type with non-universal region substs\",\n                         )"}, {"sha": "3b896f6540c07282e50ab3acd334c4709b962630", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -139,7 +139,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     upvars: &[Upvar<'tcx>],\n     use_polonius: bool,\n ) -> MirTypeckResults<'tcx> {\n-    let implicit_region_bound = infcx.tcx.mk_re_var(universal_regions.fr_fn_body);\n+    let implicit_region_bound = ty::Region::new_var(infcx.tcx, universal_regions.fr_fn_body);\n     let mut constraints = MirTypeckRegionConstraints {\n         placeholder_indices: PlaceholderIndices::default(),\n         placeholder_index_to_region: IndexVec::default(),\n@@ -766,8 +766,8 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             PlaceContext::MutatingUse(_) => ty::Invariant,\n             PlaceContext::NonUse(StorageDead | StorageLive | VarDebugInfo) => ty::Invariant,\n             PlaceContext::NonMutatingUse(\n-                Inspect | Copy | Move | PlaceMention | SharedBorrow | ShallowBorrow | UniqueBorrow\n-                | AddressOf | Projection,\n+                Inspect | Copy | Move | PlaceMention | SharedBorrow | ShallowBorrow | AddressOf\n+                | Projection,\n             ) => ty::Covariant,\n             PlaceContext::NonUse(AscribeUserTy(variance)) => variance,\n         }"}, {"sha": "c871703429a5e83dfb4721265c862b66d921e87c", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -500,7 +500,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"c-variadic\")))\n                     .as_var();\n \n-                let region = self.infcx.tcx.mk_re_var(reg_vid);\n+                let region = ty::Region::new_var(self.infcx.tcx, reg_vid);\n                 let va_list_ty =\n                     self.infcx.tcx.type_of(va_list_did).subst(self.infcx.tcx, &[region.into()]);\n \n@@ -660,7 +660,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                     kind: ty::BrEnv,\n                 };\n-                let env_region = tcx.mk_re_late_bound(ty::INNERMOST, br);\n+                let env_region = ty::Region::new_late_bound(tcx, ty::INNERMOST, br);\n                 let closure_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n \n                 // The \"inputs\" of the closure in the\n@@ -778,7 +778,8 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n     {\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             debug!(?br);\n-            let liberated_region = self.tcx.mk_re_free(all_outlive_scope.to_def_id(), br.kind);\n+            let liberated_region =\n+                ty::Region::new_free(self.tcx, all_outlive_scope.to_def_id(), br.kind);\n             let region_vid = {\n                 let name = match br.kind.get_name() {\n                     Some(name) => name,\n@@ -889,7 +890,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n-        tcx.fold_regions(value, |region, _| tcx.mk_re_var(self.to_region_vid(region)))\n+        tcx.fold_regions(value, |region, _| ty::Region::new_var(tcx, self.to_region_vid(region)))\n     }\n }\n \n@@ -929,7 +930,7 @@ fn for_each_late_bound_region_in_item<'tcx>(\n \n     for bound_var in tcx.late_bound_vars(tcx.hir().local_def_id_to_hir_id(mir_def_id)) {\n         let ty::BoundVariableKind::Region(bound_region) = bound_var else { continue; };\n-        let liberated_region = tcx.mk_re_free(mir_def_id.to_def_id(), bound_region);\n+        let liberated_region = ty::Region::new_free(tcx, mir_def_id.to_def_id(), bound_region);\n         f(liberated_region);\n     }\n }"}, {"sha": "26dccf309e1e402ff3e8700850bc1a2e81ad43d0", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -42,6 +42,32 @@ This will build your project with rustc_codegen_cranelift instead of the usual L\n \n For additional ways to use rustc_codegen_cranelift like the JIT mode see [usage.md](docs/usage.md).\n \n+## Building and testing with changes in rustc code\n+\n+This is useful when changing code in `rustc_codegen_cranelift` as part of changing [main Rust repository](https://github.com/rust-lang/rust/).\n+This can happen, for example, when you are implementing a new compiler intrinsic.\n+\n+Instruction below uses `$RustCheckoutDir` as substitute for any folder where you cloned Rust repository.\n+\n+You need to do this steps to successfully compile and use the cranelift backend with your changes in rustc code:\n+\n+1. `cd $RustCheckoutDir`\n+2. Run `python x.py setup` and choose option for compiler (`b`).\n+3. Build compiler and necessary tools: `python x.py build --stage=2 compiler library/std src/tools/rustdoc src/tools/rustfmt`\n+   * (Optional) You can also build cargo by adding `src/tools/cargo` to previous command.\n+4. Copy exectutable files from `./build/host/stage2-tools/<your hostname triple>/release`\n+to `./build/host/stage2/bin/`. Note that you would need to do this every time you rebuilt `rust` repository.\n+5. Copy cargo from another toolchain: `cp $(rustup which cargo) .build/<your hostname triple>/stage2/bin/cargo`\n+   * Another option is to build it at step 3 and copy with other executables at step 4.\n+6. Link your new `rustc` to toolchain: `rustup toolchain link stage2 ./build/host/stage2/`.\n+7. (Windows only) compile y.rs: `rustc +stage2 -O y.rs`.\n+8. You need to prefix every `./y.rs` (or `y` if you built `y.rs`) command by `rustup run stage2` to make cg_clif use your local changes in rustc.\n+\n+  * `rustup run stage2 ./y.rs prepare`\n+  * `rustup run stage2 ./y.rs build`\n+  * (Optional) run tests: `rustup run stage2 ./y.rs test`\n+9. Now you can use your cg_clif build to compile other Rust programs, e.g. you can open any Rust crate and run commands like `$RustCheckoutDir/compiler/rustc_codegen_cranelift/dist/cargo-clif build --release`.\n+\n ## Configuration\n \n See the documentation on the `BackendConfig` struct in [config.rs](src/config.rs) for all"}, {"sha": "67fd6d793e0b1923a2798f447c88158cc86b705f", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -361,7 +361,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             ty::ParamEnv::reveal_all(),\n-            ty::EarlyBinder::new(value),\n+            ty::EarlyBinder::bind(value),\n         )\n     }\n "}, {"sha": "bad87db47323e784f5d34012f6429a4115654bed", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,17 +1,15 @@\n use gccjit::LValue;\n use gccjit::{RValue, Type, ToRValue};\n-use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods,\n     ConstMethods,\n-    DerivedTypeMethods,\n     MiscMethods,\n     StaticMethods,\n };\n use rustc_middle::mir::Mutability;\n-use rustc_middle::ty::layout::{TyAndLayout, LayoutOf};\n+use rustc_middle::ty::layout::{LayoutOf};\n use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n-use rustc_target::abi::{self, HasDataLayout, Pointer, Size};\n+use rustc_target::abi::{self, HasDataLayout, Pointer};\n \n use crate::consts::const_alloc_to_gcc;\n use crate::context::CodegenCx;\n@@ -240,28 +238,26 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         const_alloc_to_gcc(self, alloc)\n     }\n \n-    fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: ConstAllocation<'tcx>, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n-        assert_eq!(alloc.inner().align, layout.align.abi);\n-        let ty = self.type_ptr_to(layout.gcc_type(self));\n-        let value =\n-            if layout.size == Size::ZERO {\n-                let value = self.const_usize(alloc.inner().align.bytes());\n-                self.const_bitcast(value, ty)\n-            }\n-            else {\n-                let init = const_alloc_to_gcc(self, alloc);\n-                let base_addr = self.static_addr_of(init, alloc.inner().align, None);\n-\n-                let array = self.const_bitcast(base_addr, self.type_i8p());\n-                let value = self.context.new_array_access(None, array, self.const_usize(offset.bytes())).get_address(None);\n-                self.const_bitcast(value, ty)\n-            };\n-        PlaceRef::new_sized(value, layout)\n-    }\n-\n     fn const_ptrcast(&self, val: RValue<'gcc>, ty: Type<'gcc>) -> RValue<'gcc> {\n         self.context.new_cast(None, val, ty)\n     }\n+\n+    fn const_bitcast(&self, value: RValue<'gcc>, typ: Type<'gcc>) -> RValue<'gcc> {\n+        if value.get_type() == self.bool_type.make_pointer() {\n+            if let Some(pointee) = typ.get_pointee() {\n+                if pointee.dyncast_vector().is_some() {\n+                    panic!()\n+                }\n+            }\n+        }\n+        // NOTE: since bitcast makes a value non-constant, don't bitcast if not necessary as some\n+        // SIMD builtins require a constant value.\n+        self.bitcast_if_needed(value, typ)\n+    }\n+    \n+    fn const_ptr_byte_offset(&self, base_addr: Self::Value, offset: abi::Size) -> Self::Value {\n+        self.context.new_array_access(None, base_addr, self.const_usize(offset.bytes())).get_address(None)\n+    }\n }\n \n pub trait SignType<'gcc, 'tcx> {"}, {"sha": "873f652e6f147e453c88e68a6b210194a58ecd85", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,6 +1,6 @@\n #[cfg(feature = \"master\")]\n use gccjit::FnAttribute;\n-use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue, Type};\n+use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n use rustc_middle::span_bug;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -16,21 +16,6 @@ use crate::context::CodegenCx;\n use crate::errors::InvalidMinimumAlignment;\n use crate::type_of::LayoutGccExt;\n \n-impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n-    pub fn const_bitcast(&self, value: RValue<'gcc>, typ: Type<'gcc>) -> RValue<'gcc> {\n-        if value.get_type() == self.bool_type.make_pointer() {\n-            if let Some(pointee) = typ.get_pointee() {\n-                if pointee.dyncast_vector().is_some() {\n-                    panic!()\n-                }\n-            }\n-        }\n-        // NOTE: since bitcast makes a value non-constant, don't bitcast if not necessary as some\n-        // SIMD builtins require a constant value.\n-        self.bitcast_if_needed(value, typ)\n-    }\n-}\n-\n fn set_global_alignment<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, gv: LValue<'gcc>, mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,"}, {"sha": "a3910fef9549fb20295f05a3bf07d73ec9fe8dd2", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -8,16 +8,15 @@ use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n \n use rustc_ast::Mutability;\n-use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::stable_hasher::{Hash128, HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n use rustc_middle::bug;\n use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n-use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n+use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::{DllCallingConvention, DllImport, PeImportNameType};\n-use rustc_target::abi::{self, AddressSpace, HasDataLayout, Pointer, Size};\n+use rustc_target::abi::{self, AddressSpace, HasDataLayout, Pointer};\n use rustc_target::spec::Target;\n \n use libc::{c_char, c_uint};\n@@ -307,38 +306,24 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         const_alloc_to_llvm(self, alloc)\n     }\n \n-    fn from_const_alloc(\n-        &self,\n-        layout: TyAndLayout<'tcx>,\n-        alloc: ConstAllocation<'tcx>,\n-        offset: Size,\n-    ) -> PlaceRef<'tcx, &'ll Value> {\n-        let alloc_align = alloc.inner().align;\n-        assert_eq!(alloc_align, layout.align.abi);\n-        let llty = self.type_ptr_to(layout.llvm_type(self));\n-        let llval = if layout.size == Size::ZERO {\n-            let llval = self.const_usize(alloc_align.bytes());\n-            unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n-        } else {\n-            let init = const_alloc_to_llvm(self, alloc);\n-            let base_addr = self.static_addr_of(init, alloc_align, None);\n-\n-            let llval = unsafe {\n-                llvm::LLVMRustConstInBoundsGEP2(\n-                    self.type_i8(),\n-                    self.const_bitcast(base_addr, self.type_i8p()),\n-                    &self.const_usize(offset.bytes()),\n-                    1,\n-                )\n-            };\n-            self.const_bitcast(llval, llty)\n-        };\n-        PlaceRef::new_sized(llval, layout)\n-    }\n-\n     fn const_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         consts::ptrcast(val, ty)\n     }\n+\n+    fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        self.const_bitcast(val, ty)\n+    }\n+\n+    fn const_ptr_byte_offset(&self, base_addr: Self::Value, offset: abi::Size) -> Self::Value {\n+        unsafe {\n+            llvm::LLVMRustConstInBoundsGEP2(\n+                self.type_i8(),\n+                self.const_bitcast(base_addr, self.type_i8p()),\n+                &self.const_usize(offset.bytes()),\n+                1,\n+            )\n+        }\n+    }\n }\n \n /// Get the [LLVM type][Type] of a [`Value`]."}, {"sha": "64961baf272f478d8e79d822606b2dfb63f971fa", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -93,7 +93,7 @@ fn make_mir_scope<'ll, 'tcx>(\n             let callee = cx.tcx.subst_and_normalize_erasing_regions(\n                 instance.substs,\n                 ty::ParamEnv::reveal_all(),\n-                ty::EarlyBinder::new(callee),\n+                ty::EarlyBinder::bind(callee),\n             );\n             let callee_fn_abi = cx.fn_abi_of_instance(callee, ty::List::empty());\n             cx.dbg_scope_fn(callee, callee_fn_abi, None)"}, {"sha": "22c1f05974ddde2fa0317b94d23d0c855bdc0e44", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -234,7 +234,6 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             | PlaceContext::NonMutatingUse(\n                 NonMutatingUseContext::Inspect\n                 | NonMutatingUseContext::SharedBorrow\n-                | NonMutatingUseContext::UniqueBorrow\n                 | NonMutatingUseContext::ShallowBorrow\n                 | NonMutatingUseContext::AddressOf\n                 | NonMutatingUseContext::Projection,"}, {"sha": "0041400320260b9ac667b55e8dd58860765a912a", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.cx.tcx(),\n             ty::ParamEnv::reveal_all(),\n-            ty::EarlyBinder::new(value),\n+            ty::EarlyBinder::bind(value),\n         )\n     }\n }"}, {"sha": "4000c9540ce5a6474bcee584dac29d33b2cc53fb", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -8,10 +8,10 @@ use crate::traits::*;\n use crate::MemFlags;\n \n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ConstValue, Pointer, Scalar};\n+use rustc_middle::mir::interpret::{alloc_range, ConstValue, Pointer, Scalar};\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::Ty;\n-use rustc_target::abi::{Abi, Align, Size};\n+use rustc_target::abi::{self, Abi, Align, Size};\n \n use std::fmt;\n \n@@ -115,13 +115,82 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 OperandValue::Pair(a_llval, b_llval)\n             }\n             ConstValue::ByRef { alloc, offset } => {\n-                return bx.load_operand(bx.from_const_alloc(layout, alloc, offset));\n+                return Self::from_const_alloc(bx, layout, alloc, offset);\n             }\n         };\n \n         OperandRef { val, layout }\n     }\n \n+    fn from_const_alloc<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n+        layout: TyAndLayout<'tcx>,\n+        alloc: rustc_middle::mir::interpret::ConstAllocation<'tcx>,\n+        offset: Size,\n+    ) -> Self {\n+        let alloc_align = alloc.inner().align;\n+        assert_eq!(alloc_align, layout.align.abi);\n+        let ty = bx.type_ptr_to(bx.cx().backend_type(layout));\n+\n+        let read_scalar = |start, size, s: abi::Scalar, ty| {\n+            let val = alloc\n+                .0\n+                .read_scalar(\n+                    bx,\n+                    alloc_range(start, size),\n+                    /*read_provenance*/ matches!(s.primitive(), abi::Pointer(_)),\n+                )\n+                .unwrap();\n+            bx.scalar_to_backend(val, s, ty)\n+        };\n+\n+        // It may seem like all types with `Scalar` or `ScalarPair` ABI are fair game at this point.\n+        // However, `MaybeUninit<u64>` is considered a `Scalar` as far as its layout is concerned --\n+        // and yet cannot be represented by an interpreter `Scalar`, since we have to handle the\n+        // case where some of the bytes are initialized and others are not. So, we need an extra\n+        // check that walks over the type of `mplace` to make sure it is truly correct to treat this\n+        // like a `Scalar` (or `ScalarPair`).\n+        match layout.abi {\n+            Abi::Scalar(s @ abi::Scalar::Initialized { .. }) => {\n+                let size = s.size(bx);\n+                assert_eq!(size, layout.size, \"abi::Scalar size does not match layout size\");\n+                let val = read_scalar(Size::ZERO, size, s, ty);\n+                OperandRef { val: OperandValue::Immediate(val), layout }\n+            }\n+            Abi::ScalarPair(\n+                a @ abi::Scalar::Initialized { .. },\n+                b @ abi::Scalar::Initialized { .. },\n+            ) => {\n+                let (a_size, b_size) = (a.size(bx), b.size(bx));\n+                let b_offset = a_size.align_to(b.align(bx).abi);\n+                assert!(b_offset.bytes() > 0);\n+                let a_val = read_scalar(\n+                    Size::ZERO,\n+                    a_size,\n+                    a,\n+                    bx.scalar_pair_element_backend_type(layout, 0, true),\n+                );\n+                let b_val = read_scalar(\n+                    b_offset,\n+                    b_size,\n+                    b,\n+                    bx.scalar_pair_element_backend_type(layout, 1, true),\n+                );\n+                OperandRef { val: OperandValue::Pair(a_val, b_val), layout }\n+            }\n+            _ if layout.is_zst() => OperandRef::new_zst(bx, layout),\n+            _ => {\n+                // Neither a scalar nor scalar pair. Load from a place\n+                let init = bx.const_data_from_alloc(alloc);\n+                let base_addr = bx.static_addr_of(init, alloc_align, None);\n+\n+                let llval = bx.const_ptr_byte_offset(base_addr, offset);\n+                let llval = bx.const_bitcast(llval, ty);\n+                bx.load_operand(PlaceRef::new_sized(llval, layout))\n+            }\n+        }\n+    }\n+\n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n     pub fn immediate(self) -> V {"}, {"sha": "0255b6603805d93fb274542b3af3f32dafe32d4d", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -668,11 +668,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::Rvalue::NullaryOp(ref null_op, ty) => {\n                 let ty = self.monomorphize(ty);\n-                assert!(bx.cx().type_is_sized(ty));\n                 let layout = bx.cx().layout_of(ty);\n                 let val = match null_op {\n-                    mir::NullOp::SizeOf => layout.size.bytes(),\n-                    mir::NullOp::AlignOf => layout.align.abi.bytes(),\n+                    mir::NullOp::SizeOf => {\n+                        assert!(bx.cx().type_is_sized(ty));\n+                        layout.size.bytes()\n+                    }\n+                    mir::NullOp::AlignOf => {\n+                        assert!(bx.cx().type_is_sized(ty));\n+                        layout.align.abi.bytes()\n+                    }\n                     mir::NullOp::OffsetOf(fields) => {\n                         layout.offset_of_subfield(bx.cx(), fields.iter().map(|f| f.index())).bytes()\n                     }"}, {"sha": "dc2fc396480129656ead4f65c127077b4ef13f73", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,8 +1,6 @@\n use super::BackendTypes;\n-use crate::mir::place::PlaceRef;\n use rustc_middle::mir::interpret::{ConstAllocation, Scalar};\n-use rustc_middle::ty::layout::TyAndLayout;\n-use rustc_target::abi::{self, Size};\n+use rustc_target::abi;\n \n pub trait ConstMethods<'tcx>: BackendTypes {\n     // Constant constructors\n@@ -30,12 +28,8 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_data_from_alloc(&self, alloc: ConstAllocation<'tcx>) -> Self::Value;\n \n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: Self::Type) -> Self::Value;\n-    fn from_const_alloc(\n-        &self,\n-        layout: TyAndLayout<'tcx>,\n-        alloc: ConstAllocation<'tcx>,\n-        offset: Size,\n-    ) -> PlaceRef<'tcx, Self::Value>;\n \n     fn const_ptrcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;\n+    fn const_bitcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;\n+    fn const_ptr_byte_offset(&self, val: Self::Value, offset: abi::Size) -> Self::Value;\n }"}, {"sha": "91ccdef7215c23e02f352c18fac5cfeed5944f66", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -497,7 +497,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .try_subst_mir_and_normalize_erasing_regions(\n                 *self.tcx,\n                 self.param_env,\n-                ty::EarlyBinder::new(value),\n+                ty::EarlyBinder::bind(value),\n             )\n             .map_err(|_| err_inval!(TooGeneric))\n     }"}, {"sha": "57d939747aab389195440e33c733cfa9005bac17", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -412,9 +412,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         BorrowKind::Shallow => {\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow)\n                         }\n-                        BorrowKind::Unique => {\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow)\n-                        }\n+                        BorrowKind::Unique => PlaceContext::MutatingUse(MutatingUseContext::Borrow),\n                         BorrowKind::Mut { .. } => {\n                             PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n                         }"}, {"sha": "3d78ea9aa9ba10fda4c104530cbd9dcea8b802b2", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -239,20 +239,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     var: ty::BoundVar::from_u32(index),\n                     kind: ty::BrNamed(def_id, name),\n                 };\n-                tcx.mk_re_late_bound(debruijn, br)\n+                ty::Region::new_late_bound(tcx, debruijn, br)\n             }\n \n             Some(rbv::ResolvedArg::EarlyBound(def_id)) => {\n                 let name = tcx.hir().ty_param_name(def_id.expect_local());\n                 let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n-                tcx.mk_re_early_bound(ty::EarlyBoundRegion { def_id, index, name })\n+                ty::Region::new_early_bound(tcx, ty::EarlyBoundRegion { def_id, index, name })\n             }\n \n             Some(rbv::ResolvedArg::Free(scope, id)) => {\n                 let name = lifetime_name(id.expect_local());\n-                tcx.mk_re_free(scope, ty::BrNamed(id, name))\n+                ty::Region::new_free(tcx, scope, ty::BrNamed(id, name))\n \n                 // (*) -- not late-bound, won't change\n             }\n@@ -269,7 +269,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     // elision. `resolve_lifetime` should have\n                     // reported an error in this case -- but if\n                     // not, let's error out.\n-                    tcx.mk_re_error_with_message(\n+                    ty::Region::new_error_with_message(\n+                        tcx,\n                         lifetime.ident.span,\n                         \"unelided lifetime in signature\",\n                     )\n@@ -485,7 +486,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             debug!(?param, \"unelided lifetime in signature\");\n \n                             // This indicates an illegal lifetime in a non-assoc-trait position\n-                            tcx.mk_re_error_with_message(\n+                            ty::Region::new_error_with_message(\n+                                tcx,\n                                 self.span,\n                                 \"unelided lifetime in signature\",\n                             )\n@@ -1219,15 +1221,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let substs =\n                 candidate.skip_binder().substs.extend_to(tcx, assoc_item.def_id, |param, _| {\n                     let subst = match param.kind {\n-                        GenericParamDefKind::Lifetime => tcx\n-                            .mk_re_late_bound(\n-                                ty::INNERMOST,\n-                                ty::BoundRegion {\n-                                    var: ty::BoundVar::from_usize(num_bound_vars),\n-                                    kind: ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n-                                },\n-                            )\n-                            .into(),\n+                        GenericParamDefKind::Lifetime => ty::Region::new_late_bound(\n+                            tcx,\n+                            ty::INNERMOST,\n+                            ty::BoundRegion {\n+                                var: ty::BoundVar::from_usize(num_bound_vars),\n+                                kind: ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n+                            },\n+                        )\n+                        .into(),\n                         GenericParamDefKind::Type { .. } => tcx\n                             .mk_bound(\n                                 ty::INNERMOST,\n@@ -1278,7 +1280,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // params (and trait ref's late bound params). This logic is very similar to\n             // `Predicate::subst_supertrait`, and it's no coincidence why.\n             let shifted_output = tcx.shift_bound_var_indices(num_bound_vars, output);\n-            let subst_output = ty::EarlyBinder::new(shifted_output).subst(tcx, substs);\n+            let subst_output = ty::EarlyBinder::bind(shifted_output).subst(tcx, substs);\n \n             let bound_vars = tcx.late_bound_vars(binding.hir_id);\n             ty::Binder::bind_with_vars(subst_output, bound_vars)\n@@ -1804,7 +1806,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         } else {\n                             err.emit()\n                         };\n-                        tcx.mk_re_error(e)\n+                        ty::Region::new_error(tcx, e)\n                     })\n                 }\n             })"}, {"sha": "31b89525f15d4ff3fbbbc9292dccad96289f8031", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -472,7 +472,8 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for RemapLateBound<'_, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         if let ty::ReFree(fr) = *r {\n-            self.tcx.mk_re_free(\n+            ty::Region::new_free(\n+                self.tcx,\n                 fr.scope,\n                 self.mapping.get(&fr.bound_region).copied().unwrap_or(fr.bound_region),\n             )\n@@ -786,23 +787,23 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n                     }\n                     let Some(ty::ReEarlyBound(e)) = map.get(&region.into()).map(|r| r.expect_region().kind())\n                     else {\n-                        return tcx.mk_re_error_with_message(return_span, \"expected ReFree to map to ReEarlyBound\")\n+                        return ty::Region::new_error_with_message(tcx, return_span, \"expected ReFree to map to ReEarlyBound\")\n                     };\n-                    tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                    ty::Region::new_early_bound(tcx, ty::EarlyBoundRegion {\n                         def_id: e.def_id,\n                         name: e.name,\n                         index: (e.index as usize - num_trait_substs + num_impl_substs) as u32,\n                     })\n                 });\n                 debug!(%ty);\n-                collected_tys.insert(def_id, ty::EarlyBinder::new(ty));\n+                collected_tys.insert(def_id, ty::EarlyBinder::bind(ty));\n             }\n             Err(err) => {\n                 let reported = tcx.sess.delay_span_bug(\n                     return_span,\n                     format!(\"could not fully resolve: {ty} => {err:?}\"),\n                 );\n-                collected_tys.insert(def_id, ty::EarlyBinder::new(tcx.ty_error(reported)));\n+                collected_tys.insert(def_id, ty::EarlyBinder::bind(tcx.ty_error(reported)));\n             }\n         }\n     }\n@@ -1933,7 +1934,8 @@ pub(super) fn check_type_bounds<'tcx>(\n                 let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n                 let bound_var = ty::BoundVariableKind::Region(kind);\n                 bound_vars.push(bound_var);\n-                tcx.mk_re_late_bound(\n+                ty::Region::new_late_bound(\n+                    tcx,\n                     ty::INNERMOST,\n                     ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n                 )"}, {"sha": "13d1abe2a65662d0bb17ceebe84245668611e31a", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -128,7 +128,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // We don't need to normalize this param-env or anything, since we're only\n     // substituting it with free params, so no additional param-env normalization\n     // can occur on top of what has been done in the param_env query itself.\n-    let param_env = ty::EarlyBinder::new(tcx.param_env(adt_def_id))\n+    let param_env = ty::EarlyBinder::bind(tcx.param_env(adt_def_id))\n         .subst(tcx, adt_to_impl_substs)\n         .with_constness(tcx.constness(drop_impl_def_id));\n \n@@ -183,7 +183,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                 }\n                 RegionResolutionError::SubSupConflict(_, _, _, a, _, b, _) => format!(\"{b}: {a}\"),\n                 RegionResolutionError::UpperBoundUniverseConflict(a, _, _, _, b) => {\n-                    format!(\"{b}: {a}\", a = tcx.mk_re_var(a))\n+                    format!(\"{b}: {a}\", a = ty::Region::new_var(tcx, a))\n                 }\n             };\n             guar = Some("}, {"sha": "1f18017f00b9d3454913cce636e2a7046a08ae9b", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -145,11 +145,13 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     ]);\n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n-            let region = tcx.mk_re_late_bound(\n+            let region = ty::Region::new_late_bound(\n+                tcx,\n                 ty::INNERMOST,\n                 ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(None) },\n             );\n-            let env_region = tcx.mk_re_late_bound(\n+            let env_region = ty::Region::new_late_bound(\n+                tcx,\n                 ty::INNERMOST,\n                 ty::BoundRegion { var: ty::BoundVar::from_u32(1), kind: ty::BrEnv },\n             );\n@@ -393,7 +395,12 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(None) };\n                 (\n                     1,\n-                    vec![tcx.mk_imm_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), param(0))],\n+                    vec![\n+                        tcx.mk_imm_ref(\n+                            ty::Region::new_late_bound(tcx, ty::INNERMOST, br),\n+                            param(0),\n+                        ),\n+                    ],\n                     tcx.mk_projection(discriminant_def_id, tcx.mk_substs(&[param(0).into()])),\n                 )\n             }\n@@ -443,7 +450,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             sym::raw_eq => {\n                 let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(None) };\n-                let param_ty = tcx.mk_imm_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), param(0));\n+                let param_ty =\n+                    tcx.mk_imm_ref(ty::Region::new_late_bound(tcx, ty::INNERMOST, br), param(0));\n                 (1, vec![param_ty; 2], tcx.types.bool)\n             }\n "}, {"sha": "fff417fcb2909901d16c9644bf07c218dc6a697e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -556,11 +556,14 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<TyCtxt<'tcx>>>(\n                 // Same for the region. In our example, 'a corresponds\n                 // to the 'me parameter.\n                 let region_param = gat_generics.param_at(*region_a_idx, tcx);\n-                let region_param = tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n-                    def_id: region_param.def_id,\n-                    index: region_param.index,\n-                    name: region_param.name,\n-                });\n+                let region_param = ty::Region::new_early_bound(\n+                    tcx,\n+                    ty::EarlyBoundRegion {\n+                        def_id: region_param.def_id,\n+                        index: region_param.index,\n+                        name: region_param.name,\n+                    },\n+                );\n                 // The predicate we expect to see. (In our example,\n                 // `Self: 'me`.)\n                 let clause = ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n@@ -593,18 +596,24 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<TyCtxt<'tcx>>>(\n                 debug!(\"required clause: {region_a} must outlive {region_b}\");\n                 // Translate into the generic parameters of the GAT.\n                 let region_a_param = gat_generics.param_at(*region_a_idx, tcx);\n-                let region_a_param = tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n-                    def_id: region_a_param.def_id,\n-                    index: region_a_param.index,\n-                    name: region_a_param.name,\n-                });\n+                let region_a_param = ty::Region::new_early_bound(\n+                    tcx,\n+                    ty::EarlyBoundRegion {\n+                        def_id: region_a_param.def_id,\n+                        index: region_a_param.index,\n+                        name: region_a_param.name,\n+                    },\n+                );\n                 // Same for the region.\n                 let region_b_param = gat_generics.param_at(*region_b_idx, tcx);\n-                let region_b_param = tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n-                    def_id: region_b_param.def_id,\n-                    index: region_b_param.index,\n-                    name: region_b_param.name,\n-                });\n+                let region_b_param = ty::Region::new_early_bound(\n+                    tcx,\n+                    ty::EarlyBoundRegion {\n+                        def_id: region_b_param.def_id,\n+                        index: region_b_param.index,\n+                        name: region_b_param.name,\n+                    },\n+                );\n                 // The predicate we expect to see.\n                 let clause = ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n                     ty::OutlivesPredicate(region_a_param, region_b_param),\n@@ -1398,7 +1407,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             }\n             let mut param_count = CountParams::default();\n             let has_region = pred.visit_with(&mut param_count).is_break();\n-            let substituted_pred = ty::EarlyBinder::new(pred).subst(tcx, substs);\n+            let substituted_pred = ty::EarlyBinder::bind(pred).subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n             if substituted_pred.has_non_region_param() || param_count.params.len() > 1 || has_region"}, {"sha": "2f7d465839c4c0f23123fb906c7d6fb46f50380f", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -440,7 +440,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                                     self.tcx.replace_late_bound_regions_uncached(\n                                         poly_trait_ref,\n                                         |_| {\n-                                            self.tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                                            ty::Region::new_early_bound(self.tcx, ty::EarlyBoundRegion {\n                                                 def_id: item_def_id,\n                                                 index: 0,\n                                                 name: Symbol::intern(&lt_name),\n@@ -1124,7 +1124,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<ty::PolyFnSig<\n             bug!(\"unexpected sort of node in fn_sig(): {:?}\", x);\n         }\n     };\n-    ty::EarlyBinder::new(output)\n+    ty::EarlyBinder::bind(output)\n }\n \n fn infer_return_ty_for_fn_sig<'tcx>(\n@@ -1312,7 +1312,7 @@ fn impl_trait_ref(\n                 check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n             )\n         })\n-        .map(ty::EarlyBinder::new)\n+        .map(ty::EarlyBinder::bind)\n }\n \n fn check_impl_constness("}, {"sha": "b92d561fb86a43a2f47d82fb14ea5a577c27e9ce", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -86,7 +86,7 @@ pub(super) fn explicit_item_bounds(\n         Some(ty::ImplTraitInTraitData::Trait { opaque_def_id, .. }) => {\n             let item = tcx.hir().get_by_def_id(opaque_def_id.expect_local()).expect_item();\n             let opaque_ty = item.expect_opaque_ty();\n-            return ty::EarlyBinder::new(opaque_type_bounds(\n+            return ty::EarlyBinder::bind(opaque_type_bounds(\n                 tcx,\n                 opaque_def_id.expect_local(),\n                 opaque_ty.bounds,\n@@ -124,7 +124,7 @@ pub(super) fn explicit_item_bounds(\n         }\n         _ => bug!(\"item_bounds called on {:?}\", def_id),\n     };\n-    ty::EarlyBinder::new(bounds)\n+    ty::EarlyBinder::bind(bounds)\n }\n \n pub(super) fn item_bounds("}, {"sha": "70d950eddd8a749da2a287083ede727edb7020d8", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -306,11 +306,14 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Gen\n \n             let Some(dup_index) = generics.param_def_id_to_index(tcx, dup_def) else { bug!() };\n \n-            let dup_region = tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n-                def_id: dup_def,\n-                index: dup_index,\n-                name: duplicate.name.ident().name,\n-            });\n+            let dup_region = ty::Region::new_early_bound(\n+                tcx,\n+                ty::EarlyBoundRegion {\n+                    def_id: dup_def,\n+                    index: dup_index,\n+                    name: duplicate.name.ident().name,\n+                },\n+            );\n             predicates.push((\n                 ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n                     ty::OutlivesPredicate(orig_region, dup_region),"}, {"sha": "65ab00fda817a172a5394421bd5fef3c34263edf", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -323,7 +323,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                 return map[&assoc_item.trait_item_def_id.unwrap()];\n             }\n             Err(_) => {\n-                return ty::EarlyBinder::new(tcx.ty_error_with_message(\n+                return ty::EarlyBinder::bind(tcx.ty_error_with_message(\n                     DUMMY_SP,\n                     \"Could not collect return position impl trait in trait tys\",\n                 ));\n@@ -497,7 +497,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n             bug!(\"unexpected sort of node in type_of(): {:?}\", x);\n         }\n     };\n-    ty::EarlyBinder::new(output)\n+    ty::EarlyBinder::bind(output)\n }\n \n fn infer_placeholder_type<'a>("}, {"sha": "7ce48fe1c012ff33e584500c4a075bf1ee5333c6", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                 }\n             }\n \n-            ty::EarlyBinder::new(required_predicates)\n+            ty::EarlyBinder::bind(required_predicates)\n         })\n     }\n }"}, {"sha": "71dca918fc5e131e151833f5e0949169d86d19c2", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -74,7 +74,7 @@ pub(super) fn infer_predicates(\n             if item_required_predicates.len() > item_predicates_len {\n                 predicates_added = true;\n                 global_inferred_outlives\n-                    .insert(item_did.to_def_id(), ty::EarlyBinder::new(item_required_predicates));\n+                    .insert(item_did.to_def_id(), ty::EarlyBinder::bind(item_required_predicates));\n             }\n         }\n "}, {"sha": "4389ad6ef2678ebe83e5b8c3b1499b8f4aa592fe", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -420,20 +420,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .steal_diagnostic(segment.ident.span, StashKey::CallIntoMethod)\n                 {\n                     // Try suggesting `foo(a)` -> `a.foo()` if possible.\n-                    if let Some(ty) =\n-                        self.suggest_call_as_method(\n-                            &mut diag,\n-                            segment,\n-                            arg_exprs,\n-                            call_expr,\n-                            expected\n-                        )\n-                    {\n-                        diag.emit();\n-                        return ty;\n-                    } else {\n-                        diag.emit();\n-                    }\n+                    self.suggest_call_as_method(\n+                        &mut diag,\n+                        segment,\n+                        arg_exprs,\n+                        call_expr,\n+                        expected\n+                    );\n+                    diag.emit();\n                 }\n \n                 let err = self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n@@ -496,9 +490,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         call_expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-    ) -> Option<Ty<'tcx>> {\n+    ) {\n         if let [callee_expr, rest @ ..] = arg_exprs {\n-            let callee_ty = self.typeck_results.borrow().expr_ty_adjusted_opt(callee_expr)?;\n+            let Some(callee_ty) = self.typeck_results.borrow().expr_ty_adjusted_opt(callee_expr) else {\n+                return;\n+            };\n \n             // First, do a probe with `IsSuggestion(true)` to avoid emitting\n             // any strange errors. If it's successful, then we'll do a true\n@@ -513,7 +509,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ProbeScope::AllTraits,\n                 expected.only_has_type(self),\n             ) else {\n-                return None;\n+                return;\n             };\n \n             let pick = self.confirm_method(\n@@ -525,7 +521,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 segment,\n             );\n             if pick.illegal_sized_bound.is_some() {\n-                return None;\n+                return;\n             }\n \n             let up_to_rcvr_span = segment.ident.span.until(callee_expr.span);\n@@ -567,22 +563,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     sugg,\n                     Applicability::MaybeIncorrect,\n                 );\n-\n-                // Let's check the method fully now\n-                let return_ty = self.check_method_argument_types(\n-                    segment.ident.span,\n-                    call_expr,\n-                    Ok(pick.callee),\n-                    rest,\n-                    TupleArgumentsFlag::DontTupleArguments,\n-                    expected,\n-                );\n-\n-                return Some(return_ty);\n             }\n         }\n-\n-        None\n     }\n \n     fn report_invalid_callee("}, {"sha": "905781ec8f59412b337766d5c0cdae819bc83956", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -62,6 +62,7 @@ use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     self, NormalizeExt, ObligationCause, ObligationCauseCode, ObligationCtxt,\n };\n@@ -144,12 +145,28 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         debug!(\"unify(a: {:?}, b: {:?}, use_lub: {})\", a, b, self.use_lub);\n         self.commit_if_ok(|_| {\n             let at = self.at(&self.cause, self.fcx.param_env);\n-            if self.use_lub {\n+\n+            let res = if self.use_lub {\n                 at.lub(DefineOpaqueTypes::Yes, b, a)\n             } else {\n                 at.sup(DefineOpaqueTypes::Yes, b, a)\n                     .map(|InferOk { value: (), obligations }| InferOk { value: a, obligations })\n+            };\n+\n+            // In the new solver, lazy norm may allow us to shallowly equate\n+            // more types, but we emit possibly impossible-to-satisfy obligations.\n+            // Filter these cases out to make sure our coercion is more accurate.\n+            if self.tcx.trait_solver_next() {\n+                if let Ok(res) = &res {\n+                    for obligation in &res.obligations {\n+                        if !self.predicate_may_hold(&obligation) {\n+                            return Err(TypeError::Mismatch);\n+                        }\n+                    }\n+                }\n             }\n+\n+            res\n         })\n     }\n \n@@ -791,6 +808,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     {\n         self.commit_if_ok(|snapshot| {\n+            let outer_universe = self.infcx.universe();\n+\n             let result = if let ty::FnPtr(fn_ty_b) = b.kind()\n                 && let (hir::Unsafety::Normal, hir::Unsafety::Unsafe) =\n                     (fn_ty_a.unsafety(), fn_ty_b.unsafety())\n@@ -807,7 +826,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // want the coerced type to be the actual supertype of these two,\n             // but for now, we want to just error to ensure we don't lock\n             // ourselves into a specific behavior with NLL.\n-            self.leak_check(false, snapshot)?;\n+            self.leak_check(outer_universe, Some(snapshot))?;\n \n             result\n         })"}, {"sha": "fb28233bfb1c251b063a585360e1efedb79e4ce0", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -269,7 +269,7 @@ pub fn resolve_interior<'a, 'tcx>(\n                     },\n                     _ => mk_bound_region(ty::BrAnon(None)),\n                 };\n-                let r = fcx.tcx.mk_re_late_bound(current_depth, br);\n+                let r = ty::Region::new_late_bound(fcx.tcx, current_depth, br);\n                 r\n             });\n             captured_tys.insert(ty).then(|| {\n@@ -295,7 +295,11 @@ pub fn resolve_interior<'a, 'tcx>(\n                     let var = ty::BoundVar::from_usize(bound_vars.len());\n                     bound_vars.push(ty::BoundVariableKind::Region(kind));\n                     counter += 1;\n-                    fcx.tcx.mk_re_late_bound(ty::INNERMOST, ty::BoundRegion { var, kind })\n+                    ty::Region::new_late_bound(\n+                        fcx.tcx,\n+                        ty::INNERMOST,\n+                        ty::BoundRegion { var, kind },\n+                    )\n                 },\n                 types: &mut |b| bug!(\"unexpected bound ty in binder: {b:?}\"),\n                 consts: &mut |b, ty| bug!(\"unexpected bound ct in binder: {b:?} {ty}\"),"}, {"sha": "6b2dd0a2b4fed91c3b61def480e3d13b9bf01712", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -70,8 +70,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             tcx: self.tcx,\n             defining_use_anchor: self.defining_use_anchor,\n             considering_regions: self.considering_regions,\n+            skip_leak_check: self.skip_leak_check,\n             inner: self.inner.clone(),\n-            skip_leak_check: self.skip_leak_check.clone(),\n             lexical_region_resolutions: self.lexical_region_resolutions.clone(),\n             selection_cache: self.selection_cache.clone(),\n             evaluation_cache: self.evaluation_cache.clone(),"}, {"sha": "bf53a73f3983c2bd5bcc82a5982de69fdf5b73fc", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -771,7 +771,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     ) -> ty::Region<'tcx> {\n         let var = self.canonical_var(info, r.into());\n         let br = ty::BoundRegion { var, kind: ty::BrAnon(None) };\n-        self.interner().mk_re_late_bound(self.binder_index, br)\n+        ty::Region::new_late_bound(self.interner(), self.binder_index, br)\n     }\n \n     /// Given a type variable `ty_var` of the given kind, first check"}, {"sha": "c8c318c3f02448bbe8fa5d2c8b35588d74b852df", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             CanonicalVarKind::PlaceholderRegion(ty::PlaceholderRegion { universe, bound }) => {\n                 let universe_mapped = universe_map(universe);\n                 let placeholder_mapped = ty::PlaceholderRegion { universe: universe_mapped, bound };\n-                self.tcx.mk_re_placeholder(placeholder_mapped).into()\n+                ty::Region::new_placeholder(self.tcx, placeholder_mapped).into()\n             }\n \n             CanonicalVarKind::Const(ui, ty) => self"}, {"sha": "2cf8d8c702d46305c94ba4a345ad8529cc8a950a", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -668,14 +668,15 @@ pub fn make_query_region_constraints<'tcx>(\n             let constraint = match *k {\n                 // Swap regions because we are going from sub (<=) to outlives\n                 // (>=).\n-                Constraint::VarSubVar(v1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_re_var(v2).into(), tcx.mk_re_var(v1))\n-                }\n+                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                    ty::Region::new_var(tcx, v2).into(),\n+                    ty::Region::new_var(tcx, v1),\n+                ),\n                 Constraint::VarSubReg(v1, r2) => {\n-                    ty::OutlivesPredicate(r2.into(), tcx.mk_re_var(v1))\n+                    ty::OutlivesPredicate(r2.into(), ty::Region::new_var(tcx, v1))\n                 }\n                 Constraint::RegSubVar(r1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_re_var(v2).into(), r1)\n+                    ty::OutlivesPredicate(ty::Region::new_var(tcx, v2).into(), r1)\n                 }\n                 Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n             };\n@@ -719,7 +720,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n     }\n \n     fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx> {\n-        self.infcx.tcx.mk_re_placeholder(placeholder)\n+        ty::Region::new_placeholder(self.infcx.tcx, placeholder)\n     }\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {"}, {"sha": "0b3bc1ce6b38d7451ea1acda3eb7f08772ca0038", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_re_var(*vid)),\n+                Some(ty::Region::new_var(self.tcx(), *vid)),\n                 cause,\n                 Some(*sub_placeholder),\n                 Some(*sup_placeholder),\n@@ -95,7 +95,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 _,\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_re_var(*vid)),\n+                Some(ty::Region::new_var(self.tcx(), *vid)),\n                 cause,\n                 Some(*sub_placeholder),\n                 None,\n@@ -111,7 +111,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_re_var(*vid)),\n+                Some(ty::Region::new_var(self.tcx(), *vid)),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n@@ -127,7 +127,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_re_var(*vid)),\n+                Some(ty::Region::new_var(self.tcx(), *vid)),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n@@ -141,7 +141,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_re_var(*vid)),\n+                Some(ty::Region::new_var(self.tcx(), *vid)),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),"}, {"sha": "974bc2f1153d288021d226db06c23551feb540b3", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -82,8 +82,10 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         let delegate = FnMutDelegate {\n             regions: &mut |br: ty::BoundRegion| {\n-                self.tcx\n-                    .mk_re_placeholder(ty::PlaceholderRegion { universe: next_universe, bound: br })\n+                ty::Region::new_placeholder(\n+                    self.tcx,\n+                    ty::PlaceholderRegion { universe: next_universe, bound: br },\n+                )\n             },\n             types: &mut |bound_ty: ty::BoundTy| {\n                 self.tcx.mk_placeholder(ty::PlaceholderType {\n@@ -103,29 +105,31 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.tcx.replace_bound_vars_uncached(binder, delegate)\n     }\n \n-    /// See [RegionConstraintCollector::leak_check][1].\n+    /// See [RegionConstraintCollector::leak_check][1]. We only check placeholder\n+    /// leaking into `outer_universe`, i.e. placeholders which cannot be named by that\n+    /// universe.\n     ///\n     /// [1]: crate::infer::region_constraints::RegionConstraintCollector::leak_check\n     pub fn leak_check(\n         &self,\n-        overly_polymorphic: bool,\n-        snapshot: &CombinedSnapshot<'tcx>,\n+        outer_universe: ty::UniverseIndex,\n+        only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,\n     ) -> RelateResult<'tcx, ()> {\n         // If the user gave `-Zno-leak-check`, or we have been\n         // configured to skip the leak check, then skip the leak check\n         // completely. The leak check is deprecated. Any legitimate\n         // subtyping errors that it would have caught will now be\n         // caught later on, during region checking. However, we\n         // continue to use it for a transition period.\n-        if self.tcx.sess.opts.unstable_opts.no_leak_check || self.skip_leak_check.get() {\n+        if self.tcx.sess.opts.unstable_opts.no_leak_check || self.skip_leak_check {\n             return Ok(());\n         }\n \n         self.inner.borrow_mut().unwrap_region_constraints().leak_check(\n             self.tcx,\n-            overly_polymorphic,\n+            outer_universe,\n             self.universe(),\n-            snapshot,\n+            only_consider_snapshot,\n         )\n     }\n }"}, {"sha": "485e34fe2bf99d255f45015a34f83935c53285f9", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -347,7 +347,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // name the placeholder, then the placeholder is\n                     // larger; otherwise, the only ancestor is `'static`.\n                     Err(placeholder) if empty_ui.can_name(placeholder.universe) => {\n-                        self.tcx().mk_re_placeholder(placeholder)\n+                        ty::Region::new_placeholder(self.tcx(), placeholder)\n                     }\n                     Err(_) => self.tcx().lifetimes.re_static,\n                 };"}, {"sha": "447d4c9f84bc057cd80be8fe188095f3bc7ecdd7", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -251,14 +251,13 @@ pub struct InferCtxt<'tcx> {\n     /// solving is left to borrowck instead.\n     pub considering_regions: bool,\n \n-    pub inner: RefCell<InferCtxtInner<'tcx>>,\n-\n     /// If set, this flag causes us to skip the 'leak check' during\n     /// higher-ranked subtyping operations. This flag is a temporary one used\n     /// to manage the removal of the leak-check: for the time being, we still run the\n-    /// leak-check, but we issue warnings. This flag can only be set to true\n-    /// when entering a snapshot.\n-    skip_leak_check: Cell<bool>,\n+    /// leak-check, but we issue warnings.\n+    skip_leak_check: bool,\n+\n+    pub inner: RefCell<InferCtxtInner<'tcx>>,\n \n     /// Once region inference is done, the values for each variable.\n     lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n@@ -543,6 +542,7 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     defining_use_anchor: DefiningAnchor,\n     considering_regions: bool,\n+    skip_leak_check: bool,\n     /// Whether we are in coherence mode.\n     intercrate: bool,\n }\n@@ -557,6 +557,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             tcx: self,\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n+            skip_leak_check: false,\n             intercrate: false,\n         }\n     }\n@@ -584,6 +585,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn skip_leak_check(mut self, skip_leak_check: bool) -> Self {\n+        self.skip_leak_check = skip_leak_check;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -605,11 +611,18 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn build(&mut self) -> InferCtxt<'tcx> {\n-        let InferCtxtBuilder { tcx, defining_use_anchor, considering_regions, intercrate } = *self;\n+        let InferCtxtBuilder {\n+            tcx,\n+            defining_use_anchor,\n+            considering_regions,\n+            skip_leak_check,\n+            intercrate,\n+        } = *self;\n         InferCtxt {\n             tcx,\n             defining_use_anchor,\n             considering_regions,\n+            skip_leak_check,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n             selection_cache: Default::default(),\n@@ -619,7 +632,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             tainted_by_errors: Cell::new(None),\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),\n-            skip_leak_check: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n             intercrate,\n         }\n@@ -815,32 +827,9 @@ impl<'tcx> InferCtxt<'tcx> {\n         r\n     }\n \n-    /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n-    #[instrument(skip(self, f), level = \"debug\")]\n-    pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'tcx>) -> R,\n-    {\n-        let snapshot = self.start_snapshot();\n-        let was_skip_leak_check = self.skip_leak_check.get();\n-        if should_skip {\n-            self.skip_leak_check.set(true);\n-        }\n-        let r = f(&snapshot);\n-        self.rollback_to(\"probe\", snapshot);\n-        self.skip_leak_check.set(was_skip_leak_check);\n-        r\n-    }\n-\n-    /// Scan the constraints produced since `snapshot` began and returns:\n-    ///\n-    /// - `None` -- if none of them involves \"region outlives\" constraints.\n-    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder.\n-    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders.\n-    pub fn region_constraints_added_in_snapshot(\n-        &self,\n-        snapshot: &CombinedSnapshot<'tcx>,\n-    ) -> Option<bool> {\n+    /// Scan the constraints produced since `snapshot` and check whether\n+    /// we added any region constraints.\n+    pub fn region_constraints_added_in_snapshot(&self, snapshot: &CombinedSnapshot<'tcx>) -> bool {\n         self.inner\n             .borrow_mut()\n             .unwrap_region_constraints()\n@@ -1065,7 +1054,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     ) -> ty::Region<'tcx> {\n         let region_var =\n             self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe, origin);\n-        self.tcx.mk_re_var(region_var)\n+        ty::Region::new_var(self.tcx, region_var)\n     }\n \n     /// Return the universe that the region `r` was created in. For"}, {"sha": "105a3f08c8205f574393aa6049f7ef26bcdf598d", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -533,17 +533,29 @@ impl<'tcx> InferCtxt<'tcx> {\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n         let span = cause.span;\n-        let prev = self.inner.borrow_mut().opaque_types().register(\n-            opaque_type_key,\n-            OpaqueHiddenType { ty: hidden_ty, span },\n-            origin,\n-        );\n-        let mut obligations = if let Some(prev) = prev {\n-            self.at(&cause, param_env)\n-                .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n-                .obligations\n+        let mut obligations = if self.intercrate {\n+            // During intercrate we do not define opaque types but instead always\n+            // force ambiguity unless the hidden type is known to not implement\n+            // our trait.\n+            vec![traits::Obligation::new(\n+                self.tcx,\n+                cause.clone(),\n+                param_env,\n+                ty::PredicateKind::Ambiguous,\n+            )]\n         } else {\n-            Vec::new()\n+            let prev = self.inner.borrow_mut().opaque_types().register(\n+                opaque_type_key,\n+                OpaqueHiddenType { ty: hidden_ty, span },\n+                origin,\n+            );\n+            if let Some(prev) = prev {\n+                self.at(&cause, param_env)\n+                    .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n+                    .obligations\n+            } else {\n+                Vec::new()\n+            }\n         };\n \n         self.add_item_bounds_for_hidden_type("}, {"sha": "dd65f66ccd14098931cf5f3e91cbb9a367e80eeb", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 71, "deletions": 73, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -3,7 +3,6 @@ use crate::infer::CombinedSnapshot;\n use rustc_data_structures::{\n     fx::FxIndexMap,\n     graph::{scc::Sccs, vec_graph::VecGraph},\n-    undo_log::UndoLogs,\n };\n use rustc_index::Idx;\n use rustc_middle::ty::error::TypeError;\n@@ -13,7 +12,9 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     /// Searches new universes created during `snapshot`, looking for\n     /// placeholders that may \"leak\" out from the universes they are contained\n     /// in. If any leaking placeholders are found, then an `Err` is returned\n-    /// (typically leading to the snapshot being reversed).\n+    /// (typically leading to the snapshot being reversed). This algorithm\n+    /// only looks at placeholders which cannot be named by `outer_universe`,\n+    /// as this is the universe we're currently checking for a leak.\n     ///\n     /// The leak check *used* to be the only way we had to handle higher-ranked\n     /// obligations. Now that we have integrated universes into the region\n@@ -55,43 +56,34 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     ///   * if they must also be equal to a placeholder P, and U cannot name P, report an error, as that\n     ///     indicates `P: R` and `R` is in an incompatible universe\n     ///\n+    /// To improve performance and for the old trait solver caching to be sound, this takes\n+    /// an optional snapshot in which case we only look at region constraints added in that\n+    /// snapshot. If we were to not do that the `leak_check` during evaluation can rely on\n+    /// region constraints added outside of that evaluation. As that is not reflected in the\n+    /// cache key this would be unsound.\n+    ///\n     /// # Historical note\n     ///\n     /// Older variants of the leak check used to report errors for these\n     /// patterns, but we no longer do:\n     ///\n     /// * R: P1, even if R cannot name P1, because R = 'static is a valid sol'n\n     /// * R: P1, R: P2, as above\n+    #[instrument(level = \"debug\", skip(self, tcx, only_consider_snapshot), ret)]\n     pub fn leak_check(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        overly_polymorphic: bool,\n+        outer_universe: ty::UniverseIndex,\n         max_universe: ty::UniverseIndex,\n-        snapshot: &CombinedSnapshot<'tcx>,\n+        only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,\n     ) -> RelateResult<'tcx, ()> {\n-        debug!(\n-            \"leak_check(max_universe={:?}, snapshot.universe={:?}, overly_polymorphic={:?})\",\n-            max_universe, snapshot.universe, overly_polymorphic\n-        );\n-\n-        assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n-\n-        let universe_at_start_of_snapshot = snapshot.universe;\n-        if universe_at_start_of_snapshot == max_universe {\n+        if outer_universe == max_universe {\n             return Ok(());\n         }\n \n-        let mini_graph =\n-            &MiniGraph::new(tcx, self.undo_log.region_constraints(), &self.storage.data.verifys);\n+        let mini_graph = &MiniGraph::new(tcx, &self, only_consider_snapshot);\n \n-        let mut leak_check = LeakCheck::new(\n-            tcx,\n-            universe_at_start_of_snapshot,\n-            max_universe,\n-            overly_polymorphic,\n-            mini_graph,\n-            self,\n-        );\n+        let mut leak_check = LeakCheck::new(tcx, outer_universe, max_universe, mini_graph, self);\n         leak_check.assign_placeholder_values()?;\n         leak_check.propagate_scc_value()?;\n         Ok(())\n@@ -100,9 +92,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n \n struct LeakCheck<'me, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    universe_at_start_of_snapshot: ty::UniverseIndex,\n-    /// Only used when reporting region errors.\n-    overly_polymorphic: bool,\n+    outer_universe: ty::UniverseIndex,\n     mini_graph: &'me MiniGraph<'tcx>,\n     rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n \n@@ -130,17 +120,15 @@ struct LeakCheck<'me, 'tcx> {\n impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        universe_at_start_of_snapshot: ty::UniverseIndex,\n+        outer_universe: ty::UniverseIndex,\n         max_universe: ty::UniverseIndex,\n-        overly_polymorphic: bool,\n         mini_graph: &'me MiniGraph<'tcx>,\n         rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n     ) -> Self {\n         let dummy_scc_universe = SccUniverse { universe: max_universe, region: None };\n         Self {\n             tcx,\n-            universe_at_start_of_snapshot,\n-            overly_polymorphic,\n+            outer_universe,\n             mini_graph,\n             rcc,\n             scc_placeholders: IndexVec::from_elem_n(None, mini_graph.sccs.num_sccs()),\n@@ -165,7 +153,7 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n \n             // Detect those SCCs that directly contain a placeholder\n             if let ty::RePlaceholder(placeholder) = **region {\n-                if self.universe_at_start_of_snapshot.cannot_name(placeholder.universe) {\n+                if self.outer_universe.cannot_name(placeholder.universe) {\n                     self.assign_scc_value(scc, placeholder)?;\n                 }\n             }\n@@ -280,7 +268,7 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n         placeholder1: ty::PlaceholderRegion,\n         placeholder2: ty::PlaceholderRegion,\n     ) -> TypeError<'tcx> {\n-        self.error(placeholder1, self.tcx.mk_re_placeholder(placeholder2))\n+        self.error(placeholder1, ty::Region::new_placeholder(self.tcx, placeholder2))\n     }\n \n     fn error(\n@@ -289,11 +277,7 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n         other_region: ty::Region<'tcx>,\n     ) -> TypeError<'tcx> {\n         debug!(\"error: placeholder={:?}, other_region={:?}\", placeholder, other_region);\n-        if self.overly_polymorphic {\n-            TypeError::RegionsOverlyPolymorphic(placeholder.bound.kind, other_region)\n-        } else {\n-            TypeError::RegionsInsufficientlyPolymorphic(placeholder.bound.kind, other_region)\n-        }\n+        TypeError::RegionsInsufficientlyPolymorphic(placeholder.bound.kind, other_region)\n     }\n }\n \n@@ -379,56 +363,70 @@ struct MiniGraph<'tcx> {\n }\n \n impl<'tcx> MiniGraph<'tcx> {\n-    fn new<'a>(\n+    fn new(\n         tcx: TyCtxt<'tcx>,\n-        undo_log: impl Iterator<Item = &'a UndoLog<'tcx>>,\n-        verifys: &[Verify<'tcx>],\n-    ) -> Self\n-    where\n-        'tcx: 'a,\n-    {\n+        region_constraints: &RegionConstraintCollector<'_, 'tcx>,\n+        only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,\n+    ) -> Self {\n         let mut nodes = FxIndexMap::default();\n         let mut edges = Vec::new();\n \n         // Note that if `R2: R1`, we get a callback `r1, r2`, so `target` is first parameter.\n-        Self::iterate_undo_log(tcx, undo_log, verifys, |target, source| {\n-            let source_node = Self::add_node(&mut nodes, source);\n-            let target_node = Self::add_node(&mut nodes, target);\n-            edges.push((source_node, target_node));\n-        });\n+        Self::iterate_region_constraints(\n+            tcx,\n+            region_constraints,\n+            only_consider_snapshot,\n+            |target, source| {\n+                let source_node = Self::add_node(&mut nodes, source);\n+                let target_node = Self::add_node(&mut nodes, target);\n+                edges.push((source_node, target_node));\n+            },\n+        );\n         let graph = VecGraph::new(nodes.len(), edges);\n         let sccs = Sccs::new(&graph);\n         Self { nodes, sccs }\n     }\n \n     /// Invokes `each_edge(R1, R2)` for each edge where `R2: R1`\n-    fn iterate_undo_log<'a>(\n+    fn iterate_region_constraints(\n         tcx: TyCtxt<'tcx>,\n-        undo_log: impl Iterator<Item = &'a UndoLog<'tcx>>,\n-        verifys: &[Verify<'tcx>],\n+        region_constraints: &RegionConstraintCollector<'_, 'tcx>,\n+        only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,\n         mut each_edge: impl FnMut(ty::Region<'tcx>, ty::Region<'tcx>),\n-    ) where\n-        'tcx: 'a,\n-    {\n-        for undo_entry in undo_log {\n-            match undo_entry {\n-                &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                    each_edge(tcx.mk_re_var(a), tcx.mk_re_var(b));\n-                }\n-                &AddConstraint(Constraint::RegSubVar(a, b)) => {\n-                    each_edge(a, tcx.mk_re_var(b));\n-                }\n-                &AddConstraint(Constraint::VarSubReg(a, b)) => {\n-                    each_edge(tcx.mk_re_var(a), b);\n-                }\n-                &AddConstraint(Constraint::RegSubReg(a, b)) => {\n-                    each_edge(a, b);\n+    ) {\n+        let mut each_constraint = |constraint| match constraint {\n+            &Constraint::VarSubVar(a, b) => {\n+                each_edge(ty::Region::new_var(tcx, a), ty::Region::new_var(tcx, b));\n+            }\n+            &Constraint::RegSubVar(a, b) => {\n+                each_edge(a, ty::Region::new_var(tcx, b));\n+            }\n+            &Constraint::VarSubReg(a, b) => {\n+                each_edge(ty::Region::new_var(tcx, a), b);\n+            }\n+            &Constraint::RegSubReg(a, b) => {\n+                each_edge(a, b);\n+            }\n+        };\n+\n+        if let Some(snapshot) = only_consider_snapshot {\n+            for undo_entry in\n+                region_constraints.undo_log.region_constraints_in_snapshot(&snapshot.undo_snapshot)\n+            {\n+                match undo_entry {\n+                    AddConstraint(constraint) => {\n+                        each_constraint(constraint);\n+                    }\n+                    &AddVerify(i) => span_bug!(\n+                        region_constraints.data().verifys[i].origin.span(),\n+                        \"we never add verifications while doing higher-ranked things\",\n+                    ),\n+                    &AddCombination(..) | &AddVar(..) => {}\n                 }\n-                &AddVerify(i) => span_bug!(\n-                    verifys[i].origin.span(),\n-                    \"we never add verifications while doing higher-ranked things\",\n-                ),\n-                &AddCombination(..) | &AddVar(..) => {}\n+            }\n+        } else {\n+            for (constraint, _origin) in &region_constraints.data().constraints {\n+                each_constraint(constraint)\n             }\n         }\n     }"}, {"sha": "613da8a0b4576b6de9b2d401a274d35a28af77b4", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -400,7 +400,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         data\n     }\n \n-    pub(super) fn data(&self) -> &RegionConstraintData<'tcx> {\n+    pub fn data(&self) -> &RegionConstraintData<'tcx> {\n         &self.data\n     }\n \n@@ -610,13 +610,13 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         let resolved = ut\n             .probe_value(root_vid)\n             .get_value_ignoring_universes()\n-            .unwrap_or_else(|| tcx.mk_re_var(root_vid));\n+            .unwrap_or_else(|| ty::Region::new_var(tcx, root_vid));\n \n         // Don't resolve a variable to a region that it cannot name.\n         if self.var_universe(vid).can_name(self.universe(resolved)) {\n             resolved\n         } else {\n-            tcx.mk_re_var(vid)\n+            ty::Region::new_var(tcx, vid)\n         }\n     }\n \n@@ -637,15 +637,15 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     ) -> Region<'tcx> {\n         let vars = TwoRegions { a, b };\n         if let Some(&c) = self.combine_map(t).get(&vars) {\n-            return tcx.mk_re_var(c);\n+            return ty::Region::new_var(tcx, c);\n         }\n         let a_universe = self.universe(a);\n         let b_universe = self.universe(b);\n         let c_universe = cmp::max(a_universe, b_universe);\n         let c = self.new_region_var(c_universe, MiscVariable(origin.span()));\n         self.combine_map(t).insert(vars, c);\n         self.undo_log.push(AddCombination(t, vars));\n-        let new_r = tcx.mk_re_var(c);\n+        let new_r = ty::Region::new_var(tcx, c);\n         for old_r in [a, b] {\n             match t {\n                 Glb => self.make_subregion(origin.clone(), new_r, old_r),\n@@ -683,15 +683,10 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     }\n \n     /// See `InferCtxt::region_constraints_added_in_snapshot`.\n-    pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'tcx>) -> Option<bool> {\n+    pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'tcx>) -> bool {\n         self.undo_log\n             .region_constraints_in_snapshot(mark)\n-            .map(|&elt| match elt {\n-                AddConstraint(constraint) => Some(constraint.involves_placeholders()),\n-                _ => None,\n-            })\n-            .max()\n-            .unwrap_or(None)\n+            .any(|&elt| matches!(elt, AddConstraint(_)))\n     }\n \n     #[inline]"}, {"sha": "25d06b21ec84fd9e00746728972d62b05c7b89aa", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -138,11 +138,9 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         }\n \n         if self.undo_log.num_open_snapshots == 1 {\n-            // The root snapshot. It's safe to clear the undo log because\n-            // there's no snapshot further out that we might need to roll back\n-            // to.\n+            // After the root snapshot the undo log should be empty.\n             assert!(snapshot.undo_len == 0);\n-            self.undo_log.logs.clear();\n+            assert!(self.undo_log.logs.is_empty());\n         }\n \n         self.undo_log.num_open_snapshots -= 1;\n@@ -183,15 +181,6 @@ impl<'tcx> InferCtxtUndoLogs<'tcx> {\n         self.logs[s.undo_len..].iter().any(|log| matches!(log, UndoLog::OpaqueTypes(..)))\n     }\n \n-    pub(crate) fn region_constraints(\n-        &self,\n-    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {\n-        self.logs.iter().filter_map(|log| match log {\n-            UndoLog::RegionConstraintCollector(log) => Some(log),\n-            _ => None,\n-        })\n-    }\n-\n     fn assert_open_snapshot(&self, snapshot: &Snapshot<'tcx>) {\n         // Failures here may indicate a failure to follow a stack discipline.\n         assert!(self.logs.len() >= snapshot.undo_len);"}, {"sha": "e707ac41a050d4a89f7b8220ca636742cf50c763", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -304,6 +304,14 @@ lint_improper_ctypes_union_layout_help = consider adding a `#[repr(C)]` or `#[re\n lint_improper_ctypes_union_layout_reason = this union has unspecified layout\n lint_improper_ctypes_union_non_exhaustive = this union is non-exhaustive\n \n+# FIXME: we should ordinalize $valid_up_to when we add support for doing so\n+lint_invalid_from_utf8_checked = calls to `{$method}` with a invalid literal always return an error\n+    .label = the literal was valid UTF-8 up to the {$valid_up_to} bytes\n+\n+# FIXME: we should ordinalize $valid_up_to when we add support for doing so\n+lint_invalid_from_utf8_unchecked = calls to `{$method}` with a invalid literal are undefined behavior\n+    .label = the literal was valid UTF-8 up to the {$valid_up_to} bytes\n+\n lint_lintpass_by_hand = implementing `LintPass` by hand\n     .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n "}, {"sha": "3291286ad679be4c79f853e025e3b6d72a1c3da5", "filename": "compiler/rustc_lint/src/invalid_from_utf8.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_lint%2Fsrc%2Finvalid_from_utf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_lint%2Fsrc%2Finvalid_from_utf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finvalid_from_utf8.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,118 @@\n+use std::str::Utf8Error;\n+\n+use rustc_ast::{BorrowKind, LitKind};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::sym;\n+\n+use crate::lints::InvalidFromUtf8Diag;\n+use crate::{LateContext, LateLintPass, LintContext};\n+\n+declare_lint! {\n+    /// The `invalid_from_utf8_unchecked` lint checks for calls to\n+    /// `std::str::from_utf8_unchecked` and `std::str::from_utf8_unchecked_mut`\n+    /// with an invalid UTF-8 literal.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// # #[allow(unused)]\n+    /// unsafe {\n+    ///     std::str::from_utf8_unchecked(b\"Ru\\x82st\");\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Creating such a `str` would result in undefined behavior as per documentation\n+    /// for `std::str::from_utf8_unchecked` and `std::str::from_utf8_unchecked_mut`.\n+    pub INVALID_FROM_UTF8_UNCHECKED,\n+    Deny,\n+    \"using a non UTF-8 literal in `std::str::from_utf8_unchecked`\"\n+}\n+\n+declare_lint! {\n+    /// The `invalid_from_utf8` lint checks for calls to\n+    /// `std::str::from_utf8` and `std::str::from_utf8_mut`\n+    /// with an invalid UTF-8 literal.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #[allow(unused)]\n+    /// std::str::from_utf8(b\"Ru\\x82st\");\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Trying to create such a `str` would always return an error as per documentation\n+    /// for `std::str::from_utf8` and `std::str::from_utf8_mut`.\n+    pub INVALID_FROM_UTF8,\n+    Warn,\n+    \"using a non UTF-8 literal in `std::str::from_utf8`\"\n+}\n+\n+declare_lint_pass!(InvalidFromUtf8 => [INVALID_FROM_UTF8_UNCHECKED, INVALID_FROM_UTF8]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidFromUtf8 {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if let ExprKind::Call(path, [arg]) = expr.kind\n+            && let ExprKind::Path(ref qpath) = path.kind\n+            && let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id()\n+            && let Some(diag_item) = cx.tcx.get_diagnostic_name(def_id)\n+            && [sym::str_from_utf8, sym::str_from_utf8_mut,\n+                sym::str_from_utf8_unchecked, sym::str_from_utf8_unchecked_mut].contains(&diag_item)\n+        {\n+            let lint = |utf8_error: Utf8Error| {\n+                let label = arg.span;\n+                let method = diag_item.as_str().strip_prefix(\"str_\").unwrap();\n+                let method = format!(\"std::str::{method}\");\n+                let valid_up_to = utf8_error.valid_up_to();\n+                let is_unchecked_variant = diag_item.as_str().contains(\"unchecked\");\n+\n+                cx.emit_spanned_lint(\n+                    if is_unchecked_variant { INVALID_FROM_UTF8_UNCHECKED } else { INVALID_FROM_UTF8 },\n+                    expr.span,\n+                    if is_unchecked_variant {\n+                        InvalidFromUtf8Diag::Unchecked { method,  valid_up_to, label }\n+                    } else {\n+                        InvalidFromUtf8Diag::Checked { method,  valid_up_to, label }\n+                    }\n+                )\n+            };\n+\n+            match &arg.kind {\n+                ExprKind::Lit(Spanned { node: lit, .. }) => {\n+                    if let LitKind::ByteStr(bytes, _) = &lit\n+                        && let Err(utf8_error) = std::str::from_utf8(bytes)\n+                    {\n+                        lint(utf8_error);\n+                    }\n+                },\n+                ExprKind::AddrOf(BorrowKind::Ref, _, Expr { kind: ExprKind::Array(args), .. }) => {\n+                    let elements = args.iter().map(|e|{\n+                        match &e.kind {\n+                            ExprKind::Lit(Spanned { node: lit, .. }) => match lit {\n+                                LitKind::Byte(b) => Some(*b),\n+                                LitKind::Int(b, _) => Some(*b as u8),\n+                                _ => None\n+                            }\n+                            _ => None\n+                        }\n+                    }).collect::<Option<Vec<_>>>();\n+\n+                    if let Some(elements) = elements\n+                        && let Err(utf8_error) = std::str::from_utf8(&elements)\n+                    {\n+                        lint(utf8_error);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}"}, {"sha": "c62109b298629db779e807036da59ac73c467efa", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -60,6 +60,7 @@ mod expect;\n mod for_loops_over_fallibles;\n pub mod hidden_unicode_codepoints;\n mod internal;\n+mod invalid_from_utf8;\n mod late;\n mod let_underscore;\n mod levels;\n@@ -102,6 +103,7 @@ use enum_intrinsics_non_enums::EnumIntrinsicsNonEnums;\n use for_loops_over_fallibles::*;\n use hidden_unicode_codepoints::*;\n use internal::*;\n+use invalid_from_utf8::*;\n use let_underscore::*;\n use map_unit_fn::*;\n use methods::*;\n@@ -207,6 +209,7 @@ late_lint_methods!(\n             HardwiredLints: HardwiredLints,\n             ImproperCTypesDeclarations: ImproperCTypesDeclarations,\n             ImproperCTypesDefinitions: ImproperCTypesDefinitions,\n+            InvalidFromUtf8: InvalidFromUtf8,\n             VariantSizeDifferences: VariantSizeDifferences,\n             BoxPointers: BoxPointers,\n             PathStatements: PathStatements,"}, {"sha": "746abebeb375af5cefb3e551067a3be543e48388", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -699,6 +699,25 @@ pub struct ForgetCopyDiag<'a> {\n     pub label: Span,\n }\n \n+// invalid_from_utf8.rs\n+#[derive(LintDiagnostic)]\n+pub enum InvalidFromUtf8Diag {\n+    #[diag(lint_invalid_from_utf8_unchecked)]\n+    Unchecked {\n+        method: String,\n+        valid_up_to: usize,\n+        #[label]\n+        label: Span,\n+    },\n+    #[diag(lint_invalid_from_utf8_checked)]\n+    Checked {\n+        method: String,\n+        valid_up_to: usize,\n+        #[label]\n+        label: Span,\n+    },\n+}\n+\n // hidden_unicode_codepoints.rs\n #[derive(LintDiagnostic)]\n #[diag(lint_hidden_unicode_codepoints)]"}, {"sha": "09e24e012afa331ad36c77df8e63d283240efaf1", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -858,7 +858,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         } else {\n             tcx.arena.alloc_from_iter(lazy.decode((self, tcx)))\n         };\n-        ty::EarlyBinder::new(&*output)\n+        ty::EarlyBinder::bind(&*output)\n     }\n \n     fn get_variant("}, {"sha": "c673eb5afc79324b7222ea0d682969cd0a520d70", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1730,7 +1730,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::Closure(_, substs) => {\n                 let constness = self.tcx.constness(def_id.to_def_id());\n                 self.tables.constness.set_some(def_id.to_def_id().index, constness);\n-                record!(self.tables.fn_sig[def_id.to_def_id()] <- ty::EarlyBinder::new(substs.as_closure().sig()));\n+                record!(self.tables.fn_sig[def_id.to_def_id()] <- ty::EarlyBinder::bind(substs.as_closure().sig()));\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\"),"}, {"sha": "29dae67bfca721038f024892e081ad67f552082b", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -415,7 +415,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                                 var: ty::BoundVar::from_usize(i),\n                                 kind: ty::BrAnon(None),\n                             };\n-                            tcx.mk_re_late_bound(ty::INNERMOST, br).into()\n+                            ty::Region::new_late_bound(tcx, ty::INNERMOST, br).into()\n                         }\n                         CanonicalVarKind::Const(_, ty)\n                         | CanonicalVarKind::PlaceholderConst(_, ty) => tcx"}, {"sha": "63cdba7f327f6e11ba52fb0837f40f8319a4b3f2", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -476,7 +476,7 @@ impl<'tcx> Body<'tcx> {\n     /// Returns the return type; it always return first element from `local_decls` array.\n     #[inline]\n     pub fn bound_return_ty(&self) -> ty::EarlyBinder<Ty<'tcx>> {\n-        ty::EarlyBinder::new(self.local_decls[RETURN_PLACE].ty)\n+        ty::EarlyBinder::bind(self.local_decls[RETURN_PLACE].ty)\n     }\n \n     /// Gets the location of the terminator for the given block."}, {"sha": "1511e25523559edd20cd0013fc0d0f7b9f20fc12", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -291,10 +291,12 @@ impl<'tcx> CodegenUnit<'tcx> {\n         self.primary = true;\n     }\n \n+    /// The order of these items is non-determinstic.\n     pub fn items(&self) -> &FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)> {\n         &self.items\n     }\n \n+    /// The order of these items is non-determinstic.\n     pub fn items_mut(&mut self) -> &mut FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)> {\n         &mut self.items\n     }"}, {"sha": "a15c419da7acaa9cbcac7ffb64484244b30d7777", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -413,7 +413,7 @@ impl<'tcx> ClosureOutlivesSubjectTy<'tcx> {\n             ty::ReVar(vid) => {\n                 let br =\n                     ty::BoundRegion { var: ty::BoundVar::new(vid.index()), kind: ty::BrAnon(None) };\n-                tcx.mk_re_late_bound(depth, br)\n+                ty::Region::new_late_bound(tcx, depth, br)\n             }\n             _ => bug!(\"unexpected region in ClosureOutlivesSubjectTy: {r:?}\"),\n         });"}, {"sha": "3e474c1d377e64001146ecd617624b1b672b2347", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -220,6 +220,11 @@ pub enum BorrowKind {\n     /// immutable, but not aliasable. This solves the problem. For\n     /// simplicity, we don't give users the way to express this\n     /// borrow, it's just used when translating closures.\n+    ///\n+    // FIXME(#112072): This is wrong. Unique borrows are mutable borrows except\n+    // that they do not require their pointee to be marked as a mutable.\n+    // They should still be treated as mutable borrows in every other way,\n+    // e.g. for variance or overlap checking.\n     Unique,\n \n     /// Data is mutable and not aliasable."}, {"sha": "8d44e929afde3a432e8ea8aaf841f418e58fdd6a", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -650,8 +650,8 @@ macro_rules! make_mir_visitor {\n                             BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n                                 NonMutatingUseContext::ShallowBorrow\n                             ),\n-                            BorrowKind::Unique => PlaceContext::NonMutatingUse(\n-                                NonMutatingUseContext::UniqueBorrow\n+                            BorrowKind::Unique => PlaceContext::MutatingUse(\n+                                MutatingUseContext::Borrow\n                             ),\n                             BorrowKind::Mut { .. } =>\n                                 PlaceContext::MutatingUse(MutatingUseContext::Borrow),\n@@ -1265,8 +1265,6 @@ pub enum NonMutatingUseContext {\n     SharedBorrow,\n     /// Shallow borrow.\n     ShallowBorrow,\n-    /// Unique borrow.\n-    UniqueBorrow,\n     /// AddressOf for *const pointer.\n     AddressOf,\n     /// PlaceMention statement.\n@@ -1345,9 +1343,7 @@ impl PlaceContext {\n         matches!(\n             self,\n             PlaceContext::NonMutatingUse(\n-                NonMutatingUseContext::SharedBorrow\n-                    | NonMutatingUseContext::ShallowBorrow\n-                    | NonMutatingUseContext::UniqueBorrow\n+                NonMutatingUseContext::SharedBorrow | NonMutatingUseContext::ShallowBorrow\n             ) | PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n         )\n     }"}, {"sha": "e067d2a984fde4f8a744d04ad765b4dbaf5ade1c", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -573,7 +573,7 @@ impl<'tcx> AdtDef<'tcx> {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer (e.g., issue #31299).\n     pub fn sized_constraint(self, tcx: TyCtxt<'tcx>) -> ty::EarlyBinder<&'tcx [Ty<'tcx>]> {\n-        ty::EarlyBinder::new(tcx.adt_sized_constraint(self.did()))\n+        ty::EarlyBinder::bind(tcx.adt_sized_constraint(self.did()))\n     }\n }\n "}, {"sha": "76f52bc34ed1425ec741c6b4eb27d3332114d3f3", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -264,7 +264,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for mir::Place<'tcx> {\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Region<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.interner().mk_region_from_kind(Decodable::decode(decoder))\n+        ty::Region::new_from_kind(decoder.interner(), Decodable::decode(decoder))\n     }\n }\n "}, {"sha": "aecb46556b0410fcde32c0bf9a9c077e421f40d0", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -254,5 +254,5 @@ pub fn const_param_default(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBind\n             \"`const_param_default` expected a generic parameter with a constant\"\n         ),\n     };\n-    ty::EarlyBinder::new(Const::from_anon_const(tcx, default_def_id))\n+    ty::EarlyBinder::bind(Const::from_anon_const(tcx, default_def_id))\n }"}, {"sha": "77725f0b3b60b1f6499ab7fa0449486fd820bf44", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 13, "deletions": 90, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -115,6 +115,16 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type FreeRegion = ty::FreeRegion;\n     type RegionVid = ty::RegionVid;\n     type PlaceholderRegion = ty::PlaceholderRegion;\n+\n+    fn ty_and_mut_to_parts(\n+        TypeAndMut { ty, mutbl }: TypeAndMut<'tcx>,\n+    ) -> (Self::Ty, Self::Mutability) {\n+        (ty, mutbl)\n+    }\n+\n+    fn mutability_is_mut(mutbl: Self::Mutability) -> bool {\n+        mutbl.is_mut()\n+    }\n }\n \n type InternedSet<'tcx, T> = ShardedHashMap<InternedInSet<'tcx, T>, ()>;\n@@ -713,34 +723,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty_from_kind(Error(reported))\n     }\n \n-    /// Constructs a `RegionKind::ReError` lifetime.\n-    #[track_caller]\n-    pub fn mk_re_error(self, reported: ErrorGuaranteed) -> Region<'tcx> {\n-        self.intern_region(ty::ReError(reported))\n-    }\n-\n-    /// Constructs a `RegionKind::ReError` lifetime and registers a `delay_span_bug` to ensure it\n-    /// gets used.\n-    #[track_caller]\n-    pub fn mk_re_error_misc(self) -> Region<'tcx> {\n-        self.mk_re_error_with_message(\n-            DUMMY_SP,\n-            \"RegionKind::ReError constructed but no error reported\",\n-        )\n-    }\n-\n-    /// Constructs a `RegionKind::ReError` lifetime and registers a `delay_span_bug` with the given\n-    /// `msg` to ensure it gets used.\n-    #[track_caller]\n-    pub fn mk_re_error_with_message<S: Into<MultiSpan>>(\n-        self,\n-        span: S,\n-        msg: &'static str,\n-    ) -> Region<'tcx> {\n-        let reported = self.sess.delay_span_bug(span, msg);\n-        self.mk_re_error(reported)\n-    }\n-\n     /// Like [TyCtxt::ty_error] but for constants, with current `ErrorGuaranteed`\n     #[track_caller]\n     pub fn const_error(self, ty: Ty<'tcx>, reported: ErrorGuaranteed) -> Const<'tcx> {\n@@ -1519,9 +1501,9 @@ macro_rules! direct_interners {\n \n // Functions with a `mk_` prefix are intended for use outside this file and\n // crate. Functions with an `intern_` prefix are intended for use within this\n-// file only, and have a corresponding `mk_` function.\n+// crate only, and have a corresponding `mk_` function.\n direct_interners! {\n-    region: intern_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n+    region: pub(crate) intern_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n     const_: intern_const(ConstData<'tcx>): Const -> Const<'tcx>,\n     const_allocation: pub mk_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n     layout: pub mk_layout(LayoutS): Layout -> Layout<'tcx>,\n@@ -1996,7 +1978,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n-                self.mk_re_early_bound(param.to_early_bound_region_data()).into()\n+                ty::Region::new_early_bound(self, param.to_early_bound_region_data()).into()\n             }\n             GenericParamDefKind::Type { .. } => self.mk_ty_param(param.index, param.name).into(),\n             GenericParamDefKind::Const { .. } => self\n@@ -2036,65 +2018,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_alias(ty::Opaque, self.mk_alias_ty(def_id, substs))\n     }\n \n-    #[inline]\n-    pub fn mk_re_early_bound(self, early_bound_region: ty::EarlyBoundRegion) -> Region<'tcx> {\n-        self.intern_region(ty::ReEarlyBound(early_bound_region))\n-    }\n-\n-    #[inline]\n-    pub fn mk_re_late_bound(\n-        self,\n-        debruijn: ty::DebruijnIndex,\n-        bound_region: ty::BoundRegion,\n-    ) -> Region<'tcx> {\n-        // Use a pre-interned one when possible.\n-        if let ty::BoundRegion { var, kind: ty::BrAnon(None) } = bound_region\n-            && let Some(inner) = self.lifetimes.re_late_bounds.get(debruijn.as_usize())\n-            && let Some(re) = inner.get(var.as_usize()).copied()\n-        {\n-            re\n-        } else {\n-            self.intern_region(ty::ReLateBound(debruijn, bound_region))\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn mk_re_free(self, scope: DefId, bound_region: ty::BoundRegionKind) -> Region<'tcx> {\n-        self.intern_region(ty::ReFree(ty::FreeRegion { scope, bound_region }))\n-    }\n-\n-    #[inline]\n-    pub fn mk_re_var(self, v: ty::RegionVid) -> Region<'tcx> {\n-        // Use a pre-interned one when possible.\n-        self.lifetimes\n-            .re_vars\n-            .get(v.as_usize())\n-            .copied()\n-            .unwrap_or_else(|| self.intern_region(ty::ReVar(v)))\n-    }\n-\n-    #[inline]\n-    pub fn mk_re_placeholder(self, placeholder: ty::PlaceholderRegion) -> Region<'tcx> {\n-        self.intern_region(ty::RePlaceholder(placeholder))\n-    }\n-\n-    // Avoid this in favour of more specific `mk_re_*` methods, where possible,\n-    // to avoid the cost of the `match`.\n-    pub fn mk_region_from_kind(self, kind: ty::RegionKind<'tcx>) -> Region<'tcx> {\n-        match kind {\n-            ty::ReEarlyBound(region) => self.mk_re_early_bound(region),\n-            ty::ReLateBound(debruijn, region) => self.mk_re_late_bound(debruijn, region),\n-            ty::ReFree(ty::FreeRegion { scope, bound_region }) => {\n-                self.mk_re_free(scope, bound_region)\n-            }\n-            ty::ReStatic => self.lifetimes.re_static,\n-            ty::ReVar(vid) => self.mk_re_var(vid),\n-            ty::RePlaceholder(region) => self.mk_re_placeholder(region),\n-            ty::ReErased => self.lifetimes.re_erased,\n-            ty::ReError(reported) => self.mk_re_error(reported),\n-        }\n-    }\n-\n     pub fn mk_place_field(self, place: Place<'tcx>, f: FieldIdx, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.mk_place_elem(place, PlaceElem::Field(f, ty))\n     }"}, {"sha": "66293f19eef63c42ccb6c9a1ce08a07ff590e2a9", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -45,7 +45,6 @@ pub enum TypeError<'tcx> {\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n     RegionsInsufficientlyPolymorphic(BoundRegionKind, Region<'tcx>),\n-    RegionsOverlyPolymorphic(BoundRegionKind, Region<'tcx>),\n     RegionsPlaceholderMismatch,\n \n     Sorts(ExpectedFound<Ty<'tcx>>),\n@@ -74,7 +73,6 @@ impl TypeError<'_> {\n         match self {\n             TypeError::RegionsDoesNotOutlive(_, _)\n             | TypeError::RegionsInsufficientlyPolymorphic(_, _)\n-            | TypeError::RegionsOverlyPolymorphic(_, _)\n             | TypeError::RegionsPlaceholderMismatch => true,\n             _ => false,\n         }\n@@ -98,11 +96,6 @@ impl<'tcx> TypeError<'tcx> {\n             }\n         }\n \n-        let br_string = |br: ty::BoundRegionKind| match br {\n-            ty::BrNamed(_, name) => format!(\" {}\", name),\n-            _ => String::new(),\n-        };\n-\n         match self {\n             CyclicTy(_) => \"cyclic type of infinite size\".into(),\n             CyclicConst(_) => \"encountered a self-referencing constant\".into(),\n@@ -144,11 +137,6 @@ impl<'tcx> TypeError<'tcx> {\n             RegionsInsufficientlyPolymorphic(..) => {\n                 \"one type is more general than the other\".into()\n             }\n-            RegionsOverlyPolymorphic(br, _) => format!(\n-                \"expected concrete lifetime, found bound lifetime parameter{}\",\n-                br_string(br)\n-            )\n-            .into(),\n             RegionsPlaceholderMismatch => \"one type is more general than the other\".into(),\n             ArgumentSorts(values, _) | Sorts(values) => {\n                 let expected = values.expected.sort_string(tcx);\n@@ -228,7 +216,6 @@ impl<'tcx> TypeError<'tcx> {\n             | FieldMisMatch(..)\n             | RegionsDoesNotOutlive(..)\n             | RegionsInsufficientlyPolymorphic(..)\n-            | RegionsOverlyPolymorphic(..)\n             | RegionsPlaceholderMismatch\n             | Traits(_)\n             | ProjectionMismatched(_)"}, {"sha": "149ce29b8d943f423a23287c57019719594e67f3", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -213,7 +213,7 @@ where\n                     // debruijn index. Then we adjust it to the\n                     // correct depth.\n                     assert_eq!(debruijn1, ty::INNERMOST);\n-                    self.tcx.mk_re_late_bound(debruijn, br)\n+                    ty::Region::new_late_bound(self.tcx, debruijn, br)\n                 } else {\n                     region\n                 }\n@@ -328,7 +328,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.replace_late_bound_regions_uncached(value, |br| {\n-            self.mk_re_free(all_outlive_scope, br.kind)\n+            ty::Region::new_free(self, all_outlive_scope, br.kind)\n         })\n     }\n \n@@ -341,7 +341,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             value,\n             FnMutDelegate {\n                 regions: &mut |r: ty::BoundRegion| {\n-                    self.mk_re_late_bound(\n+                    ty::Region::new_late_bound(\n+                        self,\n                         ty::INNERMOST,\n                         ty::BoundRegion { var: shift_bv(r.var), kind: r.kind },\n                     )\n@@ -383,7 +384,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     .or_insert_with(|| ty::BoundVariableKind::Region(ty::BrAnon(None)))\n                     .expect_region();\n                 let br = ty::BoundRegion { var, kind };\n-                self.tcx.mk_re_late_bound(ty::INNERMOST, br)\n+                ty::Region::new_late_bound(self.tcx, ty::INNERMOST, br)\n             }\n             fn replace_ty(&mut self, bt: ty::BoundTy) -> Ty<'tcx> {\n                 let entry = self.map.entry(bt.var);\n@@ -451,7 +452,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Shifter<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn >= self.current_index => {\n                 let debruijn = debruijn.shifted_in(self.amount);\n-                self.tcx.mk_re_late_bound(debruijn, br)\n+                ty::Region::new_late_bound(self.tcx, debruijn, br)\n             }\n             _ => r,\n         }\n@@ -492,7 +493,7 @@ pub fn shift_region<'tcx>(\n ) -> ty::Region<'tcx> {\n     match *region {\n         ty::ReLateBound(debruijn, br) if amount > 0 => {\n-            tcx.mk_re_late_bound(debruijn.shifted_in(amount), br)\n+            ty::Region::new_late_bound(tcx, debruijn.shifted_in(amount), br)\n         }\n         _ => region,\n     }"}, {"sha": "30f92b91cb7a01b155babf947f8afa167c692db3", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -100,7 +100,7 @@ impl GenericParamDef {\n         preceding_substs: &[ty::GenericArg<'tcx>],\n     ) -> ty::GenericArg<'tcx> {\n         match &self.kind {\n-            ty::GenericParamDefKind::Lifetime => tcx.mk_re_error_misc().into(),\n+            ty::GenericParamDefKind::Lifetime => ty::Region::new_error_misc(tcx).into(),\n             ty::GenericParamDefKind::Type { .. } => tcx.ty_error_misc().into(),\n             ty::GenericParamDefKind::Const { .. } => {\n                 tcx.const_error_misc(tcx.type_of(self.def_id).subst(tcx, preceding_substs)).into()\n@@ -343,7 +343,7 @@ impl<'tcx> GenericPredicates<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> impl Iterator<Item = (Predicate<'tcx>, Span)> + DoubleEndedIterator + ExactSizeIterator\n     {\n-        EarlyBinder::new(self.predicates).subst_iter_copied(tcx, substs)\n+        EarlyBinder::bind(self.predicates).subst_iter_copied(tcx, substs)\n     }\n \n     #[instrument(level = \"debug\", skip(self, tcx))]\n@@ -358,7 +358,7 @@ impl<'tcx> GenericPredicates<'tcx> {\n         }\n         instantiated\n             .predicates\n-            .extend(self.predicates.iter().map(|(p, _)| EarlyBinder::new(*p).subst(tcx, substs)));\n+            .extend(self.predicates.iter().map(|(p, _)| EarlyBinder::bind(*p).subst(tcx, substs)));\n         instantiated.spans.extend(self.predicates.iter().map(|(_, sp)| *sp));\n     }\n "}, {"sha": "d48672b2baaeec5015d7344253a56a90f87aacc1", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -158,7 +158,7 @@ impl<'tcx> InhabitedPredicate<'tcx> {\n     fn subst_opt(self, tcx: TyCtxt<'tcx>, substs: ty::SubstsRef<'tcx>) -> Option<Self> {\n         match self {\n             Self::ConstIsZero(c) => {\n-                let c = ty::EarlyBinder::new(c).subst(tcx, substs);\n+                let c = ty::EarlyBinder::bind(c).subst(tcx, substs);\n                 let pred = match c.kind().try_to_target_usize(tcx) {\n                     Some(0) => Self::True,\n                     Some(1..) => Self::False,\n@@ -167,7 +167,7 @@ impl<'tcx> InhabitedPredicate<'tcx> {\n                 Some(pred)\n             }\n             Self::GenericType(t) => {\n-                Some(ty::EarlyBinder::new(t).subst(tcx, substs).inhabited_predicate(tcx))\n+                Some(ty::EarlyBinder::bind(t).subst(tcx, substs).inhabited_predicate(tcx))\n             }\n             Self::And(&[a, b]) => match a.subst_opt(tcx, substs) {\n                 None => b.subst_opt(tcx, substs).map(|b| a.and(tcx, b)),"}, {"sha": "72341e656e29e6ea7ab8672effb27eff0d48790b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -764,7 +764,7 @@ impl<'tcx> Predicate<'tcx> {\n         let shifted_pred =\n             tcx.shift_bound_var_indices(trait_bound_vars.len(), bound_pred.skip_binder());\n         // 2) Self: Bar1<'a, '^0.1> -> T: Bar1<'^0.0, '^0.1>\n-        let new = EarlyBinder::new(shifted_pred).subst(tcx, trait_ref.skip_binder().substs);\n+        let new = EarlyBinder::bind(shifted_pred).subst(tcx, trait_ref.skip_binder().substs);\n         // 3) ['x] + ['b] -> ['x, 'b]\n         let bound_vars =\n             tcx.mk_bound_variable_kinds_from_iter(trait_bound_vars.iter().chain(pred_bound_vars));\n@@ -1496,7 +1496,7 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n /// identified by both a universe, as well as a name residing within that universe. Distinct bound\n /// regions/types/consts within the same universe simply have an unknown relationship to one\n /// another.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n #[derive(HashStable, TyEncodable, TyDecodable)]\n pub struct Placeholder<T> {\n     pub universe: UniverseIndex,"}, {"sha": "d1ed7be3d2e4369d1b56cbd4ad1ffbe63a114f7a", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n \n-                self.interner().mk_re_error(e)\n+                ty::Region::new_error(self.interner(), e)\n             }\n         }\n     }"}, {"sha": "6156fdf7eac24fa362540ab5b15851224a3d4b32", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> RegionHighlightMode<'tcx> {\n \n     /// Convenience wrapper for `highlighting_region`.\n     pub fn highlighting_region_vid(&mut self, vid: ty::RegionVid, number: usize) {\n-        self.highlighting_region(self.tcx.mk_re_var(vid), number)\n+        self.highlighting_region(ty::Region::new_var(self.tcx, vid), number)\n     }\n \n     /// Returns `Some(n)` with the number to use for the given region, if any.\n@@ -685,29 +685,30 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n-                let verbose = self.should_print_verbose();\n+                if self.should_print_verbose() {\n+                    p!(write(\"{:?}\", ty.kind()));\n+                    return Ok(self);\n+                }\n+\n                 if let ty::TyVar(ty_vid) = infer_ty {\n                     if let Some(name) = self.ty_infer_name(ty_vid) {\n                         p!(write(\"{}\", name))\n                     } else {\n-                        if verbose {\n-                            p!(write(\"{:?}\", infer_ty))\n-                        } else {\n-                            p!(write(\"{}\", infer_ty))\n-                        }\n+                        p!(write(\"{}\", infer_ty))\n                     }\n                 } else {\n-                    if verbose { p!(write(\"{:?}\", infer_ty)) } else { p!(write(\"{}\", infer_ty)) }\n+                    p!(write(\"{}\", infer_ty))\n                 }\n             }\n             ty::Error(_) => p!(\"{{type error}}\"),\n             ty::Param(ref param_ty) => p!(print(param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n-                ty::BoundTyKind::Anon => debug_bound_var(&mut self, debruijn, bound_ty.var)?,\n+                ty::BoundTyKind::Anon => {\n+                    rustc_type_ir::debug_bound_var(&mut self, debruijn, bound_ty.var)?\n+                }\n                 ty::BoundTyKind::Param(_, s) => match self.should_print_verbose() {\n-                    true if debruijn == ty::INNERMOST => p!(write(\"^{}\", s)),\n-                    true => p!(write(\"^{}_{}\", debruijn.index(), s)),\n-                    false => p!(write(\"{}\", s)),\n+                    true => p!(write(\"{:?}\", ty.kind())),\n+                    false => p!(write(\"{s}\")),\n                 },\n             },\n             ty::Adt(def, substs) => {\n@@ -740,10 +741,11 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n             }\n             ty::Placeholder(placeholder) => match placeholder.bound.kind {\n-                ty::BoundTyKind::Anon => {\n-                    debug_placeholder_var(&mut self, placeholder.universe, placeholder.bound.var)?;\n-                }\n-                ty::BoundTyKind::Param(_, name) => p!(write(\"{}\", name)),\n+                ty::BoundTyKind::Anon => p!(write(\"{placeholder:?}\")),\n+                ty::BoundTyKind::Param(_, name) => match self.should_print_verbose() {\n+                    true => p!(write(\"{:?}\", ty.kind())),\n+                    false => p!(write(\"{name}\")),\n+                },\n             },\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 // We use verbose printing in 'NO_QUERIES' mode, to\n@@ -1372,11 +1374,9 @@ pub trait PrettyPrinter<'tcx>:\n             }\n \n             ty::ConstKind::Bound(debruijn, bound_var) => {\n-                debug_bound_var(&mut self, debruijn, bound_var)?\n+                rustc_type_ir::debug_bound_var(&mut self, debruijn, bound_var)?\n             }\n-            ty::ConstKind::Placeholder(placeholder) => {\n-                debug_placeholder_var(&mut self, placeholder.universe, placeholder.bound)?;\n-            },\n+            ty::ConstKind::Placeholder(placeholder) => p!(write(\"{placeholder:?}\")),\n             // FIXME(generic_const_exprs):\n             // write out some legible representation of an abstract const?\n             ty::ConstKind::Expr(_) => p!(\"{{const expr}}\"),\n@@ -2303,7 +2303,7 @@ impl<'a, 'tcx> ty::TypeFolder<TyCtxt<'tcx>> for RegionFolder<'a, 'tcx> {\n         };\n         if let ty::ReLateBound(debruijn1, br) = *region {\n             assert_eq!(debruijn1, ty::INNERMOST);\n-            self.tcx.mk_re_late_bound(self.current_index, br)\n+            ty::Region::new_late_bound(self.tcx, self.current_index, br)\n         } else {\n             region\n         }\n@@ -2415,7 +2415,8 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                         if let Some(lt_idx) = lifetime_idx {\n                             if lt_idx > binder_level_idx {\n                                 let kind = ty::BrNamed(CRATE_DEF_ID.to_def_id(), name);\n-                                return tcx.mk_re_late_bound(\n+                                return ty::Region::new_late_bound(\n+                                    tcx,\n                                     ty::INNERMOST,\n                                     ty::BoundRegion { var: br.var, kind },\n                                 );\n@@ -2430,7 +2431,8 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                         if let Some(lt_idx) = lifetime_idx {\n                             if lt_idx > binder_level_idx {\n                                 let kind = ty::BrNamed(def_id, name);\n-                                return tcx.mk_re_late_bound(\n+                                return ty::Region::new_late_bound(\n+                                    tcx,\n                                     ty::INNERMOST,\n                                     ty::BoundRegion { var: br.var, kind },\n                                 );\n@@ -2443,7 +2445,8 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                         if let Some(lt_idx) = lifetime_idx {\n                             if lt_idx > binder_level_idx {\n                                 let kind = br.kind;\n-                                return tcx.mk_re_late_bound(\n+                                return ty::Region::new_late_bound(\n+                                    tcx,\n                                     ty::INNERMOST,\n                                     ty::BoundRegion { var: br.var, kind },\n                                 );\n@@ -2458,7 +2461,11 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                     start_or_continue(&mut self, \"for<\", \", \");\n                     do_continue(&mut self, name);\n                 }\n-                tcx.mk_re_late_bound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind })\n+                ty::Region::new_late_bound(\n+                    tcx,\n+                    ty::INNERMOST,\n+                    ty::BoundRegion { var: br.var, kind },\n+                )\n             };\n             let mut folder = RegionFolder {\n                 tcx,\n@@ -3065,27 +3072,3 @@ pub struct OpaqueFnEntry<'tcx> {\n     fn_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n     return_ty: Option<ty::Binder<'tcx, Term<'tcx>>>,\n }\n-\n-pub fn debug_bound_var<T: std::fmt::Write>(\n-    fmt: &mut T,\n-    debruijn: ty::DebruijnIndex,\n-    var: ty::BoundVar,\n-) -> Result<(), std::fmt::Error> {\n-    if debruijn == ty::INNERMOST {\n-        write!(fmt, \"^{}\", var.index())\n-    } else {\n-        write!(fmt, \"^{}_{}\", debruijn.index(), var.index())\n-    }\n-}\n-\n-pub fn debug_placeholder_var<T: std::fmt::Write>(\n-    fmt: &mut T,\n-    universe: ty::UniverseIndex,\n-    bound: ty::BoundVar,\n-) -> Result<(), std::fmt::Error> {\n-    if universe == ty::UniverseIndex::ROOT {\n-        write!(fmt, \"!{}\", bound.index())\n-    } else {\n-        write!(fmt, \"!{}_{}\", universe.index(), bound.index())\n-    }\n-}"}, {"sha": "8bcae3d9ab7cc7450c2a5d5bed364ed49d671731", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -589,17 +589,6 @@ pub fn structurally_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     debug!(\"{}.structurally_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n-    // HACK(const_generics): We still need to eagerly evaluate consts when\n-    // relating them because during `normalize_param_env_or_error`,\n-    // we may relate an evaluated constant in a obligation against\n-    // an unnormalized (i.e. unevaluated) const in the param-env.\n-    // FIXME(generic_const_exprs): Once we always lazily unify unevaluated constants\n-    // these `eval` calls can be removed.\n-    if !tcx.features().generic_const_exprs {\n-        a = a.eval(tcx, relation.param_env());\n-        b = b.eval(tcx, relation.param_env());\n-    }\n-\n     if tcx.features().generic_const_exprs {\n         a = tcx.expand_abstract_consts(a);\n         b = tcx.expand_abstract_consts(b);"}, {"sha": "a965450d27d43830b31538461b174afc3e8b46f2", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -88,7 +88,35 @@ impl fmt::Debug for ty::FreeRegion {\n \n impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"({:?}; c_variadic: {})->{:?}\", self.inputs(), self.c_variadic, self.output())\n+        let ty::FnSig { inputs_and_output: _, c_variadic, unsafety, abi } = self;\n+\n+        write!(f, \"{}\", unsafety.prefix_str())?;\n+        match abi {\n+            rustc_target::spec::abi::Abi::Rust => (),\n+            abi => write!(f, \"extern \\\"{abi:?}\\\" \")?,\n+        };\n+\n+        write!(f, \"fn(\")?;\n+        let inputs = self.inputs();\n+        match inputs.len() {\n+            0 if *c_variadic => write!(f, \"...)\")?,\n+            0 => write!(f, \")\")?,\n+            _ => {\n+                for ty in &self.inputs()[0..(self.inputs().len() - 1)] {\n+                    write!(f, \"{ty:?}, \")?;\n+                }\n+                write!(f, \"{:?}\", self.inputs().last().unwrap())?;\n+                if *c_variadic {\n+                    write!(f, \"...\")?;\n+                }\n+                write!(f, \")\")?;\n+            }\n+        }\n+\n+        match self.output().kind() {\n+            ty::Tuple(list) if list.is_empty() => Ok(()),\n+            _ => write!(f, \" -> {:?}\", self.output()),\n+        }\n     }\n }\n \n@@ -216,20 +244,37 @@ impl<'tcx> fmt::Debug for ty::ConstKind<'tcx> {\n         match self {\n             Param(param) => write!(f, \"{param:?}\"),\n             Infer(var) => write!(f, \"{var:?}\"),\n-            Bound(debruijn, var) => ty::print::debug_bound_var(f, *debruijn, *var),\n-            Placeholder(placeholder) => {\n-                ty::print::debug_placeholder_var(f, placeholder.universe, placeholder.bound)\n-            }\n+            Bound(debruijn, var) => rustc_type_ir::debug_bound_var(f, *debruijn, *var),\n+            Placeholder(placeholder) => write!(f, \"{placeholder:?}\"),\n             Unevaluated(uv) => {\n                 f.debug_tuple(\"Unevaluated\").field(&uv.substs).field(&uv.def).finish()\n             }\n             Value(valtree) => write!(f, \"{valtree:?}\"),\n-            Error(_) => write!(f, \"[const error]\"),\n+            Error(_) => write!(f, \"{{const error}}\"),\n             Expr(expr) => write!(f, \"{expr:?}\"),\n         }\n     }\n }\n \n+impl fmt::Debug for ty::BoundTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.kind {\n+            ty::BoundTyKind::Anon => write!(f, \"{:?}\", self.var),\n+            ty::BoundTyKind::Param(_, sym) => write!(f, \"{sym:?}\"),\n+        }\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for ty::Placeholder<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.universe == ty::UniverseIndex::ROOT {\n+            write!(f, \"!{:?}\", self.bound)\n+        } else {\n+            write!(f, \"!{}_{:?}\", self.universe.index(), self.bound)\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Atomic structs\n //\n@@ -294,6 +339,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::AliasRelationDirection,\n     crate::ty::Placeholder<crate::ty::BoundRegion>,\n     crate::ty::Placeholder<crate::ty::BoundTy>,\n+    crate::ty::Placeholder<ty::BoundVar>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,\n     crate::ty::InferTy,\n@@ -310,7 +356,6 @@ TrivialTypeTraversalAndLiftImpls! {\n     interpret::Scalar,\n     rustc_target::abi::Size,\n     ty::BoundVar,\n-    ty::Placeholder<ty::BoundVar>,\n }\n \n TrivialTypeTraversalAndLiftImpls! {"}, {"sha": "d19a7bcde79bc8fc3800f3db308e68707df981a3", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 102, "deletions": 4, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -15,14 +15,14 @@ use hir::def::DefKind;\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n+use rustc_errors::{DiagnosticArgValue, ErrorGuaranteed, IntoDiagnosticArg, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_index::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{FieldIdx, VariantIdx, FIRST_VARIANT};\n use rustc_target::spec::abi::{self, Abi};\n use std::borrow::Cow;\n@@ -568,7 +568,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n         let layout = tcx.generator_layout(def_id).unwrap();\n         layout.variant_fields.iter().map(move |variant| {\n             variant.iter().map(move |field| {\n-                ty::EarlyBinder::new(layout.field_tys[*field].ty).subst(tcx, self.substs)\n+                ty::EarlyBinder::bind(layout.field_tys[*field].ty).subst(tcx, self.substs)\n             })\n         })\n     }\n@@ -1459,6 +1459,103 @@ impl ParamConst {\n #[rustc_pass_by_value]\n pub struct Region<'tcx>(pub Interned<'tcx, RegionKind<'tcx>>);\n \n+impl<'tcx> Region<'tcx> {\n+    #[inline]\n+    pub fn new_early_bound(\n+        tcx: TyCtxt<'tcx>,\n+        early_bound_region: ty::EarlyBoundRegion,\n+    ) -> Region<'tcx> {\n+        tcx.intern_region(ty::ReEarlyBound(early_bound_region))\n+    }\n+\n+    #[inline]\n+    pub fn new_late_bound(\n+        tcx: TyCtxt<'tcx>,\n+        debruijn: ty::DebruijnIndex,\n+        bound_region: ty::BoundRegion,\n+    ) -> Region<'tcx> {\n+        // Use a pre-interned one when possible.\n+        if let ty::BoundRegion { var, kind: ty::BrAnon(None) } = bound_region\n+            && let Some(inner) = tcx.lifetimes.re_late_bounds.get(debruijn.as_usize())\n+            && let Some(re) = inner.get(var.as_usize()).copied()\n+        {\n+            re\n+        } else {\n+            tcx.intern_region(ty::ReLateBound(debruijn, bound_region))\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn new_free(\n+        tcx: TyCtxt<'tcx>,\n+        scope: DefId,\n+        bound_region: ty::BoundRegionKind,\n+    ) -> Region<'tcx> {\n+        tcx.intern_region(ty::ReFree(ty::FreeRegion { scope, bound_region }))\n+    }\n+\n+    #[inline]\n+    pub fn new_var(tcx: TyCtxt<'tcx>, v: ty::RegionVid) -> Region<'tcx> {\n+        // Use a pre-interned one when possible.\n+        tcx.lifetimes\n+            .re_vars\n+            .get(v.as_usize())\n+            .copied()\n+            .unwrap_or_else(|| tcx.intern_region(ty::ReVar(v)))\n+    }\n+\n+    #[inline]\n+    pub fn new_placeholder(tcx: TyCtxt<'tcx>, placeholder: ty::PlaceholderRegion) -> Region<'tcx> {\n+        tcx.intern_region(ty::RePlaceholder(placeholder))\n+    }\n+\n+    /// Constructs a `RegionKind::ReError` region.\n+    #[track_caller]\n+    pub fn new_error(tcx: TyCtxt<'tcx>, reported: ErrorGuaranteed) -> Region<'tcx> {\n+        tcx.intern_region(ty::ReError(reported))\n+    }\n+\n+    /// Constructs a `RegionKind::ReError` region and registers a `delay_span_bug` to ensure it\n+    /// gets used.\n+    #[track_caller]\n+    pub fn new_error_misc(tcx: TyCtxt<'tcx>) -> Region<'tcx> {\n+        Region::new_error_with_message(\n+            tcx,\n+            DUMMY_SP,\n+            \"RegionKind::ReError constructed but no error reported\",\n+        )\n+    }\n+\n+    /// Constructs a `RegionKind::ReError` region and registers a `delay_span_bug` with the given\n+    /// `msg` to ensure it gets used.\n+    #[track_caller]\n+    pub fn new_error_with_message<S: Into<MultiSpan>>(\n+        tcx: TyCtxt<'tcx>,\n+        span: S,\n+        msg: &'static str,\n+    ) -> Region<'tcx> {\n+        let reported = tcx.sess.delay_span_bug(span, msg);\n+        Region::new_error(tcx, reported)\n+    }\n+\n+    /// Avoid this in favour of more specific `new_*` methods, where possible,\n+    /// to avoid the cost of the `match`.\n+    pub fn new_from_kind(tcx: TyCtxt<'tcx>, kind: RegionKind<'tcx>) -> Region<'tcx> {\n+        match kind {\n+            ty::ReEarlyBound(region) => Region::new_early_bound(tcx, region),\n+            ty::ReLateBound(debruijn, region) => Region::new_late_bound(tcx, debruijn, region),\n+            ty::ReFree(ty::FreeRegion { scope, bound_region }) => {\n+                Region::new_free(tcx, scope, bound_region)\n+            }\n+            ty::ReStatic => tcx.lifetimes.re_static,\n+            ty::ReVar(vid) => Region::new_var(tcx, vid),\n+            ty::RePlaceholder(region) => Region::new_placeholder(tcx, region),\n+            ty::ReErased => tcx.lifetimes.re_erased,\n+            ty::ReError(reported) => Region::new_error(tcx, reported),\n+        }\n+    }\n+}\n+\n impl<'tcx> Deref for Region<'tcx> {\n     type Target = RegionKind<'tcx>;\n \n@@ -1511,10 +1608,11 @@ impl Atom for RegionVid {\n \n rustc_index::newtype_index! {\n     #[derive(HashStable)]\n+    #[debug_format = \"{}\"]\n     pub struct BoundVar {}\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct BoundTy {\n     pub var: BoundVar,"}, {"sha": "8685a22d9ca88767fb7168ed01795f0f5e76b2cc", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -545,7 +545,7 @@ impl<'tcx, T> !TypeFoldable<TyCtxt<'tcx>> for ty::EarlyBinder<T> {}\n impl<'tcx, T> !TypeVisitable<TyCtxt<'tcx>> for ty::EarlyBinder<T> {}\n \n impl<T> EarlyBinder<T> {\n-    pub fn new(inner: T) -> EarlyBinder<T> {\n+    pub fn bind(inner: T) -> EarlyBinder<T> {\n         EarlyBinder(inner)\n     }\n "}, {"sha": "311f63adc7f4962bbdc9a012b2e6f4e6146c2a23", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -709,7 +709,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             .as_ref()\n             .map_or_else(|| [].iter(), |l| l.field_tys.iter())\n             .filter(|decl| !decl.ignore_for_traits)\n-            .map(|decl| ty::EarlyBinder::new(decl.ty))\n+            .map(|decl| ty::EarlyBinder::bind(decl.ty))\n     }\n \n     /// Normalizes all opaque types in the given value, replacing them"}, {"sha": "a00c77ccbcdc2a115cb311f6633258f3abc11e59", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -96,13 +96,13 @@ impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for Representability {\n \n impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::EarlyBinder<Ty<'_>> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> Self {\n-        ty::EarlyBinder::new(Ty::from_cycle_error(tcx, cycle))\n+        ty::EarlyBinder::bind(Ty::from_cycle_error(tcx, cycle))\n     }\n }\n \n impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::EarlyBinder<ty::Binder<'_, ty::FnSig<'_>>> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> Self {\n-        ty::EarlyBinder::new(ty::Binder::from_cycle_error(tcx, cycle))\n+        ty::EarlyBinder::bind(ty::Binder::from_cycle_error(tcx, cycle))\n     }\n }\n "}, {"sha": "d00fb754c6415a60878e7211b5644d2062837f40", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -142,7 +142,7 @@ impl<'tcx> Cx<'tcx> {\n                     var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                     kind: ty::BrEnv,\n                 };\n-                let env_region = self.tcx.mk_re_late_bound(ty::INNERMOST, br);\n+                let env_region = ty::Region::new_late_bound(self.tcx, ty::INNERMOST, br);\n                 let closure_env_ty =\n                     self.tcx.closure_env_ty(closure_def_id, closure_substs, env_region).unwrap();\n                 let liberated_closure_env_ty = self.tcx.erase_late_bound_regions("}, {"sha": "6ae6bdc17d5012e7773c307eed96975a30a618e8", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -199,8 +199,7 @@ impl DefUse {\n                 | NonMutatingUseContext::Move\n                 | NonMutatingUseContext::PlaceMention\n                 | NonMutatingUseContext::ShallowBorrow\n-                | NonMutatingUseContext::SharedBorrow\n-                | NonMutatingUseContext::UniqueBorrow,\n+                | NonMutatingUseContext::SharedBorrow,\n             ) => Some(DefUse::Use),\n \n             PlaceContext::MutatingUse(MutatingUseContext::Projection)"}, {"sha": "1ba1951afdef559713089a83b2400987b56fcb5a", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -772,7 +772,6 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n             // mutation.\n             | NonMutatingUse(NonMutatingUseContext::SharedBorrow)\n             | NonMutatingUse(NonMutatingUseContext::ShallowBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::UniqueBorrow)\n             | NonMutatingUse(NonMutatingUseContext::AddressOf)\n             | MutatingUse(MutatingUseContext::Borrow)\n             | MutatingUse(MutatingUseContext::AddressOf) => {"}, {"sha": "3df459dfa79bd4dcfad618b02d40d288ffcb48b4", "filename": "compiler/rustc_mir_transform/src/copy_prop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -130,7 +130,6 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n             PlaceContext::NonMutatingUse(\n                 NonMutatingUseContext::SharedBorrow\n                 | NonMutatingUseContext::ShallowBorrow\n-                | NonMutatingUseContext::UniqueBorrow\n                 | NonMutatingUseContext::AddressOf,\n             ) => true,\n             // For debuginfo, merging locals is ok."}, {"sha": "b1c9c4acc40e44d7eae43c9d75898c9a7b36c9b0", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n                         // If the inner type matches the type bound by `Pointer`\n                         if inner_ty == bound_ty {\n                             // Do a substitution using the parameters from the callsite\n-                            let subst_ty = EarlyBinder::new(inner_ty).subst(self.tcx, substs_ref);\n+                            let subst_ty = EarlyBinder::bind(inner_ty).subst(self.tcx, substs_ref);\n                             if let Some((fn_id, fn_substs)) =\n                                 FunctionItemRefChecker::is_fn_ref(subst_ty)\n                             {"}, {"sha": "55b9f084c39f7265f754a1f2e5e1e47fc9eea162", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -192,7 +192,7 @@ impl<'tcx> Inliner<'tcx> {\n         let Ok(callee_body) = callsite.callee.try_subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             self.param_env,\n-            ty::EarlyBinder::new(callee_body.clone()),\n+            ty::EarlyBinder::bind(callee_body.clone()),\n         ) else {\n             return Err(\"failed to normalize callee body\");\n         };\n@@ -455,7 +455,7 @@ impl<'tcx> Inliner<'tcx> {\n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n                 let ty = callsite\n                     .callee\n-                    .subst_mir(self.tcx, ty::EarlyBinder::new(&place.ty(callee_body, tcx).ty));\n+                    .subst_mir(self.tcx, ty::EarlyBinder::bind(&place.ty(callee_body, tcx).ty));\n                 if ty.needs_drop(tcx, self.param_env) && let UnwindAction::Cleanup(unwind) = unwind {\n                     work_list.push(unwind);\n                 }\n@@ -790,7 +790,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n                 let ty = self\n                     .instance\n-                    .subst_mir(tcx, ty::EarlyBinder::new(&place.ty(self.callee_body, tcx).ty));\n+                    .subst_mir(tcx, ty::EarlyBinder::bind(&place.ty(self.callee_body, tcx).ty));\n                 if ty.needs_drop(tcx, self.param_env) {\n                     self.cost += CALL_PENALTY;\n                     if let UnwindAction::Cleanup(_) = unwind {\n@@ -801,7 +801,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n                 }\n             }\n             TerminatorKind::Call { func: Operand::Constant(ref f), unwind, .. } => {\n-                let fn_ty = self.instance.subst_mir(tcx, ty::EarlyBinder::new(&f.literal.ty()));\n+                let fn_ty = self.instance.subst_mir(tcx, ty::EarlyBinder::bind(&f.literal.ty()));\n                 self.cost += if let ty::FnDef(def_id, _) = *fn_ty.kind() && tcx.is_intrinsic(def_id) {\n                     // Don't give intrinsics the extra penalty for calls\n                     INSTR_COST"}, {"sha": "8a10445f8377e2210221dfbff7f6e5bf23ab527f", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -47,7 +47,7 @@ pub(crate) fn mir_callgraph_reachable<'tcx>(\n             let Ok(substs) = caller.try_subst_mir_and_normalize_erasing_regions(\n                 tcx,\n                 param_env,\n-                ty::EarlyBinder::new(substs),\n+                ty::EarlyBinder::bind(substs),\n             ) else {\n                 trace!(?caller, ?param_env, ?substs, \"cannot normalize, skipping\");\n                 continue;"}, {"sha": "ae726dea944265a0775b80849defc95907b8376b", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -69,7 +69,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n             // of this function. Is this intentional?\n             if let Some(ty::Generator(gen_def_id, substs, _)) = ty.map(Ty::kind) {\n                 let body = tcx.optimized_mir(*gen_def_id).generator_drop().unwrap();\n-                let body = EarlyBinder::new(body.clone()).subst(tcx, substs);\n+                let body = EarlyBinder::bind(body.clone()).subst(tcx, substs);\n                 debug!(\"make_shim({:?}) = {:?}\", instance, body);\n                 return body;\n             }"}, {"sha": "7a0d3a025f3652c1608d5c997588e25b782ec6fc", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -216,7 +216,6 @@ impl<'tcx> Visitor<'tcx> for SsaVisitor<'_> {\n             PlaceContext::NonMutatingUse(\n                 NonMutatingUseContext::SharedBorrow\n                 | NonMutatingUseContext::ShallowBorrow\n-                | NonMutatingUseContext::UniqueBorrow\n                 | NonMutatingUseContext::AddressOf,\n             )\n             | PlaceContext::MutatingUse(_) => {"}, {"sha": "cefa64d27acbadba858c0f6229ca9b6a0507dc92", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -677,7 +677,7 @@ impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             ty::ParamEnv::reveal_all(),\n-            ty::EarlyBinder::new(value),\n+            ty::EarlyBinder::bind(value),\n         )\n     }\n }"}, {"sha": "89dadc782f2dad06518109c76f4eb9c13f875842", "filename": "compiler/rustc_monomorphize/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,4 +1,5 @@\n #![feature(array_windows)]\n+#![feature(is_sorted)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "1b872484eb1e218c3ad8b17795c1b7d1846dbd91", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "added", "additions": 1194, "deletions": 0, "changes": 1194, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,1194 @@\n+//! Partitioning Codegen Units for Incremental Compilation\n+//! ======================================================\n+//!\n+//! The task of this module is to take the complete set of monomorphizations of\n+//! a crate and produce a set of codegen units from it, where a codegen unit\n+//! is a named set of (mono-item, linkage) pairs. That is, this module\n+//! decides which monomorphization appears in which codegen units with which\n+//! linkage. The following paragraphs describe some of the background on the\n+//! partitioning scheme.\n+//!\n+//! The most important opportunity for saving on compilation time with\n+//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n+//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n+//! we call them \"codegen units\", the particulars of how much time can be saved\n+//! by incremental compilation are tightly linked to how the output program is\n+//! partitioned into these codegen units prior to passing it to LLVM --\n+//! especially because we have to treat codegen units as opaque entities once\n+//! they are created: There is no way for us to incrementally update an existing\n+//! LLVM module and so we have to build any such module from scratch if it was\n+//! affected by some change in the source code.\n+//!\n+//! From that point of view it would make sense to maximize the number of\n+//! codegen units by, for example, putting each function into its own module.\n+//! That way only those modules would have to be re-compiled that were actually\n+//! affected by some change, minimizing the number of functions that could have\n+//! been re-used but just happened to be located in a module that is\n+//! re-compiled.\n+//!\n+//! However, since LLVM optimization does not work across module boundaries,\n+//! using such a highly granular partitioning would lead to very slow runtime\n+//! code since it would effectively prohibit inlining and other inter-procedure\n+//! optimizations. We want to avoid that as much as possible.\n+//!\n+//! Thus we end up with a trade-off: The bigger the codegen units, the better\n+//! LLVM's optimizer can do its work, but also the smaller the compilation time\n+//! reduction we get from incremental compilation.\n+//!\n+//! Ideally, we would create a partitioning such that there are few big codegen\n+//! units with few interdependencies between them. For now though, we use the\n+//! following heuristic to determine the partitioning:\n+//!\n+//! - There are two codegen units for every source-level module:\n+//! - One for \"stable\", that is non-generic, code\n+//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n+//!   defined in that module\n+//!\n+//! In order to see why this heuristic makes sense, let's take a look at when a\n+//! codegen unit can get invalidated:\n+//!\n+//! 1. The most straightforward case is when the BODY of a function or global\n+//! changes. Then any codegen unit containing the code for that item has to be\n+//! re-compiled. Note that this includes all codegen units where the function\n+//! has been inlined.\n+//!\n+//! 2. The next case is when the SIGNATURE of a function or global changes. In\n+//! this case, all codegen units containing a REFERENCE to that item have to be\n+//! re-compiled. This is a superset of case 1.\n+//!\n+//! 3. The final and most subtle case is when a REFERENCE to a generic function\n+//! is added or removed somewhere. Even though the definition of the function\n+//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n+//! instance of this function which has to be placed and compiled somewhere.\n+//! Conversely, when removing a REFERENCE, it might have been the last one with\n+//! that particular set of generic arguments and thus we have to remove it.\n+//!\n+//! From the above we see that just using one codegen unit per source-level\n+//! module is not such a good idea, since just adding a REFERENCE to some\n+//! generic item somewhere else would invalidate everything within the module\n+//! containing the generic item. The heuristic above reduces this detrimental\n+//! side-effect of references a little by at least not touching the non-generic\n+//! code of the module.\n+//!\n+//! A Note on Inlining\n+//! ------------------\n+//! As briefly mentioned above, in order for LLVM to be able to inline a\n+//! function call, the body of the function has to be available in the LLVM\n+//! module where the call is made. This has a few consequences for partitioning:\n+//!\n+//! - The partitioning algorithm has to take care of placing functions into all\n+//!   codegen units where they should be available for inlining. It also has to\n+//!   decide on the correct linkage for these functions.\n+//!\n+//! - The partitioning algorithm has to know which functions are likely to get\n+//!   inlined, so it can distribute function instantiations accordingly. Since\n+//!   there is no way of knowing for sure which functions LLVM will decide to\n+//!   inline in the end, we apply a heuristic here: Only functions marked with\n+//!   `#[inline]` are considered for inlining by the partitioner. The current\n+//!   implementation will not try to determine if a function is likely to be\n+//!   inlined by looking at the functions definition.\n+//!\n+//! Note though that as a side-effect of creating a codegen units per\n+//! source-level module, functions from the same module will be available for\n+//! inlining, even when they are not marked `#[inline]`.\n+\n+use std::cmp;\n+use std::collections::hash_map::Entry;\n+use std::fs::{self, File};\n+use std::io::{BufWriter, Write};\n+use std::path::{Path, PathBuf};\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::definitions::DefPathDataName;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n+use rustc_middle::mir;\n+use rustc_middle::mir::mono::{\n+    CodegenUnit, CodegenUnitNameBuilder, InstantiationMode, Linkage, MonoItem, Visibility,\n+};\n+use rustc_middle::query::Providers;\n+use rustc_middle::ty::print::{characteristic_def_id_of_type, with_no_trimmed_paths};\n+use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n+use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n+use rustc_span::symbol::Symbol;\n+\n+use crate::collector::InliningMap;\n+use crate::collector::{self, MonoItemCollectionMode};\n+use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode};\n+\n+struct PartitioningCx<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    target_cgu_count: usize,\n+    inlining_map: &'a InliningMap<'tcx>,\n+}\n+\n+struct PlacedRootMonoItems<'tcx> {\n+    /// The codegen units, sorted by name to make things deterministic.\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+}\n+\n+// The output CGUs are sorted by name.\n+fn partition<'tcx, I>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_items: &mut I,\n+    max_cgu_count: usize,\n+    inlining_map: &InliningMap<'tcx>,\n+) -> Vec<CodegenUnit<'tcx>>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n+{\n+    let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n+\n+    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n+\n+    // In the first step, we place all regular monomorphizations into their\n+    // respective 'home' codegen unit. Regular monomorphizations are all\n+    // functions and statics defined in the local crate.\n+    let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n+        place_root_mono_items(cx, mono_items)\n+    };\n+\n+    for cgu in &mut codegen_units {\n+        cgu.create_size_estimate(tcx);\n+    }\n+\n+    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n+\n+    // Merge until we have at most `max_cgu_count` codegen units.\n+    // `merge_codegen_units` is responsible for updating the CGU size\n+    // estimates.\n+    {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n+        merge_codegen_units(cx, &mut codegen_units);\n+        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n+    }\n+\n+    // In the next step, we use the inlining map to determine which additional\n+    // monomorphizations have to go into each codegen unit. These additional\n+    // monomorphizations can be drop-glue, functions from external crates, and\n+    // local functions the definition of which is marked with `#[inline]`.\n+    let mono_item_placements = {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n+        place_inlined_mono_items(cx, &mut codegen_units, roots)\n+    };\n+\n+    for cgu in &mut codegen_units {\n+        cgu.create_size_estimate(tcx);\n+    }\n+\n+    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n+\n+    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n+    // more freedom to optimize.\n+    if !tcx.sess.link_dead_code() {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n+        internalize_symbols(\n+            cx,\n+            &mut codegen_units,\n+            mono_item_placements,\n+            internalization_candidates,\n+        );\n+    }\n+\n+    let instrument_dead_code =\n+        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n+\n+    if instrument_dead_code {\n+        assert!(\n+            codegen_units.len() > 0,\n+            \"There must be at least one CGU that code coverage data can be generated in.\"\n+        );\n+\n+        // Find the smallest CGU that has exported symbols and put the dead\n+        // function stubs in that CGU. We look for exported symbols to increase\n+        // the likelihood the linker won't throw away the dead functions.\n+        // FIXME(#92165): In order to truly resolve this, we need to make sure\n+        // the object file (CGU) containing the dead function stubs is included\n+        // in the final binary. This will probably require forcing these\n+        // function symbols to be included via `-u` or `/include` linker args.\n+        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n+        cgus.sort_by_key(|cgu| cgu.size_estimate());\n+\n+        let dead_code_cgu =\n+            if let Some(cgu) = cgus.into_iter().rev().find(|cgu| {\n+                cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External)\n+            }) {\n+                cgu\n+            } else {\n+                // If there are no CGUs that have externally linked items,\n+                // then we just pick the first CGU as a fallback.\n+                &mut codegen_units[0]\n+            };\n+        dead_code_cgu.make_code_coverage_dead_code_cgu();\n+    }\n+\n+    // Ensure CGUs are sorted by name, so that we get deterministic results.\n+    assert!(codegen_units.is_sorted_by(|a, b| Some(a.name().as_str().cmp(b.name().as_str()))));\n+\n+    debug_dump(tcx, \"FINAL\", &codegen_units);\n+\n+    codegen_units\n+}\n+\n+fn place_root_mono_items<'tcx, I>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    mono_items: &mut I,\n+) -> PlacedRootMonoItems<'tcx>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n+{\n+    let mut roots = FxHashSet::default();\n+    let mut codegen_units = FxHashMap::default();\n+    let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n+    let mut internalization_candidates = FxHashSet::default();\n+\n+    // Determine if monomorphizations instantiated in this crate will be made\n+    // available to downstream crates. This depends on whether we are in\n+    // share-generics mode and whether the current crate can even have\n+    // downstream crates.\n+    let export_generics =\n+        cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+    let cgu_name_cache = &mut FxHashMap::default();\n+\n+    for mono_item in mono_items {\n+        match mono_item.instantiation_mode(cx.tcx) {\n+            InstantiationMode::GloballyShared { .. } => {}\n+            InstantiationMode::LocalCopy => continue,\n+        }\n+\n+        let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n+        let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n+\n+        let codegen_unit_name = match characteristic_def_id {\n+            Some(def_id) => compute_codegen_unit_name(\n+                cx.tcx,\n+                cgu_name_builder,\n+                def_id,\n+                is_volatile,\n+                cgu_name_cache,\n+            ),\n+            None => fallback_cgu_name(cgu_name_builder),\n+        };\n+\n+        let codegen_unit = codegen_units\n+            .entry(codegen_unit_name)\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n+\n+        let mut can_be_internalized = true;\n+        let (linkage, visibility) = mono_item_linkage_and_visibility(\n+            cx.tcx,\n+            &mono_item,\n+            &mut can_be_internalized,\n+            export_generics,\n+        );\n+        if visibility == Visibility::Hidden && can_be_internalized {\n+            internalization_candidates.insert(mono_item);\n+        }\n+\n+        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n+        roots.insert(mono_item);\n+    }\n+\n+    // Always ensure we have at least one CGU; otherwise, if we have a\n+    // crate with just types (for example), we could wind up with no CGU.\n+    if codegen_units.is_empty() {\n+        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n+        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n+    }\n+\n+    let mut codegen_units: Vec<_> = codegen_units.into_values().collect();\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+    PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n+}\n+\n+// This function requires the CGUs to be sorted by name on input, and ensures\n+// they are sorted by name on return, for deterministic behaviour.\n+fn merge_codegen_units<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n+) {\n+    assert!(cx.target_cgu_count >= 1);\n+\n+    // A sorted order here ensures merging is deterministic.\n+    assert!(codegen_units.is_sorted_by(|a, b| Some(a.name().as_str().cmp(b.name().as_str()))));\n+\n+    // This map keeps track of what got merged into what.\n+    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n+\n+    // Merge the two smallest codegen units until the target size is\n+    // reached.\n+    while codegen_units.len() > cx.target_cgu_count {\n+        // Sort small cgus to the back\n+        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+        let mut smallest = codegen_units.pop().unwrap();\n+        let second_smallest = codegen_units.last_mut().unwrap();\n+\n+        // Move the mono-items from `smallest` to `second_smallest`\n+        second_smallest.modify_size_estimate(smallest.size_estimate());\n+        for (k, v) in smallest.items_mut().drain() {\n+            second_smallest.items_mut().insert(k, v);\n+        }\n+\n+        // Record that `second_smallest` now contains all the stuff that was\n+        // in `smallest` before.\n+        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+\n+        debug!(\n+            \"CodegenUnit {} merged into CodegenUnit {}\",\n+            smallest.name(),\n+            second_smallest.name()\n+        );\n+    }\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+\n+    if cx.tcx.sess.opts.incremental.is_some() {\n+        // If we are doing incremental compilation, we want CGU names to\n+        // reflect the path of the source level module they correspond to.\n+        // For CGUs that contain the code of multiple modules because of the\n+        // merging done above, we use a concatenation of the names of all\n+        // contained CGUs.\n+        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+            .into_iter()\n+            // This `filter` makes sure we only update the name of CGUs that\n+            // were actually modified by merging.\n+            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+            .map(|(current_cgu_name, cgu_contents)| {\n+                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n+\n+                // Sort the names, so things are deterministic and easy to\n+                // predict. We are sorting primitive `&str`s here so we can\n+                // use unstable sort.\n+                cgu_contents.sort_unstable();\n+\n+                (current_cgu_name, cgu_contents.join(\"--\"))\n+            })\n+            .collect();\n+\n+        for cgu in codegen_units.iter_mut() {\n+            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                } else {\n+                    // If we don't require CGU names to be human-readable,\n+                    // we use a fixed length hash of the composite CGU name\n+                    // instead.\n+                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                }\n+            }\n+        }\n+    } else {\n+        // If we are compiling non-incrementally we just generate simple CGU\n+        // names containing an index.\n+        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+            let numbered_codegen_unit_name =\n+                cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n+            cgu.set_name(numbered_codegen_unit_name);\n+        }\n+    }\n+\n+    // A sorted order here ensures what follows can be deterministic.\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+}\n+\n+/// For symbol internalization, we need to know whether a symbol/mono-item is\n+/// accessed from outside the codegen unit it is defined in. This type is used\n+/// to keep track of that.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum MonoItemPlacement {\n+    SingleCgu { cgu_name: Symbol },\n+    MultipleCgus,\n+}\n+\n+fn place_inlined_mono_items<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n+    let mut mono_item_placements = FxHashMap::default();\n+\n+    let single_codegen_unit = codegen_units.len() == 1;\n+\n+    for old_codegen_unit in codegen_units.iter_mut() {\n+        // Collect all items that need to be available in this codegen unit.\n+        let mut reachable = FxHashSet::default();\n+        for root in old_codegen_unit.items().keys() {\n+            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+        }\n+\n+        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n+\n+        // Add all monomorphizations that are not already there.\n+        for mono_item in reachable {\n+            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n+                // This is a root, just copy it over.\n+                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n+            } else {\n+                if roots.contains(&mono_item) {\n+                    bug!(\n+                        \"GloballyShared mono-item inlined into other CGU: \\\n+                          {:?}\",\n+                        mono_item\n+                    );\n+                }\n+\n+                // This is a CGU-private copy.\n+                new_codegen_unit\n+                    .items_mut()\n+                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+            }\n+\n+            if !single_codegen_unit {\n+                // If there is more than one codegen unit, we need to keep track\n+                // in which codegen units each monomorphization is placed.\n+                match mono_item_placements.entry(mono_item) {\n+                    Entry::Occupied(e) => {\n+                        let placement = e.into_mut();\n+                        debug_assert!(match *placement {\n+                            MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                cgu_name != new_codegen_unit.name()\n+                            }\n+                            MonoItemPlacement::MultipleCgus => true,\n+                        });\n+                        *placement = MonoItemPlacement::MultipleCgus;\n+                    }\n+                    Entry::Vacant(e) => {\n+                        e.insert(MonoItemPlacement::SingleCgu {\n+                            cgu_name: new_codegen_unit.name(),\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+\n+        *old_codegen_unit = new_codegen_unit;\n+    }\n+\n+    return mono_item_placements;\n+\n+    fn follow_inlining<'tcx>(\n+        mono_item: MonoItem<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+        visited: &mut FxHashSet<MonoItem<'tcx>>,\n+    ) {\n+        if !visited.insert(mono_item) {\n+            return;\n+        }\n+\n+        inlining_map.with_inlining_candidates(mono_item, |target| {\n+            follow_inlining(target, inlining_map, visited);\n+        });\n+    }\n+}\n+\n+fn internalize_symbols<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+) {\n+    if codegen_units.len() == 1 {\n+        // Fast path for when there is only one codegen unit. In this case we\n+        // can internalize all candidates, since there is nowhere else they\n+        // could be accessed from.\n+        for cgu in codegen_units {\n+            for candidate in &internalization_candidates {\n+                cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    // Build a map from every monomorphization to all the monomorphizations that\n+    // reference it.\n+    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n+    cx.inlining_map.iter_accesses(|accessor, accessees| {\n+        for accessee in accessees {\n+            accessor_map.entry(*accessee).or_default().push(accessor);\n+        }\n+    });\n+\n+    // For each internalization candidates in each codegen unit, check if it is\n+    // accessed from outside its defining codegen unit.\n+    for cgu in codegen_units {\n+        let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+\n+        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n+            if !internalization_candidates.contains(accessee) {\n+                // This item is no candidate for internalizing, so skip it.\n+                continue;\n+            }\n+            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+\n+            if let Some(accessors) = accessor_map.get(accessee) {\n+                if accessors\n+                    .iter()\n+                    .filter_map(|accessor| {\n+                        // Some accessors might not have been\n+                        // instantiated. We can safely ignore those.\n+                        mono_item_placements.get(accessor)\n+                    })\n+                    .any(|placement| *placement != home_cgu)\n+                {\n+                    // Found an accessor from another CGU, so skip to the next\n+                    // item without marking this one as internal.\n+                    continue;\n+                }\n+            }\n+\n+            // If we got here, we did not find any accesses from other CGUs,\n+            // so it's fine to make this monomorphization internal.\n+            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n+        }\n+    }\n+}\n+\n+fn characteristic_def_id_of_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: MonoItem<'tcx>,\n+) -> Option<DefId> {\n+    match mono_item {\n+        MonoItem::Fn(instance) => {\n+            let def_id = match instance.def {\n+                ty::InstanceDef::Item(def) => def,\n+                ty::InstanceDef::VTableShim(..)\n+                | ty::InstanceDef::ReifyShim(..)\n+                | ty::InstanceDef::FnPtrShim(..)\n+                | ty::InstanceDef::ClosureOnceShim { .. }\n+                | ty::InstanceDef::Intrinsic(..)\n+                | ty::InstanceDef::DropGlue(..)\n+                | ty::InstanceDef::Virtual(..)\n+                | ty::InstanceDef::CloneShim(..)\n+                | ty::InstanceDef::ThreadLocalShim(..)\n+                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n+            };\n+\n+            // If this is a method, we want to put it into the same module as\n+            // its self-type. If the self-type does not provide a characteristic\n+            // DefId, we use the location of the impl after all.\n+\n+            if tcx.trait_of_item(def_id).is_some() {\n+                let self_ty = instance.substs.type_at(0);\n+                // This is a default implementation of a trait method.\n+                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n+            }\n+\n+            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n+                if tcx.sess.opts.incremental.is_some()\n+                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n+                {\n+                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n+                    // since `drop_in_place` is the only thing that can\n+                    // call it.\n+                    return None;\n+                }\n+\n+                // When polymorphization is enabled, methods which do not depend on their generic\n+                // parameters, but the self-type of their impl block do will fail to normalize.\n+                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n+                    // This is a method within an impl, find out what the self-type is:\n+                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n+                        instance.substs,\n+                        ty::ParamEnv::reveal_all(),\n+                        tcx.type_of(impl_def_id),\n+                    );\n+                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n+                        return Some(def_id);\n+                    }\n+                }\n+            }\n+\n+            Some(def_id)\n+        }\n+        MonoItem::Static(def_id) => Some(def_id),\n+        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n+    }\n+}\n+\n+fn compute_codegen_unit_name(\n+    tcx: TyCtxt<'_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_>,\n+    def_id: DefId,\n+    volatile: bool,\n+    cache: &mut CguNameCache,\n+) -> Symbol {\n+    // Find the innermost module that is not nested within a function.\n+    let mut current_def_id = def_id;\n+    let mut cgu_def_id = None;\n+    // Walk backwards from the item we want to find the module for.\n+    loop {\n+        if current_def_id.is_crate_root() {\n+            if cgu_def_id.is_none() {\n+                // If we have not found a module yet, take the crate root.\n+                cgu_def_id = Some(def_id.krate.as_def_id());\n+            }\n+            break;\n+        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n+            if cgu_def_id.is_none() {\n+                cgu_def_id = Some(current_def_id);\n+            }\n+        } else {\n+            // If we encounter something that is not a module, throw away\n+            // any module that we've found so far because we now know that\n+            // it is nested within something else.\n+            cgu_def_id = None;\n+        }\n+\n+        current_def_id = tcx.parent(current_def_id);\n+    }\n+\n+    let cgu_def_id = cgu_def_id.unwrap();\n+\n+    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n+        let def_path = tcx.def_path(cgu_def_id);\n+\n+        let components = def_path.data.iter().map(|part| match part.data.name() {\n+            DefPathDataName::Named(name) => name,\n+            DefPathDataName::Anon { .. } => unreachable!(),\n+        });\n+\n+        let volatile_suffix = volatile.then_some(\"volatile\");\n+\n+        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n+    })\n+}\n+\n+// Anything we can't find a proper codegen unit for goes into this.\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n+    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n+}\n+\n+fn mono_item_linkage_and_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> (Linkage, Visibility) {\n+    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n+        return (explicit_linkage, Visibility::Default);\n+    }\n+    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n+    (Linkage::External, vis)\n+}\n+\n+type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n+\n+fn static_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    can_be_internalized: &mut bool,\n+    def_id: DefId,\n+) -> Visibility {\n+    if tcx.is_reachable_non_generic(def_id) {\n+        *can_be_internalized = false;\n+        default_visibility(tcx, def_id, false)\n+    } else {\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn mono_item_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> Visibility {\n+    let instance = match mono_item {\n+        // This is pretty complicated; see below.\n+        MonoItem::Fn(instance) => instance,\n+\n+        // Misc handling for generics and such, but otherwise:\n+        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n+        MonoItem::GlobalAsm(item_id) => {\n+            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n+        }\n+    };\n+\n+    let def_id = match instance.def {\n+        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n+\n+        // We match the visibility of statics here\n+        InstanceDef::ThreadLocalShim(def_id) => {\n+            return static_visibility(tcx, can_be_internalized, def_id);\n+        }\n+\n+        // These are all compiler glue and such, never exported, always hidden.\n+        InstanceDef::VTableShim(..)\n+        | InstanceDef::ReifyShim(..)\n+        | InstanceDef::FnPtrShim(..)\n+        | InstanceDef::Virtual(..)\n+        | InstanceDef::Intrinsic(..)\n+        | InstanceDef::ClosureOnceShim { .. }\n+        | InstanceDef::DropGlue(..)\n+        | InstanceDef::CloneShim(..)\n+        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n+    };\n+\n+    // The `start_fn` lang item is actually a monomorphized instance of a\n+    // function in the standard library, used for the `main` function. We don't\n+    // want to export it so we tag it with `Hidden` visibility but this symbol\n+    // is only referenced from the actual `main` symbol which we unfortunately\n+    // don't know anything about during partitioning/collection. As a result we\n+    // forcibly keep this symbol out of the `internalization_candidates` set.\n+    //\n+    // FIXME: eventually we don't want to always force this symbol to have\n+    //        hidden visibility, it should indeed be a candidate for\n+    //        internalization, but we have to understand that it's referenced\n+    //        from the `main` symbol we'll generate later.\n+    //\n+    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n+    if tcx.lang_items().start_fn() == Some(def_id) {\n+        *can_be_internalized = false;\n+        return Visibility::Hidden;\n+    }\n+\n+    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+    // Upstream `DefId` instances get different handling than local ones.\n+    let Some(def_id) = def_id.as_local() else {\n+        return if export_generics && is_generic {\n+            // If it is an upstream monomorphization and we export generics, we must make\n+            // it available to downstream crates.\n+            *can_be_internalized = false;\n+            default_visibility(tcx, def_id, true)\n+        } else {\n+            Visibility::Hidden\n+        };\n+    };\n+\n+    if is_generic {\n+        if export_generics {\n+            if tcx.is_unreachable_local_definition(def_id) {\n+                // This instance cannot be used from another crate.\n+                Visibility::Hidden\n+            } else {\n+                // This instance might be useful in a downstream crate.\n+                *can_be_internalized = false;\n+                default_visibility(tcx, def_id.to_def_id(), true)\n+            }\n+        } else {\n+            // We are not exporting generics or the definition is not reachable\n+            // for downstream crates, we can internalize its instantiations.\n+            Visibility::Hidden\n+        }\n+    } else {\n+        // If this isn't a generic function then we mark this a `Default` if\n+        // this is a reachable item, meaning that it's a symbol other crates may\n+        // access when they link to us.\n+        if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n+            *can_be_internalized = false;\n+            debug_assert!(!is_generic);\n+            return default_visibility(tcx, def_id.to_def_id(), false);\n+        }\n+\n+        // If this isn't reachable then we're gonna tag this with `Hidden`\n+        // visibility. In some situations though we'll want to prevent this\n+        // symbol from being internalized.\n+        //\n+        // There's two categories of items here:\n+        //\n+        // * First is weak lang items. These are basically mechanisms for\n+        //   libcore to forward-reference symbols defined later in crates like\n+        //   the standard library or `#[panic_handler]` definitions. The\n+        //   definition of these weak lang items needs to be referencable by\n+        //   libcore, so we're no longer a candidate for internalization.\n+        //   Removal of these functions can't be done by LLVM but rather must be\n+        //   done by the linker as it's a non-local decision.\n+        //\n+        // * Second is \"std internal symbols\". Currently this is primarily used\n+        //   for allocator symbols. Allocators are a little weird in their\n+        //   implementation, but the idea is that the compiler, at the last\n+        //   minute, defines an allocator with an injected object file. The\n+        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n+        //   definition doesn't get hooked up until a linked crate artifact is\n+        //   generated.\n+        //\n+        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n+        //   veneers around the actual implementation, some other symbol which\n+        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n+        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n+        //   internal symbols\".\n+        //\n+        //   The std-internal symbols here **should not show up in a dll as an\n+        //   exported interface**, so they return `false` from\n+        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n+        //   visibility below. Like the weak lang items, though, we can't let\n+        //   LLVM internalize them as this decision is left up to the linker to\n+        //   omit them, so prevent them from being internalized.\n+        let attrs = tcx.codegen_fn_attrs(def_id);\n+        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n+            *can_be_internalized = false;\n+        }\n+\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n+    if !tcx.sess.target.default_hidden_visibility {\n+        return Visibility::Default;\n+    }\n+\n+    // Generic functions never have export-level C.\n+    if is_generic {\n+        return Visibility::Hidden;\n+    }\n+\n+    // Things with export level C don't get instantiated in\n+    // downstream crates.\n+    if !id.is_local() {\n+        return Visibility::Hidden;\n+    }\n+\n+    // C-export level items remain at `Default`, all other internal\n+    // items become `Hidden`.\n+    match tcx.reachable_non_generics(id.krate).get(&id) {\n+        Some(SymbolExportInfo { level: SymbolExportLevel::C, .. }) => Visibility::Default,\n+        _ => Visibility::Hidden,\n+    }\n+}\n+\n+fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n+    let dump = move || {\n+        use std::fmt::Write;\n+\n+        let num_cgus = cgus.len();\n+        let num_items: usize = cgus.iter().map(|cgu| cgu.items().len()).sum();\n+        let total_size: usize = cgus.iter().map(|cgu| cgu.size_estimate()).sum();\n+        let max_size = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n+        let min_size = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n+        let max_min_size_ratio = max_size as f64 / min_size as f64;\n+\n+        let s = &mut String::new();\n+        let _ = writeln!(\n+            s,\n+            \"{label} ({num_items} items, total_size={total_size}; {num_cgus} CGUs, \\\n+             max_size={max_size}, min_size={min_size}, max_size/min_size={max_min_size_ratio:.1}):\"\n+        );\n+        for (i, cgu) in cgus.iter().enumerate() {\n+            let num_items = cgu.items().len();\n+            let _ = writeln!(\n+                s,\n+                \"- CGU[{i}] {} ({num_items} items, size={}):\",\n+                cgu.name(),\n+                cgu.size_estimate()\n+            );\n+\n+            // The order of `cgu.items()` is non-deterministic; sort it by name\n+            // to give deterministic output.\n+            let mut items: Vec<_> = cgu.items().iter().collect();\n+            items.sort_by_key(|(item, _)| item.symbol_name(tcx).name);\n+            for (item, linkage) in items {\n+                let symbol_name = item.symbol_name(tcx).name;\n+                let symbol_hash_start = symbol_name.rfind('h');\n+                let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n+\n+                let size = item.size_estimate(tcx);\n+                let _ = with_no_trimmed_paths!(writeln!(\n+                    s,\n+                    \"  - {item} [{linkage:?}] [{symbol_hash}] (size={size})\"\n+                ));\n+            }\n+\n+            let _ = writeln!(s);\n+        }\n+\n+        std::mem::take(s)\n+    };\n+\n+    debug!(\"{}\", dump());\n+}\n+\n+#[inline(never)] // give this a place in the profiler\n+fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n+where\n+    I: Iterator<Item = &'a MonoItem<'tcx>>,\n+    'tcx: 'a,\n+{\n+    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n+\n+    let mut symbols: Vec<_> =\n+        mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n+\n+    symbols.sort_by_key(|sym| sym.1);\n+\n+    for &[(mono_item1, ref sym1), (mono_item2, ref sym2)] in symbols.array_windows() {\n+        if sym1 == sym2 {\n+            let span1 = mono_item1.local_span(tcx);\n+            let span2 = mono_item2.local_span(tcx);\n+\n+            // Deterministically select one of the spans for error reporting\n+            let span = match (span1, span2) {\n+                (Some(span1), Some(span2)) => {\n+                    Some(if span1.lo().0 > span2.lo().0 { span1 } else { span2 })\n+                }\n+                (span1, span2) => span1.or(span2),\n+            };\n+\n+            tcx.sess.emit_fatal(SymbolAlreadyDefined { span, symbol: sym1.to_string() });\n+        }\n+    }\n+}\n+\n+fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n+    let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n+        Some(ref s) => {\n+            let mode = s.to_lowercase();\n+            let mode = mode.trim();\n+            if mode == \"eager\" {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                if mode != \"lazy\" {\n+                    tcx.sess.emit_warning(UnknownCguCollectionMode { mode });\n+                }\n+\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+        None => {\n+            if tcx.sess.link_dead_code() {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+    };\n+\n+    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n+\n+    tcx.sess.abort_if_errors();\n+\n+    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n+        sync::join(\n+            || {\n+                let mut codegen_units = partition(\n+                    tcx,\n+                    &mut items.iter().copied(),\n+                    tcx.sess.codegen_units(),\n+                    &inlining_map,\n+                );\n+                codegen_units[0].make_primary();\n+                &*tcx.arena.alloc_from_iter(codegen_units)\n+            },\n+            || assert_symbols_are_distinct(tcx, items.iter()),\n+        )\n+    });\n+\n+    if tcx.prof.enabled() {\n+        // Record CGU size estimates for self-profiling.\n+        for cgu in codegen_units {\n+            tcx.prof.artifact_size(\n+                \"codegen_unit_size_estimate\",\n+                cgu.name().as_str(),\n+                cgu.size_estimate() as u64,\n+            );\n+        }\n+    }\n+\n+    let mono_items: DefIdSet = items\n+        .iter()\n+        .filter_map(|mono_item| match *mono_item {\n+            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Static(def_id) => Some(def_id),\n+            _ => None,\n+        })\n+        .collect();\n+\n+    // Output monomorphization stats per def_id\n+    if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n+        if let Err(err) =\n+            dump_mono_items_stats(tcx, &codegen_units, path, tcx.crate_name(LOCAL_CRATE))\n+        {\n+            tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n+        }\n+    }\n+\n+    if tcx.sess.opts.unstable_opts.print_mono_items.is_some() {\n+        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n+\n+        for cgu in codegen_units {\n+            for (&mono_item, &linkage) in cgu.items() {\n+                item_to_cgus.entry(mono_item).or_default().push((cgu.name(), linkage));\n+            }\n+        }\n+\n+        let mut item_keys: Vec<_> = items\n+            .iter()\n+            .map(|i| {\n+                let mut output = with_no_trimmed_paths!(i.to_string());\n+                output.push_str(\" @@\");\n+                let mut empty = Vec::new();\n+                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n+                cgus.sort_by_key(|(name, _)| *name);\n+                cgus.dedup();\n+                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n+                    output.push(' ');\n+                    output.push_str(cgu_name.as_str());\n+\n+                    let linkage_abbrev = match linkage {\n+                        Linkage::External => \"External\",\n+                        Linkage::AvailableExternally => \"Available\",\n+                        Linkage::LinkOnceAny => \"OnceAny\",\n+                        Linkage::LinkOnceODR => \"OnceODR\",\n+                        Linkage::WeakAny => \"WeakAny\",\n+                        Linkage::WeakODR => \"WeakODR\",\n+                        Linkage::Appending => \"Appending\",\n+                        Linkage::Internal => \"Internal\",\n+                        Linkage::Private => \"Private\",\n+                        Linkage::ExternalWeak => \"ExternalWeak\",\n+                        Linkage::Common => \"Common\",\n+                    };\n+\n+                    output.push('[');\n+                    output.push_str(linkage_abbrev);\n+                    output.push(']');\n+                }\n+                output\n+            })\n+            .collect();\n+\n+        item_keys.sort();\n+\n+        for item in item_keys {\n+            println!(\"MONO_ITEM {item}\");\n+        }\n+    }\n+\n+    (tcx.arena.alloc(mono_items), codegen_units)\n+}\n+\n+/// Outputs stats about instantiation counts and estimated size, per `MonoItem`'s\n+/// def, to a file in the given output directory.\n+fn dump_mono_items_stats<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    codegen_units: &[CodegenUnit<'tcx>],\n+    output_directory: &Option<PathBuf>,\n+    crate_name: Symbol,\n+) -> Result<(), Box<dyn std::error::Error>> {\n+    let output_directory = if let Some(ref directory) = output_directory {\n+        fs::create_dir_all(directory)?;\n+        directory\n+    } else {\n+        Path::new(\".\")\n+    };\n+\n+    let format = tcx.sess.opts.unstable_opts.dump_mono_stats_format;\n+    let ext = format.extension();\n+    let filename = format!(\"{crate_name}.mono_items.{ext}\");\n+    let output_path = output_directory.join(&filename);\n+    let file = File::create(&output_path)?;\n+    let mut file = BufWriter::new(file);\n+\n+    // Gather instantiated mono items grouped by def_id\n+    let mut items_per_def_id: FxHashMap<_, Vec<_>> = Default::default();\n+    for cgu in codegen_units {\n+        for (&mono_item, _) in cgu.items() {\n+            // Avoid variable-sized compiler-generated shims\n+            if mono_item.is_user_defined() {\n+                items_per_def_id.entry(mono_item.def_id()).or_default().push(mono_item);\n+            }\n+        }\n+    }\n+\n+    #[derive(serde::Serialize)]\n+    struct MonoItem {\n+        name: String,\n+        instantiation_count: usize,\n+        size_estimate: usize,\n+        total_estimate: usize,\n+    }\n+\n+    // Output stats sorted by total instantiated size, from heaviest to lightest\n+    let mut stats: Vec<_> = items_per_def_id\n+        .into_iter()\n+        .map(|(def_id, items)| {\n+            let name = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n+            let instantiation_count = items.len();\n+            let size_estimate = items[0].size_estimate(tcx);\n+            let total_estimate = instantiation_count * size_estimate;\n+            MonoItem { name, instantiation_count, size_estimate, total_estimate }\n+        })\n+        .collect();\n+    stats.sort_unstable_by_key(|item| cmp::Reverse(item.total_estimate));\n+\n+    if !stats.is_empty() {\n+        match format {\n+            DumpMonoStatsFormat::Json => serde_json::to_writer(file, &stats)?,\n+            DumpMonoStatsFormat::Markdown => {\n+                writeln!(\n+                    file,\n+                    \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n+                )?;\n+                writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n+\n+                for MonoItem { name, instantiation_count, size_estimate, total_estimate } in stats {\n+                    writeln!(\n+                        file,\n+                        \"| `{name}` | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n+                    )?;\n+                }\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn codegened_and_inlined_items(tcx: TyCtxt<'_>, (): ()) -> &DefIdSet {\n+    let (items, cgus) = tcx.collect_and_partition_mono_items(());\n+    let mut visited = DefIdSet::default();\n+    let mut result = items.clone();\n+\n+    for cgu in cgus {\n+        for (item, _) in cgu.items() {\n+            if let MonoItem::Fn(ref instance) = item {\n+                let did = instance.def_id();\n+                if !visited.insert(did) {\n+                    continue;\n+                }\n+                let body = tcx.instance_mir(instance.def);\n+                for block in body.basic_blocks.iter() {\n+                    for statement in &block.statements {\n+                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n+                        let scope = statement.source_info.scope;\n+                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n+                            result.insert(inlined.def_id());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    tcx.arena.alloc(result)\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.collect_and_partition_mono_items = collect_and_partition_mono_items;\n+    providers.codegened_and_inlined_items = codegened_and_inlined_items;\n+\n+    providers.is_codegened_item = |tcx, def_id| {\n+        let (all_mono_items, _) = tcx.collect_and_partition_mono_items(());\n+        all_mono_items.contains(&def_id)\n+    };\n+\n+    providers.codegen_unit = |tcx, name| {\n+        let (_, all) = tcx.collect_and_partition_mono_items(());\n+        all.iter()\n+            .find(|cgu| cgu.name() == name)\n+            .unwrap_or_else(|| panic!(\"failed to find cgu with name {name:?}\"))\n+    };\n+}"}, {"sha": "603b3ddc106e931ea2864506243a43b35fd9e819", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "removed", "additions": 0, "deletions": 644, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/1ac91624d13624c164800fcd28cb234149ce0f5a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac91624d13624c164800fcd28cb234149ce0f5a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=1ac91624d13624c164800fcd28cb234149ce0f5a", "patch": "@@ -1,644 +0,0 @@\n-use std::cmp;\n-use std::collections::hash_map::Entry;\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::definitions::DefPathDataName;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n-use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, Linkage, Visibility};\n-use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n-use rustc_middle::ty::print::characteristic_def_id_of_type;\n-use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-\n-use super::PartitioningCx;\n-use crate::collector::InliningMap;\n-use crate::partitioning::{MonoItemPlacement, Partition, PlacedRootMonoItems};\n-\n-pub struct DefaultPartitioning;\n-\n-impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>,\n-    {\n-        let mut roots = FxHashSet::default();\n-        let mut codegen_units = FxHashMap::default();\n-        let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n-        let mut internalization_candidates = FxHashSet::default();\n-\n-        // Determine if monomorphizations instantiated in this crate will be made\n-        // available to downstream crates. This depends on whether we are in\n-        // share-generics mode and whether the current crate can even have\n-        // downstream crates.\n-        let export_generics =\n-            cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n-\n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-        let cgu_name_cache = &mut FxHashMap::default();\n-\n-        for mono_item in mono_items {\n-            match mono_item.instantiation_mode(cx.tcx) {\n-                InstantiationMode::GloballyShared { .. } => {}\n-                InstantiationMode::LocalCopy => continue,\n-            }\n-\n-            let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n-            let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n-\n-            let codegen_unit_name = match characteristic_def_id {\n-                Some(def_id) => compute_codegen_unit_name(\n-                    cx.tcx,\n-                    cgu_name_builder,\n-                    def_id,\n-                    is_volatile,\n-                    cgu_name_cache,\n-                ),\n-                None => fallback_cgu_name(cgu_name_builder),\n-            };\n-\n-            let codegen_unit = codegen_units\n-                .entry(codegen_unit_name)\n-                .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n-\n-            let mut can_be_internalized = true;\n-            let (linkage, visibility) = mono_item_linkage_and_visibility(\n-                cx.tcx,\n-                &mono_item,\n-                &mut can_be_internalized,\n-                export_generics,\n-            );\n-            if visibility == Visibility::Hidden && can_be_internalized {\n-                internalization_candidates.insert(mono_item);\n-            }\n-\n-            codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n-            roots.insert(mono_item);\n-        }\n-\n-        // Always ensure we have at least one CGU; otherwise, if we have a\n-        // crate with just types (for example), we could wind up with no CGU.\n-        if codegen_units.is_empty() {\n-            let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-            codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n-        }\n-\n-        let codegen_units = codegen_units.into_values().collect();\n-        PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n-    }\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    ) {\n-        assert!(cx.target_cgu_count >= 1);\n-\n-        // Note that at this point in time the `codegen_units` here may not be\n-        // in a deterministic order (but we know they're deterministically the\n-        // same set). We want this merging to produce a deterministic ordering\n-        // of codegen units from the input.\n-        //\n-        // Due to basically how we've implemented the merging below (merge the\n-        // two smallest into each other) we're sure to start off with a\n-        // deterministic order (sorted by name). This'll mean that if two cgus\n-        // have the same size the stable sort below will keep everything nice\n-        // and deterministic.\n-        codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-        // This map keeps track of what got merged into what.\n-        let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n-            codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n-\n-        // Merge the two smallest codegen units until the target size is\n-        // reached.\n-        while codegen_units.len() > cx.target_cgu_count {\n-            // Sort small cgus to the back\n-            codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-            let mut smallest = codegen_units.pop().unwrap();\n-            let second_smallest = codegen_units.last_mut().unwrap();\n-\n-            // Move the mono-items from `smallest` to `second_smallest`\n-            second_smallest.modify_size_estimate(smallest.size_estimate());\n-            for (k, v) in smallest.items_mut().drain() {\n-                second_smallest.items_mut().insert(k, v);\n-            }\n-\n-            // Record that `second_smallest` now contains all the stuff that was\n-            // in `smallest` before.\n-            let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-            cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n-\n-            debug!(\n-                \"CodegenUnit {} merged into CodegenUnit {}\",\n-                smallest.name(),\n-                second_smallest.name()\n-            );\n-        }\n-\n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-\n-        if cx.tcx.sess.opts.incremental.is_some() {\n-            // If we are doing incremental compilation, we want CGU names to\n-            // reflect the path of the source level module they correspond to.\n-            // For CGUs that contain the code of multiple modules because of the\n-            // merging done above, we use a concatenation of the names of all\n-            // contained CGUs.\n-            let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-                .into_iter()\n-                // This `filter` makes sure we only update the name of CGUs that\n-                // were actually modified by merging.\n-                .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-                .map(|(current_cgu_name, cgu_contents)| {\n-                    let mut cgu_contents: Vec<&str> =\n-                        cgu_contents.iter().map(|s| s.as_str()).collect();\n-\n-                    // Sort the names, so things are deterministic and easy to\n-                    // predict. We are sorting primitive `&str`s here so we can\n-                    // use unstable sort.\n-                    cgu_contents.sort_unstable();\n-\n-                    (current_cgu_name, cgu_contents.join(\"--\"))\n-                })\n-                .collect();\n-\n-            for cgu in codegen_units.iter_mut() {\n-                if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                    if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n-                        cgu.set_name(Symbol::intern(&new_cgu_name));\n-                    } else {\n-                        // If we don't require CGU names to be human-readable,\n-                        // we use a fixed length hash of the composite CGU name\n-                        // instead.\n-                        let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                        cgu.set_name(Symbol::intern(&new_cgu_name));\n-                    }\n-                }\n-            }\n-        } else {\n-            // If we are compiling non-incrementally we just generate simple CGU\n-            // names containing an index.\n-            for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-                let numbered_codegen_unit_name =\n-                    cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n-                cgu.set_name(numbered_codegen_unit_name);\n-            }\n-        }\n-    }\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-        let mut mono_item_placements = FxHashMap::default();\n-\n-        let single_codegen_unit = codegen_units.len() == 1;\n-\n-        for old_codegen_unit in codegen_units.iter_mut() {\n-            // Collect all items that need to be available in this codegen unit.\n-            let mut reachable = FxHashSet::default();\n-            for root in old_codegen_unit.items().keys() {\n-                follow_inlining(*root, cx.inlining_map, &mut reachable);\n-            }\n-\n-            let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n-\n-            // Add all monomorphizations that are not already there.\n-            for mono_item in reachable {\n-                if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                    // This is a root, just copy it over.\n-                    new_codegen_unit.items_mut().insert(mono_item, *linkage);\n-                } else {\n-                    if roots.contains(&mono_item) {\n-                        bug!(\n-                            \"GloballyShared mono-item inlined into other CGU: \\\n-                              {:?}\",\n-                            mono_item\n-                        );\n-                    }\n-\n-                    // This is a CGU-private copy.\n-                    new_codegen_unit\n-                        .items_mut()\n-                        .insert(mono_item, (Linkage::Internal, Visibility::Default));\n-                }\n-\n-                if !single_codegen_unit {\n-                    // If there is more than one codegen unit, we need to keep track\n-                    // in which codegen units each monomorphization is placed.\n-                    match mono_item_placements.entry(mono_item) {\n-                        Entry::Occupied(e) => {\n-                            let placement = e.into_mut();\n-                            debug_assert!(match *placement {\n-                                MonoItemPlacement::SingleCgu { cgu_name } => {\n-                                    cgu_name != new_codegen_unit.name()\n-                                }\n-                                MonoItemPlacement::MultipleCgus => true,\n-                            });\n-                            *placement = MonoItemPlacement::MultipleCgus;\n-                        }\n-                        Entry::Vacant(e) => {\n-                            e.insert(MonoItemPlacement::SingleCgu {\n-                                cgu_name: new_codegen_unit.name(),\n-                            });\n-                        }\n-                    }\n-                }\n-            }\n-\n-            *old_codegen_unit = new_codegen_unit;\n-        }\n-\n-        return mono_item_placements;\n-\n-        fn follow_inlining<'tcx>(\n-            mono_item: MonoItem<'tcx>,\n-            inlining_map: &InliningMap<'tcx>,\n-            visited: &mut FxHashSet<MonoItem<'tcx>>,\n-        ) {\n-            if !visited.insert(mono_item) {\n-                return;\n-            }\n-\n-            inlining_map.with_inlining_candidates(mono_item, |target| {\n-                follow_inlining(target, inlining_map, visited);\n-            });\n-        }\n-    }\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        if codegen_units.len() == 1 {\n-            // Fast path for when there is only one codegen unit. In this case we\n-            // can internalize all candidates, since there is nowhere else they\n-            // could be accessed from.\n-            for cgu in codegen_units {\n-                for candidate in &internalization_candidates {\n-                    cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n-                }\n-            }\n-\n-            return;\n-        }\n-\n-        // Build a map from every monomorphization to all the monomorphizations that\n-        // reference it.\n-        let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-        cx.inlining_map.iter_accesses(|accessor, accessees| {\n-            for accessee in accessees {\n-                accessor_map.entry(*accessee).or_default().push(accessor);\n-            }\n-        });\n-\n-        // For each internalization candidates in each codegen unit, check if it is\n-        // accessed from outside its defining codegen unit.\n-        for cgu in codegen_units {\n-            let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n-\n-            for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-                if !internalization_candidates.contains(accessee) {\n-                    // This item is no candidate for internalizing, so skip it.\n-                    continue;\n-                }\n-                debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n-\n-                if let Some(accessors) = accessor_map.get(accessee) {\n-                    if accessors\n-                        .iter()\n-                        .filter_map(|accessor| {\n-                            // Some accessors might not have been\n-                            // instantiated. We can safely ignore those.\n-                            mono_item_placements.get(accessor)\n-                        })\n-                        .any(|placement| *placement != home_cgu)\n-                    {\n-                        // Found an accessor from another CGU, so skip to the next\n-                        // item without marking this one as internal.\n-                        continue;\n-                    }\n-                }\n-\n-                // If we got here, we did not find any accesses from other CGUs,\n-                // so it's fine to make this monomorphization internal.\n-                *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n-            }\n-        }\n-    }\n-}\n-\n-fn characteristic_def_id_of_mono_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: MonoItem<'tcx>,\n-) -> Option<DefId> {\n-    match mono_item {\n-        MonoItem::Fn(instance) => {\n-            let def_id = match instance.def {\n-                ty::InstanceDef::Item(def) => def,\n-                ty::InstanceDef::VTableShim(..)\n-                | ty::InstanceDef::ReifyShim(..)\n-                | ty::InstanceDef::FnPtrShim(..)\n-                | ty::InstanceDef::ClosureOnceShim { .. }\n-                | ty::InstanceDef::Intrinsic(..)\n-                | ty::InstanceDef::DropGlue(..)\n-                | ty::InstanceDef::Virtual(..)\n-                | ty::InstanceDef::CloneShim(..)\n-                | ty::InstanceDef::ThreadLocalShim(..)\n-                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n-            };\n-\n-            // If this is a method, we want to put it into the same module as\n-            // its self-type. If the self-type does not provide a characteristic\n-            // DefId, we use the location of the impl after all.\n-\n-            if tcx.trait_of_item(def_id).is_some() {\n-                let self_ty = instance.substs.type_at(0);\n-                // This is a default implementation of a trait method.\n-                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n-            }\n-\n-            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-                if tcx.sess.opts.incremental.is_some()\n-                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n-                {\n-                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n-                    // since `drop_in_place` is the only thing that can\n-                    // call it.\n-                    return None;\n-                }\n-\n-                // When polymorphization is enabled, methods which do not depend on their generic\n-                // parameters, but the self-type of their impl block do will fail to normalize.\n-                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n-                    // This is a method within an impl, find out what the self-type is:\n-                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n-                        instance.substs,\n-                        ty::ParamEnv::reveal_all(),\n-                        tcx.type_of(impl_def_id),\n-                    );\n-                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n-                        return Some(def_id);\n-                    }\n-                }\n-            }\n-\n-            Some(def_id)\n-        }\n-        MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n-    }\n-}\n-\n-fn compute_codegen_unit_name(\n-    tcx: TyCtxt<'_>,\n-    name_builder: &mut CodegenUnitNameBuilder<'_>,\n-    def_id: DefId,\n-    volatile: bool,\n-    cache: &mut CguNameCache,\n-) -> Symbol {\n-    // Find the innermost module that is not nested within a function.\n-    let mut current_def_id = def_id;\n-    let mut cgu_def_id = None;\n-    // Walk backwards from the item we want to find the module for.\n-    loop {\n-        if current_def_id.is_crate_root() {\n-            if cgu_def_id.is_none() {\n-                // If we have not found a module yet, take the crate root.\n-                cgu_def_id = Some(def_id.krate.as_def_id());\n-            }\n-            break;\n-        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n-            if cgu_def_id.is_none() {\n-                cgu_def_id = Some(current_def_id);\n-            }\n-        } else {\n-            // If we encounter something that is not a module, throw away\n-            // any module that we've found so far because we now know that\n-            // it is nested within something else.\n-            cgu_def_id = None;\n-        }\n-\n-        current_def_id = tcx.parent(current_def_id);\n-    }\n-\n-    let cgu_def_id = cgu_def_id.unwrap();\n-\n-    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n-        let def_path = tcx.def_path(cgu_def_id);\n-\n-        let components = def_path.data.iter().map(|part| match part.data.name() {\n-            DefPathDataName::Named(name) => name,\n-            DefPathDataName::Anon { .. } => unreachable!(),\n-        });\n-\n-        let volatile_suffix = volatile.then_some(\"volatile\");\n-\n-        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n-    })\n-}\n-\n-// Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n-    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n-}\n-\n-fn mono_item_linkage_and_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> (Linkage, Visibility) {\n-    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n-        return (explicit_linkage, Visibility::Default);\n-    }\n-    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n-    (Linkage::External, vis)\n-}\n-\n-type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n-\n-fn static_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    can_be_internalized: &mut bool,\n-    def_id: DefId,\n-) -> Visibility {\n-    if tcx.is_reachable_non_generic(def_id) {\n-        *can_be_internalized = false;\n-        default_visibility(tcx, def_id, false)\n-    } else {\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn mono_item_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> Visibility {\n-    let instance = match mono_item {\n-        // This is pretty complicated; see below.\n-        MonoItem::Fn(instance) => instance,\n-\n-        // Misc handling for generics and such, but otherwise:\n-        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n-        MonoItem::GlobalAsm(item_id) => {\n-            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n-        }\n-    };\n-\n-    let def_id = match instance.def {\n-        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n-\n-        // We match the visibility of statics here\n-        InstanceDef::ThreadLocalShim(def_id) => {\n-            return static_visibility(tcx, can_be_internalized, def_id);\n-        }\n-\n-        // These are all compiler glue and such, never exported, always hidden.\n-        InstanceDef::VTableShim(..)\n-        | InstanceDef::ReifyShim(..)\n-        | InstanceDef::FnPtrShim(..)\n-        | InstanceDef::Virtual(..)\n-        | InstanceDef::Intrinsic(..)\n-        | InstanceDef::ClosureOnceShim { .. }\n-        | InstanceDef::DropGlue(..)\n-        | InstanceDef::CloneShim(..)\n-        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n-    };\n-\n-    // The `start_fn` lang item is actually a monomorphized instance of a\n-    // function in the standard library, used for the `main` function. We don't\n-    // want to export it so we tag it with `Hidden` visibility but this symbol\n-    // is only referenced from the actual `main` symbol which we unfortunately\n-    // don't know anything about during partitioning/collection. As a result we\n-    // forcibly keep this symbol out of the `internalization_candidates` set.\n-    //\n-    // FIXME: eventually we don't want to always force this symbol to have\n-    //        hidden visibility, it should indeed be a candidate for\n-    //        internalization, but we have to understand that it's referenced\n-    //        from the `main` symbol we'll generate later.\n-    //\n-    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n-    if tcx.lang_items().start_fn() == Some(def_id) {\n-        *can_be_internalized = false;\n-        return Visibility::Hidden;\n-    }\n-\n-    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n-\n-    // Upstream `DefId` instances get different handling than local ones.\n-    let Some(def_id) = def_id.as_local() else {\n-        return if export_generics && is_generic {\n-            // If it is an upstream monomorphization and we export generics, we must make\n-            // it available to downstream crates.\n-            *can_be_internalized = false;\n-            default_visibility(tcx, def_id, true)\n-        } else {\n-            Visibility::Hidden\n-        };\n-    };\n-\n-    if is_generic {\n-        if export_generics {\n-            if tcx.is_unreachable_local_definition(def_id) {\n-                // This instance cannot be used from another crate.\n-                Visibility::Hidden\n-            } else {\n-                // This instance might be useful in a downstream crate.\n-                *can_be_internalized = false;\n-                default_visibility(tcx, def_id.to_def_id(), true)\n-            }\n-        } else {\n-            // We are not exporting generics or the definition is not reachable\n-            // for downstream crates, we can internalize its instantiations.\n-            Visibility::Hidden\n-        }\n-    } else {\n-        // If this isn't a generic function then we mark this a `Default` if\n-        // this is a reachable item, meaning that it's a symbol other crates may\n-        // access when they link to us.\n-        if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n-            *can_be_internalized = false;\n-            debug_assert!(!is_generic);\n-            return default_visibility(tcx, def_id.to_def_id(), false);\n-        }\n-\n-        // If this isn't reachable then we're gonna tag this with `Hidden`\n-        // visibility. In some situations though we'll want to prevent this\n-        // symbol from being internalized.\n-        //\n-        // There's two categories of items here:\n-        //\n-        // * First is weak lang items. These are basically mechanisms for\n-        //   libcore to forward-reference symbols defined later in crates like\n-        //   the standard library or `#[panic_handler]` definitions. The\n-        //   definition of these weak lang items needs to be referencable by\n-        //   libcore, so we're no longer a candidate for internalization.\n-        //   Removal of these functions can't be done by LLVM but rather must be\n-        //   done by the linker as it's a non-local decision.\n-        //\n-        // * Second is \"std internal symbols\". Currently this is primarily used\n-        //   for allocator symbols. Allocators are a little weird in their\n-        //   implementation, but the idea is that the compiler, at the last\n-        //   minute, defines an allocator with an injected object file. The\n-        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n-        //   definition doesn't get hooked up until a linked crate artifact is\n-        //   generated.\n-        //\n-        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n-        //   veneers around the actual implementation, some other symbol which\n-        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n-        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n-        //   internal symbols\".\n-        //\n-        //   The std-internal symbols here **should not show up in a dll as an\n-        //   exported interface**, so they return `false` from\n-        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n-        //   visibility below. Like the weak lang items, though, we can't let\n-        //   LLVM internalize them as this decision is left up to the linker to\n-        //   omit them, so prevent them from being internalized.\n-        let attrs = tcx.codegen_fn_attrs(def_id);\n-        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-            *can_be_internalized = false;\n-        }\n-\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n-    if !tcx.sess.target.default_hidden_visibility {\n-        return Visibility::Default;\n-    }\n-\n-    // Generic functions never have export-level C.\n-    if is_generic {\n-        return Visibility::Hidden;\n-    }\n-\n-    // Things with export level C don't get instantiated in\n-    // downstream crates.\n-    if !id.is_local() {\n-        return Visibility::Hidden;\n-    }\n-\n-    // C-export level items remain at `Default`, all other internal\n-    // items become `Hidden`.\n-    match tcx.reachable_non_generics(id.krate).get(&id) {\n-        Some(SymbolExportInfo { level: SymbolExportLevel::C, .. }) => Visibility::Default,\n-        _ => Visibility::Hidden,\n-    }\n-}"}, {"sha": "d0b23ca9ea44494dcc9dbe891f998bda48a31dc4", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "removed", "additions": 0, "deletions": 673, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/1ac91624d13624c164800fcd28cb234149ce0f5a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac91624d13624c164800fcd28cb234149ce0f5a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=1ac91624d13624c164800fcd28cb234149ce0f5a", "patch": "@@ -1,673 +0,0 @@\n-//! Partitioning Codegen Units for Incremental Compilation\n-//! ======================================================\n-//!\n-//! The task of this module is to take the complete set of monomorphizations of\n-//! a crate and produce a set of codegen units from it, where a codegen unit\n-//! is a named set of (mono-item, linkage) pairs. That is, this module\n-//! decides which monomorphization appears in which codegen units with which\n-//! linkage. The following paragraphs describe some of the background on the\n-//! partitioning scheme.\n-//!\n-//! The most important opportunity for saving on compilation time with\n-//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n-//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n-//! we call them \"codegen units\", the particulars of how much time can be saved\n-//! by incremental compilation are tightly linked to how the output program is\n-//! partitioned into these codegen units prior to passing it to LLVM --\n-//! especially because we have to treat codegen units as opaque entities once\n-//! they are created: There is no way for us to incrementally update an existing\n-//! LLVM module and so we have to build any such module from scratch if it was\n-//! affected by some change in the source code.\n-//!\n-//! From that point of view it would make sense to maximize the number of\n-//! codegen units by, for example, putting each function into its own module.\n-//! That way only those modules would have to be re-compiled that were actually\n-//! affected by some change, minimizing the number of functions that could have\n-//! been re-used but just happened to be located in a module that is\n-//! re-compiled.\n-//!\n-//! However, since LLVM optimization does not work across module boundaries,\n-//! using such a highly granular partitioning would lead to very slow runtime\n-//! code since it would effectively prohibit inlining and other inter-procedure\n-//! optimizations. We want to avoid that as much as possible.\n-//!\n-//! Thus we end up with a trade-off: The bigger the codegen units, the better\n-//! LLVM's optimizer can do its work, but also the smaller the compilation time\n-//! reduction we get from incremental compilation.\n-//!\n-//! Ideally, we would create a partitioning such that there are few big codegen\n-//! units with few interdependencies between them. For now though, we use the\n-//! following heuristic to determine the partitioning:\n-//!\n-//! - There are two codegen units for every source-level module:\n-//! - One for \"stable\", that is non-generic, code\n-//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n-//!   defined in that module\n-//!\n-//! In order to see why this heuristic makes sense, let's take a look at when a\n-//! codegen unit can get invalidated:\n-//!\n-//! 1. The most straightforward case is when the BODY of a function or global\n-//! changes. Then any codegen unit containing the code for that item has to be\n-//! re-compiled. Note that this includes all codegen units where the function\n-//! has been inlined.\n-//!\n-//! 2. The next case is when the SIGNATURE of a function or global changes. In\n-//! this case, all codegen units containing a REFERENCE to that item have to be\n-//! re-compiled. This is a superset of case 1.\n-//!\n-//! 3. The final and most subtle case is when a REFERENCE to a generic function\n-//! is added or removed somewhere. Even though the definition of the function\n-//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n-//! instance of this function which has to be placed and compiled somewhere.\n-//! Conversely, when removing a REFERENCE, it might have been the last one with\n-//! that particular set of generic arguments and thus we have to remove it.\n-//!\n-//! From the above we see that just using one codegen unit per source-level\n-//! module is not such a good idea, since just adding a REFERENCE to some\n-//! generic item somewhere else would invalidate everything within the module\n-//! containing the generic item. The heuristic above reduces this detrimental\n-//! side-effect of references a little by at least not touching the non-generic\n-//! code of the module.\n-//!\n-//! A Note on Inlining\n-//! ------------------\n-//! As briefly mentioned above, in order for LLVM to be able to inline a\n-//! function call, the body of the function has to be available in the LLVM\n-//! module where the call is made. This has a few consequences for partitioning:\n-//!\n-//! - The partitioning algorithm has to take care of placing functions into all\n-//!   codegen units where they should be available for inlining. It also has to\n-//!   decide on the correct linkage for these functions.\n-//!\n-//! - The partitioning algorithm has to know which functions are likely to get\n-//!   inlined, so it can distribute function instantiations accordingly. Since\n-//!   there is no way of knowing for sure which functions LLVM will decide to\n-//!   inline in the end, we apply a heuristic here: Only functions marked with\n-//!   `#[inline]` are considered for inlining by the partitioner. The current\n-//!   implementation will not try to determine if a function is likely to be\n-//!   inlined by looking at the functions definition.\n-//!\n-//! Note though that as a side-effect of creating a codegen units per\n-//! source-level module, functions from the same module will be available for\n-//! inlining, even when they are not marked `#[inline]`.\n-\n-mod default;\n-\n-use std::cmp;\n-use std::fs::{self, File};\n-use std::io::{BufWriter, Write};\n-use std::path::{Path, PathBuf};\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync;\n-use rustc_hir::def_id::{DefIdSet, LOCAL_CRATE};\n-use rustc_middle::mir;\n-use rustc_middle::mir::mono::MonoItem;\n-use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n-use rustc_middle::query::Providers;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n-use rustc_span::symbol::Symbol;\n-\n-use crate::collector::InliningMap;\n-use crate::collector::{self, MonoItemCollectionMode};\n-use crate::errors::{\n-    CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode, UnknownPartitionStrategy,\n-};\n-\n-enum Partitioner {\n-    Default(default::DefaultPartitioning),\n-    // Other partitioning strategies can go here.\n-    Unknown,\n-}\n-\n-impl<'tcx> Partition<'tcx> for Partitioner {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>,\n-    {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.place_root_mono_items(cx, mono_items),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    ) {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.merge_codegen_units(cx, codegen_units),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-        match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.place_inlined_mono_items(cx, codegen_units, roots)\n-            }\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.internalize_symbols(\n-                cx,\n-                codegen_units,\n-                mono_item_placements,\n-                internalization_candidates,\n-            ),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-}\n-\n-struct PartitioningCx<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    target_cgu_count: usize,\n-    inlining_map: &'a InliningMap<'tcx>,\n-}\n-\n-pub struct PlacedRootMonoItems<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<MonoItem<'tcx>>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-}\n-\n-trait Partition<'tcx> {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>;\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    );\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement>;\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    );\n-}\n-\n-fn get_partitioner(tcx: TyCtxt<'_>) -> Partitioner {\n-    let strategy = match &tcx.sess.opts.unstable_opts.cgu_partitioning_strategy {\n-        None => \"default\",\n-        Some(s) => &s[..],\n-    };\n-\n-    match strategy {\n-        \"default\" => Partitioner::Default(default::DefaultPartitioning),\n-        _ => Partitioner::Unknown,\n-    }\n-}\n-\n-fn partition<'tcx, I>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_items: &mut I,\n-    max_cgu_count: usize,\n-    inlining_map: &InliningMap<'tcx>,\n-) -> Vec<CodegenUnit<'tcx>>\n-where\n-    I: Iterator<Item = MonoItem<'tcx>>,\n-{\n-    let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n-\n-    let mut partitioner = get_partitioner(tcx);\n-    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n-    // In the first step, we place all regular monomorphizations into their\n-    // respective 'home' codegen unit. Regular monomorphizations are all\n-    // functions and statics defined in the local crate.\n-    let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        partitioner.place_root_mono_items(cx, mono_items)\n-    };\n-\n-    for cgu in &mut codegen_units {\n-        cgu.create_size_estimate(tcx);\n-    }\n-\n-    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n-\n-    // Merge until we have at most `max_cgu_count` codegen units.\n-    // `merge_codegen_units` is responsible for updating the CGU size\n-    // estimates.\n-    {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(cx, &mut codegen_units);\n-        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n-    }\n-\n-    // In the next step, we use the inlining map to determine which additional\n-    // monomorphizations have to go into each codegen unit. These additional\n-    // monomorphizations can be drop-glue, functions from external crates, and\n-    // local functions the definition of which is marked with `#[inline]`.\n-    let mono_item_placements = {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(cx, &mut codegen_units, roots)\n-    };\n-\n-    for cgu in &mut codegen_units {\n-        cgu.create_size_estimate(tcx);\n-    }\n-\n-    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n-\n-    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n-    // more freedom to optimize.\n-    if !tcx.sess.link_dead_code() {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(\n-            cx,\n-            &mut codegen_units,\n-            mono_item_placements,\n-            internalization_candidates,\n-        );\n-    }\n-\n-    let instrument_dead_code =\n-        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n-\n-    if instrument_dead_code {\n-        assert!(\n-            codegen_units.len() > 0,\n-            \"There must be at least one CGU that code coverage data can be generated in.\"\n-        );\n-\n-        // Find the smallest CGU that has exported symbols and put the dead\n-        // function stubs in that CGU. We look for exported symbols to increase\n-        // the likelihood the linker won't throw away the dead functions.\n-        // FIXME(#92165): In order to truly resolve this, we need to make sure\n-        // the object file (CGU) containing the dead function stubs is included\n-        // in the final binary. This will probably require forcing these\n-        // function symbols to be included via `-u` or `/include` linker args.\n-        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n-        cgus.sort_by_key(|cgu| cgu.size_estimate());\n-\n-        let dead_code_cgu =\n-            if let Some(cgu) = cgus.into_iter().rev().find(|cgu| {\n-                cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External)\n-            }) {\n-                cgu\n-            } else {\n-                // If there are no CGUs that have externally linked items,\n-                // then we just pick the first CGU as a fallback.\n-                &mut codegen_units[0]\n-            };\n-        dead_code_cgu.make_code_coverage_dead_code_cgu();\n-    }\n-\n-    // Finally, sort by codegen unit name, so that we get deterministic results.\n-    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-    debug_dump(tcx, \"FINAL\", &codegen_units);\n-\n-    codegen_units\n-}\n-\n-/// For symbol internalization, we need to know whether a symbol/mono-item is\n-/// accessed from outside the codegen unit it is defined in. This type is used\n-/// to keep track of that.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum MonoItemPlacement {\n-    SingleCgu { cgu_name: Symbol },\n-    MultipleCgus,\n-}\n-\n-fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n-    let dump = move || {\n-        use std::fmt::Write;\n-\n-        let num_cgus = cgus.len();\n-        let max = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n-        let min = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n-        let ratio = max as f64 / min as f64;\n-\n-        let s = &mut String::new();\n-        let _ = writeln!(\n-            s,\n-            \"{label} ({num_cgus} CodegenUnits, max={max}, min={min}, max/min={ratio:.1}):\"\n-        );\n-        for cgu in cgus {\n-            let _ =\n-                writeln!(s, \"CodegenUnit {} estimated size {}:\", cgu.name(), cgu.size_estimate());\n-\n-            for (mono_item, linkage) in cgu.items() {\n-                let symbol_name = mono_item.symbol_name(tcx).name;\n-                let symbol_hash_start = symbol_name.rfind('h');\n-                let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n-\n-                let _ = with_no_trimmed_paths!(writeln!(\n-                    s,\n-                    \" - {} [{:?}] [{}] estimated size {}\",\n-                    mono_item,\n-                    linkage,\n-                    symbol_hash,\n-                    mono_item.size_estimate(tcx)\n-                ));\n-            }\n-\n-            let _ = writeln!(s);\n-        }\n-\n-        std::mem::take(s)\n-    };\n-\n-    debug!(\"{}\", dump());\n-}\n-\n-#[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n-where\n-    I: Iterator<Item = &'a MonoItem<'tcx>>,\n-    'tcx: 'a,\n-{\n-    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n-\n-    let mut symbols: Vec<_> =\n-        mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n-\n-    symbols.sort_by_key(|sym| sym.1);\n-\n-    for &[(mono_item1, ref sym1), (mono_item2, ref sym2)] in symbols.array_windows() {\n-        if sym1 == sym2 {\n-            let span1 = mono_item1.local_span(tcx);\n-            let span2 = mono_item2.local_span(tcx);\n-\n-            // Deterministically select one of the spans for error reporting\n-            let span = match (span1, span2) {\n-                (Some(span1), Some(span2)) => {\n-                    Some(if span1.lo().0 > span2.lo().0 { span1 } else { span2 })\n-                }\n-                (span1, span2) => span1.or(span2),\n-            };\n-\n-            tcx.sess.emit_fatal(SymbolAlreadyDefined { span, symbol: sym1.to_string() });\n-        }\n-    }\n-}\n-\n-fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n-    let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n-        Some(ref s) => {\n-            let mode = s.to_lowercase();\n-            let mode = mode.trim();\n-            if mode == \"eager\" {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                if mode != \"lazy\" {\n-                    tcx.sess.emit_warning(UnknownCguCollectionMode { mode });\n-                }\n-\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-        None => {\n-            if tcx.sess.link_dead_code() {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-    };\n-\n-    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n-\n-    tcx.sess.abort_if_errors();\n-\n-    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n-        sync::join(\n-            || {\n-                let mut codegen_units = partition(\n-                    tcx,\n-                    &mut items.iter().copied(),\n-                    tcx.sess.codegen_units(),\n-                    &inlining_map,\n-                );\n-                codegen_units[0].make_primary();\n-                &*tcx.arena.alloc_from_iter(codegen_units)\n-            },\n-            || assert_symbols_are_distinct(tcx, items.iter()),\n-        )\n-    });\n-\n-    if tcx.prof.enabled() {\n-        // Record CGU size estimates for self-profiling.\n-        for cgu in codegen_units {\n-            tcx.prof.artifact_size(\n-                \"codegen_unit_size_estimate\",\n-                cgu.name().as_str(),\n-                cgu.size_estimate() as u64,\n-            );\n-        }\n-    }\n-\n-    let mono_items: DefIdSet = items\n-        .iter()\n-        .filter_map(|mono_item| match *mono_item {\n-            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n-            MonoItem::Static(def_id) => Some(def_id),\n-            _ => None,\n-        })\n-        .collect();\n-\n-    // Output monomorphization stats per def_id\n-    if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n-        if let Err(err) =\n-            dump_mono_items_stats(tcx, &codegen_units, path, tcx.crate_name(LOCAL_CRATE))\n-        {\n-            tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n-        }\n-    }\n-\n-    if tcx.sess.opts.unstable_opts.print_mono_items.is_some() {\n-        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n-\n-        for cgu in codegen_units {\n-            for (&mono_item, &linkage) in cgu.items() {\n-                item_to_cgus.entry(mono_item).or_default().push((cgu.name(), linkage));\n-            }\n-        }\n-\n-        let mut item_keys: Vec<_> = items\n-            .iter()\n-            .map(|i| {\n-                let mut output = with_no_trimmed_paths!(i.to_string());\n-                output.push_str(\" @@\");\n-                let mut empty = Vec::new();\n-                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n-                cgus.sort_by_key(|(name, _)| *name);\n-                cgus.dedup();\n-                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n-                    output.push(' ');\n-                    output.push_str(cgu_name.as_str());\n-\n-                    let linkage_abbrev = match linkage {\n-                        Linkage::External => \"External\",\n-                        Linkage::AvailableExternally => \"Available\",\n-                        Linkage::LinkOnceAny => \"OnceAny\",\n-                        Linkage::LinkOnceODR => \"OnceODR\",\n-                        Linkage::WeakAny => \"WeakAny\",\n-                        Linkage::WeakODR => \"WeakODR\",\n-                        Linkage::Appending => \"Appending\",\n-                        Linkage::Internal => \"Internal\",\n-                        Linkage::Private => \"Private\",\n-                        Linkage::ExternalWeak => \"ExternalWeak\",\n-                        Linkage::Common => \"Common\",\n-                    };\n-\n-                    output.push('[');\n-                    output.push_str(linkage_abbrev);\n-                    output.push(']');\n-                }\n-                output\n-            })\n-            .collect();\n-\n-        item_keys.sort();\n-\n-        for item in item_keys {\n-            println!(\"MONO_ITEM {item}\");\n-        }\n-    }\n-\n-    (tcx.arena.alloc(mono_items), codegen_units)\n-}\n-\n-/// Outputs stats about instantiation counts and estimated size, per `MonoItem`'s\n-/// def, to a file in the given output directory.\n-fn dump_mono_items_stats<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    codegen_units: &[CodegenUnit<'tcx>],\n-    output_directory: &Option<PathBuf>,\n-    crate_name: Symbol,\n-) -> Result<(), Box<dyn std::error::Error>> {\n-    let output_directory = if let Some(ref directory) = output_directory {\n-        fs::create_dir_all(directory)?;\n-        directory\n-    } else {\n-        Path::new(\".\")\n-    };\n-\n-    let format = tcx.sess.opts.unstable_opts.dump_mono_stats_format;\n-    let ext = format.extension();\n-    let filename = format!(\"{crate_name}.mono_items.{ext}\");\n-    let output_path = output_directory.join(&filename);\n-    let file = File::create(&output_path)?;\n-    let mut file = BufWriter::new(file);\n-\n-    // Gather instantiated mono items grouped by def_id\n-    let mut items_per_def_id: FxHashMap<_, Vec<_>> = Default::default();\n-    for cgu in codegen_units {\n-        for (&mono_item, _) in cgu.items() {\n-            // Avoid variable-sized compiler-generated shims\n-            if mono_item.is_user_defined() {\n-                items_per_def_id.entry(mono_item.def_id()).or_default().push(mono_item);\n-            }\n-        }\n-    }\n-\n-    #[derive(serde::Serialize)]\n-    struct MonoItem {\n-        name: String,\n-        instantiation_count: usize,\n-        size_estimate: usize,\n-        total_estimate: usize,\n-    }\n-\n-    // Output stats sorted by total instantiated size, from heaviest to lightest\n-    let mut stats: Vec<_> = items_per_def_id\n-        .into_iter()\n-        .map(|(def_id, items)| {\n-            let name = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n-            let instantiation_count = items.len();\n-            let size_estimate = items[0].size_estimate(tcx);\n-            let total_estimate = instantiation_count * size_estimate;\n-            MonoItem { name, instantiation_count, size_estimate, total_estimate }\n-        })\n-        .collect();\n-    stats.sort_unstable_by_key(|item| cmp::Reverse(item.total_estimate));\n-\n-    if !stats.is_empty() {\n-        match format {\n-            DumpMonoStatsFormat::Json => serde_json::to_writer(file, &stats)?,\n-            DumpMonoStatsFormat::Markdown => {\n-                writeln!(\n-                    file,\n-                    \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n-                )?;\n-                writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n-\n-                for MonoItem { name, instantiation_count, size_estimate, total_estimate } in stats {\n-                    writeln!(\n-                        file,\n-                        \"| `{name}` | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n-                    )?;\n-                }\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-fn codegened_and_inlined_items(tcx: TyCtxt<'_>, (): ()) -> &DefIdSet {\n-    let (items, cgus) = tcx.collect_and_partition_mono_items(());\n-    let mut visited = DefIdSet::default();\n-    let mut result = items.clone();\n-\n-    for cgu in cgus {\n-        for (item, _) in cgu.items() {\n-            if let MonoItem::Fn(ref instance) = item {\n-                let did = instance.def_id();\n-                if !visited.insert(did) {\n-                    continue;\n-                }\n-                let body = tcx.instance_mir(instance.def);\n-                for block in body.basic_blocks.iter() {\n-                    for statement in &block.statements {\n-                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n-                        let scope = statement.source_info.scope;\n-                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n-                            result.insert(inlined.def_id());\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    tcx.arena.alloc(result)\n-}\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.collect_and_partition_mono_items = collect_and_partition_mono_items;\n-    providers.codegened_and_inlined_items = codegened_and_inlined_items;\n-\n-    providers.is_codegened_item = |tcx, def_id| {\n-        let (all_mono_items, _) = tcx.collect_and_partition_mono_items(());\n-        all_mono_items.contains(&def_id)\n-    };\n-\n-    providers.codegen_unit = |tcx, name| {\n-        let (_, all) = tcx.collect_and_partition_mono_items(());\n-        all.iter()\n-            .find(|cgu| cgu.name() == name)\n-            .unwrap_or_else(|| panic!(\"failed to find cgu with name {name:?}\"))\n-    };\n-}"}, {"sha": "f6a80b0431fc33fa7afb19076db9871db0e740c5", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -29,12 +29,12 @@ pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: In\n         let before_feature_tys = tcx.subst_and_normalize_erasing_regions(\n             closure_instance.substs,\n             param_env,\n-            ty::EarlyBinder::new(before_feature_tys),\n+            ty::EarlyBinder::bind(before_feature_tys),\n         );\n         let after_feature_tys = tcx.subst_and_normalize_erasing_regions(\n             closure_instance.substs,\n             param_env,\n-            ty::EarlyBinder::new(after_feature_tys),\n+            ty::EarlyBinder::bind(after_feature_tys),\n         );\n \n         let new_size = tcx"}, {"sha": "c9353b6fc9fb90d00d74e4487896d46fc88baf94", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n \n \n [dependencies]\n-memoffset = { version = \"0.6.0\", features = [\"unstable_const\"] }\n+memoffset = { version = \"0.8.0\", features = [\"unstable_const\"] }\n field-offset = \"0.3.5\"\n measureme = \"10.0.0\"\n rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "7cc2b2c880c60bd75931ec04e2a596622619d366", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1372,8 +1372,6 @@ options! {\n         \"set options for branch target identification and pointer authentication on AArch64\"),\n     cf_protection: CFProtection = (CFProtection::None, parse_cfprotection, [TRACKED],\n         \"instrument control-flow architecture protection\"),\n-    cgu_partitioning_strategy: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"the codegen unit partitioning strategy to use\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the backend to use\"),\n     combine_cgu: bool = (false, parse_bool, [TRACKED],"}, {"sha": "1185563ea8063e989bafb23f980782ced36eddd3", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1454,6 +1454,10 @@ symbols! {\n         stop_after_dataflow,\n         store,\n         str,\n+        str_from_utf8,\n+        str_from_utf8_mut,\n+        str_from_utf8_unchecked,\n+        str_from_utf8_unchecked_mut,\n         str_split_whitespace,\n         str_trim,\n         str_trim_end,"}, {"sha": "0a805e2422d40e4d80bcfd59ec1f7ddf40a2600a", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -274,7 +274,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n         let mut param_env = self.tcx.param_env_reveal_all_normalized(impl_def_id);\n         if !substs.is_empty() {\n-            param_env = EarlyBinder::new(param_env).subst(self.tcx, substs);\n+            param_env = EarlyBinder::bind(param_env).subst(self.tcx, substs);\n         }\n \n         match &mut impl_trait_ref {"}, {"sha": "0f3f8f1ac2cbb5eda7bacc954a9ea9113c58ae01", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -96,7 +96,7 @@ pub(in crate::solve) fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n             let br =\n                 ty::BoundRegion { var: ty::BoundVar::from_u32(counter), kind: ty::BrAnon(None) };\n             counter += 1;\n-            tcx.mk_re_late_bound(current_depth, br)\n+            ty::Region::new_late_bound(tcx, current_depth, br)\n         }\n         // All free regions should be erased here.\n         r => bug!(\"unexpected region: {r:?}\"),"}, {"sha": "29bdb5ff67da8c908c7c5d1d0107945f1efe7f5a", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -255,7 +255,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n             }),\n         );\n         let br = ty::BoundRegion { var, kind: BrAnon(None) };\n-        self.interner().mk_re_late_bound(self.binder_index, br)\n+        ty::Region::new_late_bound(self.interner(), self.binder_index, br)\n     }\n \n     fn fold_ty(&mut self, mut t: Ty<'tcx>) -> Ty<'tcx> {"}, {"sha": "bca2343e4242204e80d95fdf8ca93e0f7c2d451c", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -137,6 +137,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self), ret)]\n     fn compute_external_query_constraints(&self) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+        // We only check for leaks from universes which were entered inside\n+        // of the query.\n+        self.infcx.leak_check(self.max_input_universe, None).map_err(|e| {\n+            debug!(?e, \"failed the leak check\");\n+            NoSolution\n+        })?;\n+\n         // Cannot use `take_registered_region_obligations` as we may compute the response\n         // inside of a `probe` whenever we have multiple choices inside of the solver.\n         let region_obligations = self.infcx.inner.borrow().region_obligations().to_owned();"}, {"sha": "d6fd457de06da42d4f5c17ac024ac8fa9c821dc2", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -5,7 +5,7 @@\n //! [trait-specialization]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n use crate::infer::outlives::env::OutlivesEnvironment;\n-use crate::infer::{CombinedSnapshot, InferOk};\n+use crate::infer::InferOk;\n use crate::traits::outlives_bounds::InferCtxtExt as _;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::util::impl_subject_and_oblig;\n@@ -62,6 +62,21 @@ pub fn add_placeholder_note(err: &mut Diagnostic) {\n     );\n }\n \n+#[derive(Debug, Clone, Copy)]\n+enum TrackAmbiguityCauses {\n+    Yes,\n+    No,\n+}\n+\n+impl TrackAmbiguityCauses {\n+    fn is_yes(self) -> bool {\n+        match self {\n+            TrackAmbiguityCauses::Yes => true,\n+            TrackAmbiguityCauses::No => false,\n+        }\n+    }\n+}\n+\n /// If there are types that satisfy both impls, returns `Some`\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, returns `None`.\n@@ -97,29 +112,28 @@ pub fn overlapping_impls(\n         return None;\n     }\n \n-    let infcx = tcx\n-        .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bubble)\n-        .intercrate(true)\n-        .build();\n-    let selcx = &mut SelectionContext::new(&infcx);\n-    let overlaps =\n-        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n-    if !overlaps {\n-        return None;\n-    }\n+    let _overlap_with_bad_diagnostics = overlap(\n+        tcx,\n+        TrackAmbiguityCauses::No,\n+        skip_leak_check,\n+        impl1_def_id,\n+        impl2_def_id,\n+        overlap_mode,\n+    )?;\n \n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    let infcx = tcx\n-        .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bubble)\n-        .intercrate(true)\n-        .build();\n-    let selcx = &mut SelectionContext::new(&infcx);\n-    selcx.enable_tracking_intercrate_ambiguity_causes();\n-    Some(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n+    let overlap = overlap(\n+        tcx,\n+        TrackAmbiguityCauses::Yes,\n+        skip_leak_check,\n+        impl1_def_id,\n+        impl2_def_id,\n+        overlap_mode,\n+    )\n+    .unwrap();\n+    Some(overlap)\n }\n \n fn with_fresh_ty_vars<'cx, 'tcx>(\n@@ -146,40 +160,34 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n-fn overlap<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n+#[instrument(level = \"debug\", skip(tcx))]\n+fn overlap<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    track_ambiguity_causes: TrackAmbiguityCauses,\n     skip_leak_check: SkipLeakCheck,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     overlap_mode: OverlapMode,\n ) -> Option<OverlapResult<'tcx>> {\n-    debug!(\n-        \"overlap(impl1_def_id={:?}, impl2_def_id={:?}, overlap_mode={:?})\",\n-        impl1_def_id, impl2_def_id, overlap_mode\n-    );\n-\n-    selcx.infcx.probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n-        overlap_within_probe(selcx, impl1_def_id, impl2_def_id, overlap_mode, snapshot)\n-    })\n-}\n-\n-fn overlap_within_probe<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    impl1_def_id: DefId,\n-    impl2_def_id: DefId,\n-    overlap_mode: OverlapMode,\n-    snapshot: &CombinedSnapshot<'tcx>,\n-) -> Option<OverlapResult<'tcx>> {\n-    let infcx = selcx.infcx;\n-\n     if overlap_mode.use_negative_impl() {\n-        if negative_impl(infcx.tcx, impl1_def_id, impl2_def_id)\n-            || negative_impl(infcx.tcx, impl2_def_id, impl1_def_id)\n+        if negative_impl(tcx, impl1_def_id, impl2_def_id)\n+            || negative_impl(tcx, impl2_def_id, impl1_def_id)\n         {\n             return None;\n         }\n     }\n \n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .skip_leak_check(skip_leak_check.is_yes())\n+        .intercrate(true)\n+        .build();\n+    let selcx = &mut SelectionContext::new(&infcx);\n+    if track_ambiguity_causes.is_yes() {\n+        selcx.enable_tracking_intercrate_ambiguity_causes();\n+    }\n+\n     // For the purposes of this check, we don't bring any placeholder\n     // types into scope; instead, we replace the generic types with\n     // fresh type variables, and hence we do our evaluations in an\n@@ -198,18 +206,23 @@ fn overlap_within_probe<'cx, 'tcx>(\n         }\n     }\n \n-    // We disable the leak when creating the `snapshot` by using\n-    // `infcx.probe_maybe_disable_leak_check`.\n-    if infcx.leak_check(true, snapshot).is_err() {\n+    // We toggle the `leak_check` by using `skip_leak_check` when constructing the\n+    // inference context, so this may be a noop.\n+    if infcx.leak_check(ty::UniverseIndex::ROOT, None).is_err() {\n         debug!(\"overlap: leak check failed\");\n         return None;\n     }\n \n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n-\n-    let involves_placeholder =\n-        matches!(selcx.infcx.region_constraints_added_in_snapshot(snapshot), Some(true));\n+    let involves_placeholder = infcx\n+        .inner\n+        .borrow_mut()\n+        .unwrap_region_constraints()\n+        .data()\n+        .constraints\n+        .iter()\n+        .any(|c| c.0.involves_placeholders());\n \n     let impl_header = selcx.infcx.resolve_vars_if_possible(impl1_header);\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })"}, {"sha": "f7389bda159e5272ffc431e3414c78b481d28577", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -32,7 +32,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_middle::query::Providers;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFolder, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n@@ -272,8 +272,62 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // parameter environments once for every fn as it goes,\n     // and errors will get reported then; so outside of type inference we\n     // can be sure that no errors should occur.\n-    let mut predicates: Vec<_> =\n-        util::elaborate(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n+    let mut predicates: Vec<_> = util::elaborate(\n+        tcx,\n+        unnormalized_env.caller_bounds().into_iter().map(|predicate| {\n+            if tcx.features().generic_const_exprs {\n+                return predicate;\n+            }\n+\n+            struct ConstNormalizer<'tcx>(TyCtxt<'tcx>);\n+\n+            impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ConstNormalizer<'tcx> {\n+                fn interner(&self) -> TyCtxt<'tcx> {\n+                    self.0\n+                }\n+\n+                fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+                    // While it is pretty sus to be evaluating things with an empty param env, it\n+                    // should actually be okay since without `feature(generic_const_exprs)` the only\n+                    // const arguments that have a non-empty param env are array repeat counts. These\n+                    // do not appear in the type system though.\n+                    c.eval(self.0, ty::ParamEnv::empty())\n+                }\n+            }\n+\n+            // This whole normalization step is a hack to work around the fact that\n+            // `normalize_param_env_or_error` is fundamentally broken from using an\n+            // unnormalized param env with a trait solver that expects the param env\n+            // to be normalized.\n+            //\n+            // When normalizing the param env we can end up evaluating obligations\n+            // that have been normalized but can only be proven via a where clause\n+            // which is still in its unnormalized form. example:\n+            //\n+            // Attempting to prove `T: Trait<<u8 as Identity>::Assoc>` in a param env\n+            // with a `T: Trait<<u8 as Identity>::Assoc>` where clause will fail because\n+            // we first normalize obligations before proving them so we end up proving\n+            // `T: Trait<u8>`. Since lazy normalization is not implemented equating `u8`\n+            // with `<u8 as Identity>::Assoc` fails outright so we incorrectly believe that\n+            // we cannot prove `T: Trait<u8>`.\n+            //\n+            // The same thing is true for const generics- attempting to prove\n+            // `T: Trait<ConstKind::Unevaluated(...)>` with the same thing as a where clauses\n+            // will fail. After normalization we may be attempting to prove `T: Trait<4>` with\n+            // the unnormalized where clause `T: Trait<ConstKind::Unevaluated(...)>`. In order\n+            // for the obligation to hold `4` must be equal to `ConstKind::Unevaluated(...)`\n+            // but as we do not have lazy norm implemented, equating the two consts fails outright.\n+            //\n+            // Ideally we would not normalize consts here at all but it is required for backwards\n+            // compatibility. Eventually when lazy norm is implemented this can just be removed.\n+            // We do not normalize types here as there is no backwards compatibility requirement\n+            // for us to do so.\n+            //\n+            // FIXME(-Ztrait-solver=next): remove this hack since we have deferred projection equality\n+            predicate.fold_with(&mut ConstNormalizer(tcx))\n+        }),\n+    )\n+    .collect();\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n \n@@ -487,7 +541,7 @@ fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefI\n                 tcx,\n                 ObligationCause::dummy_with_span(*span),\n                 param_env,\n-                ty::EarlyBinder::new(*pred).subst(tcx, impl_trait_ref.substs),\n+                ty::EarlyBinder::bind(*pred).subst(tcx, impl_trait_ref.substs),\n             )\n         })\n     });"}, {"sha": "9582479941b66cd8148ab9e934fe87ef4920a9d9", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -642,7 +642,7 @@ fn receiver_for_self_ty<'tcx>(\n         if param.index == 0 { self_ty.into() } else { tcx.mk_param_from_def(param) }\n     });\n \n-    let result = EarlyBinder::new(receiver_ty).subst(tcx, substs);\n+    let result = EarlyBinder::bind(receiver_ty).subst(tcx, substs);\n     debug!(\n         \"receiver_for_self_ty({:?}, {:?}, {:?}) = {:?}\",\n         receiver_ty, self_ty, method_def_id, result"}, {"sha": "65af0bb1c4e1f059bd1499e19dd83d5a53b7e7e5", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -824,7 +824,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderRegion { universe, bound: br };\n                 self.mapped_regions.insert(p, br);\n-                self.infcx.tcx.mk_re_placeholder(p)\n+                ty::Region::new_placeholder(self.infcx.tcx, p)\n             }\n             _ => r,\n         }\n@@ -945,7 +945,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for PlaceholderReplacer<'_, 'tcx> {\n                         let db = ty::DebruijnIndex::from_usize(\n                             self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                         );\n-                        self.interner().mk_re_late_bound(db, *replace_var)\n+                        ty::Region::new_late_bound(self.interner(), db, *replace_var)\n                     }\n                     None => r1,\n                 }"}, {"sha": "709c3f432e609a27f103f2cdc0605227501c5f19", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -307,13 +307,13 @@ pub fn dtorck_constraint_for_ty_inner<'tcx>(\n             // there, but that needs some way to handle cycles.\n             constraints\n                 .dtorck_types\n-                .extend(dtorck_types.iter().map(|t| EarlyBinder::new(*t).subst(tcx, substs)));\n+                .extend(dtorck_types.iter().map(|t| EarlyBinder::bind(*t).subst(tcx, substs)));\n             constraints\n                 .outlives\n-                .extend(outlives.iter().map(|t| EarlyBinder::new(*t).subst(tcx, substs)));\n+                .extend(outlives.iter().map(|t| EarlyBinder::bind(*t).subst(tcx, substs)));\n             constraints\n                 .overflows\n-                .extend(overflows.iter().map(|t| EarlyBinder::new(*t).subst(tcx, substs)));\n+                .extend(overflows.iter().map(|t| EarlyBinder::bind(*t).subst(tcx, substs)));\n         }\n \n         // Objects must be alive in order for their destructor"}, {"sha": "a8a74d7501abf6f442bc296c2ce8b3a5b3565e07", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     Ok(EvaluationResult::EvaluatedToAmbig)\n                 } else if self.opaque_types_added_in_snapshot(snapshot) {\n                     Ok(EvaluationResult::EvaluatedToOkModuloOpaqueTypes)\n-                } else if self.region_constraints_added_in_snapshot(snapshot).is_some() {\n+                } else if self.region_constraints_added_in_snapshot(snapshot) {\n                     Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n                 } else {\n                     Ok(EvaluationResult::EvaluatedToOk)"}, {"sha": "4e961c3ee733c56f5afcc1e9900b9c1d35245825", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -550,7 +550,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n                                 let bound_var = ty::BoundVariableKind::Region(kind);\n                                 bound_vars.push(bound_var);\n-                                tcx.mk_re_late_bound(\n+                                ty::Region::new_late_bound(\n+                                    tcx,\n                                     ty::INNERMOST,\n                                     ty::BoundRegion {\n                                         var: ty::BoundVar::from_usize(bound_vars.len() - 1),"}, {"sha": "42c1b629ac242b3a3fffded6a6ac3f936f72cf90", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -561,9 +561,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         op: impl FnOnce(&mut Self) -> Result<EvaluationResult, OverflowError>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.infcx.probe(|snapshot| -> Result<EvaluationResult, OverflowError> {\n+            let outer_universe = self.infcx.universe();\n             let result = op(self)?;\n \n-            match self.infcx.leak_check(true, snapshot) {\n+            match self.infcx.leak_check(outer_universe, Some(snapshot)) {\n                 Ok(()) => {}\n                 Err(_) => return Ok(EvaluatedToErr),\n             }\n@@ -572,9 +573,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 return Ok(result.max(EvaluatedToOkModuloOpaqueTypes));\n             }\n \n-            match self.infcx.region_constraints_added_in_snapshot(snapshot) {\n-                None => Ok(result),\n-                Some(_) => Ok(result.max(EvaluatedToOkModuloRegions)),\n+            if self.infcx.region_constraints_added_in_snapshot(snapshot) {\n+                Ok(result.max(EvaluatedToOkModuloRegions))\n+            } else {\n+                Ok(result)\n             }\n         })\n     }\n@@ -3027,7 +3029,7 @@ fn bind_generator_hidden_types_above<'tcx>(\n                             kind: ty::BrAnon(None),\n                         };\n                         counter += 1;\n-                        tcx.mk_re_late_bound(current_depth, br)\n+                        ty::Region::new_late_bound(tcx, current_depth, br)\n                     }\n                     r => bug!(\"unexpected region: {r:?}\"),\n                 })"}, {"sha": "38f94c38861880a1ed4c94b620d33224506f4cab", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -727,7 +727,7 @@ fn bound_vars_for_item(tcx: TyCtxt<'_>, def_id: DefId) -> SubstsRef<'_> {\n                 var: ty::BoundVar::from_usize(substs.len()),\n                 kind: ty::BrAnon(None),\n             };\n-            tcx.mk_re_late_bound(ty::INNERMOST, br).into()\n+            ty::Region::new_late_bound(tcx, ty::INNERMOST, br).into()\n         }\n \n         ty::GenericParamDefKind::Const { .. } => tcx"}, {"sha": "e6c6e0f13df318d8b9e0cdaee684b81fcdfb94a6", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -542,21 +542,25 @@ impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'t\n     fn lower_into(self, interner: RustInterner<'tcx>) -> Region<'tcx> {\n         let tcx = interner.tcx;\n         match self.data(interner) {\n-            chalk_ir::LifetimeData::BoundVar(var) => tcx.mk_re_late_bound(\n+            chalk_ir::LifetimeData::BoundVar(var) => ty::Region::new_late_bound(\n+                tcx,\n                 ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n                 ty::BoundRegion {\n                     var: ty::BoundVar::from_usize(var.index),\n                     kind: ty::BrAnon(None),\n                 },\n             ),\n             chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n-            chalk_ir::LifetimeData::Placeholder(p) => tcx.mk_re_placeholder(ty::Placeholder {\n-                universe: ty::UniverseIndex::from_usize(p.ui.counter),\n-                bound: ty::BoundRegion {\n-                    var: ty::BoundVar::from_usize(p.idx),\n-                    kind: ty::BoundRegionKind::BrAnon(None),\n+            chalk_ir::LifetimeData::Placeholder(p) => ty::Region::new_placeholder(\n+                tcx,\n+                ty::Placeholder {\n+                    universe: ty::UniverseIndex::from_usize(p.ui.counter),\n+                    bound: ty::BoundRegion {\n+                        var: ty::BoundVar::from_usize(p.idx),\n+                        kind: ty::BoundRegionKind::BrAnon(None),\n+                    },\n                 },\n-            }),\n+            ),\n             chalk_ir::LifetimeData::Static => tcx.lifetimes.re_static,\n             chalk_ir::LifetimeData::Erased => tcx.lifetimes.re_erased,\n             chalk_ir::LifetimeData::Phantom(void, _) => match *void {},\n@@ -1051,7 +1055,7 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for NamedBoundVarSubstitutor<'a, 'tcx> {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(_) => {\n                         let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(None) };\n-                        return self.tcx.mk_re_late_bound(index, new_br);\n+                        return ty::Region::new_late_bound(self.tcx, index, new_br);\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n                 },\n@@ -1142,7 +1146,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ParamsSubstitutor<'tcx> {\n                         var: ty::BoundVar::from_u32(*idx),\n                         kind: ty::BrAnon(None),\n                     };\n-                    self.tcx.mk_re_late_bound(self.binder_index, br)\n+                    ty::Region::new_late_bound(self.tcx, self.binder_index, br)\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n@@ -1151,7 +1155,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ParamsSubstitutor<'tcx> {\n                         kind: ty::BrAnon(None),\n                     };\n                     self.named_regions.insert(_re.def_id, idx);\n-                    self.tcx.mk_re_late_bound(self.binder_index, br)\n+                    ty::Region::new_late_bound(self.tcx, self.binder_index, br)\n                 }\n             },\n "}, {"sha": "5b3ffc9fc36d22e84792490c339b6af1a45079af", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -81,7 +81,7 @@ fn fn_sig_for_fn_abi<'tcx>(\n                 var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                 kind: ty::BoundRegionKind::BrEnv,\n             };\n-            let env_region = tcx.mk_re_late_bound(ty::INNERMOST, br);\n+            let env_region = ty::Region::new_late_bound(tcx, ty::INNERMOST, br);\n             let env_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n \n             let sig = sig.skip_binder();\n@@ -106,7 +106,7 @@ fn fn_sig_for_fn_abi<'tcx>(\n                 var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                 kind: ty::BoundRegionKind::BrEnv,\n             };\n-            let env_ty = tcx.mk_mut_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), ty);\n+            let env_ty = tcx.mk_mut_ref(ty::Region::new_late_bound(tcx, ty::INNERMOST, br), ty);\n \n             let pin_did = tcx.require_lang_item(LangItem::Pin, None);\n             let pin_adt_ref = tcx.adt_def(pin_did);"}, {"sha": "57b4183d336718bb4588b8de48fa800ee70ae3fd", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -301,7 +301,7 @@ fn associated_type_for_impl_trait_in_trait(\n     trait_assoc_ty.impl_defaultness(tcx.impl_defaultness(fn_def_id));\n \n     // Copy type_of of the opaque.\n-    trait_assoc_ty.type_of(ty::EarlyBinder::new(tcx.mk_opaque(\n+    trait_assoc_ty.type_of(ty::EarlyBinder::bind(tcx.mk_opaque(\n         opaque_ty_def_id.to_def_id(),\n         InternalSubsts::identity_for_item(tcx, opaque_ty_def_id),\n     )));"}, {"sha": "ce77df0df5dcf49abb5bf224160ed35a5b9e09cf", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -419,7 +419,7 @@ pub fn thir_abstract_const(\n \n     let root_span = body.exprs[body_id].span;\n \n-    Ok(Some(ty::EarlyBinder::new(recurse_build(tcx, body, body_id, root_span)?)))\n+    Ok(Some(ty::EarlyBinder::bind(recurse_build(tcx, body, body_id, root_span)?)))\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "7015778e24b8568f5b0cc68cef25a93c3bf55af3", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -610,7 +610,7 @@ fn generator_layout<'tcx>(\n ) -> Result<Layout<'tcx>, LayoutError<'tcx>> {\n     use SavedLocalEligibility::*;\n     let tcx = cx.tcx;\n-    let subst_field = |ty: Ty<'tcx>| EarlyBinder::new(ty).subst(tcx, substs);\n+    let subst_field = |ty: Ty<'tcx>| EarlyBinder::bind(ty).subst(tcx, substs);\n \n     let Some(info) = tcx.generator_layout(def_id) else {\n         return Err(LayoutError::Unknown(ty));"}, {"sha": "9d593dc5e04eeeca980ce7deb5b7f48b248d7012", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -210,7 +210,7 @@ fn drop_tys_helper<'tcx>(\n             match subty.kind() {\n                 ty::Adt(adt_id, subst) => {\n                     for subty in tcx.adt_drop_tys(adt_id.did())? {\n-                        vec.push(EarlyBinder::new(subty).subst(tcx, subst));\n+                        vec.push(EarlyBinder::bind(subty).subst(tcx, subst));\n                     }\n                 }\n                 _ => vec.push(subty),"}, {"sha": "12ad8b0842f5e4f1eb7abbca3a25e6cb618c831f", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -287,12 +287,13 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n             let shifted_alias_ty = self.tcx.fold_regions(unshifted_alias_ty, |re, depth| {\n                 if let ty::ReLateBound(index, bv) = re.kind() {\n                     if depth != ty::INNERMOST {\n-                        return self.tcx.mk_re_error_with_message(\n+                        return ty::Region::new_error_with_message(\n+                            self.tcx,\n                             DUMMY_SP,\n                             \"we shouldn't walk non-predicate binders with `impl Trait`...\",\n                         );\n                     }\n-                    self.tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n+                    ty::Region::new_late_bound(self.tcx, index.shifted_out_to_binder(self.depth), bv)\n                 } else {\n                     re\n                 }\n@@ -506,7 +507,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<EarlyBinder<Ty<'\n \n     if self_ty_matches {\n         debug!(\"issue33140_self_ty - MATCHES!\");\n-        Some(EarlyBinder::new(self_ty))\n+        Some(EarlyBinder::bind(self_ty))\n     } else {\n         debug!(\"issue33140_self_ty - non-matching self type\");\n         None"}, {"sha": "ae16fbb162e5c01f83fb69fb8162805a40330204", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -52,7 +52,7 @@ pub trait Interner: Sized {\n     type PolyFnSig: Clone + Debug + Hash + Ord;\n     type ListBinderExistentialPredicate: Clone + Debug + Hash + Ord;\n     type BinderListTy: Clone + Debug + Hash + Ord;\n-    type ListTy: Clone + Debug + Hash + Ord;\n+    type ListTy: Clone + Debug + Hash + Ord + IntoIterator<Item = Self::Ty>;\n     type AliasTy: Clone + Debug + Hash + Ord;\n     type ParamTy: Clone + Debug + Hash + Ord;\n     type BoundTy: Clone + Debug + Hash + Ord;\n@@ -67,6 +67,9 @@ pub trait Interner: Sized {\n     type FreeRegion: Clone + Debug + Hash + Ord;\n     type RegionVid: Clone + Debug + Hash + Ord;\n     type PlaceholderRegion: Clone + Debug + Hash + Ord;\n+\n+    fn ty_and_mut_to_parts(ty_and_mut: Self::TypeAndMut) -> (Self::Ty, Self::Mutability);\n+    fn mutability_is_mut(mutbl: Self::Mutability) -> bool;\n }\n \n /// Imagine you have a function `F: FnOnce(&[T]) -> R`, plus an iterator `iter`\n@@ -390,7 +393,19 @@ impl DebruijnIndex {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub fn debug_bound_var<T: std::fmt::Write>(\n+    fmt: &mut T,\n+    debruijn: DebruijnIndex,\n+    var: impl std::fmt::Debug,\n+) -> Result<(), std::fmt::Error> {\n+    if debruijn == INNERMOST {\n+        write!(fmt, \"^{:?}\", var)\n+    } else {\n+        write!(fmt, \"^{}_{:?}\", debruijn.index(), var)\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum IntTy {\n     Isize,\n@@ -448,7 +463,7 @@ impl IntTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum UintTy {\n     Usize,\n@@ -506,7 +521,7 @@ impl UintTy {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum FloatTy {\n     F32,"}, {"sha": "553d7f31b2d19e6e8cdf79b2213f923347da3582", "filename": "compiler/rustc_type_ir/src/structural_impls.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -4,11 +4,12 @@\n \n use crate::fold::{FallibleTypeFolder, TypeFoldable};\n use crate::visit::{TypeVisitable, TypeVisitor};\n-use crate::Interner;\n+use crate::{FloatTy, IntTy, Interner, UintTy};\n use rustc_data_structures::functor::IdFunctor;\n use rustc_data_structures::sync::Lrc;\n use rustc_index::{Idx, IndexVec};\n \n+use core::fmt;\n use std::ops::ControlFlow;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -163,3 +164,21 @@ impl<I: Interner, T: TypeVisitable<I>, Ix: Idx> TypeVisitable<I> for IndexVec<Ix\n         self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n+\n+impl fmt::Debug for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.name_str())\n+    }\n+}\n+\n+impl fmt::Debug for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.name_str())\n+    }\n+}\n+\n+impl fmt::Debug for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.name_str())\n+    }\n+}"}, {"sha": "fa18f921ee4ba5a98083522fc935c545cd7a4e15", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -294,7 +294,7 @@ impl<I: Interner> Clone for TyKind<I> {\n             Str => Str,\n             Array(t, c) => Array(t.clone(), c.clone()),\n             Slice(t) => Slice(t.clone()),\n-            RawPtr(t) => RawPtr(t.clone()),\n+            RawPtr(p) => RawPtr(p.clone()),\n             Ref(r, t, m) => Ref(r.clone(), t.clone(), m.clone()),\n             FnDef(d, s) => FnDef(d.clone(), s.clone()),\n             FnPtr(s) => FnPtr(s.clone()),\n@@ -499,33 +499,65 @@ impl<I: Interner> hash::Hash for TyKind<I> {\n impl<I: Interner> fmt::Debug for TyKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Bool => f.write_str(\"Bool\"),\n-            Char => f.write_str(\"Char\"),\n-            Int(i) => f.debug_tuple_field1_finish(\"Int\", i),\n-            Uint(u) => f.debug_tuple_field1_finish(\"Uint\", u),\n-            Float(float) => f.debug_tuple_field1_finish(\"Float\", float),\n+            Bool => write!(f, \"bool\"),\n+            Char => write!(f, \"char\"),\n+            Int(i) => write!(f, \"{i:?}\"),\n+            Uint(u) => write!(f, \"{u:?}\"),\n+            Float(float) => write!(f, \"{float:?}\"),\n             Adt(d, s) => f.debug_tuple_field2_finish(\"Adt\", d, s),\n             Foreign(d) => f.debug_tuple_field1_finish(\"Foreign\", d),\n-            Str => f.write_str(\"Str\"),\n-            Array(t, c) => f.debug_tuple_field2_finish(\"Array\", t, c),\n-            Slice(t) => f.debug_tuple_field1_finish(\"Slice\", t),\n-            RawPtr(t) => f.debug_tuple_field1_finish(\"RawPtr\", t),\n-            Ref(r, t, m) => f.debug_tuple_field3_finish(\"Ref\", r, t, m),\n+            Str => write!(f, \"str\"),\n+            Array(t, c) => write!(f, \"[{t:?}; {c:?}]\"),\n+            Slice(t) => write!(f, \"[{t:?}]\"),\n+            RawPtr(p) => {\n+                let (ty, mutbl) = I::ty_and_mut_to_parts(p.clone());\n+                match I::mutability_is_mut(mutbl) {\n+                    true => write!(f, \"*mut \"),\n+                    false => write!(f, \"*const \"),\n+                }?;\n+                write!(f, \"{ty:?}\")\n+            }\n+            Ref(r, t, m) => match I::mutability_is_mut(m.clone()) {\n+                true => write!(f, \"&{r:?} mut {t:?}\"),\n+                false => write!(f, \"&{r:?} {t:?}\"),\n+            },\n             FnDef(d, s) => f.debug_tuple_field2_finish(\"FnDef\", d, s),\n-            FnPtr(s) => f.debug_tuple_field1_finish(\"FnPtr\", s),\n-            Dynamic(p, r, repr) => f.debug_tuple_field3_finish(\"Dynamic\", p, r, repr),\n+            FnPtr(s) => write!(f, \"{s:?}\"),\n+            Dynamic(p, r, repr) => match repr {\n+                DynKind::Dyn => write!(f, \"dyn {p:?} + {r:?}\"),\n+                DynKind::DynStar => write!(f, \"dyn* {p:?} + {r:?}\"),\n+            },\n             Closure(d, s) => f.debug_tuple_field2_finish(\"Closure\", d, s),\n             Generator(d, s, m) => f.debug_tuple_field3_finish(\"Generator\", d, s, m),\n             GeneratorWitness(g) => f.debug_tuple_field1_finish(\"GeneratorWitness\", g),\n             GeneratorWitnessMIR(d, s) => f.debug_tuple_field2_finish(\"GeneratorWitnessMIR\", d, s),\n-            Never => f.write_str(\"Never\"),\n-            Tuple(t) => f.debug_tuple_field1_finish(\"Tuple\", t),\n+            Never => write!(f, \"!\"),\n+            Tuple(t) => {\n+                let mut iter = t.clone().into_iter();\n+\n+                write!(f, \"(\")?;\n+\n+                match iter.next() {\n+                    None => return write!(f, \")\"),\n+                    Some(ty) => write!(f, \"{ty:?}\")?,\n+                };\n+\n+                match iter.next() {\n+                    None => return write!(f, \",)\"),\n+                    Some(ty) => write!(f, \"{ty:?})\")?,\n+                }\n+\n+                for ty in iter {\n+                    write!(f, \", {ty:?}\")?;\n+                }\n+                write!(f, \")\")\n+            }\n             Alias(i, a) => f.debug_tuple_field2_finish(\"Alias\", i, a),\n-            Param(p) => f.debug_tuple_field1_finish(\"Param\", p),\n-            Bound(d, b) => f.debug_tuple_field2_finish(\"Bound\", d, b),\n-            Placeholder(p) => f.debug_tuple_field1_finish(\"Placeholder\", p),\n-            Infer(t) => f.debug_tuple_field1_finish(\"Infer\", t),\n-            TyKind::Error(e) => f.debug_tuple_field1_finish(\"Error\", e),\n+            Param(p) => write!(f, \"{p:?}\"),\n+            Bound(d, b) => crate::debug_bound_var(f, *d, b),\n+            Placeholder(p) => write!(f, \"{p:?}\"),\n+            Infer(t) => write!(f, \"{t:?}\"),\n+            TyKind::Error(_) => write!(f, \"{{type error}}\"),\n         }\n     }\n }"}, {"sha": "0ba5d088f6174212b720ba4d81799aa75e2d3f7c", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,3 +1,5 @@\n+#![cfg_attr(not(bootstrap), allow(invalid_from_utf8))]\n+\n use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::cmp::Ordering::{Equal, Greater, Less};"}, {"sha": "78091c0172955bd97394e28b83ddaffb501d7976", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -94,8 +94,9 @@ impl fmt::Display for AllocError {\n ///\n /// # Safety\n ///\n-/// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n-///   until the instance and all of its copies and clones are dropped,\n+/// * Memory blocks returned from an allocator that are [*currently allocated*] must point to\n+///   valid memory and retain their validity while they are [*currently allocated*] and at\n+///   least one of the instance and all of its clones has not been dropped.\n ///\n /// * copying, cloning, or moving the allocator must not invalidate memory blocks returned from this\n ///   allocator. A copied or cloned allocator must behave like the same allocator, and"}, {"sha": "76b3589b9e4b3c4223c043b0d3afc6d95dc9191b", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -538,29 +538,6 @@ impl<T, const N: usize> [T; N] {\n         drain_array_with(self, |iter| try_from_trusted_iterator(iter.map(f)))\n     }\n \n-    /// 'Zips up' two arrays into a single array of pairs.\n-    ///\n-    /// `zip()` returns a new array where every element is a tuple where the\n-    /// first element comes from the first array, and the second element comes\n-    /// from the second array. In other words, it zips two arrays together,\n-    /// into a single one.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(array_zip)]\n-    /// let x = [1, 2, 3];\n-    /// let y = [4, 5, 6];\n-    /// let z = x.zip(y);\n-    /// assert_eq!(z, [(1, 4), (2, 5), (3, 6)]);\n-    /// ```\n-    #[unstable(feature = \"array_zip\", issue = \"80094\")]\n-    pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        drain_array_with(self, |lhs| {\n-            drain_array_with(rhs, |rhs| from_trusted_iterator(crate::iter::zip(lhs, rhs)))\n-        })\n-    }\n-\n     /// Returns a slice containing the entire array. Equivalent to `&s[..]`.\n     #[stable(feature = \"array_as_slice\", since = \"1.57.0\")]\n     #[rustc_const_stable(feature = \"array_as_slice\", since = \"1.57.0\")]"}, {"sha": "462f7170a55b39ba0f382818b4c8432186c6f2e4", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -619,25 +619,26 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n     #[inline]\n     fn spec_next(&mut self) -> Option<T> {\n         if self.start < self.end {\n+            let old = self.start;\n             // SAFETY: just checked precondition\n-            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n-            Some(mem::replace(&mut self.start, n))\n+            self.start = unsafe { Step::forward_unchecked(old, 1) };\n+            Some(old)\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n     fn spec_nth(&mut self, n: usize) -> Option<T> {\n-        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n+        if let Some(plus_n) = Step::forward_checked(self.start, n) {\n             if plus_n < self.end {\n                 // SAFETY: just checked precondition\n-                self.start = unsafe { Step::forward_unchecked(plus_n.clone(), 1) };\n+                self.start = unsafe { Step::forward_unchecked(plus_n, 1) };\n                 return Some(plus_n);\n             }\n         }\n \n-        self.start = self.end.clone();\n+        self.start = self.end;\n         None\n     }\n \n@@ -655,7 +656,7 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n         // then steps_between either returns a bound to which we clamp or returns None which\n         // together with the initial inequality implies more than usize::MAX steps.\n         // Otherwise 0 is returned which always safe to use.\n-        self.start = unsafe { Step::forward_unchecked(self.start.clone(), taken) };\n+        self.start = unsafe { Step::forward_unchecked(self.start, taken) };\n \n         NonZeroUsize::new(n - taken).map_or(Ok(()), Err)\n     }\n@@ -664,24 +665,24 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n     fn spec_next_back(&mut self) -> Option<T> {\n         if self.start < self.end {\n             // SAFETY: just checked precondition\n-            self.end = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n-            Some(self.end.clone())\n+            self.end = unsafe { Step::backward_unchecked(self.end, 1) };\n+            Some(self.end)\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n     fn spec_nth_back(&mut self, n: usize) -> Option<T> {\n-        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n+        if let Some(minus_n) = Step::backward_checked(self.end, n) {\n             if minus_n > self.start {\n                 // SAFETY: just checked precondition\n                 self.end = unsafe { Step::backward_unchecked(minus_n, 1) };\n-                return Some(self.end.clone());\n+                return Some(self.end);\n             }\n         }\n \n-        self.end = self.start.clone();\n+        self.end = self.start;\n         None\n     }\n \n@@ -696,7 +697,7 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n         let taken = available.min(n);\n \n         // SAFETY: same as the spec_advance_by() implementation\n-        self.end = unsafe { Step::backward_unchecked(self.end.clone(), taken) };\n+        self.end = unsafe { Step::backward_unchecked(self.end, taken) };\n \n         NonZeroUsize::new(n - taken).map_or(Ok(()), Err)\n     }"}, {"sha": "c21a2aac1c9a697a4b0d0314bb3f916120d147d2", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -86,4 +86,4 @@ pub unsafe trait InPlaceIterable: Iterator {}\n /// for details. Consumers are free to rely on the invariants in unsafe code.\n #[unstable(feature = \"trusted_step\", issue = \"85731\")]\n #[rustc_specialization_trait]\n-pub unsafe trait TrustedStep: Step {}\n+pub unsafe trait TrustedStep: Step + Copy {}"}, {"sha": "0f23cf7ae239fbf07a27549af25c68665ac03a6e", "filename": "library/core/src/str/converts.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -84,6 +84,7 @@ use super::Utf8Error;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"const_str_from_utf8_shared\", since = \"1.63.0\")]\n #[rustc_allow_const_fn_unstable(str_internals)]\n+#[rustc_diagnostic_item = \"str_from_utf8\"]\n pub const fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     // FIXME: This should use `?` again, once it's `const`\n     match run_utf8_validation(v) {\n@@ -127,6 +128,7 @@ pub const fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n /// errors that can be returned.\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_str_from_utf8\", issue = \"91006\")]\n+#[rustc_diagnostic_item = \"str_from_utf8_mut\"]\n pub const fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n     // This should use `?` again, once it's `const`\n     match run_utf8_validation(v) {\n@@ -167,6 +169,7 @@ pub const fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_stable(feature = \"const_str_from_utf8_unchecked\", since = \"1.55.0\")]\n+#[rustc_diagnostic_item = \"str_from_utf8_unchecked\"]\n pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n     // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n     // Also relies on `&str` and `&[u8]` having the same layout.\n@@ -194,6 +197,7 @@ pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[must_use]\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_str_from_utf8_unchecked_mut\", issue = \"91005\")]\n+#[rustc_diagnostic_item = \"str_from_utf8_unchecked_mut\"]\n pub const unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n     // SAFETY: the caller must guarantee that the bytes `v`\n     // are valid UTF-8, thus the cast to `*mut str` is safe."}, {"sha": "d1732aaec2f924be6d41a9a2894e871ede1c200f", "filename": "library/portable-simd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fportable-simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fportable-simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FCargo.toml?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,5 +1,5 @@\n [workspace]\n-\n+resolver = \"1\"\n members = [\n     \"crates/core_simd\",\n     \"crates/std_float\","}, {"sha": "3ddb8748753e40c5b5ca440c82155c432e0e975c", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -127,6 +127,14 @@\n //! trait, which provides a [`from_wide`] method to convert a native Windows\n //! string (without the terminating nul character) to an [`OsString`].\n //!\n+//! ## On all platforms\n+//!\n+//! On all platforms, [`OsStr`] consists of a sequence of bytes that is encoded as a superset of\n+//! UTF-8; see [`OsString`] for more details on its encoding on different platforms.\n+//!\n+//! For limited, inexpensive conversions from and to bytes, see [`OsStr::as_os_str_bytes`] and\n+//! [`OsStr::from_os_str_bytes_unchecked`].\n+//!\n //! [Unicode scalar value]: https://www.unicode.org/glossary/#unicode_scalar_value\n //! [Unicode code point]: https://www.unicode.org/glossary/#code_point\n //! [`env::set_var()`]: crate::env::set_var \"env::set_var\""}, {"sha": "bb577acf769d4cdacf09688c045f56eb7343059e", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -667,6 +667,51 @@ impl OsStr {\n         s.as_ref()\n     }\n \n+    /// Converts a slice of bytes to an OS string slice without checking that the string contains\n+    /// valid `OsStr`-encoded data.\n+    ///\n+    /// The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n+    /// By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n+    /// ASCII.\n+    ///\n+    /// See the [module's toplevel documentation about conversions][conversions] for safe,\n+    /// cross-platform [conversions] from/to native representations.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As the encoding is unspecified, callers must pass in bytes that originated as a mixture of\n+    /// validated UTF-8 and bytes from [`OsStr::as_os_str_bytes`] from within the same rust version\n+    /// built for the same target platform.  For example, reconstructing an `OsStr` from bytes sent\n+    /// over the network or stored in a file will likely violate these safety rules.\n+    ///\n+    /// Due to the encoding being self-synchronizing, the bytes from [`OsStr::as_os_str_bytes`] can be\n+    /// split either immediately before or immediately after any valid non-empty UTF-8 substring.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(os_str_bytes)]\n+    ///\n+    /// use std::ffi::OsStr;\n+    ///\n+    /// let os_str = OsStr::new(\"Mary had a little lamb\");\n+    /// let bytes = os_str.as_os_str_bytes();\n+    /// let words = bytes.split(|b| *b == b' ');\n+    /// let words: Vec<&OsStr> = words.map(|word| {\n+    ///     // SAFETY:\n+    ///     // - Each `word` only contains content that originated from `OsStr::as_os_str_bytes`\n+    ///     // - Only split with ASCII whitespace which is a non-empty UTF-8 substring\n+    ///     unsafe { OsStr::from_os_str_bytes_unchecked(word) }\n+    /// }).collect();\n+    /// ```\n+    ///\n+    /// [conversions]: super#conversions\n+    #[inline]\n+    #[unstable(feature = \"os_str_bytes\", issue = \"111544\")]\n+    pub unsafe fn from_os_str_bytes_unchecked(bytes: &[u8]) -> &Self {\n+        Self::from_inner(Slice::from_os_str_bytes_unchecked(bytes))\n+    }\n+\n     #[inline]\n     fn from_inner(inner: &Slice) -> &OsStr {\n         // SAFETY: OsStr is just a wrapper of Slice,\n@@ -837,13 +882,24 @@ impl OsStr {\n         OsString { inner: Buf::from_box(boxed) }\n     }\n \n-    /// Gets the underlying byte representation.\n+    /// Converts an OS string slice to a byte slice.  To convert the byte slice back into an OS\n+    /// string slice, use the [`OsStr::from_os_str_bytes_unchecked`] function.\n+    ///\n+    /// The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n+    /// By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n+    /// ASCII.\n+    ///\n+    /// Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should\n+    /// be treated as opaque and only comparable within the same rust version built for the same\n+    /// target platform.  For example, sending the slice over the network or storing it in a file\n+    /// will likely result in incompatible byte slices.  See [`OsString`] for more encoding details\n+    /// and [`std::ffi`] for platform-specific, specified conversions.\n     ///\n-    /// Note: it is *crucial* that this API is not externally public, to avoid\n-    /// revealing the internal, platform-specific encodings.\n+    /// [`std::ffi`]: crate::ffi\n     #[inline]\n-    pub(crate) fn bytes(&self) -> &[u8] {\n-        unsafe { &*(&self.inner as *const _ as *const [u8]) }\n+    #[unstable(feature = \"os_str_bytes\", issue = \"111544\")]\n+    pub fn as_os_str_bytes(&self) -> &[u8] {\n+        self.inner.as_os_str_bytes()\n     }\n \n     /// Converts this string to its ASCII lower case equivalent in-place.\n@@ -1131,7 +1187,7 @@ impl Default for &OsStr {\n impl PartialEq for OsStr {\n     #[inline]\n     fn eq(&self, other: &OsStr) -> bool {\n-        self.bytes().eq(other.bytes())\n+        self.as_os_str_bytes().eq(other.as_os_str_bytes())\n     }\n }\n \n@@ -1158,23 +1214,23 @@ impl Eq for OsStr {}\n impl PartialOrd for OsStr {\n     #[inline]\n     fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> {\n-        self.bytes().partial_cmp(other.bytes())\n+        self.as_os_str_bytes().partial_cmp(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn lt(&self, other: &OsStr) -> bool {\n-        self.bytes().lt(other.bytes())\n+        self.as_os_str_bytes().lt(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn le(&self, other: &OsStr) -> bool {\n-        self.bytes().le(other.bytes())\n+        self.as_os_str_bytes().le(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn gt(&self, other: &OsStr) -> bool {\n-        self.bytes().gt(other.bytes())\n+        self.as_os_str_bytes().gt(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn ge(&self, other: &OsStr) -> bool {\n-        self.bytes().ge(other.bytes())\n+        self.as_os_str_bytes().ge(other.as_os_str_bytes())\n     }\n }\n \n@@ -1193,7 +1249,7 @@ impl PartialOrd<str> for OsStr {\n impl Ord for OsStr {\n     #[inline]\n     fn cmp(&self, other: &OsStr) -> cmp::Ordering {\n-        self.bytes().cmp(other.bytes())\n+        self.as_os_str_bytes().cmp(other.as_os_str_bytes())\n     }\n }\n \n@@ -1243,7 +1299,7 @@ impl_cmp!(Cow<'a, OsStr>, OsString);\n impl Hash for OsStr {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.bytes().hash(state)\n+        self.as_os_str_bytes().hash(state)\n     }\n }\n "}, {"sha": "28cd3c4e4dbd2d301c5728443571810f39c39015", "filename": "library/std/src/path.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -193,7 +193,7 @@ impl<'a> Prefix<'a> {\n     fn len(&self) -> usize {\n         use self::Prefix::*;\n         fn os_str_len(s: &OsStr) -> usize {\n-            s.bytes().len()\n+            s.as_os_str_bytes().len()\n         }\n         match *self {\n             Verbatim(x) => 4 + os_str_len(x),\n@@ -299,20 +299,6 @@ where\n     }\n }\n \n-unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n-    // SAFETY: See note at the top of this module to understand why this and\n-    // `OsStr::bytes` are used:\n-    //\n-    // This casts are safe as OsStr is internally a wrapper around [u8] on all\n-    // platforms.\n-    //\n-    // Note that currently this relies on the special knowledge that std has;\n-    // these types are single-element structs but are not marked\n-    // repr(transparent) or repr(C) which would make these casts not allowable\n-    // outside std.\n-    unsafe { &*(s as *const [u8] as *const OsStr) }\n-}\n-\n // Detect scheme on Redox\n fn has_redox_scheme(s: &[u8]) -> bool {\n     cfg!(target_os = \"redox\") && s.contains(&b':')\n@@ -330,26 +316,31 @@ fn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n \n // basic workhorse for splitting stem and extension\n fn rsplit_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n-    if file.bytes() == b\"..\" {\n+    if file.as_os_str_bytes() == b\"..\" {\n         return (Some(file), None);\n     }\n \n     // The unsafety here stems from converting between &OsStr and &[u8]\n     // and back. This is safe to do because (1) we only look at ASCII\n     // contents of the encoding and (2) new &OsStr values are produced\n     // only from ASCII-bounded slices of existing &OsStr values.\n-    let mut iter = file.bytes().rsplitn(2, |b| *b == b'.');\n+    let mut iter = file.as_os_str_bytes().rsplitn(2, |b| *b == b'.');\n     let after = iter.next();\n     let before = iter.next();\n     if before == Some(b\"\") {\n         (Some(file), None)\n     } else {\n-        unsafe { (before.map(|s| u8_slice_as_os_str(s)), after.map(|s| u8_slice_as_os_str(s))) }\n+        unsafe {\n+            (\n+                before.map(|s| OsStr::from_os_str_bytes_unchecked(s)),\n+                after.map(|s| OsStr::from_os_str_bytes_unchecked(s)),\n+            )\n+        }\n     }\n }\n \n fn split_file_at_dot(file: &OsStr) -> (&OsStr, Option<&OsStr>) {\n-    let slice = file.bytes();\n+    let slice = file.as_os_str_bytes();\n     if slice == b\"..\" {\n         return (file, None);\n     }\n@@ -364,7 +355,12 @@ fn split_file_at_dot(file: &OsStr) -> (&OsStr, Option<&OsStr>) {\n     };\n     let before = &slice[..i];\n     let after = &slice[i + 1..];\n-    unsafe { (u8_slice_as_os_str(before), Some(u8_slice_as_os_str(after))) }\n+    unsafe {\n+        (\n+            OsStr::from_os_str_bytes_unchecked(before),\n+            Some(OsStr::from_os_str_bytes_unchecked(after)),\n+        )\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -743,7 +739,7 @@ impl<'a> Components<'a> {\n             // separately via `include_cur_dir`\n             b\"..\" => Some(Component::ParentDir),\n             b\"\" => None,\n-            _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) })),\n+            _ => Some(Component::Normal(unsafe { OsStr::from_os_str_bytes_unchecked(comp) })),\n         }\n     }\n \n@@ -900,7 +896,7 @@ impl<'a> Iterator for Components<'a> {\n                     let raw = &self.path[..self.prefix_len()];\n                     self.path = &self.path[self.prefix_len()..];\n                     return Some(Component::Prefix(PrefixComponent {\n-                        raw: unsafe { u8_slice_as_os_str(raw) },\n+                        raw: unsafe { OsStr::from_os_str_bytes_unchecked(raw) },\n                         parsed: self.prefix.unwrap(),\n                     }));\n                 }\n@@ -972,7 +968,7 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.back = State::Done;\n                     return Some(Component::Prefix(PrefixComponent {\n-                        raw: unsafe { u8_slice_as_os_str(self.path) },\n+                        raw: unsafe { OsStr::from_os_str_bytes_unchecked(self.path) },\n                         parsed: self.prefix.unwrap(),\n                     }));\n                 }\n@@ -1481,17 +1477,17 @@ impl PathBuf {\n     fn _set_extension(&mut self, extension: &OsStr) -> bool {\n         let file_stem = match self.file_stem() {\n             None => return false,\n-            Some(f) => f.bytes(),\n+            Some(f) => f.as_os_str_bytes(),\n         };\n \n         // truncate until right after the file stem\n         let end_file_stem = file_stem[file_stem.len()..].as_ptr().addr();\n-        let start = self.inner.bytes().as_ptr().addr();\n+        let start = self.inner.as_os_str_bytes().as_ptr().addr();\n         let v = self.as_mut_vec();\n         v.truncate(end_file_stem.wrapping_sub(start));\n \n         // add the new extension, if any\n-        let new = extension.bytes();\n+        let new = extension.as_os_str_bytes();\n         if !new.is_empty() {\n             v.reserve_exact(new.len() + 1);\n             v.push(b'.');\n@@ -2011,11 +2007,11 @@ impl Path {\n     // The following (private!) function allows construction of a path from a u8\n     // slice, which is only safe when it is known to follow the OsStr encoding.\n     unsafe fn from_u8_slice(s: &[u8]) -> &Path {\n-        unsafe { Path::new(u8_slice_as_os_str(s)) }\n+        unsafe { Path::new(OsStr::from_os_str_bytes_unchecked(s)) }\n     }\n     // The following (private!) function reveals the byte encoding used for OsStr.\n     fn as_u8_slice(&self) -> &[u8] {\n-        self.inner.bytes()\n+        self.inner.as_os_str_bytes()\n     }\n \n     /// Directly wraps a string slice as a `Path` slice."}, {"sha": "963d17a47e4c022e3681ef96e1d8ab424855951d", "filename": "library/std/src/sys/common/small_c_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -19,7 +19,7 @@ pub fn run_path_with_cstr<T, F>(path: &Path, f: F) -> io::Result<T>\n where\n     F: FnOnce(&CStr) -> io::Result<T>,\n {\n-    run_with_cstr(path.as_os_str().bytes(), f)\n+    run_with_cstr(path.as_os_str().as_os_str_bytes(), f)\n }\n \n #[inline]"}, {"sha": "0a1cbcbe8ef3789ed3554b7ab5a5832a0bacebaa", "filename": "library/std/src/sys/common/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -8,7 +8,7 @@ use core::iter::repeat;\n fn stack_allocation_works() {\n     let path = Path::new(\"abc\");\n     let result = run_path_with_cstr(path, |p| {\n-        assert_eq!(p, &*CString::new(path.as_os_str().bytes()).unwrap());\n+        assert_eq!(p, &*CString::new(path.as_os_str().as_os_str_bytes()).unwrap());\n         Ok(42)\n     });\n     assert_eq!(result.unwrap(), 42);\n@@ -25,7 +25,7 @@ fn heap_allocation_works() {\n     let path = repeat(\"a\").take(384).collect::<String>();\n     let path = Path::new(&path);\n     let result = run_path_with_cstr(path, |p| {\n-        assert_eq!(p, &*CString::new(path.as_os_str().bytes()).unwrap());\n+        assert_eq!(p, &*CString::new(path.as_os_str().as_os_str_bytes()).unwrap());\n         Ok(42)\n     });\n     assert_eq!(result.unwrap(), 42);"}, {"sha": "142fcb9ed0b739f503781380f4330e82c611579e", "filename": "library/std/src/sys/unix/os_str.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -193,13 +193,18 @@ impl Buf {\n \n impl Slice {\n     #[inline]\n-    fn from_u8_slice(s: &[u8]) -> &Slice {\n+    pub fn as_os_str_bytes(&self) -> &[u8] {\n+        &self.inner\n+    }\n+\n+    #[inline]\n+    pub unsafe fn from_os_str_bytes_unchecked(s: &[u8]) -> &Slice {\n         unsafe { mem::transmute(s) }\n     }\n \n     #[inline]\n     pub fn from_str(s: &str) -> &Slice {\n-        Slice::from_u8_slice(s.as_bytes())\n+        unsafe { Slice::from_os_str_bytes_unchecked(s.as_bytes()) }\n     }\n \n     pub fn to_str(&self) -> Option<&str> {"}, {"sha": "91bc0e61a4a5baa41cd3f007e1a969af49efcab2", "filename": "library/std/src/sys/unix/os_str/tests.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn slice_debug_output() {\n-    let input = Slice::from_u8_slice(b\"\\xF0hello,\\tworld\");\n+    let input = unsafe { Slice::from_os_str_bytes_unchecked(b\"\\xF0hello,\\tworld\") };\n     let expected = r#\"\"\\xF0hello,\\tworld\"\"#;\n     let output = format!(\"{input:?}\");\n \n@@ -11,8 +11,7 @@ fn slice_debug_output() {\n \n #[test]\n fn display() {\n-    assert_eq!(\n-        \"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\",\n-        Slice::from_u8_slice(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string(),\n-    );\n+    assert_eq!(\"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\", unsafe {\n+        Slice::from_os_str_bytes_unchecked(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string()\n+    },);\n }"}, {"sha": "935245f637b8670b03f42416224899df1f2eb7b3", "filename": "library/std/src/sys/unix/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n \n     // Get the components, skipping the redundant leading \".\" component if it exists.\n     let mut components = path.strip_prefix(\".\").unwrap_or(path).components();\n-    let path_os = path.as_os_str().bytes();\n+    let path_os = path.as_os_str().as_os_str_bytes();\n \n     let mut normalized = if path.is_absolute() {\n         // \"If a pathname begins with two successive <slash> characters, the"}, {"sha": "640648e870748b4e60dc2100bcb5cfcc3a0ee92c", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -164,9 +164,9 @@ pub enum ProgramKind {\n \n impl ProgramKind {\n     fn new(program: &OsStr) -> Self {\n-        if program.bytes().starts_with(b\"/\") {\n+        if program.as_os_str_bytes().starts_with(b\"/\") {\n             Self::Absolute\n-        } else if program.bytes().contains(&b'/') {\n+        } else if program.as_os_str_bytes().contains(&b'/') {\n             // If the program has more than one component in it, it is a relative path.\n             Self::Relative\n         } else {"}, {"sha": "6b597f499bcdc18a2b74d8b4965c166faddc5e33", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -226,7 +226,7 @@ pub(crate) fn append_arg(cmd: &mut Vec<u16>, arg: &Arg, force_quotes: bool) -> i\n     // that it actually gets passed through on the command line or otherwise\n     // it will be dropped entirely when parsed on the other end.\n     ensure_no_nuls(arg)?;\n-    let arg_bytes = arg.bytes();\n+    let arg_bytes = arg.as_os_str_bytes();\n     let (quote, escape) = match quote {\n         Quote::Always => (true, true),\n         Quote::Auto => {\n@@ -297,7 +297,9 @@ pub(crate) fn make_bat_command_line(\n         // * `|<>` pipe/redirect characters.\n         const SPECIAL: &[u8] = b\"\\t &()[]{}^=;!'+,`~%|<>\";\n         let force_quotes = match arg {\n-            Arg::Regular(arg) if !force_quotes => arg.bytes().iter().any(|c| SPECIAL.contains(c)),\n+            Arg::Regular(arg) if !force_quotes => {\n+                arg.as_os_str_bytes().iter().any(|c| SPECIAL.contains(c))\n+            }\n             _ => force_quotes,\n         };\n         append_arg(&mut cmd, arg, force_quotes)?;"}, {"sha": "611f0d040f0eb74d6eb3f23b8bbda1eae5d80799", "filename": "library/std/src/sys/windows/os_str.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -151,6 +151,16 @@ impl Buf {\n }\n \n impl Slice {\n+    #[inline]\n+    pub fn as_os_str_bytes(&self) -> &[u8] {\n+        self.inner.as_bytes()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn from_os_str_bytes_unchecked(s: &[u8]) -> &Slice {\n+        mem::transmute(Wtf8::from_bytes_unchecked(s))\n+    }\n+\n     #[inline]\n     pub fn from_str(s: &str) -> &Slice {\n         unsafe { mem::transmute(Wtf8::from_str(s)) }"}, {"sha": "c9c2d10e6c444f42bddaef7294ca96b464ac577e", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,7 +1,6 @@\n use super::{c, fill_utf16_buf, to_u16s};\n use crate::ffi::{OsStr, OsString};\n use crate::io;\n-use crate::mem;\n use crate::path::{Path, PathBuf, Prefix};\n use crate::ptr;\n \n@@ -11,16 +10,6 @@ mod tests;\n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n \n-/// # Safety\n-///\n-/// `bytes` must be a valid wtf8 encoded slice\n-#[inline]\n-unsafe fn bytes_as_os_str(bytes: &[u8]) -> &OsStr {\n-    // &OsStr is layout compatible with &Slice, which is compatible with &Wtf8,\n-    // which is compatible with &[u8].\n-    mem::transmute(bytes)\n-}\n-\n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {\n     b == b'/' || b == b'\\\\'\n@@ -33,12 +22,12 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n \n /// Returns true if `path` looks like a lone filename.\n pub(crate) fn is_file_name(path: &OsStr) -> bool {\n-    !path.bytes().iter().copied().any(is_sep_byte)\n+    !path.as_os_str_bytes().iter().copied().any(is_sep_byte)\n }\n pub(crate) fn has_trailing_slash(path: &OsStr) -> bool {\n-    let is_verbatim = path.bytes().starts_with(br\"\\\\?\\\");\n+    let is_verbatim = path.as_os_str_bytes().starts_with(br\"\\\\?\\\");\n     let is_separator = if is_verbatim { is_verbatim_sep } else { is_sep_byte };\n-    if let Some(&c) = path.bytes().last() { is_separator(c) } else { false }\n+    if let Some(&c) = path.as_os_str_bytes().last() { is_separator(c) } else { false }\n }\n \n /// Appends a suffix to a path.\n@@ -60,7 +49,7 @@ impl<'a, const LEN: usize> PrefixParser<'a, LEN> {\n     fn get_prefix(path: &OsStr) -> [u8; LEN] {\n         let mut prefix = [0; LEN];\n         // SAFETY: Only ASCII characters are modified.\n-        for (i, &ch) in path.bytes().iter().take(LEN).enumerate() {\n+        for (i, &ch) in path.as_os_str_bytes().iter().take(LEN).enumerate() {\n             prefix[i] = if ch == b'/' { b'\\\\' } else { ch };\n         }\n         prefix\n@@ -93,15 +82,15 @@ impl<'a> PrefixParserSlice<'a, '_> {\n     }\n \n     fn prefix_bytes(&self) -> &'a [u8] {\n-        &self.path.bytes()[..self.index]\n+        &self.path.as_os_str_bytes()[..self.index]\n     }\n \n     fn finish(self) -> &'a OsStr {\n         // SAFETY: The unsafety here stems from converting between &OsStr and\n         // &[u8] and back. This is safe to do because (1) we only look at ASCII\n         // contents of the encoding and (2) new &OsStr values are produced only\n         // from ASCII-bounded slices of existing &OsStr values.\n-        unsafe { bytes_as_os_str(&self.path.bytes()[self.index..]) }\n+        unsafe { OsStr::from_os_str_bytes_unchecked(&self.path.as_os_str_bytes()[self.index..]) }\n     }\n }\n \n@@ -173,7 +162,7 @@ fn parse_drive(path: &OsStr) -> Option<u8> {\n         drive.is_ascii_alphabetic()\n     }\n \n-    match path.bytes() {\n+    match path.as_os_str_bytes() {\n         [drive, b':', ..] if is_valid_drive_letter(drive) => Some(drive.to_ascii_uppercase()),\n         _ => None,\n     }\n@@ -182,7 +171,7 @@ fn parse_drive(path: &OsStr) -> Option<u8> {\n // Parses a drive prefix exactly, e.g. \"C:\"\n fn parse_drive_exact(path: &OsStr) -> Option<u8> {\n     // only parse two bytes: the drive letter and the drive separator\n-    if path.bytes().get(2).map(|&x| is_sep_byte(x)).unwrap_or(true) {\n+    if path.as_os_str_bytes().get(2).map(|&x| is_sep_byte(x)).unwrap_or(true) {\n         parse_drive(path)\n     } else {\n         None\n@@ -196,21 +185,26 @@ fn parse_drive_exact(path: &OsStr) -> Option<u8> {\n fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n     let separator = if verbatim { is_verbatim_sep } else { is_sep_byte };\n \n-    match path.bytes().iter().position(|&x| separator(x)) {\n+    match path.as_os_str_bytes().iter().position(|&x| separator(x)) {\n         Some(separator_start) => {\n             let separator_end = separator_start + 1;\n \n-            let component = &path.bytes()[..separator_start];\n+            let component = &path.as_os_str_bytes()[..separator_start];\n \n             // Panic safe\n             // The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.\n-            let path = &path.bytes()[separator_end..];\n+            let path = &path.as_os_str_bytes()[separator_end..];\n \n             // SAFETY: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n             // is encoded in a single byte, therefore `bytes[separator_start]` and\n             // `bytes[separator_end]` must be code point boundaries and thus\n             // `bytes[..separator_start]` and `bytes[separator_end..]` are valid wtf8 slices.\n-            unsafe { (bytes_as_os_str(component), bytes_as_os_str(path)) }\n+            unsafe {\n+                (\n+                    OsStr::from_os_str_bytes_unchecked(component),\n+                    OsStr::from_os_str_bytes_unchecked(path),\n+                )\n+            }\n         }\n         None => (path, OsStr::new(\"\")),\n     }\n@@ -329,7 +323,7 @@ pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n     // Verbatim paths should not be modified.\n     if prefix.map(|x| x.is_verbatim()).unwrap_or(false) {\n         // NULs in verbatim paths are rejected for consistency.\n-        if path.bytes().contains(&0) {\n+        if path.as_os_str_bytes().contains(&0) {\n             return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n                 \"strings passed to WinAPI cannot contain NULs\","}, {"sha": "a573a05c39cd913c5482068b5686cde87a248aec", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -395,7 +395,7 @@ fn resolve_exe<'a>(\n     // Test if the file name has the `exe` extension.\n     // This does a case-insensitive `ends_with`.\n     let has_exe_suffix = if exe_path.len() >= EXE_SUFFIX.len() {\n-        exe_path.bytes()[exe_path.len() - EXE_SUFFIX.len()..]\n+        exe_path.as_os_str_bytes()[exe_path.len() - EXE_SUFFIX.len()..]\n             .eq_ignore_ascii_case(EXE_SUFFIX.as_bytes())\n     } else {\n         false\n@@ -425,7 +425,7 @@ fn resolve_exe<'a>(\n         // From the `CreateProcessW` docs:\n         // > If the file name does not contain an extension, .exe is appended.\n         // Note that this rule only applies when searching paths.\n-        let has_extension = exe_path.bytes().contains(&b'.');\n+        let has_extension = exe_path.as_os_str_bytes().contains(&b'.');\n \n         // Search the directories given by `search_paths`.\n         let result = search_paths(parent_paths, child_paths, |mut path| {"}, {"sha": "31bb0ad25a656a2b57b9a675607abae02443de37", "filename": "library/std/src/sys_common/wtf8.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -570,7 +570,7 @@ impl Wtf8 {\n     /// Since the byte slice is not checked for valid WTF-8, this functions is\n     /// marked unsafe.\n     #[inline]\n-    unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 {\n+    pub unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 {\n         mem::transmute(value)\n     }\n \n@@ -614,6 +614,12 @@ impl Wtf8 {\n         Wtf8CodePoints { bytes: self.bytes.iter() }\n     }\n \n+    /// Access raw bytes of WTF-8 data\n+    #[inline]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        &self.bytes\n+    }\n+\n     /// Tries to convert the string to UTF-8 and return a `&str` slice.\n     ///\n     /// Returns `None` if the string contains surrogates."}, {"sha": "43c859b00631e5ffdf36aeab37c9a0fb1ba359f9", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -103,11 +103,14 @@ impl RunConfig<'_> {\n     }\n \n     /// Return a list of crate names selected by `run.paths`.\n+    #[track_caller]\n     pub fn cargo_crates_in_set(&self) -> Interned<Vec<String>> {\n         let mut crates = Vec::new();\n         for krate in &self.paths {\n             let path = krate.assert_single_path();\n-            let crate_name = self.builder.crate_paths[&path.path];\n+            let Some(crate_name) = self.builder.crate_paths.get(&path.path) else {\n+                panic!(\"missing crate for path {}\", path.path.display())\n+            };\n             crates.push(crate_name.to_string());\n         }\n         INTERNER.intern_list(crates)\n@@ -378,7 +381,7 @@ impl StepDescription {\n             eprintln!(\n                 \"note: if you are adding a new Step to bootstrap itself, make sure you register it with `describe!`\"\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n     }\n }\n@@ -427,25 +430,6 @@ impl<'a> ShouldRun<'a> {\n         }\n     }\n \n-    /// Indicates it should run if the command-line selects the given crate or\n-    /// any of its (local) dependencies.\n-    ///\n-    /// Compared to `krate`, this treats the dependencies as aliases for the\n-    /// same job. Generally it is preferred to use `krate`, and treat each\n-    /// individual path separately. For example `./x.py test src/liballoc`\n-    /// (which uses `krate`) will test just `liballoc`. However, `./x.py check\n-    /// src/liballoc` (which uses `all_krates`) will check all of `libtest`.\n-    /// `all_krates` should probably be removed at some point.\n-    pub fn all_krates(mut self, name: &str) -> Self {\n-        let mut set = BTreeSet::new();\n-        for krate in self.builder.in_tree_crates(name, None) {\n-            let path = krate.local_path(self.builder);\n-            set.insert(TaskPath { path, kind: Some(self.kind) });\n-        }\n-        self.paths.insert(PathSet::Set(set));\n-        self\n-    }\n-\n     /// Indicates it should run if the command-line selects the given crate or\n     /// any of its (local) dependencies.\n     ///\n@@ -458,6 +442,8 @@ impl<'a> ShouldRun<'a> {\n     /// Indicates it should run if the command-line selects any of the given crates.\n     ///\n     /// `make_run` will be called a single time with all matching command-line paths.\n+    ///\n+    /// Prefer [`ShouldRun::crate_or_deps`] to this function where possible.\n     pub(crate) fn crates(mut self, crates: Vec<&Crate>) -> Self {\n         for krate in crates {\n             let path = krate.local_path(self.builder);\n@@ -487,7 +473,15 @@ impl<'a> ShouldRun<'a> {\n         self.paths(&[path])\n     }\n \n-    // multiple aliases for the same job\n+    /// Multiple aliases for the same job.\n+    ///\n+    /// This differs from [`path`] in that multiple calls to path will end up calling `make_run`\n+    /// multiple times, whereas a single call to `paths` will only ever generate a single call to\n+    /// `paths`.\n+    ///\n+    /// This is analogous to `all_krates`, although `all_krates` is gone now. Prefer [`path`] where possible.\n+    ///\n+    /// [`path`]: ShouldRun::path\n     pub fn paths(mut self, paths: &[&str]) -> Self {\n         static SUBMODULES_PATHS: OnceCell<Vec<String>> = OnceCell::new();\n \n@@ -641,12 +635,16 @@ impl Kind {\n         }\n     }\n \n-    pub fn test_description(&self) -> &'static str {\n+    pub fn description(&self) -> String {\n         match self {\n             Kind::Test => \"Testing\",\n             Kind::Bench => \"Benchmarking\",\n-            _ => panic!(\"not a test command: {}!\", self.as_str()),\n+            Kind::Doc => \"Documenting\",\n+            Kind::Run => \"Running\",\n+            Kind::Suggest => \"Suggesting\",\n+            _ => return format!(\"{self:?}\"),\n         }\n+        .to_owned()\n     }\n }\n \n@@ -1357,7 +1355,7 @@ impl<'a> Builder<'a> {\n                         \"error: `x.py clippy` requires a host `rustc` toolchain with the `clippy` component\"\n                     );\n                     eprintln!(\"help: try `rustup component add clippy`\");\n-                    crate::detail_exit(1);\n+                    crate::detail_exit_macro!(1);\n                 });\n                 if !t!(std::str::from_utf8(&output.stdout)).contains(\"nightly\") {\n                     rustflags.arg(\"--cfg=bootstrap\");"}, {"sha": "d76b830b0e530d62477b20d797101b0578366d0d", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::config::{Config, DryRun, TargetSelection};\n+use crate::doc::DocumentationFormat;\n use std::thread;\n \n fn configure(cmd: &str, host: &[&str], target: &[&str]) -> Config {\n@@ -66,6 +67,16 @@ macro_rules! std {\n     };\n }\n \n+macro_rules! doc_std {\n+    ($host:ident => $target:ident, stage = $stage:literal) => {\n+        doc::Std::new(\n+            $stage,\n+            TargetSelection::from_user(stringify!($target)),\n+            DocumentationFormat::HTML,\n+        )\n+    };\n+}\n+\n macro_rules! rustc {\n     ($host:ident => $target:ident, stage = $stage:literal) => {\n         compile::Rustc::new(\n@@ -144,6 +155,9 @@ fn alias_and_path_for_library() {\n         first(cache.all::<compile::Std>()),\n         &[std!(A => A, stage = 0), std!(A => A, stage = 1)]\n     );\n+\n+    let mut cache = run_build(&[\"library\".into(), \"core\".into()], configure(\"doc\", &[\"A\"], &[\"A\"]));\n+    assert_eq!(first(cache.all::<doc::Std>()), &[doc_std!(A => A, stage = 0)]);\n }\n \n #[test]"}, {"sha": "f5a93854bf2c4e1c4eda6d58b43bd47b5bb62dcd", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,8 +1,10 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n-use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n+use crate::builder::{crate_description, Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n-use crate::compile::{add_to_sysroot, run_cargo, rustc_cargo, rustc_cargo_env, std_cargo};\n+use crate::compile::{\n+    add_to_sysroot, make_run_crates, run_cargo, rustc_cargo, rustc_cargo_env, std_cargo,\n+};\n use crate::config::TargetSelection;\n use crate::tool::{prepare_tool_cargo, SourceType};\n use crate::INTERNER;\n@@ -12,6 +14,12 @@ use std::path::{Path, PathBuf};\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n     pub target: TargetSelection,\n+    /// Whether to build only a subset of crates.\n+    ///\n+    /// This shouldn't be used from other steps; see the comment on [`compile::Rustc`].\n+    ///\n+    /// [`compile::Rustc`]: crate::compile::Rustc\n+    crates: Interned<Vec<String>>,\n }\n \n /// Returns args for the subcommand itself (not for cargo)\n@@ -66,16 +74,23 @@ fn cargo_subcommand(kind: Kind) -> &'static str {\n     }\n }\n \n+impl Std {\n+    pub fn new(target: TargetSelection) -> Self {\n+        Self { target, crates: INTERNER.intern_list(vec![]) }\n+    }\n+}\n+\n impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"sysroot\").path(\"library\")\n+        run.crate_or_deps(\"sysroot\").path(\"library\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Std { target: run.target });\n+        let crates = make_run_crates(&run, \"library\");\n+        run.builder.ensure(Std { target: run.target, crates });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -97,7 +112,14 @@ impl Step for Std {\n             cargo.arg(\"--lib\");\n         }\n \n-        let _guard = builder.msg_check(\"library artifacts\", target);\n+        for krate in &*self.crates {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+\n+        let _guard = builder.msg_check(\n+            format_args!(\"library artifacts{}\", crate_description(&self.crates)),\n+            target,\n+        );\n         run_cargo(\n             builder,\n             cargo,\n@@ -117,7 +139,8 @@ impl Step for Std {\n         }\n \n         // don't run on std twice with x.py clippy\n-        if builder.kind == Kind::Clippy {\n+        // don't check test dependencies if we haven't built libtest\n+        if builder.kind == Kind::Clippy || !self.crates.is_empty() {\n             return;\n         }\n \n@@ -147,8 +170,8 @@ impl Step for Std {\n         // Explicitly pass -p for all dependencies krates -- this will force cargo\n         // to also check the tests/benches/examples for these crates, rather\n         // than just the leaf crate.\n-        for krate in builder.in_tree_crates(\"test\", Some(target)) {\n-            cargo.arg(\"-p\").arg(krate.name);\n+        for krate in &*self.crates {\n+            cargo.arg(\"-p\").arg(krate);\n         }\n \n         let _guard = builder.msg_check(\"library test/bench/example targets\", target);\n@@ -167,6 +190,22 @@ impl Step for Std {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n     pub target: TargetSelection,\n+    /// Whether to build only a subset of crates.\n+    ///\n+    /// This shouldn't be used from other steps; see the comment on [`compile::Rustc`].\n+    ///\n+    /// [`compile::Rustc`]: crate::compile::Rustc\n+    crates: Interned<Vec<String>>,\n+}\n+\n+impl Rustc {\n+    pub fn new(target: TargetSelection, builder: &Builder<'_>) -> Self {\n+        let mut crates = vec![];\n+        for krate in builder.in_tree_crates(\"rustc-main\", None) {\n+            crates.push(krate.name.to_string());\n+        }\n+        Self { target, crates: INTERNER.intern_list(crates) }\n+    }\n }\n \n impl Step for Rustc {\n@@ -175,11 +214,12 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"rustc-main\").path(\"compiler\")\n+        run.crate_or_deps(\"rustc-main\").path(\"compiler\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustc { target: run.target });\n+        let crates = make_run_crates(&run, \"compiler\");\n+        run.builder.ensure(Rustc { target: run.target, crates });\n     }\n \n     /// Builds the compiler.\n@@ -200,7 +240,7 @@ impl Step for Rustc {\n             builder.ensure(crate::compile::Std::new(compiler, compiler.host));\n             builder.ensure(crate::compile::Std::new(compiler, target));\n         } else {\n-            builder.ensure(Std { target });\n+            builder.ensure(Std::new(target));\n         }\n \n         let mut cargo = builder.cargo(\n@@ -218,14 +258,17 @@ impl Step for Rustc {\n             cargo.arg(\"--all-targets\");\n         }\n \n-        // Explicitly pass -p for all compiler krates -- this will force cargo\n+        // Explicitly pass -p for all compiler crates -- this will force cargo\n         // to also check the tests/benches/examples for these crates, rather\n         // than just the leaf crate.\n-        for krate in builder.in_tree_crates(\"rustc-main\", Some(target)) {\n-            cargo.arg(\"-p\").arg(krate.name);\n+        for krate in &*self.crates {\n+            cargo.arg(\"-p\").arg(krate);\n         }\n \n-        let _guard = builder.msg_check(\"compiler artifacts\", target);\n+        let _guard = builder.msg_check(\n+            format_args!(\"compiler artifacts{}\", crate_description(&self.crates)),\n+            target,\n+        );\n         run_cargo(\n             builder,\n             cargo,\n@@ -268,7 +311,7 @@ impl Step for CodegenBackend {\n         let target = self.target;\n         let backend = self.backend;\n \n-        builder.ensure(Rustc { target });\n+        builder.ensure(Rustc::new(target, builder));\n \n         let mut cargo = builder.cargo(\n             compiler,\n@@ -318,7 +361,7 @@ impl Step for RustAnalyzer {\n         let compiler = builder.compiler(builder.top_stage, builder.config.build);\n         let target = self.target;\n \n-        builder.ensure(Std { target });\n+        builder.ensure(Std::new(target));\n \n         let mut cargo = prepare_tool_cargo(\n             builder,\n@@ -386,7 +429,7 @@ macro_rules! tool_check_step {\n                 let compiler = builder.compiler(builder.top_stage, builder.config.build);\n                 let target = self.target;\n \n-                builder.ensure(Rustc { target });\n+                builder.ensure(Rustc::new(target, builder));\n \n                 let mut cargo = prepare_tool_cargo(\n                     builder,"}, {"sha": "1c66c00eda726f7e5ed3b92d5460f715cdab6f44", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -48,6 +48,17 @@ impl Std {\n     }\n }\n \n+/// Given an `alias` selected by the `Step` and the paths passed on the command line,\n+/// return a list of the crates that should be built.\n+///\n+/// Normally, people will pass *just* `library` if they pass it.\n+/// But it's possible (although strange) to pass something like `library std core`.\n+/// Build all crates anyway, as if they hadn't passed the other args.\n+pub(crate) fn make_run_crates(run: &RunConfig<'_>, alias: &str) -> Interned<Vec<String>> {\n+    let has_alias = run.paths.iter().any(|set| set.assert_single_path().path.ends_with(alias));\n+    if has_alias { Default::default() } else { run.cargo_crates_in_set() }\n+}\n+\n impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n@@ -62,16 +73,10 @@ impl Step for Std {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        // Normally, people will pass *just* library if they pass it.\n-        // But it's possible (although strange) to pass something like `library std core`.\n-        // Build all crates anyway, as if they hadn't passed the other args.\n-        let has_library =\n-            run.paths.iter().any(|set| set.assert_single_path().path.ends_with(\"library\"));\n-        let crates = if has_library { Default::default() } else { run.cargo_crates_in_set() };\n         run.builder.ensure(Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n             target: run.target,\n-            crates,\n+            crates: make_run_crates(&run, \"library\"),\n         });\n     }\n \n@@ -615,6 +620,8 @@ impl Step for Rustc {\n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let mut crates = run.builder.in_tree_crates(\"rustc-main\", None);\n         for (i, krate) in crates.iter().enumerate() {\n+            // We can't allow `build rustc` as an alias for this Step, because that's reserved by `Assemble`.\n+            // Ideally Assemble would use `build compiler` instead, but that seems too confusing to be worth the breaking change.\n             if krate.name == \"rustc-main\" {\n                 crates.swap_remove(i);\n                 break;\n@@ -1679,7 +1686,7 @@ pub fn run_cargo(\n     });\n \n     if !ok {\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     }\n \n     // Ok now we need to actually find all the files listed in `toplevel`. We've"}, {"sha": "45ad1547eb77159e103d1c6dad1d80b20e3f05f7", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -23,6 +23,7 @@ use crate::channel::{self, GitInfo};\n pub use crate::flags::Subcommand;\n use crate::flags::{Color, Flags, Warnings};\n use crate::util::{exe, output, t};\n+use build_helper::detail_exit_macro;\n use once_cell::sync::OnceCell;\n use serde::{Deserialize, Deserializer};\n use serde_derive::Deserialize;\n@@ -579,7 +580,7 @@ macro_rules! define_config {\n                                         panic!(\"overriding existing option\")\n                                     } else {\n                                         eprintln!(\"overriding existing option: `{}`\", stringify!($field));\n-                                        crate::detail_exit(2);\n+                                        detail_exit_macro!(2);\n                                     }\n                                 } else {\n                                     self.$field = other.$field;\n@@ -678,7 +679,7 @@ impl<T> Merge for Option<T> {\n                             panic!(\"overriding existing option\")\n                         } else {\n                             eprintln!(\"overriding existing option\");\n-                            crate::detail_exit(2);\n+                            detail_exit_macro!(2);\n                         }\n                     } else {\n                         *self = other;\n@@ -944,7 +945,7 @@ impl Config {\n                 .and_then(|table: toml::Value| TomlConfig::deserialize(table))\n                 .unwrap_or_else(|err| {\n                     eprintln!(\"failed to parse TOML configuration '{}': {err}\", file.display());\n-                    crate::detail_exit(2);\n+                    detail_exit_macro!(2);\n                 })\n         }\n         Self::parse_inner(args, get_toml)\n@@ -978,7 +979,7 @@ impl Config {\n             eprintln!(\n                 \"Cannot use both `llvm_bolt_profile_generate` and `llvm_bolt_profile_use` at the same time\"\n             );\n-            crate::detail_exit(1);\n+            detail_exit_macro!(1);\n         }\n \n         // Infer the rest of the configuration.\n@@ -1094,7 +1095,7 @@ impl Config {\n                 }\n             }\n             eprintln!(\"failed to parse override `{option}`: `{err}\");\n-            crate::detail_exit(2)\n+            detail_exit_macro!(2)\n         }\n         toml.merge(override_toml, ReplaceOpt::Override);\n \n@@ -1810,7 +1811,7 @@ impl Config {\n             println!(\"help: maybe your repository history is too shallow?\");\n             println!(\"help: consider disabling `download-rustc`\");\n             println!(\"help: or fetch enough history to include one upstream commit\");\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         // Warn if there were changes to the compiler or standard library since the ancestor commit."}, {"sha": "46fc5b80e99d48f12aa1b80663b6a8d49e2c415f", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -106,11 +106,7 @@ impl Step for JsonDocs {\n     /// Builds the `rust-docs-json` installer component.\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n-        builder.ensure(crate::doc::Std {\n-            stage: builder.top_stage,\n-            target: host,\n-            format: DocumentationFormat::JSON,\n-        });\n+        builder.ensure(crate::doc::Std::new(builder.top_stage, host, DocumentationFormat::JSON));\n \n         let dest = \"share/doc/rust/json\";\n "}, {"sha": "3de85c91516c4759d7e4452c87192d2ce294f2d8", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -7,7 +7,6 @@\n //! Everything here is basically just a shim around calling either `rustbook` or\n //! `rustdoc`.\n \n-use std::ffi::OsStr;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n@@ -16,6 +15,7 @@ use crate::builder::crate_description;\n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n+use crate::compile::make_run_crates;\n use crate::config::{Config, TargetSelection};\n use crate::tool::{self, prepare_tool_cargo, SourceType, Tool};\n use crate::util::{symlink_dir, t, up_to_date};\n@@ -87,15 +87,6 @@ book!(\n     StyleGuide, \"src/doc/style-guide\", \"style-guide\";\n );\n \n-// \"library/std\" -> [\"library\", \"std\"]\n-//\n-// Used for deciding whether a particular step is one requested by the user on\n-// the `x.py doc` command line, which determines whether `--open` will open that\n-// page.\n-pub(crate) fn components_simplified(path: &PathBuf) -> Vec<&str> {\n-    path.iter().map(|component| component.to_str().unwrap_or(\"???\")).collect()\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBook {\n     target: TargetSelection,\n@@ -425,11 +416,18 @@ impl Step for SharedAssets {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n pub struct Std {\n     pub stage: u32,\n     pub target: TargetSelection,\n     pub format: DocumentationFormat,\n+    crates: Interned<Vec<String>>,\n+}\n+\n+impl Std {\n+    pub(crate) fn new(stage: u32, target: TargetSelection, format: DocumentationFormat) -> Self {\n+        Std { stage, target, format, crates: INTERNER.intern_list(vec![]) }\n+    }\n }\n \n impl Step for Std {\n@@ -438,7 +436,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run.all_krates(\"sysroot\").path(\"library\").default_condition(builder.config.docs)\n+        run.crate_or_deps(\"sysroot\").path(\"library\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -450,14 +448,15 @@ impl Step for Std {\n             } else {\n                 DocumentationFormat::HTML\n             },\n+            crates: make_run_crates(&run, \"library\"),\n         });\n     }\n \n     /// Compile all standard library documentation.\n     ///\n     /// This will generate all documentation for the standard library and its\n     /// dependencies. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n+    fn run(mut self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         let out = match self.format {\n@@ -471,41 +470,24 @@ impl Step for Std {\n             builder.ensure(SharedAssets { target: self.target });\n         }\n \n-        let index_page = builder.src.join(\"src/doc/index.md\").into_os_string();\n+        let index_page = builder\n+            .src\n+            .join(\"src/doc/index.md\")\n+            .into_os_string()\n+            .into_string()\n+            .expect(\"non-utf8 paths are unsupported\");\n         let mut extra_args = match self.format {\n-            DocumentationFormat::HTML => vec![\n-                OsStr::new(\"--markdown-css\"),\n-                OsStr::new(\"rust.css\"),\n-                OsStr::new(\"--markdown-no-toc\"),\n-                OsStr::new(\"--index-page\"),\n-                &index_page,\n-            ],\n-            DocumentationFormat::JSON => vec![OsStr::new(\"--output-format\"), OsStr::new(\"json\")],\n+            DocumentationFormat::HTML => {\n+                vec![\"--markdown-css\", \"rust.css\", \"--markdown-no-toc\", \"--index-page\", &index_page]\n+            }\n+            DocumentationFormat::JSON => vec![\"--output-format\", \"json\"],\n         };\n \n         if !builder.config.docs_minification {\n-            extra_args.push(OsStr::new(\"--disable-minification\"));\n+            extra_args.push(\"--disable-minification\");\n         }\n \n-        let requested_crates = builder\n-            .paths\n-            .iter()\n-            .map(components_simplified)\n-            .filter_map(|path| {\n-                if path.len() >= 2 && path.get(0) == Some(&\"library\") {\n-                    // single crate\n-                    Some(path[1].to_owned())\n-                } else if !path.is_empty() {\n-                    // ??\n-                    Some(path[0].to_owned())\n-                } else {\n-                    // all library crates\n-                    None\n-                }\n-            })\n-            .collect::<Vec<_>>();\n-\n-        doc_std(builder, self.format, stage, target, &out, &extra_args, &requested_crates);\n+        doc_std(builder, self.format, stage, target, &out, &extra_args, &self.crates);\n \n         // Don't open if the format is json\n         if let DocumentationFormat::JSON = self.format {\n@@ -514,7 +496,11 @@ impl Step for Std {\n \n         // Look for library/std, library/core etc in the `x.py doc` arguments and\n         // open the corresponding rendered docs.\n-        for requested_crate in requested_crates {\n+        if self.crates.is_empty() {\n+            self.crates = INTERNER.intern_list(vec![\"library\".to_owned()]);\n+        };\n+\n+        for requested_crate in &*self.crates {\n             if requested_crate == \"library\" {\n                 // For `x.py doc library --open`, open `std` by default.\n                 let index = out.join(\"std\").join(\"index.html\");\n@@ -538,7 +524,7 @@ impl Step for Std {\n /// or remote link.\n const STD_PUBLIC_CRATES: [&str; 5] = [\"core\", \"alloc\", \"std\", \"proc_macro\", \"test\"];\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n pub enum DocumentationFormat {\n     HTML,\n     JSON,\n@@ -563,24 +549,22 @@ fn doc_std(\n     stage: u32,\n     target: TargetSelection,\n     out: &Path,\n-    extra_args: &[&OsStr],\n+    extra_args: &[&str],\n     requested_crates: &[String],\n ) {\n-    builder.info(&format!(\n-        \"Documenting{} stage{} library ({}) in {} format\",\n-        crate_description(requested_crates),\n-        stage,\n-        target,\n-        format.as_str()\n-    ));\n     if builder.no_std(target) == Some(true) {\n         panic!(\n             \"building std documentation for no_std target {target} is not supported\\n\\\n-             Set `docs = false` in the config to disable documentation.\"\n+             Set `docs = false` in the config to disable documentation, or pass `--exclude doc::library`.\"\n         );\n     }\n+\n     let compiler = builder.compiler(stage, builder.config.build);\n \n+    let description =\n+        format!(\"library{} in {} format\", crate_description(&requested_crates), format.as_str());\n+    let _guard = builder.msg(Kind::Doc, stage, &description, compiler.host, target);\n+\n     let target_doc_dir_name = if format == DocumentationFormat::JSON { \"json-doc\" } else { \"doc\" };\n     let target_dir =\n         builder.stage_out(compiler, Mode::Std).join(target.triple).join(target_doc_dir_name);\n@@ -590,42 +574,71 @@ fn doc_std(\n     // as a function parameter.\n     let out_dir = target_dir.join(target.triple).join(\"doc\");\n \n-    let run_cargo_rustdoc_for = |package: &str| {\n-        let mut cargo = builder.cargo(compiler, Mode::Std, SourceType::InTree, target, \"rustdoc\");\n-        compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n-        cargo\n-            .arg(\"--target-dir\")\n-            .arg(&*target_dir.to_string_lossy())\n-            .arg(\"-p\")\n-            .arg(package)\n-            .arg(\"-Zskip-rustdoc-fingerprint\")\n-            .arg(\"--\")\n-            .arg(\"-Z\")\n-            .arg(\"unstable-options\")\n-            .arg(\"--resource-suffix\")\n-            .arg(&builder.version)\n-            .args(extra_args);\n-        if builder.config.library_docs_private_items {\n-            cargo.arg(\"--document-private-items\").arg(\"--document-hidden-items\");\n-        }\n-        builder.run(&mut cargo.into());\n+    let mut cargo = builder.cargo(compiler, Mode::Std, SourceType::InTree, target, \"doc\");\n+    compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n+    cargo\n+        .arg(\"--no-deps\")\n+        .arg(\"--target-dir\")\n+        .arg(&*target_dir.to_string_lossy())\n+        .arg(\"-Zskip-rustdoc-fingerprint\")\n+        .rustdocflag(\"-Z\")\n+        .rustdocflag(\"unstable-options\")\n+        .rustdocflag(\"--resource-suffix\")\n+        .rustdocflag(&builder.version);\n+    for arg in extra_args {\n+        cargo.rustdocflag(arg);\n+    }\n+\n+    if builder.config.library_docs_private_items {\n+        cargo.rustdocflag(\"--document-private-items\").rustdocflag(\"--document-hidden-items\");\n+    }\n+\n+    // HACK: because we use `--manifest-path library/sysroot/Cargo.toml`, cargo thinks we only want to document that specific crate, not its dependencies.\n+    // Override its default.\n+    let built_crates = if requested_crates.is_empty() {\n+        builder\n+            .in_tree_crates(\"sysroot\", None)\n+            .into_iter()\n+            .map(|krate| krate.name.to_string())\n+            .collect()\n+    } else {\n+        requested_crates.to_vec()\n     };\n \n-    for krate in STD_PUBLIC_CRATES {\n-        run_cargo_rustdoc_for(krate);\n-        if requested_crates.iter().any(|p| p == krate) {\n-            // No need to document more of the libraries if we have the one we want.\n-            break;\n-        }\n+    for krate in built_crates {\n+        cargo.arg(\"-p\").arg(krate);\n     }\n \n+    builder.run(&mut cargo.into());\n     builder.cp_r(&out_dir, &out);\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     pub stage: u32,\n     pub target: TargetSelection,\n+    crates: Interned<Vec<String>>,\n+}\n+\n+impl Rustc {\n+    pub(crate) fn new(stage: u32, target: TargetSelection, builder: &Builder<'_>) -> Self {\n+        // Find dependencies for top level crates.\n+        let root_crates = vec![\n+            INTERNER.intern_str(\"rustc_driver\"),\n+            INTERNER.intern_str(\"rustc_codegen_llvm\"),\n+            INTERNER.intern_str(\"rustc_codegen_ssa\"),\n+        ];\n+        let crates: Vec<_> = root_crates\n+            .iter()\n+            .flat_map(|krate| {\n+                builder\n+                    .in_tree_crates(krate, Some(target))\n+                    .into_iter()\n+                    .map(|krate| krate.name.to_string())\n+            })\n+            .collect();\n+        Self { stage, target, crates: INTERNER.intern_list(crates) }\n+    }\n }\n \n impl Step for Rustc {\n@@ -641,7 +654,11 @@ impl Step for Rustc {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustc { stage: run.builder.top_stage, target: run.target });\n+        run.builder.ensure(Rustc {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+            crates: make_run_crates(&run, \"compiler\"),\n+        });\n     }\n \n     /// Generates compiler documentation.\n@@ -654,15 +671,6 @@ impl Step for Rustc {\n         let stage = self.stage;\n         let target = self.target;\n \n-        let paths = builder\n-            .paths\n-            .iter()\n-            .filter(|path| {\n-                let components = components_simplified(path);\n-                components.len() >= 2 && components[0] == \"compiler\"\n-            })\n-            .collect::<Vec<_>>();\n-\n         // This is the intended out directory for compiler documentation.\n         let out = builder.compiler_doc_out(target);\n         t!(fs::create_dir_all(&out));\n@@ -672,7 +680,13 @@ impl Step for Rustc {\n         let compiler = builder.compiler(stage, builder.config.build);\n         builder.ensure(compile::Std::new(compiler, builder.config.build));\n \n-        builder.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n+        let _guard = builder.msg(\n+            Kind::Doc,\n+            stage,\n+            &format!(\"compiler{}\", crate_description(&self.crates)),\n+            compiler.host,\n+            target,\n+        );\n \n         // This uses a shared directory so that librustdoc documentation gets\n         // correctly built and merged with the rustc documentation. This is\n@@ -710,22 +724,8 @@ impl Step for Rustc {\n         cargo.rustdocflag(\"--extern-html-root-url\");\n         cargo.rustdocflag(\"ena=https://docs.rs/ena/latest/\");\n \n-        let root_crates = if paths.is_empty() {\n-            vec![\n-                INTERNER.intern_str(\"rustc_driver\"),\n-                INTERNER.intern_str(\"rustc_codegen_llvm\"),\n-                INTERNER.intern_str(\"rustc_codegen_ssa\"),\n-            ]\n-        } else {\n-            paths.into_iter().map(|p| builder.crate_paths[p]).collect()\n-        };\n-        // Find dependencies for top level crates.\n-        let compiler_crates = root_crates.iter().flat_map(|krate| {\n-            builder.in_tree_crates(krate, Some(target)).into_iter().map(|krate| krate.name)\n-        });\n-\n         let mut to_open = None;\n-        for krate in compiler_crates {\n+        for krate in &*self.crates {\n             // Create all crate output directories first to make sure rustdoc uses\n             // relative links.\n             // FIXME: Cargo should probably do this itself.\n@@ -785,7 +785,7 @@ macro_rules! tool_doc {\n \n                 if true $(&& $rustc_tool)? {\n                     // Build rustc docs so that we generate relative links.\n-                    builder.ensure(Rustc { stage, target });\n+                    builder.ensure(Rustc::new(stage, target, builder));\n \n                     // Rustdoc needs the rustc sysroot available to build.\n                     // FIXME: is there a way to only ensure `check::Rustc` here? Last time I tried it failed"}, {"sha": "12780df21757a26b15d20f319e07190d5d11faa2", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -7,14 +7,15 @@ use std::{\n     process::{Command, Stdio},\n };\n \n+use build_helper::util::try_run;\n use once_cell::sync::OnceCell;\n use xz2::bufread::XzDecoder;\n \n use crate::{\n     config::RustfmtMetadata,\n     llvm::detect_llvm_sha,\n     t,\n-    util::{check_run, exe, program_out_of_date, try_run},\n+    util::{check_run, exe, program_out_of_date},\n     Config,\n };\n \n@@ -245,7 +246,7 @@ impl Config {\n             if !help_on_error.is_empty() {\n                 eprintln!(\"{}\", help_on_error);\n             }\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n     }\n "}, {"sha": "dc05f47ee9cd1a8c5f1edebc938fdd5ceaf574e9", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -193,7 +193,7 @@ impl Flags {\n             } else {\n                 panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n             }\n-            crate::detail_exit(0);\n+            crate::detail_exit_macro!(0);\n         }\n \n         Flags::parse_from(it)\n@@ -538,7 +538,7 @@ pub fn get_completion<G: clap_complete::Generator>(shell: G, path: &Path) -> Opt\n     } else {\n         std::fs::read_to_string(path).unwrap_or_else(|_| {\n             eprintln!(\"couldn't read {}\", path.display());\n-            crate::detail_exit(1)\n+            crate::detail_exit_macro!(1)\n         })\n     };\n     let mut buf = Vec::new();"}, {"sha": "ebf068b2cb16ee4cc1183daf66106510aaf0fbd7", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -40,7 +40,7 @@ fn rustfmt(src: &Path, rustfmt: &Path, paths: &[PathBuf], check: bool) -> impl F\n                         code, run `./x.py fmt` instead.\",\n                 cmd_debug,\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n         true\n     }\n@@ -196,7 +196,7 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n \n     let rustfmt_path = build.initial_rustfmt().unwrap_or_else(|| {\n         eprintln!(\"./x.py fmt is not supported on this channel\");\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     });\n     assert!(rustfmt_path.exists(), \"{}\", rustfmt_path.display());\n     let src = build.src.clone();"}, {"sha": "a1aaee68c625ded1c892633d29e7e891f62f5f17", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -27,6 +27,7 @@ use std::process::{Command, Stdio};\n use std::str;\n \n use build_helper::ci::{gha, CiEnv};\n+use build_helper::detail_exit_macro;\n use channel::GitInfo;\n use config::{DryRun, Target};\n use filetime::FileTime;\n@@ -699,7 +700,7 @@ impl Build {\n             for failure in failures.iter() {\n                 eprintln!(\"  - {}\\n\", failure);\n             }\n-            detail_exit(1);\n+            detail_exit_macro!(1);\n         }\n \n         #[cfg(feature = \"build-metrics\")]\n@@ -1020,8 +1021,8 @@ impl Build {\n         host: impl Into<Option<TargetSelection>>,\n         target: impl Into<Option<TargetSelection>>,\n     ) -> Option<gha::Group> {\n-        let action = action.into();\n-        let msg = |fmt| format!(\"{action:?}ing stage{stage} {what}{fmt}\");\n+        let action = action.into().description();\n+        let msg = |fmt| format!(\"{action} stage{stage} {what}{fmt}\");\n         let msg = if let Some(target) = target.into() {\n             let host = host.into().unwrap();\n             if host == target {\n@@ -1482,7 +1483,7 @@ impl Build {\n                 \"Error: Unable to find the stamp file {}, did you try to keep a nonexistent build stage?\",\n                 stamp.display()\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         let mut paths = Vec::new();\n@@ -1674,7 +1675,7 @@ Alternatively, set `download-ci-llvm = true` in that `[llvm]` section\n to download LLVM rather than building it.\n \"\n                 );\n-                detail_exit(1);\n+                detail_exit_macro!(1);\n             }\n         }\n \n@@ -1739,18 +1740,6 @@ fn chmod(path: &Path, perms: u32) {\n #[cfg(windows)]\n fn chmod(_path: &Path, _perms: u32) {}\n \n-/// If code is not 0 (successful exit status), exit status is 101 (rust's default error code.)\n-/// If the test is running and code is an error code, it will cause a panic.\n-fn detail_exit(code: i32) -> ! {\n-    // if in test and code is an error code, panic with status code provided\n-    if cfg!(test) {\n-        panic!(\"status code: {}\", code);\n-    } else {\n-        // otherwise,exit with provided status code\n-        std::process::exit(code);\n-    }\n-}\n-\n impl Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {\n         self.stage = stage;"}, {"sha": "872b75f6c1599889a72fd69744501ec722cdb523", "filename": "src/bootstrap/render_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Frender_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Frender_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frender_tests.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn try_run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n \n     if !run_tests(builder, cmd) {\n         if builder.fail_fast {\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         } else {\n             let mut failures = builder.delayed_failures.borrow_mut();\n             failures.push(format!(\"{cmd:?}\"));"}, {"sha": "8f5ba42736b1ffe6241f6662024696a020360170", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -104,7 +104,7 @@ You should install cmake, or set `download-ci-llvm = true` in the\n than building it.\n \"\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n     }\n "}, {"sha": "40038df8332105443cf6c7abcf2cca0b8cbdfb22", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -194,7 +194,7 @@ fn setup_config_toml(path: &PathBuf, profile: Profile, config: &Config) {\n             \"note: this will use the configuration in {}\",\n             profile.include_path(&config.src).display()\n         );\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     }\n \n     let settings = format!(\n@@ -380,7 +380,7 @@ pub fn interactive_path() -> io::Result<Profile> {\n         io::stdin().read_line(&mut input)?;\n         if input.is_empty() {\n             eprintln!(\"EOF on stdin, when expecting answer to question.  Giving up.\");\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n         break match parse_with_abbrev(&input) {\n             Ok(profile) => profile,"}, {"sha": "2924ba0bdf1c7e80b30bffe2e15ab96fd85da41e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -101,7 +101,7 @@ impl Step for CrateBootstrap {\n         );\n         builder.info(&format!(\n             \"{} {} stage0 ({})\",\n-            builder.kind.test_description(),\n+            builder.kind.description(),\n             path,\n             bootstrap_host,\n         ));\n@@ -220,7 +220,7 @@ impl Step for HtmlCheck {\n         }\n         // Ensure that a few different kinds of documentation are available.\n         builder.default_doc(&[]);\n-        builder.ensure(crate::doc::Rustc { target: self.target, stage: builder.top_stage });\n+        builder.ensure(crate::doc::Rustc::new(builder.top_stage, self.target, builder));\n \n         try_run(builder, builder.tool_cmd(Tool::HtmlChecker).arg(builder.doc_out(self.target)));\n     }\n@@ -773,7 +773,7 @@ impl Step for Clippy {\n         }\n \n         if !builder.config.cmd.bless() {\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         let mut cargo = builder.cargo(compiler, Mode::ToolRustc, SourceType::InTree, host, \"run\");\n@@ -886,11 +886,11 @@ impl Step for RustdocJSStd {\n                     command.arg(\"--test-file\").arg(path);\n                 }\n             }\n-            builder.ensure(crate::doc::Std {\n-                target: self.target,\n-                stage: builder.top_stage,\n-                format: DocumentationFormat::HTML,\n-            });\n+            builder.ensure(crate::doc::Std::new(\n+                builder.top_stage,\n+                self.target,\n+                DocumentationFormat::HTML,\n+            ));\n             builder.run(&mut command);\n         } else {\n             builder.info(\"No nodejs found, skipping \\\"tests/rustdoc-js-std\\\" tests\");\n@@ -1085,7 +1085,7 @@ help: to skip test's attempt to check tidiness, pass `--exclude src/tools/tidy`\n                     PATH = inferred_rustfmt_dir.display(),\n                     CHAN = builder.config.channel,\n                 );\n-                crate::detail_exit(1);\n+                crate::detail_exit_macro!(1);\n             }\n             crate::format::format(&builder, !builder.config.cmd.bless(), &[]);\n         }\n@@ -1108,7 +1108,7 @@ help: to skip test's attempt to check tidiness, pass `--exclude src/tools/tidy`\n                 eprintln!(\n                     \"x.py completions were changed; run `x.py run generate-completions` to update them\"\n                 );\n-                crate::detail_exit(1);\n+                crate::detail_exit_macro!(1);\n             }\n         }\n     }\n@@ -1329,7 +1329,7 @@ help: to test the compiler, use `--stage 1` instead\n help: to test the standard library, use `--stage 0 library/std` instead\n note: if you're sure you want to do this, please open an issue as to why. In the meantime, you can override this with `COMPILETEST_FORCE_STAGE0=1`.\"\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         let mut compiler = self.compiler;"}, {"sha": "0f0a3bb8775db3bec19573d7917aa28202fcba7d", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -116,7 +116,7 @@ impl Step for ToolBuild {\n \n         if !is_expected {\n             if !is_optional_tool {\n-                crate::detail_exit(1);\n+                crate::detail_exit_macro!(1);\n             } else {\n                 None\n             }"}, {"sha": "9c4d0ea265ddfa0f1b586a80421d904aa890e790", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -91,7 +91,7 @@ fn print_error(tool: &str, submodule: &str) {\n     eprintln!(\"If you do NOT intend to update '{}', please ensure you did not accidentally\", tool);\n     eprintln!(\"change the submodule at '{}'. You may ask your reviewer for the\", submodule);\n     eprintln!(\"proper steps.\");\n-    crate::detail_exit(3);\n+    crate::detail_exit_macro!(3);\n }\n \n fn check_changed_files(toolstates: &HashMap<Box<str>, ToolState>) {\n@@ -106,7 +106,7 @@ fn check_changed_files(toolstates: &HashMap<Box<str>, ToolState>) {\n         Ok(o) => o,\n         Err(e) => {\n             eprintln!(\"Failed to get changed files: {:?}\", e);\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n     };\n \n@@ -177,7 +177,7 @@ impl Step for ToolStateCheck {\n         }\n \n         if did_error {\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         check_changed_files(&toolstates);\n@@ -223,7 +223,7 @@ impl Step for ToolStateCheck {\n         }\n \n         if did_error {\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         if builder.config.channel == \"nightly\" && env::var_os(\"TOOLSTATE_PUBLISH\").is_some() {"}, {"sha": "e4bbccdb067c2dbf6b922395586ce52b75d3c469", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -3,6 +3,7 @@\n //! Simple things like testing the various filesystem operations here and there,\n //! not a lot of interesting happenings here unfortunately.\n \n+use build_helper::util::{fail, try_run};\n use std::env;\n use std::fs;\n use std::io;\n@@ -230,25 +231,10 @@ pub fn is_valid_test_suite_arg<'a, P: AsRef<Path>>(\n \n pub fn run(cmd: &mut Command, print_cmd_on_fail: bool) {\n     if !try_run(cmd, print_cmd_on_fail) {\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     }\n }\n \n-pub fn try_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n-    let status = match cmd.status() {\n-        Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e)),\n-    };\n-    if !status.success() && print_cmd_on_fail {\n-        println!(\n-            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n-             expected success, got: {}\\n\\n\",\n-            cmd, status\n-        );\n-    }\n-    status.success()\n-}\n-\n pub fn check_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n     let status = match cmd.status() {\n         Ok(status) => status,\n@@ -269,7 +255,7 @@ pub fn check_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n \n pub fn run_suppressed(cmd: &mut Command) {\n     if !try_run_suppressed(cmd) {\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     }\n }\n \n@@ -374,11 +360,6 @@ fn dir_up_to_date(src: &Path, threshold: SystemTime) -> bool {\n     })\n }\n \n-fn fail(s: &str) -> ! {\n-    eprintln!(\"\\n\\n{}\\n\\n\", s);\n-    crate::detail_exit(1);\n-}\n-\n /// Copied from `std::path::absolute` until it stabilizes.\n ///\n /// FIXME: this shouldn't exist."}, {"sha": "2d17cf7d47a8b0e5e3f6fa4dcccd537f9f72c209", "filename": "src/ci/docker/host-x86_64/test-various/uefi_qemu_test/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2FCargo.toml?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -4,6 +4,7 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [workspace]\n+resolver = \"1\"\n \n [dependencies]\n r-efi = \"4.1.0\""}, {"sha": "3ccca1e8b89bc7a06e669aee721e3da8d9fbd67a", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1 +1 @@\n-0.16.4\n\\ No newline at end of file\n+0.16.5\n\\ No newline at end of file"}, {"sha": "6d7b227d0ad3158540fed7581fb5c3c9a1fe8e4e", "filename": "src/etc/test-float-parse/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fetc%2Ftest-float-parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Fetc%2Ftest-float-parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2FCargo.toml?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -5,6 +5,7 @@ edition = \"2021\"\n publish = false\n \n [workspace]\n+resolver = \"1\"\n \n [dependencies]\n rand = \"0.4\""}, {"sha": "83887cc44b96b036a9eb746b3f545d5007a82137", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                 let infcx = cx.tcx.infer_ctxt().build();\n                 let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n                 let impl_ty = ty.subst(infcx.tcx, substs);\n-                let param_env = EarlyBinder::new(param_env).subst(infcx.tcx, substs);\n+                let param_env = EarlyBinder::bind(param_env).subst(infcx.tcx, substs);\n \n                 let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n                 let impl_trait_ref = trait_ref.subst(infcx.tcx, impl_substs);"}, {"sha": "5fd867189fd713551ee88c062868e51217720b0b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1111,8 +1111,8 @@ fn clean_fn_decl_with_args<'tcx>(\n     args: Arguments,\n ) -> FnDecl {\n     let output = match decl.output {\n-        hir::FnRetTy::Return(typ) => Return(clean_ty(typ, cx)),\n-        hir::FnRetTy::DefaultReturn(..) => DefaultReturn,\n+        hir::FnRetTy::Return(typ) => clean_ty(typ, cx),\n+        hir::FnRetTy::DefaultReturn(..) => Type::Tuple(Vec::new()),\n     };\n     FnDecl { inputs: args, output, c_variadic: decl.c_variadic }\n }\n@@ -1126,10 +1126,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n \n     // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,\n     // but shouldn't change any code meaning.\n-    let output = match clean_middle_ty(sig.output(), cx, None) {\n-        Type::Tuple(inner) if inner.is_empty() => DefaultReturn,\n-        ty => Return(ty),\n-    };\n+    let output = clean_middle_ty(sig.output(), cx, None);\n \n     FnDecl {\n         output,"}, {"sha": "1999a6b671d3a6b2c65232495260318e2b7928d7", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -42,7 +42,6 @@ use crate::formats::item_type::ItemType;\n use crate::html::render::Context;\n use crate::passes::collect_intra_doc_links::UrlFragment;\n \n-pub(crate) use self::FnRetTy::*;\n pub(crate) use self::ItemKind::*;\n pub(crate) use self::SelfTy::*;\n pub(crate) use self::Type::{\n@@ -1353,7 +1352,7 @@ pub(crate) struct Function {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub(crate) struct FnDecl {\n     pub(crate) inputs: Arguments,\n-    pub(crate) output: FnRetTy,\n+    pub(crate) output: Type,\n     pub(crate) c_variadic: bool,\n }\n \n@@ -1371,18 +1370,16 @@ impl FnDecl {\n     ///\n     /// This function will panic if the return type does not match the expected sugaring for async\n     /// functions.\n-    pub(crate) fn sugared_async_return_type(&self) -> FnRetTy {\n-        match &self.output {\n-            FnRetTy::Return(Type::ImplTrait(bounds)) => match &bounds[0] {\n-                GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n-                    let bindings = trait_.bindings().unwrap();\n-                    let ret_ty = bindings[0].term();\n-                    let ty = ret_ty.ty().expect(\"Unexpected constant return term\");\n-                    FnRetTy::Return(ty.clone())\n-                }\n-                _ => panic!(\"unexpected desugaring of async function\"),\n-            },\n-            _ => panic!(\"unexpected desugaring of async function\"),\n+    pub(crate) fn sugared_async_return_type(&self) -> Type {\n+        if let Type::ImplTrait(v) = &self.output &&\n+            let [GenericBound::TraitBound(PolyTrait { trait_, .. }, _ )] = &v[..]\n+        {\n+            let bindings = trait_.bindings().unwrap();\n+            let ret_ty = bindings[0].term();\n+            let ty = ret_ty.ty().expect(\"Unexpected constant return term\");\n+            ty.clone()\n+        } else {\n+            panic!(\"unexpected desugaring of async function\")\n         }\n     }\n }\n@@ -1425,21 +1422,6 @@ impl Argument {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub(crate) enum FnRetTy {\n-    Return(Type),\n-    DefaultReturn,\n-}\n-\n-impl FnRetTy {\n-    pub(crate) fn as_return(&self) -> Option<&Type> {\n-        match self {\n-            Return(ret) => Some(ret),\n-            DefaultReturn => None,\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub(crate) struct Trait {\n     pub(crate) def_id: DefId,\n@@ -1641,6 +1623,10 @@ impl Type {\n         matches!(self, Type::ImplTrait(_))\n     }\n \n+    pub(crate) fn is_unit(&self) -> bool {\n+        matches!(self, Type::Tuple(v) if v.is_empty())\n+    }\n+\n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath(box QPathData { self_type, trait_, assoc, .. }) = self {\n             Some((self_type, trait_.as_ref()?.def_id(), assoc.clone()))"}, {"sha": "f26d74629dd941c6756afb0017810f6d43dc36cb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1257,9 +1257,9 @@ impl clean::Impl {\n                 };\n                 primitive_link_fragment(f, PrimitiveType::Tuple, &format!(\"fn ({name}\u2081, {name}\u2082, \u2026, {name}\u2099{ellipsis})\"), \"#trait-implementations-1\", cx)?;\n                 // Write output.\n-                if let clean::FnRetTy::Return(ty) = &bare_fn.decl.output {\n+                if !bare_fn.decl.output.is_unit() {\n                     write!(f, \" -> \")?;\n-                    fmt_type(ty, f, use_absolute, cx)?;\n+                    fmt_type(&bare_fn.decl.output, f, use_absolute, cx)?;\n                 }\n             } else if let Some(ty) = self.kind.as_blanket_ty() {\n                 fmt_type(ty, f, use_absolute, cx)?;\n@@ -1296,22 +1296,6 @@ impl clean::Arguments {\n     }\n }\n \n-impl clean::FnRetTy {\n-    pub(crate) fn print<'a, 'tcx: 'a>(\n-        &'a self,\n-        cx: &'a Context<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        display_fn(move |f| match self {\n-            clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ty) if f.alternate() => {\n-                write!(f, \" -> {:#}\", ty.print(cx))\n-            }\n-            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cx)),\n-            clean::DefaultReturn => Ok(()),\n-        })\n-    }\n-}\n-\n impl clean::BareFunctionDecl {\n     fn print_hrtb_with_space<'a, 'tcx: 'a>(\n         &'a self,\n@@ -1366,15 +1350,15 @@ impl clean::FnDecl {\n                     \"({args:#}{ellipsis}){arrow:#}\",\n                     args = self.inputs.print(cx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cx)\n+                    arrow = self.print_output(cx)\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"({args}{ellipsis}){arrow}\",\n                     args = self.inputs.print(cx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cx)\n+                    arrow = self.print_output(cx)\n                 )\n             }\n         })\n@@ -1464,9 +1448,22 @@ impl clean::FnDecl {\n             Some(n) => write!(f, \"\\n{})\", Indent(n))?,\n         };\n \n-        fmt::Display::fmt(&self.output.print(cx), f)?;\n+        fmt::Display::fmt(&self.print_output(cx), f)?;\n         Ok(())\n     }\n+\n+    pub(crate) fn print_output<'a, 'tcx: 'a>(\n+        &'a self,\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        display_fn(move |f| match &self.output {\n+            clean::Tuple(tys) if tys.is_empty() => Ok(()),\n+            ty if f.alternate() => {\n+                write!(f, \" -> {:#}\", ty.print(cx))\n+            }\n+            ty => write!(f, \" -&gt; {}\", ty.print(cx)),\n+        })\n+    }\n }\n \n pub(crate) fn visibility_print_with_space<'a, 'tcx: 'a>("}, {"sha": "a5223bd6309d707b28f5f95b9f3b13e2187ccc74", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -844,7 +844,7 @@ fn assoc_method(\n         + name.as_str().len()\n         + generics_len;\n \n-    let notable_traits = d.output.as_return().and_then(|output| notable_traits_button(output, cx));\n+    let notable_traits = notable_traits_button(&d.output, cx);\n \n     let (indent, indent_str, end_newline) = if parent == ItemType::Trait {\n         header_len += 4;\n@@ -1282,6 +1282,11 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n pub(crate) fn notable_traits_button(ty: &clean::Type, cx: &mut Context<'_>) -> Option<String> {\n     let mut has_notable_trait = false;\n \n+    if ty.is_unit() {\n+        // Very common fast path.\n+        return None;\n+    }\n+\n     let did = ty.def_id(cx.cache())?;\n \n     // Box has pass-through impls for Read, Write, Iterator, and Future when the"}, {"sha": "21f61acb2c53f86c569b478b8f2992c1a1ea1765", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -587,8 +587,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n         + name.as_str().len()\n         + generics_len;\n \n-    let notable_traits =\n-        f.decl.output.as_return().and_then(|output| notable_traits_button(output, cx));\n+    let notable_traits = notable_traits_button(&f.decl.output, cx);\n \n     wrap_item(w, |w| {\n         w.reserve(header_len);\n@@ -1420,30 +1419,36 @@ fn item_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n-fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n-    wrap_item(w, |w| {\n+fn item_proc_macro(\n+    w: &mut impl fmt::Write,\n+    cx: &mut Context<'_>,\n+    it: &clean::Item,\n+    m: &clean::ProcMacro,\n+) {\n+    let mut buffer = Buffer::new();\n+    wrap_item(&mut buffer, |buffer| {\n         let name = it.name.expect(\"proc-macros always have names\");\n         match m.kind {\n             MacroKind::Bang => {\n-                write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n+                write!(buffer, \"{}!() {{ /* proc-macro */ }}\", name);\n             }\n             MacroKind::Attr => {\n-                write!(w, \"#[{}]\", name);\n+                write!(buffer, \"#[{}]\", name);\n             }\n             MacroKind::Derive => {\n-                write!(w, \"#[derive({})]\", name);\n+                write!(buffer, \"#[derive({})]\", name);\n                 if !m.helpers.is_empty() {\n-                    w.push_str(\"\\n{\\n\");\n-                    w.push_str(\"    // Attributes available to this derive:\\n\");\n+                    buffer.push_str(\"\\n{\\n\");\n+                    buffer.push_str(\"    // Attributes available to this derive:\\n\");\n                     for attr in &m.helpers {\n-                        writeln!(w, \"    #[{}]\", attr);\n+                        writeln!(buffer, \"    #[{}]\", attr);\n                     }\n-                    w.push_str(\"}\\n\");\n+                    buffer.push_str(\"}\\n\");\n                 }\n             }\n         }\n     });\n-    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n+    write!(w, \"{}{}\", buffer.into_inner(), document(cx, it, None, HeadingOffset::H2)).unwrap();\n }\n \n fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {"}, {"sha": "f34be120d292b94f12acbbfdd4c8bdbaebc26ead", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -7,7 +7,7 @@ use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n-use crate::clean::types::{FnRetTy, Function, Generics, ItemId, Type, WherePredicate};\n+use crate::clean::types::{Function, Generics, ItemId, Type, WherePredicate};\n use crate::formats::cache::{Cache, OrphanImplItem};\n use crate::formats::item_type::ItemType;\n use crate::html::format::join_with_double_colon;\n@@ -656,22 +656,9 @@ fn get_fn_inputs_and_outputs<'tcx>(\n     }\n \n     let mut ret_types = Vec::new();\n-    match decl.output {\n-        FnRetTy::Return(ref return_type) => {\n-            add_generics_and_bounds_as_types(\n-                self_,\n-                generics,\n-                return_type,\n-                tcx,\n-                0,\n-                &mut ret_types,\n-                cache,\n-            );\n-            if ret_types.is_empty() {\n-                ret_types.push(get_index_type(return_type, vec![]));\n-            }\n-        }\n-        _ => {}\n-    };\n+    add_generics_and_bounds_as_types(self_, generics, &decl.output, tcx, 0, &mut ret_types, cache);\n+    if ret_types.is_empty() {\n+        ret_types.push(get_index_type(&decl.output, vec![]));\n+    }\n     (all_types, ret_types)\n }"}, {"sha": "91cd55b1113abd51763e1b95029f3f7ea65e3c39", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -624,10 +624,7 @@ impl FromWithTcx<clean::FnDecl> for FnDecl {\n                 .into_iter()\n                 .map(|arg| (arg.name.to_string(), arg.type_.into_tcx(tcx)))\n                 .collect(),\n-            output: match output {\n-                clean::FnRetTy::Return(t) => Some(t.into_tcx(tcx)),\n-                clean::FnRetTy::DefaultReturn => None,\n-            },\n+            output: if output.is_unit() { None } else { Some(output.into_tcx(tcx)) },\n             c_variadic,\n         }\n     }"}, {"sha": "abb9229fbd51a9bc58605caac389a3ea98d38c0b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -267,6 +267,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline)\n             || use_attrs.lists(sym::doc).has_word(sym::hidden);\n \n+        if is_no_inline {\n+            return false;\n+        }\n+\n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously unreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n@@ -281,31 +285,38 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         };\n \n         let is_private = !self.cx.cache.effective_visibilities.is_directly_public(tcx, ori_res_did);\n-        let is_hidden = inherits_doc_hidden(tcx, res_did, None);\n+        let is_hidden = tcx.is_doc_hidden(ori_res_did);\n+        let item = tcx.hir().get_by_def_id(res_did);\n \n-        // Only inline if requested or if the item would otherwise be stripped.\n-        if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n-            return false;\n-        }\n-\n-        if !please_inline &&\n-            let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n+        if !please_inline {\n+            let inherits_hidden = inherits_doc_hidden(tcx, res_did, None);\n+            // Only inline if requested or if the item would otherwise be stripped.\n+            //\n+            // If it's a doc hidden module, we need to keep it in case some of its inner items\n+            // are re-exported.\n+            if (!is_private && !inherits_hidden) || (\n+                is_hidden &&\n+                !matches!(item, Node::Item(&hir::Item { kind: hir::ItemKind::Mod(_), .. }))\n+            ) {\n+                return false;\n+            } else if let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n                 .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n                 .chain(iter::once(res_did)).nth(1) &&\n-            item_def_id != def_id &&\n-            self\n-                .cx\n-                .cache\n-                .effective_visibilities\n-                .is_directly_public(tcx, item_def_id.to_def_id()) &&\n-            !inherits_doc_hidden(tcx, item_def_id, None)\n-        {\n-            // The imported item is public and not `doc(hidden)` so no need to inline it.\n-            return false;\n+                item_def_id != def_id &&\n+                self\n+                    .cx\n+                    .cache\n+                    .effective_visibilities\n+                    .is_directly_public(tcx, item_def_id.to_def_id()) &&\n+                !inherits_doc_hidden(tcx, item_def_id, None)\n+            {\n+                // The imported item is public and not `doc(hidden)` so no need to inline it.\n+                return false;\n+            }\n         }\n \n         let is_bang_macro = matches!(\n-            tcx.hir().get_by_def_id(res_did),\n+            item,\n             Node::Item(&hir::Item { kind: hir::ItemKind::Macro(_, MacroKind::Bang), .. })\n         );\n \n@@ -317,12 +328,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             // Bang macros are handled a bit on their because of how they are handled by the\n             // compiler. If they have `#[doc(hidden)]` and the re-export doesn't have\n             // `#[doc(inline)]`, then we don't inline it.\n-            Node::Item(_)\n-                if is_bang_macro\n-                    && !please_inline\n-                    && renamed.is_some()\n-                    && self.cx.tcx.is_doc_hidden(ori_res_did) =>\n-            {\n+            Node::Item(_) if is_bang_macro && !please_inline && renamed.is_some() && is_hidden => {\n                 return false;\n             }\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n@@ -455,6 +461,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             is_glob,\n                             please_inline,\n                         ) {\n+                            debug!(\"Inlining {:?}\", item.owner_id.def_id);\n                             continue;\n                         }\n                     }"}, {"sha": "3fa970373b3fb85a99923c58cead5a777103a5c2", "filename": "src/tools/build_helper/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fbuild_helper%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fbuild_helper%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild_helper%2Fsrc%2Flib.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,2 +1,3 @@\n pub mod ci;\n pub mod git;\n+pub mod util;"}, {"sha": "731095023a96e8bbae1a1ef60509552acfd9fea4", "filename": "src/tools/build_helper/src/util.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fbuild_helper%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fbuild_helper%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild_helper%2Fsrc%2Futil.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,41 @@\n+use std::process::Command;\n+\n+/// Invokes `build_helper::util::detail_exit` with `cfg!(test)`\n+#[macro_export]\n+macro_rules! detail_exit_macro {\n+    ($code:expr) => {\n+        build_helper::util::detail_exit($code, cfg!(test));\n+    };\n+}\n+\n+/// If code is not 0 (successful exit status), exit status is 101 (rust's default error code.)\n+/// If `is_test` true and code is an error code, it will cause a panic.\n+pub fn detail_exit(code: i32, is_test: bool) -> ! {\n+    // if in test and code is an error code, panic with status code provided\n+    if is_test {\n+        panic!(\"status code: {}\", code);\n+    } else {\n+        // otherwise,exit with provided status code\n+        std::process::exit(code);\n+    }\n+}\n+\n+pub fn fail(s: &str) -> ! {\n+    eprintln!(\"\\n\\n{}\\n\\n\", s);\n+    detail_exit(1, cfg!(test));\n+}\n+\n+pub fn try_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n+    let status = match cmd.status() {\n+        Ok(status) => status,\n+        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e)),\n+    };\n+    if !status.success() && print_cmd_on_fail {\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n\\n\",\n+            cmd, status\n+        );\n+    }\n+    status.success()\n+}"}, {"sha": "f7b95e31642e09c2b6eabb18ed75007dda6677a0", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1 +1 @@\n-Subproject commit 64fb38c97ac4d3a327fc9032c862dd28c8833b17\n+Subproject commit f7b95e31642e09c2b6eabb18ed75007dda6677a0"}, {"sha": "0ae95b045e03ce634e48c773b7f3c0c6c33067d9", "filename": "src/tools/clippy/clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -212,7 +212,6 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::instant_subtraction::UNCHECKED_DURATION_SUBTRACTION_INFO,\n     crate::int_plus_one::INT_PLUS_ONE_INFO,\n     crate::invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS_INFO,\n-    crate::invalid_utf8_in_unchecked::INVALID_UTF8_IN_UNCHECKED_INFO,\n     crate::items_after_statements::ITEMS_AFTER_STATEMENTS_INFO,\n     crate::items_after_test_module::ITEMS_AFTER_TEST_MODULE_INFO,\n     crate::iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR_INFO,"}, {"sha": "a1d2147cb496592c3e0028ac49b32b0ad82a1792", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1219,7 +1219,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n                 return false;\n             }\n \n-            let predicate = EarlyBinder::new(predicate).subst(cx.tcx, &substs_with_referent_ty);\n+            let predicate = EarlyBinder::bind(predicate).subst(cx.tcx, &substs_with_referent_ty);\n             let obligation = Obligation::new(cx.tcx, ObligationCause::dummy(), cx.param_env, predicate);\n             let infcx = cx.tcx.infer_ctxt().build();\n             infcx.predicate_must_hold_modulo_regions(&obligation)"}, {"sha": "c919b4de65dea38fded783e10a5dac91c3f71b26", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -243,7 +243,7 @@ fn get_ufcs_type_name<'tcx>(cx: &LateContext<'tcx>, method_def_id: DefId, substs\n                 | ty::Ref(..)\n                 | ty::Slice(_)\n                 | ty::Tuple(_) => {\n-                    format!(\"<{}>\", EarlyBinder::new(ty).subst(cx.tcx, substs))\n+                    format!(\"<{}>\", EarlyBinder::bind(ty).subst(cx.tcx, substs))\n                 },\n                 _ => ty.to_string(),\n             }"}, {"sha": "6a4861747d267c83663ca3e405a8d61d13564c26", "filename": "src/tools/clippy/clippy_lints/src/invalid_utf8_in_unchecked.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1ac91624d13624c164800fcd28cb234149ce0f5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_utf8_in_unchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac91624d13624c164800fcd28cb234149ce0f5a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_utf8_in_unchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_utf8_in_unchecked.rs?ref=1ac91624d13624c164800fcd28cb234149ce0f5a", "patch": "@@ -1,74 +0,0 @@\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_function_call, paths};\n-use rustc_ast::{BorrowKind, LitKind};\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-use rustc_span::Span;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `std::str::from_utf8_unchecked` with an invalid UTF-8 literal\n-    ///\n-    /// ### Why is this bad?\n-    /// Creating such a `str` would result in undefined behavior\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # #[allow(unused)]\n-    /// unsafe {\n-    ///     std::str::from_utf8_unchecked(b\"cl\\x82ippy\");\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.64.0\"]\n-    pub INVALID_UTF8_IN_UNCHECKED,\n-    correctness,\n-    \"using a non UTF-8 literal in `std::std::from_utf8_unchecked`\"\n-}\n-declare_lint_pass!(InvalidUtf8InUnchecked => [INVALID_UTF8_IN_UNCHECKED]);\n-\n-impl<'tcx> LateLintPass<'tcx> for InvalidUtf8InUnchecked {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let Some([arg]) = match_function_call(cx, expr, &paths::STR_FROM_UTF8_UNCHECKED) {\n-            match &arg.kind {\n-                ExprKind::Lit(Spanned { node: lit, .. }) => {\n-                    if let LitKind::ByteStr(bytes, _) = &lit\n-                        && std::str::from_utf8(bytes).is_err()\n-                    {\n-                        lint(cx, expr.span);\n-                    }\n-                },\n-                ExprKind::AddrOf(BorrowKind::Ref, _, Expr { kind: ExprKind::Array(args), .. }) => {\n-                    let elements = args.iter().map(|e|{\n-                        match &e.kind {\n-                            ExprKind::Lit(Spanned { node: lit, .. }) => match lit {\n-                                LitKind::Byte(b) => Some(*b),\n-                                #[allow(clippy::cast_possible_truncation)]\n-                                LitKind::Int(b, _) => Some(*b as u8),\n-                                _ => None\n-                            }\n-                            _ => None\n-                        }\n-                    }).collect::<Option<Vec<_>>>();\n-\n-                    if let Some(elements) = elements\n-                        && std::str::from_utf8(&elements).is_err()\n-                    {\n-                        lint(cx, expr.span);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn lint(cx: &LateContext<'_>, span: Span) {\n-    span_lint(\n-        cx,\n-        INVALID_UTF8_IN_UNCHECKED,\n-        span,\n-        \"non UTF-8 literal in `std::str::from_utf8_unchecked`\",\n-    );\n-}"}, {"sha": "fcca595c2bc4cb93ea5e66401a9c8a2c13c6da74", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -157,7 +157,6 @@ mod inline_fn_without_body;\n mod instant_subtraction;\n mod int_plus_one;\n mod invalid_upcast_comparisons;\n-mod invalid_utf8_in_unchecked;\n mod items_after_statements;\n mod items_after_test_module;\n mod iter_not_returning_iterator;\n@@ -937,7 +936,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move |_| Box::new(manual_retain::ManualRetain::new(msrv())));\n     let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n     store.register_late_pass(move |_| Box::new(operators::Operators::new(verbose_bit_mask_threshold)));\n-    store.register_late_pass(|_| Box::new(invalid_utf8_in_unchecked::InvalidUtf8InUnchecked));\n     store.register_late_pass(|_| Box::<std_instead_of_core::StdReexports>::default());\n     store.register_late_pass(move |_| Box::new(instant_subtraction::InstantSubtraction::new(msrv())));\n     store.register_late_pass(|_| Box::new(partialeq_to_none::PartialeqToNone));"}, {"sha": "99f810c27cf82f7bd6618c610fc013c7ac6d93e4", "filename": "src/tools/clippy/clippy_lints/src/methods/needless_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -241,7 +241,7 @@ fn is_contains_sig(cx: &LateContext<'_>, call_id: HirId, iter_expr: &Expr<'_>) -\n         && let proj_ty = cx.tcx.mk_projection(iter_item.def_id, substs)\n         && let Ok(item_ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, proj_ty)\n     {\n-        item_ty == EarlyBinder::new(search_ty).subst(cx.tcx, cx.typeck_results().node_substs(call_id))\n+        item_ty == EarlyBinder::bind(search_ty).subst(cx.tcx, cx.typeck_results().node_substs(call_id))\n     } else {\n         false\n     }"}, {"sha": "309d2157b76ee4f762ca30ae2872aaff895bb728", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -428,7 +428,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                                      }));\n \n                         if trait_predicates.any(|predicate| {\n-                            let predicate = EarlyBinder::new(predicate).subst(cx.tcx, new_subst);\n+                            let predicate = EarlyBinder::bind(predicate).subst(cx.tcx, new_subst);\n                             let obligation = Obligation::new(cx.tcx, ObligationCause::dummy(), cx.param_env, predicate);\n                             !cx.tcx.infer_ctxt().build().predicate_must_hold_modulo_regions(&obligation)\n                         }) {\n@@ -438,7 +438,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                         let output_ty = fn_sig.output();\n                         if output_ty.contains(*param_ty) {\n                             if let Ok(new_ty)  = cx.tcx.try_subst_and_normalize_erasing_regions(\n-                                new_subst, cx.param_env, EarlyBinder::new(output_ty)) {\n+                                new_subst, cx.param_env, EarlyBinder::bind(output_ty)) {\n                                 expr = parent_expr;\n                                 ty = new_ty;\n                                 continue;"}, {"sha": "7c2a100efdac6a4bba2e75cda46ed2416474d9a8", "filename": "src/tools/clippy/clippy_lints/src/renamed_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -43,6 +43,7 @@ pub static RENAMED_LINTS: &[(&str, &str)] = &[\n     (\"clippy::into_iter_on_array\", \"array_into_iter\"),\n     (\"clippy::invalid_atomic_ordering\", \"invalid_atomic_ordering\"),\n     (\"clippy::invalid_ref\", \"invalid_value\"),\n+    (\"clippy::invalid_utf8_in_unchecked\", \"invalid_from_utf8_unchecked\"),\n     (\"clippy::let_underscore_drop\", \"let_underscore_drop\"),\n     (\"clippy::mem_discriminant_non_enum\", \"enum_intrinsics_non_enums\"),\n     (\"clippy::panic_params\", \"non_fmt_panics\"),"}, {"sha": "cc3183759ae7a2627ef6e12a76278b064149b595", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 let substs = if self.substs.is_empty() {\n                     substs\n                 } else {\n-                    EarlyBinder::new(substs).subst(self.lcx.tcx, self.substs)\n+                    EarlyBinder::bind(substs).subst(self.lcx.tcx, self.substs)\n                 };\n \n                 let result = self"}, {"sha": "3dc096d3197fbe5eba20a5ca73b5a65d72739c7b", "filename": "src/tools/clippy/tests/ui/invalid_utf8_in_unchecked.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1ac91624d13624c164800fcd28cb234149ce0f5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_utf8_in_unchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac91624d13624c164800fcd28cb234149ce0f5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_utf8_in_unchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_utf8_in_unchecked.rs?ref=1ac91624d13624c164800fcd28cb234149ce0f5a", "patch": "@@ -1,20 +0,0 @@\n-#![warn(clippy::invalid_utf8_in_unchecked)]\n-\n-fn main() {\n-    // Valid\n-    unsafe {\n-        std::str::from_utf8_unchecked(&[99, 108, 105, 112, 112, 121]);\n-        std::str::from_utf8_unchecked(&[b'c', b'l', b'i', b'p', b'p', b'y']);\n-        std::str::from_utf8_unchecked(b\"clippy\");\n-\n-        let x = 0xA0;\n-        std::str::from_utf8_unchecked(&[0xC0, x]);\n-    }\n-\n-    // Invalid\n-    unsafe {\n-        std::str::from_utf8_unchecked(&[99, 108, 130, 105, 112, 112, 121]);\n-        std::str::from_utf8_unchecked(&[b'c', b'l', b'\\x82', b'i', b'p', b'p', b'y']);\n-        std::str::from_utf8_unchecked(b\"cl\\x82ippy\");\n-    }\n-}"}, {"sha": "c89cd2758ee9fe407fb359ed45f6232082fd400b", "filename": "src/tools/clippy/tests/ui/invalid_utf8_in_unchecked.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1ac91624d13624c164800fcd28cb234149ce0f5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_utf8_in_unchecked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ac91624d13624c164800fcd28cb234149ce0f5a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_utf8_in_unchecked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finvalid_utf8_in_unchecked.stderr?ref=1ac91624d13624c164800fcd28cb234149ce0f5a", "patch": "@@ -1,22 +0,0 @@\n-error: non UTF-8 literal in `std::str::from_utf8_unchecked`\n-  --> $DIR/invalid_utf8_in_unchecked.rs:16:9\n-   |\n-LL |         std::str::from_utf8_unchecked(&[99, 108, 130, 105, 112, 112, 121]);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-utf8-in-unchecked` implied by `-D warnings`\n-\n-error: non UTF-8 literal in `std::str::from_utf8_unchecked`\n-  --> $DIR/invalid_utf8_in_unchecked.rs:17:9\n-   |\n-LL |         std::str::from_utf8_unchecked(&[b'c', b'l', b'/x82', b'i', b'p', b'p', b'y']);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: non UTF-8 literal in `std::str::from_utf8_unchecked`\n-  --> $DIR/invalid_utf8_in_unchecked.rs:18:9\n-   |\n-LL |         std::str::from_utf8_unchecked(b\"cl/x82ippy\");\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "53ac65473b827c4463b5102b801eb0a29e2ad6c0", "filename": "src/tools/clippy/tests/ui/rename.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -38,6 +38,7 @@\n #![allow(array_into_iter)]\n #![allow(invalid_atomic_ordering)]\n #![allow(invalid_value)]\n+#![allow(invalid_from_utf8_unchecked)]\n #![allow(let_underscore_drop)]\n #![allow(enum_intrinsics_non_enums)]\n #![allow(non_fmt_panics)]\n@@ -87,6 +88,7 @@\n #![warn(array_into_iter)]\n #![warn(invalid_atomic_ordering)]\n #![warn(invalid_value)]\n+#![warn(invalid_from_utf8_unchecked)]\n #![warn(let_underscore_drop)]\n #![warn(enum_intrinsics_non_enums)]\n #![warn(non_fmt_panics)]"}, {"sha": "722c0b3eb27508cbc2b602ba55b61ed89bcfe525", "filename": "src/tools/clippy/tests/ui/rename.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -38,6 +38,7 @@\n #![allow(array_into_iter)]\n #![allow(invalid_atomic_ordering)]\n #![allow(invalid_value)]\n+#![allow(invalid_from_utf8_unchecked)]\n #![allow(let_underscore_drop)]\n #![allow(enum_intrinsics_non_enums)]\n #![allow(non_fmt_panics)]\n@@ -87,6 +88,7 @@\n #![warn(clippy::into_iter_on_array)]\n #![warn(clippy::invalid_atomic_ordering)]\n #![warn(clippy::invalid_ref)]\n+#![warn(clippy::invalid_utf8_in_unchecked)]\n #![warn(clippy::let_underscore_drop)]\n #![warn(clippy::mem_discriminant_non_enum)]\n #![warn(clippy::panic_params)]"}, {"sha": "1ff83917660235f1e9d4e3bf3cbd509196d1b52d", "filename": "src/tools/clippy/tests/ui/rename.stderr", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,292 +1,298 @@\n error: lint `clippy::almost_complete_letter_range` has been renamed to `clippy::almost_complete_range`\n-  --> $DIR/rename.rs:49:9\n+  --> $DIR/rename.rs:50:9\n    |\n LL | #![warn(clippy::almost_complete_letter_range)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::almost_complete_range`\n    |\n    = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n error: lint `clippy::blacklisted_name` has been renamed to `clippy::disallowed_names`\n-  --> $DIR/rename.rs:50:9\n+  --> $DIR/rename.rs:51:9\n    |\n LL | #![warn(clippy::blacklisted_name)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_names`\n \n error: lint `clippy::block_in_if_condition_expr` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:51:9\n+  --> $DIR/rename.rs:52:9\n    |\n LL | #![warn(clippy::block_in_if_condition_expr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::block_in_if_condition_stmt` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:52:9\n+  --> $DIR/rename.rs:53:9\n    |\n LL | #![warn(clippy::block_in_if_condition_stmt)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::box_vec` has been renamed to `clippy::box_collection`\n-  --> $DIR/rename.rs:53:9\n+  --> $DIR/rename.rs:54:9\n    |\n LL | #![warn(clippy::box_vec)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::box_collection`\n \n error: lint `clippy::const_static_lifetime` has been renamed to `clippy::redundant_static_lifetimes`\n-  --> $DIR/rename.rs:54:9\n+  --> $DIR/rename.rs:55:9\n    |\n LL | #![warn(clippy::const_static_lifetime)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::redundant_static_lifetimes`\n \n error: lint `clippy::cyclomatic_complexity` has been renamed to `clippy::cognitive_complexity`\n-  --> $DIR/rename.rs:55:9\n+  --> $DIR/rename.rs:56:9\n    |\n LL | #![warn(clippy::cyclomatic_complexity)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::cognitive_complexity`\n \n error: lint `clippy::derive_hash_xor_eq` has been renamed to `clippy::derived_hash_with_manual_eq`\n-  --> $DIR/rename.rs:56:9\n+  --> $DIR/rename.rs:57:9\n    |\n LL | #![warn(clippy::derive_hash_xor_eq)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::derived_hash_with_manual_eq`\n \n error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_methods`\n-  --> $DIR/rename.rs:57:9\n+  --> $DIR/rename.rs:58:9\n    |\n LL | #![warn(clippy::disallowed_method)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n \n error: lint `clippy::disallowed_type` has been renamed to `clippy::disallowed_types`\n-  --> $DIR/rename.rs:58:9\n+  --> $DIR/rename.rs:59:9\n    |\n LL | #![warn(clippy::disallowed_type)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_types`\n \n error: lint `clippy::eval_order_dependence` has been renamed to `clippy::mixed_read_write_in_expression`\n-  --> $DIR/rename.rs:59:9\n+  --> $DIR/rename.rs:60:9\n    |\n LL | #![warn(clippy::eval_order_dependence)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::mixed_read_write_in_expression`\n \n error: lint `clippy::identity_conversion` has been renamed to `clippy::useless_conversion`\n-  --> $DIR/rename.rs:60:9\n+  --> $DIR/rename.rs:61:9\n    |\n LL | #![warn(clippy::identity_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::useless_conversion`\n \n error: lint `clippy::if_let_some_result` has been renamed to `clippy::match_result_ok`\n-  --> $DIR/rename.rs:61:9\n+  --> $DIR/rename.rs:62:9\n    |\n LL | #![warn(clippy::if_let_some_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::match_result_ok`\n \n error: lint `clippy::integer_arithmetic` has been renamed to `clippy::arithmetic_side_effects`\n-  --> $DIR/rename.rs:62:9\n+  --> $DIR/rename.rs:63:9\n    |\n LL | #![warn(clippy::integer_arithmetic)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::arithmetic_side_effects`\n \n error: lint `clippy::logic_bug` has been renamed to `clippy::overly_complex_bool_expr`\n-  --> $DIR/rename.rs:63:9\n+  --> $DIR/rename.rs:64:9\n    |\n LL | #![warn(clippy::logic_bug)]\n    |         ^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::overly_complex_bool_expr`\n \n error: lint `clippy::new_without_default_derive` has been renamed to `clippy::new_without_default`\n-  --> $DIR/rename.rs:64:9\n+  --> $DIR/rename.rs:65:9\n    |\n LL | #![warn(clippy::new_without_default_derive)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::new_without_default`\n \n error: lint `clippy::option_and_then_some` has been renamed to `clippy::bind_instead_of_map`\n-  --> $DIR/rename.rs:65:9\n+  --> $DIR/rename.rs:66:9\n    |\n LL | #![warn(clippy::option_and_then_some)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::bind_instead_of_map`\n \n error: lint `clippy::option_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:66:9\n+  --> $DIR/rename.rs:67:9\n    |\n LL | #![warn(clippy::option_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::option_map_unwrap_or` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:67:9\n+  --> $DIR/rename.rs:68:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:68:9\n+  --> $DIR/rename.rs:69:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:69:9\n+  --> $DIR/rename.rs:70:9\n    |\n LL | #![warn(clippy::option_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n-  --> $DIR/rename.rs:70:9\n+  --> $DIR/rename.rs:71:9\n    |\n LL | #![warn(clippy::ref_in_deref)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n \n error: lint `clippy::result_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:71:9\n+  --> $DIR/rename.rs:72:9\n    |\n LL | #![warn(clippy::result_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::result_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:72:9\n+  --> $DIR/rename.rs:73:9\n    |\n LL | #![warn(clippy::result_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::result_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:73:9\n+  --> $DIR/rename.rs:74:9\n    |\n LL | #![warn(clippy::result_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::single_char_push_str` has been renamed to `clippy::single_char_add_str`\n-  --> $DIR/rename.rs:74:9\n+  --> $DIR/rename.rs:75:9\n    |\n LL | #![warn(clippy::single_char_push_str)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::single_char_add_str`\n \n error: lint `clippy::stutter` has been renamed to `clippy::module_name_repetitions`\n-  --> $DIR/rename.rs:75:9\n+  --> $DIR/rename.rs:76:9\n    |\n LL | #![warn(clippy::stutter)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::module_name_repetitions`\n \n error: lint `clippy::to_string_in_display` has been renamed to `clippy::recursive_format_impl`\n-  --> $DIR/rename.rs:76:9\n+  --> $DIR/rename.rs:77:9\n    |\n LL | #![warn(clippy::to_string_in_display)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::recursive_format_impl`\n \n error: lint `clippy::zero_width_space` has been renamed to `clippy::invisible_characters`\n-  --> $DIR/rename.rs:77:9\n+  --> $DIR/rename.rs:78:9\n    |\n LL | #![warn(clippy::zero_width_space)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::invisible_characters`\n \n error: lint `clippy::clone_double_ref` has been renamed to `suspicious_double_ref_op`\n-  --> $DIR/rename.rs:78:9\n+  --> $DIR/rename.rs:79:9\n    |\n LL | #![warn(clippy::clone_double_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `suspicious_double_ref_op`\n \n error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n-  --> $DIR/rename.rs:79:9\n+  --> $DIR/rename.rs:80:9\n    |\n LL | #![warn(clippy::drop_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n error: lint `clippy::drop_copy` has been renamed to `dropping_copy_types`\n-  --> $DIR/rename.rs:80:9\n+  --> $DIR/rename.rs:81:9\n    |\n LL | #![warn(clippy::drop_copy)]\n    |         ^^^^^^^^^^^^^^^^^ help: use the new name: `dropping_copy_types`\n \n error: lint `clippy::drop_ref` has been renamed to `dropping_references`\n-  --> $DIR/rename.rs:81:9\n+  --> $DIR/rename.rs:82:9\n    |\n LL | #![warn(clippy::drop_ref)]\n    |         ^^^^^^^^^^^^^^^^ help: use the new name: `dropping_references`\n \n error: lint `clippy::for_loop_over_option` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:82:9\n+  --> $DIR/rename.rs:83:9\n    |\n LL | #![warn(clippy::for_loop_over_option)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::for_loop_over_result` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:83:9\n+  --> $DIR/rename.rs:84:9\n    |\n LL | #![warn(clippy::for_loop_over_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::for_loops_over_fallibles` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:84:9\n+  --> $DIR/rename.rs:85:9\n    |\n LL | #![warn(clippy::for_loops_over_fallibles)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::forget_copy` has been renamed to `forgetting_copy_types`\n-  --> $DIR/rename.rs:85:9\n+  --> $DIR/rename.rs:86:9\n    |\n LL | #![warn(clippy::forget_copy)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `forgetting_copy_types`\n \n error: lint `clippy::forget_ref` has been renamed to `forgetting_references`\n-  --> $DIR/rename.rs:86:9\n+  --> $DIR/rename.rs:87:9\n    |\n LL | #![warn(clippy::forget_ref)]\n    |         ^^^^^^^^^^^^^^^^^^ help: use the new name: `forgetting_references`\n \n error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n-  --> $DIR/rename.rs:87:9\n+  --> $DIR/rename.rs:88:9\n    |\n LL | #![warn(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n-  --> $DIR/rename.rs:88:9\n+  --> $DIR/rename.rs:89:9\n    |\n LL | #![warn(clippy::invalid_atomic_ordering)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n \n error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n-  --> $DIR/rename.rs:89:9\n+  --> $DIR/rename.rs:90:9\n    |\n LL | #![warn(clippy::invalid_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n+error: lint `clippy::invalid_utf8_in_unchecked` has been renamed to `invalid_from_utf8_unchecked`\n+  --> $DIR/rename.rs:91:9\n+   |\n+LL | #![warn(clippy::invalid_utf8_in_unchecked)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_from_utf8_unchecked`\n+\n error: lint `clippy::let_underscore_drop` has been renamed to `let_underscore_drop`\n-  --> $DIR/rename.rs:90:9\n+  --> $DIR/rename.rs:92:9\n    |\n LL | #![warn(clippy::let_underscore_drop)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `let_underscore_drop`\n \n error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n-  --> $DIR/rename.rs:91:9\n+  --> $DIR/rename.rs:93:9\n    |\n LL | #![warn(clippy::mem_discriminant_non_enum)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n \n error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n-  --> $DIR/rename.rs:92:9\n+  --> $DIR/rename.rs:94:9\n    |\n LL | #![warn(clippy::panic_params)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n \n error: lint `clippy::positional_named_format_parameters` has been renamed to `named_arguments_used_positionally`\n-  --> $DIR/rename.rs:93:9\n+  --> $DIR/rename.rs:95:9\n    |\n LL | #![warn(clippy::positional_named_format_parameters)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `named_arguments_used_positionally`\n \n error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n-  --> $DIR/rename.rs:94:9\n+  --> $DIR/rename.rs:96:9\n    |\n LL | #![warn(clippy::temporary_cstring_as_ptr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n-  --> $DIR/rename.rs:95:9\n+  --> $DIR/rename.rs:97:9\n    |\n LL | #![warn(clippy::unknown_clippy_lints)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n error: lint `clippy::unused_label` has been renamed to `unused_labels`\n-  --> $DIR/rename.rs:96:9\n+  --> $DIR/rename.rs:98:9\n    |\n LL | #![warn(clippy::unused_label)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n \n-error: aborting due to 48 previous errors\n+error: aborting due to 49 previous errors\n "}, {"sha": "f24d448e980859ad3d97f91e16ab7f7896387264", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1 +1 @@\n-498553fc04f6a3fdc53412320f4e913bc53bc267\n+617d3d6d722c432cdcbf210e6db55c3bdeafe381"}, {"sha": "c68b40b744bf257e41887f7b962f480f237a6af8", "filename": "src/tools/miri/tests/pass/shims/time-with-isolation2.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ftime-with-isolation2.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ftime-with-isolation2.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ftime-with-isolation2.stdout?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1 +1 @@\n-The loop took around 13s\n+The loop took around 7s"}, {"sha": "4cb200ebc7c5f1928287648adfb0c662eaa30373", "filename": "src/tools/rustdoc-gui-test/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -4,6 +4,7 @@ version = \"0.1.0\"\n edition = \"2021\"\n \n [dependencies]\n+build_helper = { path = \"../build_helper\" }\n compiletest = { path = \"../compiletest\" }\n getopts = \"0.2\"\n walkdir = \"2\""}, {"sha": "3f60a90f87a22c154e6a077e59e8dd3334a67d1a", "filename": "src/tools/rustdoc-gui-test/src/main.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,3 +1,4 @@\n+use build_helper::util::try_run;\n use compiletest::header::TestProps;\n use config::Config;\n use std::path::{Path, PathBuf};\n@@ -60,23 +61,6 @@ fn find_librs<P: AsRef<Path>>(path: P) -> Option<PathBuf> {\n     None\n }\n \n-// FIXME: move `bootstrap::util::try_run` into `build_helper` crate\n-// and use that one instead of creating this function.\n-fn try_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n-    let status = match cmd.status() {\n-        Ok(status) => status,\n-        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e),\n-    };\n-    if !status.success() && print_cmd_on_fail {\n-        println!(\n-            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n-             expected success, got: {}\\n\\n\",\n-            cmd, status\n-        );\n-    }\n-    status.success()\n-}\n-\n fn main() {\n     let config = Arc::new(Config::from_args(env::args().collect()));\n \n@@ -143,6 +127,16 @@ If you want to install the `browser-ui-test` dependency, run `npm install browse\n     }\n \n     let mut command = Command::new(&config.nodejs);\n+\n+    if let Ok(current_dir) = env::current_dir() {\n+        let local_node_modules = current_dir.join(\"node_modules\");\n+        if local_node_modules.exists() {\n+            // Link the local node_modules if exists.\n+            // This is useful when we run rustdoc-gui-test from outside of the source root.\n+            env::set_var(\"NODE_PATH\", local_node_modules);\n+        }\n+    }\n+\n     command\n         .arg(config.rust_src.join(\"src/tools/rustdoc-gui/tester.js\"))\n         .arg(\"--jobs\")"}, {"sha": "db2b7910b711c497762569a30e164daf2f30fa45", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -38,7 +38,6 @@ const LICENSES: &[&str] = &[\n const EXCEPTIONS: &[(&str, &str)] = &[\n     // tidy-alphabetical-start\n     (\"ar_archive_writer\", \"Apache-2.0 WITH LLVM-exception\"), // rustc\n-    (\"codespan-reporting\", \"Apache-2.0\"),                    // cxx via iana-time-zone-haiku via time, only on haiku\n     (\"colored\", \"MPL-2.0\"),                                  // rustfmt\n     (\"dissimilar\", \"Apache-2.0\"),                            // rustdoc, rustc_lexer (few tests) via expect-test, (dev deps)\n     (\"fluent-langneg\", \"Apache-2.0\"),                        // rustc (fluent translations)"}, {"sha": "01ef4abd3dca37ccc682231f2015f107d76a82c1", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -10,8 +10,8 @@ use std::path::{Path, PathBuf};\n \n const ENTRY_LIMIT: usize = 900;\n // FIXME: The following limits should be reduced eventually.\n-const ISSUES_ENTRY_LIMIT: usize = 1920;\n-const ROOT_ENTRY_LIMIT: usize = 896;\n+const ISSUES_ENTRY_LIMIT: usize = 1898;\n+const ROOT_ENTRY_LIMIT: usize = 891;\n \n const EXPECTED_TEST_FILE_EXTENSIONS: &[&str] = &[\n     \"rs\",     // test source files"}, {"sha": "24f3f43d0787444157b3082985f7c679454141a4", "filename": "tests/codegen/array-map.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fcodegen%2Farray-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fcodegen%2Farray-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-map.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -4,7 +4,6 @@\n // ignore-debug (the extra assertions get in the way)\n \n #![crate_type = \"lib\"]\n-#![feature(array_zip)]\n \n // CHECK-LABEL: @short_integer_map\n #[no_mangle]\n@@ -16,16 +15,6 @@ pub fn short_integer_map(x: [u32; 8]) -> [u32; 8] {\n     x.map(|x| 2 * x + 1)\n }\n \n-// CHECK-LABEL: @short_integer_zip_map\n-#[no_mangle]\n-pub fn short_integer_zip_map(x: [u32; 8], y: [u32; 8]) -> [u32; 8] {\n-    // CHECK: %[[A:.+]] = load <8 x i32>\n-    // CHECK: %[[B:.+]] = load <8 x i32>\n-    // CHECK: sub <8 x i32> %[[B]], %[[A]]\n-    // CHECK: store <8 x i32>\n-    x.zip(y).map(|(x, y)| x - y)\n-}\n-\n // This test is checking that LLVM can SRoA away a bunch of the overhead,\n // like fully moving the iterators to registers.  Notably, previous implementations\n // of `map` ended up `alloca`ing the whole `array::IntoIterator`, meaning both a"}, {"sha": "54392be707f533f3c765f21df76d4783247a5c7d", "filename": "tests/codegen/autovectorize-f32x4.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fcodegen%2Fautovectorize-f32x4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fcodegen%2Fautovectorize-f32x4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fautovectorize-f32x4.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,7 +1,6 @@\n // compile-flags: -C opt-level=3 -Z merge-functions=disabled\n // only-x86_64\n #![crate_type = \"lib\"]\n-#![feature(array_zip)]\n \n // CHECK-LABEL: @auto_vectorize_direct\n #[no_mangle]\n@@ -32,12 +31,12 @@ pub fn auto_vectorize_loop(a: [f32; 4], b: [f32; 4]) -> [f32; 4] {\n     c\n }\n \n-// CHECK-LABEL: @auto_vectorize_array_zip_map\n+// CHECK-LABEL: @auto_vectorize_array_from_fn\n #[no_mangle]\n-pub fn auto_vectorize_array_zip_map(a: [f32; 4], b: [f32; 4]) -> [f32; 4] {\n+pub fn auto_vectorize_array_from_fn(a: [f32; 4], b: [f32; 4]) -> [f32; 4] {\n // CHECK: load <4 x float>\n // CHECK: load <4 x float>\n // CHECK: fadd <4 x float>\n // CHECK: store <4 x float>\n-    a.zip(b).map(|(a, b)| a + b)\n+    std::array::from_fn(|i| a[i] + b[i])\n }"}, {"sha": "8f32c50b7988420b7d960e4a36ee739dcae018a1", "filename": "tests/codegen/const_scalar_pair.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fcodegen%2Fconst_scalar_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fcodegen%2Fconst_scalar_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fconst_scalar_pair.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: --crate-type=lib -Copt-level=0 -Zmir-opt-level=0 -C debuginfo=2\n+\n+#![feature(inline_const)]\n+\n+pub fn foo() -> (i32, i32) {\n+    // CHECK: ret { i32, i32 } { i32 1, i32 2 }\n+    const { (1, 2) }\n+}"}, {"sha": "e7d91235e73563bbbdaf6f0841c80e48e380a1d6", "filename": "tests/incremental/issue-110457-same-span-closures/auxiliary/egui_inspect_derive.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fincremental%2Fissue-110457-same-span-closures%2Fauxiliary%2Fegui_inspect_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fincremental%2Fissue-110457-same-span-closures%2Fauxiliary%2Fegui_inspect_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fissue-110457-same-span-closures%2Fauxiliary%2Fegui_inspect_derive.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,90 @@\n+// force-host\n+// no-prefer-dynamic\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n+\n+#[proc_macro]\n+pub fn expand(_: TokenStream) -> TokenStream {\n+    // Hand expansion/rewriting of\n+    // ```\n+    // quote! {\n+    //     output_mut(|o| o.copied_text = \"\".into());\n+    //     output_mut(|o| o.copied_text = format!(\"{:?}\", self.tile_db));\n+    // }.into()\n+    // ```\n+    stream([\n+        ident(\"output_mut\"),\n+        group(\n+            Delimiter::Parenthesis,\n+            [\n+                or(),\n+                ident(\"o\"),\n+                or(),\n+                ident(\"o\"),\n+                dot(),\n+                ident(\"copied_text\"),\n+                eq(),\n+                string(\"\"),\n+                dot(),\n+                ident(\"into\"),\n+                group(Delimiter::Parenthesis, []),\n+            ],\n+        ),\n+        semi(),\n+        ident(\"output_mut\"),\n+        group(\n+            Delimiter::Parenthesis,\n+            [\n+                or(),\n+                ident(\"o\"),\n+                or(),\n+                ident(\"o\"),\n+                dot(),\n+                ident(\"copied_text\"),\n+                eq(),\n+                ident(\"format\"),\n+                bang(),\n+                group(\n+                    Delimiter::Parenthesis,\n+                    [string(\"{:?}\"), comma(), ident(\"self\"), dot(), ident(\"tile_db\")],\n+                ),\n+            ],\n+        ),\n+        semi(),\n+    ])\n+}\n+\n+fn stream(s: impl IntoIterator<Item = TokenTree>) -> TokenStream {\n+    s.into_iter().collect()\n+}\n+\n+fn ident(i: &str) -> TokenTree {\n+    TokenTree::Ident(Ident::new(i, Span::call_site()))\n+}\n+fn group(d: Delimiter, s: impl IntoIterator<Item = TokenTree>) -> TokenTree {\n+    TokenTree::Group(Group::new(d, s.into_iter().collect()))\n+}\n+fn semi() -> TokenTree {\n+    TokenTree::Punct(Punct::new(';', Spacing::Alone))\n+}\n+fn or() -> TokenTree {\n+    TokenTree::Punct(Punct::new('|', Spacing::Alone))\n+}\n+fn dot() -> TokenTree {\n+    TokenTree::Punct(Punct::new('.', Spacing::Alone))\n+}\n+fn eq() -> TokenTree {\n+    TokenTree::Punct(Punct::new('=', Spacing::Alone))\n+}\n+fn bang() -> TokenTree {\n+    TokenTree::Punct(Punct::new('!', Spacing::Alone))\n+}\n+fn comma() -> TokenTree {\n+    TokenTree::Punct(Punct::new(',', Spacing::Alone))\n+}\n+fn string(s: &str) -> TokenTree {\n+    TokenTree::Literal(Literal::string(s))\n+}"}, {"sha": "b44fda3d36a292e510abd47b6f0041c673cf0227", "filename": "tests/incremental/issue-110457-same-span-closures/main.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fincremental%2Fissue-110457-same-span-closures%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fincremental%2Fissue-110457-same-span-closures%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fissue-110457-same-span-closures%2Fmain.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,47 @@\n+// aux-build: egui_inspect_derive.rs\n+// revisions: cpass1 cpass2\n+\n+extern crate egui_inspect_derive;\n+\n+pub struct TileDef {\n+    pub layer: (),\n+    #[cfg(cpass2)]\n+    pub blend_graphic: String,\n+}\n+\n+pub(crate) struct GameState {\n+    pub(crate) tile_db: TileDb,\n+}\n+\n+impl GameState {\n+    fn inspect_mut(&mut self) {\n+        egui_inspect_derive::expand! {}\n+    }\n+}\n+\n+fn new() -> GameState {\n+    loop {}\n+}\n+\n+fn main() {\n+    let mut app = new();\n+    app.inspect_mut();\n+}\n+// this is actually used\n+pub struct TileDb {\n+    unknown_bg: TileDef,\n+}\n+\n+impl std::fmt::Debug for TileDb {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        loop {}\n+    }\n+}\n+\n+pub struct PlatformOutput {\n+    pub copied_text: String,\n+}\n+\n+pub fn output_mut<R>(writer: impl FnOnce(&mut PlatformOutput) -> R) -> R {\n+    loop {}\n+}"}, {"sha": "693939e75f4f41028632982ea44fd2e04e40e019", "filename": "tests/mir-opt/pre-codegen/range_iter.forward_loop.PreCodegen.after.mir", "status": "modified", "additions": 78, "deletions": 30, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.forward_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.forward_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.forward_loop.PreCodegen.after.mir?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -8,19 +8,32 @@ fn forward_loop(_1: u32, _2: u32, _3: impl Fn(u32)) -> () {\n     let mut _4: std::ops::Range<u32>;    // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n     let mut _5: std::ops::Range<u32>;    // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n     let mut _6: &mut std::ops::Range<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n-    let mut _7: std::option::Option<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n-    let mut _8: isize;                   // in scope 0 at $DIR/range_iter.rs:+1:5: +3:6\n-    let mut _10: &impl Fn(u32);          // in scope 0 at $DIR/range_iter.rs:+2:9: +2:10\n-    let mut _11: (u32,);                 // in scope 0 at $DIR/range_iter.rs:+2:9: +2:13\n-    let _12: ();                         // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n+    let mut _10: std::option::Option<u32>; // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n+    let mut _13: isize;                  // in scope 0 at $DIR/range_iter.rs:+1:5: +3:6\n+    let mut _15: &impl Fn(u32);          // in scope 0 at $DIR/range_iter.rs:+2:9: +2:10\n+    let mut _16: (u32,);                 // in scope 0 at $DIR/range_iter.rs:+2:9: +2:13\n+    let _17: ();                         // in scope 0 at $DIR/range_iter.rs:+1:14: +1:24\n     scope 1 {\n         debug iter => _5;                // in scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n-        let _9: u32;                     // in scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n+        let _14: u32;                    // in scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n         scope 2 {\n-            debug x => _9;               // in scope 2 at $DIR/range_iter.rs:+1:9: +1:10\n+            debug x => _14;              // in scope 2 at $DIR/range_iter.rs:+1:9: +1:10\n         }\n         scope 4 (inlined iter::range::<impl Iterator for std::ops::Range<u32>>::next) { // at $DIR/range_iter.rs:21:14: 21:24\n             debug self => _6;            // in scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            scope 5 (inlined <std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next) { // at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                debug self => _6;        // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _7: &u32;        // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _8: &u32;        // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _9: bool;        // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let _11: u32;            // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _12: u32;        // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                scope 6 {\n+                    debug old => _11;    // in scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                    scope 7 {\n+                    }\n+                }\n+            }\n         }\n     }\n     scope 3 (inlined <std::ops::Range<u32> as IntoIterator>::into_iter) { // at $DIR/range_iter.rs:21:14: 21:24\n@@ -35,57 +48,92 @@ fn forward_loop(_1: u32, _2: u32, _3: impl Fn(u32)) -> () {\n     }\n \n     bb1: {\n-        StorageLive(_7);                 // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n+        StorageLive(_10);                // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n         _6 = &mut _5;                    // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n-        _7 = <std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next(_6) -> [return: bb2, unwind: bb8]; // scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_9);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_7);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _7 = &((*_6).0: u32);            // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_8);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _8 = &((*_6).1: u32);            // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _9 = <u32 as PartialOrd>::lt(move _7, move _8) -> [return: bb2, unwind: bb12]; // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n-                                         // + literal: Const { ty: for<'a> fn(&'a mut std::ops::Range<u32>) -> Option<<std::ops::Range<u32> as iter::range::RangeIteratorImpl>::Item> {<std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next}, val: Value(<ZST>) }\n+                                         // + literal: Const { ty: for<'a, 'b> fn(&'a u32, &'b u32) -> bool {<u32 as PartialOrd>::lt}, val: Value(<ZST>) }\n     }\n \n     bb2: {\n-        _8 = discriminant(_7);           // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n-        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb7]; // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n+        StorageDead(_8);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_7);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        switchInt(move _9) -> [0: bb3, otherwise: bb4]; // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n     }\n \n     bb3: {\n-        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n-        StorageDead(_5);                 // scope 0 at $DIR/range_iter.rs:+3:5: +3:6\n-        drop(_3) -> bb4;                 // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n+        _10 = Option::<u32>::None;       // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        goto -> bb6;                     // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n     }\n \n     bb4: {\n-        return;                          // scope 0 at $DIR/range_iter.rs:+4:2: +4:2\n+        _11 = ((*_6).0: u32);            // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_12);                // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _12 = <u32 as Step>::forward_unchecked(_11, const 1_usize) -> [return: bb5, unwind: bb12]; // scope 7 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe fn(u32, usize) -> u32 {<u32 as Step>::forward_unchecked}, val: Value(<ZST>) }\n     }\n \n     bb5: {\n-        _9 = ((_7 as Some).0: u32);      // scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n-        StorageLive(_10);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n-        _10 = &_3;                       // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n-        StorageLive(_11);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n-        _11 = (_9,);                     // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n-        _12 = <impl Fn(u32) as Fn<(u32,)>>::call(move _10, move _11) -> [return: bb6, unwind: bb8]; // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+        ((*_6).0: u32) = move _12;       // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_12);                // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _10 = Option::<u32>::Some(_11);  // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        goto -> bb6;                     // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb6: {\n+        StorageDead(_9);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _13 = discriminant(_10);         // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n+        switchInt(move _13) -> [0: bb7, 1: bb9, otherwise: bb11]; // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n+    }\n+\n+    bb7: {\n+        StorageDead(_10);                // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n+        StorageDead(_5);                 // scope 0 at $DIR/range_iter.rs:+3:5: +3:6\n+        drop(_3) -> bb8;                 // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n+    }\n+\n+    bb8: {\n+        return;                          // scope 0 at $DIR/range_iter.rs:+4:2: +4:2\n+    }\n+\n+    bb9: {\n+        _14 = ((_10 as Some).0: u32);    // scope 1 at $DIR/range_iter.rs:+1:9: +1:10\n+        StorageLive(_15);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n+        _15 = &_3;                       // scope 2 at $DIR/range_iter.rs:+2:9: +2:10\n+        StorageLive(_16);                // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+        _16 = (_14,);                    // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n+        _17 = <impl Fn(u32) as Fn<(u32,)>>::call(move _15, move _16) -> [return: bb10, unwind: bb12]; // scope 2 at $DIR/range_iter.rs:+2:9: +2:13\n                                          // mir::Constant\n                                          // + span: $DIR/range_iter.rs:22:9: 22:10\n                                          // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(u32), (u32,)) -> <impl Fn(u32) as FnOnce<(u32,)>>::Output {<impl Fn(u32) as Fn<(u32,)>>::call}, val: Value(<ZST>) }\n     }\n \n-    bb6: {\n-        StorageDead(_11);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n-        StorageDead(_10);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n-        StorageDead(_7);                 // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n+    bb10: {\n+        StorageDead(_16);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n+        StorageDead(_15);                // scope 2 at $DIR/range_iter.rs:+2:12: +2:13\n+        StorageDead(_10);                // scope 1 at $DIR/range_iter.rs:+3:5: +3:6\n         goto -> bb1;                     // scope 1 at $DIR/range_iter.rs:+1:5: +3:6\n     }\n \n-    bb7: {\n+    bb11: {\n         unreachable;                     // scope 1 at $DIR/range_iter.rs:+1:14: +1:24\n     }\n \n-    bb8 (cleanup): {\n-        drop(_3) -> [return: bb9, unwind terminate]; // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n+    bb12 (cleanup): {\n+        drop(_3) -> [return: bb13, unwind terminate]; // scope 0 at $DIR/range_iter.rs:+4:1: +4:2\n     }\n \n-    bb9 (cleanup): {\n+    bb13 (cleanup): {\n         resume;                          // scope 0 at $DIR/range_iter.rs:+0:1: +4:2\n     }\n }"}, {"sha": "668ec31c6c134954be98d0790414031a141f1336", "filename": "tests/mir-opt/pre-codegen/range_iter.range_iter_next.PreCodegen.after.mir", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.range_iter_next.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.range_iter_next.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Frange_iter.range_iter_next.PreCodegen.after.mir?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -5,16 +5,64 @@ fn range_iter_next(_1: &mut std::ops::Range<u32>) -> Option<u32> {\n     let mut _0: std::option::Option<u32>; // return place in scope 0 at $DIR/range_iter.rs:+0:48: +0:59\n     scope 1 (inlined iter::range::<impl Iterator for std::ops::Range<u32>>::next) { // at $DIR/range_iter.rs:11:8: 11:14\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        scope 2 (inlined <std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next) { // at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            debug self => _1;            // in scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            let mut _2: &u32;            // in scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            let mut _3: &u32;            // in scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            let mut _4: bool;            // in scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            let _5: u32;                 // in scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            let mut _6: u32;             // in scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            scope 3 {\n+                debug old => _5;         // in scope 3 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                scope 4 {\n+                }\n+            }\n+        }\n     }\n \n     bb0: {\n-        _0 = <std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next(_1) -> bb1; // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_5);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_2);                 // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _2 = &((*_1).0: u32);            // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _3 = &((*_1).1: u32);            // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _4 = <u32 as PartialOrd>::lt(move _2, move _3) -> bb1; // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n-                                         // + literal: Const { ty: for<'a> fn(&'a mut std::ops::Range<u32>) -> Option<<std::ops::Range<u32> as iter::range::RangeIteratorImpl>::Item> {<std::ops::Range<u32> as iter::range::RangeIteratorImpl>::spec_next}, val: Value(<ZST>) }\n+                                         // + literal: Const { ty: for<'a, 'b> fn(&'a u32, &'b u32) -> bool {<u32 as PartialOrd>::lt}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n+        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_2);                 // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        switchInt(move _4) -> [0: bb2, otherwise: bb3]; // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb2: {\n+        _0 = Option::<u32>::None;        // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        goto -> bb5;                     // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb3: {\n+        _5 = ((*_1).0: u32);             // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _6 = <u32 as Step>::forward_unchecked(_5, const 1_usize) -> bb4; // scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe fn(u32, usize) -> u32 {<u32 as Step>::forward_unchecked}, val: Value(<ZST>) }\n+    }\n+\n+    bb4: {\n+        ((*_1).0: u32) = move _6;        // scope 3 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _0 = Option::<u32>::Some(_5);    // scope 3 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        goto -> bb5;                     // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb5: {\n+        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_5);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n         return;                          // scope 0 at $DIR/range_iter.rs:+2:2: +2:2\n     }\n }"}, {"sha": "c5e7f813dd1940ab4bcc4376b566f42e6253e349", "filename": "tests/rustdoc-gui/target.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Frustdoc-gui%2Ftarget.goml", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Frustdoc-gui%2Ftarget.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Ftarget.goml?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -25,11 +25,11 @@ call-function: (\"check-style\", {\n })\n call-function: (\"check-style\", {\n     \"theme\": \"dark\",\n-    \"background\": \"rgb(73, 74, 61)\",\n-    \"border\": \"rgb(187, 116, 16)\",\n+    \"background\": \"#494a3d\",\n+    \"border\": \"#bb7410\",\n })\n call-function: (\"check-style\", {\n     \"theme\": \"light\",\n-    \"background\": \"rgb(253, 255, 211)\",\n-    \"border\": \"rgb(173, 124, 55)\",\n+    \"background\": \"#fdffd3\",\n+    \"border\": \"#ad7c37\",\n })"}, {"sha": "1e4216d3c0cac46bd9a224114bdf51940b4ae46c", "filename": "tests/rustdoc/reexport-doc-hidden-inside-private.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Frustdoc%2Freexport-doc-hidden-inside-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Frustdoc%2Freexport-doc-hidden-inside-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-doc-hidden-inside-private.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,16 @@\n+// This test ensures that a re-export of  `#[doc(hidden)]` item inside a private\n+// module will still be displayed (the re-export, not the item).\n+\n+#![crate_name = \"foo\"]\n+\n+mod private_module {\n+    #[doc(hidden)]\n+    pub struct Public;\n+}\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"reexport.Foo\"]/code' 'pub use crate::private_module::Public as Foo;'\n+pub use crate::private_module::Public as Foo;\n+// Glob re-exports with no visible items should not be displayed.\n+// @count - '//*[@class=\"item-table\"]/li' 1\n+pub use crate::private_module::*;"}, {"sha": "ac18470c6211399cc7266631a5341ae431592526", "filename": "tests/ui/async-await/issue-78115.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fasync-await%2Fissue-78115.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fasync-await%2Fissue-78115.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fissue-78115.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-78115.rs"}, {"sha": "f21ef43fb7ccb4c3ae2684d950e5bfa26e1ba9df", "filename": "tests/ui/closures/2229_closure_analysis/unique-borrows-are-invariant-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-1.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,18 @@\n+// edition:2021\n+\n+// regression test for #112056\n+\n+fn extend_lifetime<'a, 'b>(x: &mut (&'a str,), y: &'b str) {\n+    let mut closure = |input| x.0 = input;\n+    //~^ ERROR: lifetime may not live long enough\n+    closure(y);\n+}\n+\n+fn main() {\n+    let mut tuple = (\"static\",);\n+    {\n+        let x = String::from(\"temporary\");\n+        extend_lifetime(&mut tuple, &x);\n+    }\n+    println!(\"{}\", tuple.0);\n+}"}, {"sha": "730823281abc950fcfc9dca20a05cc1692b83b1d", "filename": "tests/ui/closures/2229_closure_analysis/unique-borrows-are-invariant-1.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-1.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,14 @@\n+error: lifetime may not live long enough\n+  --> $DIR/unique-borrows-are-invariant-1.rs:6:31\n+   |\n+LL | fn extend_lifetime<'a, 'b>(x: &mut (&'a str,), y: &'b str) {\n+   |                    --  -- lifetime `'b` defined here\n+   |                    |\n+   |                    lifetime `'a` defined here\n+LL |     let mut closure = |input| x.0 = input;\n+   |                               ^^^^^^^^^^^ assignment requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: aborting due to previous error\n+"}, {"sha": "dd9d986c2089b28b688c187447ab40751269744a", "filename": "tests/ui/closures/2229_closure_analysis/unique-borrows-are-invariant-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-2.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,31 @@\n+// edition:2021\n+\n+// regression test for #112056\n+\n+struct Spooky<'b> {\n+    owned: Option<&'static u32>,\n+    borrowed: &'b &'static u32,\n+}\n+\n+impl<'b> Spooky<'b> {\n+    fn create_self_reference<'a>(&'a mut self) {\n+        let mut closure = || {\n+            if let Some(owned) = &self.owned {\n+                let borrow: &'a &'static u32 = owned;\n+                self.borrowed = borrow;\n+                //~^ ERROR: lifetime may not live long enough\n+            }\n+        };\n+        closure();\n+    }\n+}\n+\n+fn main() {\n+    let mut spooky: Spooky<'static> = Spooky {\n+        owned: Some(&1),\n+        borrowed: &&1,\n+    };\n+    spooky.create_self_reference();\n+    spooky.owned = None;\n+    println!(\"{}\", **spooky.borrowed);\n+}"}, {"sha": "66ba0fe3547a684dafe726ef838de9217a49d945", "filename": "tests/ui/closures/2229_closure_analysis/unique-borrows-are-invariant-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Funique-borrows-are-invariant-2.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,15 @@\n+error: lifetime may not live long enough\n+  --> $DIR/unique-borrows-are-invariant-2.rs:15:17\n+   |\n+LL | impl<'b> Spooky<'b> {\n+   |      -- lifetime `'b` defined here\n+LL |     fn create_self_reference<'a>(&'a mut self) {\n+   |                              -- lifetime `'a` defined here\n+...\n+LL |                 self.borrowed = borrow;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ assignment requires that `'a` must outlive `'b`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "b1f028fbccb9d81846cca70723bffb735d86d69f", "filename": "tests/ui/coercion/issue-3794.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fcoercion%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fcoercion%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoercion%2Fissue-3794.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-3794.rs"}, {"sha": "4701bc0b139736890b28c68d26394124c6c0deb4", "filename": "tests/ui/coherence/coherence-inherited-subtyping.re.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ac91624d13624c164800fcd28cb234149ce0f5a/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ac91624d13624c164800fcd28cb234149ce0f5a/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr?ref=1ac91624d13624c164800fcd28cb234149ce0f5a", "patch": "@@ -1,14 +0,0 @@\n-error[E0592]: duplicate definitions with name `method1`\n-  --> $DIR/coherence-inherited-subtyping.rs:14:5\n-   |\n-LL |     fn method1(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^ duplicate definitions for `method1`\n-...\n-LL |     fn method1(&self) {}\n-   |     ----------------- other definition for `method1`\n-   |\n-   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0592`."}, {"sha": "f35cd2103da4af5337a08774b77ed75e7479bf72", "filename": "tests/ui/coherence/coherence-inherited-subtyping.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -4,8 +4,6 @@\n // Note: This scenario is currently accepted, but as part of the\n // universe transition (#56105) may eventually become an error.\n \n-// revisions: old re\n-\n struct Foo<T> {\n     t: T,\n }"}, {"sha": "f60b2aa2735d5b6530aebc0bba586ea28259f009", "filename": "tests/ui/coherence/coherence-inherited-subtyping.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,5 +1,5 @@\n error[E0592]: duplicate definitions with name `method1`\n-  --> $DIR/coherence-inherited-subtyping.rs:14:5\n+  --> $DIR/coherence-inherited-subtyping.rs:12:5\n    |\n LL |     fn method1(&self) {}\n    |     ^^^^^^^^^^^^^^^^^ duplicate definitions for `method1`", "previous_filename": "tests/ui/coherence/coherence-inherited-subtyping.old.stderr"}, {"sha": "c68895fc4e63ee6039d4dc278f57c78f903326b1", "filename": "tests/ui/coinduction/canonicalization-rerun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fcoinduction%2Fcanonicalization-rerun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fcoinduction%2Fcanonicalization-rerun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoinduction%2Fcanonicalization-rerun.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n-// revisions: old new\n-//[new] compile-flags: -Ztrait-solver=next\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n \n // If we use canonical goals during trait solving we have to reevaluate\n // the root goal of a cycle until we hit a fixpoint."}, {"sha": "e320df4b7ad8f95dc2ce29b443abed72b28ea08c", "filename": "tests/ui/consts/issue-16538.mir.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-16538.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-16538.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-16538.mir.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-16538.mir.stderr"}, {"sha": "270fa3014142732f78dc776dca3b3ed086e44e0a", "filename": "tests/ui/consts/issue-16538.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-16538.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-16538.rs"}, {"sha": "4a862869274f8943d827673209b7d51140492e77", "filename": "tests/ui/consts/issue-16538.thir.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-16538.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-16538.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-16538.thir.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-16538.thir.stderr"}, {"sha": "10e5d1dd0ac157caf207d9a8bd97ab9af6657f5a", "filename": "tests/ui/consts/issue-28822.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-28822.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-28822.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-28822.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-28822.rs"}, {"sha": "5eff5d1915bad5130c63916e1714025a5204d74d", "filename": "tests/ui/consts/issue-29798.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-29798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fconsts%2Fissue-29798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-29798.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-29798.rs"}, {"sha": "b49f2950020a2d32dd43db3731ddc046b14897c2", "filename": "tests/ui/enum-discriminant/issue-50689.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fenum-discriminant%2Fissue-50689.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fenum-discriminant%2Fissue-50689.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum-discriminant%2Fissue-50689.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-50689.rs"}, {"sha": "c2c047c79615ec99b2749f165ed9b8d143768e3a", "filename": "tests/ui/extern/issue-1251.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fextern%2Fissue-1251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fextern%2Fissue-1251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextern%2Fissue-1251.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-1251.rs"}, {"sha": "de5a6d35925869810728fad41e681fc93937fbd8", "filename": "tests/ui/for-loop-while/issue-1257.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Ffor-loop-while%2Fissue-1257.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Ffor-loop-while%2Fissue-1257.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor-loop-while%2Fissue-1257.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/issues/issue-1257.rs"}, {"sha": "769b6a9253769a44edf9b1fdc8aa04d3feac63fe", "filename": "tests/ui/higher-rank-trait-bounds/issue-95230.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ac91624d13624c164800fcd28cb234149ce0f5a/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac91624d13624c164800fcd28cb234149ce0f5a/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs?ref=1ac91624d13624c164800fcd28cb234149ce0f5a", "patch": "@@ -1,11 +0,0 @@\n-// revisions: old new\n-//[new] compile-flags: -Ztrait-solver=next\n-//[old] check-pass\n-//[new] known-bug: #109764\n-\n-\n-pub struct Bar\n-where\n-    for<'a> &'a mut Self:;\n-\n-fn main() {}"}, {"sha": "f3393347d90dc5a74c9e6b94308eb9729a5d9061", "filename": "tests/ui/higher-ranked/higher-lifetime-bounds.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fhigher-lifetime-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fhigher-lifetime-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fhigher-lifetime-bounds.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-lifetime-bounds.rs"}, {"sha": "bc6d2288cdfc4fc6fa7b5681a426376055c666c4", "filename": "tests/ui/higher-ranked/higher-lifetime-bounds.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fhigher-lifetime-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fhigher-lifetime-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fhigher-lifetime-bounds.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-lifetime-bounds.stderr"}, {"sha": "e8d6cff856c9e840a309d0da1553e1d097236b4e", "filename": "tests/ui/higher-ranked/leak-check-in-selection.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fleak-check-in-selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fleak-check-in-selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fleak-check-in-selection.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n+#![allow(coherence_leak_check)]\n+\n+trait Trait: Sized {\n+    fn is_higher_ranked(self) -> bool;\n+}\n+\n+impl Trait for for<'a> fn(&'a ()) {\n+    fn is_higher_ranked(self) -> bool {\n+        true\n+    }\n+}\n+impl<'a> Trait for fn(&'a ()) {\n+    fn is_higher_ranked(self) -> bool {\n+        false\n+    }\n+}\n+\n+fn main() {\n+    let x: for<'a> fn(&'a ()) = |&()| ();\n+    assert!(x.is_higher_ranked());\n+}"}, {"sha": "b7264c7e933f30d744adf60f8fc15d47d2dbcf70", "filename": "tests/ui/higher-ranked/subtype/hr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/hr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr"}, {"sha": "2355979b0f95d7dc3488790e687095332ce6d5ae", "filename": "tests/ui/higher-ranked/subtype/hr-subtype.bound_a_vs_free_x.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_a_vs_free_x.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/hr-subtype.bound_a_vs_free_x.stderr"}, {"sha": "a73c03feb8768a474973d3d4e8240c16f4df2556", "filename": "tests/ui/higher-ranked/subtype/hr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/hr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr"}, {"sha": "31d36d7168b612f6e6f1010d49a242eab4ca9566", "filename": "tests/ui/higher-ranked/subtype/hr-subtype.free_inv_x_vs_free_inv_y.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/hr-subtype.free_inv_x_vs_free_inv_y.stderr"}, {"sha": "269cde54c7e3d2acc15b1a07956c8efd49fc4674", "filename": "tests/ui/higher-ranked/subtype/hr-subtype.free_x_vs_free_y.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.free_x_vs_free_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.free_x_vs_free_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.free_x_vs_free_y.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/hr-subtype.free_x_vs_free_y.stderr"}, {"sha": "c770e0de85c0805b80b26a8c380da651db35e786", "filename": "tests/ui/higher-ranked/subtype/hr-subtype.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fhr-subtype.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/hr-subtype.rs"}, {"sha": "bd4533e0433ff8a4084dc1736c67b4bc22b883cd", "filename": "tests/ui/higher-ranked/subtype/placeholder-pattern-fail.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern-fail.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/placeholder-pattern-fail.rs"}, {"sha": "73b0a3173644772a32c111083e5a00e6250112c2", "filename": "tests/ui/higher-ranked/subtype/placeholder-pattern-fail.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern-fail.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/placeholder-pattern-fail.stderr"}, {"sha": "061e66e54d2f442541b8fe8cdf2da5a8916845de", "filename": "tests/ui/higher-ranked/subtype/placeholder-pattern.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Fplaceholder-pattern.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/placeholder-pattern.rs"}, {"sha": "6455854f34db89cc8a7bd0e112733a2f4bd0e3de", "filename": "tests/ui/higher-ranked/subtype/return-static.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Freturn-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Freturn-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Fsubtype%2Freturn-static.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/hr-subtype/return-static.rs"}, {"sha": "8cdfe247e025e7b17626f8976fbaaeb2ff781f81", "filename": "tests/ui/higher-ranked/trait-bounds/complex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fcomplex.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/complex.rs"}, {"sha": "1afd15613b51c301643befc0db04542813a037c9", "filename": "tests/ui/higher-ranked/trait-bounds/due-to-where-clause.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fdue-to-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fdue-to-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fdue-to-where-clause.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/due-to-where-clause.rs"}, {"sha": "520938a633514b6c41bdf929605ab24a2f061843", "filename": "tests/ui/higher-ranked/trait-bounds/due-to-where-clause.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fdue-to-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fdue-to-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fdue-to-where-clause.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/due-to-where-clause.stderr"}, {"sha": "9af6bc45c7a060c14ff3f875983ce0bdaf2ef3a8", "filename": "tests/ui/higher-ranked/trait-bounds/fn-ptr.classic.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Ffn-ptr.classic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Ffn-ptr.classic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Ffn-ptr.classic.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/fn-ptr.classic.stderr"}, {"sha": "853160f961245ce3388972fd4c4e68f27fb0c767", "filename": "tests/ui/higher-ranked/trait-bounds/fn-ptr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Ffn-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Ffn-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Ffn-ptr.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/fn-ptr.rs"}, {"sha": "d34b7a29623cfcfa30ee313b3d1779ecf493ebcf", "filename": "tests/ui/higher-ranked/trait-bounds/hang-on-deeply-nested-dyn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhang-on-deeply-nested-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhang-on-deeply-nested-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhang-on-deeply-nested-dyn.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hang-on-deeply-nested-dyn.rs"}, {"sha": "a9d649b8285220f97be93571f07173c420a823db", "filename": "tests/ui/higher-ranked/trait-bounds/hang-on-deeply-nested-dyn.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhang-on-deeply-nested-dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhang-on-deeply-nested-dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhang-on-deeply-nested-dyn.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -14,7 +14,7 @@ LL |       f\n    |       ^ expected `&dyn Fn(&dyn Fn(&dyn Fn(&...)))`, found `&dyn Fn(u32)`\n    |\n    = note: expected reference `&dyn Fn(&dyn Fn(&dyn Fn(&dyn Fn(&dyn Fn(&dyn Fn(&dyn Fn(&dyn Fn(&dyn Fn(&dyn Fn(&dyn Fn(&...)))))))))))`\n-           the full type name has been written to '$TEST_BUILD_DIR/higher-rank-trait-bounds/hang-on-deeply-nested-dyn/hang-on-deeply-nested-dyn.long-type-hash.txt'\n+           the full type name has been written to '$TEST_BUILD_DIR/higher-ranked/trait-bounds/hang-on-deeply-nested-dyn/hang-on-deeply-nested-dyn.long-type-hash.txt'\n               found reference `&dyn Fn(u32)`\n \n error: aborting due to previous error", "previous_filename": "tests/ui/higher-rank-trait-bounds/hang-on-deeply-nested-dyn.stderr"}, {"sha": "cc766c0605c9f03e648a2299bba744b01bb6fb2b", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-binder-levels-in-object-types.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-binder-levels-in-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-binder-levels-in-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-binder-levels-in-object-types.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-binder-levels-in-object-types.rs"}, {"sha": "a20d03c7747cdb24078e791a4a31de085176744b", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-cache-issue-54302.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-cache-issue-54302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-cache-issue-54302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-cache-issue-54302.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-cache-issue-54302.rs"}, {"sha": "f014eab8601fa4a728a6411304841a81553f5eeb", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-cache-issue-54302.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-cache-issue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-cache-issue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-cache-issue-54302.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-cache-issue-54302.stderr"}, {"sha": "e83686404a351b1f5abf79a41038192b870b0642", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-conflate-regions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-conflate-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-conflate-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-conflate-regions.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-conflate-regions.rs"}, {"sha": "46f5308dd87ba4cb193cc6884f806743790f883f", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-conflate-regions.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-conflate-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-conflate-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-conflate-regions.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-conflate-regions.stderr"}, {"sha": "05d3e1a434e69c78d0bf37e837e35251cc037fc2", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-debruijn-in-receiver.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-in-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-in-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-in-receiver.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-debruijn-in-receiver.rs"}, {"sha": "fa391ecba8a9510a686be3cf2057f324bd28480f", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-debruijn-in-receiver.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-in-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-in-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-in-receiver.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-debruijn-in-receiver.stderr"}, {"sha": "8431226a3ece1205a9dad2c9c292db413bad4751", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-debruijn-object-types-in-closures.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-object-types-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-object-types-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-debruijn-object-types-in-closures.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-debruijn-object-types-in-closures.rs"}, {"sha": "567802376184da5316e82becf37edbb70d9724c1", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-exists-forall-fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-fn.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-exists-forall-fn.rs"}, {"sha": "9914783d9767d5d99ecd0790eae8597cc1714265", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-exists-forall-fn.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-fn.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-exists-forall-fn.stderr"}, {"sha": "921061916fc95b7d46c891db83d39cfae29499a5", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-exists-forall-trait-contravariant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-contravariant.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-exists-forall-trait-contravariant.rs"}, {"sha": "364b613fc7717b87ac4401c7d5edaa7883bad873", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-exists-forall-trait-contravariant.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-contravariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-contravariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-contravariant.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-exists-forall-trait-contravariant.stderr"}, {"sha": "f95496a6c3cc0dc5845f83dfede498241dd2632f", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-exists-forall-trait-covariant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-covariant.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-exists-forall-trait-covariant.rs"}, {"sha": "9b9e4496a870dc926c88791b9e4aaebc4e54d623", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-exists-forall-trait-invariant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-invariant.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-exists-forall-trait-invariant.rs"}, {"sha": "cb2ce8a4116aa887b5621130f33e9f5e1bbd391d", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-exists-forall-trait-invariant.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-invariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-invariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-exists-forall-trait-invariant.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-exists-forall-trait-invariant.stderr"}, {"sha": "ff84ad9d2988e4bb2c5507659b5e4c902469d939", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-fn-like-trait-object.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-fn-like-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-fn-like-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-fn-like-trait-object.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-fn-like-trait-object.rs"}, {"sha": "afab9986ce2a34041a03403722373cdeb0e681d9", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-fn-like-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-fn-like-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-fn-like-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-fn-like-trait.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-fn-like-trait.rs"}, {"sha": "f9ae1429ee4a2c52a2a4c6e03a29ef3fe512c849", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-higher-ranker-supertraits-transitive.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits-transitive.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-higher-ranker-supertraits-transitive.rs"}, {"sha": "b1b8ffa8c548336a75f06f80439a71f174492fd1", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-higher-ranker-supertraits-transitive.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits-transitive.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-higher-ranker-supertraits-transitive.stderr"}, {"sha": "48ebe5017aa62df306ff1efa806a4a39cf689726", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-higher-ranker-supertraits.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-higher-ranker-supertraits.rs"}, {"sha": "7f96909b6e76e3afc51cd0854a2c4c5a58b1a3d0", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-higher-ranker-supertraits.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-higher-ranker-supertraits.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-higher-ranker-supertraits.stderr"}, {"sha": "89fc4705a787fa1cc976b803c7bbfed38f685577", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-identity-fn-borrows.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-identity-fn-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-identity-fn-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-identity-fn-borrows.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-identity-fn-borrows.rs"}, {"sha": "25af011e3fc410049cc0a39322f06044556a0431", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-identity-fn-borrows.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-identity-fn-borrows.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-identity-fn-borrows.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-identity-fn-borrows.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-identity-fn-borrows.stderr"}, {"sha": "8fb4218f8a409cb3d50993eab69b043c40048456", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-just-for-static.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-just-for-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-just-for-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-just-for-static.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-just-for-static.rs"}, {"sha": "31e11e12835166a4aca0c219a9cfd58ecc0f3b0b", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-just-for-static.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-just-for-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-just-for-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-just-for-static.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-just-for-static.stderr"}, {"sha": "4b096be591a049ff7c50a0a354bfde6a84ce118a", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-malformed-lifetime-generics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-malformed-lifetime-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-malformed-lifetime-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-malformed-lifetime-generics.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-malformed-lifetime-generics.rs"}, {"sha": "e8f6d63b5ab8ad0bbd355506e99b339c97667f1d", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-malformed-lifetime-generics.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-malformed-lifetime-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-malformed-lifetime-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-malformed-lifetime-generics.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-malformed-lifetime-generics.stderr"}, {"sha": "04519f116003191004d3f9601ddf62762f035b11", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-opt-in-copy.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-opt-in-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-opt-in-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-opt-in-copy.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-opt-in-copy.rs"}, {"sha": "1fab9758c5c83bd28adde3df8dee45f3d8a57d11", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-parse.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-parse.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-parse.rs"}, {"sha": "a94c80eb30b16c23589d081828522ac35303e96c", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-perfect-forwarding.polonius.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.polonius.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-perfect-forwarding.polonius.stderr"}, {"sha": "d45fa183c0c4c5f8cd571d5ba5dd32f384e52ffa", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-perfect-forwarding.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-perfect-forwarding.rs"}, {"sha": "727b9e6bec8e6aa01587077b370d4b2bf80dd4bc", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-perfect-forwarding.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-perfect-forwarding.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-perfect-forwarding.stderr"}, {"sha": "42247798f661b1ec7887e15d5023a9b688c95512", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-precedence-of-plus-where-clause.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-precedence-of-plus-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-precedence-of-plus-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-precedence-of-plus-where-clause.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-precedence-of-plus-where-clause.rs"}, {"sha": "6834c392d4e96634a8791cf071857fec2e9a3925", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-precedence-of-plus.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-precedence-of-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-precedence-of-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-precedence-of-plus.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-precedence-of-plus.rs"}, {"sha": "b97fdf4df508f2160a5e722d97741824190d9e24", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-resolve-lifetime.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-resolve-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-resolve-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-resolve-lifetime.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-resolve-lifetime.rs"}, {"sha": "d8c726cdd71e50b0bb94b6991fe72f11754194bc", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-trait-object-paren-notation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-trait-object-paren-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-trait-object-paren-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-trait-object-paren-notation.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-trait-object-paren-notation.rs"}, {"sha": "41ebb3f5a14ab1ee07b4cf085edf9cf6457198d5", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-trait-object-passed-to-closure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-trait-object-passed-to-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-trait-object-passed-to-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-trait-object-passed-to-closure.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-trait-object-passed-to-closure.rs"}, {"sha": "88d396101dba23106de9a1daf0e6e3c325e9f8f6", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-type-outlives.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-type-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-type-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-type-outlives.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-type-outlives.rs"}, {"sha": "a4a8a5ac6ccbc42c127e2e631ca1747b4e051d39", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-unboxed-closure-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-unboxed-closure-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-unboxed-closure-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-unboxed-closure-trait.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-unboxed-closure-trait.rs"}, {"sha": "1a9bb252340a6f1d0048fa0235341e3f24099507", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-wrong-kind.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-wrong-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-wrong-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-wrong-kind.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-wrong-kind.rs"}, {"sha": "765ea9f7854036087c38357513ca26a7c663942c", "filename": "tests/ui/higher-ranked/trait-bounds/hrtb-wrong-kind.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-wrong-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-wrong-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fhrtb-wrong-kind.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/hrtb-wrong-kind.stderr"}, {"sha": "2db7f8a354cf58479eae15f7c81282ef25a274fc", "filename": "tests/ui/higher-ranked/trait-bounds/issue-100689.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-100689.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-100689.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-100689.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-100689.rs"}, {"sha": "952b81584f30d9ce0bf24ead28e785d8716d2fed", "filename": "tests/ui/higher-ranked/trait-bounds/issue-102899.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-102899.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-102899.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-102899.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-102899.rs"}, {"sha": "4a6399c8f62468da8df6562ddcabec733ae10557", "filename": "tests/ui/higher-ranked/trait-bounds/issue-30786.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-30786.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-30786.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-30786.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-30786.rs"}, {"sha": "f32ba57200d535f1ad813870c8498e2f8ac38072", "filename": "tests/ui/higher-ranked/trait-bounds/issue-30786.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-30786.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-30786.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-30786.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "patch": "@@ -31,7 +31,7 @@ LL | pub struct Filter<S, F> {\n LL |     let count = filter.countx();\n    |                        ^^^^^^ method cannot be called due to unsatisfied trait bounds\n    |\n-   = note: the full type name has been written to '$TEST_BUILD_DIR/higher-rank-trait-bounds/issue-30786/issue-30786.long-type-hash.txt'\n+   = note: the full type name has been written to '$TEST_BUILD_DIR/higher-ranked/trait-bounds/issue-30786/issue-30786.long-type-hash.txt'\n note: the following trait bounds were not satisfied:\n       `&'a mut &Filter<Map<Repeat, for<'a> fn(&'a u64) -> &'a u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:131:30: 131:37]>: Stream`\n       `&'a mut &mut Filter<Map<Repeat, for<'a> fn(&'a u64) -> &'a u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:131:30: 131:37]>: Stream`", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-30786.stderr"}, {"sha": "2d49151ffccc1d209f9746b25adc08b1a9f251f6", "filename": "tests/ui/higher-ranked/trait-bounds/issue-36139-normalize-closure-sig.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-36139-normalize-closure-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-36139-normalize-closure-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-36139-normalize-closure-sig.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-36139-normalize-closure-sig.rs"}, {"sha": "968cf08916fd6dd2bfd840e605fb7c0c715d4df7", "filename": "tests/ui/higher-ranked/trait-bounds/issue-39292.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-39292.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-39292.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-39292.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-39292.rs"}, {"sha": "01515fdc9d2bff7b47479cb52d8db50a0ca79e5d", "filename": "tests/ui/higher-ranked/trait-bounds/issue-42114.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-42114.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-42114.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-42114.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-42114.rs"}, {"sha": "cedcf7c361c3bbb6d32109c49be0aaa2c28adf72", "filename": "tests/ui/higher-ranked/trait-bounds/issue-43623.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-43623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-43623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-43623.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-43623.rs"}, {"sha": "4a09f4be156e2bb60a879883cf640004796c28d1", "filename": "tests/ui/higher-ranked/trait-bounds/issue-46989.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-46989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-46989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-46989.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-46989.rs"}, {"sha": "3f874220a270809870f519518cda65675b160e87", "filename": "tests/ui/higher-ranked/trait-bounds/issue-46989.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-46989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-46989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-46989.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-46989.stderr"}, {"sha": "392e7233b567aecf26e5402746ccc5b536c399e5", "filename": "tests/ui/higher-ranked/trait-bounds/issue-57639.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-57639.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-57639.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-57639.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-57639.rs"}, {"sha": "6006a108c5cc6e3adc7c69ea31e6aa1970d4dfa8", "filename": "tests/ui/higher-ranked/trait-bounds/issue-58451.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-58451.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-58451.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-58451.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-58451.rs"}, {"sha": "0f051be2128b0486cfcda81f474e94ac8f563db3", "filename": "tests/ui/higher-ranked/trait-bounds/issue-58451.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-58451.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-58451.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-58451.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-58451.stderr"}, {"sha": "3ad548450e583df0b2064e7de88cf85c54ef3b98", "filename": "tests/ui/higher-ranked/trait-bounds/issue-59311.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-59311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-59311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-59311.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-59311.rs"}, {"sha": "c01ab8e347c6c11b3ab6a0490e93a05059962329", "filename": "tests/ui/higher-ranked/trait-bounds/issue-59311.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-59311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-59311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-59311.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-59311.stderr"}, {"sha": "05315b3f9f5e9931275c7dbc590c99ba4b6a7bfc", "filename": "tests/ui/higher-ranked/trait-bounds/issue-60283.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-60283.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-60283.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-60283.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-60283.rs"}, {"sha": "e70f6fc3430f67726e0192f0119ffd3657d5cff2", "filename": "tests/ui/higher-ranked/trait-bounds/issue-62203-hrtb-ice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-62203-hrtb-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-62203-hrtb-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-62203-hrtb-ice.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-62203-hrtb-ice.rs"}, {"sha": "4d470ae70229f1f5fe1fd4804433073bb4e8c598", "filename": "tests/ui/higher-ranked/trait-bounds/issue-62203-hrtb-ice.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-62203-hrtb-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-62203-hrtb-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-62203-hrtb-ice.stderr?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-62203-hrtb-ice.stderr"}, {"sha": "571b8531757cdc4579771b716e1711ca63c3354b", "filename": "tests/ui/higher-ranked/trait-bounds/issue-88446.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-88446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb35803cb7990a12d83aab676fd546de00ca8b7f/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-88446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-ranked%2Ftrait-bounds%2Fissue-88446.rs?ref=fb35803cb7990a12d83aab676fd546de00ca8b7f", "previous_filename": "tests/ui/higher-rank-trait-bounds/issue-88446.rs"}]}