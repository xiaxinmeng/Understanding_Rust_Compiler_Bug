{"sha": "db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDNiNThmMjNiYThiNGI5ZWU4OWIyY2UyODU4OGRhNmI1MjI1YzM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-12-30T19:09:26Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-12-31T09:53:37Z"}, "message": "remove move_val_init leftovers", "tree": {"sha": "57cea70856623ad8ab31d05cc2d643e54dcd2742", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57cea70856623ad8ab31d05cc2d643e54dcd2742"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "html_url": "https://github.com/rust-lang/rust/commit/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1862135351e87905e7a497bee96f199040ce1b51", "url": "https://api.github.com/repos/rust-lang/rust/commits/1862135351e87905e7a497bee96f199040ce1b51", "html_url": "https://github.com/rust-lang/rust/commit/1862135351e87905e7a497bee96f199040ce1b51"}], "stats": {"total": 434, "additions": 36, "deletions": 398}, "files": [{"sha": "0732d2568ad1dab081e9fe46d835c28d109347b8", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "patch": "@@ -223,21 +223,13 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n         // Check for raw pointer `Deref`.\n         for (base, proj) in place.iter_projections() {\n             if proj == ProjectionElem::Deref {\n-                let source_info = self.source_info; // Backup source_info so we can restore it later.\n-                if base.projection.is_empty() && decl.internal {\n-                    // Internal locals are used in the `move_val_init` desugaring.\n-                    // We want to check unsafety against the source info of the\n-                    // desugaring, rather than the source info of the RHS.\n-                    self.source_info = self.body.local_decls[place.local].source_info;\n-                }\n                 let base_ty = base.ty(self.body, self.tcx).ty;\n                 if base_ty.is_unsafe_ptr() {\n                     self.require_unsafe(\n                         UnsafetyViolationKind::GeneralAndConstFn,\n                         UnsafetyViolationDetails::DerefOfRawPointer,\n                     )\n                 }\n-                self.source_info = source_info; // Restore backed-up source_info.\n             }\n         }\n "}, {"sha": "59bb701db64ee960ca1abdff12aa25a555108130", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 34, "deletions": 74, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "patch": "@@ -10,9 +10,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, CanonicalUserTypeAnnotation};\n-use rustc_span::symbol::sym;\n-use rustc_target::spec::abi::Abi;\n+use rustc_middle::ty::{CanonicalUserTypeAnnotation};\n \n use std::slice;\n \n@@ -185,79 +183,41 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 )\n             }\n-            ExprKind::Call { ty, fun, args, from_hir_call, fn_span } => {\n-                let intrinsic = match *ty.kind() {\n-                    ty::FnDef(def_id, _) => {\n-                        let f = ty.fn_sig(this.hir.tcx());\n-                        if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n-                            Some(this.hir.tcx().item_name(def_id))\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    _ => None,\n-                };\n+            ExprKind::Call { ty: _, fun, args, from_hir_call, fn_span } => {\n                 let fun = unpack!(block = this.as_local_operand(block, fun));\n-                if let Some(sym::move_val_init) = intrinsic {\n-                    // `move_val_init` has \"magic\" semantics - the second argument is\n-                    // always evaluated \"directly\" into the first one.\n-\n-                    let mut args = args.into_iter();\n-                    let ptr = args.next().expect(\"0 arguments to `move_val_init`\");\n-                    let val = args.next().expect(\"1 argument to `move_val_init`\");\n-                    assert!(args.next().is_none(), \">2 arguments to `move_val_init`\");\n-\n-                    let ptr = this.hir.mirror(ptr);\n-                    let ptr_ty = ptr.ty;\n-                    // Create an *internal* temp for the pointer, so that unsafety\n-                    // checking won't complain about the raw pointer assignment.\n-                    let ptr_temp = this\n-                        .local_decls\n-                        .push(LocalDecl::with_source_info(ptr_ty, source_info).internal());\n-                    let ptr_temp = Place::from(ptr_temp);\n-                    // No need for a scope, ptr_temp doesn't need drop\n-                    let block = unpack!(this.into(ptr_temp, None, block, ptr));\n-                    // Maybe we should provide a scope here so that\n-                    // `move_val_init` wouldn't leak on panic even with an\n-                    // arbitrary `val` expression, but `schedule_drop`,\n-                    // borrowck and drop elaboration all prevent us from\n-                    // dropping `ptr_temp.deref()`.\n-                    this.into(this.hir.tcx().mk_place_deref(ptr_temp), None, block, val)\n-                } else {\n-                    let args: Vec<_> = args\n-                        .into_iter()\n-                        .map(|arg| unpack!(block = this.as_local_call_operand(block, arg)))\n-                        .collect();\n-\n-                    let success = this.cfg.start_new_block();\n-\n-                    this.record_operands_moved(&args);\n-\n-                    debug!(\"into_expr: fn_span={:?}\", fn_span);\n-\n-                    this.cfg.terminate(\n-                        block,\n-                        source_info,\n-                        TerminatorKind::Call {\n-                            func: fun,\n-                            args,\n-                            cleanup: None,\n-                            // FIXME(varkor): replace this with an uninhabitedness-based check.\n-                            // This requires getting access to the current module to call\n-                            // `tcx.is_ty_uninhabited_from`, which is currently tricky to do.\n-                            destination: if expr.ty.is_never() {\n-                                None\n-                            } else {\n-                                Some((destination, success))\n-                            },\n-                            from_hir_call,\n-                            fn_span,\n+                let args: Vec<_> = args\n+                    .into_iter()\n+                    .map(|arg| unpack!(block = this.as_local_call_operand(block, arg)))\n+                    .collect();\n+\n+                let success = this.cfg.start_new_block();\n+\n+                this.record_operands_moved(&args);\n+\n+                debug!(\"into_expr: fn_span={:?}\", fn_span);\n+\n+                this.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Call {\n+                        func: fun,\n+                        args,\n+                        cleanup: None,\n+                        // FIXME(varkor): replace this with an uninhabitedness-based check.\n+                        // This requires getting access to the current module to call\n+                        // `tcx.is_ty_uninhabited_from`, which is currently tricky to do.\n+                        destination: if expr.ty.is_never() {\n+                            None\n+                        } else {\n+                            Some((destination, success))\n                         },\n-                    );\n-                    this.diverge_from(block);\n-                    schedule_drop(this);\n-                    success.unit()\n-                }\n+                        from_hir_call,\n+                        fn_span,\n+                    },\n+                );\n+                this.diverge_from(block);\n+                schedule_drop(this);\n+                success.unit()\n             }\n             ExprKind::Use { source } => this.into(destination, scope, block, source),\n             ExprKind::Borrow { arg, borrow_kind } => {"}, {"sha": "2ef50cda2a8e3de452cccebc6c2faef7fe440d12", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "patch": "@@ -713,7 +713,6 @@ symbols! {\n         more_struct_aliases,\n         movbe_target_feature,\n         move_ref_pattern,\n-        move_val_init,\n         mul,\n         mul_assign,\n         mul_with_overflow,"}, {"sha": "aff90c857c6d4a3c0c9afcec2a647bfeef119821", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "patch": "@@ -159,7 +159,6 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             }\n             sym::forget => (1, vec![param(0)], tcx.mk_unit()),\n             sym::transmute => (2, vec![param(0)], param(1)),\n-            sym::move_val_init => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n             sym::prefetch_read_data\n             | sym::prefetch_write_data\n             | sym::prefetch_read_instruction"}, {"sha": "6222536b506007871dcafb71ad15d4d353074dca", "filename": "src/test/codegen/intrinsics/move-val-init.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fcodegen%2Fintrinsics%2Fmove-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fcodegen%2Fintrinsics%2Fmove-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fmove-val-init.rs?ref=1862135351e87905e7a497bee96f199040ce1b51", "patch": "@@ -1,19 +0,0 @@\n-// compile-flags: -C no-prepopulate-passes\n-\n-#![feature(core_intrinsics)]\n-#![crate_type = \"lib\"]\n-\n-// test that `move_val_init` actually avoids big allocas\n-\n-use std::intrinsics::move_val_init;\n-\n-pub struct Big {\n-    pub data: [u8; 65536]\n-}\n-\n-// CHECK-LABEL: @test_mvi\n-#[no_mangle]\n-pub unsafe fn test_mvi(target: *mut Big, make_big: fn() -> Big) {\n-    // CHECK: call void %make_big(%Big*{{[^%]*}} %target)\n-    move_val_init(target, make_big());\n-}"}, {"sha": "9804c421db081cec72c5def5ef4305a808d921da", "filename": "src/test/ui/intrinsics/intrinsic-move-val-cleanups.rs", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs?ref=1862135351e87905e7a497bee96f199040ce1b51", "patch": "@@ -1,191 +0,0 @@\n-// run-pass\n-#![allow(unused_braces)]\n-#![allow(unused_unsafe)]\n-#![allow(unreachable_code)]\n-// ignore-emscripten no threads support\n-#![allow(stable_features)]\n-\n-// This test is checking that the move_val_init intrinsic is\n-// respecting cleanups for both of its argument expressions.\n-//\n-// In other words, if either DEST or SOURCE in\n-//\n-//   `intrinsics::move_val_init(DEST, SOURCE)\n-//\n-// introduce temporaries that require cleanup, and SOURCE panics, then\n-// make sure the cleanups still occur.\n-\n-#![feature(core_intrinsics, sync_poison)]\n-\n-use std::cell::RefCell;\n-use std::intrinsics;\n-use std::sync::{Arc, LockResult, Mutex, MutexGuard};\n-use std::thread;\n-\n-type LogEntry = (&'static str, i32);\n-type Guarded = RefCell<Vec<LogEntry>>;\n-#[derive(Clone)]\n-struct Log(Arc<Mutex<Guarded>>);\n-struct Acquired<'a>(MutexGuard<'a, Guarded>);\n-type LogState = (MutexWas, &'static [LogEntry]);\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum MutexWas { Poisoned, NotPoisoned }\n-\n-impl Log {\n-    fn lock(&self) -> LockResult<MutexGuard<RefCell<Vec<LogEntry>>>> { self.0.lock() }\n-    fn acquire(&self) -> Acquired { Acquired(self.0.lock().unwrap()) }\n-}\n-\n-impl<'a> Acquired<'a> {\n-    fn log(&self, s: &'static str, i: i32) { self.0.borrow_mut().push((s, i)); }\n-}\n-\n-const TEST1_EXPECT: LogState = (MutexWas::NotPoisoned,\n-                                &[(\"double-check non-poisoning path\", 1)\n-                                  ]);\n-\n-fn test1(log: Log) {\n-    {\n-        let acq = log.acquire();\n-        acq.log(\"double-check non-poisoning path\", 1);\n-    }\n-    panic!(\"every test ends in a panic\");\n-}\n-\n-const TEST2_EXPECT: LogState = (MutexWas::Poisoned,\n-                                &[(\"double-check poisoning path\", 1),\n-                                  (\"and multiple log entries\", 2),\n-                                  ]);\n-fn test2(log: Log) {\n-    let acq = log.acquire();\n-    acq.log(\"double-check poisoning path\", 1);\n-    acq.log(\"and multiple log entries\", 2);\n-    panic!(\"every test ends in a panic\");\n-}\n-\n-struct LogOnDrop<'a>(&'a Acquired<'a>, &'static str, i32);\n-impl<'a> Drop for LogOnDrop<'a> {\n-    fn drop(&mut self) {\n-        self.0.log(self.1, self.2);\n-    }\n-}\n-\n-const TEST3_EXPECT: LogState = (MutexWas::Poisoned,\n-                                &[(\"double-check destructors can log\", 1),\n-                                  (\"drop d2\", 2),\n-                                  (\"drop d1\", 3),\n-                                  ]);\n-fn test3(log: Log) {\n-    let acq = log.acquire();\n-    acq.log(\"double-check destructors can log\", 1);\n-    let _d1 = LogOnDrop(&acq, \"drop d1\", 3);\n-    let _d2 = LogOnDrop(&acq, \"drop d2\", 2);\n-    panic!(\"every test ends in a panic\");\n-}\n-\n-// The *real* tests of panic-handling for move_val_init intrinsic\n-// start here.\n-\n-const TEST4_EXPECT: LogState = (MutexWas::Poisoned,\n-                                &[(\"neither arg panics\", 1),\n-                                  (\"drop temp LOD\", 2),\n-                                  (\"drop temp LOD\", 3),\n-                                  (\"drop dest_b\", 4),\n-                                  (\"drop dest_a\", 5),\n-                                  ]);\n-fn test4(log: Log) {\n-    let acq = log.acquire();\n-    acq.log(\"neither arg panics\", 1);\n-    let mut dest_a = LogOnDrop(&acq, \"a will be overwritten, not dropped\", 0);\n-    let mut dest_b = LogOnDrop(&acq, \"b will be overwritten, not dropped\", 0);\n-    unsafe {\n-        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n-                                  LogOnDrop(&acq, \"drop dest_a\", 5));\n-        intrinsics::move_val_init(&mut dest_b, { LogOnDrop(&acq, \"drop temp LOD\", 3);\n-                                                 LogOnDrop(&acq, \"drop dest_b\", 4) });\n-    }\n-    panic!(\"every test ends in a panic\");\n-}\n-\n-\n-// Check that move_val_init(PANIC, SOURCE_EXPR) never evaluates SOURCE_EXPR\n-const TEST5_EXPECT: LogState = (MutexWas::Poisoned,\n-                                &[(\"first arg panics\", 1),\n-                                  (\"drop orig dest_a\", 2),\n-                                  ]);\n-fn test5(log: Log) {\n-    let acq = log.acquire();\n-    acq.log(\"first arg panics\", 1);\n-    let mut _dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 2);\n-    unsafe {\n-        intrinsics::move_val_init({ panic!(\"every test ends in a panic\") },\n-                                  LogOnDrop(&acq, \"we never get here\", 0));\n-    }\n-}\n-\n-// Check that move_val_init(DEST_EXPR, PANIC) cleans up temps from DEST_EXPR.\n-const TEST6_EXPECT: LogState = (MutexWas::Poisoned,\n-                                &[(\"second arg panics\", 1),\n-                                  (\"drop temp LOD\", 2),\n-                                  (\"drop orig dest_a\", 3),\n-                                  ]);\n-fn test6(log: Log) {\n-    let acq = log.acquire();\n-    acq.log(\"second arg panics\", 1);\n-    let mut dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 3);\n-    unsafe {\n-        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n-                                  { panic!(\"every test ends in a panic\"); });\n-    }\n-}\n-\n-// Check that move_val_init(DEST_EXPR, COMPLEX_PANIC) cleans up temps from COMPLEX_PANIC.\n-const TEST7_EXPECT: LogState = (MutexWas::Poisoned,\n-                                &[(\"second arg panics\", 1),\n-                                  (\"drop temp LOD\", 2),\n-                                  (\"drop temp LOD\", 3),\n-                                  (\"drop orig dest_a\", 4),\n-                                  ]);\n-fn test7(log: Log) {\n-    let acq = log.acquire();\n-    acq.log(\"second arg panics\", 1);\n-    let mut dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 4);\n-    unsafe {\n-        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n-                                  { LogOnDrop(&acq, \"drop temp LOD\", 3);\n-                                    panic!(\"every test ends in a panic\"); });\n-    }\n-}\n-\n-const TEST_SUITE: &'static [(&'static str, fn (Log), LogState)] =\n-    &[(\"test1\", test1, TEST1_EXPECT),\n-      (\"test2\", test2, TEST2_EXPECT),\n-      (\"test3\", test3, TEST3_EXPECT),\n-      (\"test4\", test4, TEST4_EXPECT),\n-      (\"test5\", test5, TEST5_EXPECT),\n-      (\"test6\", test6, TEST6_EXPECT),\n-      (\"test7\", test7, TEST7_EXPECT),\n-      ];\n-\n-fn main() {\n-    for &(name, test, expect) in TEST_SUITE {\n-        let log = Log(Arc::new(Mutex::new(RefCell::new(Vec::new()))));\n-        let ret = { let log = log.clone(); thread::spawn(move || test(log)).join() };\n-        assert!(ret.is_err(), \"{} must end with panic\", name);\n-        {\n-            let l = log.lock();\n-            match l {\n-                Ok(acq) => {\n-                    assert_eq!((MutexWas::NotPoisoned, &acq.borrow()[..]), expect);\n-                    println!(\"{} (unpoisoned) log: {:?}\", name, *acq);\n-                }\n-                Err(e) => {\n-                    let acq = e.into_inner();\n-                    assert_eq!((MutexWas::Poisoned, &acq.borrow()[..]), expect);\n-                    println!(\"{} (poisoned) log: {:?}\", name, *acq);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "b672f1ed26e8d8d1dfdd81f57fa2cf929fa5f42b", "filename": "src/test/ui/intrinsics/intrinsic-move-val.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val.rs?ref=1862135351e87905e7a497bee96f199040ce1b51", "patch": "@@ -1,81 +0,0 @@\n-// run-pass\n-\n-#![feature(box_syntax)]\n-#![feature(intrinsics)]\n-\n-mod rusti {\n-    extern \"rust-intrinsic\" {\n-        pub fn move_val_init<T>(dst: *mut T, src: T);\n-    }\n-}\n-\n-pub fn main() {\n-    unsafe {\n-        // sanity check\n-        check_drops_state(0, None);\n-\n-        let mut x: Option<Box<D>> = Some(box D(1));\n-        assert_eq!(x.as_ref().unwrap().0, 1);\n-\n-        // A normal overwrite, to demonstrate `check_drops_state`.\n-        x = Some(box D(2));\n-\n-        // At this point, one destructor has run, because the\n-        // overwrite of `x` drops its initial value.\n-        check_drops_state(1, Some(1));\n-\n-        let mut y: Option<Box<D>> = std::mem::zeroed();\n-\n-        // An initial binding does not overwrite anything.\n-        check_drops_state(1, Some(1));\n-\n-        // Since `y` has been initialized via the `init` intrinsic, it\n-        // would be unsound to directly overwrite its value via normal\n-        // assignment.\n-        //\n-        // The code currently generated by the compiler is overly\n-        // accepting, however, in that it will check if `y` is itself\n-        // null and thus avoid the unsound action of attempting to\n-        // free null. In other words, if we were to do a normal\n-        // assignment like `y = box D(4);` here, it probably would not\n-        // crash today. But the plan is that it may well crash in the\n-        // future, (I believe).\n-\n-        // `x` is moved here; the manner in which this is tracked by the\n-        // compiler is hidden.\n-        rusti::move_val_init(&mut y, x);\n-\n-        // But what we *can* observe is how many times the destructor\n-        // for `D` is invoked, and what the last value we saw was\n-        // during such a destructor call. We do so after the end of\n-        // this scope.\n-\n-        assert_eq!(y.as_ref().unwrap().0, 2);\n-        y.as_mut().unwrap().0 = 3;\n-        assert_eq!(y.as_ref().unwrap().0, 3);\n-\n-        check_drops_state(1, Some(1));\n-    }\n-\n-    check_drops_state(2, Some(3));\n-}\n-\n-static mut NUM_DROPS: i32 = 0;\n-static mut LAST_DROPPED: Option<i32> = None;\n-\n-fn check_drops_state(num_drops: i32, last_dropped: Option<i32>) {\n-    unsafe {\n-        assert_eq!(NUM_DROPS, num_drops);\n-        assert_eq!(LAST_DROPPED, last_dropped);\n-    }\n-}\n-\n-struct D(i32);\n-impl Drop for D {\n-    fn drop(&mut self) {\n-        unsafe {\n-            NUM_DROPS += 1;\n-            LAST_DROPPED = Some(self.0);\n-        }\n-    }\n-}"}, {"sha": "68e3e21df3e0841079bbece611ebcef22e160e6e", "filename": "src/test/ui/panic-handler/weak-lang-item.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db03b58f23ba8b4b9ee89b2ce28588da6b5225c3/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr?ref=db03b58f23ba8b4b9ee89b2ce28588da6b5225c3", "patch": "@@ -10,10 +10,10 @@ help: you can use `as` to change the binding name of the import\n LL | extern crate core as other_core;\n    |\n \n-error: `#[panic_handler]` function required, but not found\n-\n error: language item required, but not found: `eh_personality`\n \n+error: `#[panic_handler]` function required, but not found\n+\n error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0259`."}, {"sha": "24249a7a813ec69f494a440abcd39a49b5cb2309", "filename": "src/test/ui/unsafe/unsafe-move-val-init.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fui%2Funsafe%2Funsafe-move-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fui%2Funsafe%2Funsafe-move-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-move-val-init.rs?ref=1862135351e87905e7a497bee96f199040ce1b51", "patch": "@@ -1,10 +0,0 @@\n-#![feature(core_intrinsics)]\n-\n-use std::intrinsics;\n-\n-// `move_val_init` has an odd desugaring, check that it is still treated\n-// as unsafe.\n-fn main() {\n-    intrinsics::move_val_init(1 as *mut u32, 1);\n-    //~^ ERROR dereference of raw pointer is unsafe\n-}"}, {"sha": "44c2aae7cf4f474ca12025eedcbbf41ca06e298c", "filename": "src/test/ui/unsafe/unsafe-move-val-init.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fui%2Funsafe%2Funsafe-move-val-init.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1862135351e87905e7a497bee96f199040ce1b51/src%2Ftest%2Fui%2Funsafe%2Funsafe-move-val-init.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-move-val-init.stderr?ref=1862135351e87905e7a497bee96f199040ce1b51", "patch": "@@ -1,11 +0,0 @@\n-error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n-  --> $DIR/unsafe-move-val-init.rs:8:5\n-   |\n-LL |     intrinsics::move_val_init(1 as *mut u32, 1);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer\n-   |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0133`."}]}