{"sha": "a5aba685ba8ef7272520b705962abadf6f330b67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YWJhNjg1YmE4ZWY3MjcyNTIwYjcwNTk2MmFiYWRmNmYzMzBiNjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T23:29:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T23:55:59Z"}, "message": "rollup merge of #18534 : huonw/next-floats", "tree": {"sha": "c4da670f21a8c4780c5b599515994a5986465ced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4da670f21a8c4780c5b599515994a5986465ced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5aba685ba8ef7272520b705962abadf6f330b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5aba685ba8ef7272520b705962abadf6f330b67", "html_url": "https://github.com/rust-lang/rust/commit/a5aba685ba8ef7272520b705962abadf6f330b67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5aba685ba8ef7272520b705962abadf6f330b67/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9", "html_url": "https://github.com/rust-lang/rust/commit/eb793616dcf0b1e4cc416dea3bec0ef5b80834a9"}, {"sha": "e49be7aae3b33ba9afa1e517022fab3558af1aba", "url": "https://api.github.com/repos/rust-lang/rust/commits/e49be7aae3b33ba9afa1e517022fab3558af1aba", "html_url": "https://github.com/rust-lang/rust/commit/e49be7aae3b33ba9afa1e517022fab3558af1aba"}], "stats": {"total": 70, "additions": 56, "deletions": 14}, "files": [{"sha": "660603198915103cf7a5a0dbd4b72540ef8ffe46", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5aba685ba8ef7272520b705962abadf6f330b67/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aba685ba8ef7272520b705962abadf6f330b67/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=a5aba685ba8ef7272520b705962abadf6f330b67", "patch": "@@ -227,6 +227,13 @@ fn ziggurat<R:Rng>(\n         // creating a f64), so we might as well reuse some to save\n         // generating a whole extra random number. (Seems to be 15%\n         // faster.)\n+        //\n+        // This unfortunately misses out on the benefits of direct\n+        // floating point generation if an RNG like dSMFT is\n+        // used. (That is, such RNGs create floats directly, highly\n+        // efficiently and overload next_f32/f64, so by not calling it\n+        // this may be slower than it would be otherwise.)\n+        // FIXME: investigate/optimise for the above.\n         let bits: u64 = rng.gen();\n         let i = (bits & 0xff) as uint;\n         let f = (bits >> 11) as f64 / SCALE;"}, {"sha": "3c528c564a7ae6ce0827db3fedd124474ce54f86", "filename": "src/librand/lib.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a5aba685ba8ef7272520b705962abadf6f330b67/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aba685ba8ef7272520b705962abadf6f330b67/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=a5aba685ba8ef7272520b705962abadf6f330b67", "patch": "@@ -78,6 +78,46 @@ pub trait Rng {\n         (self.next_u32() as u64 << 32) | (self.next_u32() as u64)\n     }\n \n+    /// Return the next random f32 selected from the half-open\n+    /// interval `[0, 1)`.\n+    ///\n+    /// By default this is implemented in terms of `next_u32`, but a\n+    /// random number generator which can generate numbers satisfying\n+    /// the requirements directly can overload this for performance.\n+    /// It is required that the return value lies in `[0, 1)`.\n+    ///\n+    /// See `Closed01` for the closed interval `[0,1]`, and\n+    /// `Open01` for the open interval `(0,1)`.\n+    fn next_f32(&mut self) -> f32 {\n+        const MANTISSA_BITS: uint = 24;\n+        const IGNORED_BITS: uint = 8;\n+        const SCALE: f32 = (1u64 << MANTISSA_BITS) as f32;\n+\n+        // using any more than `MANTISSA_BITS` bits will\n+        // cause (e.g.) 0xffff_ffff to correspond to 1\n+        // exactly, so we need to drop some (8 for f32, 11\n+        // for f64) to guarantee the open end.\n+        (self.next_u32() >> IGNORED_BITS) as f32 / SCALE\n+    }\n+\n+    /// Return the next random f64 selected from the half-open\n+    /// interval `[0, 1)`.\n+    ///\n+    /// By default this is implemented in terms of `next_u64`, but a\n+    /// random number generator which can generate numbers satisfying\n+    /// the requirements directly can overload this for performance.\n+    /// It is required that the return value lies in `[0, 1)`.\n+    ///\n+    /// See `Closed01` for the closed interval `[0,1]`, and\n+    /// `Open01` for the open interval `(0,1)`.\n+    fn next_f64(&mut self) -> f64 {\n+        const MANTISSA_BITS: uint = 53;\n+        const IGNORED_BITS: uint = 11;\n+        const SCALE: f64 = (1u64 << MANTISSA_BITS) as f64;\n+\n+        (self.next_u64() >> IGNORED_BITS) as f64 / SCALE\n+    }\n+\n     /// Fill `dest` with random data.\n     ///\n     /// This has a default implementation in terms of `next_u64` and"}, {"sha": "96f40bcc1565e48db09995a9bb6da6ee656ac8d9", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a5aba685ba8ef7272520b705962abadf6f330b67/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aba685ba8ef7272520b705962abadf6f330b67/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=a5aba685ba8ef7272520b705962abadf6f330b67", "patch": "@@ -96,11 +96,11 @@ impl Rand for u64 {\n }\n \n macro_rules! float_impls {\n-    ($mod_name:ident, $ty:ty, $mantissa_bits:expr, $method_name:ident, $ignored_bits:expr) => {\n+    ($mod_name:ident, $ty:ty, $mantissa_bits:expr, $method_name:ident) => {\n         mod $mod_name {\n             use {Rand, Rng, Open01, Closed01};\n \n-            static SCALE: $ty = (1u64 << $mantissa_bits) as $ty;\n+            const SCALE: $ty = (1u64 << $mantissa_bits) as $ty;\n \n             impl Rand for $ty {\n                 /// Generate a floating point number in the half-open\n@@ -110,11 +110,7 @@ macro_rules! float_impls {\n                 /// and `Open01` for the open interval `(0,1)`.\n                 #[inline]\n                 fn rand<R: Rng>(rng: &mut R) -> $ty {\n-                    // using any more than `mantissa_bits` bits will\n-                    // cause (e.g.) 0xffff_ffff to correspond to 1\n-                    // exactly, so we need to drop some (8 for f32, 11\n-                    // for f64) to guarantee the open end.\n-                    (rng.$method_name() >> $ignored_bits) as $ty / SCALE\n+                    rng.$method_name()\n                 }\n             }\n             impl Rand for Open01<$ty> {\n@@ -124,23 +120,22 @@ macro_rules! float_impls {\n                     // the precision of f64/f32 at 1.0), so that small\n                     // numbers are larger than 0, but large numbers\n                     // aren't pushed to/above 1.\n-                    Open01(((rng.$method_name() >> $ignored_bits) as $ty + 0.25) / SCALE)\n+                    Open01(rng.$method_name() + 0.25 / SCALE)\n                 }\n             }\n             impl Rand for Closed01<$ty> {\n                 #[inline]\n                 fn rand<R: Rng>(rng: &mut R) -> Closed01<$ty> {\n-                    // divide by the maximum value of the numerator to\n-                    // get a non-zero probability of getting exactly\n-                    // 1.0.\n-                    Closed01((rng.$method_name() >> $ignored_bits) as $ty / (SCALE - 1.0))\n+                    // rescale so that 1.0 - epsilon becomes 1.0\n+                    // precisely.\n+                    Closed01(rng.$method_name() * SCALE / (SCALE - 1.0))\n                 }\n             }\n         }\n     }\n }\n-float_impls! { f64_rand_impls, f64, 53, next_u64, 11 }\n-float_impls! { f32_rand_impls, f32, 24, next_u32, 8 }\n+float_impls! { f64_rand_impls, f64, 53, next_f64 }\n+float_impls! { f32_rand_impls, f32, 24, next_f32 }\n \n impl Rand for char {\n     #[inline]"}]}