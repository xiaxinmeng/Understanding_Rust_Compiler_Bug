{"sha": "226ce31edde65a0a4b8eff25aab368694e440d51", "node_id": "C_kwDOAAsO6NoAKDIyNmNlMzFlZGRlNjVhMGE0YjhlZmYyNWFhYjM2ODY5NGU0NDBkNTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-20T13:32:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-20T13:32:55Z"}, "message": "Rollup merge of #108200 - jhpratt:restricted-damerau-levenshtein-distance, r=tmiasko\n\nUse restricted Damerau-Levenshtein distance for diagnostics\n\nThis replaces the existing Levenshtein algorithm with the Damerau-Levenshtein algorithm. This means that \"ab\" to \"ba\" is one change (a transposition) instead of two (a deletion and insertion). More specifically, this is a _restricted_ implementation, in that \"ca\" to \"abc\" cannot be performed as \"ca\" \u2192 \"ac\" \u2192 \"abc\", as there is an insertion in the middle of a transposition. I believe that errors like that are sufficiently rare that it's not worth taking into account.\n\nThis was first brought up [on IRLO](https://internals.rust-lang.org/t/18227) when it was noticed that the diagnostic for `prinltn!` (transposed L and T) was `print!` and not `println!`. Only a single existing UI test was effected, with the result being an objective improvement.\n\n~~I have left the method name and various other references to the Levenshtein algorithm untouched, as the exact manner in which the edit distance is calculated should not be relevant to the caller.~~\n\nr? ``@estebank``\n\n``@rustbot`` label +A-diagnostics +C-enhancement", "tree": {"sha": "4cc4a60002008bdea0145c3a784731fd64cc9474", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cc4a60002008bdea0145c3a784731fd64cc9474"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/226ce31edde65a0a4b8eff25aab368694e440d51", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj83aHCRBK7hj4Ov3rIwAA+O4IAJqCDqEzOlmn9KkGyb/wzUlf\nLS4T1yCCKnwFfBWtUYTpOdRsnN10FeH/ANT9u2TDMKV6TnFQh1fASrrEDfTc8tdt\nhfMLDVIN9EifuQFziu9iVwnazG7f6XCtJyYtc49c0+IFI9k2YztwdCaPs1hkIzAT\nrlXasxftC7EZbWB8OHsVLtE/P1yIYTC9QUZd0UUMoWOFWdTsUFkbePhcl8I8pdiC\nYBCtujHXHe3KjxxVL/L0hUZix7E54BukoNNs7u8DLoBcco5ydwYPSTb6HiPNF/p7\n7Hkizd4MrO7G35Ybxn3foH2GltB4SV9j7DRj4+ZyVrYNyfNcPp4FKL1PyAk8gQQ=\n=myHW\n-----END PGP SIGNATURE-----\n", "payload": "tree 4cc4a60002008bdea0145c3a784731fd64cc9474\nparent 1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6\nparent ab4c0dd137f064b9a141d1341c546170b1c7272b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676899975 +0100\ncommitter GitHub <noreply@github.com> 1676899975 +0100\n\nRollup merge of #108200 - jhpratt:restricted-damerau-levenshtein-distance, r=tmiasko\n\nUse restricted Damerau-Levenshtein distance for diagnostics\n\nThis replaces the existing Levenshtein algorithm with the Damerau-Levenshtein algorithm. This means that \"ab\" to \"ba\" is one change (a transposition) instead of two (a deletion and insertion). More specifically, this is a _restricted_ implementation, in that \"ca\" to \"abc\" cannot be performed as \"ca\" \u2192 \"ac\" \u2192 \"abc\", as there is an insertion in the middle of a transposition. I believe that errors like that are sufficiently rare that it's not worth taking into account.\n\nThis was first brought up [on IRLO](https://internals.rust-lang.org/t/18227) when it was noticed that the diagnostic for `prinltn!` (transposed L and T) was `print!` and not `println!`. Only a single existing UI test was effected, with the result being an objective improvement.\n\n~~I have left the method name and various other references to the Levenshtein algorithm untouched, as the exact manner in which the edit distance is calculated should not be relevant to the caller.~~\n\nr? ``@estebank``\n\n``@rustbot`` label +A-diagnostics +C-enhancement\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/226ce31edde65a0a4b8eff25aab368694e440d51", "html_url": "https://github.com/rust-lang/rust/commit/226ce31edde65a0a4b8eff25aab368694e440d51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/226ce31edde65a0a4b8eff25aab368694e440d51/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6", "html_url": "https://github.com/rust-lang/rust/commit/1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6"}, {"sha": "ab4c0dd137f064b9a141d1341c546170b1c7272b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab4c0dd137f064b9a141d1341c546170b1c7272b", "html_url": "https://github.com/rust-lang/rust/commit/ab4c0dd137f064b9a141d1341c546170b1c7272b"}], "stats": {"total": 628, "additions": 357, "deletions": 271}, "files": [{"sha": "4a0e005b8b90220c1befaeda82a973fa76218d06", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, Symbol};"}, {"sha": "a68e0e0ac5bd058afaa9b4c4fc2e0529659502db", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::traits::FulfillmentError;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::parse::feature_err;\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n "}, {"sha": "c0cd54cc916e09ae4b397409d934ececb4cb3e87", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -37,8 +37,8 @@ use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeVisitable};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;"}, {"sha": "08cbfffdd171b581cf21cf47d75b9ea598c7f647", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -45,8 +45,8 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, Ty, TypeVisitable};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_session::parse::feature_err;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_target::spec::abi::Abi::RustIntrinsic;"}, {"sha": "88af554483b8e71b31bb814f38c72287d77088f5", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -24,8 +24,8 @@ use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint;\n use rustc_span::def_id::DefId;\n use rustc_span::def_id::LocalDefId;\n-use rustc_span::lev_distance::{\n-    find_best_match_for_name_with_substrings, lev_distance_with_substrings,\n+use rustc_span::edit_distance::{\n+    edit_distance_with_substrings, find_best_match_for_name_with_substrings,\n };\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n@@ -69,7 +69,7 @@ struct ProbeContext<'a, 'tcx> {\n     impl_dups: FxHashSet<DefId>,\n \n     /// When probing for names, include names that are close to the\n-    /// requested name (by Levenshtein distance)\n+    /// requested name (by edit distance)\n     allow_similar_names: bool,\n \n     /// Some(candidate) if there is a private candidate\n@@ -1793,7 +1793,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n     /// candidate method where the method name may have been misspelled. Similarly to other\n-    /// Levenshtein based suggestions, we provide at most one such suggestion.\n+    /// edit distance based suggestions, we provide at most one such suggestion.\n     fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n@@ -2024,8 +2024,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if self.matches_by_doc_alias(x.def_id) {\n                             return true;\n                         }\n-                        match lev_distance_with_substrings(name.as_str(), x.name.as_str(), max_dist)\n-                        {\n+                        match edit_distance_with_substrings(\n+                            name.as_str(),\n+                            x.name.as_str(),\n+                            max_dist,\n+                        ) {\n                             Some(d) => d > 0,\n                             None => false,\n                         }"}, {"sha": "4f3dbe03c052aac1c9c961441e1ec81c61e2d344", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitabl\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n-use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n+use rustc_span::{edit_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedNote;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1014,7 +1014,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // that had unsatisfied trait bounds\n         if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n             let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n-            if let Some(suggestion) = lev_distance::find_best_match_for_name(\n+            if let Some(suggestion) = edit_distance::find_best_match_for_name(\n                 &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n                 item_name.name,\n                 None,"}, {"sha": "ab6e76ef8aa35932c416a2f82820ab1c244953f5", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -14,8 +14,8 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::{self, Adt, BindingMode, Ty, TypeVisitable};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, DUMMY_SP};"}, {"sha": "475d3601b52ab65263b5fc92e767c71ac7d40049", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -14,8 +14,8 @@ use rustc_session::filesearch::sysroot_candidates;\n use rustc_session::lint::{self, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::CrateConfig;\n use rustc_session::{early_error, filesearch, output, Session};\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n use session::CompilerIO;"}, {"sha": "aace4974cc935cad3de3cb4957f8a0a6cdcde790", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -39,7 +39,7 @@ use rustc_middle::ty::{self, print::Printer, subst::GenericArg, RegisteredTools,\n use rustc_session::lint::{BuiltinLintDiagnostics, LintExpectationId};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_target::abi;"}, {"sha": "f164bb330f3daee79ee8ff506ca26398cc713b46", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -19,8 +19,8 @@ use rustc_errors::{\n     struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n     StashKey,\n };\n+use rustc_span::edit_distance::edit_distance;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n@@ -459,7 +459,8 @@ impl<'a> Parser<'a> {\n                 // Maybe the user misspelled `macro_rules` (issue #91227)\n                 if self.token.is_ident()\n                     && path.segments.len() == 1\n-                    && lev_distance(\"macro_rules\", &path.segments[0].ident.to_string(), 3).is_some()\n+                    && edit_distance(\"macro_rules\", &path.segments[0].ident.to_string(), 2)\n+                        .is_some()\n                 {\n                     err.span_suggestion(\n                         path.span,"}, {"sha": "cd26dbd61901d7819686426200e3b594504696f4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -21,9 +21,9 @@ use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n use rustc_session::lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::Session;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span, SyntaxContext};"}, {"sha": "48188b4ba355ec1ea52566e5e0c45274fc5fb071", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -21,8 +21,8 @@ use rustc_middle::span_bug;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::{PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::LocalExpnId;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n "}, {"sha": "174a543fe466df57a2371c6be199dac97d999784", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -25,9 +25,9 @@ use rustc_middle::ty::DefIdTree;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n \n@@ -542,7 +542,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n         }\n \n-        // Try Levenshtein algorithm.\n+        // Try finding a suitable replacement.\n         let typo_sugg =\n             self.lookup_typo_candidate(path, source.namespace(), is_expected).to_opt_suggestion();\n         if path.len() == 1 && self.self_type_is_available() {\n@@ -770,7 +770,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 _ => {}\n             }\n \n-            // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n+            // If the trait has a single item (which wasn't matched by the algorithm), suggest it\n             let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n             if !self.r.add_typo_suggestion(err, suggestion, ident_span) {\n                 fallback = !self.let_binding_suggestion(err, ident_span);"}, {"sha": "89f0386e3e97fe934abdfb4d73ee8a0f1b3b34e5", "filename": "compiler/rustc_span/src/edit_distance.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -0,0 +1,229 @@\n+//! Edit distances.\n+//!\n+//! The [edit distance] is a metric for measuring the difference between two strings.\n+//!\n+//! [edit distance]: https://en.wikipedia.org/wiki/Edit_distance\n+\n+// The current implementation is the restricted Damerau-Levenshtein algorithm. It is restricted\n+// because it does not permit modifying characters that have already been transposed. The specific\n+// algorithm should not matter to the caller of the methods, which is why it is not noted in the\n+// documentation.\n+\n+use crate::symbol::Symbol;\n+use std::{cmp, mem};\n+\n+#[cfg(test)]\n+mod tests;\n+\n+/// Finds the [edit distance] between two strings.\n+///\n+/// Returns `None` if the distance exceeds the limit.\n+///\n+/// [edit distance]: https://en.wikipedia.org/wiki/Edit_distance\n+pub fn edit_distance(a: &str, b: &str, limit: usize) -> Option<usize> {\n+    let mut a = &a.chars().collect::<Vec<_>>()[..];\n+    let mut b = &b.chars().collect::<Vec<_>>()[..];\n+\n+    // Ensure that `b` is the shorter string, minimizing memory use.\n+    if a.len() < b.len() {\n+        mem::swap(&mut a, &mut b);\n+    }\n+\n+    let min_dist = a.len() - b.len();\n+    // If we know the limit will be exceeded, we can return early.\n+    if min_dist > limit {\n+        return None;\n+    }\n+\n+    // Strip common prefix.\n+    while let Some(((b_char, b_rest), (a_char, a_rest))) = b.split_first().zip(a.split_first())\n+        && a_char == b_char\n+    {\n+        a = a_rest;\n+        b = b_rest;\n+    }\n+    // Strip common suffix.\n+    while let Some(((b_char, b_rest), (a_char, a_rest))) = b.split_last().zip(a.split_last())\n+        && a_char == b_char\n+    {\n+        a = a_rest;\n+        b = b_rest;\n+    }\n+\n+    // If either string is empty, the distance is the length of the other.\n+    // We know that `b` is the shorter string, so we don't need to check `a`.\n+    if b.len() == 0 {\n+        return Some(min_dist);\n+    }\n+\n+    let mut prev_prev = vec![usize::MAX; b.len() + 1];\n+    let mut prev = (0..=b.len()).collect::<Vec<_>>();\n+    let mut current = vec![0; b.len() + 1];\n+\n+    // row by row\n+    for i in 1..=a.len() {\n+        current[0] = i;\n+        let a_idx = i - 1;\n+\n+        // column by column\n+        for j in 1..=b.len() {\n+            let b_idx = j - 1;\n+\n+            // There is no cost to substitute a character with itself.\n+            let substitution_cost = if a[a_idx] == b[b_idx] { 0 } else { 1 };\n+\n+            current[j] = cmp::min(\n+                // deletion\n+                prev[j] + 1,\n+                cmp::min(\n+                    // insertion\n+                    current[j - 1] + 1,\n+                    // substitution\n+                    prev[j - 1] + substitution_cost,\n+                ),\n+            );\n+\n+            if (i > 1) && (j > 1) && (a[a_idx] == b[b_idx - 1]) && (a[a_idx - 1] == b[b_idx]) {\n+                // transposition\n+                current[j] = cmp::min(current[j], prev_prev[j - 2] + 1);\n+            }\n+        }\n+\n+        // Rotate the buffers, reusing the memory.\n+        [prev_prev, prev, current] = [prev, current, prev_prev];\n+    }\n+\n+    // `prev` because we already rotated the buffers.\n+    let distance = prev[b.len()];\n+    (distance <= limit).then_some(distance)\n+}\n+\n+/// Provides a word similarity score between two words that accounts for substrings being more\n+/// meaningful than a typical edit distance. The lower the score, the closer the match. 0 is an\n+/// identical match.\n+///\n+/// Uses the edit distance between the two strings and removes the cost of the length difference.\n+/// If this is 0 then it is either a substring match or a full word match, in the substring match\n+/// case we detect this and return `1`. To prevent finding meaningless substrings, eg. \"in\" in\n+/// \"shrink\", we only perform this subtraction of length difference if one of the words is not\n+/// greater than twice the length of the other. For cases where the words are close in size but not\n+/// an exact substring then the cost of the length difference is discounted by half.\n+///\n+/// Returns `None` if the distance exceeds the limit.\n+pub fn edit_distance_with_substrings(a: &str, b: &str, limit: usize) -> Option<usize> {\n+    let n = a.chars().count();\n+    let m = b.chars().count();\n+\n+    // Check one isn't less than half the length of the other. If this is true then there is a\n+    // big difference in length.\n+    let big_len_diff = (n * 2) < m || (m * 2) < n;\n+    let len_diff = if n < m { m - n } else { n - m };\n+    let distance = edit_distance(a, b, limit + len_diff)?;\n+\n+    // This is the crux, subtracting length difference means exact substring matches will now be 0\n+    let score = distance - len_diff;\n+\n+    // If the score is 0 but the words have different lengths then it's a substring match not a full\n+    // word match\n+    let score = if score == 0 && len_diff > 0 && !big_len_diff {\n+        1 // Exact substring match, but not a total word match so return non-zero\n+    } else if !big_len_diff {\n+        // Not a big difference in length, discount cost of length difference\n+        score + (len_diff + 1) / 2\n+    } else {\n+        // A big difference in length, add back the difference in length to the score\n+        score + len_diff\n+    };\n+\n+    (score <= limit).then_some(score)\n+}\n+\n+/// Finds the best match for given word in the given iterator where substrings are meaningful.\n+///\n+/// A version of [`find_best_match_for_name`] that uses [`edit_distance_with_substrings`] as the\n+/// score for word similarity. This takes an optional distance limit which defaults to one-third of\n+/// the given word.\n+///\n+/// We use case insensitive comparison to improve accuracy on an edge case with a lower(upper)case\n+/// letters mismatch.\n+pub fn find_best_match_for_name_with_substrings(\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    find_best_match_for_name_impl(true, candidates, lookup, dist)\n+}\n+\n+/// Finds the best match for a given word in the given iterator.\n+///\n+/// As a loose rule to avoid the obviously incorrect suggestions, it takes\n+/// an optional limit for the maximum allowable edit distance, which defaults\n+/// to one-third of the given word.\n+///\n+/// We use case insensitive comparison to improve accuracy on an edge case with a lower(upper)case\n+/// letters mismatch.\n+pub fn find_best_match_for_name(\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    find_best_match_for_name_impl(false, candidates, lookup, dist)\n+}\n+\n+#[cold]\n+fn find_best_match_for_name_impl(\n+    use_substring_score: bool,\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    let lookup = lookup.as_str();\n+    let lookup_uppercase = lookup.to_uppercase();\n+\n+    // Priority of matches:\n+    // 1. Exact case insensitive match\n+    // 2. Edit distance match\n+    // 3. Sorted word match\n+    if let Some(c) = candidates.iter().find(|c| c.as_str().to_uppercase() == lookup_uppercase) {\n+        return Some(*c);\n+    }\n+\n+    let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n+    let mut best = None;\n+    for c in candidates {\n+        match if use_substring_score {\n+            edit_distance_with_substrings(lookup, c.as_str(), dist)\n+        } else {\n+            edit_distance(lookup, c.as_str(), dist)\n+        } {\n+            Some(0) => return Some(*c),\n+            Some(d) => {\n+                dist = d - 1;\n+                best = Some(*c);\n+            }\n+            None => {}\n+        }\n+    }\n+    if best.is_some() {\n+        return best;\n+    }\n+\n+    find_match_by_sorted_words(candidates, lookup)\n+}\n+\n+fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {\n+    iter_names.iter().fold(None, |result, candidate| {\n+        if sort_by_words(candidate.as_str()) == sort_by_words(lookup) {\n+            Some(*candidate)\n+        } else {\n+            result\n+        }\n+    })\n+}\n+\n+fn sort_by_words(name: &str) -> String {\n+    let mut split_words: Vec<&str> = name.split('_').collect();\n+    // We are sorting primitive &strs and can use unstable sort here.\n+    split_words.sort_unstable();\n+    split_words.join(\"_\")\n+}"}, {"sha": "c9c7a1f1bf2f687f9a0290cdc6471ddf659ea969", "filename": "compiler/rustc_span/src/edit_distance/tests.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -0,0 +1,80 @@\n+use super::*;\n+\n+#[test]\n+fn test_edit_distance() {\n+    // Test bytelength agnosticity\n+    for c in (0..char::MAX as u32).filter_map(char::from_u32).map(|i| i.to_string()) {\n+        assert_eq!(edit_distance(&c[..], &c[..], usize::MAX), Some(0));\n+    }\n+\n+    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    assert_eq!(edit_distance(a, b, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(b, a, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(a, c, usize::MAX), Some(2));\n+    assert_eq!(edit_distance(c, a, usize::MAX), Some(2));\n+    assert_eq!(edit_distance(b, c, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(c, b, usize::MAX), Some(1));\n+}\n+\n+#[test]\n+fn test_edit_distance_limit() {\n+    assert_eq!(edit_distance(\"abc\", \"abcd\", 1), Some(1));\n+    assert_eq!(edit_distance(\"abc\", \"abcd\", 0), None);\n+    assert_eq!(edit_distance(\"abc\", \"xyz\", 3), Some(3));\n+    assert_eq!(edit_distance(\"abc\", \"xyz\", 2), None);\n+}\n+\n+#[test]\n+fn test_method_name_similarity_score() {\n+    assert_eq!(edit_distance_with_substrings(\"empty\", \"is_empty\", 1), Some(1));\n+    assert_eq!(edit_distance_with_substrings(\"shrunk\", \"rchunks\", 2), None);\n+    assert_eq!(edit_distance_with_substrings(\"abc\", \"abcd\", 1), Some(1));\n+    assert_eq!(edit_distance_with_substrings(\"a\", \"abcd\", 1), None);\n+    assert_eq!(edit_distance_with_substrings(\"edf\", \"eq\", 1), None);\n+    assert_eq!(edit_distance_with_substrings(\"abc\", \"xyz\", 3), Some(3));\n+    assert_eq!(edit_distance_with_substrings(\"abcdef\", \"abcdef\", 2), Some(0));\n+}\n+\n+#[test]\n+fn test_find_best_match_for_name() {\n+    use crate::create_default_session_globals_then;\n+    create_default_session_globals_then(|| {\n+        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n+            Some(Symbol::intern(\"aaab\"))\n+        );\n+\n+        assert_eq!(find_best_match_for_name(&input, Symbol::intern(\"1111111111\"), None), None);\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), Some(4)),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"a_variable_longer_name\"), None),\n+            Some(Symbol::intern(\"a_longer_variable_name\"))\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_precise_algorithm() {\n+    // Not Levenshtein distance.\n+    assert_ne!(edit_distance(\"ab\", \"ba\", usize::MAX), Some(2));\n+    // Not unrestricted Damerau-Levenshtein distance.\n+    assert_ne!(edit_distance(\"abde\", \"bcaed\", usize::MAX), Some(3));\n+    // The current implementation is a restricted Damerau-Levenshtein distance.\n+    assert_eq!(edit_distance(\"abde\", \"bcaed\", usize::MAX), Some(4));\n+}"}, {"sha": "61e4b98a8d28bbda31d873b007217a5a2fc5e350", "filename": "compiler/rustc_span/src/lev_distance.rs", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs?ref=1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6", "patch": "@@ -1,177 +0,0 @@\n-//! Levenshtein distances.\n-//!\n-//! The [Levenshtein distance] is a metric for measuring the difference between two strings.\n-//!\n-//! [Levenshtein distance]: https://en.wikipedia.org/wiki/Levenshtein_distance\n-\n-use crate::symbol::Symbol;\n-use std::cmp;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-/// Finds the Levenshtein distance between two strings.\n-///\n-/// Returns None if the distance exceeds the limit.\n-pub fn lev_distance(a: &str, b: &str, limit: usize) -> Option<usize> {\n-    let n = a.chars().count();\n-    let m = b.chars().count();\n-    let min_dist = if n < m { m - n } else { n - m };\n-\n-    if min_dist > limit {\n-        return None;\n-    }\n-    if n == 0 || m == 0 {\n-        return (min_dist <= limit).then_some(min_dist);\n-    }\n-\n-    let mut dcol: Vec<_> = (0..=m).collect();\n-\n-    for (i, sc) in a.chars().enumerate() {\n-        let mut current = i;\n-        dcol[0] = current + 1;\n-\n-        for (j, tc) in b.chars().enumerate() {\n-            let next = dcol[j + 1];\n-            if sc == tc {\n-                dcol[j + 1] = current;\n-            } else {\n-                dcol[j + 1] = cmp::min(current, next);\n-                dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n-            }\n-            current = next;\n-        }\n-    }\n-\n-    (dcol[m] <= limit).then_some(dcol[m])\n-}\n-\n-/// Provides a word similarity score between two words that accounts for substrings being more\n-/// meaningful than a typical Levenshtein distance. The lower the score, the closer the match.\n-/// 0 is an identical match.\n-///\n-/// Uses the Levenshtein distance between the two strings and removes the cost of the length\n-/// difference. If this is 0 then it is either a substring match or a full word match, in the\n-/// substring match case we detect this and return `1`. To prevent finding meaningless substrings,\n-/// eg. \"in\" in \"shrink\", we only perform this subtraction of length difference if one of the words\n-/// is not greater than twice the length of the other. For cases where the words are close in size\n-/// but not an exact substring then the cost of the length difference is discounted by half.\n-///\n-/// Returns `None` if the distance exceeds the limit.\n-pub fn lev_distance_with_substrings(a: &str, b: &str, limit: usize) -> Option<usize> {\n-    let n = a.chars().count();\n-    let m = b.chars().count();\n-\n-    // Check one isn't less than half the length of the other. If this is true then there is a\n-    // big difference in length.\n-    let big_len_diff = (n * 2) < m || (m * 2) < n;\n-    let len_diff = if n < m { m - n } else { n - m };\n-    let lev = lev_distance(a, b, limit + len_diff)?;\n-\n-    // This is the crux, subtracting length difference means exact substring matches will now be 0\n-    let score = lev - len_diff;\n-\n-    // If the score is 0 but the words have different lengths then it's a substring match not a full\n-    // word match\n-    let score = if score == 0 && len_diff > 0 && !big_len_diff {\n-        1 // Exact substring match, but not a total word match so return non-zero\n-    } else if !big_len_diff {\n-        // Not a big difference in length, discount cost of length difference\n-        score + (len_diff + 1) / 2\n-    } else {\n-        // A big difference in length, add back the difference in length to the score\n-        score + len_diff\n-    };\n-\n-    (score <= limit).then_some(score)\n-}\n-\n-/// Finds the best match for given word in the given iterator where substrings are meaningful.\n-///\n-/// A version of [`find_best_match_for_name`] that uses [`lev_distance_with_substrings`] as the score\n-/// for word similarity. This takes an optional distance limit which defaults to one-third of the\n-/// given word.\n-///\n-/// Besides the modified Levenshtein, we use case insensitive comparison to improve accuracy\n-/// on an edge case with a lower(upper)case letters mismatch.\n-pub fn find_best_match_for_name_with_substrings(\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    find_best_match_for_name_impl(true, candidates, lookup, dist)\n-}\n-\n-/// Finds the best match for a given word in the given iterator.\n-///\n-/// As a loose rule to avoid the obviously incorrect suggestions, it takes\n-/// an optional limit for the maximum allowable edit distance, which defaults\n-/// to one-third of the given word.\n-///\n-/// Besides Levenshtein, we use case insensitive comparison to improve accuracy\n-/// on an edge case with a lower(upper)case letters mismatch.\n-pub fn find_best_match_for_name(\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    find_best_match_for_name_impl(false, candidates, lookup, dist)\n-}\n-\n-#[cold]\n-fn find_best_match_for_name_impl(\n-    use_substring_score: bool,\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    let lookup = lookup.as_str();\n-    let lookup_uppercase = lookup.to_uppercase();\n-\n-    // Priority of matches:\n-    // 1. Exact case insensitive match\n-    // 2. Levenshtein distance match\n-    // 3. Sorted word match\n-    if let Some(c) = candidates.iter().find(|c| c.as_str().to_uppercase() == lookup_uppercase) {\n-        return Some(*c);\n-    }\n-\n-    let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n-    let mut best = None;\n-    for c in candidates {\n-        match if use_substring_score {\n-            lev_distance_with_substrings(lookup, c.as_str(), dist)\n-        } else {\n-            lev_distance(lookup, c.as_str(), dist)\n-        } {\n-            Some(0) => return Some(*c),\n-            Some(d) => {\n-                dist = d - 1;\n-                best = Some(*c);\n-            }\n-            None => {}\n-        }\n-    }\n-    if best.is_some() {\n-        return best;\n-    }\n-\n-    find_match_by_sorted_words(candidates, lookup)\n-}\n-\n-fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {\n-    iter_names.iter().fold(None, |result, candidate| {\n-        if sort_by_words(candidate.as_str()) == sort_by_words(lookup) {\n-            Some(*candidate)\n-        } else {\n-            result\n-        }\n-    })\n-}\n-\n-fn sort_by_words(name: &str) -> String {\n-    let mut split_words: Vec<&str> = name.split('_').collect();\n-    // We are sorting primitive &strs and can use unstable sort here.\n-    split_words.sort_unstable();\n-    split_words.join(\"_\")\n-}"}, {"sha": "ed03b22c61fd6a2eb20675ee7de0f799322e53b5", "filename": "compiler/rustc_span/src/lev_distance/tests.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs?ref=1f5c2b1efd885d730e6cf56f3b5d01c593f20ca6", "patch": "@@ -1,70 +0,0 @@\n-use super::*;\n-\n-#[test]\n-fn test_lev_distance() {\n-    // Test bytelength agnosticity\n-    for c in (0..char::MAX as u32).filter_map(char::from_u32).map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(&c[..], &c[..], usize::MAX), Some(0));\n-    }\n-\n-    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    assert_eq!(lev_distance(a, b, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(b, a, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(a, c, usize::MAX), Some(2));\n-    assert_eq!(lev_distance(c, a, usize::MAX), Some(2));\n-    assert_eq!(lev_distance(b, c, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(c, b, usize::MAX), Some(1));\n-}\n-\n-#[test]\n-fn test_lev_distance_limit() {\n-    assert_eq!(lev_distance(\"abc\", \"abcd\", 1), Some(1));\n-    assert_eq!(lev_distance(\"abc\", \"abcd\", 0), None);\n-    assert_eq!(lev_distance(\"abc\", \"xyz\", 3), Some(3));\n-    assert_eq!(lev_distance(\"abc\", \"xyz\", 2), None);\n-}\n-\n-#[test]\n-fn test_method_name_similarity_score() {\n-    assert_eq!(lev_distance_with_substrings(\"empty\", \"is_empty\", 1), Some(1));\n-    assert_eq!(lev_distance_with_substrings(\"shrunk\", \"rchunks\", 2), None);\n-    assert_eq!(lev_distance_with_substrings(\"abc\", \"abcd\", 1), Some(1));\n-    assert_eq!(lev_distance_with_substrings(\"a\", \"abcd\", 1), None);\n-    assert_eq!(lev_distance_with_substrings(\"edf\", \"eq\", 1), None);\n-    assert_eq!(lev_distance_with_substrings(\"abc\", \"xyz\", 3), Some(3));\n-    assert_eq!(lev_distance_with_substrings(\"abcdef\", \"abcdef\", 2), Some(0));\n-}\n-\n-#[test]\n-fn test_find_best_match_for_name() {\n-    use crate::create_default_session_globals_then;\n-    create_default_session_globals_then(|| {\n-        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n-            Some(Symbol::intern(\"aaab\"))\n-        );\n-\n-        assert_eq!(find_best_match_for_name(&input, Symbol::intern(\"1111111111\"), None), None);\n-\n-        let input = vec![Symbol::intern(\"AAAA\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n-            Some(Symbol::intern(\"AAAA\"))\n-        );\n-\n-        let input = vec![Symbol::intern(\"AAAA\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), Some(4)),\n-            Some(Symbol::intern(\"AAAA\"))\n-        );\n-\n-        let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"a_variable_longer_name\"), None),\n-            Some(Symbol::intern(\"a_longer_variable_name\"))\n-        );\n-    })\n-}"}, {"sha": "e112100aa5fcdb05fcb8e48f7a0c8a17c3f08ef2", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -19,6 +19,7 @@\n #![feature(negative_impls)]\n #![feature(min_specialization)]\n #![feature(rustc_attrs)]\n+#![feature(let_chains)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n@@ -46,7 +47,7 @@ pub use hygiene::{ExpnData, ExpnHash, ExpnId, LocalExpnId, SyntaxContext};\n use rustc_data_structures::stable_hasher::HashingControls;\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LocalDefId, LOCAL_CRATE};\n-pub mod lev_distance;\n+pub mod edit_distance;\n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n "}, {"sha": "83383ea61a4ab20a20ccd66be9220d394e384589", "filename": "tests/ui/check-cfg/invalid-cfg-value.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -2,7 +2,9 @@ warning: unexpected `cfg` condition value\n   --> $DIR/invalid-cfg-value.rs:7:7\n    |\n LL | #[cfg(feature = \"sedre\")]\n-   |       ^^^^^^^^^^^^^^^^^\n+   |       ^^^^^^^^^^-------\n+   |                 |\n+   |                 help: did you mean: `\"serde\"`\n    |\n    = note: expected values for `feature` are: full, serde\n    = note: `#[warn(unexpected_cfgs)]` on by default"}, {"sha": "685b5e1f284035c1ded45649ea69dd22bf1c7c21", "filename": "tests/ui/did_you_mean/println-typo.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -0,0 +1,6 @@\n+// https://internals.rust-lang.org/t/18227\n+\n+fn main() {\n+    prinltn!(); //~ ERROR cannot find macro `prinltn` in this scope\n+    //^ a macro with a similar name exists: `println`\n+}"}, {"sha": "43b7b1894e2ae31e718403f5e34466c69da38ba0", "filename": "tests/ui/did_you_mean/println-typo.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/226ce31edde65a0a4b8eff25aab368694e440d51/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226ce31edde65a0a4b8eff25aab368694e440d51/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr?ref=226ce31edde65a0a4b8eff25aab368694e440d51", "patch": "@@ -0,0 +1,11 @@\n+error: cannot find macro `prinltn` in this scope\n+  --> $DIR/println-typo.rs:4:5\n+   |\n+LL |     prinltn!();\n+   |     ^^^^^^^ help: a macro with a similar name exists: `println`\n+  --> $SRC_DIR/std/src/macros.rs:LL:COL\n+   |\n+   = note: similarly named macro `println` defined here\n+\n+error: aborting due to previous error\n+"}]}