{"sha": "9dd32e177e941c18ba157d37a9292ffc972304bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZDMyZTE3N2U5NDFjMThiYTE1N2QzN2E5MjkyZmZjOTcyMzA0YmM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-11-15T17:34:10Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-11-27T19:39:49Z"}, "message": "Encode proc_macro directly.\n\nEncode proc_macro name directly.\n\nDo not store None values.", "tree": {"sha": "52f893363d2e880cd0ca49d26da00f03fc7ec3b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52f893363d2e880cd0ca49d26da00f03fc7ec3b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dd32e177e941c18ba157d37a9292ffc972304bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dd32e177e941c18ba157d37a9292ffc972304bc", "html_url": "https://github.com/rust-lang/rust/commit/9dd32e177e941c18ba157d37a9292ffc972304bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dd32e177e941c18ba157d37a9292ffc972304bc/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9228570668803e3e6402770d55f23a12c9ae686", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9228570668803e3e6402770d55f23a12c9ae686", "html_url": "https://github.com/rust-lang/rust/commit/c9228570668803e3e6402770d55f23a12c9ae686"}], "stats": {"total": 129, "additions": 62, "deletions": 67}, "files": [{"sha": "e82449f69fd8e1639aaa3c4ca160572a5f084057", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 25, "deletions": 62, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/9dd32e177e941c18ba157d37a9292ffc972304bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd32e177e941c18ba157d37a9292ffc972304bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=9dd32e177e941c18ba157d37a9292ffc972304bc", "patch": "@@ -644,6 +644,7 @@ impl EntryKind {\n             EntryKind::TraitAlias => DefKind::TraitAlias,\n             EntryKind::Enum(..) => DefKind::Enum,\n             EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n+            EntryKind::ProcMacro(kind) => DefKind::Macro(kind),\n             EntryKind::ForeignType => DefKind::ForeignTy,\n             EntryKind::Impl(_) => DefKind::Impl,\n             EntryKind::Closure => DefKind::Closure,\n@@ -685,20 +686,11 @@ impl CrateRoot<'_> {\n }\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n-    fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.root\n-            .proc_macro_data\n-            .as_ref()\n-            .and_then(|data| data.macros.decode(self).find(|x| *x == id))\n-            .is_some()\n-    }\n-\n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n         self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n     }\n \n     fn kind(&self, item_id: DefIndex) -> EntryKind {\n-        assert!(!self.is_proc_macro(item_id));\n         self.maybe_kind(item_id).unwrap_or_else(|| {\n             bug!(\n                 \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n@@ -725,35 +717,24 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn item_ident(&self, item_index: DefIndex, sess: &Session) -> Ident {\n-        if !self.is_proc_macro(item_index) {\n-            let name = self\n-                .def_key(item_index)\n-                .disambiguated_data\n-                .data\n-                .get_opt_name()\n-                .expect(\"no name in item_ident\");\n-            let span = self\n-                .root\n-                .tables\n-                .ident_span\n-                .get(self, item_index)\n-                .map(|data| data.decode((self, sess)))\n-                .unwrap_or_else(|| panic!(\"Missing ident span for {:?} ({:?})\", name, item_index));\n-            Ident::new(name, span)\n-        } else {\n-            Ident::new(\n-                Symbol::intern(self.raw_proc_macro(item_index).name()),\n-                self.get_span(item_index, sess),\n-            )\n-        }\n+        let name = self\n+            .def_key(item_index)\n+            .disambiguated_data\n+            .data\n+            .get_opt_name()\n+            .expect(\"no name in item_ident\");\n+        let span = self\n+            .root\n+            .tables\n+            .ident_span\n+            .get(self, item_index)\n+            .map(|data| data.decode((self, sess)))\n+            .unwrap_or_else(|| panic!(\"Missing ident span for {:?} ({:?})\", name, item_index));\n+        Ident::new(name, span)\n     }\n \n     fn def_kind(&self, index: DefIndex) -> DefKind {\n-        if !self.is_proc_macro(index) {\n-            self.kind(index).def_kind()\n-        } else {\n-            DefKind::Macro(macro_kind(self.raw_proc_macro(index)))\n-        }\n+        self.kind(index).def_kind()\n     }\n \n     fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n@@ -956,30 +937,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n-        match self.is_proc_macro(id) {\n-            true => self.root.proc_macro_data.as_ref().unwrap().stability,\n-            false => self.root.tables.stability.get(self, id).map(|stab| stab.decode(self)),\n-        }\n+        self.root.tables.stability.get(self, id).map(|stab| stab.decode(self))\n     }\n \n     fn get_const_stability(&self, id: DefIndex) -> Option<attr::ConstStability> {\n         self.root.tables.const_stability.get(self, id).map(|stab| stab.decode(self))\n     }\n \n     fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        self.root\n-            .tables\n-            .deprecation\n-            .get(self, id)\n-            .filter(|_| !self.is_proc_macro(id))\n-            .map(|depr| depr.decode(self))\n+        self.root.tables.deprecation.get(self, id).map(|depr| depr.decode(self))\n     }\n \n     fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n-        match self.is_proc_macro(id) {\n-            true => ty::Visibility::Public,\n-            false => self.root.tables.visibility.get(self, id).unwrap().decode(self),\n-        }\n+        self.root.tables.visibility.get(self, id).unwrap().decode(self)\n     }\n \n     fn get_impl_data(&self, id: DefIndex) -> ImplData {\n@@ -1191,7 +1161,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn is_item_mir_available(&self, id: DefIndex) -> bool {\n-        !self.is_proc_macro(id) && self.root.tables.mir.get(self, id).is_some()\n+        self.root.tables.mir.get(self, id).is_some()\n     }\n \n     fn module_expansion(&self, id: DefIndex, sess: &Session) -> ExpnId {\n@@ -1207,7 +1177,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .mir\n             .get(self, id)\n-            .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n@@ -1223,7 +1192,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .mir_abstract_consts\n             .get(self, id)\n-            .filter(|_| !self.is_proc_macro(id))\n             .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }\n \n@@ -1232,7 +1200,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .unused_generic_params\n             .get(self, id)\n-            .filter(|_| !self.is_proc_macro(id))\n             .map(|params| params.decode(self))\n             .unwrap_or_default()\n     }\n@@ -1242,7 +1209,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .promoted_mir\n             .get(self, id)\n-            .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n@@ -1546,14 +1512,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     #[inline]\n     fn def_key(&self, index: DefIndex) -> DefKey {\n-        *self.def_key_cache.lock().entry(index).or_insert_with(|| {\n-            let mut key = self.root.tables.def_keys.get(self, index).unwrap().decode(self);\n-            if self.is_proc_macro(index) {\n-                let name = self.raw_proc_macro(index).name();\n-                key.disambiguated_data.data = DefPathData::MacroNs(Symbol::intern(name));\n-            }\n-            key\n-        })\n+        *self\n+            .def_key_cache\n+            .lock()\n+            .entry(index)\n+            .or_insert_with(|| self.root.tables.def_keys.get(self, index).unwrap().decode(self))\n     }\n \n     // Returns the path leading to the thing with this `id`."}, {"sha": "46dd0df65e06fa1714e82e359b41926b505239b1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9dd32e177e941c18ba157d37a9292ffc972304bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd32e177e941c18ba157d37a9292ffc972304bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=9dd32e177e941c18ba157d37a9292ffc972304bc", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::{ItemLikeVisitor, ParItemLikeVisitor};\n use rustc_hir::lang_items;\n@@ -27,7 +28,7 @@ use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n-use rustc_span::hygiene::{ExpnDataEncodeMode, HygieneEncodeContext};\n+use rustc_span::hygiene::{ExpnDataEncodeMode, HygieneEncodeContext, MacroKind};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span, SyntaxContext};\n use rustc_target::abi::VariantIdx;\n@@ -1539,12 +1540,41 @@ impl EncodeContext<'a, 'tcx> {\n             // so we manually encode just the information that we need\n             for proc_macro in &hir.krate().proc_macros {\n                 let id = proc_macro.owner.local_def_index;\n-                let span = self.lazy(hir.span(*proc_macro));\n+                let mut name = hir.name(*proc_macro);\n+                let span = hir.span(*proc_macro);\n                 // Proc-macros may have attributes like `#[allow_internal_unstable]`,\n                 // so downstream crates need access to them.\n-                let attrs = self.lazy(hir.attrs(*proc_macro));\n-                self.tables.span.set(id, span);\n-                self.tables.attributes.set(id, attrs);\n+                let attrs = hir.attrs(*proc_macro);\n+                let macro_kind = if tcx.sess.contains_name(attrs, sym::proc_macro) {\n+                    MacroKind::Bang\n+                } else if tcx.sess.contains_name(attrs, sym::proc_macro_attribute) {\n+                    MacroKind::Attr\n+                } else if let Some(attr) = tcx.sess.find_by_name(attrs, sym::proc_macro_derive) {\n+                    // This unwrap chain should have been checked by the proc-macro harness.\n+                    name = attr.meta_item_list().unwrap()[0]\n+                        .meta_item()\n+                        .unwrap()\n+                        .ident()\n+                        .unwrap()\n+                        .name;\n+                    MacroKind::Derive\n+                } else {\n+                    bug!(\"Unknown proc-macro type for item {:?}\", id);\n+                };\n+\n+                let mut def_key = self.tcx.hir().def_key(proc_macro.owner);\n+                def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n+\n+                let def_id = DefId::local(id);\n+                record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n+                record!(self.tables.attributes[def_id] <- attrs);\n+                record!(self.tables.def_keys[def_id] <- def_key);\n+                record!(self.tables.ident_span[def_id] <- span);\n+                record!(self.tables.span[def_id] <- span);\n+                record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+                if let Some(stability) = stability {\n+                    record!(self.tables.stability[def_id] <- stability);\n+                }\n             }\n \n             Some(ProcMacroData { proc_macro_decls_static, stability, macros })"}, {"sha": "536061789096408dccbf0fc8264dc0210573aa67", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd32e177e941c18ba157d37a9292ffc972304bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd32e177e941c18ba157d37a9292ffc972304bc/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=9dd32e177e941c18ba157d37a9292ffc972304bc", "patch": "@@ -20,6 +20,7 @@ use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::CrateDisambiguator;\n use rustc_span::edition::Edition;\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, ExpnData, ExpnId, Span};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n@@ -336,6 +337,7 @@ enum EntryKind {\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n+    ProcMacro(MacroKind),\n     Closure,\n     Generator(hir::GeneratorKind),\n     Trait(Lazy<TraitData>),"}]}