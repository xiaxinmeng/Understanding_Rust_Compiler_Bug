{"sha": "48ad726f2abc90fe62cdf239bc1c9318261a6926", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YWQ3MjZmMmFiYzkwZmU2MmNkZjIzOWJjMWM5MzE4MjYxYTY5MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-08T09:52:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-08T09:52:56Z"}, "message": "auto merge of #7605 : thestinger/rust/vec, r=Aatch\n\nThis is work continued from the now landed #7495 and #7521 pulls.\r\n\r\nRemoving the headers from unique vectors is another project, so I've separated the allocator.", "tree": {"sha": "fb48c49be09efe99d543e18e1dd711d444521639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb48c49be09efe99d543e18e1dd711d444521639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48ad726f2abc90fe62cdf239bc1c9318261a6926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48ad726f2abc90fe62cdf239bc1c9318261a6926", "html_url": "https://github.com/rust-lang/rust/commit/48ad726f2abc90fe62cdf239bc1c9318261a6926", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48ad726f2abc90fe62cdf239bc1c9318261a6926/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44770ae3a8001de38b33e449889c6444808941fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/44770ae3a8001de38b33e449889c6444808941fc", "html_url": "https://github.com/rust-lang/rust/commit/44770ae3a8001de38b33e449889c6444808941fc"}, {"sha": "90f1db10fa29eb6b91e22037f13130f854da1401", "url": "https://api.github.com/repos/rust-lang/rust/commits/90f1db10fa29eb6b91e22037f13130f854da1401", "html_url": "https://github.com/rust-lang/rust/commit/90f1db10fa29eb6b91e22037f13130f854da1401"}], "stats": {"total": 367, "additions": 235, "deletions": 132}, "files": [{"sha": "d4d1997a56f250d4db38314535a04a379017735f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -63,33 +63,34 @@ pub enum LangItem {\n     FailFnLangItem,                    // 24\n     FailBoundsCheckFnLangItem,         // 25\n     ExchangeMallocFnLangItem,          // 26\n-    ClosureExchangeMallocFnLangItem,   // 27\n-    ExchangeFreeFnLangItem,            // 28\n-    MallocFnLangItem,                  // 29\n-    FreeFnLangItem,                    // 30\n-    BorrowAsImmFnLangItem,             // 31\n-    BorrowAsMutFnLangItem,             // 32\n-    ReturnToMutFnLangItem,             // 33\n-    CheckNotBorrowedFnLangItem,        // 34\n-    StrDupUniqFnLangItem,              // 35\n-    RecordBorrowFnLangItem,            // 36\n-    UnrecordBorrowFnLangItem,          // 37\n-\n-    StartFnLangItem,                   // 38\n-\n-    TyDescStructLangItem,              // 39\n-    TyVisitorTraitLangItem,            // 40\n-    OpaqueStructLangItem,              // 41\n+    VectorExchangeMallocFnLangItem,    // 27\n+    ClosureExchangeMallocFnLangItem,   // 28\n+    ExchangeFreeFnLangItem,            // 29\n+    MallocFnLangItem,                  // 30\n+    FreeFnLangItem,                    // 31\n+    BorrowAsImmFnLangItem,             // 32\n+    BorrowAsMutFnLangItem,             // 33\n+    ReturnToMutFnLangItem,             // 34\n+    CheckNotBorrowedFnLangItem,        // 35\n+    StrDupUniqFnLangItem,              // 36\n+    RecordBorrowFnLangItem,            // 37\n+    UnrecordBorrowFnLangItem,          // 38\n+\n+    StartFnLangItem,                   // 39\n+\n+    TyDescStructLangItem,              // 40\n+    TyVisitorTraitLangItem,            // 41\n+    OpaqueStructLangItem,              // 42\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..42]\n+    items: [Option<def_id>, ..43]\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..42 ]\n+            items: [ None, ..43 ]\n         }\n     }\n \n@@ -129,23 +130,24 @@ impl LanguageItems {\n             24 => \"fail_\",\n             25 => \"fail_bounds_check\",\n             26 => \"exchange_malloc\",\n-            27 => \"closure_exchange_malloc\",\n-            28 => \"exchange_free\",\n-            29 => \"malloc\",\n-            30 => \"free\",\n-            31 => \"borrow_as_imm\",\n-            32 => \"borrow_as_mut\",\n-            33 => \"return_to_mut\",\n-            34 => \"check_not_borrowed\",\n-            35 => \"strdup_uniq\",\n-            36 => \"record_borrow\",\n-            37 => \"unrecord_borrow\",\n-\n-            38 => \"start\",\n-\n-            39 => \"ty_desc\",\n-            40 => \"ty_visitor\",\n-            41 => \"opaque\",\n+            27 => \"vector_exchange_malloc\",\n+            28 => \"closure_exchange_malloc\",\n+            29 => \"exchange_free\",\n+            30 => \"malloc\",\n+            31 => \"free\",\n+            32 => \"borrow_as_imm\",\n+            33 => \"borrow_as_mut\",\n+            34 => \"return_to_mut\",\n+            35 => \"check_not_borrowed\",\n+            36 => \"strdup_uniq\",\n+            37 => \"record_borrow\",\n+            38 => \"unrecord_borrow\",\n+\n+            39 => \"start\",\n+\n+            40 => \"ty_desc\",\n+            41 => \"ty_visitor\",\n+            42 => \"opaque\",\n \n             _ => \"???\"\n         }\n@@ -238,6 +240,9 @@ impl LanguageItems {\n     pub fn exchange_malloc_fn(&self) -> def_id {\n         self.items[ExchangeMallocFnLangItem as uint].get()\n     }\n+    pub fn vector_exchange_malloc_fn(&self) -> def_id {\n+        self.items[VectorExchangeMallocFnLangItem as uint].get()\n+    }\n     pub fn closure_exchange_malloc_fn(&self) -> def_id {\n         self.items[ClosureExchangeMallocFnLangItem as uint].get()\n     }\n@@ -331,6 +336,7 @@ impl<'self> LanguageItemCollector<'self> {\n         item_refs.insert(@\"fail_bounds_check\",\n                          FailBoundsCheckFnLangItem as uint);\n         item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n+        item_refs.insert(@\"vector_exchange_malloc\", VectorExchangeMallocFnLangItem as uint);\n         item_refs.insert(@\"closure_exchange_malloc\", ClosureExchangeMallocFnLangItem as uint);\n         item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n         item_refs.insert(@\"malloc\", MallocFnLangItem as uint);"}, {"sha": "80654342d0deee2c8097e8bdca5b7502a4a9b5b3", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -1395,8 +1395,12 @@ pub fn compile_submatch(bcx: block,\n     }\n \n     if any_uniq_pat(m, col) {\n+        let pat_ty = node_id_type(bcx, pat_id);\n         let llbox = Load(bcx, val);\n-        let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+        let unboxed = match ty::get(pat_ty).sty {\n+            ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n+            _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n+        };\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk);\n         return;\n@@ -1868,8 +1872,12 @@ pub fn bind_irrefutable_pat(bcx: block,\n             }\n         }\n         ast::pat_box(inner) | ast::pat_uniq(inner) => {\n+            let pat_ty = node_id_type(bcx, pat.id);\n             let llbox = Load(bcx, val);\n-            let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+            let unboxed = match ty::get(pat_ty).sty {\n+                ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n+                    _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n+            };\n             bcx = bind_irrefutable_pat(bcx,\n                                        inner,\n                                        unboxed,"}, {"sha": "e2795f77d7d86b338a56edefe96df09c3c97171d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -289,21 +289,25 @@ pub fn malloc_raw_dyn(bcx: block,\n     let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    let (mk_fn, langcall) = match heap {\n-        heap_managed | heap_managed_unique => {\n-            (ty::mk_imm_box, bcx.tcx().lang_items.malloc_fn())\n-        }\n-        heap_exchange => {\n-            (ty::mk_imm_uniq, bcx.tcx().lang_items.exchange_malloc_fn())\n-        }\n-        heap_exchange_closure => {\n-            (ty::mk_imm_uniq, bcx.tcx().lang_items.closure_exchange_malloc_fn())\n-        }\n-    };\n-\n     if heap == heap_exchange {\n+        let llty_value = type_of::type_of(ccx, t);\n+        let llalign = llalign_of_min(ccx, llty_value);\n+\n+        // Allocate space:\n+        let rval = alloca(bcx, Type::i8p());\n+        let bcx = callee::trans_lang_call(\n+            bcx,\n+            bcx.tcx().lang_items.exchange_malloc_fn(),\n+            [C_i32(llalign as i32), size],\n+            expr::SaveIn(rval));\n+        rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty_value.ptr_to()))\n+    } else if heap == heap_exchange_vector {\n         // Grab the TypeRef type of box_ptr_ty.\n-        let box_ptr_ty = mk_fn(bcx.tcx(), t);\n+        let element_type = match ty::get(t).sty {\n+            ty::ty_unboxed_vec(e) => e,\n+            _ => fail!(\"not a vector body\")\n+        };\n+        let box_ptr_ty = ty::mk_evec(bcx.tcx(), element_type, ty::vstore_uniq);\n         let llty = type_of(ccx, box_ptr_ty);\n \n         let llty_value = type_of::type_of(ccx, t);\n@@ -313,11 +317,22 @@ pub fn malloc_raw_dyn(bcx: block,\n         let rval = alloca(bcx, Type::i8p());\n         let bcx = callee::trans_lang_call(\n             bcx,\n-            langcall,\n+            bcx.tcx().lang_items.vector_exchange_malloc_fn(),\n             [C_i32(llalign as i32), size],\n             expr::SaveIn(rval));\n         rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty))\n     } else {\n+        // we treat ~fn, @fn and @[] as @ here, which isn't ideal\n+        let (mk_fn, langcall) = match heap {\n+            heap_managed | heap_managed_unique => {\n+                (ty::mk_imm_box, bcx.tcx().lang_items.malloc_fn())\n+            }\n+            heap_exchange_closure => {\n+                (ty::mk_imm_box, bcx.tcx().lang_items.closure_exchange_malloc_fn())\n+            }\n+            _ => fail!(\"heap_exchange/heap_exchange_vector already handled\")\n+        };\n+\n         // Grab the TypeRef type of box_ptr_ty.\n         let box_ptr_ty = mk_fn(bcx.tcx(), t);\n         let llty = type_of(ccx, box_ptr_ty);\n@@ -359,16 +374,17 @@ pub struct MallocResult {\n // and pulls out the body\n pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n+    assert!(heap != heap_exchange);\n     let _icx = push_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let body = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n \n     MallocResult { bcx: bcx, box: llbox, body: body }\n }\n \n-pub fn malloc_general(bcx: block, t: ty::t, heap: heap)\n-    -> MallocResult {\n-        let ty = type_of(bcx.ccx(), t);\n+pub fn malloc_general(bcx: block, t: ty::t, heap: heap) -> MallocResult {\n+    let ty = type_of(bcx.ccx(), t);\n+    assert!(heap != heap_exchange);\n     malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n pub fn malloc_boxed(bcx: block, t: ty::t)\n@@ -385,6 +401,7 @@ pub fn heap_for_unique(bcx: block, t: ty::t) -> heap {\n }\n \n pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n+    assert!(heap != heap_exchange);\n     if heap == heap_managed_unique {\n         // In cases where we are looking at a unique-typed allocation in the\n         // managed heap (thus have refcount 1 from the managed allocator),\n@@ -396,11 +413,6 @@ pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n     }\n }\n \n-pub fn malloc_unique(bcx: block, t: ty::t)\n-    -> MallocResult {\n-    malloc_general(bcx, t, heap_for_unique(bcx, t))\n-}\n-\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc_simple(ccx: &mut CrateContext, t: ty::t) -> ValueRef {"}, {"sha": "973a124c48ad2897de82d7fc55f287997481ac9a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -274,6 +274,7 @@ pub enum heap {\n     heap_managed,\n     heap_managed_unique,\n     heap_exchange,\n+    heap_exchange_vector,\n     heap_exchange_closure\n }\n \n@@ -395,7 +396,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n         let f: @fn(block) -> block = |a| glue::trans_free(a, ptr);\n         f\n       }\n-      heap_exchange | heap_exchange_closure => {\n+      heap_exchange | heap_exchange_vector | heap_exchange_closure => {\n         let f: @fn(block) -> block = |a| glue::trans_exchange_free(a, ptr);\n         f\n       }"}, {"sha": "e86709d72b329e296365339be90fa47d20b6337c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -100,6 +100,7 @@ use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::write_guard;\n+use middle::trans::type_::Type;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n@@ -567,18 +568,31 @@ impl Datum {\n          * This datum must represent an @T or ~T box.  Returns a new\n          * by-ref datum of type T, pointing at the contents. */\n \n-        let content_ty = match ty::get(self.ty).sty {\n-            ty::ty_box(mt) | ty::ty_uniq(mt) => mt.ty,\n+        let (content_ty, header) = match ty::get(self.ty).sty {\n+            ty::ty_box(mt) => (mt.ty, true),\n+            ty::ty_uniq(mt) => (mt.ty, false),\n+            ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+                let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);\n+                let unboxed_vec_ty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n+                (unboxed_vec_ty, true)\n+            }\n             _ => {\n                 bcx.tcx().sess.bug(fmt!(\n                     \"box_body() invoked on non-box type %s\",\n                     ty_to_str(bcx.tcx(), self.ty)));\n             }\n         };\n \n-        let ptr = self.to_value_llval(bcx);\n-        let body = opaque_box_body(bcx, content_ty, ptr);\n-        Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        if !header && !ty::type_contents(bcx.tcx(), content_ty).contains_managed() {\n+            let ptr = self.to_value_llval(bcx);\n+            let ty = type_of(bcx.ccx(), content_ty);\n+            let body = PointerCast(bcx, ptr, ty.ptr_to());\n+            Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        } else { // has a header\n+            let ptr = self.to_value_llval(bcx);\n+            let body = opaque_box_body(bcx, content_ty, ptr);\n+            Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        }\n     }\n \n     pub fn to_rptr(&self, bcx: block) -> Datum {"}, {"sha": "4cf3873ee70671ba063e59256e4301abf88b311b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -150,6 +150,7 @@ use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n+use middle::trans::machine::llsize_of;\n \n use middle::trans::type_::Type;\n \n@@ -464,7 +465,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                                       expr, contents);\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_uniq) => {\n-            let heap = heap_for_unique(bcx, expr_ty(bcx, contents));\n+            let heap = tvec::heap_for_unique_vector(bcx, expr_ty(bcx, contents));\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap,\n                                                       expr, contents);\n         }\n@@ -1329,12 +1330,23 @@ fn trans_unary_datum(bcx: block,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n         let _icx = push_ctxt(\"trans_boxed_expr\");\n-        let base::MallocResult { bcx, box: bx, body } =\n-            base::malloc_general(bcx, contents_ty, heap);\n-        add_clean_free(bcx, bx, heap);\n-        let bcx = trans_into(bcx, contents, SaveIn(body));\n-        revoke_clean(bcx, bx);\n-        return immediate_rvalue_bcx(bcx, bx, box_ty);\n+        if heap == heap_exchange {\n+            let llty = type_of(bcx.ccx(), contents_ty);\n+            let size = llsize_of(bcx.ccx(), llty);\n+            let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n+                                                               heap_exchange, size);\n+            add_clean_free(bcx, val, heap_exchange);\n+            let bcx = trans_into(bcx, contents, SaveIn(val));\n+            revoke_clean(bcx, val);\n+            return immediate_rvalue_bcx(bcx, val, box_ty);\n+        } else {\n+            let base::MallocResult { bcx, box: bx, body } =\n+                base::malloc_general(bcx, contents_ty, heap);\n+            add_clean_free(bcx, bx, heap);\n+            let bcx = trans_into(bcx, contents, SaveIn(body));\n+            revoke_clean(bcx, bx);\n+            return immediate_rvalue_bcx(bcx, bx, box_ty);\n+        }\n     }\n }\n "}, {"sha": "682a4f133c08d3a845ac6e8345400e6b670defb2", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -386,7 +386,9 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_uniq(*) => {\n         uniq::make_free_glue(bcx, v, t)\n       }\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+        tvec::make_uniq_free_glue(bcx, v, t)\n+      }\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         make_free_glue(bcx, v,\n                        tvec::expand_boxed_vec_ty(bcx.tcx(), t));"}, {"sha": "14cc822b5a571687ecc97787076f20e03918404a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -548,6 +548,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n \n     let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n+    let mut bcx = bcx;\n \n     // Load the vtable from the @Trait pair\n     debug!(\"(translating trait callee) loading vtable from pair %s\",\n@@ -576,6 +577,10 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n         }\n         ast::sty_region(*) => {\n             match store {\n+                ty::UniqTraitStore\n+                    if !ty::type_contents(bcx.tcx(), callee_ty).contains_managed() => {\n+                    llself = llbox;\n+                }\n                 ty::BoxTraitStore |\n                 ty::UniqTraitStore => {\n                     llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);"}, {"sha": "de91993f345a83c10870baeb7d5478be36a1f82f", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -194,7 +194,11 @@ impl Reflector {\n           }\n           ty::ty_uniq(ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(\"uniq\", extra)\n+              if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+                  self.visit(\"uniq_managed\", extra)\n+              } else {\n+                  self.visit(\"uniq\", extra)\n+              }\n           }\n           ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);"}, {"sha": "809838ded0ab13fdc91b1f1419fca16e118b80c1", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -33,6 +33,23 @@ use std::option::None;\n use syntax::ast;\n use syntax::codemap;\n \n+pub fn make_uniq_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n+    -> block {\n+    let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n+\n+    let not_null = IsNotNull(bcx, box_datum.val);\n+    do with_cond(bcx, not_null) |bcx| {\n+        let body_datum = box_datum.box_body(bcx);\n+        let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n+                                body_datum.ty);\n+        if ty::type_contents(bcx.tcx(), box_ty).contains_managed() {\n+            glue::trans_free(bcx, box_datum.val)\n+        } else {\n+            glue::trans_exchange_free(bcx, box_datum.val)\n+        }\n+    }\n+}\n+\n // Boxed vector types are in some sense currently a \"shorthand\" for a box\n // containing an unboxed vector. This expands a boxed vector type into such an\n // expanded type. It doesn't respect mutability, but that doesn't matter at\n@@ -42,7 +59,7 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n       ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) => {\n-        ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n+        fail!(\"cannot treat vectors/strings as exchange allocations yet\");\n       }\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         ty::mk_imm_box(tcx, unboxed_vec_ty)\n@@ -95,9 +112,17 @@ pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n     return rslt(bcx, bx);\n }\n \n+pub fn heap_for_unique_vector(bcx: block, t: ty::t) -> heap {\n+    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+        heap_managed_unique\n+    } else {\n+        heap_exchange_vector\n+    }\n+}\n+\n pub fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n                       fill: ValueRef, alloc: ValueRef) -> Result {\n-    alloc_raw(bcx, unit_ty, fill, alloc, base::heap_for_unique(bcx, unit_ty))\n+    alloc_raw(bcx, unit_ty, fill, alloc, heap_for_unique_vector(bcx, unit_ty))\n }\n \n pub fn alloc_vec(bcx: block,\n@@ -298,7 +323,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n \n     // Handle ~\"\".\n     match heap {\n-        heap_exchange => {\n+        heap_exchange_vector => {\n             match content_expr.node {\n                 ast::expr_lit(@codemap::spanned {\n                     node: ast::lit_str(s), _\n@@ -321,7 +346,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n                 _ => {}\n             }\n         }\n-        heap_exchange_closure => fail!(\"vectors are not allocated with closure_exchange_alloc\"),\n+        heap_exchange | heap_exchange_closure => fail!(\"vectors use vector_exchange_alloc\"),\n         heap_managed | heap_managed_unique => {}\n     }\n "}, {"sha": "1d20481617575c5dfc39c0a257be0f3f14ea6eb1", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -72,29 +72,6 @@ pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n     }\n }\n \n-pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> Type {\n-    assert!(!ty::type_needs_infer(t));\n-\n-    let t_norm = ty::normalize_ty(cx.tcx, t);\n-    if t != t_norm {\n-        type_of_non_gc_box(cx, t_norm)\n-    } else {\n-        match ty::get(t).sty {\n-          ty::ty_box(mt) => {\n-              let ty = type_of(cx, mt.ty);\n-              Type::box(cx, &ty).ptr_to()\n-          }\n-          ty::ty_uniq(mt) => {\n-              let ty = type_of(cx, mt.ty);\n-              Type::unique(cx, &ty).ptr_to()\n-          }\n-          _ => {\n-            cx.sess.bug(\"non-box in type_of_non_gc_box\");\n-          }\n-        }\n-    }\n-}\n-\n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n // guaranteed to be equivalent to what you would get out of `type_of()`. It's\n // useful because:\n@@ -231,7 +208,11 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::unique(cx, &ty).ptr_to()\n+          if ty::type_contents(cx.tcx, mt.ty).contains_managed() {\n+              Type::unique(cx, &ty).ptr_to()\n+          } else {\n+              ty.ptr_to()\n+          }\n       }\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);"}, {"sha": "df9e29cad7f78397fd82b718402d3c0abbb67447", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -17,6 +17,9 @@ use middle::trans::datum::immediate_rvalue;\n use middle::trans::datum;\n use middle::trans::glue;\n use middle::ty;\n+use middle::trans::machine::llsize_of;\n+use middle::trans::type_of;\n+use middle::trans::type_of::*;\n \n pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n@@ -44,12 +47,21 @@ pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n     let body_datum = src_datum.box_body(bcx);\n \n     // Malloc space in exchange heap and copy src into it\n-    let MallocResult {\n-        bcx: bcx,\n-        box: dst_box,\n-        body: dst_body\n-    } = malloc_unique(bcx, body_datum.ty);\n-    body_datum.copy_to(bcx, datum::INIT, dst_body);\n-\n-    rslt(bcx, dst_box)\n+    if ty::type_contents(bcx.tcx(), src_ty).contains_managed() {\n+        let MallocResult {\n+            bcx: bcx,\n+            box: dst_box,\n+            body: dst_body\n+        } = malloc_general(bcx, body_datum.ty, heap_managed_unique);\n+        body_datum.copy_to(bcx, datum::INIT, dst_body);\n+\n+        rslt(bcx, dst_box)\n+    } else {\n+        let body_datum = body_datum.to_value_datum(bcx);\n+        let llty = type_of(bcx.ccx(), body_datum.ty);\n+        let size = llsize_of(bcx.ccx(), llty);\n+        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, body_datum.ty, heap_exchange, size);\n+        body_datum.copy_to(bcx, datum::INIT, val);\n+        Result { bcx: bcx, val: val }\n+    }\n }"}, {"sha": "9075133b08617b12f94674096c4b733bf3e1dcc2", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -248,6 +248,14 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(not(stage0))]\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n     fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }"}, {"sha": "dd5075f8e66887a2913c5ff6036ddee219e1eb6e", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -300,6 +300,15 @@ impl TyVisitor for ReprVisitor {\n     }\n \n     fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('~');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<*c_void> |b| {\n+            self.visit_ptr_inner(*b, inner);\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write_char('~');\n         self.write_mut_qualifier(mtbl);\n         do self.get::<&managed::raw::BoxRepr> |b| {"}, {"sha": "54deb8924f5c708add448532266a1a8483cfa8aa", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -80,7 +80,14 @@ pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[cfg(not(stage0), not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n-pub unsafe fn exchange_malloc(align: u32, size: uintptr_t) -> *c_char {\n+pub unsafe fn exchange_malloc(_align: u32, size: uintptr_t) -> *c_char {\n+    malloc_raw(size as uint) as *c_char\n+}\n+\n+#[cfg(not(test))]\n+#[lang=\"vector_exchange_malloc\"]\n+#[inline]\n+pub unsafe fn vector_exchange_malloc(align: u32, size: uintptr_t) -> *c_char {\n     let total_size = get_box_size(size as uint, align as uint);\n     malloc_raw(total_size as uint) as *c_char\n }"}, {"sha": "ce5ccf2401dbd00ea6e64ad1e9ca14f6ae8f95ce", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -91,6 +91,7 @@ pub trait TyVisitor {\n \n     fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n "}, {"sha": "33857556548fa4025fc2ef7f085f424620ba2856", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -33,28 +33,15 @@ use sys::size_of;\n use uint;\n use unstable::intrinsics;\n #[cfg(stage0)]\n-use intrinsic::{get_tydesc};\n+use intrinsic::{get_tydesc, TyDesc};\n #[cfg(not(stage0))]\n-use unstable::intrinsics::{get_tydesc, contains_managed};\n+use unstable::intrinsics::{get_tydesc, contains_managed, TyDesc};\n use vec;\n use util;\n \n-#[doc(hidden)]\n-pub mod rustrt {\n-    use libc;\n-    use vec::raw;\n-    #[cfg(stage0)]\n-    use intrinsic::{TyDesc};\n-    #[cfg(not(stage0))]\n-    use unstable::intrinsics::{TyDesc};\n-\n-    #[abi = \"cdecl\"]\n-    pub extern {\n-        #[fast_ffi]\n-        unsafe fn vec_reserve_shared_actual(t: *TyDesc,\n-                                            v: **raw::VecRepr,\n-                                            n: libc::size_t);\n-    }\n+extern {\n+    #[fast_ffi]\n+    unsafe fn vec_reserve_shared_actual(t: *TyDesc, v: **raw::VecRepr, n: libc::size_t);\n }\n \n /// Returns true if two vectors have the same length\n@@ -1152,7 +1139,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                 let td = get_tydesc::<T>();\n                 if ((**ptr).box_header.ref_count ==\n                     managed::raw::RC_MANAGED_UNIQUE) {\n-                    rustrt::vec_reserve_shared_actual(td, ptr as **raw::VecRepr, n as libc::size_t);\n+                    vec_reserve_shared_actual(td, ptr as **raw::VecRepr, n as libc::size_t);\n                 } else {\n                     let alloc = n * sys::nonzero_size_of::<T>();\n                     *ptr = realloc_raw(*ptr as *mut c_void, alloc + size_of::<raw::VecRepr>())\n@@ -1182,7 +1169,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                 let ptr: *mut *mut raw::VecRepr = cast::transmute(self);\n                 let td = get_tydesc::<T>();\n                 if contains_managed::<T>() {\n-                    rustrt::vec_reserve_shared_actual(td, ptr as **raw::VecRepr, n as libc::size_t);\n+                    vec_reserve_shared_actual(td, ptr as **raw::VecRepr, n as libc::size_t);\n                 } else {\n                     let alloc = n * sys::nonzero_size_of::<T>();\n                     *ptr = realloc_raw(*ptr as *mut c_void, alloc + size_of::<raw::VecRepr>())"}, {"sha": "53b39d5ed3038876612bf21144ae9d9277e02d40", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -232,6 +232,13 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n     fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n@@ -552,6 +559,7 @@ impl TyVisitor for my_visitor {\n \n     fn visit_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq_managed(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_rptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n "}, {"sha": "4ce229526ffbaf865b9178ca64526129eafdaf80", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ad726f2abc90fe62cdf239bc1c9318261a6926/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=48ad726f2abc90fe62cdf239bc1c9318261a6926", "patch": "@@ -70,6 +70,7 @@ impl TyVisitor for MyVisitor {\n \n     fn visit_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq_managed(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_rptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n "}]}