{"sha": "0e63af5da3400ace48a0345117980473fd21ad73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNjNhZjVkYTM0MDBhY2U0OGEwMzQ1MTE3OTgwNDczZmQyMWFkNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-31T10:01:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-31T10:01:15Z"}, "message": "Auto merge of #81478 - sivadeilra:windows_dll_imports, r=m-ou-se\n\nResolve DLL imports at CRT startup, not on demand\n\nOn Windows, libstd uses GetProcAddress to locate some DLL imports, so\nthat libstd can run on older versions of Windows. If a given DLL import\nis not present, then libstd uses other behavior (such as fallback\nimplementations).\n\nThis commit uses a feature of the Windows CRT to do these DLL imports\nduring module initialization, before main() (or DllMain()) is called.\nThis is the ideal time to resolve imports, because the module is\neffectively single-threaded at that point; no other threads can\ntouch the data or code of the module that is being initialized.\n\nThis avoids several problems. First, it makes the cost of performing\nthe DLL import lookups deterministic. Right now, the DLL imports are\ndone on demand, which means that application threads _might_ have to\ndo the DLL import during some time-sensitive operation. This is a\nsmall source of unpredictability. Since threads can race, it's even\npossible to have more than one thread running the same redundant\nDLL lookup.\n\nThis commit also removes using the heap to allocate strings, during\nthe DLL lookups.", "tree": {"sha": "7ae0de5b515a0eb7d1d176a7f2f379ae0dcaf6d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ae0de5b515a0eb7d1d176a7f2f379ae0dcaf6d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e63af5da3400ace48a0345117980473fd21ad73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e63af5da3400ace48a0345117980473fd21ad73", "html_url": "https://github.com/rust-lang/rust/commit/0e63af5da3400ace48a0345117980473fd21ad73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e63af5da3400ace48a0345117980473fd21ad73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b3242982202707be2485b1e4cf5f3b34466a38d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3242982202707be2485b1e4cf5f3b34466a38d", "html_url": "https://github.com/rust-lang/rust/commit/9b3242982202707be2485b1e4cf5f3b34466a38d"}, {"sha": "f4debc8e946efc02b622660c8ebb8ef369edd52d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4debc8e946efc02b622660c8ebb8ef369edd52d", "html_url": "https://github.com/rust-lang/rust/commit/f4debc8e946efc02b622660c8ebb8ef369edd52d"}], "stats": {"total": 166, "additions": 95, "deletions": 71}, "files": [{"sha": "dec886208103de07b05582a011c4b5a494421743", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e63af5da3400ace48a0345117980473fd21ad73/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e63af5da3400ace48a0345117980473fd21ad73/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=0e63af5da3400ace48a0345117980473fd21ad73", "patch": "@@ -975,6 +975,7 @@ extern \"system\" {\n     pub fn freeaddrinfo(res: *mut ADDRINFOA);\n \n     pub fn GetProcAddress(handle: HMODULE, name: LPCSTR) -> *mut c_void;\n+    pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;\n     pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n \n     pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);"}, {"sha": "017a4bbe97cc59781dc1b152073254701293d7f2", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 88, "deletions": 65, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/0e63af5da3400ace48a0345117980473fd21ad73/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e63af5da3400ace48a0345117980473fd21ad73/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=0e63af5da3400ace48a0345117980473fd21ad73", "patch": "@@ -1,93 +1,116 @@\n-//! A \"compatibility layer\" for spanning XP and Windows 7\n+//! A \"compatibility layer\" for supporting older versions of Windows\n //!\n-//! The standard library currently binds many functions that are not available\n-//! on Windows XP, but we would also like to support building executables that\n-//! run on XP. To do this we specify all non-XP APIs as having a fallback\n-//! implementation to do something reasonable.\n+//! The standard library uses some Windows API functions that are not present\n+//! on older versions of Windows.  (Note that the oldest version of Windows\n+//! that Rust supports is Windows 7 (client) and Windows Server 2008 (server).)\n+//! This module implements a form of delayed DLL import binding, using\n+//! `GetModuleHandle` and `GetProcAddress` to look up DLL entry points at\n+//! runtime.\n //!\n-//! This dynamic runtime detection of whether a function is available is\n-//! implemented with `GetModuleHandle` and `GetProcAddress` paired with a\n-//! static-per-function which caches the result of the first check. In this\n-//! manner we pay a semi-large one-time cost up front for detecting whether a\n-//! function is available but afterwards it's just a load and a jump.\n-\n-use crate::ffi::CString;\n-use crate::sys::c;\n-\n-pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n-    let mut module: Vec<u16> = module.encode_utf16().collect();\n-    module.push(0);\n-    let symbol = CString::new(symbol).unwrap();\n-    unsafe {\n-        let handle = c::GetModuleHandleW(module.as_ptr());\n-        match c::GetProcAddress(handle, symbol.as_ptr()) as usize {\n-            0 => None,\n-            n => Some(n),\n-        }\n-    }\n-}\n+//! This implementation uses a static initializer to look up the DLL entry\n+//! points. The CRT (C runtime) executes static initializers before `main`\n+//! is called (for binaries) and before `DllMain` is called (for DLLs).\n+//! This is the ideal time to look up DLL imports, because we are guaranteed\n+//! that no other threads will attempt to call these entry points. Thus,\n+//! we can look up the imports and store them in `static mut` fields\n+//! without any synchronization.\n+//!\n+//! This has an additional advantage: Because the DLL import lookup happens\n+//! at module initialization, the cost of these lookups is deterministic,\n+//! and is removed from the code paths that actually call the DLL imports.\n+//! That is, there is no unpredictable \"cache miss\" that occurs when calling\n+//! a DLL import. For applications that benefit from predictable delays,\n+//! this is a benefit. This also eliminates the comparison-and-branch\n+//! from the hot path.\n+//!\n+//! Currently, the standard library uses only a small number of dynamic\n+//! DLL imports. If this number grows substantially, then the cost of\n+//! performing all of the lookups at initialization time might become\n+//! substantial.\n+//!\n+//! The mechanism of registering a static initializer with the CRT is\n+//! documented in\n+//! [CRT Initialization](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-160).\n+//! It works by contributing a global symbol to the `.CRT$XCU` section.\n+//! The linker builds a table of all static initializer functions.\n+//! The CRT startup code then iterates that table, calling each\n+//! initializer function.\n+//!\n+//! # **WARNING!!*\n+//! The environment that a static initializer function runs in is highly\n+//! constrained. There are **many** restrictions on what static initializers\n+//! can safely do. Static initializer functions **MUST NOT** do any of the\n+//! following (this list is not comprehensive):\n+//! * touch any other static field that is used by a different static\n+//!   initializer, because the order that static initializers run in\n+//!   is not defined.\n+//! * call `LoadLibrary` or any other function that acquires the DLL\n+//!   loader lock.\n+//! * call any Rust function or CRT function that touches any static\n+//!   (global) state.\n \n macro_rules! compat_fn {\n     ($module:literal: $(\n         $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $body:block\n+        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $fallback_body:block\n     )*) => ($(\n         $(#[$meta])*\n         pub mod $symbol {\n             #[allow(unused_imports)]\n             use super::*;\n-            use crate::sync::atomic::{AtomicUsize, Ordering};\n             use crate::mem;\n \n             type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n \n-            static PTR: AtomicUsize = AtomicUsize::new(0);\n-\n-            #[allow(unused_variables)]\n-            unsafe extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $body\n-\n-            /// This address is stored in `PTR` to incidate an unavailable API.\n-            ///\n-            /// This way, call() will end up calling fallback() if it is unavailable.\n-            ///\n-            /// This is a `static` to avoid rustc duplicating `fn fallback()`\n-            /// into both load() and is_available(), which would break\n-            /// is_available()'s comparison. By using the same static variable\n-            /// in both places, they'll refer to the same (copy of the)\n-            /// function.\n+            /// Points to the DLL import, or the fallback function.\n             ///\n-            /// LLVM merging the address of fallback with other functions\n-            /// (because of unnamed_addr) is fine, since it's only compared to\n-            /// an address from GetProcAddress from an external dll.\n-            static FALLBACK: F = fallback;\n+            /// This static can be an ordinary, unsynchronized, mutable static because\n+            /// we guarantee that all of the writes finish during CRT initialization,\n+            /// and all of the reads occur after CRT initialization.\n+            static mut PTR: Option<F> = None;\n \n-            #[cold]\n-            fn load() -> usize {\n-                // There is no locking here. It's okay if this is executed by multiple threads in\n-                // parallel. `lookup` will result in the same value, and it's okay if they overwrite\n-                // eachothers result as long as they do so atomically. We don't need any guarantees\n-                // about memory ordering, as this involves just a single atomic variable which is\n-                // not used to protect or order anything else.\n-                let addr = crate::sys::compat::lookup($module, stringify!($symbol))\n-                    .unwrap_or(FALLBACK as usize);\n-                PTR.store(addr, Ordering::Relaxed);\n-                addr\n-            }\n+            /// This symbol is what allows the CRT to find the `init` function and call it.\n+            /// It is marked `#[used]` because otherwise Rust would assume that it was not\n+            /// used, and would remove it.\n+            #[used]\n+            #[link_section = \".CRT$XCU\"]\n+            static INIT_TABLE_ENTRY: fn() = init;\n \n-            fn addr() -> usize {\n-                match PTR.load(Ordering::Relaxed) {\n-                    0 => load(),\n-                    addr => addr,\n+            fn init() {\n+                // There is no locking here. This code is executed before main() is entered, and\n+                // is guaranteed to be single-threaded.\n+                //\n+                // DO NOT do anything interesting or complicated in this function! DO NOT call\n+                // any Rust functions or CRT functions, if those functions touch any global state,\n+                // because this function runs during global initialization. For example, DO NOT\n+                // do any dynamic allocation, don't call LoadLibrary, etc.\n+                unsafe {\n+                    let module_name: *const u8 = concat!($module, \"\\0\").as_ptr();\n+                    let symbol_name: *const u8 = concat!(stringify!($symbol), \"\\0\").as_ptr();\n+                    let module_handle = $crate::sys::c::GetModuleHandleA(module_name as *const i8);\n+                    if !module_handle.is_null() {\n+                        match $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8) as usize {\n+                            0 => {}\n+                            n => {\n+                                PTR = Some(mem::transmute::<usize, F>(n));\n+                            }\n+                        }\n+                    }\n                 }\n             }\n \n             #[allow(dead_code)]\n-            pub fn is_available() -> bool {\n-                addr() != FALLBACK as usize\n+            pub fn option() -> Option<F> {\n+                unsafe { PTR }\n             }\n \n+            #[allow(dead_code)]\n             pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n-                mem::transmute::<usize, F>(addr())($($argname),*)\n+                if let Some(ptr) = PTR {\n+                    ptr($($argname),*)\n+                } else {\n+                    $fallback_body\n+                }\n             }\n         }\n "}, {"sha": "4f59d4dd452be9d2149ae17aa816f62500dad47a", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e63af5da3400ace48a0345117980473fd21ad73/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e63af5da3400ace48a0345117980473fd21ad73/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=0e63af5da3400ace48a0345117980473fd21ad73", "patch": "@@ -108,10 +108,10 @@ impl Parker {\n             return;\n         }\n \n-        if c::WaitOnAddress::is_available() {\n+        if let Some(wait_on_address) = c::WaitOnAddress::option() {\n             loop {\n                 // Wait for something to happen, assuming it's still set to PARKED.\n-                c::WaitOnAddress(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, c::INFINITE);\n+                wait_on_address(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, c::INFINITE);\n                 // Change NOTIFIED=>EMPTY but leave PARKED alone.\n                 if self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Acquire).is_ok() {\n                     // Actually woken up by unpark().\n@@ -140,9 +140,9 @@ impl Parker {\n             return;\n         }\n \n-        if c::WaitOnAddress::is_available() {\n+        if let Some(wait_on_address) = c::WaitOnAddress::option() {\n             // Wait for something to happen, assuming it's still set to PARKED.\n-            c::WaitOnAddress(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, dur2timeout(timeout));\n+            wait_on_address(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, dur2timeout(timeout));\n             // Set the state back to EMPTY (from either PARKED or NOTIFIED).\n             // Note that we don't just write EMPTY, but use swap() to also\n             // include an acquire-ordered read to synchronize with unpark()'s\n@@ -192,9 +192,9 @@ impl Parker {\n         // purpose, to make sure every unpark() has a release-acquire ordering\n         // with park().\n         if self.state.swap(NOTIFIED, Release) == PARKED {\n-            if c::WakeByAddressSingle::is_available() {\n+            if let Some(wake_by_address_single) = c::WakeByAddressSingle::option() {\n                 unsafe {\n-                    c::WakeByAddressSingle(self.ptr());\n+                    wake_by_address_single(self.ptr());\n                 }\n             } else {\n                 // If we run NtReleaseKeyedEvent before the waiting thread runs"}]}