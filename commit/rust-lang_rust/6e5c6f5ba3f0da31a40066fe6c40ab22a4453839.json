{"sha": "6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNWM2ZjViYTNmMGRhMzFhNDAwNjZmZTZjNDBhYjIyYTQ0NTM4Mzk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-08-19T18:47:40Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-08-31T02:14:13Z"}, "message": "Use getters to access `Span` fields", "tree": {"sha": "7d8dce23eacbed05c5e7edce4cfd189c004c652a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d8dce23eacbed05c5e7edce4cfd189c004c652a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "html_url": "https://github.com/rust-lang/rust/commit/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eca284c9f3e26c42be3d9f2dba9859ca96dae6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eca284c9f3e26c42be3d9f2dba9859ca96dae6d", "html_url": "https://github.com/rust-lang/rust/commit/4eca284c9f3e26c42be3d9f2dba9859ca96dae6d"}], "stats": {"total": 598, "additions": 303, "deletions": 295}, "files": [{"sha": "27119dd6f0ddc14b38e214c06fcba95b145d990f", "filename": "src/chains.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -470,7 +470,7 @@ fn rewrite_method_call(\n     shape: Shape,\n ) -> Option<String> {\n     let (lo, type_str) = if types.is_empty() {\n-        (args[0].span.hi, String::new())\n+        (args[0].span.hi(), String::new())\n     } else {\n         let type_list: Vec<_> =\n             try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n@@ -481,11 +481,11 @@ fn rewrite_method_call(\n             format!(\"::<{}>\", type_list.join(\", \"))\n         };\n \n-        (types.last().unwrap().span.hi, type_str)\n+        (types.last().unwrap().span.hi(), type_str)\n     };\n \n     let callee_str = format!(\".{}{}\", method_name, type_str);\n-    let span = mk_sp(lo, span.hi);\n+    let span = mk_sp(lo, span.hi());\n \n     rewrite_call(context, &callee_str, &args[1..], span, shape)\n }"}, {"sha": "e156f34015b6d266a98925a745e75a3812224ec9", "filename": "src/codemap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -50,7 +50,7 @@ impl SpanUtils for CodeMap {\n         let snippet = self.span_to_snippet(original).unwrap();\n         let offset = snippet.find_uncommented(needle).unwrap() + needle.len();\n \n-        original.lo + BytePos(offset as u32)\n+        original.lo() + BytePos(offset as u32)\n     }\n \n     fn span_after_last(&self, original: Span, needle: &str) -> BytePos {\n@@ -61,21 +61,21 @@ impl SpanUtils for CodeMap {\n             offset += additional_offset + needle.len();\n         }\n \n-        original.lo + BytePos(offset as u32)\n+        original.lo() + BytePos(offset as u32)\n     }\n \n     fn span_before(&self, original: Span, needle: &str) -> BytePos {\n         let snippet = self.span_to_snippet(original).unwrap();\n         let offset = snippet.find_uncommented(needle).unwrap();\n \n-        original.lo + BytePos(offset as u32)\n+        original.lo() + BytePos(offset as u32)\n     }\n }\n \n impl LineRangeUtils for CodeMap {\n     fn lookup_line_range(&self, span: Span) -> LineRange {\n-        let lo = self.lookup_char_pos(span.lo);\n-        let hi = self.lookup_char_pos(span.hi);\n+        let lo = self.lookup_char_pos(span.lo());\n+        let hi = self.lookup_char_pos(span.hi());\n \n         assert!(\n             lo.file.name == hi.file.name,"}, {"sha": "e1c32235386d970edcef538f574a024f36b8c746", "filename": "src/expr.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -65,7 +65,7 @@ pub fn format_expr(\n     let expr_rw = match expr.node {\n         ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n             expr_vec.iter().map(|e| &**e),\n-            mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n+            mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi()),\n             context,\n             shape,\n             false,\n@@ -81,7 +81,7 @@ pub fn format_expr(\n             ),\n         },\n         ast::ExprKind::Call(ref callee, ref args) => {\n-            let inner_span = mk_sp(callee.span.hi, expr.span.hi);\n+            let inner_span = mk_sp(callee.span.hi(), expr.span.hi());\n             rewrite_call_with_binary_search(\n                 context,\n                 &**callee,\n@@ -308,8 +308,8 @@ pub fn format_expr(\n             let attrs = outer_attributes(&expr.attrs);\n             let attrs_str = try_opt!(attrs.rewrite(context, shape));\n             let span = mk_sp(\n-                attrs.last().map_or(expr.span.lo, |attr| attr.span.hi),\n-                expr.span.lo,\n+                attrs.last().map_or(expr.span.lo(), |attr| attr.span.hi()),\n+                expr.span.lo(),\n             );\n             combine_strs_with_missing_comments(context, &attrs_str, &expr_str, span, shape, false)\n         })\n@@ -417,11 +417,11 @@ where\n         context.codemap,\n         expr_iter,\n         \"]\",\n-        |item| item.span.lo,\n-        |item| item.span.hi,\n+        |item| item.span.lo(),\n+        |item| item.span.hi(),\n         |item| item.rewrite(context, nested_shape),\n-        span.lo,\n-        span.hi,\n+        span.lo(),\n+        span.hi(),\n         false,\n     ).collect::<Vec<_>>();\n \n@@ -536,7 +536,7 @@ fn rewrite_closure_fn_decl(\n         |arg| span_hi_for_arg(context, arg),\n         |arg| arg.rewrite(context, arg_shape),\n         context.codemap.span_after(span, \"|\"),\n-        body.span.lo,\n+        body.span.lo(),\n         false,\n     );\n     let item_vec = arg_items.collect::<Vec<_>>();\n@@ -837,9 +837,9 @@ fn rewrite_block_with_visitor(\n         ast::BlockCheckMode::Unsafe(..) => {\n             let snippet = context.snippet(block.span);\n             let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n-            visitor.last_pos = block.span.lo + BytePos(open_pos as u32)\n+            visitor.last_pos = block.span.lo() + BytePos(open_pos as u32)\n         }\n-        ast::BlockCheckMode::Default => visitor.last_pos = block.span.lo,\n+        ast::BlockCheckMode::Default => visitor.last_pos = block.span.lo(),\n     }\n \n     visitor.visit_block(block, None);\n@@ -1193,7 +1193,7 @@ impl<'a> ControlFlow<'a> {\n         let cond_span = if let Some(cond) = self.cond {\n             cond.span\n         } else {\n-            mk_sp(self.block.span.lo, self.block.span.lo)\n+            mk_sp(self.block.span.lo(), self.block.span.lo())\n         };\n \n         // `for event in event`\n@@ -1204,8 +1204,8 @@ impl<'a> ControlFlow<'a> {\n                 .codemap\n                 .span_after(mk_sp(lo, self.span.hi), self.keyword.trim()),\n             self.pat\n-                .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n-                    p.span.lo\n+                .map_or(cond_span.lo(), |p| if self.matcher.is_empty() {\n+                    p.span.lo()\n                 } else {\n                     context.codemap.span_before(self.span, self.matcher.trim())\n                 }),\n@@ -1214,7 +1214,7 @@ impl<'a> ControlFlow<'a> {\n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n \n         let after_cond_comment =\n-            extract_comment(mk_sp(cond_span.hi, self.block.span.lo), context, shape);\n+            extract_comment(mk_sp(cond_span.hi(), self.block.span.lo()), context, shape);\n \n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n@@ -1305,7 +1305,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                         next_else_block.as_ref().map(|e| &**e),\n                         false,\n                         true,\n-                        mk_sp(else_block.span.lo, self.span.hi),\n+                        mk_sp(else_block.span.lo(), self.span.hi()),\n                     ).rewrite(context, shape)\n                 }\n                 ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n@@ -1316,7 +1316,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                         next_else_block.as_ref().map(|e| &**e),\n                         false,\n                         true,\n-                        mk_sp(else_block.span.lo, self.span.hi),\n+                        mk_sp(else_block.span.lo(), self.span.hi()),\n                     ).rewrite(context, shape)\n                 }\n                 _ => {\n@@ -1332,19 +1332,19 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             };\n \n             let between_kwd_else_block = mk_sp(\n-                self.block.span.hi,\n+                self.block.span.hi(),\n                 context\n                     .codemap\n-                    .span_before(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"),\n+                    .span_before(mk_sp(self.block.span.hi(), else_block.span.lo()), \"else\"),\n             );\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n             let after_else = mk_sp(\n                 context\n                     .codemap\n-                    .span_after(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"),\n-                else_block.span.lo,\n+                    .span_after(mk_sp(self.block.span.hi(), else_block.span.lo()), \"else\"),\n+                else_block.span.lo(),\n             );\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n@@ -1504,9 +1504,9 @@ fn rewrite_match(\n     let open_brace_pos = if inner_attrs.is_empty() {\n         context\n             .codemap\n-            .span_after(mk_sp(cond.span.hi, arms[0].span().lo), \"{\")\n+            .span_after(mk_sp(cond.span.hi(), arms[0].span().lo()), \"{\")\n     } else {\n-        inner_attrs[inner_attrs.len() - 1].span().hi\n+        inner_attrs[inner_attrs.len() - 1].span().hi()\n     };\n \n     let arm_indent_str = if context.config.indent_match_arms() {\n@@ -1571,11 +1571,11 @@ fn rewrite_match_arms(\n             .zip(is_last_iter)\n             .map(|(arm, is_last)| ArmWrapper::new(arm, is_last)),\n         \"}\",\n-        |arm| arm.arm.span().lo,\n-        |arm| arm.arm.span().hi,\n+        |arm| arm.arm.span().lo(),\n+        |arm| arm.arm.span().hi(),\n         |arm| arm.rewrite(context, arm_shape),\n         open_brace_pos,\n-        span.hi,\n+        span.hi(),\n         false,\n     );\n     let arms_vec: Vec<_> = items.collect();\n@@ -1611,7 +1611,7 @@ fn rewrite_match_arm(\n             ));\n         }\n         (\n-            mk_sp(arm.attrs[arm.attrs.len() - 1].span.hi, arm.pats[0].span.lo),\n+            mk_sp(arm.attrs[arm.attrs.len() - 1].span.hi(), arm.pats[0].span.lo()),\n             try_opt!(arm.attrs.rewrite(context, shape)),\n         )\n     } else {\n@@ -1973,7 +1973,7 @@ fn string_requires_rewrite(\n     string: &str,\n     shape: Shape,\n ) -> bool {\n-    if context.codemap.lookup_char_pos(span.lo).col.0 != shape.indent.width() {\n+    if context.codemap.lookup_char_pos(span.lo()).col.0 != shape.indent.width() {\n         return true;\n     }\n \n@@ -2087,7 +2087,7 @@ where\n     ).ok_or(Ordering::Greater)?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n-    let args_span = mk_sp(span_lo, span.hi);\n+    let args_span = mk_sp(span_lo, span.hi());\n \n     let (extendable, list_str) = rewrite_call_args(\n         context,\n@@ -2146,11 +2146,11 @@ where\n         context.codemap,\n         args.iter(),\n         \")\",\n-        |item| item.span().lo,\n-        |item| item.span().hi,\n+        |item| item.span().lo(),\n+        |item| item.span().hi(),\n         |item| item.rewrite(context, shape),\n-        span.lo,\n-        span.hi,\n+        span.lo(),\n+        span.hi(),\n         true,\n     );\n     let mut item_vec: Vec<_> = items.collect();\n@@ -2569,7 +2569,7 @@ fn rewrite_struct_lit<'a>(\n             fields,\n             context,\n             shape,\n-            mk_sp(body_lo, span.hi),\n+            mk_sp(body_lo, span.hi()),\n             one_line_width,\n         ))\n     } else {\n@@ -2579,17 +2579,17 @@ fn rewrite_struct_lit<'a>(\n             .chain(base.into_iter().map(StructLitField::Base));\n \n         let span_lo = |item: &StructLitField| match *item {\n-            StructLitField::Regular(field) => field.span().lo,\n+            StructLitField::Regular(field) => field.span().lo(),\n             StructLitField::Base(expr) => {\n-                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n-                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                let last_field_hi = fields.last().map_or(span.lo(), |field| field.span.hi());\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo()));\n                 let pos = snippet.find_uncommented(\"..\").unwrap();\n                 last_field_hi + BytePos(pos as u32)\n             }\n         };\n         let span_hi = |item: &StructLitField| match *item {\n-            StructLitField::Regular(field) => field.span().hi,\n-            StructLitField::Base(expr) => expr.span.hi,\n+            StructLitField::Regular(field) => field.span().hi(),\n+            StructLitField::Base(expr) => expr.span.hi(),\n         };\n         let rewrite = |item: &StructLitField| match *item {\n             StructLitField::Regular(field) => {\n@@ -2611,7 +2611,7 @@ fn rewrite_struct_lit<'a>(\n             span_hi,\n             rewrite,\n             body_lo,\n-            span.hi,\n+            span.hi(),\n             false,\n         );\n         let item_vec = items.collect::<Vec<_>>();\n@@ -2760,11 +2760,11 @@ where\n         context.codemap,\n         items,\n         \")\",\n-        |item| item.span().lo,\n-        |item| item.span().hi,\n+        |item| item.span().lo(),\n+        |item| item.span().hi(),\n         |item| item.rewrite(context, nested_shape),\n         list_lo,\n-        span.hi - BytePos(1),\n+        span.hi() - BytePos(1),\n         false,\n     );\n     let item_vec: Vec<_> = items.collect();"}, {"sha": "04492665d70fc0adb8b248ea6f4ddd742aea4989", "filename": "src/imports.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -198,9 +198,9 @@ impl<'a> FmtVisitor<'a> {\n                     self.last_pos,\n                     p_i.attrs\n                         .iter()\n-                        .map(|attr| attr.span.lo)\n+                        .map(|attr| attr.span.lo())\n                         .min()\n-                        .unwrap_or(p_i.span.lo),\n+                        .unwrap_or(p_i.span.lo()),\n                 )\n             })\n             .unwrap_or(self.last_pos);\n@@ -211,7 +211,7 @@ impl<'a> FmtVisitor<'a> {\n             .iter()\n             .map(|p_i| {\n                 let new_item = (&*p_i, last_pos_of_prev_use_item);\n-                last_pos_of_prev_use_item = p_i.span.hi;\n+                last_pos_of_prev_use_item = p_i.span.hi();\n                 new_item\n             })\n             .collect::<Vec<_>>();\n@@ -275,23 +275,23 @@ impl<'a> FmtVisitor<'a> {\n         match rw {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n-                let prev_span = utils::mk_sp(self.last_pos, source!(self, span).lo);\n+                let prev_span = utils::mk_sp(self.last_pos, source!(self, span).lo());\n                 let span_end = match self.snippet(prev_span).rfind('\\n') {\n                     Some(offset) => self.last_pos + BytePos(offset as u32),\n-                    None => source!(self, span).lo,\n+                    None => source!(self, span).lo(),\n                 };\n                 self.format_missing(span_end);\n-                self.last_pos = source!(self, span).hi;\n+                self.last_pos = source!(self, span).hi();\n             }\n             Some(ref s) => {\n                 let s = format!(\"{}use {};\", vis, s);\n-                self.format_missing_with_indent(source!(self, span).lo);\n+                self.format_missing_with_indent(source!(self, span).lo());\n                 self.buffer.push_str(&s);\n-                self.last_pos = source!(self, span).hi;\n+                self.last_pos = source!(self, span).hi();\n             }\n             None => {\n-                self.format_missing_with_indent(source!(self, span).lo);\n-                self.format_missing(source!(self, span).hi);\n+                self.format_missing_with_indent(source!(self, span).lo());\n+                self.format_missing(source!(self, span).hi());\n             }\n         }\n     }\n@@ -442,11 +442,11 @@ fn rewrite_use_list(\n             context.codemap,\n             path_list.iter(),\n             \"}\",\n-            |vpi| vpi.span.lo,\n-            |vpi| vpi.span.hi,\n+            |vpi| vpi.span.lo(),\n+            |vpi| vpi.span.hi(),\n             rewrite_path_item,\n             context.codemap.span_after(span, \"{\"),\n-            span.hi,\n+            span.hi(),\n             false,\n         );\n         items.extend(iter);"}, {"sha": "500150d877a1eefef8312e8174fded67531d9846", "filename": "src/items.rs", "status": "modified", "additions": 93, "deletions": 89, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -167,11 +167,11 @@ impl<'a> FmtVisitor<'a> {\n         if !item.body.is_empty() || contains_comment(&snippet[brace_pos..]) {\n             // FIXME: this skips comments between the extern keyword and the opening\n             // brace.\n-            self.last_pos = item.span.lo + BytePos(brace_pos as u32 + 1);\n+            self.last_pos = item.span.lo() + BytePos(brace_pos as u32 + 1);\n             self.block_indent = self.block_indent.block_indent(self.config);\n \n             if item.body.is_empty() {\n-                self.format_missing_no_indent(item.span.hi - BytePos(1));\n+                self.format_missing_no_indent(item.span.hi() - BytePos(1));\n                 self.block_indent = self.block_indent.block_unindent(self.config);\n \n                 self.buffer\n@@ -182,12 +182,12 @@ impl<'a> FmtVisitor<'a> {\n                 }\n \n                 self.block_indent = self.block_indent.block_unindent(self.config);\n-                self.format_missing_with_indent(item.span.hi - BytePos(1));\n+                self.format_missing_with_indent(item.span.hi() - BytePos(1));\n             }\n         }\n \n         self.buffer.push_str(\"}\");\n-        self.last_pos = item.span.hi;\n+        self.last_pos = item.span.hi();\n     }\n \n     fn format_body_element(&mut self, element: &BodyElement) {\n@@ -205,7 +205,7 @@ impl<'a> FmtVisitor<'a> {\n     fn format_foreign_item(&mut self, item: &ast::ForeignItem) {\n         let rewrite = item.rewrite(&self.get_context(), self.shape());\n         self.push_rewrite(item.span(), rewrite);\n-        self.last_pos = item.span.hi;\n+        self.last_pos = item.span.hi();\n     }\n \n     pub fn rewrite_fn(\n@@ -224,7 +224,7 @@ impl<'a> FmtVisitor<'a> {\n     ) -> Option<String> {\n         let context = self.get_context();\n \n-        let block_snippet = self.snippet(mk_sp(block.span.lo, block.span.hi));\n+        let block_snippet = self.snippet(mk_sp(block.span.lo(), block.span.hi()));\n         let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n             !context.config.fn_empty_single_line();\n         let mut newline_brace = newline_for_brace(self.config, &generics.where_clause, has_body);\n@@ -277,7 +277,7 @@ impl<'a> FmtVisitor<'a> {\n         span: Span,\n     ) -> Option<String> {\n         // Drop semicolon or it will be interpreted as comment.\n-        let span = mk_sp(span.lo, span.hi - BytePos(1));\n+        let span = mk_sp(span.lo(), span.hi() - BytePos(1));\n         let context = self.get_context();\n \n         let (mut result, _) = try_opt!(rewrite_fn_base(\n@@ -362,7 +362,7 @@ impl<'a> FmtVisitor<'a> {\n \n         let enum_snippet = self.snippet(span);\n         let brace_pos = enum_snippet.find_uncommented(\"{\").unwrap();\n-        let body_start = span.lo + BytePos(brace_pos as u32 + 1);\n+        let body_start = span.lo() + BytePos(brace_pos as u32 + 1);\n         let generics_str = format_generics(\n             &self.get_context(),\n             generics,\n@@ -371,21 +371,21 @@ impl<'a> FmtVisitor<'a> {\n             self.config.item_brace_style(),\n             enum_def.variants.is_empty(),\n             self.block_indent,\n-            mk_sp(span.lo, body_start),\n+            mk_sp(span.lo(), body_start),\n             last_line_width(&enum_header),\n         ).unwrap();\n         self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n \n         self.block_indent = self.block_indent.block_indent(self.config);\n-        let variant_list = self.format_variant_list(enum_def, body_start, span.hi - BytePos(1));\n+        let variant_list = self.format_variant_list(enum_def, body_start, span.hi() - BytePos(1));\n         match variant_list {\n             Some(ref body_str) => self.buffer.push_str(body_str),\n             None => if contains_comment(&enum_snippet[brace_pos..]) {\n-                self.format_missing_no_indent(span.hi - BytePos(1))\n+                self.format_missing_no_indent(span.hi() - BytePos(1))\n             } else {\n-                self.format_missing(span.hi - BytePos(1))\n+                self.format_missing(span.hi() - BytePos(1))\n             },\n         }\n         self.block_indent = self.block_indent.block_unindent(self.config);\n@@ -395,7 +395,7 @@ impl<'a> FmtVisitor<'a> {\n                 .push_str(&self.block_indent.to_string(self.config));\n         }\n         self.buffer.push_str(\"}\");\n-        self.last_pos = span.hi;\n+        self.last_pos = span.hi();\n     }\n \n     // Format the body of an enum definition\n@@ -418,11 +418,11 @@ impl<'a> FmtVisitor<'a> {\n             enum_def.variants.iter(),\n             \"}\",\n             |f| if !f.node.attrs.is_empty() {\n-                f.node.attrs[0].span.lo\n+                f.node.attrs[0].span.lo()\n             } else {\n-                f.span.lo\n+                f.span.lo()\n             },\n-            |f| f.span.hi,\n+            |f| f.span.hi(),\n             |f| self.format_variant(f),\n             body_lo,\n             body_hi,\n@@ -450,8 +450,8 @@ impl<'a> FmtVisitor<'a> {\n     // Variant of an enum.\n     fn format_variant(&self, field: &ast::Variant) -> Option<String> {\n         if contains_skip(&field.node.attrs) {\n-            let lo = field.node.attrs[0].span.lo;\n-            let span = mk_sp(lo, field.span.hi);\n+            let lo = field.node.attrs[0].span.lo();\n+            let span = mk_sp(lo, field.span.hi());\n             return Some(self.snippet(span));\n         }\n \n@@ -463,8 +463,8 @@ impl<'a> FmtVisitor<'a> {\n             .node\n             .attrs\n             .last()\n-            .map_or(field.span.lo, |attr| attr.span.hi);\n-        let span = mk_sp(lo, field.span.lo);\n+            .map_or(field.span.lo(), |attr| attr.span.hi());\n+        let span = mk_sp(lo, field.span.lo());\n \n         let variant_body = match field.node.data {\n             ast::VariantData::Tuple(..) | ast::VariantData::Struct(..) => {\n@@ -547,7 +547,7 @@ pub fn format_impl(\n             context.config.where_density(),\n             \"{\",\n             where_span_end,\n-            self_ty.span.hi,\n+            self_ty.span.hi(),\n             option,\n         ));\n \n@@ -612,14 +612,14 @@ pub fn format_impl(\n         if !items.is_empty() || contains_comment(&snippet[open_pos..]) {\n             let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n             visitor.block_indent = offset.block_only().block_indent(context.config);\n-            visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n+            visitor.last_pos = item.span.lo() + BytePos(open_pos as u32);\n \n             visitor.visit_attrs(&item.attrs, ast::AttrStyle::Inner);\n             for item in items {\n                 visitor.visit_impl_item(item);\n             }\n \n-            visitor.format_missing(item.span.hi - BytePos(1));\n+            visitor.format_missing(item.span.hi() - BytePos(1));\n \n             let inner_indent_str = visitor.block_indent.to_string(context.config);\n             let outer_indent_str = offset.block_only().to_string(context.config);\n@@ -683,8 +683,8 @@ fn format_impl_ref_and_type(\n \n         let lo = context.codemap.span_after(item.span, \"impl\");\n         let hi = match *trait_ref {\n-            Some(ref tr) => tr.path.span.lo,\n-            None => self_ty.span.lo,\n+            Some(ref tr) => tr.path.span.lo(),\n+            None => self_ty.span.lo(),\n         };\n         let shape = try_opt!(generics_shape_from_config(\n             context.config,\n@@ -891,7 +891,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             context,\n             generics,\n             shape,\n-            mk_sp(item.span.lo, body_lo),\n+            mk_sp(item.span.lo(), body_lo),\n         ));\n         result.push_str(&generics_str);\n \n@@ -931,9 +931,9 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 .checked_sub(last_line_width(&result))\n         );\n         let pos_before_where = if type_param_bounds.is_empty() {\n-            generics.where_clause.span.lo\n+            generics.where_clause.span.lo()\n         } else {\n-            type_param_bounds[type_param_bounds.len() - 1].span().hi\n+            type_param_bounds[type_param_bounds.len() - 1].span().hi()\n         };\n         let option = WhereClauseOption::snuggled(&generics_str);\n         let where_clause_str = try_opt!(rewrite_where_clause(\n@@ -1009,13 +1009,13 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         if !trait_items.is_empty() || contains_comment(&snippet[open_pos..]) {\n             let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n             visitor.block_indent = offset.block_only().block_indent(context.config);\n-            visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n+            visitor.last_pos = item.span.lo() + BytePos(open_pos as u32);\n \n             for item in trait_items {\n                 visitor.visit_trait_item(item);\n             }\n \n-            visitor.format_missing(item.span.hi - BytePos(1));\n+            visitor.format_missing(item.span.hi() - BytePos(1));\n \n             let inner_indent_str = visitor.block_indent.to_string(context.config);\n             let outer_indent_str = offset.block_only().to_string(context.config);\n@@ -1067,7 +1067,7 @@ pub fn format_struct_struct(\n             context.config.item_brace_style(),\n             fields.is_empty(),\n             offset,\n-            mk_sp(span.lo, body_lo),\n+            mk_sp(span.lo(), body_lo),\n             last_line_width(&result),\n         )),\n         None => {\n@@ -1103,7 +1103,7 @@ pub fn format_struct_struct(\n     }\n \n     if fields.is_empty() {\n-        let snippet = context.snippet(mk_sp(body_lo, span.hi - BytePos(1)));\n+        let snippet = context.snippet(mk_sp(body_lo, span.hi() - BytePos(1)));\n         if snippet.trim().is_empty() {\n             // `struct S {}`\n         } else if snippet.trim_right_matches(&[' ', '\\t'][..]).ends_with('\\n') {\n@@ -1131,7 +1131,7 @@ pub fn format_struct_struct(\n         fields,\n         context,\n         Shape::indented(offset, context.config),\n-        mk_sp(body_lo, span.hi),\n+        mk_sp(body_lo, span.hi()),\n         one_line_budget,\n     ));\n \n@@ -1168,27 +1168,27 @@ fn format_tuple_struct(\n     let body_lo = if fields.is_empty() {\n         context.codemap.span_after(span, \"(\")\n     } else {\n-        fields[0].span.lo\n+        fields[0].span.lo()\n     };\n     let body_hi = if fields.is_empty() {\n         context.codemap.span_after(span, \")\")\n     } else {\n         // This is a dirty hack to work around a missing `)` from the span of the last field.\n         let last_arg_span = fields[fields.len() - 1].span;\n         if context.snippet(last_arg_span).ends_with(\")\") {\n-            last_arg_span.hi\n+            last_arg_span.hi()\n         } else {\n             context\n                 .codemap\n-                .span_after(mk_sp(last_arg_span.hi, span.hi), \")\")\n+                .span_after(mk_sp(last_arg_span.hi(), span.hi()), \")\")\n         }\n     };\n \n     let where_clause_str = match generics {\n         Some(generics) => {\n             let budget = context.budget(last_line_width(&header_str));\n             let shape = Shape::legacy(budget, offset);\n-            let g_span = mk_sp(span.lo, body_lo);\n+            let g_span = mk_sp(span.lo(), body_lo);\n             let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n             result.push_str(&generics_str);\n \n@@ -1279,7 +1279,7 @@ pub fn rewrite_type_alias(\n \n     // 2 = `= `\n     let shape = try_opt!(Shape::indented(indent + result.len(), context.config).sub_width(2));\n-    let g_span = mk_sp(context.codemap.span_after(span, \"type\"), ty.span.lo);\n+    let g_span = mk_sp(context.codemap.span_after(span, \"type\"), ty.span.lo());\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n@@ -1297,8 +1297,8 @@ pub fn rewrite_type_alias(\n         Shape::legacy(where_budget, indent),\n         context.config.where_density(),\n         \"=\",\n-        Some(span.hi),\n-        generics.span.hi,\n+        Some(span.hi()),\n+        generics.span.hi(),\n         option,\n     ));\n     result.push_str(&where_clause_str);\n@@ -1396,7 +1396,7 @@ pub fn rewrite_struct_field(\n     lhs_max_width: usize,\n ) -> Option<String> {\n     if contains_skip(&field.attrs) {\n-        let span = context.snippet(mk_sp(field.attrs[0].span.lo, field.span.hi));\n+        let span = context.snippet(mk_sp(field.attrs[0].span.lo(), field.span.hi()));\n         return wrap_str(span, context.config.max_width(), shape);\n     }\n \n@@ -1407,9 +1407,9 @@ pub fn rewrite_struct_field(\n     let attrs_extendable = attrs_str.is_empty() ||\n         (context.config.attributes_on_same_line_as_field() && is_attributes_extendable(&attrs_str));\n     let missing_span = if field.attrs.is_empty() {\n-        mk_sp(field.span.lo, field.span.lo)\n+        mk_sp(field.span.lo(), field.span.lo())\n     } else {\n-        mk_sp(field.attrs.last().unwrap().span.hi, field.span.lo)\n+        mk_sp(field.attrs.last().unwrap().span.hi(), field.span.lo())\n     };\n     let mut spacing = String::from(if field.ident.is_some() {\n         type_annotation_spacing.1\n@@ -1706,17 +1706,17 @@ fn explicit_self_mutability(arg: &ast::Arg) -> ast::Mutability {\n \n pub fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n     if is_named_arg(arg) {\n-        arg.pat.span.lo\n+        arg.pat.span.lo()\n     } else {\n-        arg.ty.span.lo\n+        arg.ty.span.lo()\n     }\n }\n \n pub fn span_hi_for_arg(context: &RewriteContext, arg: &ast::Arg) -> BytePos {\n     match arg.ty.node {\n-        ast::TyKind::Infer if context.snippet(arg.ty.span) == \"_\" => arg.ty.span.hi,\n-        ast::TyKind::Infer if is_named_arg(arg) => arg.pat.span.hi,\n-        _ => arg.ty.span.hi,\n+        ast::TyKind::Infer if context.snippet(arg.ty.span) == \"_\" => arg.ty.span.hi(),\n+        ast::TyKind::Infer if is_named_arg(arg) => arg.pat.span.hi(),\n+        _ => arg.ty.span.hi(),\n     }\n }\n \n@@ -1782,7 +1782,7 @@ fn rewrite_fn_base(\n         indent: indent,\n         offset: used_width,\n     };\n-    let g_span = mk_sp(span.lo, fd.output.span().lo);\n+    let g_span = mk_sp(span.lo(), fd.output.span().lo());\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n@@ -1850,15 +1850,19 @@ fn rewrite_fn_base(\n     let args_start = generics\n         .ty_params\n         .last()\n-        .map_or(span.lo, |tp| end_typaram(tp));\n+        .map_or(span.lo(), |tp| end_typaram(tp));\n     let args_end = if fd.inputs.is_empty() {\n-        context.codemap.span_after(mk_sp(args_start, span.hi), \")\")\n+        context\n+            .codemap\n+            .span_after(mk_sp(args_start, span.hi()), \")\")\n     } else {\n-        let last_span = mk_sp(fd.inputs[fd.inputs.len() - 1].span().hi, span.hi);\n+        let last_span = mk_sp(fd.inputs[fd.inputs.len() - 1].span().hi(), span.hi());\n         context.codemap.span_after(last_span, \")\")\n     };\n     let args_span = mk_sp(\n-        context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n+        context\n+            .codemap\n+            .span_after(mk_sp(args_start, span.hi()), \"(\"),\n         args_end,\n     );\n     let arg_str = try_opt!(rewrite_args(\n@@ -1970,9 +1974,9 @@ fn rewrite_fn_base(\n         }\n \n         // Comment between return type and the end of the decl.\n-        let snippet_lo = fd.output.span().hi;\n+        let snippet_lo = fd.output.span().hi();\n         if where_clause.predicates.is_empty() {\n-            let snippet_hi = span.hi;\n+            let snippet_hi = span.hi();\n             let snippet = context.snippet(mk_sp(snippet_lo, snippet_hi));\n             // Try to preserve the layout of the original snippet.\n             let original_starts_with_newline = snippet\n@@ -2003,8 +2007,8 @@ fn rewrite_fn_base(\n     };\n \n     let pos_before_where = match fd.output {\n-        ast::FunctionRetTy::Default(..) => args_span.hi,\n-        ast::FunctionRetTy::Ty(ref ty) => ty.span.hi,\n+        ast::FunctionRetTy::Default(..) => args_span.hi(),\n+        ast::FunctionRetTy::Ty(ref ty) => ty.span.hi(),\n     };\n \n     if where_clause.predicates.len() == 1 && should_compress_where {\n@@ -2020,7 +2024,7 @@ fn rewrite_fn_base(\n             Shape::legacy(budget, indent),\n             Density::Compressed,\n             \"{\",\n-            Some(span.hi),\n+            Some(span.hi()),\n             pos_before_where,\n             WhereClauseOption::compressed(),\n         ) {\n@@ -2038,7 +2042,7 @@ fn rewrite_fn_base(\n         Shape::indented(indent, context.config),\n         Density::Tall,\n         \"{\",\n-        Some(span.hi),\n+        Some(span.hi()),\n         pos_before_where,\n         option,\n     ));\n@@ -2047,7 +2051,7 @@ fn rewrite_fn_base(\n     if where_clause_str.is_empty() {\n         if let ast::FunctionRetTy::Default(ret_span) = fd.output {\n             match recover_missing_comment_in_span(\n-                mk_sp(args_span.hi, ret_span.hi),\n+                mk_sp(args_span.hi(), ret_span.hi()),\n                 shape,\n                 context,\n                 last_line_width(&result),\n@@ -2144,15 +2148,15 @@ fn rewrite_args(\n     if args.len() >= min_args || variadic {\n         let comment_span_start = if min_args == 2 {\n             let second_arg_start = if arg_has_pattern(&args[1]) {\n-                args[1].pat.span.lo\n+                args[1].pat.span.lo()\n             } else {\n-                args[1].ty.span.lo\n+                args[1].ty.span.lo()\n             };\n-            let reduced_span = mk_sp(span.lo, second_arg_start);\n+            let reduced_span = mk_sp(span.lo(), second_arg_start);\n \n             context.codemap.span_after_last(reduced_span, \",\")\n         } else {\n-            span.lo\n+            span.lo()\n         };\n \n         enum ArgumentKind<'a> {\n@@ -2161,7 +2165,7 @@ fn rewrite_args(\n         }\n \n         let variadic_arg = if variadic {\n-            let variadic_span = mk_sp(args.last().unwrap().ty.span.hi, span.hi);\n+            let variadic_span = mk_sp(args.last().unwrap().ty.span.hi(), span.hi());\n             let variadic_start = context.codemap.span_after(variadic_span, \"...\") - BytePos(3);\n             Some(ArgumentKind::Variadic(variadic_start))\n         } else {\n@@ -2180,15 +2184,15 @@ fn rewrite_args(\n                 ArgumentKind::Variadic(start) => start,\n             },\n             |arg| match *arg {\n-                ArgumentKind::Regular(arg) => arg.ty.span.hi,\n+                ArgumentKind::Regular(arg) => arg.ty.span.hi(),\n                 ArgumentKind::Variadic(start) => start + BytePos(3),\n             },\n             |arg| match *arg {\n                 ArgumentKind::Regular(..) => None,\n                 ArgumentKind::Variadic(..) => Some(\"...\".to_owned()),\n             },\n             comment_span_start,\n-            span.hi,\n+            span.hi(),\n             false,\n         );\n \n@@ -2376,24 +2380,24 @@ fn rewrite_generics_inner(\n     // Extract comments between generics.\n     let lt_spans = lifetimes.iter().map(|l| {\n         let hi = if l.bounds.is_empty() {\n-            l.lifetime.span.hi\n+            l.lifetime.span.hi()\n         } else {\n-            l.bounds[l.bounds.len() - 1].span.hi\n+            l.bounds[l.bounds.len() - 1].span.hi()\n         };\n-        mk_sp(l.lifetime.span.lo, hi)\n+        mk_sp(l.lifetime.span.lo(), hi)\n     });\n     let ty_spans = tys.iter().map(|ty| ty.span());\n \n     let items = itemize_list(\n         context.codemap,\n         lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n         \">\",\n-        |&(sp, _)| sp.lo,\n-        |&(sp, _)| sp.hi,\n+        |&(sp, _)| sp.lo(),\n+        |&(sp, _)| sp.hi(),\n         // FIXME: don't clone\n         |&(_, ref str)| str.clone(),\n         context.codemap.span_after(span, \"<\"),\n-        span.hi,\n+        span.hi(),\n         false,\n     );\n     format_generics_item_list(context, items, shape, one_line_width)\n@@ -2524,18 +2528,18 @@ fn rewrite_where_clause_rfc_style(\n \n     let clause_shape = block_shape.block_indent(context.config.tab_spaces());\n     // each clause on one line, trailing comma (except if suppress_comma)\n-    let span_start = where_clause.predicates[0].span().lo;\n+    let span_start = where_clause.predicates[0].span().lo();\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n     let len = where_clause.predicates.len();\n-    let end_of_preds = where_clause.predicates[len - 1].span().hi;\n+    let end_of_preds = where_clause.predicates[len - 1].span().hi();\n     let span_end = span_end.unwrap_or(end_of_preds);\n     let items = itemize_list(\n         context.codemap,\n         where_clause.predicates.iter(),\n         terminator,\n-        |pred| pred.span().lo,\n-        |pred| pred.span().hi,\n+        |pred| pred.span().lo(),\n+        |pred| pred.span().hi(),\n         |pred| pred.rewrite(context, block_shape),\n         span_start,\n         span_end,\n@@ -2626,18 +2630,18 @@ fn rewrite_where_clause(\n     // be out by a char or two.\n \n     let budget = context.config.max_width() - offset.width();\n-    let span_start = where_clause.predicates[0].span().lo;\n+    let span_start = where_clause.predicates[0].span().lo();\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n     let len = where_clause.predicates.len();\n-    let end_of_preds = where_clause.predicates[len - 1].span().hi;\n+    let end_of_preds = where_clause.predicates[len - 1].span().hi();\n     let span_end = span_end.unwrap_or(end_of_preds);\n     let items = itemize_list(\n         context.codemap,\n         where_clause.predicates.iter(),\n         terminator,\n-        |pred| pred.span().lo,\n-        |pred| pred.span().hi,\n+        |pred| pred.span().lo(),\n+        |pred| pred.span().hi(),\n         |pred| pred.rewrite(context, Shape::legacy(budget, offset)),\n         span_start,\n         span_end,\n@@ -2700,10 +2704,10 @@ fn missing_span_before_after_where(\n     before_item_span_end: BytePos,\n     where_clause: &ast::WhereClause,\n ) -> (Span, Span) {\n-    let missing_span_before = mk_sp(before_item_span_end, where_clause.span.lo);\n+    let missing_span_before = mk_sp(before_item_span_end, where_clause.span.lo());\n     // 5 = `where`\n-    let pos_after_where = where_clause.span.lo + BytePos(5);\n-    let missing_span_after = mk_sp(pos_after_where, where_clause.predicates[0].span().lo);\n+    let pos_after_where = where_clause.span.lo() + BytePos(5);\n+    let missing_span_after = mk_sp(pos_after_where, where_clause.predicates[0].span().lo());\n     (missing_span_before, missing_span_after)\n }\n \n@@ -2754,8 +2758,8 @@ fn format_generics(\n             Shape::legacy(budget, offset.block_only()),\n             Density::Tall,\n             terminator,\n-            Some(span.hi),\n-            generics.span.hi,\n+            Some(span.hi()),\n+            generics.span.hi(),\n             option,\n         ));\n         result.push_str(&where_clause_str);\n@@ -2796,7 +2800,7 @@ impl Rewrite for ast::ForeignItem {\n         let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n         // Drop semicolon or it will be interpreted as comment.\n         // FIXME: this may be a faulty span from libsyntax.\n-        let span = mk_sp(self.span.lo, self.span.hi - BytePos(1));\n+        let span = mk_sp(self.span.lo(), self.span.hi() - BytePos(1));\n \n         let item_str = try_opt!(match self.node {\n             ast::ForeignItemKind::Fn(ref fn_decl, ref generics) => {\n@@ -2841,9 +2845,9 @@ impl Rewrite for ast::ForeignItem {\n         });\n \n         let missing_span = if self.attrs.is_empty() {\n-            mk_sp(self.span.lo, self.span.lo)\n+            mk_sp(self.span.lo(), self.span.lo())\n         } else {\n-            mk_sp(self.attrs[self.attrs.len() - 1].span.hi, self.span.lo)\n+            mk_sp(self.attrs[self.attrs.len() - 1].span.hi(), self.span.lo())\n         };\n         combine_strs_with_missing_comments(\n             context,"}, {"sha": "da87ede7c60189884a74f9e9d972da349e9d0926", "filename": "src/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -86,15 +86,15 @@ macro_rules! span_with_attrs_lo_hi {\n             if attrs.is_empty() {\n                 mk_sp($lo, $hi)\n             } else {\n-                mk_sp(attrs[0].span.lo, $hi)\n+                mk_sp(attrs[0].span.lo(), $hi)\n             }\n         }\n     }\n }\n \n macro_rules! span_with_attrs {\n     ($this:ident) => {\n-        span_with_attrs_lo_hi!($this, $this.span.lo, $this.span.hi)\n+        span_with_attrs_lo_hi!($this, $this.span.lo(), $this.span.hi())\n     }\n }\n \n@@ -121,7 +121,7 @@ impl Spanned for ast::Stmt {\n             ast::StmtKind::Local(ref local) => mk_sp(local.span().lo, self.span.hi),\n             ast::StmtKind::Item(ref item) => mk_sp(item.span().lo, self.span.hi),\n             ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n-                mk_sp(expr.span().lo, self.span.hi)\n+                mk_sp(expr.span().lo(), self.span.hi())\n             }\n             ast::StmtKind::Mac(ref mac) => {\n                 let (_, _, ref attrs) = **mac;\n@@ -149,14 +149,14 @@ impl Spanned for ast::Ty {\n \n impl Spanned for ast::Arm {\n     fn span(&self) -> Span {\n-        span_with_attrs_lo_hi!(self, self.pats[0].span.lo, self.body.span.hi)\n+        span_with_attrs_lo_hi!(self, self.pats[0].span.lo(), self.body.span.hi())\n     }\n }\n \n impl Spanned for ast::Arg {\n     fn span(&self) -> Span {\n         if items::is_named_arg(self) {\n-            utils::mk_sp(self.pat.span.lo, self.ty.span.hi)\n+            utils::mk_sp(self.pat.span.lo(), self.ty.span.hi())\n         } else {\n             self.ty.span\n         }\n@@ -165,7 +165,7 @@ impl Spanned for ast::Arg {\n \n impl Spanned for ast::StructField {\n     fn span(&self) -> Span {\n-        span_with_attrs_lo_hi!(self, self.span.lo, self.ty.span.hi)\n+        span_with_attrs_lo_hi!(self, self.span.lo(), self.ty.span.hi())\n     }\n }\n \n@@ -192,17 +192,17 @@ impl Spanned for ast::TyParam {\n     fn span(&self) -> Span {\n         // Note that ty.span is the span for ty.ident, not the whole item.\n         let lo = if self.attrs.is_empty() {\n-            self.span.lo\n+            self.span.lo()\n         } else {\n-            self.attrs[0].span.lo\n+            self.attrs[0].span.lo()\n         };\n         if let Some(ref def) = self.default {\n-            return mk_sp(lo, def.span.hi);\n+            return mk_sp(lo, def.span.hi());\n         }\n         if self.bounds.is_empty() {\n-            return mk_sp(lo, self.span.hi);\n+            return mk_sp(lo, self.span.hi());\n         }\n-        let hi = self.bounds[self.bounds.len() - 1].span().hi;\n+        let hi = self.bounds[self.bounds.len() - 1].span().hi();\n         mk_sp(lo, hi)\n     }\n }\n@@ -705,7 +705,7 @@ where\n         }\n         {\n             let mut visitor = FmtVisitor::from_codemap(parse_session, config);\n-            let filemap = visitor.codemap.lookup_char_pos(module.inner.lo).file;\n+            let filemap = visitor.codemap.lookup_char_pos(module.inner.lo()).file;\n             // Format inner attributes if available.\n             if !krate.attrs.is_empty() && path == main_file {\n                 visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner);"}, {"sha": "d9156e08e85ab18fa8ada3c44d67965046f0936f", "filename": "src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -234,7 +234,7 @@ pub fn rewrite_macro(\n                         context\n                             .codemap\n                             .span_after(mac.span, original_style.opener()),\n-                        mac.span.hi - BytePos(1),\n+                        mac.span.hi() - BytePos(1),\n                     ),\n                     context,\n                     mac_shape,"}, {"sha": "43e81e12f71431565b2b654bc7e4c4b3960e6836", "filename": "src/missed_spans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -82,14 +82,14 @@ impl<'a> FmtVisitor<'a> {\n         // Get a snippet from the file start to the span's hi without allocating.\n         // We need it to determine what precedes the current comment. If the comment\n         // follows code on the same line, we won't touch it.\n-        let big_span_lo = self.codemap.lookup_char_pos(span.lo).file.start_pos;\n+        let big_span_lo = self.codemap.lookup_char_pos(span.lo()).file.start_pos;\n         let local_begin = self.codemap.lookup_byte_offset(big_span_lo);\n-        let local_end = self.codemap.lookup_byte_offset(span.hi);\n+        let local_end = self.codemap.lookup_byte_offset(span.hi());\n         let start_index = local_begin.pos.to_usize();\n         let end_index = local_end.pos.to_usize();\n         let big_snippet = &local_begin.fm.src.as_ref().unwrap()[start_index..end_index];\n \n-        let big_diff = (span.lo - big_span_lo).to_usize();\n+        let big_diff = (span.lo() - big_span_lo).to_usize();\n         let snippet = self.snippet(span.clone());\n \n         debug!(\"write_snippet `{}`\", snippet);\n@@ -114,7 +114,7 @@ impl<'a> FmtVisitor<'a> {\n         let mut last_wspace = None;\n         let mut rewrite_next_comment = true;\n \n-        let char_pos = self.codemap.lookup_char_pos(span.lo);\n+        let char_pos = self.codemap.lookup_char_pos(span.lo());\n         let file_name = &char_pos.file.name;\n         let mut cur_line = char_pos.line;\n "}, {"sha": "70d94f4bee7282baab164d8235fdc89e7c77df30", "filename": "src/patterns.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -157,11 +157,11 @@ fn rewrite_struct_pat(\n         context.codemap,\n         fields.iter(),\n         terminator,\n-        |f| f.span.lo,\n-        |f| f.span.hi,\n+        |f| f.span.lo(),\n+        |f| f.span.hi(),\n         |f| f.node.rewrite(context, v_shape),\n         context.codemap.span_after(span, \"{\"),\n-        span.hi,\n+        span.hi(),\n         false,\n     );\n     let item_vec = items.collect::<Vec<_>>();\n@@ -266,24 +266,24 @@ fn rewrite_tuple_pat(\n \n     if let Some(pos) = dotdot_pos {\n         let prev = if pos == 0 {\n-            span.lo\n+            span.lo()\n         } else {\n-            pats[pos - 1].span().hi\n+            pats[pos - 1].span().hi()\n         };\n         let next = if pos + 1 >= pats.len() {\n-            span.hi\n+            span.hi()\n         } else {\n-            pats[pos + 1].span().lo\n+            pats[pos + 1].span().lo()\n         };\n         let dot_span = mk_sp(prev, next);\n         let snippet = context.snippet(dot_span);\n-        let lo = dot_span.lo + BytePos(snippet.find_uncommented(\"..\").unwrap() as u32);\n-        let dotdot = TuplePatField::Dotdot(Span {\n-            lo: lo,\n+        let lo = dot_span.lo() + BytePos(snippet.find_uncommented(\"..\").unwrap() as u32);\n+        let dotdot = TuplePatField::Dotdot(Span::new(\n+            lo,\n             // 2 == \"..\".len()\n-            hi: lo + BytePos(2),\n-            ctxt: codemap::NO_EXPANSION,\n-        });\n+            lo + BytePos(2),\n+            codemap::NO_EXPANSION,\n+        ));\n         pat_vec.insert(pos, dotdot);\n     }\n \n@@ -297,9 +297,12 @@ fn rewrite_tuple_pat(\n         let new_item_count = 1 + pat_vec.len() - wildcard_suffix_len;\n         let sp = pat_vec[new_item_count - 1].span();\n         let snippet = context.snippet(sp);\n-        let lo = sp.lo + BytePos(snippet.find_uncommented(\"_\").unwrap() as u32);\n+        let lo = sp.lo() + BytePos(snippet.find_uncommented(\"_\").unwrap() as u32);\n         pat_vec[new_item_count - 1] = TuplePatField::Dotdot(mk_sp(lo, lo + BytePos(1)));\n-        (&pat_vec[..new_item_count], mk_sp(span.lo, lo + BytePos(1)))\n+        (\n+            &pat_vec[..new_item_count],\n+            mk_sp(span.lo(), lo + BytePos(1)),\n+        )\n     } else {\n         (&pat_vec[..], span)\n     };\n@@ -338,11 +341,11 @@ fn count_wildcard_suffix_len(\n         context.codemap,\n         patterns.iter(),\n         \")\",\n-        |item| item.span().lo,\n-        |item| item.span().hi,\n+        |item| item.span().lo(),\n+        |item| item.span().hi(),\n         |item| item.rewrite(context, shape),\n         context.codemap.span_after(span, \"(\"),\n-        span.hi - BytePos(1),\n+        span.hi() - BytePos(1),\n         false,\n     ).collect();\n "}, {"sha": "86a6e4d3d7261beefa68fa1fc3db407a661a3a34", "filename": "src/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -50,7 +50,7 @@ pub fn rewrite_path(\n         String::new()\n     };\n \n-    let mut span_lo = path.span.lo;\n+    let mut span_lo = path.span.lo();\n \n     if let Some(qself) = qself {\n         result.push('<');\n@@ -76,7 +76,7 @@ pub fn rewrite_path(\n                 result,\n                 path.segments.iter().take(skip_count),\n                 span_lo,\n-                path.span.hi,\n+                path.span.hi(),\n                 context,\n                 shape,\n             ));\n@@ -87,15 +87,15 @@ pub fn rewrite_path(\n         }\n \n         result.push_str(\">::\");\n-        span_lo = qself.ty.span.hi + BytePos(1);\n+        span_lo = qself.ty.span.hi() + BytePos(1);\n     }\n \n     rewrite_path_segments(\n         path_context,\n         result,\n         path.segments.iter().skip(skip_count),\n         span_lo,\n-        path.span.hi,\n+        path.span.hi(),\n         context,\n         shape,\n     )\n@@ -218,7 +218,7 @@ fn rewrite_segment(\n                     .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n                     .collect::<Vec<_>>();\n \n-                let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n+                let next_span_lo = param_list.last().unwrap().get_span().hi() + BytePos(1);\n                 let list_lo = context.codemap.span_after(mk_sp(*span_lo, span_hi), \"<\");\n                 let separator = if path_context == PathContext::Expr {\n                     \"::\"\n@@ -236,8 +236,8 @@ fn rewrite_segment(\n                     context.codemap,\n                     param_list.into_iter(),\n                     \">\",\n-                    |param| param.get_span().lo,\n-                    |param| param.get_span().hi,\n+                    |param| param.get_span().lo(),\n+                    |param| param.get_span().hi(),\n                     |seg| seg.rewrite(context, generics_shape),\n                     list_lo,\n                     span_hi,\n@@ -332,19 +332,19 @@ where\n             .chain(variadic_arg),\n         \")\",\n         |arg| match *arg {\n-            ArgumentKind::Regular(ref ty) => ty.span().lo,\n+            ArgumentKind::Regular(ref ty) => ty.span().lo(),\n             ArgumentKind::Variadic(start) => start,\n         },\n         |arg| match *arg {\n-            ArgumentKind::Regular(ref ty) => ty.span().hi,\n+            ArgumentKind::Regular(ref ty) => ty.span().hi(),\n             ArgumentKind::Variadic(start) => start + BytePos(3),\n         },\n         |arg| match *arg {\n             ArgumentKind::Regular(ref ty) => ty.rewrite(context, list_shape),\n             ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n         },\n         list_lo,\n-        span.hi,\n+        span.hi(),\n         false,\n     );\n "}, {"sha": "f99e1958f8c9507af644dac85011a8a28a3acbbb", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -208,7 +208,7 @@ pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n             ast::RegionTyParamBound(ref lt) => lt.span,\n             ast::TraitTyParamBound(ref prt, _) => prt.span,\n         })\n-        .hi\n+        .hi()\n }\n \n #[inline]\n@@ -363,11 +363,7 @@ macro_rules! source {\n }\n \n pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span {\n-        lo,\n-        hi,\n-        ctxt: NO_EXPANSION,\n-    }\n+    Span::new(lo, hi, NO_EXPANSION)\n }\n \n // Return true if the given span does not intersect with file lines."}, {"sha": "600bdeaba3a0284fa11096ed8bdf23698bc5b1c5", "filename": "src/vertical.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -49,9 +49,9 @@ impl AlignedItem for ast::StructField {\n     fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n         let missing_span = if self.attrs.is_empty() {\n-            mk_sp(self.span.lo, self.span.lo)\n+            mk_sp(self.span.lo(), self.span.lo())\n         } else {\n-            mk_sp(self.attrs.last().unwrap().span.hi, self.span.lo)\n+            mk_sp(self.attrs.last().unwrap().span.hi(), self.span.lo())\n         };\n         rewrite_struct_field_prefix(context, self).and_then(|field_str| {\n             combine_strs_with_missing_comments(\n@@ -88,9 +88,9 @@ impl AlignedItem for ast::Field {\n         let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n         let name = &self.ident.node.to_string();\n         let missing_span = if self.attrs.is_empty() {\n-            mk_sp(self.span.lo, self.span.lo)\n+            mk_sp(self.span.lo(), self.span.lo())\n         } else {\n-            mk_sp(self.attrs.last().unwrap().span.hi, self.span.lo)\n+            mk_sp(self.attrs.last().unwrap().span.hi(), self.span.lo())\n         };\n         combine_strs_with_missing_comments(\n             context,\n@@ -127,15 +127,15 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n     let init = &fields[0..group_index + 1];\n     let rest = &fields[group_index + 1..];\n     let init_last_pos = if rest.is_empty() {\n-        span.hi\n+        span.hi()\n     } else {\n         // Decide whether the missing comments should stick to init or rest.\n-        let init_hi = init[init.len() - 1].get_span().hi;\n-        let rest_lo = rest[0].get_span().lo;\n+        let init_hi = init[init.len() - 1].get_span().hi();\n+        let rest_lo = rest[0].get_span().lo();\n         let missing_span = mk_sp(init_hi, rest_lo);\n         let missing_span = mk_sp(\n             context.codemap.span_after(missing_span, \",\"),\n-            missing_span.hi,\n+            missing_span.hi(),\n         );\n \n         let snippet = context.snippet(missing_span);\n@@ -158,10 +158,10 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n \n             init_hi + BytePos(offset as u32 + 2)\n         } else {\n-            missing_span.lo\n+            missing_span.lo()\n         }\n     };\n-    let init_span = mk_sp(span.lo, init_last_pos);\n+    let init_span = mk_sp(span.lo(), init_last_pos);\n     let one_line_width = if rest.is_empty() { one_line_width } else { 0 };\n     let result = try_opt!(rewrite_aligned_items_inner(\n         context,\n@@ -173,7 +173,7 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n     if rest.is_empty() {\n         Some(result + spaces)\n     } else {\n-        let rest_span = mk_sp(init_last_pos, span.hi);\n+        let rest_span = mk_sp(init_last_pos, span.hi());\n         let rest_str = try_opt!(rewrite_with_alignment(\n             rest,\n             context,\n@@ -239,11 +239,11 @@ fn rewrite_aligned_items_inner<T: AlignedItem>(\n         context.codemap,\n         fields.iter(),\n         \"}\",\n-        |field| field.get_span().lo,\n-        |field| field.get_span().hi,\n+        |field| field.get_span().lo(),\n+        |field| field.get_span().hi(),\n         |field| field.rewrite_aligned_item(context, item_shape, field_prefix_max_width),\n-        span.lo,\n-        span.hi,\n+        span.lo(),\n+        span.hi(),\n         false,\n     ).collect::<Vec<_>>();\n \n@@ -277,7 +277,7 @@ fn group_aligned_items<T: AlignedItem>(\n             return (\"\", index);\n         }\n         // See if there are comments or empty lines between fields.\n-        let span = mk_sp(fields[i].get_span().hi, fields[i + 1].get_span().lo);\n+        let span = mk_sp(fields[i].get_span().hi(), fields[i + 1].get_span().lo());\n         let snippet = context\n             .snippet(span)\n             .lines()"}, {"sha": "057bd0ee7eeae05df2590f13c36929345da6665c", "filename": "src/visitor.rs", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -65,8 +65,8 @@ impl<'a> FmtVisitor<'a> {\n     fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n         debug!(\n             \"visit_stmt: {:?} {:?}\",\n-            self.codemap.lookup_char_pos(stmt.span.lo),\n-            self.codemap.lookup_char_pos(stmt.span.hi)\n+            self.codemap.lookup_char_pos(stmt.span.lo()),\n+            self.codemap.lookup_char_pos(stmt.span.hi())\n         );\n \n         match stmt.node {\n@@ -93,16 +93,16 @@ impl<'a> FmtVisitor<'a> {\n                 } else {\n                     self.visit_mac(mac, None, MacroPosition::Statement);\n                 }\n-                self.format_missing(stmt.span.hi);\n+                self.format_missing(stmt.span.hi());\n             }\n         }\n     }\n \n     pub fn visit_block(&mut self, b: &ast::Block, inner_attrs: Option<&[ast::Attribute]>) {\n         debug!(\n             \"visit_block: {:?} {:?}\",\n-            self.codemap.lookup_char_pos(b.span.lo),\n-            self.codemap.lookup_char_pos(b.span.hi)\n+            self.codemap.lookup_char_pos(b.span.lo()),\n+            self.codemap.lookup_char_pos(b.span.hi())\n         );\n \n         // Check if this block has braces.\n@@ -118,7 +118,7 @@ impl<'a> FmtVisitor<'a> {\n             if let Some(first_stmt) = b.stmts.first() {\n                 let attr_lo = inner_attrs\n                     .and_then(|attrs| {\n-                        inner_attributes(attrs).first().map(|attr| attr.span.lo)\n+                        inner_attributes(attrs).first().map(|attr| attr.span.lo())\n                     })\n                     .or_else(|| {\n                         // Attributes for an item in a statement position\n@@ -130,17 +130,19 @@ impl<'a> FmtVisitor<'a> {\n                         }.and_then(|attr| {\n                             // Some stmts can have embedded attributes.\n                             // e.g. `match { #![attr] ... }`\n-                            let attr_lo = attr.span.lo;\n-                            if attr_lo < first_stmt.span.lo {\n+                            let attr_lo = attr.span.lo();\n+                            if attr_lo < first_stmt.span.lo() {\n                                 Some(attr_lo)\n                             } else {\n                                 None\n                             }\n                         })\n                     });\n \n-                let snippet =\n-                    self.snippet(mk_sp(self.last_pos, attr_lo.unwrap_or(first_stmt.span.lo)));\n+                let snippet = self.snippet(mk_sp(\n+                    self.last_pos,\n+                    attr_lo.unwrap_or(first_stmt.span.lo()),\n+                ));\n                 let len = CommentCodeSlices::new(&snippet).nth(0).and_then(\n                     |(kind, _, s)| if kind == CodeCharKind::Normal {\n                         s.rfind('\\n')\n@@ -175,8 +177,8 @@ impl<'a> FmtVisitor<'a> {\n         if self.config.remove_blank_lines_at_start_or_end_of_block() {\n             if let Some(stmt) = b.stmts.last() {\n                 let snippet = self.snippet(mk_sp(\n-                    stmt.span.hi,\n-                    source!(self, b.span).hi - brace_compensation,\n+                    stmt.span.hi(),\n+                    source!(self, b.span).hi() - brace_compensation,\n                 ));\n                 let len = CommentCodeSlices::new(&snippet)\n                     .last()\n@@ -203,12 +205,14 @@ impl<'a> FmtVisitor<'a> {\n         if unindent_comment {\n             self.block_indent = self.block_indent.block_unindent(self.config);\n         }\n-        self.format_missing_with_indent(source!(self, b.span).hi - brace_compensation - remove_len);\n+        self.format_missing_with_indent(\n+            source!(self, b.span).hi() - brace_compensation - remove_len,\n+        );\n         if unindent_comment {\n             self.block_indent = self.block_indent.block_indent(self.config);\n         }\n         self.close_block(unindent_comment);\n-        self.last_pos = source!(self, b.span).hi;\n+        self.last_pos = source!(self, b.span).hi();\n     }\n \n     // FIXME: this is a terrible hack to indent the comments between the last\n@@ -255,7 +259,7 @@ impl<'a> FmtVisitor<'a> {\n                     defaultness,\n                     abi,\n                     vis,\n-                    mk_sp(s.lo, b.span.lo),\n+                    mk_sp(s.lo(), b.span.lo()),\n                     &b,\n                 )\n             }\n@@ -271,27 +275,27 @@ impl<'a> FmtVisitor<'a> {\n                     defaultness,\n                     sig.abi,\n                     vis.unwrap_or(&ast::Visibility::Inherited),\n-                    mk_sp(s.lo, b.span.lo),\n+                    mk_sp(s.lo(), b.span.lo()),\n                     &b,\n                 )\n             }\n             visit::FnKind::Closure(_) => unreachable!(),\n         };\n \n         if let Some(fn_str) = rewrite {\n-            self.format_missing_with_indent(source!(self, s).lo);\n+            self.format_missing_with_indent(source!(self, s).lo());\n             self.buffer.push_str(&fn_str);\n             if let Some(c) = fn_str.chars().last() {\n                 if c == '}' {\n-                    self.last_pos = source!(self, block.span).hi;\n+                    self.last_pos = source!(self, block.span).hi();\n                     return;\n                 }\n             }\n         } else {\n-            self.format_missing(source!(self, block.span).lo);\n+            self.format_missing(source!(self, block.span).lo());\n         }\n \n-        self.last_pos = source!(self, block.span).lo;\n+        self.last_pos = source!(self, block.span).lo();\n         self.visit_block(block, inner_attrs)\n     }\n \n@@ -305,8 +309,8 @@ impl<'a> FmtVisitor<'a> {\n         let mut attrs = item.attrs.clone();\n         match item.node {\n             ast::ItemKind::Mod(ref m) => {\n-                let outer_file = self.codemap.lookup_char_pos(item.span.lo).file;\n-                let inner_file = self.codemap.lookup_char_pos(m.inner.lo).file;\n+                let outer_file = self.codemap.lookup_char_pos(item.span.lo()).file;\n+                let inner_file = self.codemap.lookup_char_pos(m.inner.lo()).file;\n                 if outer_file.name == inner_file.name {\n                     // Module is inline, in this case we treat modules like any\n                     // other item.\n@@ -323,7 +327,7 @@ impl<'a> FmtVisitor<'a> {\n                     let filterd_attrs = item.attrs\n                         .iter()\n                         .filter_map(|a| {\n-                            let attr_file = self.codemap.lookup_char_pos(a.span.lo).file;\n+                            let attr_file = self.codemap.lookup_char_pos(a.span.lo()).file;\n                             if attr_file.name == outer_file.name {\n                                 Some(a.clone())\n                             } else {\n@@ -352,24 +356,24 @@ impl<'a> FmtVisitor<'a> {\n                 let snippet = self.snippet(item.span);\n                 let where_span_end = snippet\n                     .find_uncommented(\"{\")\n-                    .map(|x| (BytePos(x as u32)) + source!(self, item.span).lo);\n+                    .map(|x| (BytePos(x as u32)) + source!(self, item.span).lo());\n                 if let Some(impl_str) =\n                     format_impl(&self.get_context(), item, self.block_indent, where_span_end)\n                 {\n                     self.buffer.push_str(&impl_str);\n-                    self.last_pos = source!(self, item.span).hi;\n+                    self.last_pos = source!(self, item.span).hi();\n                 }\n             }\n             ast::ItemKind::Trait(..) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(item.span.lo());\n                 if let Some(trait_str) = format_trait(&self.get_context(), item, self.block_indent)\n                 {\n                     self.buffer.push_str(&trait_str);\n-                    self.last_pos = source!(self, item.span).hi;\n+                    self.last_pos = source!(self, item.span).hi();\n                 }\n             }\n             ast::ItemKind::ExternCrate(_) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo());\n                 let new_str = self.snippet(item.span);\n                 if contains_comment(&new_str) {\n                     self.buffer.push_str(&new_str)\n@@ -379,7 +383,7 @@ impl<'a> FmtVisitor<'a> {\n                     self.buffer\n                         .push_str(&Regex::new(r\"\\s;\").unwrap().replace(no_whitespace, \";\"));\n                 }\n-                self.last_pos = source!(self, item.span).hi;\n+                self.last_pos = source!(self, item.span).hi();\n             }\n             ast::ItemKind::Struct(ref def, ref generics) => {\n                 let rewrite = {\n@@ -403,19 +407,19 @@ impl<'a> FmtVisitor<'a> {\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::ItemKind::Enum(ref def, ref generics) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo());\n                 self.visit_enum(item.ident, &item.vis, def, generics, item.span);\n-                self.last_pos = source!(self, item.span).hi;\n+                self.last_pos = source!(self, item.span).hi();\n             }\n             ast::ItemKind::Mod(ref module) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo());\n                 self.format_mod(module, &item.vis, item.span, item.ident, &attrs);\n             }\n             ast::ItemKind::Mac(ref mac) => {\n                 self.visit_mac(mac, Some(item.ident), MacroPosition::Item);\n             }\n             ast::ItemKind::ForeignMod(ref foreign_mod) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo());\n                 self.format_foreign_mod(foreign_mod, item.span);\n             }\n             ast::ItemKind::Static(ref ty, mutability, ref expr) => {\n@@ -619,10 +623,10 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     pub fn push_rewrite(&mut self, span: Span, rewrite: Option<String>) {\n-        self.format_missing_with_indent(source!(self, span).lo);\n+        self.format_missing_with_indent(source!(self, span).lo());\n         let result = rewrite.unwrap_or_else(|| self.snippet(span));\n         self.buffer.push_str(&result);\n-        self.last_pos = source!(self, span).hi;\n+        self.last_pos = source!(self, span).hi();\n     }\n \n     pub fn from_codemap(parse_session: &'a ParseSess, config: &'a Config) -> FmtVisitor<'a> {\n@@ -643,8 +647,8 @@ impl<'a> FmtVisitor<'a> {\n             Err(_) => {\n                 println!(\n                     \"Couldn't make snippet for span {:?}->{:?}\",\n-                    self.codemap.lookup_char_pos(span.lo),\n-                    self.codemap.lookup_char_pos(span.hi)\n+                    self.codemap.lookup_char_pos(span.lo()),\n+                    self.codemap.lookup_char_pos(span.hi())\n                 );\n                 \"\".to_owned()\n             }\n@@ -750,7 +754,7 @@ impl<'a> FmtVisitor<'a> {\n         // Decide whether this is an inline mod or an external mod.\n         let local_file_name = self.codemap.span_to_filename(s);\n         let inner_span = source!(self, m.inner);\n-        let is_internal = !(inner_span.lo.0 == 0 && inner_span.hi.0 == 0) &&\n+        let is_internal = !(inner_span.lo().0 == 0 && inner_span.hi().0 == 0) &&\n             local_file_name == self.codemap.span_to_filename(inner_span);\n \n         self.buffer.push_str(&*utils::format_visibility(vis));\n@@ -765,7 +769,8 @@ impl<'a> FmtVisitor<'a> {\n             }\n             // Hackery to account for the closing }.\n             let mod_lo = self.codemap.span_after(source!(self, s), \"{\");\n-            let body_snippet = self.snippet(mk_sp(mod_lo, source!(self, m.inner).hi - BytePos(1)));\n+            let body_snippet =\n+                self.snippet(mk_sp(mod_lo, source!(self, m.inner).hi() - BytePos(1)));\n             let body_snippet = body_snippet.trim();\n             if body_snippet.is_empty() {\n                 self.buffer.push_str(\"}\");\n@@ -774,13 +779,13 @@ impl<'a> FmtVisitor<'a> {\n                 self.block_indent = self.block_indent.block_indent(self.config);\n                 self.visit_attrs(attrs, ast::AttrStyle::Inner);\n                 self.walk_mod_items(m);\n-                self.format_missing_with_indent(source!(self, m.inner).hi - BytePos(1));\n+                self.format_missing_with_indent(source!(self, m.inner).hi() - BytePos(1));\n                 self.close_block(false);\n             }\n-            self.last_pos = source!(self, m.inner).hi;\n+            self.last_pos = source!(self, m.inner).hi();\n         } else {\n             self.buffer.push_str(\";\");\n-            self.last_pos = source!(self, s).hi;\n+            self.last_pos = source!(self, s).hi();\n         }\n     }\n \n@@ -828,11 +833,11 @@ impl Rewrite for ast::MetaItem {\n                     context.codemap,\n                     list.iter(),\n                     \")\",\n-                    |nested_meta_item| nested_meta_item.span.lo,\n-                    |nested_meta_item| nested_meta_item.span.hi,\n+                    |nested_meta_item| nested_meta_item.span.lo(),\n+                    |nested_meta_item| nested_meta_item.span.hi(),\n                     |nested_meta_item| nested_meta_item.rewrite(context, item_shape),\n-                    self.span.lo,\n-                    self.span.hi,\n+                    self.span.lo(),\n+                    self.span.hi(),\n                     false,\n                 );\n                 let item_vec = items.collect::<Vec<_>>();\n@@ -909,7 +914,7 @@ impl<'a> Rewrite for [ast::Attribute] {\n \n             // Write comments and blank lines between attributes.\n             if i > 0 {\n-                let comment = context.snippet(mk_sp(self[i - 1].span.hi, a.span.lo));\n+                let comment = context.snippet(mk_sp(self[i - 1].span.hi(), a.span.lo()));\n                 // This particular horror show is to preserve line breaks in between doc\n                 // comments. An alternative would be to force such line breaks to start\n                 // with the usual doc comment token."}, {"sha": "684c811f582879e207a8523826ddcee90f706f1d", "filename": "tests/source/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -13,9 +13,9 @@ fn main() {\n \n     let loooooooooooooong_name = |field| {\n              // format comments.\n-             if field.node.attrs.len() > 0 { field.node.attrs[0].span.lo\n+             if field.node.attrs.len() > 0 { field.node.attrs[0].span.lo()\n              } else {\n-                 field.span.lo\n+                 field.span.lo()\n              }};\n \n     let unblock_me = |trivial| {\n@@ -85,7 +85,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n fn foo() {\n     lifetimes_iter___map(|lasdfasfd| {\n         let hi = if l.bounds.is_empty() {\n-            l.lifetime.span.hi\n+            l.lifetime.span.hi()\n         };\n     });\n }"}, {"sha": "18706783fb463fed8259cce4b16ea88a8ecabd8f", "filename": "tests/source/expr-block.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Fsource%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Fsource%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr-block.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -83,32 +83,32 @@ fn function_calls() {\n     let items = itemize_list(context.codemap,\n                              args.iter(),\n                              \")\",\n-                             |item| item.span.lo,\n-                             |item| item.span.hi,\n+                             |item| item.span.lo(),\n+                             |item| item.span.hi(),\n                              |item| {\n                                  item.rewrite(context,\n                                               Shape {\n                                                   width: remaining_width,\n                                                   ..nested_shape\n                                               })\n                              },\n-                             span.lo,\n-                             span.hi);\n+                             span.lo(),\n+                             span.hi());\n \n     itemize_list(context.codemap,\n                              args.iter(),\n                              \")\",\n-                             |item| item.span.lo,\n-                             |item| item.span.hi,\n+                             |item| item.span.lo(),\n+                             |item| item.span.hi(),\n                              |item| {\n                                  item.rewrite(context,\n                                               Shape {\n                                                   width: remaining_width,\n                                                   ..nested_shape\n                                               })\n                              },\n-                             span.lo,\n-                             span.hi)\n+                             span.lo(),\n+                             span.hi())\n }\n \n fn macros() {"}, {"sha": "1aa72baf1329f83837db6e6067e90f9f90e0c448", "filename": "tests/target/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -24,9 +24,9 @@ fn main() {\n     let loooooooooooooong_name = |field| {\n         // format comments.\n         if field.node.attrs.len() > 0 {\n-            field.node.attrs[0].span.lo\n+            field.node.attrs[0].span.lo()\n         } else {\n-            field.span.lo\n+            field.span.lo()\n         }\n     };\n \n@@ -106,7 +106,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n fn foo() {\n     lifetimes_iter___map(|lasdfasfd| {\n         let hi = if l.bounds.is_empty() {\n-            l.lifetime.span.hi\n+            l.lifetime.span.hi()\n         };\n     });\n }"}, {"sha": "7285898436fdeea6033f97a1426a2fb686ea3e21", "filename": "tests/target/expr-block.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Ftarget%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Ftarget%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-block.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -112,8 +112,8 @@ fn function_calls() {\n         context.codemap,\n         args.iter(),\n         \")\",\n-        |item| item.span.lo,\n-        |item| item.span.hi,\n+        |item| item.span.lo(),\n+        |item| item.span.hi(),\n         |item| {\n             item.rewrite(\n                 context,\n@@ -123,16 +123,16 @@ fn function_calls() {\n                 },\n             )\n         },\n-        span.lo,\n-        span.hi,\n+        span.lo(),\n+        span.hi(),\n     );\n \n     itemize_list(\n         context.codemap,\n         args.iter(),\n         \")\",\n-        |item| item.span.lo,\n-        |item| item.span.hi,\n+        |item| item.span.lo(),\n+        |item| item.span.hi(),\n         |item| {\n             item.rewrite(\n                 context,\n@@ -142,8 +142,8 @@ fn function_calls() {\n                 },\n             )\n         },\n-        span.lo,\n-        span.hi,\n+        span.lo(),\n+        span.hi(),\n     )\n }\n "}, {"sha": "95b9bc2dea20db82b5439507152cea45a4a6802b", "filename": "tests/target/nested-visual-block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Ftarget%2Fnested-visual-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5c6f5ba3f0da31a40066fe6c40ab22a4453839/tests%2Ftarget%2Fnested-visual-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnested-visual-block.rs?ref=6e5c6f5ba3f0da31a40066fe6c40ab22a4453839", "patch": "@@ -5,17 +5,17 @@ fn main() {\n         field_iter,\n         \"}\",\n         |item| match *item {\n-            StructLitField::Regular(ref field) => field.span.lo,\n+            StructLitField::Regular(ref field) => field.span.lo(),\n             StructLitField::Base(ref expr) => {\n-                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n-                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                let last_field_hi = fields.last().map_or(span.lo(), |field| field.span.hi());\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo()));\n                 let pos = snippet.find_uncommented(\"..\").unwrap();\n                 last_field_hi + BytePos(pos as u32)\n             }\n         },\n         |item| match *item {\n-            StructLitField::Regular(ref field) => field.span.hi,\n-            StructLitField::Base(ref expr) => expr.span.hi,\n+            StructLitField::Regular(ref field) => field.span.hi(),\n+            StructLitField::Base(ref expr) => expr.span.hi(),\n         },\n         |item| {\n             match *item {\n@@ -34,7 +34,7 @@ fn main() {\n             }\n         },\n         context.codemap.span_after(span, \"{\"),\n-        span.hi,\n+        span.hi(),\n     );\n \n     // #1580"}]}