{"sha": "4ccf5f731bb71db3470002d6baf5ab4792b821d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjY2Y1ZjczMWJiNzFkYjM0NzAwMDJkNmJhZjVhYjQ3OTJiODIxZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T18:24:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T18:24:02Z"}, "message": "Auto merge of #77430 - ecstatic-morse:mir-source-in-body, r=lcnr\n\nStore a `MirSource` inside every `Body`\n\nResolves #77427.\n\nr? `@ghost`", "tree": {"sha": "2a066b9fad8ec915bb91d565e61d9cfe8c72a354", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a066b9fad8ec915bb91d565e61d9cfe8c72a354"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ccf5f731bb71db3470002d6baf5ab4792b821d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ccf5f731bb71db3470002d6baf5ab4792b821d9", "html_url": "https://github.com/rust-lang/rust/commit/4ccf5f731bb71db3470002d6baf5ab4792b821d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ccf5f731bb71db3470002d6baf5ab4792b821d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "html_url": "https://github.com/rust-lang/rust/commit/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b"}, {"sha": "606655edc431d5f0069543a5d523c8bc67b918cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/606655edc431d5f0069543a5d523c8bc67b918cf", "html_url": "https://github.com/rust-lang/rust/commit/606655edc431d5f0069543a5d523c8bc67b918cf"}], "stats": {"total": 707, "additions": 327, "deletions": 380}, "files": [{"sha": "2f306809f1fd658295824affdfd8ee46e469240e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -10,12 +10,11 @@ use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n-use crate::ty::{\n-    self, AdtDef, CanonicalUserTypeAnnotations, List, Region, Ty, TyCtxt, UserTypeAnnotationIndex,\n-};\n+use crate::ty::{self, List, Ty, TyCtxt};\n+use crate::ty::{AdtDef, InstanceDef, Region, UserTypeAnnotationIndex};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Namespace};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::{self, GeneratorKind};\n use rustc_target::abi::VariantIdx;\n \n@@ -112,6 +111,38 @@ impl MirPhase {\n     }\n }\n \n+/// Where a specific `mir::Body` comes from.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n+pub struct MirSource<'tcx> {\n+    pub instance: InstanceDef<'tcx>,\n+\n+    /// If `Some`, this is a promoted rvalue within the parent function.\n+    pub promoted: Option<Promoted>,\n+}\n+\n+impl<'tcx> MirSource<'tcx> {\n+    pub fn item(def_id: DefId) -> Self {\n+        MirSource {\n+            instance: InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n+            promoted: None,\n+        }\n+    }\n+\n+    pub fn from_instance(instance: InstanceDef<'tcx>) -> Self {\n+        MirSource { instance, promoted: None }\n+    }\n+\n+    pub fn with_opt_param(self) -> ty::WithOptConstParam<DefId> {\n+        self.instance.with_opt_param()\n+    }\n+\n+    #[inline]\n+    pub fn def_id(&self) -> DefId {\n+        self.instance.def_id()\n+    }\n+}\n+\n /// The lowered representation of a single function.\n #[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable)]\n pub struct Body<'tcx> {\n@@ -126,6 +157,8 @@ pub struct Body<'tcx> {\n     /// us to see the difference and forego optimization on the inlined promoted items.\n     pub phase: MirPhase,\n \n+    pub source: MirSource<'tcx>,\n+\n     /// A list of source scopes; these are referenced by statements\n     /// and used for debuginfo. Indexed by a `SourceScope`.\n     pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n@@ -151,7 +184,7 @@ pub struct Body<'tcx> {\n     pub local_decls: LocalDecls<'tcx>,\n \n     /// User type annotations.\n-    pub user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n+    pub user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n \n     /// The number of arguments this function takes.\n     ///\n@@ -209,10 +242,11 @@ pub struct Body<'tcx> {\n \n impl<'tcx> Body<'tcx> {\n     pub fn new(\n+        source: MirSource<'tcx>,\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData>,\n         local_decls: LocalDecls<'tcx>,\n-        user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n+        user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n         var_debug_info: Vec<VarDebugInfo<'tcx>>,\n         span: Span,\n@@ -228,6 +262,7 @@ impl<'tcx> Body<'tcx> {\n \n         let mut body = Body {\n             phase: MirPhase::Build,\n+            source,\n             basic_blocks,\n             source_scopes,\n             yield_ty: None,\n@@ -257,6 +292,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n         let mut body = Body {\n             phase: MirPhase::Build,\n+            source: MirSource::item(DefId::local(CRATE_DEF_INDEX)),\n             basic_blocks,\n             source_scopes: IndexVec::new(),\n             yield_ty: None,"}, {"sha": "9bb1c0ed7ded50dad2a0b41626bb30abff5c0704", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -22,7 +22,8 @@ pub struct Instance<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum InstanceDef<'tcx> {\n     /// A user-defined callable item.\n     ///"}, {"sha": "37e2730025d11c8fe2d9b38b4a97a8075ff31912", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, InstanceDef, ParamEnv, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n \n@@ -36,7 +36,6 @@ use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathInd\n use crate::dataflow::move_paths::{InitLocation, LookupResult, MoveData, MoveError};\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{Analysis, BorrowckFlowState as Flows, BorrowckResults};\n-use crate::transform::MirSource;\n \n use self::diagnostics::{AccessKind, RegionName};\n use self::location::LocationTable;\n@@ -236,13 +235,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n-    nll::dump_mir_results(\n-        infcx,\n-        MirSource { instance: InstanceDef::Item(def.to_global()), promoted: None },\n-        &body,\n-        &regioncx,\n-        &opt_closure_req,\n-    );\n+    nll::dump_mir_results(infcx, &body, &regioncx, &opt_closure_req);\n \n     // We also have a `#[rustc_regions]` annotation that causes us to dump\n     // information."}, {"sha": "44125885f2a12123e196c32667973bcb360542ee", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, InstanceDef, RegionKind, RegionVid};\n+use rustc_middle::ty::{self, RegionKind, RegionVid};\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;\n@@ -24,7 +24,6 @@ use polonius_engine::{Algorithm, Output};\n use crate::dataflow::impls::MaybeInitializedPlaces;\n use crate::dataflow::move_paths::{InitKind, InitLocation, MoveData};\n use crate::dataflow::ResultsCursor;\n-use crate::transform::MirSource;\n use crate::util as mir_util;\n use crate::util::pretty;\n \n@@ -72,8 +71,7 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);\n \n-    let source = MirSource { instance: InstanceDef::Item(def.to_global()), promoted: None };\n-    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n+    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, body, |_, _| Ok(()));\n \n     universal_regions\n }\n@@ -315,16 +313,15 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n pub(super) fn dump_mir_results<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n-    source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n ) {\n-    if !mir_util::dump_enabled(infcx.tcx, \"nll\", source.def_id()) {\n+    if !mir_util::dump_enabled(infcx.tcx, \"nll\", body.source.def_id()) {\n         return;\n     }\n \n-    mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, source, body, |pass_where, out| {\n+    mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, body, |pass_where, out| {\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => {\n@@ -352,14 +349,14 @@ pub(super) fn dump_mir_results<'a, 'tcx>(\n     // Also dump the inference graph constraints as a graphviz file.\n     let _: io::Result<()> = try {\n         let mut file =\n-            pretty::create_dump_file(infcx.tcx, \"regioncx.all.dot\", None, \"nll\", &0, source)?;\n+            pretty::create_dump_file(infcx.tcx, \"regioncx.all.dot\", None, \"nll\", &0, body.source)?;\n         regioncx.dump_graphviz_raw_constraints(&mut file)?;\n     };\n \n     // Also dump the inference graph constraints as a graphviz file.\n     let _: io::Result<()> = try {\n         let mut file =\n-            pretty::create_dump_file(infcx.tcx, \"regioncx.scc.dot\", None, \"nll\", &0, source)?;\n+            pretty::create_dump_file(infcx.tcx, \"regioncx.scc.dot\", None, \"nll\", &0, body.source)?;\n         regioncx.dump_graphviz_scc_constraints(&mut file)?;\n     };\n }"}, {"sha": "5431d22e70320c7a66306bb5973c257c7ad8c1d7", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -78,8 +78,6 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n     run_passes(\n         tcx,\n         &mut result,\n-        instance,\n-        None,\n         MirPhase::Const,\n         &[&[\n             &add_moves_for_packed_drops::AddMovesForPackedDrops,\n@@ -163,7 +161,9 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     block(&mut blocks, TerminatorKind::Goto { target: return_block });\n     block(&mut blocks, TerminatorKind::Return);\n \n-    let mut body = new_body(blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n+    let source = MirSource::from_instance(ty::InstanceDef::DropGlue(def_id, ty));\n+    let mut body =\n+        new_body(source, blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n \n     if let Some(..) = ty {\n         // The first argument (index 0), but add 1 for the return value.\n@@ -202,12 +202,14 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n }\n \n fn new_body<'tcx>(\n+    source: MirSource<'tcx>,\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     arg_count: usize,\n     span: Span,\n ) -> Body<'tcx> {\n     Body::new(\n+        source,\n         basic_blocks,\n         IndexVec::from_elem_n(\n             SourceScopeData { span, parent_scope: None, local_data: ClearCrossCrate::Clear },\n@@ -344,7 +346,11 @@ impl CloneShimBuilder<'tcx> {\n     }\n \n     fn into_mir(self) -> Body<'tcx> {\n-        new_body(self.blocks, self.local_decls, self.sig.inputs().len(), self.span)\n+        let source = MirSource::from_instance(ty::InstanceDef::CloneShim(\n+            self.def_id,\n+            self.sig.inputs_and_output[0],\n+        ));\n+        new_body(source, self.blocks, self.local_decls, self.sig.inputs().len(), self.span)\n     }\n \n     fn source_info(&self) -> SourceInfo {\n@@ -834,7 +840,8 @@ fn build_call_shim<'tcx>(\n         block(&mut blocks, vec![], TerminatorKind::Resume, true);\n     }\n \n-    let mut body = new_body(blocks, local_decls, sig.inputs().len(), span);\n+    let mut body =\n+        new_body(MirSource::from_instance(instance), blocks, local_decls, sig.inputs().len(), span);\n \n     if let Abi::RustCall = sig.abi {\n         body.spread_arg = Some(Local::new(sig.inputs().len()));\n@@ -897,18 +904,16 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n         is_cleanup: false,\n     };\n \n-    let body =\n-        new_body(IndexVec::from_elem_n(start_block, 1), local_decls, sig.inputs().len(), span);\n-\n-    crate::util::dump_mir(\n-        tcx,\n-        None,\n-        \"mir_map\",\n-        &0,\n-        crate::transform::MirSource::item(ctor_id),\n-        &body,\n-        |_, _| Ok(()),\n+    let source = MirSource::item(ctor_id);\n+    let body = new_body(\n+        source,\n+        IndexVec::from_elem_n(start_block, 1),\n+        local_decls,\n+        sig.inputs().len(),\n+        span,\n     );\n \n+    crate::util::dump_mir(tcx, None, \"mir_map\", &0, &body, |_, _| Ok(()));\n+\n     body\n }"}, {"sha": "1dddaeb89e684cfb1b331fb51c7bb2ff0babf404", "filename": "compiler/rustc_mir/src/transform/add_call_guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_call_guards.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,4 +1,4 @@\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n@@ -31,7 +31,7 @@ pub use self::AddCallGuards::*;\n  */\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         self.add_call_guards(body);\n     }\n }"}, {"sha": "977bc853100794191c3db1d6235c4b10a4d8c879", "filename": "compiler/rustc_mir/src/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util;\n use crate::util::patch::MirPatch;\n \n@@ -40,9 +40,9 @@ use crate::util::patch::MirPatch;\n pub struct AddMovesForPackedDrops;\n \n impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n-        add_moves_for_packed_drops(tcx, body, src.def_id());\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", body.source, body.span);\n+        add_moves_for_packed_drops(tcx, body, body.source.def_id());\n     }\n }\n "}, {"sha": "eec704e6cb775224a5eb38970470f8ec2299487d", "filename": "compiler/rustc_mir/src/transform/add_retag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -4,7 +4,7 @@\n //! of MIR building, and only after this pass we think of the program has having the\n //! normal MIR semantics.\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -58,13 +58,13 @@ fn may_be_reference(ty: Ty<'tcx>) -> bool {\n }\n \n impl<'tcx> MirPass<'tcx> for AddRetag {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }\n \n         // We need an `AllCallEdges` pass before we can do any work.\n-        super::add_call_guards::AllCallEdges.run_pass(tcx, src, body);\n+        super::add_call_guards::AllCallEdges.run_pass(tcx, body);\n \n         let (span, arg_count) = (body.span, body.arg_count);\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();"}, {"sha": "4d4e9b989171a75001196db61d84daa422a283c0", "filename": "compiler/rustc_mir/src/transform/check_const_item_mutation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -6,12 +6,12 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::CONST_ITEM_MUTATION;\n use rustc_span::def_id::DefId;\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n \n pub struct CheckConstItemMutation;\n \n impl<'tcx> MirPass<'tcx> for CheckConstItemMutation {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let mut checker = ConstMutationChecker { body, tcx, target_local: None };\n         checker.visit_body(&body);\n     }"}, {"sha": "ee88daa83e783b4891a942e5140383d837e9442a", "filename": "compiler/rustc_mir/src/transform/check_packed_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -3,14 +3,14 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::UNALIGNED_REFERENCES;\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util;\n \n pub struct CheckPackedRef;\n \n impl<'tcx> MirPass<'tcx> for CheckPackedRef {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let param_env = tcx.param_env(src.instance.def_id());\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let param_env = tcx.param_env(body.source.def_id());\n         let source_info = SourceInfo::outermost(body.span);\n         let mut checker = PackedRefChecker { body, tcx, param_env, source_info };\n         checker.visit_body(&body);"}, {"sha": "8ff0fae76861819f95afc55728eb7c98f7e71ea4", "filename": "compiler/rustc_mir/src/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcleanup_post_borrowck.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -18,7 +18,7 @@\n //! [`ForMatchGuard`]: rustc_middle::mir::FakeReadCause::ForMatchGuard\n //! [`Nop`]: rustc_middle::mir::StatementKind::Nop\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_middle::mir::visit::MutVisitor;\n use rustc_middle::mir::{Body, BorrowKind, Location, Rvalue};\n use rustc_middle::mir::{Statement, StatementKind};\n@@ -31,7 +31,7 @@ pub struct DeleteNonCodegenStatements<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements { tcx };\n         delete.visit_body(body);\n         body.user_type_annotations.raw.clear();"}, {"sha": "14b310cda939eae7380962d76aabaebcb80cabd0", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -32,7 +32,7 @@ use crate::interpret::{\n     InterpCx, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand,\n     PlaceTy, Pointer, ScalarMaybeUninit, StackPopCleanup,\n };\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n /// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n@@ -60,30 +60,31 @@ macro_rules! throw_machine_stop_str {\n pub struct ConstProp;\n \n impl<'tcx> MirPass<'tcx> for ConstProp {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n-        if source.promoted.is_some() {\n+        if body.source.promoted.is_some() {\n             return;\n         }\n \n         use rustc_middle::hir::map::blocks::FnLikeNode;\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(source.def_id().expect_local());\n+        let def_id = body.source.def_id().expect_local();\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n-        let is_assoc_const = tcx.def_kind(source.def_id()) == DefKind::AssocConst;\n+        let is_assoc_const = tcx.def_kind(def_id.to_def_id()) == DefKind::AssocConst;\n \n         // Only run const prop on functions, methods, closures and associated constants\n         if !is_fn_like && !is_assoc_const {\n             // skip anon_const/statics/consts because they'll be evaluated by miri anyway\n-            trace!(\"ConstProp skipped for {:?}\", source.def_id());\n+            trace!(\"ConstProp skipped for {:?}\", def_id);\n             return;\n         }\n \n-        let is_generator = tcx.type_of(source.def_id()).is_generator();\n+        let is_generator = tcx.type_of(def_id.to_def_id()).is_generator();\n         // FIXME(welseywiser) const prop doesn't work on generators because of query cycles\n         // computing their layout.\n         if is_generator {\n-            trace!(\"ConstProp skipped for generator {:?}\", source.def_id());\n+            trace!(\"ConstProp skipped for generator {:?}\", def_id);\n             return;\n         }\n \n@@ -114,39 +115,40 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         // the normalization code (leading to cycle errors), since\n         // it's usually never invoked in this way.\n         let predicates = tcx\n-            .predicates_of(source.def_id())\n+            .predicates_of(def_id.to_def_id())\n             .predicates\n             .iter()\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n             traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n         ) {\n-            trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", source.def_id());\n+            trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n         }\n \n-        trace!(\"ConstProp starting for {:?}\", source.def_id());\n+        trace!(\"ConstProp starting for {:?}\", def_id);\n \n         let dummy_body = &Body::new(\n+            body.source,\n             body.basic_blocks().clone(),\n             body.source_scopes.clone(),\n             body.local_decls.clone(),\n             Default::default(),\n             body.arg_count,\n             Default::default(),\n-            tcx.def_span(source.def_id()),\n+            tcx.def_span(def_id),\n             body.generator_kind,\n         );\n \n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n         // constants, instead of just checking for const-folding succeeding.\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n-        let mut optimization_finder = ConstPropagator::new(body, dummy_body, tcx, source);\n+        let mut optimization_finder = ConstPropagator::new(body, dummy_body, tcx);\n         optimization_finder.visit_body(body);\n \n-        trace!(\"ConstProp done for {:?}\", source.def_id());\n+        trace!(\"ConstProp done for {:?}\", def_id);\n     }\n }\n \n@@ -346,9 +348,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         body: &Body<'tcx>,\n         dummy_body: &'mir Body<'tcx>,\n         tcx: TyCtxt<'tcx>,\n-        source: MirSource<'tcx>,\n     ) -> ConstPropagator<'mir, 'tcx> {\n-        let def_id = source.def_id();\n+        let def_id = body.source.def_id();\n         let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n "}, {"sha": "4f44bb7b20476f9a49e947da21e69f6371e08eb8", "filename": "compiler/rustc_mir/src/transform/copy_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcopy_prop.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -19,7 +19,7 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util::def_use::DefUseAnalysis;\n use rustc_middle::mir::visit::MutVisitor;\n use rustc_middle::mir::{\n@@ -30,7 +30,7 @@ use rustc_middle::ty::TyCtxt;\n pub struct CopyPropagation;\n \n impl<'tcx> MirPass<'tcx> for CopyPropagation {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let opts = &tcx.sess.opts.debugging_opts;\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info."}, {"sha": "5bd7256c666c619f0d9f6c092ce87a26320214ba", "filename": "compiler/rustc_mir/src/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeaggregator.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,12 +1,12 @@\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util::expand_aggregate;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n pub struct Deaggregator;\n \n impl<'tcx> MirPass<'tcx> for Deaggregator {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "0982bcfb0ca5ba81d58c5df929d2e33def69611a", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 46, "deletions": 56, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -99,7 +99,7 @@\n use crate::dataflow::impls::{MaybeInitializedLocals, MaybeLiveLocals};\n use crate::dataflow::Analysis;\n use crate::{\n-    transform::{MirPass, MirSource},\n+    transform::MirPass,\n     util::{dump_mir, PassWhere},\n };\n use itertools::Itertools;\n@@ -126,16 +126,18 @@ const MAX_BLOCKS: usize = 250;\n pub struct DestinationPropagation;\n \n impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // Only run at mir-opt-level=2 or higher for now (we don't fix up debuginfo and remove\n         // storage statements at the moment).\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n             return;\n         }\n \n+        let def_id = body.source.def_id();\n+\n         let candidates = find_candidates(tcx, body);\n         if candidates.is_empty() {\n-            debug!(\"{:?}: no dest prop candidates, done\", source.def_id());\n+            debug!(\"{:?}: no dest prop candidates, done\", def_id);\n             return;\n         }\n \n@@ -152,31 +154,29 @@ impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n         let relevant = relevant_locals.count();\n         debug!(\n             \"{:?}: {} locals ({} relevant), {} blocks\",\n-            source.def_id(),\n+            def_id,\n             body.local_decls.len(),\n             relevant,\n             body.basic_blocks().len()\n         );\n         if relevant > MAX_LOCALS {\n             warn!(\n                 \"too many candidate locals in {:?} ({}, max is {}), not optimizing\",\n-                source.def_id(),\n-                relevant,\n-                MAX_LOCALS\n+                def_id, relevant, MAX_LOCALS\n             );\n             return;\n         }\n         if body.basic_blocks().len() > MAX_BLOCKS {\n             warn!(\n                 \"too many blocks in {:?} ({}, max is {}), not optimizing\",\n-                source.def_id(),\n+                def_id,\n                 body.basic_blocks().len(),\n                 MAX_BLOCKS\n             );\n             return;\n         }\n \n-        let mut conflicts = Conflicts::build(tcx, body, source, &relevant_locals);\n+        let mut conflicts = Conflicts::build(tcx, body, &relevant_locals);\n \n         let mut replacements = Replacements::new(body.local_decls.len());\n         for candidate @ CandidateAssignment { dest, src, loc } in candidates {\n@@ -192,7 +192,7 @@ impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n             }\n \n             if !tcx.consider_optimizing(|| {\n-                format!(\"DestinationPropagation {:?} {:?}\", source.def_id(), candidate)\n+                format!(\"DestinationPropagation {:?} {:?}\", def_id, candidate)\n             }) {\n                 break;\n             }\n@@ -398,7 +398,6 @@ impl Conflicts<'a> {\n     fn build<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &'_ Body<'tcx>,\n-        source: MirSource<'tcx>,\n         relevant_locals: &'a BitSet<Local>,\n     ) -> Self {\n         // We don't have to look out for locals that have their address taken, since\n@@ -409,7 +408,7 @@ impl Conflicts<'a> {\n             body.local_decls.len(),\n         );\n \n-        let def_id = source.def_id();\n+        let def_id = body.source.def_id();\n         let mut init = MaybeInitializedLocals\n             .into_engine(tcx, body, def_id)\n             .iterate_to_fixpoint()\n@@ -420,58 +419,49 @@ impl Conflicts<'a> {\n             .into_results_cursor(body);\n \n         let mut reachable = None;\n-        dump_mir(\n-            tcx,\n-            None,\n-            \"DestinationPropagation-dataflow\",\n-            &\"\",\n-            source,\n-            body,\n-            |pass_where, w| {\n-                let reachable =\n-                    reachable.get_or_insert_with(|| traversal::reachable_as_bitset(body));\n-\n-                match pass_where {\n-                    PassWhere::BeforeLocation(loc) if reachable.contains(loc.block) => {\n-                        init.seek_before_primary_effect(loc);\n-                        live.seek_after_primary_effect(loc);\n-\n-                        writeln!(w, \"        // init: {:?}\", init.get())?;\n-                        writeln!(w, \"        // live: {:?}\", live.get())?;\n-                    }\n-                    PassWhere::AfterTerminator(bb) if reachable.contains(bb) => {\n-                        let loc = body.terminator_loc(bb);\n-                        init.seek_after_primary_effect(loc);\n-                        live.seek_before_primary_effect(loc);\n+        dump_mir(tcx, None, \"DestinationPropagation-dataflow\", &\"\", body, |pass_where, w| {\n+            let reachable = reachable.get_or_insert_with(|| traversal::reachable_as_bitset(body));\n \n-                        writeln!(w, \"        // init: {:?}\", init.get())?;\n-                        writeln!(w, \"        // live: {:?}\", live.get())?;\n-                    }\n+            match pass_where {\n+                PassWhere::BeforeLocation(loc) if reachable.contains(loc.block) => {\n+                    init.seek_before_primary_effect(loc);\n+                    live.seek_after_primary_effect(loc);\n \n-                    PassWhere::BeforeBlock(bb) if reachable.contains(bb) => {\n-                        init.seek_to_block_start(bb);\n-                        live.seek_to_block_start(bb);\n+                    writeln!(w, \"        // init: {:?}\", init.get())?;\n+                    writeln!(w, \"        // live: {:?}\", live.get())?;\n+                }\n+                PassWhere::AfterTerminator(bb) if reachable.contains(bb) => {\n+                    let loc = body.terminator_loc(bb);\n+                    init.seek_after_primary_effect(loc);\n+                    live.seek_before_primary_effect(loc);\n \n-                        writeln!(w, \"    // init: {:?}\", init.get())?;\n-                        writeln!(w, \"    // live: {:?}\", live.get())?;\n-                    }\n+                    writeln!(w, \"        // init: {:?}\", init.get())?;\n+                    writeln!(w, \"        // live: {:?}\", live.get())?;\n+                }\n \n-                    PassWhere::BeforeCFG | PassWhere::AfterCFG | PassWhere::AfterLocation(_) => {}\n+                PassWhere::BeforeBlock(bb) if reachable.contains(bb) => {\n+                    init.seek_to_block_start(bb);\n+                    live.seek_to_block_start(bb);\n \n-                    PassWhere::BeforeLocation(_) | PassWhere::AfterTerminator(_) => {\n-                        writeln!(w, \"        // init: <unreachable>\")?;\n-                        writeln!(w, \"        // live: <unreachable>\")?;\n-                    }\n+                    writeln!(w, \"    // init: {:?}\", init.get())?;\n+                    writeln!(w, \"    // live: {:?}\", live.get())?;\n+                }\n \n-                    PassWhere::BeforeBlock(_) => {\n-                        writeln!(w, \"    // init: <unreachable>\")?;\n-                        writeln!(w, \"    // live: <unreachable>\")?;\n-                    }\n+                PassWhere::BeforeCFG | PassWhere::AfterCFG | PassWhere::AfterLocation(_) => {}\n+\n+                PassWhere::BeforeLocation(_) | PassWhere::AfterTerminator(_) => {\n+                    writeln!(w, \"        // init: <unreachable>\")?;\n+                    writeln!(w, \"        // live: <unreachable>\")?;\n                 }\n \n-                Ok(())\n-            },\n-        );\n+                PassWhere::BeforeBlock(_) => {\n+                    writeln!(w, \"    // init: <unreachable>\")?;\n+                    writeln!(w, \"    // live: <unreachable>\")?;\n+                }\n+            }\n+\n+            Ok(())\n+        });\n \n         let mut this = Self {\n             relevant_locals,"}, {"sha": "5b6edf17d06abef747f2f76317ab2b2db7c4ead1", "filename": "compiler/rustc_mir/src/transform/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdump_mir.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use std::fs::File;\n use std::io;\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util as mir_util;\n use rustc_middle::mir::Body;\n use rustc_middle::ty::TyCtxt;\n@@ -18,7 +18,7 @@ impl<'tcx> MirPass<'tcx> for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut Body<'tcx>) {}\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _body: &mut Body<'tcx>) {}\n }\n \n pub struct Disambiguator {\n@@ -36,17 +36,15 @@ pub fn on_mir_pass<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     pass_num: &dyn fmt::Display,\n     pass_name: &str,\n-    source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     is_after: bool,\n ) {\n-    if mir_util::dump_enabled(tcx, pass_name, source.def_id()) {\n+    if mir_util::dump_enabled(tcx, pass_name, body.source.def_id()) {\n         mir_util::dump_mir(\n             tcx,\n             Some(pass_num),\n             pass_name,\n             &Disambiguator { is_after },\n-            source,\n             body,\n             |_, _| Ok(()),\n         );"}, {"sha": "a45b0e86fffc2d9438991b28bb777de73f9776d5", "filename": "compiler/rustc_mir/src/transform/early_otherwise_branch.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,7 +1,4 @@\n-use crate::{\n-    transform::{MirPass, MirSource},\n-    util::patch::MirPatch,\n-};\n+use crate::{transform::MirPass, util::patch::MirPatch};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{Ty, TyCtxt};\n use std::{borrow::Cow, fmt::Debug};\n@@ -28,11 +25,11 @@ use super::simplify::simplify_cfg;\n pub struct EarlyOtherwiseBranch;\n \n impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level < 1 {\n             return;\n         }\n-        trace!(\"running EarlyOtherwiseBranch on {:?}\", source);\n+        trace!(\"running EarlyOtherwiseBranch on {:?}\", body.source);\n         // we are only interested in this bb if the terminator is a switchInt\n         let bbs_with_switch =\n             body.basic_blocks().iter_enumerated().filter(|(_, bb)| is_switch(bb.terminator()));"}, {"sha": "f59050f58385c34a73ce37b40091768d640e8e40", "filename": "compiler/rustc_mir/src/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -5,7 +5,7 @@ use crate::dataflow::on_lookup_result_bits;\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use crate::dataflow::{Analysis, ResultsCursor};\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util::elaborate_drops::{elaborate_drop, DropFlagState, Unwind};\n use crate::util::elaborate_drops::{DropElaborator, DropFlagMode, DropStyle};\n use crate::util::patch::MirPatch;\n@@ -21,11 +21,11 @@ use std::fmt;\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        debug!(\"elaborate_drops({:?} @ {:?})\", body.source, body.span);\n \n-        let def_id = src.def_id();\n-        let param_env = tcx.param_env_reveal_all_normalized(src.def_id());\n+        let def_id = body.source.def_id();\n+        let param_env = tcx.param_env_reveal_all_normalized(def_id);\n         let move_data = match MoveData::gather_moves(body, tcx, param_env) {\n             Ok(move_data) => move_data,\n             Err((move_data, _)) => {"}, {"sha": "7c3a0502decf5896f7a4d2209263c3fb48241409", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -55,7 +55,7 @@ use crate::dataflow::impls::{\n use crate::dataflow::{self, Analysis};\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util::dump_mir;\n use crate::util::expand_aggregate;\n use crate::util::storage;\n@@ -451,11 +451,10 @@ struct LivenessInfo {\n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    source: MirSource<'tcx>,\n     always_live_locals: &storage::AlwaysLiveLocals,\n     movable: bool,\n ) -> LivenessInfo {\n-    let def_id = source.def_id();\n+    let def_id = body.source.def_id();\n     let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n@@ -915,7 +914,6 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n fn create_generator_drop_shim<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     transform: &TransformVisitor<'tcx>,\n-    source: MirSource<'tcx>,\n     gen_ty: Ty<'tcx>,\n     body: &mut Body<'tcx>,\n     drop_clean: BasicBlock,\n@@ -968,7 +966,7 @@ fn create_generator_drop_shim<'tcx>(\n     // unrelated code from the resume part of the function\n     simplify::remove_dead_blocks(&mut body);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, source, &body, |_, _| Ok(()));\n+    dump_mir(tcx, None, \"generator_drop\", &0, &body, |_, _| Ok(()));\n \n     body\n }\n@@ -1070,7 +1068,6 @@ fn can_unwind<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> bool {\n fn create_generator_resume_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     transform: TransformVisitor<'tcx>,\n-    source: MirSource<'tcx>,\n     body: &mut Body<'tcx>,\n     can_return: bool,\n ) {\n@@ -1142,7 +1139,7 @@ fn create_generator_resume_function<'tcx>(\n     // unrelated code from the drop part of the function\n     simplify::remove_dead_blocks(body);\n \n-    dump_mir(tcx, None, \"generator_resume\", &0, source, body, |_, _| Ok(()));\n+    dump_mir(tcx, None, \"generator_resume\", &0, body, |_, _| Ok(()));\n }\n \n fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n@@ -1239,7 +1236,7 @@ fn create_cases<'tcx>(\n }\n \n impl<'tcx> MirPass<'tcx> for StateTransform {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {\n@@ -1249,7 +1246,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         assert!(body.generator_drop.is_none());\n \n-        let def_id = source.def_id();\n+        let def_id = body.source.def_id();\n \n         // The first argument is the generator type passed by value\n         let gen_ty = body.local_decls.raw[1].ty;\n@@ -1307,7 +1304,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let always_live_locals = storage::AlwaysLiveLocals::new(&body);\n \n         let liveness_info =\n-            locals_live_across_suspend_points(tcx, body, source, &always_live_locals, movable);\n+            locals_live_across_suspend_points(tcx, body, &always_live_locals, movable);\n \n         sanitize_witness(tcx, body, def_id, interior, &upvars, &liveness_info.saved_locals);\n \n@@ -1356,23 +1353,22 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         // This is expanded to a drop ladder in `elaborate_generator_drops`.\n         let drop_clean = insert_clean_drop(body);\n \n-        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, body, |_, _| Ok(()));\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, body, |_, _| Ok(()));\n \n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n         elaborate_generator_drops(tcx, def_id, body);\n \n-        dump_mir(tcx, None, \"generator_post-transform\", &0, source, body, |_, _| Ok(()));\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, body, |_, _| Ok(()));\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n-        let drop_shim =\n-            create_generator_drop_shim(tcx, &transform, source, gen_ty, body, drop_clean);\n+        let drop_shim = create_generator_drop_shim(tcx, &transform, gen_ty, body, drop_clean);\n \n         body.generator_drop = Some(box drop_shim);\n \n         // Create the Generator::resume function\n-        create_generator_resume_function(tcx, transform, source, body, can_return);\n+        create_generator_resume_function(tcx, transform, body, can_return);\n     }\n }\n "}, {"sha": "ced8a2289d577cee44add8176b2c6af539a25fcd", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{self, ConstKind, Instance, InstanceDef, ParamEnv, Ty, TyC\n use rustc_target::spec::abi::Abi;\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use std::collections::VecDeque;\n use std::iter;\n \n@@ -37,15 +37,15 @@ struct CallSite<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for Inline {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             if tcx.sess.opts.debugging_opts.instrument_coverage {\n                 // The current implementation of source code coverage injects code region counters\n                 // into the MIR, and assumes a 1-to-1 correspondence between MIR and source-code-\n                 // based function.\n                 debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n             } else {\n-                Inliner { tcx, source, codegen_fn_attrs: tcx.codegen_fn_attrs(source.def_id()) }\n+                Inliner { tcx, codegen_fn_attrs: tcx.codegen_fn_attrs(body.source.def_id()) }\n                     .run_pass(body);\n             }\n         }\n@@ -54,7 +54,6 @@ impl<'tcx> MirPass<'tcx> for Inline {\n \n struct Inliner<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    source: MirSource<'tcx>,\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n }\n \n@@ -74,11 +73,15 @@ impl Inliner<'tcx> {\n \n         let mut callsites = VecDeque::new();\n \n-        let param_env = self.tcx.param_env_reveal_all_normalized(self.source.def_id());\n+        let def_id = caller_body.source.def_id();\n+\n+        let param_env = self.tcx.param_env_reveal_all_normalized(def_id);\n \n         // Only do inlining into fn bodies.\n-        let id = self.tcx.hir().local_def_id_to_hir_id(self.source.def_id().expect_local());\n-        if self.tcx.hir().body_owner_kind(id).is_fn_or_closure() && self.source.promoted.is_none() {\n+        let self_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+        if self.tcx.hir().body_owner_kind(self_hir_id).is_fn_or_closure()\n+            && caller_body.source.promoted.is_none()\n+        {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) =\n                     self.get_valid_function_call(bb, bb_data, caller_body, param_env)\n@@ -104,8 +107,6 @@ impl Inliner<'tcx> {\n \n                 let callee_body = if let Some(callee_def_id) = callsite.callee.as_local() {\n                     let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n-                    let self_hir_id =\n-                        self.tcx.hir().local_def_id_to_hir_id(self.source.def_id().expect_local());\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n                     // a lower `HirId` than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation.\n@@ -178,7 +179,7 @@ impl Inliner<'tcx> {\n \n         // Simplify if we inlined anything.\n         if changed {\n-            debug!(\"running simplify cfg on {:?}\", self.source);\n+            debug!(\"running simplify cfg on {:?}\", caller_body.source);\n             CfgSimplifier::new(caller_body).simplify();\n             remove_dead_blocks(caller_body);\n         }\n@@ -300,7 +301,7 @@ impl Inliner<'tcx> {\n \n         // FIXME: Give a bonus to functions with only a single caller\n \n-        let param_env = tcx.param_env(self.source.def_id());\n+        let param_env = tcx.param_env(callee_body.source.def_id());\n \n         let mut first_block = true;\n         let mut cost = 0;\n@@ -430,7 +431,7 @@ impl Inliner<'tcx> {\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n-                debug!(\"inlined {:?} into {:?}\", callsite.callee, self.source);\n+                debug!(\"inlined {:?} into {:?}\", callsite.callee, caller_body.source);\n \n                 let mut local_map = IndexVec::with_capacity(callee_body.local_decls.len());\n                 let mut scope_map = IndexVec::with_capacity(callee_body.source_scopes.len());"}, {"sha": "1a8e281d417df374976b52d24e4e4b7903450afb", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,6 +1,6 @@\n //! Performs various peephole optimizations.\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n use rustc_index::vec::Idx;\n@@ -19,7 +19,7 @@ use std::mem;\n pub struct InstCombine;\n \n impl<'tcx> MirPass<'tcx> for InstCombine {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Place::ty()`)."}, {"sha": "388fb90651c5fe63ec7a9e08ccb790da9cb0bbef", "filename": "compiler/rustc_mir/src/transform/instrument_coverage.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,4 +1,4 @@\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util::pretty;\n use crate::util::spanview::{\n     source_range_no_file, statement_kind_name, terminator_kind_name, write_spanview_document,\n@@ -74,16 +74,11 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> CoverageInfo\n }\n \n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n-    fn run_pass(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        mir_source: MirSource<'tcx>,\n-        mir_body: &mut mir::Body<'tcx>,\n-    ) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n         // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n         // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n-        if mir_source.promoted.is_none() {\n-            Instrumentor::new(&self.name(), tcx, mir_source, mir_body).inject_counters();\n+        if mir_body.source.promoted.is_none() {\n+            Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n         }\n     }\n }\n@@ -97,7 +92,6 @@ struct CoverageRegion {\n struct Instrumentor<'a, 'tcx> {\n     pass_name: &'a str,\n     tcx: TyCtxt<'tcx>,\n-    mir_source: MirSource<'tcx>,\n     mir_body: &'a mut mir::Body<'tcx>,\n     hir_body: &'tcx rustc_hir::Body<'tcx>,\n     function_source_hash: Option<u64>,\n@@ -106,17 +100,11 @@ struct Instrumentor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n-    fn new(\n-        pass_name: &'a str,\n-        tcx: TyCtxt<'tcx>,\n-        mir_source: MirSource<'tcx>,\n-        mir_body: &'a mut mir::Body<'tcx>,\n-    ) -> Self {\n-        let hir_body = hir_body(tcx, mir_source.def_id());\n+    fn new(pass_name: &'a str, tcx: TyCtxt<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n+        let hir_body = hir_body(tcx, mir_body.source.def_id());\n         Self {\n             pass_name,\n             tcx,\n-            mir_source,\n             mir_body,\n             hir_body,\n             function_source_hash: None,\n@@ -156,7 +144,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n     fn inject_counters(&mut self) {\n         let tcx = self.tcx;\n-        let def_id = self.mir_source.def_id();\n+        let def_id = self.mir_body.source.def_id();\n         let mir_body = &self.mir_body;\n         let body_span = self.hir_body.value.span;\n         debug!(\n@@ -239,9 +227,15 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         }\n \n         if let Some(span_viewables) = span_viewables {\n-            let mut file =\n-                pretty::create_dump_file(tcx, \"html\", None, self.pass_name, &0, self.mir_source)\n-                    .expect(\"Unexpected error creating MIR spanview HTML file\");\n+            let mut file = pretty::create_dump_file(\n+                tcx,\n+                \"html\",\n+                None,\n+                self.pass_name,\n+                &0,\n+                self.mir_body.source,\n+            )\n+            .expect(\"Unexpected error creating MIR spanview HTML file\");\n             write_spanview_document(tcx, def_id, span_viewables, &mut file)\n                 .expect(\"Unexpected IO error dumping coverage spans as HTML\");\n         }"}, {"sha": "dad3812c5cd74d0026ae345dc120256f588abd38", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,4 +1,4 @@\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n@@ -37,8 +37,8 @@ pub struct MatchBranchSimplification;\n /// ```\n \n impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let param_env = tcx.param_env(src.def_id());\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let param_env = tcx.param_env(body.source.def_id());\n         let bbs = body.basic_blocks_mut();\n         'outer: for bb_idx in bbs.indices() {\n             let (discr, val, switch_ty, first, second) = match bbs[bb_idx].terminator().kind {"}, {"sha": "d8bc00c5f3f926f3cd6ed1c77dc70ee404cb74c9", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 19, "deletions": 86, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::visit::Visitor as _;\n use rustc_middle::mir::{traversal, Body, ConstQualifs, MirPhase, Promoted};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::steal::Steal;\n-use rustc_middle::ty::{self, InstanceDef, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_span::{Span, Symbol};\n use std::borrow::Cow;\n \n@@ -49,6 +49,8 @@ pub mod uninhabited_enum_branching;\n pub mod unreachable_prop;\n pub mod validate;\n \n+pub use rustc_middle::mir::MirSource;\n+\n pub(crate) fn provide(providers: &mut Providers) {\n     self::check_unsafety::provide(providers);\n     *providers = Providers {\n@@ -132,33 +134,6 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> FxHashSet<LocalDefId> {\n     set\n }\n \n-/// Where a specific `mir::Body` comes from.\n-#[derive(Debug, Copy, Clone)]\n-pub struct MirSource<'tcx> {\n-    pub instance: InstanceDef<'tcx>,\n-\n-    /// If `Some`, this is a promoted rvalue within the parent function.\n-    pub promoted: Option<Promoted>,\n-}\n-\n-impl<'tcx> MirSource<'tcx> {\n-    pub fn item(def_id: DefId) -> Self {\n-        MirSource {\n-            instance: InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n-            promoted: None,\n-        }\n-    }\n-\n-    pub fn with_opt_param(self) -> ty::WithOptConstParam<DefId> {\n-        self.instance.with_opt_param()\n-    }\n-\n-    #[inline]\n-    pub fn def_id(&self) -> DefId {\n-        self.instance.def_id()\n-    }\n-}\n-\n /// Generates a default name for the pass based on the name of the\n /// type `T`.\n pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n@@ -174,19 +149,16 @@ pub trait MirPass<'tcx> {\n         default_name::<Self>()\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>);\n }\n \n pub fn run_passes(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n-    instance: InstanceDef<'tcx>,\n-    promoted: Option<Promoted>,\n     mir_phase: MirPhase,\n     passes: &[&[&dyn MirPass<'tcx>]],\n ) {\n     let phase_index = mir_phase.phase_index();\n-    let source = MirSource { instance, promoted };\n     let validate = tcx.sess.opts.debugging_opts.validate_mir;\n \n     if body.phase >= mir_phase {\n@@ -195,7 +167,7 @@ pub fn run_passes(\n \n     if validate {\n         validate::Validator { when: format!(\"input to phase {:?}\", mir_phase), mir_phase }\n-            .run_pass(tcx, source, body);\n+            .run_pass(tcx, body);\n     }\n \n     let mut index = 0;\n@@ -205,21 +177,20 @@ pub fn run_passes(\n                 tcx,\n                 &format_args!(\"{:03}-{:03}\", phase_index, index),\n                 &pass.name(),\n-                source,\n                 body,\n                 is_after,\n             );\n         };\n         run_hooks(body, index, false);\n-        pass.run_pass(tcx, source, body);\n+        pass.run_pass(tcx, body);\n         run_hooks(body, index, true);\n \n         if validate {\n             validate::Validator {\n                 when: format!(\"after {} in phase {:?}\", pass.name(), mir_phase),\n                 mir_phase,\n             }\n-            .run_pass(tcx, source, body);\n+            .run_pass(tcx, body);\n         }\n \n         index += 1;\n@@ -235,7 +206,7 @@ pub fn run_passes(\n \n     if mir_phase == MirPhase::Optimization {\n         validate::Validator { when: format!(\"end of phase {:?}\", mir_phase), mir_phase }\n-            .run_pass(tcx, source, body);\n+            .run_pass(tcx, body);\n     }\n }\n \n@@ -292,21 +263,11 @@ fn mir_const<'tcx>(\n \n     let mut body = tcx.mir_built(def).steal();\n \n-    util::dump_mir(\n-        tcx,\n-        None,\n-        \"mir_map\",\n-        &0,\n-        MirSource { instance: InstanceDef::Item(def.to_global()), promoted: None },\n-        &body,\n-        |_, _| Ok(()),\n-    );\n+    util::dump_mir(tcx, None, \"mir_map\", &0, &body, |_, _| Ok(()));\n \n     run_passes(\n         tcx,\n         &mut body,\n-        InstanceDef::Item(def.to_global()),\n-        None,\n         MirPhase::Const,\n         &[&[\n             // MIR-level lints.\n@@ -359,14 +320,7 @@ fn mir_promoted(\n         &[]\n     };\n \n-    run_passes(\n-        tcx,\n-        &mut body,\n-        InstanceDef::Item(def.to_global()),\n-        None,\n-        MirPhase::ConstPromotion,\n-        &[promote, opt_coverage],\n-    );\n+    run_passes(tcx, &mut body, MirPhase::ConstPromotion, &[promote, opt_coverage]);\n \n     let promoted = promote_pass.promoted_fragments.into_inner();\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n@@ -391,19 +345,14 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n     let (body, _) = tcx.mir_promoted(def);\n     let mut body = body.steal();\n \n-    run_post_borrowck_cleanup_passes(tcx, &mut body, def.did, None);\n+    run_post_borrowck_cleanup_passes(tcx, &mut body);\n     check_consts::post_drop_elaboration::check_live_drops(tcx, def.did, &body);\n     tcx.alloc_steal_mir(body)\n }\n \n /// After this series of passes, no lifetime analysis based on borrowing can be done.\n-fn run_post_borrowck_cleanup_passes<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n-    def_id: LocalDefId,\n-    promoted: Option<Promoted>,\n-) {\n-    debug!(\"post_borrowck_cleanup({:?})\", def_id);\n+fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    debug!(\"post_borrowck_cleanup({:?})\", body.source.def_id());\n \n     let post_borrowck_cleanup: &[&dyn MirPass<'tcx>] = &[\n         // Remove all things only needed by analysis\n@@ -428,22 +377,10 @@ fn run_post_borrowck_cleanup_passes<'tcx>(\n         &deaggregator::Deaggregator,\n     ];\n \n-    run_passes(\n-        tcx,\n-        body,\n-        InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id())),\n-        promoted,\n-        MirPhase::DropLowering,\n-        &[post_borrowck_cleanup],\n-    );\n+    run_passes(tcx, body, MirPhase::DropLowering, &[post_borrowck_cleanup]);\n }\n \n-fn run_optimization_passes<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n-    def_id: LocalDefId,\n-    promoted: Option<Promoted>,\n-) {\n+fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let mir_opt_level = tcx.sess.opts.debugging_opts.mir_opt_level;\n \n     // Lowering generator control-flow and variables has to happen before we do anything else\n@@ -502,8 +439,6 @@ fn run_optimization_passes<'tcx>(\n     run_passes(\n         tcx,\n         body,\n-        InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id())),\n-        promoted,\n         MirPhase::GeneratorLowering,\n         &[\n             if mir_opt_level > 0 {\n@@ -519,8 +454,6 @@ fn run_optimization_passes<'tcx>(\n     run_passes(\n         tcx,\n         body,\n-        InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id())),\n-        promoted,\n         MirPhase::Optimization,\n         &[\n             if mir_opt_level > 0 { optimizations } else { no_optimizations },\n@@ -558,7 +491,7 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>)\n     }\n \n     let mut body = tcx.mir_drops_elaborated_and_const_checked(def).steal();\n-    run_optimization_passes(tcx, &mut body, def.did, None);\n+    run_optimization_passes(tcx, &mut body);\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n \n@@ -581,9 +514,9 @@ fn promoted_mir<'tcx>(\n     let (_, promoted) = tcx.mir_promoted(def);\n     let mut promoted = promoted.steal();\n \n-    for (p, mut body) in promoted.iter_enumerated_mut() {\n-        run_post_borrowck_cleanup_passes(tcx, &mut body, def.did, Some(p));\n-        run_optimization_passes(tcx, &mut body, def.did, Some(p));\n+    for body in &mut promoted {\n+        run_post_borrowck_cleanup_passes(tcx, body);\n+        run_optimization_passes(tcx, body);\n     }\n \n     debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");"}, {"sha": "c37b54a3190f8fb7e6eb736b89d1341a59a968ea", "filename": "compiler/rustc_mir/src/transform/multiple_return_terminators.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmultiple_return_terminators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmultiple_return_terminators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmultiple_return_terminators.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,15 +1,15 @@\n //! This pass removes jumps to basic blocks containing only a return, and replaces them with a\n //! return instead.\n \n-use crate::transform::{simplify, MirPass, MirSource};\n+use crate::transform::{simplify, MirPass};\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n pub struct MultipleReturnTerminators;\n \n impl<'tcx> MirPass<'tcx> for MultipleReturnTerminators {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level < 3 {\n             return;\n         }"}, {"sha": "83954c93c04a13edb27f1c1c680e5faf8a9ad6c1", "filename": "compiler/rustc_mir/src/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fno_landing_pads.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,7 +1,7 @@\n //! This pass removes the unwind branch of all the terminators when the no-landing-pads option is\n //! specified.\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_middle::mir::visit::MutVisitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n@@ -18,7 +18,7 @@ impl<'tcx> NoLandingPads<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }"}, {"sha": "7e05d66074bb152de555f22ef2171a62a68e1be2", "filename": "compiler/rustc_mir/src/transform/nrvo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -4,7 +4,7 @@ use rustc_middle::mir::visit::{MutVisitor, NonUseContext, PlaceContext, Visitor}\n use rustc_middle::mir::{self, BasicBlock, Local, Location};\n use rustc_middle::ty::TyCtxt;\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n \n /// This pass looks for MIR that always copies the same local into the return place and eliminates\n /// the copy by renaming all uses of that local to `_0`.\n@@ -31,22 +31,22 @@ use crate::transform::{MirPass, MirSource};\n pub struct RenameReturnPlace;\n \n impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut mir::Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut mir::Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return;\n         }\n \n         let returned_local = match local_eligible_for_nrvo(body) {\n             Some(l) => l,\n             None => {\n-                debug!(\"`{:?}` was ineligible for NRVO\", src.def_id());\n+                debug!(\"`{:?}` was ineligible for NRVO\", body.source.def_id());\n                 return;\n             }\n         };\n \n         debug!(\n             \"`{:?}` was eligible for NRVO, making {:?} the return place\",\n-            src.def_id(),\n+            body.source.def_id(),\n             returned_local\n         );\n "}, {"sha": "7ad659bddbe3dc9299c82d1cc89604e469da1579", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -32,7 +32,7 @@ use std::{cmp, iter, mem};\n \n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstCx};\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n \n /// A `MirPass` for promotion.\n ///\n@@ -47,7 +47,7 @@ pub struct PromoteTemps<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         //\n         // This does not include MIR that failed const-checking, which we still try to promote.\n@@ -56,11 +56,11 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n             return;\n         }\n \n-        if src.promoted.is_some() {\n+        if body.source.promoted.is_some() {\n             return;\n         }\n \n-        let def = src.with_opt_param().expect_local();\n+        let def = body.source.with_opt_param().expect_local();\n \n         let mut rpo = traversal::reverse_postorder(body);\n         let ccx = ConstCx::new(tcx, def.did, body);\n@@ -1167,6 +1167,7 @@ pub fn promote_candidates<'tcx>(\n         let initial_locals = iter::once(LocalDecl::new(tcx.types.never, body.span)).collect();\n \n         let mut promoted = Body::new(\n+            body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n             // FIXME: maybe try to filter this to avoid blowing up\n             // memory usage?\n@@ -1190,7 +1191,8 @@ pub fn promote_candidates<'tcx>(\n         };\n \n         //FIXME(oli-obk): having a `maybe_push()` method on `IndexVec` might be nice\n-        if let Some(promoted) = promoter.promote_candidate(def, candidate, promotions.len()) {\n+        if let Some(mut promoted) = promoter.promote_candidate(def, candidate, promotions.len()) {\n+            promoted.source.promoted = Some(promotions.next_index());\n             promotions.push(promoted);\n         }\n     }"}, {"sha": "b45c533d2c0025d1d4c44313098fbff987f39671", "filename": "compiler/rustc_mir/src/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,4 +1,4 @@\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use crate::util::patch::MirPatch;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n@@ -20,7 +20,7 @@ pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>)\n }\n \n impl<'tcx> MirPass<'tcx> for RemoveNoopLandingPads {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         remove_noop_landing_pads(tcx, body);\n     }\n }"}, {"sha": "cfee656eda413e4ec6862b2b593048d816086d80", "filename": "compiler/rustc_mir/src/transform/remove_unneeded_drops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,6 +1,6 @@\n //! This pass replaces a drop of a type that does not need dropping, with a goto\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -11,13 +11,13 @@ use super::simplify::simplify_cfg;\n pub struct RemoveUnneededDrops;\n \n impl<'tcx> MirPass<'tcx> for RemoveUnneededDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        trace!(\"Running RemoveUnneededDrops on {:?}\", source);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        trace!(\"Running RemoveUnneededDrops on {:?}\", body.source);\n         let mut opt_finder = RemoveUnneededDropsOptimizationFinder {\n             tcx,\n             body,\n             optimizations: vec![],\n-            def_id: source.def_id().expect_local(),\n+            def_id: body.source.def_id().expect_local(),\n         };\n         opt_finder.visit_body(body);\n         let should_simplify = !opt_finder.optimizations.is_empty();"}, {"sha": "366041581c2a83a44322c9d1c74731a5c27283fb", "filename": "compiler/rustc_mir/src/transform/rustc_peek.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -5,7 +5,7 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, Body, Local, Location};\n@@ -23,9 +23,9 @@ use crate::dataflow::{Analysis, JoinSemiLattice, Results, ResultsCursor};\n pub struct SanityCheck;\n \n impl<'tcx> MirPass<'tcx> for SanityCheck {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         use crate::dataflow::has_rustc_mir_with;\n-        let def_id = src.def_id();\n+        let def_id = body.source.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n             return;"}, {"sha": "f0c87bcf513cd027c82024fdee7c72bb99a045bd", "filename": "compiler/rustc_mir/src/transform/simplify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -27,7 +27,7 @@\n //! naively generate still contains the `_a = ()` write in the unreachable block \"after\" the\n //! return.\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n@@ -59,7 +59,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n         simplify_cfg(body);\n     }\n@@ -318,8 +318,8 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n pub struct SimplifyLocals;\n \n impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        trace!(\"running SimplifyLocals on {:?}\", source);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        trace!(\"running SimplifyLocals on {:?}\", body.source);\n \n         // First, we're going to get a count of *actual* uses for every `Local`.\n         // Take a look at `DeclMarker::visit_local()` to see exactly what is ignored."}, {"sha": "161856a38ee0303a095cd1458c1472cbae73673b", "filename": "compiler/rustc_mir/src/transform/simplify_branches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,6 +1,6 @@\n //! A pass that simplifies branches when their condition is known.\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n@@ -21,8 +21,8 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let param_env = tcx.param_env(src.def_id());\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let param_env = tcx.param_env(body.source.def_id());\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {"}, {"sha": "9f837cf78a60842631faffe69d4c2883e9d02021", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,4 +1,4 @@\n-use super::{MirPass, MirSource};\n+use super::MirPass;\n use rustc_middle::{\n     mir::{\n         interpret::Scalar, BasicBlock, BinOp, Body, Operand, Place, Rvalue, Statement,\n@@ -24,8 +24,8 @@ use rustc_middle::{\n pub struct SimplifyComparisonIntegral;\n \n impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        trace!(\"Running SimplifyComparisonIntegral on {:?}\", source);\n+    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        trace!(\"Running SimplifyComparisonIntegral on {:?}\", body.source);\n \n         let helper = OptimizationFinder { body };\n         let opts = helper.find_optimizations();"}, {"sha": "e6b7345d6e48842412465c747fdc023c622ab5c2", "filename": "compiler/rustc_mir/src/transform/simplify_try.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -9,7 +9,7 @@\n //!\n //! into just `x`.\n \n-use crate::transform::{simplify, MirPass, MirSource};\n+use crate::transform::{simplify, MirPass};\n use itertools::Itertools as _;\n use rustc_index::{bit_set::BitSet, vec::IndexVec};\n use rustc_middle::mir::visit::{NonUseContext, PlaceContext, Visitor};\n@@ -367,13 +367,15 @@ fn optimization_applies<'tcx>(\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // FIXME(77359): This optimization can result in unsoundness.\n         if !tcx.sess.opts.debugging_opts.unsound_mir_opts {\n             return;\n         }\n \n+        let source = body.source;\n         trace!(\"running SimplifyArmIdentity on {:?}\", source);\n+\n         let local_uses = LocalUseCounter::get_local_uses(body);\n         let (basic_blocks, local_decls, debug_info) =\n             body.basic_blocks_local_decls_mut_and_var_debug_info();\n@@ -528,8 +530,8 @@ fn match_variant_field_place<'tcx>(place: Place<'tcx>) -> Option<(Local, VarFiel\n pub struct SimplifyBranchSame;\n \n impl<'tcx> MirPass<'tcx> for SimplifyBranchSame {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        trace!(\"Running SimplifyBranchSame on {:?}\", source);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        trace!(\"Running SimplifyBranchSame on {:?}\", body.source);\n         let finder = SimplifyBranchSameOptimizationFinder { body, tcx };\n         let opts = finder.find();\n "}, {"sha": "a6bfa0c7409f2d3dd6516ea256c0efbab0bcf6e7", "filename": "compiler/rustc_mir/src/transform/uninhabited_enum_branching.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -1,6 +1,6 @@\n //! A pass that eliminates branches on uninhabited enum variants.\n \n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_middle::mir::{\n     BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, TerminatorKind,\n };\n@@ -66,12 +66,12 @@ fn variant_discriminants<'tcx>(\n }\n \n impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        if source.promoted.is_some() {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        if body.source.promoted.is_some() {\n             return;\n         }\n \n-        trace!(\"UninhabitedEnumBranching starting for {:?}\", source);\n+        trace!(\"UninhabitedEnumBranching starting for {:?}\", body.source);\n \n         let basic_block_count = body.basic_blocks().len();\n \n@@ -86,7 +86,7 @@ impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n                     continue;\n                 };\n \n-            let layout = tcx.layout_of(tcx.param_env(source.def_id()).and(discriminant_ty));\n+            let layout = tcx.layout_of(tcx.param_env(body.source.def_id()).and(discriminant_ty));\n \n             let allowed_variants = if let Ok(layout) = layout {\n                 variant_discriminants(&layout, discriminant_ty, tcx)"}, {"sha": "c6426a06ea155a0e1b5ea4c2997c03093480b4e3", "filename": "compiler/rustc_mir/src/transform/unreachable_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -3,7 +3,7 @@\n //! post-order traversal of the blocks.\n \n use crate::transform::simplify;\n-use crate::transform::{MirPass, MirSource};\n+use crate::transform::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n@@ -12,7 +12,7 @@ use std::borrow::Cow;\n pub struct UnreachablePropagation;\n \n impl MirPass<'_> for UnreachablePropagation {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level < 3 {\n             // Enable only under -Zmir-opt-level=3 as in some cases (check the deeply-nested-opt\n             // perf benchmark) LLVM may spend quite a lot of time optimizing the generated code."}, {"sha": "0c3580584ff269eb7973737f8914c7f7a4b4b40a", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -4,7 +4,7 @@ use crate::dataflow::impls::MaybeStorageLive;\n use crate::dataflow::{Analysis, ResultsCursor};\n use crate::util::storage::AlwaysLiveLocals;\n \n-use super::{MirPass, MirSource};\n+use super::MirPass;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n     AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPhase, Operand, Rvalue,\n@@ -31,8 +31,8 @@ pub struct Validator {\n }\n \n impl<'tcx> MirPass<'tcx> for Validator {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let def_id = source.def_id();\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let def_id = body.source.def_id();\n         let param_env = tcx.param_env(def_id);\n         let mir_phase = self.mir_phase;\n \n@@ -42,7 +42,7 @@ impl<'tcx> MirPass<'tcx> for Validator {\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n \n-        TypeChecker { when: &self.when, source, body, tcx, param_env, mir_phase, storage_liveness }\n+        TypeChecker { when: &self.when, body, tcx, param_env, mir_phase, storage_liveness }\n             .visit_body(body);\n     }\n }\n@@ -141,7 +141,6 @@ pub fn equal_up_to_regions(\n \n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n-    source: MirSource<'tcx>,\n     body: &'a Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n@@ -158,7 +157,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             span,\n             &format!(\n                 \"broken MIR in {:?} ({}) at {:?}:\\n{}\",\n-                self.source.instance,\n+                self.body.source.instance,\n                 self.when,\n                 location,\n                 msg.as_ref()"}, {"sha": "c10724ad404569c631c9268b6bbc84ee45a2b8c2", "filename": "compiler/rustc_mir/src/util/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -22,7 +22,7 @@ where\n \n     for def_id in def_ids {\n         let body = &tcx.optimized_mir(def_id);\n-        write_mir_fn_graphviz(tcx, def_id, body, use_subgraphs, w)?;\n+        write_mir_fn_graphviz(tcx, body, use_subgraphs, w)?;\n     }\n \n     if use_subgraphs {\n@@ -41,14 +41,14 @@ pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n /// Write a graphviz DOT graph of the MIR.\n pub fn write_mir_fn_graphviz<'tcx, W>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n     body: &Body<'_>,\n     subgraph: bool,\n     w: &mut W,\n ) -> io::Result<()>\n where\n     W: Write,\n {\n+    let def_id = body.source.def_id();\n     let kind = if subgraph { \"subgraph\" } else { \"digraph\" };\n     let cluster = if subgraph { \"cluster_\" } else { \"\" }; // Prints a border around MIR\n     let def_name = graphviz_safe_def_name(def_id);"}, {"sha": "ad871fde00f78702287839c4383fd114728e1d8b", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -75,17 +75,16 @@ pub fn dump_mir<'tcx, F>(\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n-    source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     extra_data: F,\n ) where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n-    if !dump_enabled(tcx, pass_name, source.def_id()) {\n+    if !dump_enabled(tcx, pass_name, body.source.def_id()) {\n         return;\n     }\n \n-    dump_matched_mir_node(tcx, pass_num, pass_name, disambiguator, source, body, extra_data);\n+    dump_matched_mir_node(tcx, pass_num, pass_name, disambiguator, body, extra_data);\n }\n \n pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, def_id: DefId) -> bool {\n@@ -113,20 +112,20 @@ fn dump_matched_mir_node<'tcx, F>(\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n-    source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     mut extra_data: F,\n ) where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n     let _: io::Result<()> = try {\n-        let mut file = create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, source)?;\n+        let mut file =\n+            create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, body.source)?;\n         let def_path = ty::print::with_forced_impl_filename_line(|| {\n             // see notes on #41697 above\n-            tcx.def_path_str(source.def_id())\n+            tcx.def_path_str(body.source.def_id())\n         });\n         write!(file, \"// MIR for `{}\", def_path)?;\n-        match source.promoted {\n+        match body.source.promoted {\n             None => write!(file, \"`\")?,\n             Some(promoted) => write!(file, \"::{:?}`\", promoted)?,\n         }\n@@ -137,24 +136,24 @@ fn dump_matched_mir_node<'tcx, F>(\n         writeln!(file)?;\n         extra_data(PassWhere::BeforeCFG, &mut file)?;\n         write_user_type_annotations(tcx, body, &mut file)?;\n-        write_mir_fn(tcx, source, body, &mut extra_data, &mut file)?;\n+        write_mir_fn(tcx, body, &mut extra_data, &mut file)?;\n         extra_data(PassWhere::AfterCFG, &mut file)?;\n     };\n \n     if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n         let _: io::Result<()> = try {\n             let mut file =\n-                create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, source)?;\n-            write_mir_fn_graphviz(tcx, source.def_id(), body, false, &mut file)?;\n+                create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, body.source)?;\n+            write_mir_fn_graphviz(tcx, body, false, &mut file)?;\n         };\n     }\n \n     if let Some(spanview) = tcx.sess.opts.debugging_opts.dump_mir_spanview {\n         let _: io::Result<()> = try {\n             let mut file =\n-                create_dump_file(tcx, \"html\", pass_num, pass_name, disambiguator, source)?;\n-            if source.def_id().is_local() {\n-                write_mir_fn_spanview(tcx, source.def_id(), body, spanview, &mut file)?;\n+                create_dump_file(tcx, \"html\", pass_num, pass_name, disambiguator, body.source)?;\n+            if body.source.def_id().is_local() {\n+                write_mir_fn_spanview(tcx, body.source.def_id(), body, spanview, &mut file)?;\n             }\n         };\n     }\n@@ -263,15 +262,11 @@ pub fn write_mir_pretty<'tcx>(\n             writeln!(w)?;\n         }\n \n-        write_mir_fn(tcx, MirSource::item(def_id), body, &mut |_, _| Ok(()), w)?;\n+        write_mir_fn(tcx, body, &mut |_, _| Ok(()), w)?;\n \n-        for (i, body) in tcx.promoted_mir(def_id).iter_enumerated() {\n+        for body in tcx.promoted_mir(def_id) {\n             writeln!(w)?;\n-            let src = MirSource {\n-                instance: ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n-                promoted: Some(i),\n-            };\n-            write_mir_fn(tcx, src, body, &mut |_, _| Ok(()), w)?;\n+            write_mir_fn(tcx, body, &mut |_, _| Ok(()), w)?;\n         }\n     }\n     Ok(())\n@@ -280,15 +275,14 @@ pub fn write_mir_pretty<'tcx>(\n /// Write out a human-readable textual representation for the given function.\n pub fn write_mir_fn<'tcx, F>(\n     tcx: TyCtxt<'tcx>,\n-    src: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     extra_data: &mut F,\n     w: &mut dyn Write,\n ) -> io::Result<()>\n where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n-    write_mir_intro(tcx, src, body, w)?;\n+    write_mir_intro(tcx, body, w)?;\n     for block in body.basic_blocks().indices() {\n         extra_data(PassWhere::BeforeBlock(block), w)?;\n         write_basic_block(tcx, block, body, extra_data, w)?;\n@@ -548,11 +542,10 @@ fn write_scope_tree(\n /// local variables (both user-defined bindings and compiler temporaries).\n pub fn write_mir_intro<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    src: MirSource<'tcx>,\n     body: &Body<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n-    write_mir_sig(tcx, src, body, w)?;\n+    write_mir_sig(tcx, body, w)?;\n     writeln!(w, \"{{\")?;\n \n     // construct a scope tree and write it out\n@@ -850,25 +843,21 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n     Ok(())\n }\n \n-fn write_mir_sig(\n-    tcx: TyCtxt<'_>,\n-    src: MirSource<'tcx>,\n-    body: &Body<'_>,\n-    w: &mut dyn Write,\n-) -> io::Result<()> {\n+fn write_mir_sig(tcx: TyCtxt<'_>, body: &Body<'_>, w: &mut dyn Write) -> io::Result<()> {\n     use rustc_hir::def::DefKind;\n \n-    trace!(\"write_mir_sig: {:?}\", src.instance);\n-    let kind = tcx.def_kind(src.def_id());\n+    trace!(\"write_mir_sig: {:?}\", body.source.instance);\n+    let def_id = body.source.def_id();\n+    let kind = tcx.def_kind(def_id);\n     let is_function = match kind {\n         DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(..) => true,\n-        _ => tcx.is_closure(src.def_id()),\n+        _ => tcx.is_closure(def_id),\n     };\n-    match (kind, src.promoted) {\n+    match (kind, body.source.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in \", i)?,\n         (DefKind::Const | DefKind::AssocConst, _) => write!(w, \"const \")?,\n         (DefKind::Static, _) => {\n-            write!(w, \"static {}\", if tcx.is_mutable_static(src.def_id()) { \"mut \" } else { \"\" })?\n+            write!(w, \"static {}\", if tcx.is_mutable_static(def_id) { \"mut \" } else { \"\" })?\n         }\n         (_, _) if is_function => write!(w, \"fn \")?,\n         (DefKind::AnonConst, _) => {} // things like anon const, not an item\n@@ -877,10 +866,10 @@ fn write_mir_sig(\n \n     ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 elsewhere\n-        write!(w, \"{}\", tcx.def_path_str(src.def_id()))\n+        write!(w, \"{}\", tcx.def_path_str(def_id))\n     })?;\n \n-    if src.promoted.is_none() && is_function {\n+    if body.source.promoted.is_none() && is_function {\n         write!(w, \"(\")?;\n \n         // fn argument types."}, {"sha": "72814e3373bbb8b28b225cd49f63a2ab63fe8e8a", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf5f731bb71db3470002d6baf5ab4792b821d9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=4ccf5f731bb71db3470002d6baf5ab4792b821d9", "patch": "@@ -29,7 +29,13 @@ crate fn mir_built<'tcx>(\n         return tcx.mir_built(def);\n     }\n \n-    tcx.alloc_steal_mir(mir_build(tcx, def))\n+    let mut body = mir_build(tcx, def);\n+    if def.const_param_did.is_some() {\n+        assert!(matches!(body.source.instance, ty::InstanceDef::Item(_)));\n+        body.source = MirSource::from_instance(ty::InstanceDef::Item(def.to_global()));\n+    }\n+\n+    tcx.alloc_steal_mir(body)\n }\n \n /// Construct the MIR for a given `DefId`.\n@@ -296,6 +302,7 @@ struct Builder<'a, 'tcx> {\n     hir: Cx<'a, 'tcx>,\n     cfg: CFG<'tcx>,\n \n+    def_id: DefId,\n     fn_span: Span,\n     arg_count: usize,\n     generator_kind: Option<GeneratorKind>,\n@@ -597,6 +604,7 @@ where\n \n     let mut builder = Builder::new(\n         hir,\n+        fn_def_id.to_def_id(),\n         span_with_body,\n         arguments.len(),\n         safety,\n@@ -675,8 +683,9 @@ fn construct_const<'a, 'tcx>(\n ) -> Body<'tcx> {\n     let tcx = hir.tcx();\n     let owner_id = tcx.hir().body_owner(body_id);\n+    let def_id = tcx.hir().local_def_id(owner_id);\n     let span = tcx.hir().span(owner_id);\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, const_ty, const_ty_span, None);\n+    let mut builder = Builder::new(hir, def_id.to_def_id(), span, 0, Safety::Safe, const_ty, const_ty_span, None);\n \n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n@@ -705,6 +714,7 @@ fn construct_const<'a, 'tcx>(\n fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'tcx> {\n     let tcx = hir.tcx();\n     let owner_id = tcx.hir().body_owner(body_id);\n+    let def_id = tcx.hir().local_def_id(owner_id);\n     let span = tcx.hir().span(owner_id);\n     let ty = tcx.ty_error();\n     let num_params = match hir.body_owner_kind {\n@@ -722,7 +732,7 @@ fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'t\n         hir::BodyOwnerKind::Const => 0,\n         hir::BodyOwnerKind::Static(_) => 0,\n     };\n-    let mut builder = Builder::new(hir, span, num_params, Safety::Safe, ty, span, None);\n+    let mut builder = Builder::new(hir, def_id.to_def_id(), span, num_params, Safety::Safe, ty, span, None);\n     let source_info = builder.source_info(span);\n     // Some MIR passes will expect the number of parameters to match the\n     // function declaration.\n@@ -740,6 +750,7 @@ fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'t\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn new(\n         hir: Cx<'a, 'tcx>,\n+        def_id: DefId,\n         span: Span,\n         arg_count: usize,\n         safety: Safety,\n@@ -750,6 +761,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n             hir,\n+            def_id,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             arg_count,\n@@ -790,6 +802,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         Body::new(\n+            MirSource::item(self.def_id),\n             self.cfg.basic_blocks,\n             self.source_scopes,\n             self.local_decls,"}]}