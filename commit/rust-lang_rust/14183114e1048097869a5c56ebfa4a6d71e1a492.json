{"sha": "14183114e1048097869a5c56ebfa4a6d71e1a492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MTgzMTE0ZTEwNDgwOTc4NjlhNWM1NmViZmE0YTZkNzFlMWE0OTI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-08T12:46:20Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-08T13:00:05Z"}, "message": "syntax: aesthetic improvements to the `for` desugaring.", "tree": {"sha": "da8753d901a569992bf4ee1a30c016b377221485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da8753d901a569992bf4ee1a30c016b377221485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14183114e1048097869a5c56ebfa4a6d71e1a492", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14183114e1048097869a5c56ebfa4a6d71e1a492", "html_url": "https://github.com/rust-lang/rust/commit/14183114e1048097869a5c56ebfa4a6d71e1a492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14183114e1048097869a5c56ebfa4a6d71e1a492/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07351b44c657225d45e2aa0a302ccd28f96839a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/07351b44c657225d45e2aa0a302ccd28f96839a8", "html_url": "https://github.com/rust-lang/rust/commit/07351b44c657225d45e2aa0a302ccd28f96839a8"}], "stats": {"total": 168, "additions": 38, "deletions": 130}, "files": [{"sha": "099fa54c0c2991900e801b57b57ef58cda11ae38", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 38, "deletions": 130, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/14183114e1048097869a5c56ebfa4a6d71e1a492/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14183114e1048097869a5c56ebfa4a6d71e1a492/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=14183114e1048097869a5c56ebfa4a6d71e1a492", "patch": "@@ -14,13 +14,13 @@ use ast::{item_mac, Mrk, Stmt_, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::{token_tree};\n use ast;\n use ast_util::{mtwt_outer_mark, new_rename, new_mark};\n+use ext::build::AstBuilder;\n use attr;\n use attr::AttrMetaMethods;\n use codemap;\n-use codemap::{Span, Spanned, spanned, ExpnInfo, NameAndSpan};\n+use codemap::{Span, Spanned, ExpnInfo, NameAndSpan};\n use ext::base::*;\n use fold::*;\n-use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n@@ -33,7 +33,7 @@ use std::vec;\n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    e: &Expr_,\n-                   s: Span,\n+                   span: Span,\n                    fld: @ast_fold,\n                    orig: @fn(&Expr_, Span, @ast_fold) -> (Expr_, Span))\n                 -> (Expr_, Span) {\n@@ -66,7 +66,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         }\n                         Some(@SE(NormalTT(expandfun, exp_span))) => {\n                             cx.bt_push(ExpnInfo {\n-                                call_site: s,\n+                                call_site: span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n                                     span: exp_span,\n@@ -98,7 +98,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                 fld.fold_expr(marked_after).node.clone();\n                             cx.bt_pop();\n \n-                            (fully_expanded, s)\n+                            (fully_expanded, span)\n                         }\n                         _ => {\n                             cx.span_fatal(\n@@ -112,62 +112,18 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         }\n \n         // Desugar expr_for_loop\n-        // From: `for <src_pat> in <src_expr> <src_loop_block>`\n+        // From: `['<ident>:] for <src_pat> in <src_expr> <src_loop_block>`\n         ast::ExprForLoop(src_pat, src_expr, ref src_loop_block, opt_ident) => {\n-            let src_pat = src_pat.clone();\n-            let src_expr = src_expr.clone();\n-\n             // Expand any interior macros etc.\n             // NB: we don't fold pats yet. Curious.\n-            let src_expr = fld.fold_expr(src_expr).clone();\n-            let src_loop_block = fld.fold_block(src_loop_block).clone();\n-\n-            let span = s;\n-            let lo = s.lo;\n-            let hi = s.hi;\n-\n-            pub fn mk_expr(cx: @ExtCtxt, span: Span,\n-                           node: Expr_) -> @ast::Expr {\n-                @ast::Expr {\n-                    id: cx.next_id(),\n-                    node: node,\n-                    span: span,\n-                }\n-            }\n-\n-            fn mk_block(cx: @ExtCtxt,\n-                        stmts: &[@ast::Stmt],\n-                        expr: Option<@ast::Expr>,\n-                        span: Span) -> ast::Block {\n-                ast::Block {\n-                    view_items: ~[],\n-                    stmts: stmts.to_owned(),\n-                    expr: expr,\n-                    id: cx.next_id(),\n-                    rules: ast::DefaultBlock,\n-                    span: span,\n-                }\n-            }\n-\n-            fn mk_simple_path(ident: ast::Ident, span: Span) -> ast::Path {\n-                ast::Path {\n-                    span: span,\n-                    global: false,\n-                    segments: ~[\n-                        ast::PathSegment {\n-                            identifier: ident,\n-                            lifetime: None,\n-                            types: opt_vec::Empty,\n-                        }\n-                    ],\n-                }\n-            }\n+            let src_expr = fld.fold_expr(src_expr);\n+            let src_loop_block = fld.fold_block(src_loop_block);\n \n             // to:\n             //\n             // {\n             //   let _i = &mut <src_expr>;\n-            //   loop {\n+            //   ['<ident>:] loop {\n             //       match i.next() {\n             //           None => break,\n             //           Some(<src_pat>) => <src_loop_block>\n@@ -176,98 +132,50 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             // }\n \n             let local_ident = token::gensym_ident(\"i\");\n-            let some_ident = token::str_to_ident(\"Some\");\n-            let none_ident = token::str_to_ident(\"None\");\n-            let next_ident = token::str_to_ident(\"next\");\n+            let next_ident = cx.ident_of(\"next\");\n+            let none_ident = cx.ident_of(\"None\");\n \n-            let local_path_1 = mk_simple_path(local_ident, span);\n-            let local_path_2 = mk_simple_path(local_ident, span);\n-            let some_path = mk_simple_path(some_ident, span);\n-            let none_path = mk_simple_path(none_ident, span);\n+            let local_path = cx.path_ident(span, local_ident);\n+            let some_path = cx.path_ident(span, cx.ident_of(\"Some\"));\n \n             // `let i = &mut <src_expr>`\n-            let iter_decl_stmt = {\n-                let ty = ast::Ty {\n-                    id: cx.next_id(),\n-                    node: ast::ty_infer,\n-                    span: span\n-                };\n-                let local = @ast::Local {\n-                    is_mutbl: false,\n-                    ty: ty,\n-                    pat: @ast::Pat {\n-                        id: cx.next_id(),\n-                        node: ast::PatIdent(ast::BindInfer, local_path_1, None),\n-                        span: src_expr.span\n-                    },\n-                    init: Some(mk_expr(cx, src_expr.span,\n-                                       ast::ExprAddrOf(ast::MutMutable, src_expr))),\n-                    id: cx.next_id(),\n-                    span: src_expr.span,\n-                };\n-                let e = @spanned(src_expr.span.lo,\n-                                 src_expr.span.hi,\n-                                 ast::DeclLocal(local));\n-                @spanned(lo, hi, ast::StmtDecl(e, cx.next_id()))\n-            };\n+            let iter_decl_stmt = cx.stmt_let(span, false, local_ident,\n+                                             cx.expr_mut_addr_of(span, src_expr));\n \n-            // `None => break;`\n+            // `None => break ['<ident>];`\n             let none_arm = {\n-                let break_expr = mk_expr(cx, span, ast::ExprBreak(None));\n-                let break_stmt = @spanned(lo, hi, ast::StmtExpr(break_expr, cx.next_id()));\n-                let none_block = mk_block(cx, [break_stmt], None, span);\n-                let none_pat = @ast::Pat {\n-                    id: cx.next_id(),\n-                    node: ast::PatIdent(ast::BindInfer, none_path, None),\n-                    span: span\n-                };\n-                ast::Arm {\n-                    pats: ~[none_pat],\n-                    guard: None,\n-                    body: none_block\n-                }\n+                let break_expr = cx.expr(span, ast::ExprBreak(opt_ident));\n+                let none_pat = cx.pat_ident(span, none_ident);\n+                cx.arm(span, ~[none_pat], break_expr)\n             };\n \n             // `Some(<src_pat>) => <src_loop_block>`\n-            let some_arm = {\n-                let pat = @ast::Pat {\n-                    id: cx.next_id(),\n-                    node: ast::PatEnum(some_path, Some(~[src_pat])),\n-                    span: src_pat.span\n-                };\n-                ast::Arm {\n-                    pats: ~[pat],\n-                    guard: None,\n-                    body: src_loop_block\n-                }\n-            };\n+            let some_arm =\n+                cx.arm(span,\n+                       ~[cx.pat_enum(span, some_path, ~[src_pat])],\n+                       cx.expr_block(src_loop_block));\n \n             // `match i.next() { ... }`\n-            let match_stmt = {\n-                let local_expr = mk_expr(cx, span, ast::ExprPath(local_path_2));\n-                let next_call_expr = mk_expr(cx, span,\n-                                             ast::ExprMethodCall(cx.next_id(),\n-                                                                   local_expr, next_ident,\n-                                                                   ~[], ~[], ast::NoSugar));\n-                let match_expr = mk_expr(cx, span, ast::ExprMatch(next_call_expr,\n-                                                                   ~[none_arm, some_arm]));\n-                @spanned(lo, hi, ast::StmtExpr(match_expr, cx.next_id()))\n-            };\n+            let match_expr = {\n+                let next_call_expr =\n+                    cx.expr_method_call(span, cx.expr_path(local_path), next_ident, ~[]);\n \n-            // `loop { ... }`\n-            let loop_block = {\n-                let loop_body_block = mk_block(cx, [match_stmt], None, span);\n-                let loop_body_expr = mk_expr(cx, span, ast::ExprLoop(loop_body_block, opt_ident));\n-                let loop_body_stmt = @spanned(lo, hi, ast::StmtExpr(loop_body_expr, cx.next_id()));\n-                mk_block(cx, [iter_decl_stmt,\n-                              loop_body_stmt],\n-                         None, span)\n+                cx.expr_match(span, next_call_expr, ~[none_arm, some_arm])\n             };\n \n-            (ast::ExprBlock(loop_block), span)\n+            // ['ident:] loop { ... }\n+            let loop_expr = cx.expr(span,\n+                                    ast::ExprLoop(cx.block_expr(match_expr), opt_ident));\n+\n+            // `{ let ... ;  loop { ... } }`\n+            let block = cx.block(span,\n+                                 ~[iter_decl_stmt],\n+                                 Some(loop_expr));\n+\n+            (ast::ExprBlock(block), span)\n         }\n \n-        _ => orig(e, s, fld)\n+        _ => orig(e, span, fld)\n     }\n }\n "}]}