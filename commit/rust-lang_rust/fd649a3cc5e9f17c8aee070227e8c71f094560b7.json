{"sha": "fd649a3cc5e9f17c8aee070227e8c71f094560b7", "node_id": "C_kwDOAAsO6NoAKGZkNjQ5YTNjYzVlOWYxN2M4YWVlMDcwMjI3ZThjNzFmMDk0NTYwYjc", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-30T11:03:32Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-30T12:26:26Z"}, "message": "Replace enum `==`s with `match`es where it makes sense", "tree": {"sha": "b2d741c4f018a744f79877a8ca669a2617c652e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2d741c4f018a744f79877a8ca669a2617c652e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd649a3cc5e9f17c8aee070227e8c71f094560b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd649a3cc5e9f17c8aee070227e8c71f094560b7", "html_url": "https://github.com/rust-lang/rust/commit/fd649a3cc5e9f17c8aee070227e8c71f094560b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd649a3cc5e9f17c8aee070227e8c71f094560b7/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "url": "https://api.github.com/repos/rust-lang/rust/commits/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "html_url": "https://github.com/rust-lang/rust/commit/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54"}], "stats": {"total": 485, "additions": 256, "deletions": 229}, "files": [{"sha": "eece99a3eef0358c29f2792a6762955e1e9a03c6", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -58,23 +58,24 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         // In case we have doc comments like `/**` or `/*!`, we want to remove stars if they are\n         // present. However, we first need to strip the empty lines so they don't get in the middle\n         // when we try to compute the \"horizontal trim\".\n-        let lines = if kind == CommentKind::Block {\n-            // Whatever happens, we skip the first line.\n-            let mut i = lines\n-                .get(0)\n-                .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n-                .unwrap_or(0);\n-            let mut j = lines.len();\n-\n-            while i < j && lines[i].trim().is_empty() {\n-                i += 1;\n-            }\n-            while j > i && lines[j - 1].trim().is_empty() {\n-                j -= 1;\n+        let lines = match kind {\n+            CommentKind::Block => {\n+                // Whatever happens, we skip the first line.\n+                let mut i = lines\n+                    .get(0)\n+                    .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n+                    .unwrap_or(0);\n+                let mut j = lines.len();\n+\n+                while i < j && lines[i].trim().is_empty() {\n+                    i += 1;\n+                }\n+                while j > i && lines[j - 1].trim().is_empty() {\n+                    j -= 1;\n+                }\n+                &lines[i..j]\n             }\n-            &lines[i..j]\n-        } else {\n-            lines\n+            CommentKind::Line => lines,\n         };\n \n         for line in lines {"}, {"sha": "d865d5bc974e069f27714768bb9812ad999134cf", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -622,10 +622,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         let alloc = alloc.inner();\n         if is_write {\n             // Write access. These are never allowed, but we give a targeted error message.\n-            if alloc.mutability == Mutability::Not {\n-                Err(err_ub!(WriteToReadOnly(alloc_id)).into())\n-            } else {\n-                Err(ConstEvalErrKind::ModifiedGlobal.into())\n+            match alloc.mutability {\n+                Mutability::Not => Err(err_ub!(WriteToReadOnly(alloc_id)).into()),\n+                Mutability::Mut => Err(ConstEvalErrKind::ModifiedGlobal.into()),\n             }\n         } else {\n             // Read access. These are usually allowed, with some exceptions."}, {"sha": "faeaa548619708f5c2c0621f27ac25073b68b715", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -2113,30 +2113,38 @@ impl EmitterWriter {\n                         }\n                     }\n                     for sugg in suggestions {\n-                        if sugg.style == SuggestionStyle::CompletelyHidden {\n-                            // do not display this suggestion, it is meant only for tools\n-                        } else if sugg.style == SuggestionStyle::HideCodeAlways {\n-                            if let Err(e) = self.emit_message_default(\n-                                &MultiSpan::new(),\n-                                &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n-                                args,\n-                                &None,\n-                                &Level::Help,\n-                                max_line_num_len,\n-                                true,\n-                                None,\n-                            ) {\n-                                panic!(\"failed to emit error: {}\", e);\n+                        match sugg.style {\n+                            SuggestionStyle::CompletelyHidden => {\n+                                // do not display this suggestion, it is meant only for tools\n                             }\n-                        } else if let Err(e) = self.emit_suggestion_default(\n-                            span,\n-                            sugg,\n-                            args,\n-                            &Level::Help,\n-                            max_line_num_len,\n-                        ) {\n-                            panic!(\"failed to emit error: {}\", e);\n-                        };\n+                            SuggestionStyle::HideCodeAlways => {\n+                                if let Err(e) = self.emit_message_default(\n+                                    &MultiSpan::new(),\n+                                    &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n+                                    args,\n+                                    &None,\n+                                    &Level::Help,\n+                                    max_line_num_len,\n+                                    true,\n+                                    None,\n+                                ) {\n+                                    panic!(\"failed to emit error: {}\", e);\n+                                }\n+                            }\n+                            SuggestionStyle::HideCodeInline\n+                            | SuggestionStyle::ShowCode\n+                            | SuggestionStyle::ShowAlways => {\n+                                if let Err(e) = self.emit_suggestion_default(\n+                                    span,\n+                                    sugg,\n+                                    args,\n+                                    &Level::Help,\n+                                    max_line_num_len,\n+                                ) {\n+                                    panic!(\"failed to emit error: {}\", e);\n+                                }\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "5e8f727df69dade8cc2016d81e5cfc1cac2c75f4", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -385,10 +385,9 @@ pub fn check_generic_arg_count_for_call(\n ) -> GenericArgCountResult {\n     let empty_args = hir::GenericArgs::none();\n     let gen_args = seg.args.unwrap_or(&empty_args);\n-    let gen_pos = if is_method_call == IsMethodCall::Yes {\n-        GenericArgPosition::MethodCall\n-    } else {\n-        GenericArgPosition::Value\n+    let gen_pos = match is_method_call {\n+        IsMethodCall::Yes => GenericArgPosition::MethodCall,\n+        IsMethodCall::No => GenericArgPosition::Value,\n     };\n     let has_self = generics.parent.is_none() && generics.has_self;\n "}, {"sha": "8609afc506806a4fbbd8b90da33804cbd83942d4", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -605,59 +605,66 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             };\n             check_abi(tcx, it.hir_id(), it.span, abi);\n \n-            if abi == Abi::RustIntrinsic {\n-                for item in items {\n-                    let item = tcx.hir().foreign_item(item.id);\n-                    intrinsic::check_intrinsic_type(tcx, item);\n-                }\n-            } else if abi == Abi::PlatformIntrinsic {\n-                for item in items {\n-                    let item = tcx.hir().foreign_item(item.id);\n-                    intrinsic::check_platform_intrinsic_type(tcx, item);\n+            match abi {\n+                Abi::RustIntrinsic => {\n+                    for item in items {\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        intrinsic::check_intrinsic_type(tcx, item);\n+                    }\n                 }\n-            } else {\n-                for item in items {\n-                    let def_id = item.id.owner_id.def_id;\n-                    let generics = tcx.generics_of(def_id);\n-                    let own_counts = generics.own_counts();\n-                    if generics.params.len() - own_counts.lifetimes != 0 {\n-                        let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts) {\n-                            (_, 0) => (\"type\", \"types\", Some(\"u32\")),\n-                            // We don't specify an example value, because we can't generate\n-                            // a valid value for any type.\n-                            (0, _) => (\"const\", \"consts\", None),\n-                            _ => (\"type or const\", \"types or consts\", None),\n-                        };\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            item.span,\n-                            E0044,\n-                            \"foreign items may not have {kinds} parameters\",\n-                        )\n-                        .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n-                        .help(\n-                            // FIXME: once we start storing spans for type arguments, turn this\n-                            // into a suggestion.\n-                            &format!(\n-                                \"replace the {} parameters with concrete {}{}\",\n-                                kinds,\n-                                kinds_pl,\n-                                egs.map(|egs| format!(\" like `{}`\", egs)).unwrap_or_default(),\n-                            ),\n-                        )\n-                        .emit();\n+\n+                Abi::PlatformIntrinsic => {\n+                    for item in items {\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        intrinsic::check_platform_intrinsic_type(tcx, item);\n                     }\n+                }\n \n-                    let item = tcx.hir().foreign_item(item.id);\n-                    match &item.kind {\n-                        hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n-                            require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n+                _ => {\n+                    for item in items {\n+                        let def_id = item.id.owner_id.def_id;\n+                        let generics = tcx.generics_of(def_id);\n+                        let own_counts = generics.own_counts();\n+                        if generics.params.len() - own_counts.lifetimes != 0 {\n+                            let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts)\n+                            {\n+                                (_, 0) => (\"type\", \"types\", Some(\"u32\")),\n+                                // We don't specify an example value, because we can't generate\n+                                // a valid value for any type.\n+                                (0, _) => (\"const\", \"consts\", None),\n+                                _ => (\"type or const\", \"types or consts\", None),\n+                            };\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                item.span,\n+                                E0044,\n+                                \"foreign items may not have {kinds} parameters\",\n+                            )\n+                            .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n+                            .help(\n+                                // FIXME: once we start storing spans for type arguments, turn this\n+                                // into a suggestion.\n+                                &format!(\n+                                    \"replace the {} parameters with concrete {}{}\",\n+                                    kinds,\n+                                    kinds_pl,\n+                                    egs.map(|egs| format!(\" like `{}`\", egs)).unwrap_or_default(),\n+                                ),\n+                            )\n+                            .emit();\n                         }\n-                        hir::ForeignItemKind::Static(..) => {\n-                            check_static_inhabited(tcx, def_id);\n-                            check_static_linkage(tcx, def_id);\n+\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        match &item.kind {\n+                            hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n+                                require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n+                            }\n+                            hir::ForeignItemKind::Static(..) => {\n+                                check_static_inhabited(tcx, def_id);\n+                                check_static_linkage(tcx, def_id);\n+                            }\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "0b30bf957a3d3dba303edeb2da613d44411c84e6", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -1354,13 +1354,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        applicable_candidates.pop().map(|(probe, status)| {\n-            if status == ProbeResult::Match {\n+        applicable_candidates.pop().map(|(probe, status)| match status {\n+            ProbeResult::Match => {\n                 Ok(probe\n                     .to_unadjusted_pick(self_ty, unstable_candidates.cloned().unwrap_or_default()))\n-            } else {\n-                Err(MethodError::BadReturnType)\n             }\n+            ProbeResult::NoMatch | ProbeResult::BadReturnType => Err(MethodError::BadReturnType),\n         })\n     }\n }"}, {"sha": "697e90fdaa95aba13d8a08ce1f6145aa6c30112a", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -580,27 +580,28 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n-        // If the method is an impl for a trait, don't doc.\n         let context = method_context(cx, impl_item.owner_id.def_id);\n-        if context == MethodLateContext::TraitImpl {\n-            return;\n-        }\n-\n-        // If the method is an impl for an item with docs_hidden, don't doc.\n-        if context == MethodLateContext::PlainImpl {\n-            let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n-            let impl_ty = cx.tcx.type_of(parent);\n-            let outerdef = match impl_ty.kind() {\n-                ty::Adt(def, _) => Some(def.did()),\n-                ty::Foreign(def_id) => Some(*def_id),\n-                _ => None,\n-            };\n-            let is_hidden = match outerdef {\n-                Some(id) => cx.tcx.is_doc_hidden(id),\n-                None => false,\n-            };\n-            if is_hidden {\n-                return;\n+        \n+        match context {\n+            // If the method is an impl for a trait, don't doc.\n+            MethodLateContext::TraitImpl => return,\n+            MethodLateContext::TraitAutoImpl => {}\n+            // If the method is an impl for an item with docs_hidden, don't doc.\n+            MethodLateContext::PlainImpl => {\n+                let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n+                let impl_ty = cx.tcx.type_of(parent);\n+                let outerdef = match impl_ty.kind() {\n+                    ty::Adt(def, _) => Some(def.did()),\n+                    ty::Foreign(def_id) => Some(*def_id),\n+                    _ => None,\n+                };\n+                let is_hidden = match outerdef {\n+                    Some(id) => cx.tcx.is_doc_hidden(id),\n+                    None => false,\n+                };\n+                if is_hidden {\n+                    return;\n+                }\n             }\n         }\n "}, {"sha": "39ef4276faf10360b96efa1eda9a5f504cee1b6b", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -113,37 +113,37 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         CrateType::Staticlib => Linkage::Static,\n     };\n \n-    if preferred_linkage == Linkage::NotLinked {\n+    match preferred_linkage {\n         // If the crate is not linked, there are no link-time dependencies.\n-        return Vec::new();\n-    }\n-\n-    if preferred_linkage == Linkage::Static {\n-        // Attempt static linkage first. For dylibs and executables, we may be\n-        // able to retry below with dynamic linkage.\n-        if let Some(v) = attempt_static(tcx) {\n-            return v;\n-        }\n+        Linkage::NotLinked => return Vec::new(),\n+        Linkage::Static => {\n+            // Attempt static linkage first. For dylibs and executables, we may be\n+            // able to retry below with dynamic linkage.\n+            if let Some(v) = attempt_static(tcx) {\n+                return v;\n+            }\n \n-        // Staticlibs and static executables must have all static dependencies.\n-        // If any are not found, generate some nice pretty errors.\n-        if ty == CrateType::Staticlib\n-            || (ty == CrateType::Executable\n-                && sess.crt_static(Some(ty))\n-                && !sess.target.crt_static_allows_dylibs)\n-        {\n-            for &cnum in tcx.crates(()).iter() {\n-                if tcx.dep_kind(cnum).macros_only() {\n-                    continue;\n+            // Staticlibs and static executables must have all static dependencies.\n+            // If any are not found, generate some nice pretty errors.\n+            if ty == CrateType::Staticlib\n+                || (ty == CrateType::Executable\n+                    && sess.crt_static(Some(ty))\n+                    && !sess.target.crt_static_allows_dylibs)\n+            {\n+                for &cnum in tcx.crates(()).iter() {\n+                    if tcx.dep_kind(cnum).macros_only() {\n+                        continue;\n+                    }\n+                    let src = tcx.used_crate_source(cnum);\n+                    if src.rlib.is_some() {\n+                        continue;\n+                    }\n+                    sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum) });\n                 }\n-                let src = tcx.used_crate_source(cnum);\n-                if src.rlib.is_some() {\n-                    continue;\n-                }\n-                sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum) });\n+                return Vec::new();\n             }\n-            return Vec::new();\n         }\n+        Linkage::Dynamic | Linkage::IncludedFromDylib => {}\n     }\n \n     let mut formats = FxHashMap::default();\n@@ -283,12 +283,9 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     let mut ret = tcx\n         .crates(())\n         .iter()\n-        .map(|&cnum| {\n-            if tcx.dep_kind(cnum) == CrateDepKind::Explicit {\n-                Linkage::Static\n-            } else {\n-                Linkage::NotLinked\n-            }\n+        .map(|&cnum| match tcx.dep_kind(cnum) {\n+            CrateDepKind::Explicit => Linkage::Static,\n+            CrateDepKind::MacrosOnly | CrateDepKind::Implicit => Linkage::NotLinked,\n         })\n         .collect::<Vec<_>>();\n "}, {"sha": "db24dae11304f6ec0d84ccba748f05e6e730ddc0", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -135,7 +135,10 @@ impl Debug for CoverageKind {\n                 \"Expression({:?}) = {} {} {}\",\n                 id.index(),\n                 lhs.index(),\n-                if *op == Op::Add { \"+\" } else { \"-\" },\n+                match op {\n+                    Op::Add => \"+\",\n+                    Op::Subtract => \"-\",\n+                },\n                 rhs.index(),\n             ),\n             Unreachable => write!(fmt, \"Unreachable\"),"}, {"sha": "22ea8710e6a96204efe13ead400e7442b9311a5e", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -323,7 +323,10 @@ impl DebugCounters {\n                         String::new()\n                     },\n                     self.format_operand(lhs),\n-                    if op == Op::Add { \"+\" } else { \"-\" },\n+                    match op {\n+                        Op::Add => \"+\",\n+                        Op::Subtract => \"-\",\n+                    },\n                     self.format_operand(rhs),\n                 );\n             }"}, {"sha": "58c7a398f14252e3e2ac7cd4bcf79c16b9049ab6", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -93,11 +93,12 @@ impl<'a> Parser<'a> {\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path.\n             // Also, we avoid stealing syntax from `parse_item_`.\n-            if force_collect == ForceCollect::Yes {\n-                self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))\n-            } else {\n-                self.parse_stmt_path_start(lo, attrs)\n-            }?\n+            match force_collect {\n+                ForceCollect::Yes => {\n+                    self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))?\n+                }\n+                ForceCollect::No => self.parse_stmt_path_start(lo, attrs)?,\n+            }\n         } else if let Some(item) = self.parse_item_common(\n             attrs.clone(),\n             false,\n@@ -113,13 +114,12 @@ impl<'a> Parser<'a> {\n             self.mk_stmt(lo, StmtKind::Empty)\n         } else if self.token != token::CloseDelim(Delimiter::Brace) {\n             // Remainder are line-expr stmts.\n-            let e = if force_collect == ForceCollect::Yes {\n-                self.collect_tokens_no_attrs(|this| {\n+            let e = match force_collect {\n+                ForceCollect::Yes => self.collect_tokens_no_attrs(|this| {\n                     this.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n-                })\n-            } else {\n-                self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n-            }?;\n+                })?,\n+                ForceCollect::No => self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))?,\n+            };\n             if matches!(e.kind, ExprKind::Assign(..)) && self.eat_keyword(kw::Else) {\n                 let bl = self.parse_block()?;\n                 // Destructuring assignment ... else."}, {"sha": "8b4f0ab8feb848a0008a9a212aae65bbc0f332ec", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -323,13 +323,14 @@ impl<'a> Parser<'a> {\n         } else if self.can_begin_bound() {\n             self.parse_bare_trait_object(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n-            if allow_c_variadic == AllowCVariadic::Yes {\n-                TyKind::CVarArgs\n-            } else {\n-                // FIXME(Centril): Should we just allow `...` syntactically\n-                // anywhere in a type and use semantic restrictions instead?\n-                self.error_illegal_c_varadic_ty(lo);\n-                TyKind::Err\n+            match allow_c_variadic {\n+                AllowCVariadic::Yes => TyKind::CVarArgs,\n+                AllowCVariadic::No => {\n+                    // FIXME(Centril): Should we just allow `...` syntactically\n+                    // anywhere in a type and use semantic restrictions instead?\n+                    self.error_illegal_c_varadic_ty(lo);\n+                    TyKind::Err\n+                }\n             }\n         } else {\n             let msg = format!(\"expected type, found {}\", super::token_descr(&self.token));\n@@ -343,10 +344,9 @@ impl<'a> Parser<'a> {\n         let mut ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n-        if allow_plus == AllowPlus::Yes {\n-            self.maybe_recover_from_bad_type_plus(&ty)?;\n-        } else {\n-            self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty);\n+        match allow_plus {\n+            AllowPlus::Yes => self.maybe_recover_from_bad_type_plus(&ty)?,\n+            AllowPlus::No => self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty),\n         }\n         if RecoverQuestionMark::Yes == recover_question_mark {\n             ty = self.maybe_recover_from_question_mark(ty);"}, {"sha": "d67d52da497468b5d2f484aa896fd94d6ef21167", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -864,33 +864,39 @@ impl CheckAttrVisitor<'_> {\n         target: Target,\n         specified_inline: &mut Option<(bool, Span)>,\n     ) -> bool {\n-        if target == Target::Use || target == Target::ExternCrate {\n-            let do_inline = meta.name_or_empty() == sym::inline;\n-            if let Some((prev_inline, prev_span)) = *specified_inline {\n-                if do_inline != prev_inline {\n-                    let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n-                    spans.push_span_label(prev_span, fluent::passes_doc_inline_conflict_first);\n-                    spans.push_span_label(meta.span(), fluent::passes_doc_inline_conflict_second);\n-                    self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n-                    return false;\n+        match target {\n+            Target::Use | Target::ExternCrate => {\n+                let do_inline = meta.name_or_empty() == sym::inline;\n+                if let Some((prev_inline, prev_span)) = *specified_inline {\n+                    if do_inline != prev_inline {\n+                        let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n+                        spans.push_span_label(prev_span, fluent::passes_doc_inline_conflict_first);\n+                        spans.push_span_label(\n+                            meta.span(),\n+                            fluent::passes_doc_inline_conflict_second,\n+                        );\n+                        self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n+                        return false;\n+                    }\n+                    true\n+                } else {\n+                    *specified_inline = Some((do_inline, meta.span()));\n+                    true\n                 }\n-                true\n-            } else {\n-                *specified_inline = Some((do_inline, meta.span()));\n-                true\n             }\n-        } else {\n-            self.tcx.emit_spanned_lint(\n-                INVALID_DOC_ATTRIBUTES,\n-                hir_id,\n-                meta.span(),\n-                errors::DocInlineOnlyUse {\n-                    attr_span: meta.span(),\n-                    item_span: (attr.style == AttrStyle::Outer)\n-                        .then(|| self.tcx.hir().span(hir_id)),\n-                },\n-            );\n-            false\n+            _ => {\n+                self.tcx.emit_spanned_lint(\n+                    INVALID_DOC_ATTRIBUTES,\n+                    hir_id,\n+                    meta.span(),\n+                    errors::DocInlineOnlyUse {\n+                        attr_span: meta.span(),\n+                        item_span: (attr.style == AttrStyle::Outer)\n+                            .then(|| self.tcx.hir().span(hir_id)),\n+                    },\n+                );\n+                false\n+            }\n         }\n     }\n \n@@ -1137,7 +1143,7 @@ impl CheckAttrVisitor<'_> {\n                                     errors::DocTestUnknownInclude {\n                                         path,\n                                         value: value.to_string(),\n-                                        inner: if attr.style == AttrStyle::Inner { \"!\" } else { \"\" },\n+                                        inner: match attr.style { AttrStyle::Inner=>  \"!\" , AttrStyle::Outer => \"\" },\n                                         sugg: (attr.meta().unwrap().span, applicability),\n                                     }\n                                 );"}, {"sha": "84421dc1f62253354794e3b8079c190213e7d66b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -298,14 +298,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             self.r.record_partial_res(id, PartialRes::new(res));\n                         }\n                         if module.is_normal() {\n-                            if res == Res::Err {\n-                                Ok(ty::Visibility::Public)\n-                            } else {\n-                                let vis = ty::Visibility::Restricted(res.def_id());\n-                                if self.r.is_accessible_from(vis, parent_scope.module) {\n-                                    Ok(vis.expect_local())\n-                                } else {\n-                                    Err(VisResolutionError::AncestorOnly(path.span))\n+                            match res {\n+                                Res::Err => Ok(ty::Visibility::Public),\n+                                _ => {\n+                                    let vis = ty::Visibility::Restricted(res.def_id());\n+                                    if self.r.is_accessible_from(vis, parent_scope.module) {\n+                                        Ok(vis.expect_local())\n+                                    } else {\n+                                        Err(VisResolutionError::AncestorOnly(path.span))\n+                                    }\n                                 }\n                             }\n                         } else {"}, {"sha": "7375df451e89cb247b3ddeae05989c260105519f", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -1552,12 +1552,12 @@ impl<'a> Resolver<'a> {\n             if b.is_extern_crate() && ident.span.rust_2018() {\n                 help_msgs.push(format!(\"use `::{ident}` to refer to this {thing} unambiguously\"))\n             }\n-            if misc == AmbiguityErrorMisc::SuggestCrate {\n-                help_msgs\n-                    .push(format!(\"use `crate::{ident}` to refer to this {thing} unambiguously\"))\n-            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n-                help_msgs\n-                    .push(format!(\"use `self::{ident}` to refer to this {thing} unambiguously\"))\n+            match misc {\n+                AmbiguityErrorMisc::SuggestCrate => help_msgs\n+                    .push(format!(\"use `crate::{ident}` to refer to this {thing} unambiguously\")),\n+                AmbiguityErrorMisc::SuggestSelf => help_msgs\n+                    .push(format!(\"use `self::{ident}` to refer to this {thing} unambiguously\")),\n+                AmbiguityErrorMisc::FromPrelude | AmbiguityErrorMisc::None => {}\n             }\n \n             err.span_note(b.span, &note_msg);"}, {"sha": "e35ffd154bb9cb4993b6678b5b0512a0d0f64910", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd649a3cc5e9f17c8aee070227e8c71f094560b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=fd649a3cc5e9f17c8aee070227e8c71f094560b7", "patch": "@@ -1230,20 +1230,23 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     }\n \n                     ty::PredicateKind::WellFormed(ty) => {\n-                        if self.tcx.sess.opts.unstable_opts.trait_solver == TraitSolver::Classic {\n-                            // WF predicates cannot themselves make\n-                            // errors. They can only block due to\n-                            // ambiguity; otherwise, they always\n-                            // degenerate into other obligations\n-                            // (which may fail).\n-                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                        } else {\n-                            // FIXME: we'll need a better message which takes into account\n-                            // which bounds actually failed to hold.\n-                            self.tcx.sess.struct_span_err(\n-                                span,\n-                                &format!(\"the type `{}` is not well-formed\", ty),\n-                            )\n+                        match self.tcx.sess.opts.unstable_opts.trait_solver {\n+                            TraitSolver::Classic => {\n+                                // WF predicates cannot themselves make\n+                                // errors. They can only block due to\n+                                // ambiguity; otherwise, they always\n+                                // degenerate into other obligations\n+                                // (which may fail).\n+                                span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                            }\n+                            TraitSolver::Chalk | TraitSolver::Next => {\n+                                // FIXME: we'll need a better message which takes into account\n+                                // which bounds actually failed to hold.\n+                                self.tcx.sess.struct_span_err(\n+                                    span,\n+                                    &format!(\"the type `{}` is not well-formed\", ty),\n+                                )\n+                            }\n                         }\n                     }\n "}]}