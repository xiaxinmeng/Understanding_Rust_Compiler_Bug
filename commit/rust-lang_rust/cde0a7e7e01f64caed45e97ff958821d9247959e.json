{"sha": "cde0a7e7e01f64caed45e97ff958821d9247959e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZTBhN2U3ZTAxZjY0Y2FlZDQ1ZTk3ZmY5NTg4MjFkOTI0Nzk1OWU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-04T02:01:58Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-06T20:23:29Z"}, "message": "rustc: store ty::Tables separately for each body (except closures').", "tree": {"sha": "726fb0b8ac8158e87b779d7fbc43bcca4bc5643b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/726fb0b8ac8158e87b779d7fbc43bcca4bc5643b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cde0a7e7e01f64caed45e97ff958821d9247959e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cde0a7e7e01f64caed45e97ff958821d9247959e", "html_url": "https://github.com/rust-lang/rust/commit/cde0a7e7e01f64caed45e97ff958821d9247959e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cde0a7e7e01f64caed45e97ff958821d9247959e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85a4a192c73f3b1f6c0d4c6fcb54532a8f820122", "url": "https://api.github.com/repos/rust-lang/rust/commits/85a4a192c73f3b1f6c0d4c6fcb54532a8f820122", "html_url": "https://github.com/rust-lang/rust/commit/85a4a192c73f3b1f6c0d4c6fcb54532a8f820122"}], "stats": {"total": 694, "additions": 220, "deletions": 474}, "files": [{"sha": "a68876b5ae9c0b6bdbe03bc862f5727317c75b14", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -113,6 +113,7 @@ pub enum DepNode<D: Clone + Debug> {\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n+    Tables(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -162,6 +163,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemSignature,\n             AssociatedItemDefIds,\n             InherentImpls,\n+            Tables,\n             TraitImpls,\n             ReprHints,\n         }\n@@ -230,6 +232,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n+            Tables(ref d) => op(d).map(Tables),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "bd0ff695d093a518ca58c395b59953f5cf477fc0", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -23,10 +23,6 @@ pub struct NodeCollector<'ast> {\n     pub(super) map: Vec<MapEntry<'ast>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n-    /// If true, completely ignore nested items. We set this when loading\n-    /// HIR from metadata, since in that case we only want the HIR for\n-    /// one specific item (and not the ones nested inside of it).\n-    pub ignore_nested_items: bool\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -35,30 +31,12 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n-            ignore_nested_items: false\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n \n         collector\n     }\n \n-    pub(super) fn extend(krate: &'ast Crate,\n-                         parent: &'ast InlinedItem,\n-                         parent_node: NodeId,\n-                         map: Vec<MapEntry<'ast>>)\n-                         -> NodeCollector<'ast> {\n-        let mut collector = NodeCollector {\n-            krate: krate,\n-            map: map,\n-            parent_node: parent_node,\n-            ignore_nested_items: true\n-        };\n-\n-        collector.insert_entry(parent_node, RootInlinedParent(parent));\n-\n-        collector\n-    }\n-\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n@@ -92,27 +70,19 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        if !self.ignore_nested_items {\n-            self.visit_item(self.krate.item(item.id))\n-        }\n+        self.visit_item(self.krate.item(item.id));\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        if !self.ignore_nested_items {\n-            self.visit_trait_item(self.krate.trait_item(item_id))\n-        }\n+        self.visit_trait_item(self.krate.trait_item(item_id));\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        if !self.ignore_nested_items {\n-            self.visit_impl_item(self.krate.impl_item(item_id))\n-        }\n+        self.visit_impl_item(self.krate.impl_item(item_id));\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        if !self.ignore_nested_items {\n-            self.visit_body(self.krate.body(id))\n-        }\n+        self.visit_body(self.krate.body(id));\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {"}, {"sha": "7c0621279fd6f607f26e0675ec4484c8886db298", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 79, "deletions": 163, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -25,28 +25,18 @@ use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n-use hir::intravisit::Visitor;\n use hir::print::Nested;\n+use util::nodemap::DefIdMap;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n use std::io;\n-use std::mem;\n \n pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n \n-/// The data we save and restore about an inlined item or method.  This is not\n-/// part of the AST that we parse from a file, but it becomes part of the tree\n-/// that we trans.\n-#[derive(Debug)]\n-struct InlinedItem {\n-    def_id: DefId,\n-    body: Body,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n@@ -99,7 +89,6 @@ enum MapEntry<'ast> {\n \n     /// Roots for node trees.\n     RootCrate,\n-    RootInlinedParent(&'ast InlinedItem)\n }\n \n impl<'ast> Clone for MapEntry<'ast> {\n@@ -152,8 +141,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryVisibility(id, _) => id,\n \n             NotPresent |\n-            RootCrate |\n-            RootInlinedParent(_) => return None,\n+            RootCrate => return None,\n         })\n     }\n \n@@ -225,15 +213,15 @@ impl<'ast> MapEntry<'ast> {\n pub struct Forest {\n     krate: Crate,\n     pub dep_graph: DepGraph,\n-    inlined_items: TypedArena<InlinedItem>\n+    inlined_bodies: TypedArena<Body>\n }\n \n impl Forest {\n     pub fn new(krate: Crate, dep_graph: &DepGraph) -> Forest {\n         Forest {\n             krate: krate,\n             dep_graph: dep_graph.clone(),\n-            inlined_items: TypedArena::new()\n+            inlined_bodies: TypedArena::new()\n         }\n     }\n \n@@ -263,20 +251,15 @@ pub struct Map<'ast> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: RefCell<Vec<MapEntry<'ast>>>,\n+    map: Vec<MapEntry<'ast>>,\n \n     definitions: Definitions,\n \n-    /// All NodeIds that are numerically greater or equal to this value come\n-    /// from inlined items.\n-    local_node_id_watermark: NodeId,\n+    /// Bodies inlined from other crates are cached here.\n+    inlined_bodies: RefCell<DefIdMap<&'ast Body>>,\n }\n \n impl<'ast> Map<'ast> {\n-    pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n-        id >= self.local_node_id_watermark\n-    }\n-\n     /// Registers a read in the dependency graph of the AST node with\n     /// the given `id`. This needs to be called each time a public\n     /// function returns the HIR for a node -- in other words, when it\n@@ -289,111 +272,71 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n-        let map = self.map.borrow();\n         let mut id = id0;\n-        if !self.is_inlined_node_id(id) {\n-            let mut last_expr = None;\n-            loop {\n-                let entry = map[id.as_usize()];\n-                match entry {\n-                    EntryItem(..) |\n-                    EntryTraitItem(..) |\n-                    EntryImplItem(..) => {\n-                        if let Some(last_id) = last_expr {\n-                            // The body may have a separate dep node\n-                            if entry.is_body_owner(last_id) {\n-                                let def_id = self.local_def_id(id);\n-                                return DepNode::HirBody(def_id);\n-                            }\n+        let mut last_expr = None;\n+        loop {\n+            let entry = self.map[id.as_usize()];\n+            match entry {\n+                EntryItem(..) |\n+                EntryTraitItem(..) |\n+                EntryImplItem(..) => {\n+                    if let Some(last_id) = last_expr {\n+                        // The body may have a separate dep node\n+                        if entry.is_body_owner(last_id) {\n+                            let def_id = self.local_def_id(id);\n+                            return DepNode::HirBody(def_id);\n                         }\n-                        return DepNode::Hir(self.local_def_id(id));\n                     }\n+                    return DepNode::Hir(self.local_def_id(id));\n+                }\n \n-                    EntryVariant(p, v) => {\n-                        id = p;\n+                EntryVariant(p, v) => {\n+                    id = p;\n \n-                        if last_expr.is_some() {\n-                            if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n-                                // The enum parent holds both Hir and HirBody nodes.\n-                                let def_id = self.local_def_id(id);\n-                                return DepNode::HirBody(def_id);\n-                            }\n+                    if last_expr.is_some() {\n+                        if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n+                            // The enum parent holds both Hir and HirBody nodes.\n+                            let def_id = self.local_def_id(id);\n+                            return DepNode::HirBody(def_id);\n                         }\n                     }\n+                }\n \n-                    EntryForeignItem(p, _) |\n-                    EntryField(p, _) |\n-                    EntryStmt(p, _) |\n-                    EntryTy(p, _) |\n-                    EntryTraitRef(p, _) |\n-                    EntryLocal(p, _) |\n-                    EntryPat(p, _) |\n-                    EntryBlock(p, _) |\n-                    EntryStructCtor(p, _) |\n-                    EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) |\n-                    EntryVisibility(p, _) =>\n-                        id = p,\n-\n-                    EntryExpr(p, _) => {\n-                        last_expr = Some(id);\n-                        id = p;\n-                    }\n-\n-                    RootCrate => {\n-                        return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n-                    }\n-\n-                    RootInlinedParent(_) =>\n-                        bug!(\"node {} has inlined ancestor but is not inlined\", id0),\n-\n-                    NotPresent =>\n-                        // Some nodes, notably macro definitions, are not\n-                        // present in the map for whatever reason, but\n-                        // they *do* have def-ids. So if we encounter an\n-                        // empty hole, check for that case.\n-                        return self.opt_local_def_id(id)\n-                                   .map(|def_id| DepNode::Hir(def_id))\n-                                   .unwrap_or_else(|| {\n-                                       bug!(\"Walking parents from `{}` \\\n-                                             led to `NotPresent` at `{}`\",\n-                                            id0, id)\n-                                   }),\n+                EntryForeignItem(p, _) |\n+                EntryField(p, _) |\n+                EntryStmt(p, _) |\n+                EntryTy(p, _) |\n+                EntryTraitRef(p, _) |\n+                EntryLocal(p, _) |\n+                EntryPat(p, _) |\n+                EntryBlock(p, _) |\n+                EntryStructCtor(p, _) |\n+                EntryLifetime(p, _) |\n+                EntryTyParam(p, _) |\n+                EntryVisibility(p, _) =>\n+                    id = p,\n+\n+                EntryExpr(p, _) => {\n+                    last_expr = Some(id);\n+                    id = p;\n                 }\n-            }\n-        } else {\n-            // reading from an inlined def-id is really a read out of\n-            // the metadata from which we loaded the item.\n-            loop {\n-                match map[id.as_usize()] {\n-                    EntryItem(p, _) |\n-                    EntryForeignItem(p, _) |\n-                    EntryTraitItem(p, _) |\n-                    EntryImplItem(p, _) |\n-                    EntryVariant(p, _) |\n-                    EntryField(p, _) |\n-                    EntryExpr(p, _) |\n-                    EntryStmt(p, _) |\n-                    EntryTy(p, _) |\n-                    EntryTraitRef(p, _) |\n-                    EntryLocal(p, _) |\n-                    EntryPat(p, _) |\n-                    EntryBlock(p, _) |\n-                    EntryStructCtor(p, _) |\n-                    EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) |\n-                    EntryVisibility(p, _) =>\n-                        id = p,\n-\n-                    RootInlinedParent(parent) =>\n-                        return DepNode::MetaData(parent.def_id),\n-\n-                    RootCrate =>\n-                        bug!(\"node {} has crate ancestor but is inlined\", id0),\n-\n-                    NotPresent =>\n-                        bug!(\"node {} is inlined but not present in map\", id0),\n+\n+                RootCrate => {\n+                    return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n                 }\n+\n+                NotPresent =>\n+                    // Some nodes, notably macro definitions, are not\n+                    // present in the map for whatever reason, but\n+                    // they *do* have def-ids. So if we encounter an\n+                    // empty hole, check for that case.\n+                    return self.opt_local_def_id(id)\n+                               .map(|def_id| DepNode::Hir(def_id))\n+                               .unwrap_or_else(|| {\n+                                   bug!(\"Walking parents from `{}` \\\n+                                         led to `NotPresent` at `{}`\",\n+                                        id0, id)\n+                               }),\n             }\n         }\n     }\n@@ -442,11 +385,11 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn entry_count(&self) -> usize {\n-        self.map.borrow().len()\n+        self.map.len()\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id.as_usize()).cloned()\n+        self.map.get(id.as_usize()).cloned()\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -483,7 +426,7 @@ impl<'ast> Map<'ast> {\n     /// for embedded constant expressions (e.g. `N` in `[T; N]`).\n     pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node(node_id);\n-        if self.map.borrow()[parent.as_usize()].is_body_owner(node_id) {\n+        if self.map[parent.as_usize()].is_body_owner(node_id) {\n             parent\n         } else {\n             node_id\n@@ -644,11 +587,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n-        let parent = self.get_parent(id);\n-        match self.find_entry(parent) {\n-            Some(RootInlinedParent(ii)) => ii.def_id,\n-            _ => self.local_def_id(parent)\n-        }\n+        self.local_def_id(self.get_parent(id))\n     }\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n@@ -660,8 +599,6 @@ impl<'ast> Map<'ast> {\n                     _ => None\n                 }\n             }\n-            /// Wrong but OK, because the only inlined foreign items are intrinsics.\n-            Some(RootInlinedParent(_)) => Some(Abi::RustIntrinsic),\n             _ => None\n         };\n         match abi {\n@@ -737,11 +674,17 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_inlined_body(&self, id: NodeId) -> &'ast Body {\n-        match self.find_entry(id) {\n-            Some(RootInlinedParent(inlined_item)) => &inlined_item.body,\n-            _ => bug!(\"expected inlined item, found {}\", self.node_to_string(id)),\n-        }\n+    pub fn get_inlined_body(&self, def_id: DefId) -> Option<&'ast Body> {\n+        self.inlined_bodies.borrow().get(&def_id).map(|&body| {\n+            self.dep_graph.read(DepNode::MetaData(def_id));\n+            body\n+        })\n+    }\n+\n+    pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'ast Body {\n+        let body = self.forest.inlined_bodies.alloc(body);\n+        self.inlined_bodies.borrow_mut().insert(def_id, body);\n+        body\n     }\n \n     /// Returns the name associated with the given NodeId's AST.\n@@ -824,7 +767,6 @@ impl<'ast> Map<'ast> {\n             Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n \n             Some(RootCrate) => self.forest.krate.span,\n-            Some(RootInlinedParent(parent)) => parent.body.value.span,\n             Some(NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n@@ -973,41 +915,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    let local_node_id_watermark = NodeId::new(map.len());\n-\n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n-        map: RefCell::new(map),\n+        map: map,\n         definitions: definitions,\n-        local_node_id_watermark: local_node_id_watermark,\n+        inlined_bodies: RefCell::new(DefIdMap()),\n     }\n }\n \n-/// Used for bodies loaded from external crate that are being inlined into this\n-/// crate.\n-pub fn map_decoded_body<'ast>(map: &Map<'ast>,\n-                              def_id: DefId,\n-                              body: Body,\n-                              parent_id: NodeId)\n-                              -> &'ast Body {\n-    let _ignore = map.forest.dep_graph.in_ignore();\n-\n-    let ii = map.forest.inlined_items.alloc(InlinedItem {\n-        def_id: def_id,\n-        body: body\n-    });\n-\n-    let mut collector = NodeCollector::extend(map.krate(),\n-                                              ii,\n-                                              parent_id,\n-                                              mem::replace(&mut *map.map.borrow_mut(), vec![]));\n-    collector.visit_body(&ii.body);\n-    *map.map.borrow_mut() = collector.map;\n-\n-    &ii.body\n-}\n-\n /// Identical to the `PpAnn` implementation for `hir::Crate`,\n /// except it avoids creating a dependency on the whole crate.\n impl<'ast> print::PpAnn for Map<'ast> {"}, {"sha": "3df64ebd1581b66237b088c3d5d7d30f473e531f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -65,6 +65,7 @@ pub struct GlobalArenas<'tcx> {\n     trait_def: TypedArena<ty::TraitDef>,\n     adt_def: TypedArena<ty::AdtDef>,\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n+    tables: TypedArena<ty::Tables<'tcx>>,\n }\n \n impl<'tcx> GlobalArenas<'tcx> {\n@@ -75,6 +76,7 @@ impl<'tcx> GlobalArenas<'tcx> {\n             trait_def: TypedArena::new(),\n             adt_def: TypedArena::new(),\n             mir: TypedArena::new(),\n+            tables: TypedArena::new(),\n         }\n     }\n }\n@@ -189,6 +191,7 @@ pub struct CommonTypes<'tcx> {\n     pub err: Ty<'tcx>,\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Tables<'tcx> {\n     /// Resolved definitions for `<T>::X` associated paths.\n     pub type_relative_path_defs: NodeMap<Def>,\n@@ -399,7 +402,7 @@ pub struct GlobalCtxt<'tcx> {\n     free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n     // FIXME: jroesch make this a refcell\n \n-    pub tables: RefCell<Tables<'tcx>>,\n+    pub tables: RefCell<DepTrackingMap<maps::Tables<'tcx>>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n     pub associated_items: RefCell<DepTrackingMap<maps::AssociatedItems<'tcx>>>,\n@@ -651,6 +654,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.mir.alloc(RefCell::new(mir))\n     }\n \n+    pub fn alloc_tables(self, tables: ty::Tables<'gcx>) -> &'gcx ty::Tables<'gcx> {\n+        self.global_arenas.tables.alloc(tables)\n+    }\n+\n     pub fn alloc_trait_def(self, def: ty::TraitDef) -> &'gcx ty::TraitDef {\n         self.global_arenas.trait_def.alloc(def)\n     }\n@@ -749,7 +756,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             variance_computed: Cell::new(false),\n             sess: s,\n             trait_map: resolutions.trait_map,\n-            tables: RefCell::new(Tables::empty()),\n+            tables: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "59d22d270b15d49f946af7ec5b272586d8078ea4", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -48,3 +48,4 @@ dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }\n dep_map_ty! { ClosureKinds: ItemSignature(DefId) -> ty::ClosureKind }\n dep_map_ty! { ClosureTypes: ItemSignature(DefId) -> ty::ClosureTy<'tcx> }\n+dep_map_ty! { Tables: Tables(DefId) -> &'tcx ty::Tables<'tcx> }"}, {"sha": "a88b1e3ece9641b1ffdc80bf44ad9edb0b780246", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -321,7 +321,7 @@ pub struct MethodCallee<'tcx> {\n /// needed to add to the side tables. Thus to disambiguate\n /// we also keep track of whether there's an adjustment in\n /// our key.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct MethodCall {\n     pub expr_id: NodeId,\n     pub autoderef: u32\n@@ -501,7 +501,7 @@ impl<T> Slice<T> {\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n     pub var_id: NodeId,\n     pub closure_expr_id: NodeId,\n@@ -1917,19 +1917,30 @@ impl BorrowKind {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn tables(self) -> Ref<'a, Tables<'gcx>> {\n-        self.tables.borrow()\n-    }\n-\n-    pub fn body_tables(self, body: hir::BodyId) -> &'a Tables<'gcx> {\n+    pub fn body_tables(self, body: hir::BodyId) -> &'gcx Tables<'gcx> {\n         self.item_tables(self.map.body_owner_def_id(body))\n     }\n \n-    pub fn item_tables(self, _def_id: DefId) -> &'a Tables<'gcx> {\n-        // HACK(eddyb) temporarily work around RefCell until proper per-body tables\n-        unsafe {\n-            mem::transmute::<&Tables, &Tables>(&self.tables())\n-        }\n+    pub fn item_tables(self, def_id: DefId) -> &'gcx Tables<'gcx> {\n+        self.tables.memoize(def_id, || {\n+            if def_id.is_local() {\n+                // Closures' tables come from their outermost function,\n+                // as they are part of the same \"inference environment\".\n+                let outer_def_id = self.closure_base_def_id(def_id);\n+                if outer_def_id != def_id {\n+                    return self.item_tables(outer_def_id);\n+                }\n+\n+                bug!(\"No def'n found for {:?} in tcx.tables\", def_id);\n+            }\n+\n+            // Cross-crate side-tables only exist alongside serialized HIR.\n+            self.sess.cstore.maybe_get_item_body(self.global_tcx(), def_id).map(|_| {\n+                self.tables.borrow()[&def_id]\n+            }).unwrap_or_else(|| {\n+                bug!(\"tcx.item_tables({:?}): missing from metadata\", def_id)\n+            })\n+        })\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {"}, {"sha": "bc72c8fb9b6fe14eb2cb71b9041a71be6fdc4500", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -52,21 +52,20 @@ macro_rules! math {\n \n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant_def: DefId)\n-                                  -> Option<(&'tcx Expr, &'a ty::Tables<'tcx>)> {\n+                                  -> Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>)> {\n     if let Some(variant_node_id) = tcx.map.as_local_node_id(variant_def) {\n         let enum_node_id = tcx.map.get_parent(variant_node_id);\n         if let Some(ast_map::NodeItem(it)) = tcx.map.find(enum_node_id) {\n-            match it.node {\n-                hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n-                    for variant in variants {\n-                        if variant.node.data.id() == variant_node_id {\n-                            return variant.node.disr_expr.map(|e| {\n-                                (&tcx.map.body(e).value, tcx.body_tables(e))\n-                            });\n-                        }\n+            if let hir::ItemEnum(ref edef, _) = it.node {\n+                for variant in &edef.variants {\n+                    if variant.node.data.id() == variant_node_id {\n+                        return variant.node.disr_expr.map(|e| {\n+                            let def_id = tcx.map.body_owner_def_id(e);\n+                            (&tcx.map.body(e).value,\n+                             tcx.tables.borrow().get(&def_id).cloned())\n+                        });\n                     }\n                 }\n-                _ => {}\n             }\n         }\n     }\n@@ -81,7 +80,8 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n                                         substs: Option<&'tcx Substs<'tcx>>)\n-                                        -> Option<(&'tcx Expr, &'a ty::Tables<'tcx>,\n+                                        -> Option<(&'tcx Expr,\n+                                                   Option<&'a ty::Tables<'tcx>>,\n                                                    Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n@@ -92,7 +92,8 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Some(ast_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Const(ref ty, body), ..\n             })) => {\n-                Some((&tcx.map.body(body).value, tcx.item_tables(def_id),\n+                Some((&tcx.map.body(body).value,\n+                      tcx.tables.borrow().get(&def_id).cloned(),\n                       tcx.ast_ty_to_prim_ty(ty)))\n             }\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n@@ -104,7 +105,8 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let trait_id = tcx.map.get_parent(node_id);\n                         let trait_id = tcx.map.local_def_id(trait_id);\n                         let default_value = default.map(|body| {\n-                            (&tcx.map.body(body).value, tcx.item_tables(def_id),\n+                            (&tcx.map.body(body).value,\n+                             tcx.tables.borrow().get(&def_id).cloned(),\n                              tcx.ast_ty_to_prim_ty(ty))\n                         });\n                         resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n@@ -124,7 +126,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     } else {\n         let expr_tables_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-            (&body.value, tcx.item_tables(def_id),\n+            (&body.value, Some(tcx.item_tables(def_id)),\n              Some(tcx.sess.cstore.item_type(tcx, def_id)))\n         });\n         match tcx.sess.cstore.describe_def(def_id) {\n@@ -152,20 +154,21 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> Option<(&'tcx hir::Body, &'a ty::Tables<'tcx>)>\n+                                   -> Option<(&'tcx hir::Body, Option<&'a ty::Tables<'tcx>>)>\n {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         FnLikeNode::from_node(tcx.map.get(node_id)).and_then(|fn_like| {\n             if fn_like.constness() == hir::Constness::Const {\n-                Some((tcx.map.body(fn_like.body()), tcx.body_tables(fn_like.body())))\n+                Some((tcx.map.body(fn_like.body()),\n+                      tcx.tables.borrow().get(&def_id).cloned()))\n             } else {\n                 None\n             }\n         })\n     } else {\n         if tcx.sess.cstore.is_const_fn(def_id) {\n             tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-                (body, tcx.item_tables(def_id))\n+                (body, Some(tcx.item_tables(def_id)))\n             })\n         } else {\n             None\n@@ -223,19 +226,24 @@ pub fn note_const_eval_err<'a, 'tcx>(\n \n pub struct ConstContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: &'a ty::Tables<'tcx>,\n+    tables: Option<&'a ty::Tables<'tcx>>,\n     fn_args: Option<DefIdMap<ConstVal>>\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: hir::BodyId) -> Self {\n-        ConstContext::with_tables(tcx, tcx.body_tables(body))\n+        let def_id = tcx.map.body_owner_def_id(body);\n+        ConstContext {\n+            tcx: tcx,\n+            tables: tcx.tables.borrow().get(&def_id).cloned(),\n+            fn_args: None\n+        }\n     }\n \n     pub fn with_tables(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &'a ty::Tables<'tcx>) -> Self {\n         ConstContext {\n             tcx: tcx,\n-            tables: tables,\n+            tables: Some(tables),\n             fn_args: None\n         }\n     }\n@@ -436,7 +444,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n     let ety = match ty_hint {\n         ExprTypeChecked => {\n             // After type-checking, expr_ty is guaranteed to succeed.\n-            Some(cx.tables.expr_ty(e))\n+            cx.tables.map(|tables| tables.expr_ty(e))\n         }\n         UncheckedExprHint(ty) => {\n             // Use the type hint; it's not guaranteed to be right, but it's\n@@ -447,7 +455,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             // This expression might not be type-checked, and we have no hint.\n             // Try to query the context for a type anyway; we might get lucky\n             // (for example, if the expression was imported from another crate).\n-            cx.tables.expr_ty_opt(e)\n+            cx.tables.and_then(|tables| tables.expr_ty_opt(e))\n         }\n     };\n     let result = match e.node {\n@@ -594,7 +602,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            match cx.tables.expr_ty_opt(&base) {\n+            match cx.tables.and_then(|tables| tables.expr_ty_opt(&base)) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n             }\n@@ -623,12 +631,18 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-          let def = cx.tables.qpath_def(qpath, e.id);\n+          let def = cx.tables.map(|tables| tables.qpath_def(qpath, e.id)).unwrap_or_else(|| {\n+            // There are no tables so we can only handle already-resolved HIR.\n+            match *qpath {\n+                hir::QPath::Resolved(_, ref path) => path.def,\n+                hir::QPath::TypeRelative(..) => Def::Err\n+            }\n+          });\n           match def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(cx.tables.node_id_item_substs(e.id)\n+                      Some(cx.tables.and_then(|tables| tables.node_id_item_substs(e.id))\n                         .unwrap_or_else(|| tcx.intern_substs(&[])))\n                   } else {\n                       None\n@@ -638,7 +652,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                           Some(ty) => ty_hint.checked_or(ty),\n                           None => ty_hint,\n                       };\n-                      let cx = ConstContext::with_tables(tcx, tables);\n+                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n                       match cx.eval(expr, item_hint) {\n                           Ok(val) => val,\n                           Err(err) => {\n@@ -652,7 +666,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               },\n               Def::VariantCtor(variant_def, ..) => {\n                   if let Some((expr, tables)) = lookup_variant_by_id(tcx, variant_def) {\n-                      let cx = ConstContext::with_tables(tcx, tables);\n+                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n                       match cx.eval(expr, ty_hint) {\n                           Ok(val) => val,\n                           Err(err) => {\n@@ -903,10 +917,10 @@ fn infer<'a, 'tcx>(i: ConstInt,\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_item_id: DefId,\n-    default_value: Option<(&'tcx Expr, &'a ty::Tables<'tcx>, Option<ty::Ty<'tcx>>)>,\n+    default_value: Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>, Option<ty::Ty<'tcx>>)>,\n     trait_id: DefId,\n     rcvr_substs: &'tcx Substs<'tcx>\n-) -> Option<(&'tcx Expr, &'a ty::Tables<'tcx>, Option<ty::Ty<'tcx>>)>\n+) -> Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\","}, {"sha": "fbd15b6eb103531fbd6e746ddd7c31c9de95b869", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -582,7 +582,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                     Some((const_expr, const_tables, _const_ty)) => {\n                         // Enter the inlined constant's tables temporarily.\n                         let old_tables = self.tables;\n-                        self.tables = const_tables;\n+                        self.tables = const_tables.expect(\"missing tables after typeck\");\n                         let pat = self.lower_const_expr(const_expr, pat_id, span);\n                         self.tables = old_tables;\n                         return pat;"}, {"sha": "3c14d38cc38211a6ad32612476a1d54ef28648c8", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 11, "deletions": 109, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -8,60 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::map as ast_map;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n-use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange, NestedVisitorMap};\n-\n-use cstore::CrateMetadata;\n use encoder::EncodeContext;\n use schema::*;\n \n use rustc::hir;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt, Ty};\n-\n-use syntax::ast;\n+use rustc::ty;\n \n use rustc_serialize::Encodable;\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ast<'tcx> {\n-    id_range: IdRange,\n-    body: Lazy<hir::Body>,\n-    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>,\n+    pub body: Lazy<hir::Body>,\n+    pub tables: Lazy<ty::Tables<'tcx>>,\n     pub nested_bodies: LazySeq<hir::Body>,\n     pub rvalue_promotable_to_static: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-enum TableEntry<'tcx> {\n-    TypeRelativeDef(Def),\n-    NodeType(Ty<'tcx>),\n-    ItemSubsts(ty::ItemSubsts<'tcx>),\n-    Adjustment(ty::adjustment::Adjustment<'tcx>),\n-}\n-\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    pub fn encode_body(&mut self, body: hir::BodyId) -> Lazy<Ast<'tcx>> {\n-        let body = self.tcx.map.body(body);\n-\n-        let mut id_visitor = IdRangeComputingVisitor::new(&self.tcx.map);\n-        id_visitor.visit_body(body);\n+    pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n+        let body = self.tcx.map.body(body_id);\n+        let lazy_body = self.lazy(body);\n \n-        let body_pos = self.position();\n-        body.encode(self).unwrap();\n-\n-        let tables_pos = self.position();\n-        let tables_count = {\n-            let mut visitor = SideTableEncodingIdVisitor {\n-                tables: self.tcx.body_tables(body.id()),\n-                ecx: self,\n-                count: 0,\n-            };\n-            visitor.visit_body(body);\n-            visitor.count\n-        };\n+        let tables = self.tcx.body_tables(body_id);\n+        let lazy_tables = self.lazy(tables);\n \n         let nested_pos = self.position();\n         let nested_count = {\n@@ -77,45 +48,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n \n         self.lazy(&Ast {\n-            id_range: id_visitor.result(),\n-            body: Lazy::with_position(body_pos),\n-            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count),\n+            body: lazy_body,\n+            tables: lazy_tables,\n             nested_bodies: LazySeq::with_position_and_length(nested_pos, nested_count),\n             rvalue_promotable_to_static: rvalue_promotable_to_static\n         })\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    tables: &'a ty::Tables<'tcx>,\n-    count: usize,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ecx.tcx.map)\n-    }\n-\n-    fn visit_id(&mut self, id: ast::NodeId) {\n-        debug!(\"Encoding side tables for id {}\", id);\n-\n-        let tables = self.tables;\n-        let mut encode = |entry: Option<TableEntry>| {\n-            if let Some(entry) = entry {\n-                (id, entry).encode(self.ecx).unwrap();\n-                self.count += 1;\n-            }\n-        };\n-\n-        encode(tables.type_relative_path_defs.get(&id).cloned()\n-                     .map(TableEntry::TypeRelativeDef));\n-        encode(tables.node_types.get(&id).cloned().map(TableEntry::NodeType));\n-        encode(tables.item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n-        encode(tables.adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n-    }\n-}\n-\n struct NestedBodyEncodingVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n     count: usize,\n@@ -134,41 +74,3 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedBodyEncodingVisitor<'a, 'b, 'tcx> {\n         self.visit_body(body);\n     }\n }\n-\n-/// Decodes an item's body from its AST in the cdata's metadata and adds it to the\n-/// ast-map.\n-pub fn decode_body<'a, 'tcx>(cdata: &CrateMetadata,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             def_id: DefId,\n-                             ast: Ast<'tcx>)\n-                             -> &'tcx hir::Body {\n-    debug!(\"> Decoding inlined fn: {}\", tcx.item_path_str(def_id));\n-\n-    let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n-    let start = tcx.sess.reserve_node_ids(cnt);\n-    let id_ranges = [ast.id_range,\n-                     IdRange {\n-                         min: start,\n-                         max: ast::NodeId::new(start.as_usize() + cnt),\n-                     }];\n-\n-    for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n-        match entry {\n-            TableEntry::TypeRelativeDef(def) => {\n-                tcx.tables.borrow_mut().type_relative_path_defs.insert(id, def);\n-            }\n-            TableEntry::NodeType(ty) => {\n-                tcx.tables.borrow_mut().node_types.insert(id, ty);\n-            }\n-            TableEntry::ItemSubsts(item_substs) => {\n-                tcx.tables.borrow_mut().item_substs.insert(id, item_substs);\n-            }\n-            TableEntry::Adjustment(adj) => {\n-                tcx.tables.borrow_mut().adjustments.insert(id, adj);\n-            }\n-        }\n-    }\n-\n-    let body = ast.body.decode((cdata, tcx, id_ranges));\n-    ast_map::map_decoded_body(&tcx.map, def_id, body, tcx.sess.next_node_id())\n-}"}, {"sha": "efc19abb33e1b5fdb34928a940b18eff6897c471", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -97,7 +97,6 @@ pub struct CStore {\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub inlined_item_cache: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n@@ -112,7 +111,6 @@ impl CStore {\n             statically_included_foreign_items: RefCell::new(FxHashSet()),\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n-            inlined_item_cache: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "3d025e984b0400f903e76fe76a10ff2947647da4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -434,27 +434,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                                def_id: DefId)\n                                -> Option<&'tcx hir::Body>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-\n-        if let Some(&cached) = self.inlined_item_cache.borrow().get(&def_id) {\n-            return cached.map(|root_id| {\n-                // Already inline\n-                debug!(\"maybe_get_item_body({}): already inline\", tcx.item_path_str(def_id));\n-                tcx.map.expect_inlined_body(root_id)\n-            });\n+        if let Some(cached) = tcx.map.get_inlined_body(def_id) {\n+            return Some(cached);\n         }\n \n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         debug!(\"maybe_get_item_body({}): inlining item\", tcx.item_path_str(def_id));\n \n-        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index);\n-\n-        self.inlined_item_cache.borrow_mut().insert(def_id, inlined.map(|body| {\n-            let root_id = tcx.map.get_parent_node(body.value.id);\n-            assert_eq!(tcx.map.get_parent_node(root_id), root_id);\n-            root_id\n-        }));\n-\n-        inlined\n+        self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index)\n     }\n \n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {"}, {"sha": "f3a673898b25c10c112c67b14001057f7b945a3c", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 54, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -10,13 +10,11 @@\n \n // Decoding metadata from a single crate's metadata\n \n-use astencode::decode_body;\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n-use rustc::hir::intravisit::IdRange;\n \n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n@@ -40,7 +38,7 @@ use std::u32;\n \n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n-use syntax::ast::{self, NodeId};\n+use syntax::ast;\n use syntax::codemap;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n use rustc_i128::{u128, i128};\n@@ -50,8 +48,6 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'a Session>,\n     tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n-    from_id_range: IdRange,\n-    to_id_range: IdRange,\n \n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n@@ -67,18 +63,12 @@ pub trait Metadata<'a, 'tcx>: Copy {\n     fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n-        let id_range = IdRange {\n-            min: NodeId::from_u32(u32::MIN),\n-            max: NodeId::from_u32(u32::MAX),\n-        };\n         let tcx = self.tcx();\n         DecodeContext {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n             cdata: self.cdata(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n             tcx: tcx,\n-            from_id_range: id_range,\n-            to_id_range: id_range,\n             last_filemap_index: 0,\n             lazy_state: LazyState::NoNode,\n         }\n@@ -128,26 +118,6 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>\n     }\n }\n \n-// HACK(eddyb) Only used by astencode to customize the from/to IdRange's.\n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>, [IdRange; 2]) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.0.raw_bytes()\n-    }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self.0)\n-    }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n-        Some(self.1)\n-    }\n-\n-    fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n-        let mut dcx = (self.0, self.1).decoder(pos);\n-        dcx.from_id_range = self.2[0];\n-        dcx.to_id_range = self.2[1];\n-        dcx\n-    }\n-}\n-\n impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n         let mut dcx = meta.decoder(self.position);\n@@ -256,28 +226,6 @@ impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<NodeId> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n-        let id = u32::decode(self)?;\n-\n-        // from_id_range should be non-empty\n-        assert!(!self.from_id_range.empty());\n-        // Make sure that translating the NodeId will actually yield a\n-        // meaningful result\n-        if !self.from_id_range.contains(NodeId::from_u32(id)) {\n-            bug!(\"NodeId::decode: {} out of DecodeContext range ({:?} -> {:?})\",\n-                 id,\n-                 self.from_id_range,\n-                 self.to_id_range);\n-        }\n-\n-        // Use wrapping arithmetic because otherwise it introduces control flow.\n-        // Maybe we should just have the control flow? -- aatch\n-        Ok(NodeId::from_u32(id.wrapping_sub(self.from_id_range.min.as_u32())\n-            .wrapping_add(self.to_id_range.min.as_u32())))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<CrateNum> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n         let cnum = CrateNum::from_u32(u32::decode(self)?);\n@@ -829,7 +777,14 @@ impl<'a, 'tcx> CrateMetadata {\n                                -> Option<&'tcx hir::Body> {\n         if self.is_proc_macro(id) { return None; }\n         self.entry(id).ast.map(|ast| {\n-            decode_body(self, tcx, self.local_def_id(id), ast.decode(self))\n+            let def_id = self.local_def_id(id);\n+            let ast = ast.decode(self);\n+\n+            let tables = ast.tables.decode((self, tcx));\n+            tcx.tables.borrow_mut().insert(def_id, tcx.alloc_tables(tables));\n+\n+            let body = ast.body.decode((self, tcx));\n+            tcx.map.intern_inlined_body(def_id, body)\n         })\n     }\n "}, {"sha": "4b553a71b83259df57478b4a33273efe42a83dfa", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -20,7 +20,6 @@ use rustc::mir::transform::MirSource;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n@@ -52,17 +51,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Promoted(..) => bug!(),\n         };\n \n-        let src_node_id = src.item_id();\n-\n-        // We are going to be accessing various tables\n-        // generated by TypeckItemBody; we also assume\n-        // that the body passes type check. These tables\n-        // are not individually tracked, so just register\n-        // a read here.\n-        let src_def_id = infcx.tcx.map.local_def_id(src_node_id);\n-        infcx.tcx.dep_graph.read(DepNode::TypeckItemBody(src_def_id));\n-\n-        let attrs = infcx.tcx.map.attrs(src_node_id);\n+        let attrs = infcx.tcx.map.attrs(src.item_id());\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on"}, {"sha": "a9c1edfdc66cc600ae6c7d9afffc2ac44ee02cb3", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -95,8 +95,6 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                 let sym = ccx.symbol_map()\n                              .get(TransItem::Static(id))\n                              .expect(\"Local statics should always be in the SymbolMap\");\n-                // Make sure that this is never executed for something inlined.\n-                assert!(!ccx.tcx().map.is_inlined_node_id(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()"}, {"sha": "1473e55b2643cbef4b8f6aef5ccf759fe45d8cd8", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -1738,14 +1738,6 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let tcx = cx.tcx();\n \n-    // Don't create debuginfo for globals inlined from other crates. The other\n-    // crate should already contain debuginfo for it. More importantly, the\n-    // global might not even exist in un-inlined form anywhere which would lead\n-    // to a linker errors.\n-    if tcx.map.is_inlined_node_id(node_id) {\n-        return;\n-    }\n-\n     let node_def_id = tcx.map.local_def_id(node_id);\n     let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n "}, {"sha": "9e56bcc458d864fe88c8aabc0acea352c020ae1e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -679,7 +679,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n         fcx.regionck_fn(fn_id, body);\n-        fcx.resolve_type_vars_in_body(body, fn_id);\n+        fcx.resolve_type_vars_in_body(body);\n     });\n }\n \n@@ -1246,7 +1246,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         fcx.select_all_obligations_or_error();\n \n         fcx.regionck_expr(body);\n-        fcx.resolve_type_vars_in_body(body, id);\n+        fcx.resolve_type_vars_in_body(body);\n     });\n }\n "}, {"sha": "02ac7c196b5cb620945be4435ce98d2b04772a80", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde0a7e7e01f64caed45e97ff958821d9247959e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=cde0a7e7e01f64caed45e97ff958821d9247959e", "patch": "@@ -33,10 +33,12 @@ use rustc::hir;\n // Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_body(&self,\n-                                     body: &'gcx hir::Body,\n-                                     item_id: ast::NodeId) {\n+    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) {\n         assert_eq!(self.writeback_errors.get(), false);\n+\n+        let item_id = self.tcx.map.body_owner(body.id());\n+        let item_def_id = self.tcx.map.local_def_id(item_id);\n+\n         let mut wbcx = WritebackCx::new(self);\n         for arg in &body.arguments {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n@@ -49,6 +51,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n         wbcx.visit_type_nodes();\n+\n+        let tables = self.tcx.alloc_tables(wbcx.tables);\n+        self.tcx.tables.borrow_mut().insert(item_def_id, tables);\n     }\n }\n \n@@ -63,6 +68,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n \n+    tables: ty::Tables<'gcx>,\n+\n     // Mapping from free regions of the function to the\n     // early-bound versions of them, visible from the\n     // outside of the function. This is needed by, and\n@@ -74,6 +81,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>) -> WritebackCx<'cx, 'gcx, 'tcx> {\n         let mut wbcx = WritebackCx {\n             fcx: fcx,\n+            tables: ty::Tables::empty(),\n             free_to_bound_regions: DefIdMap()\n         };\n \n@@ -113,10 +121,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n-    fn write_ty_to_tcx(&self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n-        debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n+    fn write_ty_to_tables(&mut self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tables({}, {:?})\", node_id,  ty);\n         assert!(!ty.needs_infer());\n-        self.tcx().tables.borrow_mut().node_types.insert(node_id, ty);\n+        self.tables.node_types.insert(node_id, ty);\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n@@ -238,13 +246,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n-        self.write_ty_to_tcx(l.id, var_ty);\n+        self.write_ty_to_tables(l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn visit_upvar_borrow_map(&self) {\n+    fn visit_upvar_borrow_map(&mut self) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -262,11 +270,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             debug!(\"Upvar capture for {:?} resolved to {:?}\",\n                    upvar_id,\n                    new_upvar_capture);\n-            self.tcx()\n-                .tables\n-                .borrow_mut()\n-                .upvar_capture_map\n-                .insert(*upvar_id, new_upvar_capture);\n+            self.tables.upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n@@ -336,10 +340,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n+    fn visit_node_id(&mut self, reason: ResolveReason, id: ast::NodeId) {\n         // Export associated path extensions.\n         if let Some(def) = self.fcx.tables.borrow_mut().type_relative_path_defs.remove(&id) {\n-            self.tcx().tables.borrow_mut().type_relative_path_defs.insert(id, def);\n+            self.tables.type_relative_path_defs.insert(id, def);\n         }\n \n         // Resolve any borrowings for the node with id `id`\n@@ -348,7 +352,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         // Resolve the type of the node with id `id`\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n-        self.write_ty_to_tcx(id, n_ty);\n+        self.write_ty_to_tables(id, n_ty);\n         debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n@@ -357,12 +361,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             if !item_substs.is_noop() {\n                 debug!(\"write_substs_to_tcx({}, {:?})\", id, item_substs);\n                 assert!(!item_substs.substs.needs_infer());\n-                self.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n+                self.tables.item_substs.insert(id, item_substs);\n             }\n         });\n     }\n \n-    fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n+    fn visit_adjustments(&mut self, reason: ResolveReason, id: ast::NodeId) {\n         let adjustments = self.fcx.tables.borrow_mut().adjustments.remove(&id);\n         match adjustments {\n             None => {\n@@ -405,13 +409,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     target: self.resolve(&adjustment.target, reason)\n                 };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n-                self.tcx().tables.borrow_mut().adjustments.insert(\n-                    id, resolved_adjustment);\n+                self.tables.adjustments.insert(id, resolved_adjustment);\n             }\n         }\n     }\n \n-    fn visit_method_map_entry(&self,\n+    fn visit_method_map_entry(&mut self,\n                               reason: ResolveReason,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n@@ -433,25 +436,25 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n         //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n         if let Some(method) = new_method {\n-            self.tcx().tables.borrow_mut().method_map.insert(method_call, method);\n+            self.tables.method_map.insert(method_call, method);\n         }\n     }\n \n-    fn visit_liberated_fn_sigs(&self) {\n+    fn visit_liberated_fn_sigs(&mut self) {\n         for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n             let fn_sig = self.resolve(fn_sig, ResolvingFnSig(node_id));\n-            self.tcx().tables.borrow_mut().liberated_fn_sigs.insert(node_id, fn_sig.clone());\n+            self.tables.liberated_fn_sigs.insert(node_id, fn_sig.clone());\n         }\n     }\n \n-    fn visit_fru_field_types(&self) {\n+    fn visit_fru_field_types(&mut self) {\n         for (&node_id, ftys) in self.fcx.tables.borrow().fru_field_types.iter() {\n             let ftys = self.resolve(ftys, ResolvingFieldTypes(node_id));\n-            self.tcx().tables.borrow_mut().fru_field_types.insert(node_id, ftys);\n+            self.tables.fru_field_types.insert(node_id, ftys);\n         }\n     }\n \n-    fn visit_deferred_obligations(&self, item_id: ast::NodeId) {\n+    fn visit_deferred_obligations(&mut self, item_id: ast::NodeId) {\n         let deferred_obligations = self.fcx.deferred_obligations.borrow();\n         let obligations: Vec<_> = deferred_obligations.iter().map(|obligation| {\n             let reason = ResolvingDeferredObligation(obligation.cause.span);"}]}