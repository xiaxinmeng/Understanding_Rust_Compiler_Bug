{"sha": "4442f13b030162319cfe53335d4abc369f75214b", "node_id": "C_kwDOAAsO6NoAKDQ0NDJmMTNiMDMwMTYyMzE5Y2ZlNTMzMzVkNGFiYzM2OWY3NTIxNGI", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T00:58:22Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T02:47:38Z"}, "message": "rustc_metadata: remove huge error imports", "tree": {"sha": "a9a9225e9811d0a2e9cfa91f040e2394287add0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9a9225e9811d0a2e9cfa91f040e2394287add0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4442f13b030162319cfe53335d4abc369f75214b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4442f13b030162319cfe53335d4abc369f75214b", "html_url": "https://github.com/rust-lang/rust/commit/4442f13b030162319cfe53335d4abc369f75214b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4442f13b030162319cfe53335d4abc369f75214b/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60e82aef64ed62a40ec06357a9946196909ce953", "url": "https://api.github.com/repos/rust-lang/rust/commits/60e82aef64ed62a40ec06357a9946196909ce953", "html_url": "https://github.com/rust-lang/rust/commit/60e82aef64ed62a40ec06357a9946196909ce953"}], "stats": {"total": 181, "additions": 89, "deletions": 92}, "files": [{"sha": "21652063b47167585124ef8f3293cc7acf031985", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4442f13b030162319cfe53335d4abc369f75214b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4442f13b030162319cfe53335d4abc369f75214b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=4442f13b030162319cfe53335d4abc369f75214b", "patch": "@@ -1,10 +1,6 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::errors::{\n-    ConflictingAllocErrorHandler, ConflictingGlobalAlloc, CrateNotPanicRuntime,\n-    GlobalAllocRequired, NoMultipleAllocErrorHandler, NoMultipleGlobalAlloc, NoPanicStrategy,\n-    NoTransitiveNeedsDep, NotProfilerRuntime, ProfilerBuiltinsNeedsCore,\n-};\n+use crate::errors;\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n@@ -768,10 +764,11 @@ impl<'a> CrateLoader<'a> {\n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n         if !data.is_panic_runtime() {\n-            self.sess.emit_err(CrateNotPanicRuntime { crate_name: name });\n+            self.sess.emit_err(errors::CrateNotPanicRuntime { crate_name: name });\n         }\n         if data.required_panic_strategy() != Some(desired_strategy) {\n-            self.sess.emit_err(NoPanicStrategy { crate_name: name, strategy: desired_strategy });\n+            self.sess\n+                .emit_err(errors::NoPanicStrategy { crate_name: name, strategy: desired_strategy });\n         }\n \n         self.cstore.injected_panic_runtime = Some(cnum);\n@@ -791,29 +788,30 @@ impl<'a> CrateLoader<'a> {\n \n         let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);\n         if name == sym::profiler_builtins && self.sess.contains_name(&krate.attrs, sym::no_core) {\n-            self.sess.emit_err(ProfilerBuiltinsNeedsCore);\n+            self.sess.emit_err(errors::ProfilerBuiltinsNeedsCore);\n         }\n \n         let Some(cnum) = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit) else { return; };\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n         if !data.is_profiler_runtime() {\n-            self.sess.emit_err(NotProfilerRuntime { crate_name: name });\n+            self.sess.emit_err(errors::NotProfilerRuntime { crate_name: name });\n         }\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n         self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n-                self.sess.emit_err(NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n+                self.sess.emit_err(errors::NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n         };\n         self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n-                self.sess.emit_err(NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n+                self.sess\n+                    .emit_err(errors::NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n@@ -849,7 +847,7 @@ impl<'a> CrateLoader<'a> {\n             if data.has_global_allocator() {\n                 match global_allocator {\n                     Some(other_crate) => {\n-                        self.sess.emit_err(ConflictingGlobalAlloc {\n+                        self.sess.emit_err(errors::ConflictingGlobalAlloc {\n                             crate_name: data.name(),\n                             other_crate_name: other_crate,\n                         });\n@@ -864,7 +862,7 @@ impl<'a> CrateLoader<'a> {\n             if data.has_alloc_error_handler() {\n                 match alloc_error_handler {\n                     Some(other_crate) => {\n-                        self.sess.emit_err(ConflictingAllocErrorHandler {\n+                        self.sess.emit_err(errors::ConflictingAllocErrorHandler {\n                             crate_name: data.name(),\n                             other_crate_name: other_crate,\n                         });\n@@ -884,7 +882,7 @@ impl<'a> CrateLoader<'a> {\n             if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n                 && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n             {\n-                self.sess.emit_err(GlobalAllocRequired);\n+                self.sess.emit_err(errors::GlobalAllocRequired);\n             }\n             self.cstore.allocator_kind = Some(AllocatorKind::Default);\n         }\n@@ -917,7 +915,7 @@ impl<'a> CrateLoader<'a> {\n         for dep in self.cstore.crate_dependencies_in_reverse_postorder(krate) {\n             let data = self.cstore.get_crate_data(dep);\n             if needs_dep(&data) {\n-                self.sess.emit_err(NoTransitiveNeedsDep {\n+                self.sess.emit_err(errors::NoTransitiveNeedsDep {\n                     crate_name: self.cstore.get_crate_data(krate).name(),\n                     needs_crate_name: what,\n                     deps_crate_name: data.name(),"}, {"sha": "74f91a14ea9ae742c2e93a338fa8e050b62f23d9", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4442f13b030162319cfe53335d4abc369f75214b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4442f13b030162319cfe53335d4abc369f75214b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=4442f13b030162319cfe53335d4abc369f75214b", "patch": "@@ -213,12 +213,7 @@\n //! metadata::locator or metadata::creader for all the juicy details!\n \n use crate::creader::Library;\n-use crate::errors::{\n-    CannotFindCrate, CrateLocationUnknownType, DlError, ExternLocationNotExist,\n-    ExternLocationNotFile, FoundStaticlib, IncompatibleRustc, InvalidMetadataFiles,\n-    LibFilenameForm, MultipleCandidates, NewerCrateVersion, NoCrateWithTriple, NoDylibPlugin,\n-    NonAsciiName, StableCrateIdCollision, SymbolConflictsCurrent, SymbolConflictsOthers,\n-};\n+use crate::errors;\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -980,28 +975,28 @@ impl CrateError {\n     pub(crate) fn report(self, sess: &Session, span: Span, missing_core: bool) {\n         match self {\n             CrateError::NonAsciiName(crate_name) => {\n-                sess.emit_err(NonAsciiName { span, crate_name });\n+                sess.emit_err(errors::NonAsciiName { span, crate_name });\n             }\n             CrateError::ExternLocationNotExist(crate_name, loc) => {\n-                sess.emit_err(ExternLocationNotExist { span, crate_name, location: &loc });\n+                sess.emit_err(errors::ExternLocationNotExist { span, crate_name, location: &loc });\n             }\n             CrateError::ExternLocationNotFile(crate_name, loc) => {\n-                sess.emit_err(ExternLocationNotFile { span, crate_name, location: &loc });\n+                sess.emit_err(errors::ExternLocationNotFile { span, crate_name, location: &loc });\n             }\n             CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n-                sess.emit_err(MultipleCandidates { span, crate_name, flavor, candidates });\n+                sess.emit_err(errors::MultipleCandidates { span, crate_name, flavor, candidates });\n             }\n             CrateError::SymbolConflictsCurrent(root_name) => {\n-                sess.emit_err(SymbolConflictsCurrent { span, crate_name: root_name });\n+                sess.emit_err(errors::SymbolConflictsCurrent { span, crate_name: root_name });\n             }\n             CrateError::SymbolConflictsOthers(root_name) => {\n-                sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name });\n+                sess.emit_err(errors::SymbolConflictsOthers { span, crate_name: root_name });\n             }\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n-                sess.emit_err(StableCrateIdCollision { span, crate_name0, crate_name1 });\n+                sess.emit_err(errors::StableCrateIdCollision { span, crate_name0, crate_name1 });\n             }\n             CrateError::DlOpen(s) | CrateError::DlSym(s) => {\n-                sess.emit_err(DlError { span, err: s });\n+                sess.emit_err(errors::DlError { span, err: s });\n             }\n             CrateError::LocatorCombined(locator) => {\n                 let crate_name = locator.crate_name;\n@@ -1012,8 +1007,12 @@ impl CrateError {\n                 if !locator.crate_rejections.via_filename.is_empty() {\n                     let mismatches = locator.crate_rejections.via_filename.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        sess.emit_err(CrateLocationUnknownType { span, path: &path, crate_name });\n-                        sess.emit_err(LibFilenameForm {\n+                        sess.emit_err(errors::CrateLocationUnknownType {\n+                            span,\n+                            path: &path,\n+                            crate_name,\n+                        });\n+                        sess.emit_err(errors::LibFilenameForm {\n                             span,\n                             dll_prefix: &locator.dll_prefix,\n                             dll_suffix: &locator.dll_suffix,\n@@ -1039,7 +1038,7 @@ impl CrateError {\n                             ));\n                         }\n                     }\n-                    sess.emit_err(NewerCrateVersion {\n+                    sess.emit_err(errors::NewerCrateVersion {\n                         span,\n                         crate_name: crate_name,\n                         add_info,\n@@ -1055,7 +1054,7 @@ impl CrateError {\n                             path.display(),\n                         ));\n                     }\n-                    sess.emit_err(NoCrateWithTriple {\n+                    sess.emit_err(errors::NoCrateWithTriple {\n                         span,\n                         crate_name,\n                         locator_triple: locator.triple.triple(),\n@@ -1071,7 +1070,12 @@ impl CrateError {\n                             path.display()\n                         ));\n                     }\n-                    sess.emit_err(FoundStaticlib { span, crate_name, add_info, found_crates });\n+                    sess.emit_err(errors::FoundStaticlib {\n+                        span,\n+                        crate_name,\n+                        add_info,\n+                        found_crates,\n+                    });\n                 } else if !locator.crate_rejections.via_version.is_empty() {\n                     let mismatches = locator.crate_rejections.via_version.iter();\n                     for CrateMismatch { path, got } in mismatches {\n@@ -1082,7 +1086,7 @@ impl CrateError {\n                             path.display(),\n                         ));\n                     }\n-                    sess.emit_err(IncompatibleRustc {\n+                    sess.emit_err(errors::IncompatibleRustc {\n                         span,\n                         crate_name,\n                         add_info,\n@@ -1094,14 +1098,14 @@ impl CrateError {\n                     for CrateMismatch { path: _, got } in locator.crate_rejections.via_invalid {\n                         crate_rejections.push(got);\n                     }\n-                    sess.emit_err(InvalidMetadataFiles {\n+                    sess.emit_err(errors::InvalidMetadataFiles {\n                         span,\n                         crate_name,\n                         add_info,\n                         crate_rejections,\n                     });\n                 } else {\n-                    sess.emit_err(CannotFindCrate {\n+                    sess.emit_err(errors::CannotFindCrate {\n                         span,\n                         crate_name,\n                         add_info,\n@@ -1118,7 +1122,7 @@ impl CrateError {\n                 }\n             }\n             CrateError::NonDylibPlugin(crate_name) => {\n-                sess.emit_err(NoDylibPlugin { span, crate_name });\n+                sess.emit_err(errors::NoDylibPlugin { span, crate_name });\n             }\n         }\n     }"}, {"sha": "e263fc7483537607483a9da0de99a0f4bdb881d4", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 49, "deletions": 54, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4442f13b030162319cfe53335d4abc369f75214b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4442f13b030162319cfe53335d4abc369f75214b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=4442f13b030162319cfe53335d4abc369f75214b", "patch": "@@ -13,17 +13,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n-use crate::errors::{\n-    AsNeededCompatibility, BundleNeedsStatic, EmptyLinkName, EmptyRenamingTarget,\n-    FrameworkOnlyWindows, ImportNameTypeForm, ImportNameTypeRaw, ImportNameTypeX86,\n-    IncompatibleWasmLink, InvalidLinkModifier, LibFrameworkApple, LinkCfgForm,\n-    LinkCfgSinglePredicate, LinkFrameworkApple, LinkKindForm, LinkModifiersForm, LinkNameForm,\n-    LinkOrdinalRawDylib, LinkRequiresName, MissingNativeLibrary, MultipleCfgs,\n-    MultipleImportNameType, MultipleKindsInLink, MultipleLinkModifiers, MultipleModifiers,\n-    MultipleNamesInLink, MultipleRenamings, MultipleWasmImport, NoLinkModOverride, RawDylibNoNul,\n-    RenamingNoLink, UnexpectedLinkArg, UnknownImportNameType, UnknownLinkKind, UnknownLinkModifier,\n-    UnsupportedAbi, UnsupportedAbiI686, WasmImportForm, WholeArchiveNeedsStatic,\n-};\n+use crate::errors;\n \n use std::path::PathBuf;\n \n@@ -52,7 +42,7 @@ pub fn find_native_static_library(\n         }\n     }\n \n-    sess.emit_fatal(MissingNativeLibrary::new(name, verbatim));\n+    sess.emit_fatal(errors::MissingNativeLibrary::new(name, verbatim));\n }\n \n fn find_bundled_library(\n@@ -129,26 +119,26 @@ impl<'tcx> Collector<'tcx> {\n                 match item.name_or_empty() {\n                     sym::name => {\n                         if name.is_some() {\n-                            sess.emit_err(MultipleNamesInLink { span: item.span() });\n+                            sess.emit_err(errors::MultipleNamesInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_name) = item.value_str() else {\n-                            sess.emit_err(LinkNameForm { span: item.span() });\n+                            sess.emit_err(errors::LinkNameForm { span: item.span() });\n                             continue;\n                         };\n                         let span = item.name_value_literal_span().unwrap();\n                         if link_name.is_empty() {\n-                            sess.emit_err(EmptyLinkName { span });\n+                            sess.emit_err(errors::EmptyLinkName { span });\n                         }\n                         name = Some((link_name, span));\n                     }\n                     sym::kind => {\n                         if kind.is_some() {\n-                            sess.emit_err(MultipleKindsInLink { span: item.span() });\n+                            sess.emit_err(errors::MultipleKindsInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_kind) = item.value_str() else {\n-                            sess.emit_err(LinkKindForm { span: item.span() });\n+                            sess.emit_err(errors::LinkKindForm { span: item.span() });\n                             continue;\n                         };\n \n@@ -158,13 +148,13 @@ impl<'tcx> Collector<'tcx> {\n                             \"dylib\" => NativeLibKind::Dylib { as_needed: None },\n                             \"framework\" => {\n                                 if !sess.target.is_like_osx {\n-                                    sess.emit_err(LinkFrameworkApple { span });\n+                                    sess.emit_err(errors::LinkFrameworkApple { span });\n                                 }\n                                 NativeLibKind::Framework { as_needed: None }\n                             }\n                             \"raw-dylib\" => {\n                                 if !sess.target.is_like_windows {\n-                                    sess.emit_err(FrameworkOnlyWindows { span });\n+                                    sess.emit_err(errors::FrameworkOnlyWindows { span });\n                                 } else if !features.raw_dylib && sess.target.arch == \"x86\" {\n                                     feature_err(\n                                         &sess.parse_sess,\n@@ -177,34 +167,34 @@ impl<'tcx> Collector<'tcx> {\n                                 NativeLibKind::RawDylib\n                             }\n                             kind => {\n-                                sess.emit_err(UnknownLinkKind { span, kind });\n+                                sess.emit_err(errors::UnknownLinkKind { span, kind });\n                                 continue;\n                             }\n                         };\n                         kind = Some(link_kind);\n                     }\n                     sym::modifiers => {\n                         if modifiers.is_some() {\n-                            sess.emit_err(MultipleLinkModifiers { span: item.span() });\n+                            sess.emit_err(errors::MultipleLinkModifiers { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_modifiers) = item.value_str() else {\n-                            sess.emit_err(LinkModifiersForm { span: item.span() });\n+                            sess.emit_err(errors::LinkModifiersForm { span: item.span() });\n                             continue;\n                         };\n                         modifiers = Some((link_modifiers, item.name_value_literal_span().unwrap()));\n                     }\n                     sym::cfg => {\n                         if cfg.is_some() {\n-                            sess.emit_err(MultipleCfgs { span: item.span() });\n+                            sess.emit_err(errors::MultipleCfgs { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_cfg) = item.meta_item_list() else {\n-                            sess.emit_err(LinkCfgForm { span: item.span() });\n+                            sess.emit_err(errors::LinkCfgForm { span: item.span() });\n                             continue;\n                         };\n                         let [NestedMetaItem::MetaItem(link_cfg)] = link_cfg else {\n-                            sess.emit_err(LinkCfgSinglePredicate { span: item.span() });\n+                            sess.emit_err(errors::LinkCfgSinglePredicate { span: item.span() });\n                             continue;\n                         };\n                         if !features.link_cfg {\n@@ -220,26 +210,26 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     sym::wasm_import_module => {\n                         if wasm_import_module.is_some() {\n-                            sess.emit_err(MultipleWasmImport { span: item.span() });\n+                            sess.emit_err(errors::MultipleWasmImport { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_wasm_import_module) = item.value_str() else {\n-                            sess.emit_err(WasmImportForm { span: item.span() });\n+                            sess.emit_err(errors::WasmImportForm { span: item.span() });\n                             continue;\n                         };\n                         wasm_import_module = Some((link_wasm_import_module, item.span()));\n                     }\n                     sym::import_name_type => {\n                         if import_name_type.is_some() {\n-                            sess.emit_err(MultipleImportNameType { span: item.span() });\n+                            sess.emit_err(errors::MultipleImportNameType { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_import_name_type) = item.value_str() else {\n-                            sess.emit_err(ImportNameTypeForm { span: item.span() });\n+                            sess.emit_err(errors::ImportNameTypeForm { span: item.span() });\n                             continue;\n                         };\n                         if self.tcx.sess.target.arch != \"x86\" {\n-                            sess.emit_err(ImportNameTypeX86 { span: item.span() });\n+                            sess.emit_err(errors::ImportNameTypeX86 { span: item.span() });\n                             continue;\n                         }\n \n@@ -248,7 +238,7 @@ impl<'tcx> Collector<'tcx> {\n                             \"noprefix\" => PeImportNameType::NoPrefix,\n                             \"undecorated\" => PeImportNameType::Undecorated,\n                             import_name_type => {\n-                                sess.emit_err(UnknownImportNameType {\n+                                sess.emit_err(errors::UnknownImportNameType {\n                                     span: item.span(),\n                                     import_name_type,\n                                 });\n@@ -268,7 +258,7 @@ impl<'tcx> Collector<'tcx> {\n                         import_name_type = Some((link_import_name_type, item.span()));\n                     }\n                     _ => {\n-                        sess.emit_err(UnexpectedLinkArg { span: item.span() });\n+                        sess.emit_err(errors::UnexpectedLinkArg { span: item.span() });\n                     }\n                 }\n             }\n@@ -280,7 +270,7 @@ impl<'tcx> Collector<'tcx> {\n                     let (modifier, value) = match modifier.strip_prefix(&['+', '-']) {\n                         Some(m) => (m, modifier.starts_with('+')),\n                         None => {\n-                            sess.emit_err(InvalidLinkModifier { span });\n+                            sess.emit_err(errors::InvalidLinkModifier { span });\n                             continue;\n                         }\n                     };\n@@ -298,7 +288,7 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     let assign_modifier = |dst: &mut Option<bool>| {\n                         if dst.is_some() {\n-                            sess.emit_err(MultipleModifiers { span, modifier });\n+                            sess.emit_err(errors::MultipleModifiers { span, modifier });\n                         } else {\n                             *dst = Some(value);\n                         }\n@@ -308,7 +298,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(bundle)\n                         }\n                         (\"bundle\", _) => {\n-                            sess.emit_err(BundleNeedsStatic { span });\n+                            sess.emit_err(errors::BundleNeedsStatic { span });\n                         }\n \n                         (\"verbatim\", _) => assign_modifier(&mut verbatim),\n@@ -317,7 +307,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(whole_archive)\n                         }\n                         (\"whole-archive\", _) => {\n-                            sess.emit_err(WholeArchiveNeedsStatic { span });\n+                            sess.emit_err(errors::WholeArchiveNeedsStatic { span });\n                         }\n \n                         (\"as-needed\", Some(NativeLibKind::Dylib { as_needed }))\n@@ -326,35 +316,35 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(as_needed)\n                         }\n                         (\"as-needed\", _) => {\n-                            sess.emit_err(AsNeededCompatibility { span });\n+                            sess.emit_err(errors::AsNeededCompatibility { span });\n                         }\n \n                         _ => {\n-                            sess.emit_err(UnknownLinkModifier { span, modifier });\n+                            sess.emit_err(errors::UnknownLinkModifier { span, modifier });\n                         }\n                     }\n                 }\n             }\n \n             if let Some((_, span)) = wasm_import_module {\n                 if name.is_some() || kind.is_some() || modifiers.is_some() || cfg.is_some() {\n-                    sess.emit_err(IncompatibleWasmLink { span });\n+                    sess.emit_err(errors::IncompatibleWasmLink { span });\n                 }\n             } else if name.is_none() {\n-                sess.emit_err(LinkRequiresName { span: m.span });\n+                sess.emit_err(errors::LinkRequiresName { span: m.span });\n             }\n \n             // Do this outside of the loop so that `import_name_type` can be specified before `kind`.\n             if let Some((_, span)) = import_name_type {\n                 if kind != Some(NativeLibKind::RawDylib) {\n-                    sess.emit_err(ImportNameTypeRaw { span });\n+                    sess.emit_err(errors::ImportNameTypeRaw { span });\n                 }\n             }\n \n             let dll_imports = match kind {\n                 Some(NativeLibKind::RawDylib) => {\n                     if let Some((name, span)) = name && name.as_str().contains('\\0') {\n-                        sess.emit_err(RawDylibNoNul { span });\n+                        sess.emit_err(errors::RawDylibNoNul { span });\n                     }\n                     foreign_mod_items\n                         .iter()\n@@ -383,7 +373,9 @@ impl<'tcx> Collector<'tcx> {\n                                 .iter()\n                                 .find(|a| a.has_name(sym::link_ordinal))\n                                 .unwrap();\n-                            sess.emit_err(LinkOrdinalRawDylib { span: link_ordinal_attr.span });\n+                            sess.emit_err(errors::LinkOrdinalRawDylib {\n+                                span: link_ordinal_attr.span,\n+                            });\n                         }\n                     }\n \n@@ -414,7 +406,7 @@ impl<'tcx> Collector<'tcx> {\n         for lib in &self.tcx.sess.opts.libs {\n             if let NativeLibKind::Framework { .. } = lib.kind && !self.tcx.sess.target.is_like_osx {\n                 // Cannot check this when parsing options because the target is not yet available.\n-                self.tcx.sess.emit_err(LibFrameworkApple);\n+                self.tcx.sess.emit_err(errors::LibFrameworkApple);\n             }\n             if let Some(ref new_name) = lib.new_name {\n                 let any_duplicate = self\n@@ -423,11 +415,11 @@ impl<'tcx> Collector<'tcx> {\n                     .filter_map(|lib| lib.name.as_ref())\n                     .any(|n| n.as_str() == lib.name);\n                 if new_name.is_empty() {\n-                    self.tcx.sess.emit_err(EmptyRenamingTarget { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::EmptyRenamingTarget { lib_name: &lib.name });\n                 } else if !any_duplicate {\n-                    self.tcx.sess.emit_err(RenamingNoLink { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::RenamingNoLink { lib_name: &lib.name });\n                 } else if !renames.insert(&lib.name) {\n-                    self.tcx.sess.emit_err(MultipleRenamings { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::MultipleRenamings { lib_name: &lib.name });\n                 }\n             }\n         }\n@@ -453,12 +445,15 @@ impl<'tcx> Collector<'tcx> {\n                             // explicit `:rename` in particular.\n                             if lib.has_modifiers() || passed_lib.has_modifiers() {\n                                 match lib.foreign_module {\n-                                    Some(def_id) => self.tcx.sess.emit_err(NoLinkModOverride {\n-                                        span: Some(self.tcx.def_span(def_id)),\n-                                    }),\n-                                    None => {\n-                                        self.tcx.sess.emit_err(NoLinkModOverride { span: None })\n+                                    Some(def_id) => {\n+                                        self.tcx.sess.emit_err(errors::NoLinkModOverride {\n+                                            span: Some(self.tcx.def_span(def_id)),\n+                                        })\n                                     }\n+                                    None => self\n+                                        .tcx\n+                                        .sess\n+                                        .emit_err(errors::NoLinkModOverride { span: None }),\n                                 };\n                             }\n                             if passed_lib.kind != NativeLibKind::Unspecified {\n@@ -542,14 +537,14 @@ impl<'tcx> Collector<'tcx> {\n                     DllCallingConvention::Vectorcall(self.i686_arg_list_size(item))\n                 }\n                 _ => {\n-                    self.tcx.sess.emit_fatal(UnsupportedAbiI686 { span: item.span });\n+                    self.tcx.sess.emit_fatal(errors::UnsupportedAbiI686 { span: item.span });\n                 }\n             }\n         } else {\n             match abi {\n                 Abi::C { .. } | Abi::Win64 { .. } | Abi::System { .. } => DllCallingConvention::C,\n                 _ => {\n-                    self.tcx.sess.emit_fatal(UnsupportedAbi { span: item.span });\n+                    self.tcx.sess.emit_fatal(errors::UnsupportedAbi { span: item.span });\n                 }\n             }\n         };"}]}