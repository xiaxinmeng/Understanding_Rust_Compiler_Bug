{"sha": "31c33ca5ff31e21116885c12ed99ccb27b5e7c8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYzMzY2E1ZmYzMWUyMTExNjg4NWMxMmVkOTljY2IyN2I1ZTdjOGQ=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-06-05T14:12:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:55Z"}, "message": "std: doc and misc cleanup in net::tcp\n\n* updated rustdoc info for several functions\n* changed read_stop to take control of the port returned by read_start\n* made write_future do an explicit data copy with the binary vector it is\npassed", "tree": {"sha": "1ea7ea9f805449a329f5cf1ebadee7385cef85e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ea7ea9f805449a329f5cf1ebadee7385cef85e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31c33ca5ff31e21116885c12ed99ccb27b5e7c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31c33ca5ff31e21116885c12ed99ccb27b5e7c8d", "html_url": "https://github.com/rust-lang/rust/commit/31c33ca5ff31e21116885c12ed99ccb27b5e7c8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31c33ca5ff31e21116885c12ed99ccb27b5e7c8d/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7e3a4e036cbe84677a924548c2ecbb49b551265", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7e3a4e036cbe84677a924548c2ecbb49b551265", "html_url": "https://github.com/rust-lang/rust/commit/f7e3a4e036cbe84677a924548c2ecbb49b551265"}], "stats": {"total": 56, "additions": 35, "deletions": 21}, "files": [{"sha": "ae9556eec5012ec85cdd613bdd340e3ad9a672f8", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/31c33ca5ff31e21116885c12ed99ccb27b5e7c8d/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c33ca5ff31e21116885c12ed99ccb27b5e7c8d/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=31c33ca5ff31e21116885c12ed99ccb27b5e7c8d", "patch": "@@ -105,15 +105,16 @@ Initiate a client connection over TCP/IP\n \n # Arguments\n \n-* `ip` - The IP address (versions 4 or 6) of the remote host\n+* `input_ip` - The IP address (versions 4 or 6) of the remote host\n * `port` - the unsigned integer of the desired remote host port\n * `iotask` - a `uv::iotask` that the tcp request will run on\n \n # Returns\n \n-A `result` that, if the operation succeeds, contains a `tcp_socket` that\n-can be used to send and receive data to/from the remote host. In the event\n-of failure, a `tcp_err_data` will be returned\n+A `result` that, if the operation succeeds, contains a `net::net::tcp_socket`\n+that can be used to send and receive data to/from the remote host. In the\n+event of failure, a `net::tcp::tcp_connect_err_data` instance will be\n+returned\n \"]\n fn connect(input_ip: ip::ip_addr, port: uint,\n            iotask: iotask)\n@@ -244,9 +245,12 @@ Write binary data to tcp stream; Returns a `future::future` value immediately\n \n # Safety\n \n-This function can produce unsafe results if the call to `write_future` is\n-made, the `future::future` value returned is never resolved via\n-`future::get`, and then the `tcp_socket` passed in to `write_future` leaves\n+This function can produce unsafe results if:\n+\n+1. the call to `write_future` is made\n+2. the `future::future` value returned is never resolved via\n+`future::get`\n+3. and then the `tcp_socket` passed in to `write_future` leaves\n scope and is destructed before the task that runs the libuv write\n operation completes.\n \n@@ -270,7 +274,8 @@ fn write_future(sock: tcp_socket, raw_write_data: [u8]/~)\n     -> future<result::result<(), tcp_err_data>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     future_spawn {||\n-        write_common_impl(socket_data_ptr, raw_write_data)\n+        let data_copy = copy(raw_write_data);\n+        write_common_impl(socket_data_ptr, data_copy)\n     }\n }\n \n@@ -301,9 +306,11 @@ Stop reading from an open TCP connection; used with `read_start`\n \n * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n \"]\n-fn read_stop(sock: tcp_socket) ->\n+fn read_stop(sock: tcp_socket,\n+             -read_port: comm::port<result::result<[u8], tcp_err_data>>) ->\n     result::result<(), tcp_err_data> unsafe {\n-    let socket_data = ptr::addr_of(*(sock.socket_data));\n+    log(debug, #fmt(\"taking the read_port out of commission %?\", read_port));\n+    let socket_data = ptr::addr_of(**sock);\n     read_stop_common_impl(socket_data)\n }\n \n@@ -388,7 +395,15 @@ Here, the `new_conn` is used in conjunction with `accept` from within\n a task spawned by the `new_connect_cb` passed into `listen`\n \n ~~~~~~~~~~~\n-net::tcp::listen(remote_ip, remote_port, backlog) {|new_conn, kill_ch|\n+net::tcp::listen(remote_ip, remote_port, backlog)\n+    // this callback is ran once after the connection is successfully\n+    // set up\n+    {|kill_ch|\n+      // pass the kill_ch to your main loop or wherever you want\n+      // to be able to externally kill the server from\n+    }\n+    // this callback is ran when a new connection arrives\n+    {|new_conn, kill_ch|\n     let cont_po = comm::port::<option<tcp_err_data>>();\n     let cont_ch = comm::chan(cont_po);\n     task::spawn {||\n@@ -418,13 +433,11 @@ net::tcp::listen(remote_ip, remote_port, backlog) {|new_conn, kill_ch|\n \n # Returns\n \n-* Success\n-  * On success, this function will return a `net::tcp::tcp_socket` as the\n-  `ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n-  the task that `accept` was called within for its lifetime.\n-* Failure\n-  * On failure, this function will return a `net::tcp::tcp_err_data` record\n-  as the `err` variant of a `result`.\n+On success, this function will return a `net::tcp::tcp_socket` as the\n+`ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n+the task that `accept` was called within for its lifetime. On failure,\n+this function will return a `net::tcp::tcp_err_data` record\n+as the `err` variant of a `result`.\n \"]\n fn accept(new_conn: tcp_new_connection)\n     -> result::result<tcp_socket, tcp_err_data> unsafe {\n@@ -525,7 +538,7 @@ callback's arguments are:\n # returns\n \n a `result` instance containing empty data of type `()` on a\n-successful/normal shutdown, and a `tcp_err_data` record in the event\n+successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n of listen exiting because of an error\n \"]\n fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n@@ -665,9 +678,10 @@ impl methods_tcp_socket for tcp_socket {\n         result::result<[u8]/~, tcp_err_data>>, tcp_err_data> {\n         read_start(self)\n     }\n-    fn read_stop() ->\n+    fn read_stop(-read_port:\n+                 comm::port<result::result<[u8], tcp_err_data>>) ->\n         result::result<(), tcp_err_data> {\n-        read_stop(self)\n+        read_stop(self, read_port)\n     }\n     fn read(timeout_msecs: uint) ->\n         result::result<[u8]/~, tcp_err_data> {"}]}