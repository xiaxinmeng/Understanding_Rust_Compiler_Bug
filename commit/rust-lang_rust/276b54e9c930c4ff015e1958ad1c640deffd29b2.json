{"sha": "276b54e9c930c4ff015e1958ad1c640deffd29b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NmI1NGU5YzkzMGM0ZmYwMTVlMTk1OGFkMWM2NDBkZWZmZDI5YjI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-21T12:06:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-21T12:06:38Z"}, "message": "Rollup merge of #69955 - alexcrichton:stderr-infallible, r=sfackler\n\nFix abort-on-eprintln during process shutdown\n\nThis commit fixes an issue where if `eprintln!` is used in a TLS\ndestructor it can accidentally cause the process to abort. TLS\ndestructors are executed after `main` returns on the main thread, and at\nthis point we've also deinitialized global `Lazy` values like those\nwhich store the `Stderr` and `Stdout` internals. This means that despite\nhandling TLS not being accessible in `eprintln!`, we will fail due to\nnot being able to call `stderr()`. This means that we'll double-panic\nquickly because panicking also attempt to write to stderr.\n\nThe fix here is to reimplement the global stderr handle to avoid the\nneed for destruction. This avoids the need for `Lazy` as well as the\nhidden panic inside of the `stderr` function.\n\nOverall this should improve the robustness of printing errors and/or\npanics in weird situations, since the `stderr` accessor should be\ninfallible in more situations.", "tree": {"sha": "4c1eb2b3b0d3e5b53b4a4e1ada7042001f5ed089", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c1eb2b3b0d3e5b53b4a4e1ada7042001f5ed089"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/276b54e9c930c4ff015e1958ad1c640deffd29b2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJedgNOCRBK7hj4Ov3rIwAAdHIIAAe8V6Wl3sIDlGbinLJ756No\nsbMuDEeNssSqyQMzS8WHUUa8vZoEHcWNqYrwBLTHUlD6HWV972W8rrAbyixvO7DR\nPRFC53q5b1x2dnS15k5v6pPKz9zRVdPt9PyevvZ0qLVfTx0lIjK5EEVkBxrpqRzv\n+MXhHV42bSCsplFdsGD+foBFx2U1gAZxwy/hD6tV33i118FNxzr8lgb3vUa/wcWO\nnrmboG5dxrRraBvTULCxXxIwlgf1GylUoMrSQoi4ZfZQ2aEIreWHFxRx30wDMSdK\nxH8lAlV8lwqRDUTthebFZEleciGSPuYrDHXC4J/CDagkIYBwv/GbyOxMrHxOKhQ=\n=yVPb\n-----END PGP SIGNATURE-----\n", "payload": "tree 4c1eb2b3b0d3e5b53b4a4e1ada7042001f5ed089\nparent 8deeac153fcca97f6a5185b322f8d65d59fab5f4\nparent 5edaa7eefd76d4996dcf85dfc1c1a3f737087257\nauthor Dylan DPC <dylan.dpc@gmail.com> 1584792398 +0100\ncommitter GitHub <noreply@github.com> 1584792398 +0100\n\nRollup merge of #69955 - alexcrichton:stderr-infallible, r=sfackler\n\nFix abort-on-eprintln during process shutdown\n\nThis commit fixes an issue where if `eprintln!` is used in a TLS\ndestructor it can accidentally cause the process to abort. TLS\ndestructors are executed after `main` returns on the main thread, and at\nthis point we've also deinitialized global `Lazy` values like those\nwhich store the `Stderr` and `Stdout` internals. This means that despite\nhandling TLS not being accessible in `eprintln!`, we will fail due to\nnot being able to call `stderr()`. This means that we'll double-panic\nquickly because panicking also attempt to write to stderr.\n\nThe fix here is to reimplement the global stderr handle to avoid the\nneed for destruction. This avoids the need for `Lazy` as well as the\nhidden panic inside of the `stderr` function.\n\nOverall this should improve the robustness of printing errors and/or\npanics in weird situations, since the `stderr` accessor should be\ninfallible in more situations.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/276b54e9c930c4ff015e1958ad1c640deffd29b2", "html_url": "https://github.com/rust-lang/rust/commit/276b54e9c930c4ff015e1958ad1c640deffd29b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/276b54e9c930c4ff015e1958ad1c640deffd29b2/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8deeac153fcca97f6a5185b322f8d65d59fab5f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8deeac153fcca97f6a5185b322f8d65d59fab5f4", "html_url": "https://github.com/rust-lang/rust/commit/8deeac153fcca97f6a5185b322f8d65d59fab5f4"}, {"sha": "5edaa7eefd76d4996dcf85dfc1c1a3f737087257", "url": "https://api.github.com/repos/rust-lang/rust/commits/5edaa7eefd76d4996dcf85dfc1c1a3f737087257", "html_url": "https://github.com/rust-lang/rust/commit/5edaa7eefd76d4996dcf85dfc1c1a3f737087257"}], "stats": {"total": 249, "additions": 149, "deletions": 100}, "files": [{"sha": "9a82ae7626d9714094ac733402e8950284d5e983", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -6,7 +6,7 @@ use crate::cell::RefCell;\n use crate::fmt;\n use crate::io::lazy::Lazy;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n-use crate::sync::{Arc, Mutex, MutexGuard};\n+use crate::sync::{Arc, Mutex, MutexGuard, Once};\n use crate::sys::stdio;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread::LocalKey;\n@@ -493,7 +493,11 @@ pub fn stdout() -> Stdout {\n             Ok(stdout) => Maybe::Real(stdout),\n             _ => Maybe::Fake,\n         };\n-        Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))))\n+        unsafe {\n+            let ret = Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))));\n+            ret.init();\n+            return ret;\n+        }\n     }\n }\n \n@@ -520,7 +524,7 @@ impl Stdout {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdoutLock<'_> {\n-        StdoutLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n+        StdoutLock { inner: self.inner.lock() }\n     }\n }\n \n@@ -581,7 +585,7 @@ impl fmt::Debug for StdoutLock<'_> {\n /// an error.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n-    inner: Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>>,\n+    inner: &'static ReentrantMutex<RefCell<Maybe<StderrRaw>>>,\n }\n \n /// A locked reference to the `Stderr` handle.\n@@ -639,19 +643,28 @@ pub struct StderrLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> = Lazy::new();\n-    return Stderr {\n-        inner: unsafe { INSTANCE.get(stderr_init).expect(\"cannot access stderr during shutdown\") },\n-    };\n-\n-    fn stderr_init() -> Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> {\n-        // This must not reentrantly access `INSTANCE`\n-        let stderr = match stderr_raw() {\n-            Ok(stderr) => Maybe::Real(stderr),\n-            _ => Maybe::Fake,\n-        };\n-        Arc::new(ReentrantMutex::new(RefCell::new(stderr)))\n-    }\n+    // Note that unlike `stdout()` we don't use `Lazy` here which registers a\n+    // destructor. Stderr is not buffered nor does the `stderr_raw` type consume\n+    // any owned resources, so there's no need to run any destructors at some\n+    // point in the future.\n+    //\n+    // This has the added benefit of allowing `stderr` to be usable during\n+    // process shutdown as well!\n+    static INSTANCE: ReentrantMutex<RefCell<Maybe<StderrRaw>>> =\n+        unsafe { ReentrantMutex::new(RefCell::new(Maybe::Fake)) };\n+\n+    // When accessing stderr we need one-time initialization of the reentrant\n+    // mutex, followed by one-time detection of whether we actually have a\n+    // stderr handle or not. Afterwards we can just always use the now-filled-in\n+    // `INSTANCE` value.\n+    static INIT: Once = Once::new();\n+    INIT.call_once(|| unsafe {\n+        INSTANCE.init();\n+        if let Ok(stderr) = stderr_raw() {\n+            *INSTANCE.lock().borrow_mut() = Maybe::Real(stderr);\n+        }\n+    });\n+    return Stderr { inner: &INSTANCE };\n }\n \n impl Stderr {\n@@ -677,7 +690,7 @@ impl Stderr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StderrLock<'_> {\n-        StderrLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n+        StderrLock { inner: self.inner.lock() }\n     }\n }\n "}, {"sha": "580ab0e8ad863face1a94e6243a19d72a21960fe", "filename": "src/libstd/sys/cloudabi/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -53,16 +53,16 @@ pub struct ReentrantMutex {\n }\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex {\n             lock: UnsafeCell::new(MaybeUninit::uninit()),\n             recursion: UnsafeCell::new(MaybeUninit::uninit()),\n         }\n     }\n \n-    pub unsafe fn init(&mut self) {\n-        self.lock = UnsafeCell::new(MaybeUninit::new(AtomicU32::new(abi::LOCK_UNLOCKED.0)));\n-        self.recursion = UnsafeCell::new(MaybeUninit::new(0));\n+    pub unsafe fn init(&self) {\n+        *self.lock.get() = MaybeUninit::new(AtomicU32::new(abi::LOCK_UNLOCKED.0));\n+        *self.recursion.get() = MaybeUninit::new(0);\n     }\n \n     pub unsafe fn try_lock(&self) -> bool {"}, {"sha": "3d4813209cbc4d0030dca9030f28afe18e6a83e7", "filename": "src/libstd/sys/hermit/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -46,13 +46,13 @@ pub struct ReentrantMutex {\n }\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { inner: ptr::null() }\n     }\n \n     #[inline]\n-    pub unsafe fn init(&mut self) {\n-        let _ = abi::recmutex_init(&mut self.inner as *mut *const c_void);\n+    pub unsafe fn init(&self) {\n+        let _ = abi::recmutex_init(&self.inner as *const *const c_void as *mut _);\n     }\n \n     #[inline]"}, {"sha": "4911c2f5387690877a75b1e8b4d372d6cc51854f", "filename": "src/libstd/sys/sgx/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -75,7 +75,7 @@ impl ReentrantMutex {\n     }\n \n     #[inline]\n-    pub unsafe fn init(&mut self) {}\n+    pub unsafe fn init(&self) {}\n \n     #[inline]\n     pub unsafe fn lock(&self) {"}, {"sha": "103d87e3d2f91c075fbe8437d1496bc8620bd3db", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -92,11 +92,11 @@ unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n \n-    pub unsafe fn init(&mut self) {\n+    pub unsafe fn init(&self) {\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n         let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);"}, {"sha": "103d87e3d2f91c075fbe8437d1496bc8620bd3db", "filename": "src/libstd/sys/vxworks/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -92,11 +92,11 @@ unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n \n-    pub unsafe fn init(&mut self) {\n+    pub unsafe fn init(&self) {\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n         let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);"}, {"sha": "7aaf1b3a343b613637c3cb443087c8928356cc16", "filename": "src/libstd/sys/wasm/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -47,11 +47,11 @@ impl Mutex {\n pub struct ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex {}\n     }\n \n-    pub unsafe fn init(&mut self) {}\n+    pub unsafe fn init(&self) {}\n \n     pub unsafe fn lock(&self) {}\n "}, {"sha": "268a53bb5641ca58ca79b89b75310b6d3d5c91d8", "filename": "src/libstd/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -80,11 +80,11 @@ unsafe impl Sync for ReentrantMutex {}\n // released when this recursion counter reaches 0.\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { owner: AtomicU32::new(0), recursions: UnsafeCell::new(0) }\n     }\n \n-    pub unsafe fn init(&mut self) {\n+    pub unsafe fn init(&self) {\n         // nothing to do...\n     }\n "}, {"sha": "63dfc640908e94da6e82418dd0368fd0df43b9e7", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -109,7 +109,7 @@ impl Mutex {\n             0 => {}\n             n => return n as *mut _,\n         }\n-        let mut re = box ReentrantMutex::uninitialized();\n+        let re = box ReentrantMutex::uninitialized();\n         re.init();\n         let re = Box::into_raw(re);\n         match self.lock.compare_and_swap(0, re as usize, Ordering::SeqCst) {\n@@ -157,11 +157,11 @@ unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub fn uninitialized() -> ReentrantMutex {\n+    pub const fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { inner: UnsafeCell::new(MaybeUninit::uninit()) }\n     }\n \n-    pub unsafe fn init(&mut self) {\n+    pub unsafe fn init(&self) {\n         c::InitializeCriticalSection((&mut *self.inner.get()).as_mut_ptr());\n     }\n "}, {"sha": "4f19bbc467f33d19b47d70a7fc320562d58506f5", "filename": "src/libstd/sys_common/remutex.rs", "status": "modified", "additions": 51, "deletions": 63, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Flibstd%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fremutex.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -3,16 +3,14 @@ use crate::marker;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n use crate::sys::mutex as sys;\n-use crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n \n /// A re-entrant mutual exclusion\n ///\n /// This mutex will block *other* threads waiting for the lock to become\n /// available. The thread which has already locked the mutex can lock it\n /// multiple times without blocking, preventing a common source of deadlocks.\n pub struct ReentrantMutex<T> {\n-    inner: Box<sys::ReentrantMutex>,\n-    poison: poison::Flag,\n+    inner: sys::ReentrantMutex,\n     data: T,\n }\n \n@@ -39,23 +37,30 @@ pub struct ReentrantMutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref currently works (it disregards field\n     // privacy).\n     __lock: &'a ReentrantMutex<T>,\n-    __poison: poison::Guard,\n }\n \n impl<T> !marker::Send for ReentrantMutexGuard<'_, T> {}\n \n impl<T> ReentrantMutex<T> {\n     /// Creates a new reentrant mutex in an unlocked state.\n-    pub fn new(t: T) -> ReentrantMutex<T> {\n-        unsafe {\n-            let mut mutex = ReentrantMutex {\n-                inner: box sys::ReentrantMutex::uninitialized(),\n-                poison: poison::Flag::new(),\n-                data: t,\n-            };\n-            mutex.inner.init();\n-            mutex\n-        }\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because it is required that `init` is called\n+    /// once this mutex is in its final resting place, and only then are the\n+    /// lock/unlock methods safe.\n+    pub const unsafe fn new(t: T) -> ReentrantMutex<T> {\n+        ReentrantMutex { inner: sys::ReentrantMutex::uninitialized(), data: t }\n+    }\n+\n+    /// Initializes this mutex so it's ready for use.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// Unsafe to call more than once, and must be called after this will no\n+    /// longer move in memory.\n+    pub unsafe fn init(&self) {\n+        self.inner.init();\n     }\n \n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n@@ -70,7 +75,7 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn lock(&self) -> LockResult<ReentrantMutexGuard<'_, T>> {\n+    pub fn lock(&self) -> ReentrantMutexGuard<'_, T> {\n         unsafe { self.inner.lock() }\n         ReentrantMutexGuard::new(&self)\n     }\n@@ -87,12 +92,8 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn try_lock(&self) -> TryLockResult<ReentrantMutexGuard<'_, T>> {\n-        if unsafe { self.inner.try_lock() } {\n-            Ok(ReentrantMutexGuard::new(&self)?)\n-        } else {\n-            Err(TryLockError::WouldBlock)\n-        }\n+    pub fn try_lock(&self) -> Option<ReentrantMutexGuard<'_, T>> {\n+        if unsafe { self.inner.try_lock() } { Some(ReentrantMutexGuard::new(&self)) } else { None }\n     }\n }\n \n@@ -108,11 +109,8 @@ impl<T> Drop for ReentrantMutex<T> {\n impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.try_lock() {\n-            Ok(guard) => f.debug_struct(\"ReentrantMutex\").field(\"data\", &*guard).finish(),\n-            Err(TryLockError::Poisoned(err)) => {\n-                f.debug_struct(\"ReentrantMutex\").field(\"data\", &**err.get_ref()).finish()\n-            }\n-            Err(TryLockError::WouldBlock) => {\n+            Some(guard) => f.debug_struct(\"ReentrantMutex\").field(\"data\", &*guard).finish(),\n+            None => {\n                 struct LockedPlaceholder;\n                 impl fmt::Debug for LockedPlaceholder {\n                     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -127,11 +125,8 @@ impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n }\n \n impl<'mutex, T> ReentrantMutexGuard<'mutex, T> {\n-    fn new(lock: &'mutex ReentrantMutex<T>) -> LockResult<ReentrantMutexGuard<'mutex, T>> {\n-        poison::map_result(lock.poison.borrow(), |guard| ReentrantMutexGuard {\n-            __lock: lock,\n-            __poison: guard,\n-        })\n+    fn new(lock: &'mutex ReentrantMutex<T>) -> ReentrantMutexGuard<'mutex, T> {\n+        ReentrantMutexGuard { __lock: lock }\n     }\n }\n \n@@ -147,7 +142,6 @@ impl<T> Drop for ReentrantMutexGuard<'_, T> {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            self.__lock.poison.done(&self.__poison);\n             self.__lock.inner.unlock();\n         }\n     }\n@@ -162,13 +156,17 @@ mod tests {\n \n     #[test]\n     fn smoke() {\n-        let m = ReentrantMutex::new(());\n+        let m = unsafe {\n+            let m = ReentrantMutex::new(());\n+            m.init();\n+            m\n+        };\n         {\n-            let a = m.lock().unwrap();\n+            let a = m.lock();\n             {\n-                let b = m.lock().unwrap();\n+                let b = m.lock();\n                 {\n-                    let c = m.lock().unwrap();\n+                    let c = m.lock();\n                     assert_eq!(*c, ());\n                 }\n                 assert_eq!(*b, ());\n@@ -179,15 +177,19 @@ mod tests {\n \n     #[test]\n     fn is_mutex() {\n-        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n+        let m = unsafe {\n+            let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n+            m.init();\n+            m\n+        };\n         let m2 = m.clone();\n-        let lock = m.lock().unwrap();\n+        let lock = m.lock();\n         let child = thread::spawn(move || {\n-            let lock = m2.lock().unwrap();\n+            let lock = m2.lock();\n             assert_eq!(*lock.borrow(), 4950);\n         });\n         for i in 0..100 {\n-            let lock = m.lock().unwrap();\n+            let lock = m.lock();\n             *lock.borrow_mut() += i;\n         }\n         drop(lock);\n@@ -196,17 +198,21 @@ mod tests {\n \n     #[test]\n     fn trylock_works() {\n-        let m = Arc::new(ReentrantMutex::new(()));\n+        let m = unsafe {\n+            let m = Arc::new(ReentrantMutex::new(()));\n+            m.init();\n+            m\n+        };\n         let m2 = m.clone();\n-        let _lock = m.try_lock().unwrap();\n-        let _lock2 = m.try_lock().unwrap();\n+        let _lock = m.try_lock();\n+        let _lock2 = m.try_lock();\n         thread::spawn(move || {\n             let lock = m2.try_lock();\n-            assert!(lock.is_err());\n+            assert!(lock.is_none());\n         })\n         .join()\n         .unwrap();\n-        let _lock3 = m.try_lock().unwrap();\n+        let _lock3 = m.try_lock();\n     }\n \n     pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);\n@@ -215,22 +221,4 @@ mod tests {\n             *self.0.borrow_mut() = 42;\n         }\n     }\n-\n-    #[test]\n-    fn poison_works() {\n-        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n-        let mc = m.clone();\n-        let result = thread::spawn(move || {\n-            let lock = mc.lock().unwrap();\n-            *lock.borrow_mut() = 1;\n-            let lock2 = mc.lock().unwrap();\n-            *lock.borrow_mut() = 2;\n-            let _answer = Answer(lock2);\n-            panic!(\"What the answer to my lifetimes dilemma is?\");\n-        })\n-        .join();\n-        assert!(result.is_err());\n-        let r = m.lock().err().unwrap().into_inner();\n-        assert_eq!(*r.borrow(), 42);\n-    }\n }"}, {"sha": "9c4800c1a3fa1affff3dfca6e31ae1e51cb5192e", "filename": "src/test/ui/eprint-on-tls-drop.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Ftest%2Fui%2Feprint-on-tls-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b54e9c930c4ff015e1958ad1c640deffd29b2/src%2Ftest%2Fui%2Feprint-on-tls-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feprint-on-tls-drop.rs?ref=276b54e9c930c4ff015e1958ad1c640deffd29b2", "patch": "@@ -0,0 +1,48 @@\n+// run-pass\n+// ignore-emscripten no processes\n+\n+use std::cell::RefCell;\n+use std::env;\n+use std::process::Command;\n+\n+fn main() {\n+    let name = \"YOU_ARE_THE_TEST\";\n+    if env::var(name).is_ok() {\n+        std::thread::spawn(|| {\n+            TLS.with(|f| f.borrow().ensure());\n+        })\n+        .join()\n+        .unwrap();\n+    } else {\n+        let me = env::current_exe().unwrap();\n+        let output = Command::new(&me).env(name, \"1\").output().unwrap();\n+        println!(\"{:?}\", output);\n+        assert!(output.status.success());\n+        let stderr = String::from_utf8(output.stderr).unwrap();\n+        assert!(stderr.contains(\"hello new\\n\"));\n+        assert!(stderr.contains(\"hello drop\\n\"));\n+    }\n+}\n+\n+struct Stuff {\n+    _x: usize,\n+}\n+\n+impl Stuff {\n+    fn new() -> Self {\n+        eprintln!(\"hello new\");\n+        Self { _x: 0 }\n+    }\n+\n+    fn ensure(&self) {}\n+}\n+\n+impl Drop for Stuff {\n+    fn drop(&mut self) {\n+        eprintln!(\"hello drop\");\n+    }\n+}\n+\n+thread_local! {\n+    static TLS: RefCell<Stuff> = RefCell::new(Stuff::new());\n+}"}]}