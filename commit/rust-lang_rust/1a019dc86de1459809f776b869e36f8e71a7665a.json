{"sha": "1a019dc86de1459809f776b869e36f8e71a7665a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMDE5ZGM4NmRlMTQ1OTgwOWY3NzZiODY5ZTM2ZjhlNzFhNzY2NWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-12T04:57:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-12T04:57:39Z"}, "message": "Auto merge of #31925 - aturon:inherent-overlap, r=nikomatsakis\n\nForbid items with the same name from appearing in overlapping inherent impl blocks\n\nFor example, the following is now correctly illegal:\n\n```rust\nstruct Foo;\n\nimpl Foo {\n    fn id() {}\n}\n\nimpl Foo {\n    fn id() {}\n}\n```\n\n\"Overlapping\" here is determined the same way it is for traits (and in fact shares the same code path): roughly, there must be some way of substituting any generic types to unify the impls, such that none of the `where` clauses are provably unsatisfiable under such a unification.\n\nAlong the way, this PR also introduces an `ImplHeader` abstraction (the first commit) that makes it easier to work with impls abstractly (without caring whether they are trait or inherent impl blocks); see the first commit.\n\nCloses #22889\nr? @nikomatsakis", "tree": {"sha": "992312b494f02d65307b79fe8cb7a7eae2d4c3f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/992312b494f02d65307b79fe8cb7a7eae2d4c3f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a019dc86de1459809f776b869e36f8e71a7665a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a019dc86de1459809f776b869e36f8e71a7665a", "html_url": "https://github.com/rust-lang/rust/commit/1a019dc86de1459809f776b869e36f8e71a7665a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a019dc86de1459809f776b869e36f8e71a7665a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1d6f126effd61c21c2134751b75b6e8924d65e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d6f126effd61c21c2134751b75b6e8924d65e3", "html_url": "https://github.com/rust-lang/rust/commit/f1d6f126effd61c21c2134751b75b6e8924d65e3"}, {"sha": "6265b6bec872240adf3cb72eecd6b0cae8627014", "url": "https://api.github.com/repos/rust-lang/rust/commits/6265b6bec872240adf3cb72eecd6b0cae8627014", "html_url": "https://github.com/rust-lang/rust/commit/6265b6bec872240adf3cb72eecd6b0cae8627014"}], "stats": {"total": 362, "additions": 253, "deletions": 109}, "files": [{"sha": "f4df6994e047b501c049923adf84b208fec34783", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -58,6 +58,7 @@ pub enum DepNode {\n     CoherenceCheckImpl(DefId),\n     CoherenceOverlapCheck(DefId),\n     CoherenceOverlapCheckSpecial(DefId),\n+    CoherenceOverlapInherentCheck(DefId),\n     CoherenceOrphanCheck(DefId),\n     Variance,\n     WfCheck(DefId),"}, {"sha": "3eca4624bc17dd463c2271c1e7b11065926d6127", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -458,14 +458,13 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n }\n \n pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                   a_is_expected: bool,\n-                                   origin: TypeOrigin,\n-                                   a: ty::TraitRef<'tcx>,\n-                                   b: ty::TraitRef<'tcx>)\n-                                   -> UnitResult<'tcx>\n+                                  a_is_expected: bool,\n+                                  origin: TypeOrigin,\n+                                  a: ty::TraitRef<'tcx>,\n+                                  b: ty::TraitRef<'tcx>)\n+                                  -> UnitResult<'tcx>\n {\n-    debug!(\"mk_eq_trait_refs({:?} <: {:?})\",\n-           a, b);\n+    debug!(\"mk_eq_trait_refs({:?} = {:?})\", a, b);\n     cx.eq_trait_refs(a_is_expected, origin, a, b)\n }\n \n@@ -476,11 +475,25 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                         b: ty::PolyTraitRef<'tcx>)\n                                         -> UnitResult<'tcx>\n {\n-    debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\",\n-           a, b);\n+    debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\", a, b);\n     cx.sub_poly_trait_refs(a_is_expected, origin, a, b)\n }\n \n+pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                                    a_is_expected: bool,\n+                                    origin: TypeOrigin,\n+                                    a: &ty::ImplHeader<'tcx>,\n+                                    b: &ty::ImplHeader<'tcx>)\n+                                    -> UnitResult<'tcx>\n+{\n+    debug!(\"mk_eq_impl_header({:?} = {:?})\", a, b);\n+    match (a.trait_ref, b.trait_ref) {\n+        (Some(a_ref), Some(b_ref)) => mk_eq_trait_refs(cx, a_is_expected, origin, a_ref, b_ref),\n+        (None, None) => mk_eqty(cx, a_is_expected, origin, a.self_ty, b.self_ty),\n+        _ => cx.tcx.sess.bug(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+    }\n+}\n+\n fn expected_found<T>(a_is_expected: bool,\n                      a: T,\n                      b: T)"}, {"sha": "6005d36ff4eb20c79bc36592fd85fca6fc27d185", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 25, "deletions": 69, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -10,29 +10,25 @@\n \n //! See `README.md` for high-level documentation\n \n-use super::Normalized;\n-use super::SelectionContext;\n-use super::ObligationCause;\n-use super::PredicateObligation;\n-use super::project;\n-use super::util;\n+use super::{SelectionContext};\n+use super::{Obligation, ObligationCause};\n \n use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n-use middle::subst::{Subst, Substs, TypeSpace};\n+use middle::subst::TypeSpace;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::infer::{self, InferCtxt, TypeOrigin};\n-use syntax::codemap::{DUMMY_SP, Span};\n+use syntax::codemap::DUMMY_SP;\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n-/// If there are types that satisfy both impls, returns a `TraitRef`\n+/// If there are types that satisfy both impls, returns an `ImplTy`\n /// with those types substituted (by updating the given `infcx`)\n pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n                                     impl1_def_id: DefId,\n                                     impl2_def_id: DefId)\n-                                    -> Option<ty::TraitRef<'tcx>>\n+                                    -> Option<ty::ImplHeader<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -45,34 +41,28 @@ pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n }\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n-/// `where` clauses)? If so, returns a `TraitRef` that unifies the two impls.\n+/// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n                       a_def_id: DefId,\n                       b_def_id: DefId)\n-                      -> Option<ty::TraitRef<'tcx>>\n+                      -> Option<ty::ImplHeader<'tcx>>\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n            a_def_id,\n            b_def_id);\n \n-    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n-                                                                a_def_id,\n-                                                                util::fresh_type_vars_for_impl);\n+    let a_impl_header = ty::ImplHeader::with_fresh_ty_vars(selcx, a_def_id);\n+    let b_impl_header = ty::ImplHeader::with_fresh_ty_vars(selcx, b_def_id);\n \n-    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx,\n-                                                                b_def_id,\n-                                                                util::fresh_type_vars_for_impl);\n-\n-    debug!(\"overlap: a_trait_ref={:?} a_obligations={:?}\", a_trait_ref, a_obligations);\n-\n-    debug!(\"overlap: b_trait_ref={:?} b_obligations={:?}\", b_trait_ref, b_obligations);\n+    debug!(\"overlap: a_impl_header={:?}\", a_impl_header);\n+    debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    if let Err(_) = infer::mk_eq_trait_refs(selcx.infcx(),\n-                                            true,\n-                                            TypeOrigin::Misc(DUMMY_SP),\n-                                            a_trait_ref,\n-                                            b_trait_ref) {\n+    if let Err(_) = infer::mk_eq_impl_headers(selcx.infcx(),\n+                                              true,\n+                                              TypeOrigin::Misc(DUMMY_SP),\n+                                              &a_impl_header,\n+                                              &b_impl_header) {\n         return None;\n     }\n \n@@ -81,17 +71,21 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     // Are any of the obligations unsatisfiable? If so, no overlap.\n     let infcx = selcx.infcx();\n     let opt_failing_obligation =\n-        a_obligations.iter()\n-                     .chain(&b_obligations)\n-                     .map(|o| infcx.resolve_type_vars_if_possible(o))\n+        a_impl_header.predicates\n+                     .iter()\n+                     .chain(&b_impl_header.predicates)\n+                     .map(|p| infcx.resolve_type_vars_if_possible(p))\n+                     .map(|p| Obligation { cause: ObligationCause::dummy(),\n+                                           recursion_depth: 0,\n+                                           predicate: p })\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n         return None\n     }\n \n-    Some(selcx.infcx().resolve_type_vars_if_possible(&a_trait_ref))\n+    Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n }\n \n pub fn trait_ref_is_knowable<'tcx>(tcx: &TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n@@ -125,44 +119,6 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &TyCtxt<'tcx>, trait_ref: &ty::TraitRef<\n     orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(true)).is_err()\n }\n \n-type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n-                                span: Span,\n-                                impl_def_id: DefId)\n-                                -> Substs<'tcx>;\n-\n-/// Instantiate fresh variables for all bound parameters of the impl\n-/// and return the impl trait ref with those variables substituted.\n-fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                                     impl_def_id: DefId,\n-                                     substs_fn: SubstsFn)\n-                                     -> (ty::TraitRef<'tcx>,\n-                                         Vec<PredicateObligation<'tcx>>)\n-{\n-    let impl_substs =\n-        &substs_fn(selcx.infcx(), DUMMY_SP, impl_def_id);\n-    let impl_trait_ref =\n-        selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n-    let impl_trait_ref =\n-        impl_trait_ref.subst(selcx.tcx(), impl_substs);\n-    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n-        project::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n-\n-    let predicates = selcx.tcx().lookup_predicates(impl_def_id);\n-    let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n-    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n-        project::normalize(selcx, ObligationCause::dummy(), &predicates);\n-    let impl_obligations =\n-        util::predicates_for_generics(ObligationCause::dummy(), 0, &predicates);\n-\n-    let impl_obligations: Vec<_> =\n-        impl_obligations.into_iter()\n-        .chain(normalization_obligations1)\n-        .chain(normalization_obligations2)\n-        .collect();\n-\n-    (impl_trait_ref, impl_obligations)\n-}\n-\n pub enum OrphanCheckErr<'tcx> {\n     NoLocalInputType,\n     UncoveredTy(Ty<'tcx>),"}, {"sha": "fbfd4b67b5bd5393b8c71ad2b62f98ca8f281bec", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -391,7 +391,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n-\n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n     pub fn evaluate_obligation(&mut self,\n                                obligation: &PredicateObligation<'tcx>)"}, {"sha": "090d4eeb87437bcc7bf7cb783fd7c0d9881657ff", "filename": "src/librustc/middle/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -146,6 +146,10 @@ pub trait TypeFolder<'tcx> : Sized {\n         t.super_fold_with(self)\n     }\n \n+    fn fold_impl_header(&mut self, imp: &ty::ImplHeader<'tcx>) -> ty::ImplHeader<'tcx> {\n+        imp.super_fold_with(self)\n+    }\n+\n     fn fold_substs(&mut self,\n                    substs: &subst::Substs<'tcx>)\n                    -> subst::Substs<'tcx> {"}, {"sha": "b54b0b73ef292fd4e92577aaa3142195453371e5", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -152,6 +152,41 @@ impl ImplOrTraitItemContainer {\n     }\n }\n \n+/// The \"header\" of an impl is everything outside the body: a Self type, a trait\n+/// ref (in the case of a trait impl), and a set of predicates (from the\n+/// bounds/where clauses).\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ImplHeader<'tcx> {\n+    pub impl_def_id: DefId,\n+    pub self_ty: Ty<'tcx>,\n+    pub trait_ref: Option<TraitRef<'tcx>>,\n+    pub predicates: Vec<Predicate<'tcx>>,\n+}\n+\n+impl<'tcx> ImplHeader<'tcx> {\n+    pub fn with_fresh_ty_vars<'a>(selcx: &mut traits::SelectionContext<'a, 'tcx>,\n+                                  impl_def_id: DefId)\n+                                  -> ImplHeader<'tcx>\n+    {\n+        let tcx = selcx.tcx();\n+        let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n+        let impl_substs = selcx.infcx().fresh_substs_for_generics(DUMMY_SP, &impl_generics);\n+\n+        let header = ImplHeader {\n+            impl_def_id: impl_def_id,\n+            self_ty: tcx.lookup_item_type(impl_def_id).ty,\n+            trait_ref: tcx.impl_trait_ref(impl_def_id),\n+            predicates: tcx.lookup_predicates(impl_def_id).predicates.into_vec(),\n+        }.subst(tcx, &impl_substs);\n+\n+        let traits::Normalized { value: mut header, obligations } =\n+            traits::normalize(selcx, traits::ObligationCause::dummy(), &header);\n+\n+        header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n+        header\n+    }\n+}\n+\n #[derive(Clone)]\n pub enum ImplOrTraitItem<'tcx> {\n     ConstTraitItem(Rc<AssociatedConst<'tcx>>),"}, {"sha": "57cfdd0d8b8aecd727a8fa58d9ea36e811dd098d", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -446,6 +446,27 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ImplHeader {\n+            impl_def_id: self.impl_def_id,\n+            self_ty: self.self_ty.fold_with(folder),\n+            trait_ref: self.trait_ref.map(|t| t.fold_with(folder)),\n+            predicates: self.predicates.iter().map(|p| p.fold_with(folder)).collect(),\n+        }\n+    }\n+\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_impl_header(self)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.self_ty.visit_with(visitor) ||\n+            self.trait_ref.map(|r| r.visit_with(visitor)).unwrap_or(false) ||\n+            self.predicates.iter().any(|p| p.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n         *self"}, {"sha": "9dc8d7ae943a110ace0790197552e9f4d90afa1d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -35,7 +35,9 @@ use CrateCtxt;\n use middle::infer::{self, InferCtxt, TypeOrigin, new_infer_ctxt};\n use std::cell::RefCell;\n use std::rc::Rc;\n+use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::errors::DiagnosticBuilder;\n use util::nodemap::{DefIdMap, FnvHashMap};\n use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n@@ -519,6 +521,13 @@ fn enforce_trait_manually_implementable(tcx: &TyCtxt, sp: Span, trait_def_id: De\n     err.emit();\n }\n \n+// Factored out into helper because the error cannot be defined in multiple locations.\n+pub fn report_duplicate_item<'tcx>(tcx: &TyCtxt<'tcx>, sp: Span, name: ast::Name)\n+                                   -> DiagnosticBuilder<'tcx>\n+{\n+    struct_span_err!(tcx.sess, sp, E0201, \"duplicate definitions with name `{}`:\", name)\n+}\n+\n pub fn check_coherence(crate_context: &CrateCtxt) {\n     let _task = crate_context.tcx.dep_graph.in_task(DepNode::Coherence);\n     let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None);"}, {"sha": "80430076f197d6294d6403ff043f8ea0590e94a8", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n //! Overlap: No two impls for the same trait are implemented for the\n-//! same type.\n+//! same type. Likewise, no two inherent impls for a given type\n+//! constructor provide a method with the same name.\n \n use middle::cstore::{CrateStore, LOCAL_CRATE};\n use middle::def_id::DefId;\n@@ -115,7 +116,6 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         }\n     }\n \n-\n     fn check_if_impls_overlap(&self,\n                               impl1_def_id: DefId,\n                               impl2_def_id: DefId)\n@@ -128,8 +128,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl2_def_id);\n \n             let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n-            if let Some(trait_ref) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-                self.report_overlap_error(impl1_def_id, impl2_def_id, trait_ref);\n+            if let Some(header) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+                self.report_overlap_error(impl1_def_id, impl2_def_id, header.trait_ref.unwrap());\n             }\n         }\n     }\n@@ -150,13 +150,13 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             }).unwrap_or(String::new())\n         };\n \n-        let mut err = struct_span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n+        let mut err = struct_span_err!(self.tcx.sess, self.span_of_def_id(impl1), E0119,\n                                        \"conflicting implementations of trait `{}`{}:\",\n                                        trait_ref,\n                                        self_type);\n \n         if impl2.is_local() {\n-            span_note!(&mut err, self.span_of_impl(impl2),\n+            span_note!(&mut err, self.span_of_def_id(impl2),\n                        \"conflicting implementation is here:\");\n         } else {\n             let cname = self.tcx.sess.cstore.crate_name(impl2.krate);\n@@ -165,10 +165,61 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         err.emit();\n     }\n \n-    fn span_of_impl(&self, impl_did: DefId) -> Span {\n-        let node_id = self.tcx.map.as_local_node_id(impl_did).unwrap();\n+    fn span_of_def_id(&self, did: DefId) -> Span {\n+        let node_id = self.tcx.map.as_local_node_id(did).unwrap();\n         self.tcx.map.span(node_id)\n     }\n+\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+        #[derive(Copy, Clone, PartialEq)]\n+        enum Namespace { Type, Value }\n+\n+        fn name_and_namespace(tcx: &TyCtxt, item: &ty::ImplOrTraitItemId)\n+                              -> (ast::Name, Namespace)\n+        {\n+            let name = tcx.impl_or_trait_item(item.def_id()).name();\n+            (name, match *item {\n+                ty::TypeTraitItemId(..) => Namespace::Type,\n+                ty::ConstTraitItemId(..) => Namespace::Value,\n+                ty::MethodTraitItemId(..) => Namespace::Value,\n+            })\n+        }\n+\n+        let impl_items = self.tcx.impl_items.borrow();\n+\n+        for item1 in &impl_items[&impl1] {\n+            let (name, namespace) = name_and_namespace(&self.tcx, item1);\n+\n+            for item2 in &impl_items[&impl2] {\n+                if (name, namespace) == name_and_namespace(&self.tcx, item2) {\n+                    let mut err = super::report_duplicate_item(\n+                        &self.tcx, self.span_of_def_id(item1.def_id()), name);\n+                    span_note!(&mut err, self.span_of_def_id(item2.def_id()),\n+                               \"conflicting definition is here:\");\n+                    err.emit();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n+        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n+\n+        let inherent_impls = self.tcx.inherent_impls.borrow();\n+        let impls = match inherent_impls.get(&ty_def_id) {\n+            Some(impls) => impls,\n+            None => return\n+        };\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            for &impl2_def_id in &impls[(i+1)..] {\n+                let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n+                if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n+                    self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                }\n+            }\n+        }\n+    }\n }\n \n \n@@ -180,6 +231,11 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 self.check_for_overlapping_impls_of_trait(trait_def_id);\n             }\n \n+            hir::ItemEnum(..) | hir::ItemStruct(..) => {\n+                let type_def_id = self.tcx.map.local_def_id(item.id);\n+                self.check_for_overlapping_inherent_impls(type_def_id);\n+            }\n+\n             hir::ItemDefaultImpl(..) => {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be"}, {"sha": "b493b64a45fcf9f650c3bc0fa76ec1377fb6a88b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -63,6 +63,7 @@ use lint;\n use middle::def::Def;\n use middle::def_id::DefId;\n use constrained_type_params as ctp;\n+use coherence;\n use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime;\n use middle::const_eval::{self, ConstVal};\n@@ -750,17 +751,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     _                    => &mut seen_value_items,\n                 };\n                 if !seen_items.insert(impl_item.name) {\n-                    let desc = match impl_item.node {\n-                        hir::ImplItemKind::Const(_, _) => \"associated constant\",\n-                        hir::ImplItemKind::Type(_) => \"associated type\",\n-                        hir::ImplItemKind::Method(ref sig, _) =>\n-                            match sig.explicit_self.node {\n-                                hir::SelfStatic => \"associated function\",\n-                                _ => \"method\",\n-                            },\n-                    };\n-\n-                    span_err!(tcx.sess, impl_item.span, E0201, \"duplicate {}\", desc);\n+                    coherence::report_duplicate_item(tcx, impl_item.span, impl_item.name).emit();\n                 }\n \n                 if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {"}, {"sha": "5c411bec5065d132b2c08385b65649de6e604239", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -2285,6 +2285,21 @@ impl Baz for Foo {\n     type Quux = u32;\n }\n ```\n+\n+Note, however, that items with the same name are allowed for inherent `impl`\n+blocks that don't overlap:\n+\n+```\n+struct Foo<T>(T);\n+\n+impl Foo<u8> {\n+    fn bar(&self) -> bool { self.0 > 5 }\n+}\n+\n+impl Foo<bool> {\n+    fn bar(&self) -> bool { self.0 }\n+}\n+```\n \"##,\n \n E0202: r##\""}, {"sha": "ab903591fbb069b3f15a68b30cb19812965b8f20", "filename": "src/test/compile-fail/associated-item-duplicate-names-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names-2.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -14,7 +14,7 @@ struct Foo;\n \n impl Foo {\n     const bar: bool = true;\n-    fn bar() {} //~ ERROR duplicate associated function\n+    fn bar() {} //~ ERROR duplicate definitions\n }\n \n fn main() {}"}, {"sha": "12cab13d0b9b33bee7402b73e4f4d515b9bb2f6d", "filename": "src/test/compile-fail/associated-item-duplicate-names-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names-3.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -20,7 +20,7 @@ struct Baz;\n \n impl Foo for Baz {\n     type Bar = i16;\n-    type Bar = u16; //~ ERROR duplicate associated type\n+    type Bar = u16; //~ ERROR duplicate definitions\n }\n \n fn main() {"}, {"sha": "85868f5c02085df966afe230c66a480cde32f3cd", "filename": "src/test/compile-fail/associated-item-duplicate-names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-item-duplicate-names.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -19,9 +19,9 @@ trait Foo {\n \n impl Foo for () {\n     type Ty = ();\n-    type Ty = usize; //~ ERROR duplicate associated type\n+    type Ty = usize; //~ ERROR duplicate definitions\n     const BAR: u32 = 7;\n-    const BAR: u32 = 8; //~ ERROR duplicate associated constant\n+    const BAR: u32 = 8; //~ ERROR duplicate definitions\n }\n \n fn main() {"}, {"sha": "148958ae128970624c30498fc6de5b8c2f618a8f", "filename": "src/test/compile-fail/impl-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n impl Foo {\n     fn orange(&self){}\n-    fn orange(&self){}   //~ ERROR duplicate method\n+    fn orange(&self){}   //~ ERROR duplicate definitions\n }\n \n fn main() {}"}, {"sha": "5b014dbfd2255a2149581c0429b29c078350a1dd", "filename": "src/test/compile-fail/inherent-overlap.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Finherent-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Finherent-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherent-overlap.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that you cannot define items with the same name in overlapping inherent\n+// impl blocks.\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn id() {} //~ ERROR E0201\n+}\n+\n+impl Foo {\n+    fn id() {}\n+}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Bar<T> {\n+    fn bar(&self) {} //~ ERROR E0201\n+}\n+\n+impl Bar<u32> {\n+    fn bar(&self) {}\n+}\n+\n+struct Baz<T>(T);\n+\n+impl<T: Copy> Baz<T> {\n+    fn baz(&self) {} //~ ERROR E0201\n+}\n+\n+impl<T> Baz<Vec<T>> {\n+    fn baz(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "62db68dcbb2ee63f7ceb8eaf446c9a2a0acce957", "filename": "src/test/compile-fail/issue-4265.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -17,7 +17,7 @@ impl Foo {\n         Foo { baz: 0 }.bar();\n     }\n \n-    fn bar() { //~ ERROR duplicate associated function\n+    fn bar() { //~ ERROR duplicate definitions\n     }\n }\n "}, {"sha": "457918b54d4aed619e5ef128085a0ccb03fa1ad1", "filename": "src/test/compile-fail/issue-8153.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fissue-8153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fissue-8153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8153.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -18,7 +18,7 @@ trait Bar {\n \n impl Bar for Foo {\n     fn bar(&self) -> isize {1}\n-    fn bar(&self) -> isize {2} //~ ERROR duplicate method\n+    fn bar(&self) -> isize {2} //~ ERROR duplicate definitions\n }\n \n fn main() {"}, {"sha": "f3c227849dcbeea03b0ec7f80d728c1647339751", "filename": "src/test/compile-fail/method-macro-backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -29,7 +29,7 @@ impl S {\n \n     // Cause an error. It shouldn't have any macro backtrace frames.\n     fn bar(&self) { }\n-    fn bar(&self) { } //~ ERROR duplicate method\n+    fn bar(&self) { } //~ ERROR duplicate definitions\n }\n \n fn main() { }"}, {"sha": "25c97ee2c76a9833af7d76a586bc4e4d1c20f50b", "filename": "src/test/rustdoc/issue-25001.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a019dc86de1459809f776b869e36f8e71a7665a/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-25001.rs?ref=1a019dc86de1459809f776b869e36f8e71a7665a", "patch": "@@ -17,15 +17,15 @@ pub trait Bar {\n     fn quux(self);\n }\n \n-impl<T> Foo<T> {\n+impl Foo<u8> {\n     // @has - '//*[@id=\"method.pass\"]//code' 'fn pass()'\n     pub fn pass() {}\n }\n-impl<T> Foo<T> {\n+impl Foo<u16> {\n     // @has - '//*[@id=\"method.pass-1\"]//code' 'fn pass() -> usize'\n     pub fn pass() -> usize { 42 }\n }\n-impl<T> Foo<T> {\n+impl Foo<u32> {\n     // @has - '//*[@id=\"method.pass-2\"]//code' 'fn pass() -> isize'\n     pub fn pass() -> isize { 42 }\n }"}]}