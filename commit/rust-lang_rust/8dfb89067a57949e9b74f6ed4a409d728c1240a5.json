{"sha": "8dfb89067a57949e9b74f6ed4a409d728c1240a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZmI4OTA2N2E1Nzk0OWU5Yjc0ZjZlZDRhNDA5ZDcyOGMxMjQwYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-16T08:51:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-16T08:51:30Z"}, "message": "Auto merge of #28353 - GuillaumeGomez:error_codes, r=Manishearth\n\nr? @Manishearth \r\n\r\nThis is a work in progress.", "tree": {"sha": "150efb1104afe9f1920e3372a42f13989dee0820", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/150efb1104afe9f1920e3372a42f13989dee0820"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dfb89067a57949e9b74f6ed4a409d728c1240a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dfb89067a57949e9b74f6ed4a409d728c1240a5", "html_url": "https://github.com/rust-lang/rust/commit/8dfb89067a57949e9b74f6ed4a409d728c1240a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dfb89067a57949e9b74f6ed4a409d728c1240a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fe126af2ec65eb0dc49cdfecd437d422c68c686", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe126af2ec65eb0dc49cdfecd437d422c68c686", "html_url": "https://github.com/rust-lang/rust/commit/1fe126af2ec65eb0dc49cdfecd437d422c68c686"}, {"sha": "e6f6da119e7c5a3b8c24893d111b7e2422ec57fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6f6da119e7c5a3b8c24893d111b7e2422ec57fd", "html_url": "https://github.com/rust-lang/rust/commit/e6f6da119e7c5a3b8c24893d111b7e2422ec57fd"}], "stats": {"total": 443, "additions": 295, "deletions": 148}, "files": [{"sha": "19c880905aeb8f200040ad464f07533a4e69934d", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 153, "deletions": 2, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -1886,7 +1886,117 @@ This explicitly states that you expect the trait object `SomeTrait` to\n contain references (with a maximum lifetime of `'a`).\n \n [1]: https://github.com/rust-lang/rfcs/pull/1156\n-\"##\n+\"##,\n+\n+E0454: r##\"\n+A link name was given with an empty name. Erroneous code example:\n+\n+```\n+#[link(name = \"\")] extern {} // error: #[link(name = \"\")] given with empty name\n+```\n+\n+The rust compiler cannot link to an external library if you don't give it its\n+name. Example:\n+\n+```\n+#[link(name = \"some_lib\")] extern {} // ok!\n+```\n+\"##,\n+\n+E0458: r##\"\n+An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n+\n+```\n+#[link(kind = \"wonderful_unicorn\")] extern {}\n+// error: unknown kind: `wonderful_unicorn`\n+```\n+\n+Please specify a valid \"kind\" value, from one of the following:\n+ * static\n+ * dylib\n+ * framework\n+\"##,\n+\n+E0459: r##\"\n+A link was used without a name parameter. Erroneous code example:\n+\n+```\n+#[link(kind = \"dylib\")] extern {}\n+// error: #[link(...)] specified without `name = \"foo\"`\n+```\n+\n+Please add the name parameter to allow the rust compiler to find the library\n+you want. Example:\n+\n+```\n+#[link(kind = \"dylib\", name = \"some_lib\")] extern {} // ok!\n+```\n+\"##,\n+\n+E0493: r##\"\n+A type with a destructor was assigned to an invalid type of variable. Erroneous\n+code example:\n+\n+```\n+struct Foo {\n+    a: u32\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+const F : Foo = Foo { a : 0 };\n+// error: constants are not allowed to have destructors\n+static S : Foo = Foo { a : 0 };\n+// error: statics are not allowed to have destructors\n+```\n+\n+To solve this issue, please use a type which does allow the usage of type with\n+destructors.\n+\"##,\n+\n+E0494: r##\"\n+A reference of an interior static was assigned to another const/static.\n+Erroneous code example:\n+\n+```\n+struct Foo {\n+    a: u32\n+}\n+\n+static S : Foo = Foo { a : 0 };\n+static A : &'static u32 = &S.a;\n+// error: cannot refer to the interior of another static, use a\n+//        constant instead\n+```\n+\n+The \"base\" variable has to be a const if you want another static/const variable\n+to refer to one of its fields. Example:\n+\n+```\n+struct Foo {\n+    a: u32\n+}\n+\n+const S : Foo = Foo { a : 0 };\n+static A : &'static u32 = &S.a; // ok!\n+```\n+\"##,\n+\n+E0497: r##\"\n+A stability attribute was used outside of the standard library. Erroneous code\n+example:\n+\n+```\n+#[stable] // error: stability attributes may not be used outside of the\n+          //        standard library\n+fn foo() {}\n+```\n+\n+It is not possible to use stability attributes outside of the standard library.\n+Also, for now, it is not possible to write deprecation messages either.\n+\"##,\n \n }\n \n@@ -1914,5 +2024,46 @@ register_diagnostics! {\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n-    E0400  // overloaded derefs are not allowed in constants\n+    E0400, // overloaded derefs are not allowed in constants\n+    E0452, // malformed lint attribute\n+    E0453, // overruled by outer forbid\n+    E0455, // native frameworks are only available on OSX targets\n+    E0456, // plugin `..` is not available for triple `..`\n+    E0457, // plugin `..` only found in rlib format, but must be available...\n+    E0460, // found possibly newer version of crate `..`\n+    E0461, // couldn't find crate `..` with expected target triple ..\n+    E0462, // found staticlib `..` instead of rlib or dylib\n+    E0463, // can't find crate for `..`\n+    E0464, // multiple matching crates for `..`\n+    E0465, // multiple .. candidates for `..` found\n+    E0466, // bad macro import\n+    E0467, // bad macro reexport\n+    E0468, // an `extern crate` loading macros must be at the crate root\n+    E0469, // imported macro not found\n+    E0470, // reexported macro not found\n+    E0471, // constant evaluation error: ..\n+    E0472, // asm! is unsupported on this target\n+    E0473, // dereference of reference outside its lifetime\n+    E0474, // captured variable `..` does not outlive the enclosing closure\n+    E0475, // index of slice outside its lifetime\n+    E0476, // lifetime of the source pointer does not outlive lifetime bound...\n+    E0477, // the type `..` does not fulfill the required lifetime...\n+    E0478, // lifetime bound not satisfied\n+    E0479, // the type `..` (provided as the value of a type parameter) is...\n+    E0480, // lifetime of method receiver does not outlive the method call\n+    E0481, // lifetime of function argument does not outlive the function call\n+    E0482, // lifetime of return value does not outlive the function call\n+    E0483, // lifetime of operand does not outlive the operation\n+    E0484, // reference is not valid at the time of borrow\n+    E0485, // automatically reference is not valid at the time of borrow\n+    E0486, // type of expression contains references that are not valid during...\n+    E0487, // unsafe use of destructor: destructor might be called while...\n+    E0488, // lifetime of variable does not enclose its declaration\n+    E0489, // type/lifetime parameter not in scope here\n+    E0490, // a value of type `..` is borrowed for too long\n+    E0491, // in type `..`, reference has a longer lifetime than the data it...\n+    E0492, // cannot borrow a constant which contains interior mutability\n+    E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n+    E0496, // .. name `..` shadows a .. name that is already in scope\n+    E0498, // malformed plugin attribute\n }"}, {"sha": "dade1f4eb26fa0a553715a877d9acfd33c378896", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -433,7 +433,8 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         for result in gather_attrs(attrs) {\n             let v = match result {\n                 Err(span) => {\n-                    self.tcx.sess.span_err(span, \"malformed lint attribute\");\n+                    span_err!(self.tcx.sess, span, E0452,\n+                              \"malformed lint attribute\");\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n@@ -462,10 +463,10 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                 let now = self.lints.get_level_source(lint_id).0;\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n-                    self.tcx.sess.span_err(span,\n-                                           &format!(\"{}({}) overruled by outer forbid({})\",\n-                                                   level.as_str(), lint_name,\n-                                                   lint_name));\n+                    span_err!(self.tcx.sess, span, E0453,\n+                              \"{}({}) overruled by outer forbid({})\",\n+                              level.as_str(), lint_name,\n+                              lint_name);\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));"}, {"sha": "64f808dc67805aa210c1e855d774733b3e9915a5", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -119,8 +119,8 @@ fn register_native_lib(sess: &Session,\n     if name.is_empty() {\n         match span {\n             Some(span) => {\n-                sess.span_err(span, \"#[link(name = \\\"\\\")] given with \\\n-                                     empty name\");\n+                span_err!(sess, span, E0454,\n+                          \"#[link(name = \\\"\\\")] given with empty name\");\n             }\n             None => {\n                 sess.err(\"empty library name given via `-l`\");\n@@ -132,7 +132,10 @@ fn register_native_lib(sess: &Session,\n     if kind == cstore::NativeFramework && !is_osx {\n         let msg = \"native frameworks are only available on OSX targets\";\n         match span {\n-            Some(span) => sess.span_err(span, msg),\n+            Some(span) => {\n+                span_err!(sess, span, E0455,\n+                          \"{}\", msg)\n+            }\n             None => sess.err(msg),\n         }\n     }\n@@ -514,7 +517,7 @@ impl<'a> CrateReader<'a> {\n                                   name,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(span, &message[..]);\n+            span_err!(self.sess, span, E0456, \"{}\", &message[..]);\n             self.sess.abort_if_errors();\n         }\n \n@@ -524,10 +527,10 @@ impl<'a> CrateReader<'a> {\n         match (ekrate.dylib.as_ref(), registrar) {\n             (Some(dylib), Some(reg)) => Some((dylib.to_path_buf(), reg)),\n             (None, Some(_)) => {\n-                let message = format!(\"plugin `{}` only found in rlib format, \\\n-                                       but must be available in dylib format\",\n-                                       name);\n-                self.sess.span_err(span, &message[..]);\n+                span_err!(self.sess, span, E0457,\n+                          \"plugin `{}` only found in rlib format, but must be available \\\n+                           in dylib format\",\n+                          name);\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None\n@@ -760,7 +763,8 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                 Some(\"dylib\") => cstore::NativeUnknown,\n                 Some(\"framework\") => cstore::NativeFramework,\n                 Some(k) => {\n-                    self.sess.span_err(m.span, &format!(\"unknown kind: `{}`\", k));\n+                    span_err!(self.sess, m.span, E0458,\n+                              \"unknown kind: `{}`\", k);\n                     cstore::NativeUnknown\n                 }\n                 None => cstore::NativeUnknown\n@@ -771,8 +775,8 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n             let n = match n {\n                 Some(n) => n,\n                 None => {\n-                    self.sess.span_err(m.span, \"#[link(...)] specified without \\\n-                                                `name = \\\"foo\\\"`\");\n+                    span_err!(self.sess, m.span, E0459,\n+                              \"#[link(...)] specified without `name = \\\"foo\\\"`\");\n                     InternedString::new(\"foo\")\n                 }\n             };"}, {"sha": "99d1eaebdb2518da848f9b4c7ee34d196ca0fdb8", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -308,23 +308,28 @@ impl<'a> Context<'a> {\n     }\n \n     pub fn report_load_errs(&mut self) {\n-        let message = if !self.rejected_via_hash.is_empty() {\n-            format!(\"found possibly newer version of crate `{}`\",\n-                    self.ident)\n+        let add = match self.root {\n+            &None => String::new(),\n+            &Some(ref r) => format!(\" which `{}` depends on\",\n+                                    r.ident)\n+        };\n+        if !self.rejected_via_hash.is_empty() {\n+            span_err!(self.sess, self.span, E0460,\n+                      \"found possibly newer version of crate `{}`{}\",\n+                      self.ident, add);\n         } else if !self.rejected_via_triple.is_empty() {\n-            format!(\"couldn't find crate `{}` with expected target triple {}\",\n-                    self.ident, self.triple)\n+            span_err!(self.sess, self.span, E0461,\n+                      \"couldn't find crate `{}` with expected target triple {}{}\",\n+                      self.ident, self.triple, add);\n         } else if !self.rejected_via_kind.is_empty() {\n-            format!(\"found staticlib `{}` instead of rlib or dylib\", self.ident)\n+            span_err!(self.sess, self.span, E0462,\n+                      \"found staticlib `{}` instead of rlib or dylib{}\",\n+                      self.ident, add);\n         } else {\n-            format!(\"can't find crate for `{}`\", self.ident)\n-        };\n-        let message = match self.root {\n-            &None => message,\n-            &Some(ref r) => format!(\"{} which `{}` depends on\",\n-                                    message, r.ident)\n-        };\n-        self.sess.span_err(self.span, &message[..]);\n+            span_err!(self.sess, self.span, E0463,\n+                      \"can't find crate for `{}`{}\",\n+                      self.ident, add);\n+        }\n \n         if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n@@ -473,9 +478,9 @@ impl<'a> Context<'a> {\n             0 => None,\n             1 => Some(libraries.into_iter().next().unwrap()),\n             _ => {\n-                self.sess.span_err(self.span,\n-                    &format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name));\n+                span_err!(self.sess, self.span, E0464,\n+                          \"multiple matching crates for `{}`\",\n+                          self.crate_name);\n                 self.sess.note(\"candidates:\");\n                 for lib in &libraries {\n                     match lib.dylib {\n@@ -543,11 +548,9 @@ impl<'a> Context<'a> {\n                 }\n             };\n             if ret.is_some() {\n-                self.sess.span_err(self.span,\n-                                   &format!(\"multiple {} candidates for `{}` \\\n-                                            found\",\n-                                           flavor,\n-                                           self.crate_name));\n+                span_err!(self.sess, self.span, E0465,\n+                          \"multiple {} candidates for `{}` found\",\n+                          flavor, self.crate_name);\n                 self.sess.span_note(self.span,\n                                     &format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap().0"}, {"sha": "ca5999afbd3afc231256a08fd0d678842ccc3b6c", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -40,6 +40,10 @@ impl<'a> MacroLoader<'a> {\n     }\n }\n \n+pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n+    span_err!(a, b, E0467, \"bad macro reexport\");\n+}\n+\n /// Read exported macros.\n pub fn read_macro_defs(sess: &Session, krate: &ast::Crate) -> Vec<ast::MacroDef> {\n     let mut loader = MacroLoader::new(sess);\n@@ -90,7 +94,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n                             if let ast::MetaWord(ref name) = attr.node {\n                                 sel.insert(name.clone(), attr.span);\n                             } else {\n-                                self.sess.span_err(attr.span, \"bad macro import\");\n+                                span_err!(self.sess, attr.span, E0466, \"bad macro import\");\n                             }\n                         }\n                     }\n@@ -99,7 +103,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n                     let names = match attr.meta_item_list() {\n                         Some(names) => names,\n                         None => {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            call_bad_macro_reexport(self.sess, attr.span);\n                             continue;\n                         }\n                     };\n@@ -108,7 +112,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n                         if let ast::MetaWord(ref name) = attr.node {\n                             reexport.insert(name.clone(), attr.span);\n                         } else {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            call_bad_macro_reexport(self.sess, attr.span);\n                         }\n                     }\n                 }\n@@ -140,8 +144,8 @@ impl<'a> MacroLoader<'a> {\n         }\n \n         if !self.span_whitelist.contains(&vi.span) {\n-            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n-                                         the crate root\");\n+            span_err!(self.sess, vi.span, E0468,\n+                      \"an `extern crate` loading macros must be at the crate root\");\n             return;\n         }\n \n@@ -166,14 +170,16 @@ impl<'a> MacroLoader<'a> {\n         if let Some(sel) = import.as_ref() {\n             for (name, span) in sel {\n                 if !seen.contains(&name) {\n-                    self.sess.span_err(*span, \"imported macro not found\");\n+                    span_err!(self.sess, *span, E0469,\n+                              \"imported macro not found\");\n                 }\n             }\n         }\n \n         for (name, span) in &reexport {\n             if !seen.contains(&name) {\n-                self.sess.span_err(*span, \"reexported macro not found\");\n+                span_err!(self.sess, *span, E0470,\n+                          \"reexported macro not found\");\n             }\n         }\n     }"}, {"sha": "d0451026d27ac4f0a6de5ecd9b29e3925672b056", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -499,9 +499,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n                     outer = outer | ConstQualif::NOT_CONST;\n                     if self.mode != Mode::Var {\n-                        self.tcx.sess.span_err(ex.span,\n-                            \"cannot borrow a constant which contains \\\n-                             interior mutability, create a static instead\");\n+                        span_err!(self.tcx.sess, ex.span, E0492,\n+                                  \"cannot borrow a constant which contains \\\n+                                   interior mutability, create a static instead\");\n                     }\n                 }\n                 // If the reference has to be 'static, avoid in-place initialization\n@@ -548,9 +548,9 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ty::TyEnum(def, _) if def.has_dtor() => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n-                v.tcx.sess.span_err(e.span,\n-                                    &format!(\"{}s are not allowed to have destructors\",\n-                                             v.msg()));\n+                span_err!(v.tcx.sess, e.span, E0493,\n+                          \"{}s are not allowed to have destructors\",\n+                          v.msg());\n             }\n         }\n         _ => {}\n@@ -909,9 +909,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                         // Borrowed statics can specifically *only* have their address taken,\n                         // not any number of other borrows such as borrowing fields, reading\n                         // elements of an array, etc.\n-                        self.tcx.sess.span_err(borrow_span,\n-                            \"cannot refer to the interior of another \\\n-                             static, use a constant instead\");\n+                        span_err!(self.tcx.sess, borrow_span, E0494,\n+                                  \"cannot refer to the interior of another \\\n+                                   static, use a constant instead\");\n                     }\n                     break;\n                 }"}, {"sha": "85abfc16628da106f9596cf25a4549315783572b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -282,9 +282,9 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n \n                 Err(err) => {\n                     let subspan = p.span.lo <= err.span.lo && err.span.hi <= p.span.hi;\n-                    cx.tcx.sess.span_err(err.span,\n-                                         &format!(\"constant evaluation error: {}\",\n-                                                  err.description()));\n+                    span_err!(cx.tcx.sess, err.span, E0471,\n+                              \"constant evaluation error: {}\",\n+                              err.description());\n                     if !subspan {\n                         cx.tcx.sess.span_note(p.span,\n                                               \"in pattern here\")"}, {"sha": "b9f8f20536a132ce2272958707a2e708bf076815", "filename": "src/librustc/middle/check_no_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Fcheck_no_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Fcheck_no_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_no_asm.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -32,8 +32,8 @@ struct CheckNoAsm<'a> {\n impl<'a, 'v> Visitor<'v> for CheckNoAsm<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprInlineAsm(_) => self.sess.span_err(e.span,\n-                                                        \"asm! is unsupported on this target\"),\n+            ast::ExprInlineAsm(_) => span_err!(self.sess, e.span, E0472,\n+                                               \"asm! is unsupported on this target\"),\n             _ => {},\n         }\n         visit::walk_expr(self, e)"}, {"sha": "69911c7683d8a4587072742f0f2554184e0445c8", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 59, "deletions": 81, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -718,20 +718,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::DerefPointer(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"dereference of reference outside its lifetime\");\n+                span_err!(self.tcx.sess, span, E0473,\n+                          \"dereference of reference outside its lifetime\");\n                 self.tcx.note_and_explain_region(\n                     \"the reference is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::FreeVariable(span, id) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"captured variable `{}` does not \\\n-                              outlive the enclosing closure\",\n-                             self.tcx.local_var_name_str(id)));\n+                span_err!(self.tcx.sess, span, E0474,\n+                          \"captured variable `{}` does not outlive the enclosing closure\",\n+                          self.tcx.local_var_name_str(id));\n                 self.tcx.note_and_explain_region(\n                     \"captured variable is valid for \",\n                     sup,\n@@ -742,18 +739,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::IndexSlice(span) => {\n-                self.tcx.sess.span_err(span,\n-                                       \"index of slice outside its lifetime\");\n+                span_err!(self.tcx.sess, span, E0475,\n+                          \"index of slice outside its lifetime\");\n                 self.tcx.note_and_explain_region(\n                     \"the slice is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::RelateObjectBound(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of the source pointer does not outlive \\\n-                     lifetime bound of the object type\");\n+                span_err!(self.tcx.sess, span, E0476,\n+                          \"lifetime of the source pointer does not outlive \\\n+                           lifetime bound of the object type\");\n                 self.tcx.note_and_explain_region(\n                     \"object type is valid for \",\n                     sub,\n@@ -764,20 +760,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::RelateParamBound(span, ty) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"the type `{}` does not fulfill the \\\n-                             required lifetime\",\n-                            self.ty_to_string(ty)));\n+                span_err!(self.tcx.sess, span, E0477,\n+                          \"the type `{}` does not fulfill the required lifetime\",\n+                          self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n             }\n             infer::RelateRegionParamBound(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime bound not satisfied\");\n+                span_err!(self.tcx.sess, span, E0478,\n+                          \"lifetime bound not satisfied\");\n                 self.tcx.note_and_explain_region(\n                     \"lifetime parameter instantiated with \",\n                     sup,\n@@ -788,92 +781,82 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::RelateDefaultParamBound(span, ty) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"the type `{}` (provided as the value of \\\n-                             a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty)));\n+                span_err!(self.tcx.sess, span, E0479,\n+                          \"the type `{}` (provided as the value of \\\n+                           a type parameter) is not valid at this point\",\n+                          self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n             }\n             infer::CallRcvr(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of method receiver does not outlive \\\n-                     the method call\");\n+                span_err!(self.tcx.sess, span, E0480,\n+                          \"lifetime of method receiver does not outlive \\\n+                           the method call\");\n                 self.tcx.note_and_explain_region(\n                     \"the receiver is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::CallArg(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of function argument does not outlive \\\n-                     the function call\");\n+                span_err!(self.tcx.sess, span, E0481,\n+                          \"lifetime of function argument does not outlive \\\n+                           the function call\");\n                 self.tcx.note_and_explain_region(\n                     \"the function argument is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::CallReturn(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of return value does not outlive \\\n-                     the function call\");\n+                span_err!(self.tcx.sess, span, E0482,\n+                          \"lifetime of return value does not outlive \\\n+                           the function call\");\n                 self.tcx.note_and_explain_region(\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::Operand(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of operand does not outlive \\\n-                     the operation\");\n+                span_err!(self.tcx.sess, span, E0483,\n+                          \"lifetime of operand does not outlive \\\n+                           the operation\");\n                 self.tcx.note_and_explain_region(\n                     \"the operand is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::AddrOf(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"reference is not valid \\\n-                     at the time of borrow\");\n+                span_err!(self.tcx.sess, span, E0484,\n+                          \"reference is not valid at the time of borrow\");\n                 self.tcx.note_and_explain_region(\n                     \"the borrow is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::AutoBorrow(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"automatically reference is not valid \\\n-                     at the time of borrow\");\n+                span_err!(self.tcx.sess, span, E0485,\n+                          \"automatically reference is not valid \\\n+                           at the time of borrow\");\n                 self.tcx.note_and_explain_region(\n                     \"the automatic borrow is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"type of expression contains references \\\n-                             that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t)));\n+                span_err!(self.tcx.sess, span, E0486,\n+                          \"type of expression contains references \\\n+                           that are not valid during the expression: `{}`\",\n+                          self.ty_to_string(t));\n                 self.tcx.note_and_explain_region(\n                     \"type is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::SafeDestructor(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"unsafe use of destructor: destructor might be called \\\n-                     while references are dead\");\n+                span_err!(self.tcx.sess, span, E0487,\n+                          \"unsafe use of destructor: destructor might be called \\\n+                           while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n                 self.tcx.note_and_explain_region(\n                     \"superregion: \",\n@@ -885,37 +868,33 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of variable does not enclose its declaration\");\n+                span_err!(self.tcx.sess, span, E0488,\n+                          \"lifetime of variable does not enclose its declaration\");\n                 self.tcx.note_and_explain_region(\n                     \"the variable is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::ParameterInScope(_, span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"type/lifetime parameter not in scope here\"));\n+                span_err!(self.tcx.sess, span, E0489,\n+                          \"type/lifetime parameter not in scope here\");\n                 self.tcx.note_and_explain_region(\n                     \"the parameter is only valid for \",\n                     sub,\n                     \"\");\n             }\n             infer::DataBorrowed(ty, span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"a value of type `{}` is borrowed for too long\",\n-                             self.ty_to_string(ty)));\n+                span_err!(self.tcx.sess, span, E0490,\n+                          \"a value of type `{}` is borrowed for too long\",\n+                          self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(\"the type is valid for \", sub, \"\");\n                 self.tcx.note_and_explain_region(\"but the borrow lasts for \", sup, \"\");\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"in type `{}`, reference has a longer lifetime \\\n-                             than the data it references\",\n-                            self.ty_to_string(ty)));\n+                span_err!(self.tcx.sess, span, E0491,\n+                          \"in type `{}`, reference has a longer lifetime \\\n+                           than the data it references\",\n+                          self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(\n                     \"the pointer is valid for \",\n                     sub,\n@@ -1648,11 +1627,10 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        self.tcx.sess.span_err(\n-            var_origin.span(),\n-            &format!(\"cannot infer an appropriate lifetime{} \\\n-                    due to conflicting requirements\",\n-                    var_description));\n+        span_err!(self.tcx.sess, var_origin.span(), E0495,\n+                  \"cannot infer an appropriate lifetime{} \\\n+                   due to conflicting requirements\",\n+                  var_description);\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1779,7 +1757,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"...so that return value is valid for the call\");\n             }\n             infer::Operand(span) => {\n-                self.tcx.sess.span_err(\n+                self.tcx.sess.span_note(\n                     span,\n                     \"...so that operand is valid for operation\");\n             }"}, {"sha": "c21999c2dbc322d0db4cafa700b2655ad4defe54", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -357,10 +357,10 @@ fn signal_shadowing_problem(\n     sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n     if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n-        sess.span_err(shadower.span,\n-                      &format!(\"{} name `{}` shadows a \\\n-                                {} name that is already in scope\",\n-                               shadower.kind.desc(), name, orig.kind.desc()));\n+        span_err!(sess, shadower.span, E0496,\n+                  \"{} name `{}` shadows a \\\n+                   {} name that is already in scope\",\n+                  shadower.kind.desc(), name, orig.kind.desc());\n     } else {\n         // shadowing involving a label is only a warning, due to issues with\n         // labels and lifetimes not being macro-hygienic."}, {"sha": "288426830efaf38298dcace8c2a84580bb460f90", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dfb89067a57949e9b74f6ed4a409d728c1240a5/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=8dfb89067a57949e9b74f6ed4a409d728c1240a5", "patch": "@@ -39,6 +39,10 @@ struct PluginLoader<'a> {\n     plugins: Vec<PluginRegistrar>,\n }\n \n+fn call_malformed_plugin_attribute(a: &Session, b: Span) {\n+    span_err!(a, b, E0498, \"malformed plugin attribute\");\n+}\n+\n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n@@ -52,14 +56,14 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n         let plugins = match attr.meta_item_list() {\n             Some(xs) => xs,\n             None => {\n-                sess.span_err(attr.span, \"malformed plugin attribute\");\n+                call_malformed_plugin_attribute(sess, attr.span);\n                 continue;\n             }\n         };\n \n         for plugin in plugins {\n             if plugin.value_str().is_some() {\n-                sess.span_err(attr.span, \"malformed plugin attribute\");\n+                call_malformed_plugin_attribute(sess, attr.span);\n                 continue;\n             }\n "}]}