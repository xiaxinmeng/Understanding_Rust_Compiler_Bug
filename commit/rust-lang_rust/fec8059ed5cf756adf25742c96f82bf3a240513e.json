{"sha": "fec8059ed5cf756adf25742c96f82bf3a240513e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYzgwNTllZDVjZjc1NmFkZjI1NzQyYzk2ZjgyYmYzYTI0MDUxM2U=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-12T23:44:09Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-13T01:16:01Z"}, "message": "Move port_set and shared_chan into core.", "tree": {"sha": "1554f94c63590c4af63699e9e6f2f16de5f19e06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1554f94c63590c4af63699e9e6f2f16de5f19e06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fec8059ed5cf756adf25742c96f82bf3a240513e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fec8059ed5cf756adf25742c96f82bf3a240513e", "html_url": "https://github.com/rust-lang/rust/commit/fec8059ed5cf756adf25742c96f82bf3a240513e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fec8059ed5cf756adf25742c96f82bf3a240513e/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba10819800aa70d702633d18ecc58ebfc74be8d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba10819800aa70d702633d18ecc58ebfc74be8d0", "html_url": "https://github.com/rust-lang/rust/commit/ba10819800aa70d702633d18ecc58ebfc74be8d0"}], "stats": {"total": 291, "additions": 81, "deletions": 210}, "files": [{"sha": "7362614a769c415a8987bd7ec3304f2e6af9432e", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 79, "deletions": 5, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fec8059ed5cf756adf25742c96f82bf3a240513e/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec8059ed5cf756adf25742c96f82bf3a240513e/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=fec8059ed5cf756adf25742c96f82bf3a240513e", "patch": "@@ -3,6 +3,19 @@\n import unsafe::{forget, reinterpret_cast, transmute};\n import either::{either, left, right};\n import option::unwrap;\n+import arc::methods;\n+\n+/* Use this after the snapshot\n+macro_rules! move {\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n+}\n+*/\n+\n+fn macros() {\n+    #macro[\n+        [#move(x), { unsafe { let y <- *ptr::addr_of(x); y } }]\n+    ];\n+}\n \n enum state {\n     empty,\n@@ -455,11 +468,6 @@ enum port<T:send> {\n fn stream<T:send>() -> (chan<T>, port<T>) {\n     let (c, s) = streamp::init();\n \n-    #macro[\n-        [#move[x],\n-         unsafe { let y <- *ptr::addr_of(x); y }]\n-    ];\n-\n     (chan_({ mut endp: some(c) }), port_({ mut endp: some(s) }))\n }\n \n@@ -506,3 +514,69 @@ impl port<T: send> for port<T> {\n         peek\n     }\n }\n+\n+// Treat a whole bunch of ports as one.\n+class port_set<T: send> {\n+    let mut ports: ~[pipes::port<T>];\n+\n+    new() { self.ports = ~[]; }\n+\n+    fn add(+port: pipes::port<T>) {\n+        vec::push(self.ports, port)\n+    }\n+\n+    fn try_recv() -> option<T> {\n+        let mut result = none;\n+        while result == none && self.ports.len() > 0 {\n+            let i = pipes::wait_many(self.ports.map(|p| p.header()));\n+            // dereferencing an unsafe pointer nonsense to appease the\n+            // borrowchecker.\n+            alt unsafe {(*ptr::addr_of(self.ports[i])).try_recv()} {\n+              some(m) {\n+                result = some(#move(m));\n+              }\n+              none {\n+                // Remove this port.\n+                let mut ports = ~[];\n+                self.ports <-> ports;\n+                vec::consume(ports,\n+                             |j, x| if i != j { vec::push(self.ports, x) });\n+              }\n+            }\n+        }\n+        result\n+    }\n+\n+    fn recv() -> T {\n+        option::unwrap(self.try_recv())\n+    }\n+}\n+\n+impl private_methods/&<T: send> for pipes::port<T> {\n+    pure fn header() -> *pipes::packet_header unchecked {\n+        alt self.endp {\n+          some(endp) {\n+            endp.header()\n+          }\n+          none { fail \"peeking empty stream\" }\n+        }\n+    }\n+}\n+\n+\n+type shared_chan<T: send> = arc::exclusive<pipes::chan<T>>;\n+\n+impl chan<T: send> for shared_chan<T> {\n+    fn send(+x: T) {\n+        let mut xx = some(x);\n+        do self.with |_c, chan| {\n+            let mut x = none;\n+            x <-> xx;\n+            chan.send(option::unwrap(x))\n+        }\n+    }\n+}\n+\n+fn shared_chan<T:send>(+c: pipes::chan<T>) -> shared_chan<T> {\n+    arc::exclusive(c)\n+}"}, {"sha": "b5fd5a4526ea674ea874b90b6e3ef894f857702f", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 111, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fec8059ed5cf756adf25742c96f82bf3a240513e/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec8059ed5cf756adf25742c96f82bf3a240513e/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=fec8059ed5cf756adf25742c96f82bf3a240513e", "patch": "@@ -13,7 +13,7 @@ import io::writer;\n import io::writer_util;\n \n import arc::methods;\n-import pipes::{port, chan};\n+import pipes::{port, chan, shared_chan};\n \n macro_rules! move {\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n@@ -96,113 +96,3 @@ fn main(args: ~[str]) {\n     #debug(\"%?\", args);\n     run(args);\n }\n-\n-// Treat a whole bunch of ports as one.\n-class box<T> {\n-    let mut contents: option<T>;\n-    new(+x: T) { self.contents = some(x); }\n-\n-    fn swap(f: fn(+T) -> T) {\n-        let mut tmp = none;\n-        self.contents <-> tmp;\n-        self.contents = some(f(option::unwrap(tmp)));\n-    }\n-\n-    fn unwrap() -> T {\n-        let mut tmp = none;\n-        self.contents <-> tmp;\n-        option::unwrap(tmp)\n-    }\n-}\n-\n-class port_set<T: send> {\n-    let mut ports: ~[pipes::port<T>];\n-\n-    new() { self.ports = ~[]; }\n-\n-    fn add(+port: pipes::port<T>) {\n-        vec::push(self.ports, port)\n-    }\n-\n-    fn try_recv() -> option<T> {\n-        let mut result = none;\n-        while result == none && self.ports.len() > 0 {\n-            let i = pipes::wait_many(self.ports.map(|p| p.header()));\n-            // dereferencing an unsafe pointer nonsense to appease the\n-            // borrowchecker.\n-            alt unsafe {(*ptr::addr_of(self.ports[i])).try_recv()} {\n-              some(m) {\n-                result = some(move!{m});\n-              }\n-              none {\n-                // Remove this port.\n-                let mut ports = ~[];\n-                self.ports <-> ports;\n-                vec::consume(ports,\n-                             |j, x| if i != j { vec::push(self.ports, x) });\n-              }\n-            }\n-        }\n-/*        \n-        while !done {\n-            do self.ports.swap |ports| {\n-                if ports.len() > 0 {\n-                    let old_len = ports.len();\n-                    let (_, m, ports) = pipes::select(ports);\n-                    alt m {\n-                      some(pipes::streamp::data(x, next)) {\n-                        result = some(move!{x});\n-                        done = true;\n-                        assert ports.len() == old_len - 1;\n-                        vec::append_one(ports, move!{next})\n-                      }\n-                      none {\n-                        //#error(\"pipe closed\");\n-                        assert ports.len() == old_len - 1;\n-                        ports\n-                      }\n-                    }\n-                }\n-                else {\n-                    //#error(\"no more pipes\");\n-                    done = true;\n-                    ~[]\n-                }\n-            }\n-        }\n-*/\n-        result\n-    }\n-\n-    fn recv() -> T {\n-        option::unwrap(self.try_recv())\n-    }\n-}\n-\n-impl private_methods/&<T: send> for pipes::port<T> {\n-    pure fn header() -> *pipes::packet_header unchecked {\n-        alt self.endp {\n-          some(endp) {\n-            endp.header()\n-          }\n-          none { fail \"peeking empty stream\" }\n-        }\n-    }\n-}\n-\n-type shared_chan<T: send> = arc::exclusive<pipes::chan<T>>;\n-\n-impl chan<T: send> for shared_chan<T> {\n-    fn send(+x: T) {\n-        let mut xx = some(x);\n-        do self.with |_c, chan| {\n-            let mut x = none;\n-            x <-> xx;\n-            chan.send(option::unwrap(x))\n-        }\n-    }\n-}\n-\n-fn shared_chan<T:send>(+c: pipes::chan<T>) -> shared_chan<T> {\n-    arc::exclusive(c)\n-}\n\\ No newline at end of file"}, {"sha": "3b9ea45f221676b69c2ee1cc086debc2cc960363", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 94, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fec8059ed5cf756adf25742c96f82bf3a240513e/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec8059ed5cf756adf25742c96f82bf3a240513e/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=fec8059ed5cf756adf25742c96f82bf3a240513e", "patch": "@@ -8,7 +8,7 @@ use std;\n import io::writer;\n import io::writer_util;\n \n-import pipes::{port, chan};\n+import pipes::{port, port_set, chan};\n \n macro_rules! move {\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n@@ -92,96 +92,3 @@ fn main(args: ~[str]) {\n     #debug(\"%?\", args);\n     run(args);\n }\n-\n-// Treat a whole bunch of ports as one.\n-class box<T> {\n-    let mut contents: option<T>;\n-    new(+x: T) { self.contents = some(x); }\n-\n-    fn swap(f: fn(+T) -> T) {\n-        let mut tmp = none;\n-        self.contents <-> tmp;\n-        self.contents = some(f(option::unwrap(tmp)));\n-    }\n-\n-    fn unwrap() -> T {\n-        let mut tmp = none;\n-        self.contents <-> tmp;\n-        option::unwrap(tmp)\n-    }\n-}\n-\n-class port_set<T: send> {\n-    let mut ports: ~[pipes::port<T>];\n-\n-    new() { self.ports = ~[]; }\n-\n-    fn add(+port: pipes::port<T>) {\n-        vec::push(self.ports, port)\n-    }\n-\n-    fn try_recv() -> option<T> {\n-        let mut result = none;\n-        while result == none && self.ports.len() > 0 {\n-            let i = pipes::wait_many(self.ports.map(|p| p.header()));\n-            // dereferencing an unsafe pointer nonsense to appease the\n-            // borrowchecker.\n-            alt unsafe {(*ptr::addr_of(self.ports[i])).try_recv()} {\n-              some(m) {\n-                result = some(move!{m});\n-              }\n-              none {\n-                // Remove this port.\n-                let mut ports = ~[];\n-                self.ports <-> ports;\n-                vec::consume(ports,\n-                             |j, x| if i != j { vec::push(self.ports, x) });\n-              }\n-            }\n-        }\n-/*        \n-        while !done {\n-            do self.ports.swap |ports| {\n-                if ports.len() > 0 {\n-                    let old_len = ports.len();\n-                    let (_, m, ports) = pipes::select(ports);\n-                    alt m {\n-                      some(pipes::streamp::data(x, next)) {\n-                        result = some(move!{x});\n-                        done = true;\n-                        assert ports.len() == old_len - 1;\n-                        vec::append_one(ports, move!{next})\n-                      }\n-                      none {\n-                        //#error(\"pipe closed\");\n-                        assert ports.len() == old_len - 1;\n-                        ports\n-                      }\n-                    }\n-                }\n-                else {\n-                    //#error(\"no more pipes\");\n-                    done = true;\n-                    ~[]\n-                }\n-            }\n-        }\n-*/\n-        result\n-    }\n-\n-    fn recv() -> T {\n-        option::unwrap(self.try_recv())\n-    }\n-}\n-\n-impl private_methods/&<T: send> for pipes::port<T> {\n-    pure fn header() -> *pipes::packet_header unchecked {\n-        alt self.endp {\n-          some(endp) {\n-            endp.header()\n-          }\n-          none { fail \"peeking empty stream\" }\n-        }\n-    }\n-}\n\\ No newline at end of file"}]}