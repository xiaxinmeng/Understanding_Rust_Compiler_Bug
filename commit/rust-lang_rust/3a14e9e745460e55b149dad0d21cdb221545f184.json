{"sha": "3a14e9e745460e55b149dad0d21cdb221545f184", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMTRlOWU3NDU0NjBlNTViMTQ5ZGFkMGQyMWNkYjIyMTU0NWYxODQ=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-25T22:32:14Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-28T15:12:55Z"}, "message": "Make Rvalue::ty infallible", "tree": {"sha": "8368b3e32b414a48cc40c8c0e74f5b5f54ea57d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8368b3e32b414a48cc40c8c0e74f5b5f54ea57d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a14e9e745460e55b149dad0d21cdb221545f184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a14e9e745460e55b149dad0d21cdb221545f184", "html_url": "https://github.com/rust-lang/rust/commit/3a14e9e745460e55b149dad0d21cdb221545f184", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a14e9e745460e55b149dad0d21cdb221545f184/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5872a8d78bfa6b94187af0e72cff063259d74531", "url": "https://api.github.com/repos/rust-lang/rust/commits/5872a8d78bfa6b94187af0e72cff063259d74531", "html_url": "https://github.com/rust-lang/rust/commit/5872a8d78bfa6b94187af0e72cff063259d74531"}], "stats": {"total": 76, "additions": 34, "deletions": 42}, "files": [{"sha": "ae60be7aa4b0e74e24d55e3135426a3b92df914a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -1038,7 +1038,8 @@ pub enum CastKind {\n \n #[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum AggregateKind<'tcx> {\n-    Array,\n+    /// The type is of the element\n+    Array(Ty<'tcx>),\n     Tuple,\n     /// The second field is variant number (discriminant), it's equal to 0\n     /// for struct and union expressions. The fourth field is active field\n@@ -1135,7 +1136,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 }\n \n                 match *kind {\n-                    AggregateKind::Array => write!(fmt, \"{:?}\", lvs),\n+                    AggregateKind::Array(_) => write!(fmt, \"{:?}\", lvs),\n \n                     AggregateKind::Tuple => {\n                         match lvs.len() {"}, {"sha": "cfd53cfcddcd3061a17cef0c7861b6021bf815c3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -134,76 +134,70 @@ impl<'tcx> Lvalue<'tcx> {\n }\n \n impl<'tcx> Rvalue<'tcx> {\n-    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>>\n+    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n     {\n         match *self {\n-            Rvalue::Use(ref operand) => Some(operand.ty(mir, tcx)),\n+            Rvalue::Use(ref operand) => operand.ty(mir, tcx),\n             Rvalue::Repeat(ref operand, ref count) => {\n                 let op_ty = operand.ty(mir, tcx);\n                 let count = count.value.as_u64(tcx.sess.target.uint_type);\n                 assert_eq!(count as usize as u64, count);\n-                Some(tcx.mk_array(op_ty, count as usize))\n+                tcx.mk_array(op_ty, count as usize)\n             }\n             Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n-                Some(tcx.mk_ref(reg,\n+                tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n                         ty: lv_ty,\n                         mutbl: bk.to_mutbl_lossy()\n                     }\n-                ))\n+                )\n             }\n-            Rvalue::Len(..) => Some(tcx.types.usize),\n-            Rvalue::Cast(.., ty) => Some(ty),\n+            Rvalue::Len(..) => tcx.types.usize,\n+            Rvalue::Cast(.., ty) => ty,\n             Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs_ty = lhs.ty(mir, tcx);\n                 let rhs_ty = rhs.ty(mir, tcx);\n-                Some(op.ty(tcx, lhs_ty, rhs_ty))\n+                op.ty(tcx, lhs_ty, rhs_ty)\n             }\n             Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs_ty = lhs.ty(mir, tcx);\n                 let rhs_ty = rhs.ty(mir, tcx);\n                 let ty = op.ty(tcx, lhs_ty, rhs_ty);\n-                let ty = tcx.intern_tup(&[ty, tcx.types.bool], false);\n-                Some(ty)\n+                tcx.intern_tup(&[ty, tcx.types.bool], false)\n             }\n             Rvalue::UnaryOp(_, ref operand) => {\n-                Some(operand.ty(mir, tcx))\n+                operand.ty(mir, tcx)\n             }\n             Rvalue::Discriminant(ref lval) => {\n                 let ty = lval.ty(mir, tcx).to_ty(tcx);\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    Some(adt_def.repr.discr_type().to_ty(tcx))\n+                    adt_def.repr.discr_type().to_ty(tcx)\n                 } else {\n                     // Undefined behaviour, bug for now; may want to return something for\n                     // the `discriminant` intrinsic later.\n                     bug!(\"Rvalue::Discriminant on Lvalue of type {:?}\", ty);\n                 }\n             }\n             Rvalue::Box(t) => {\n-                Some(tcx.mk_box(t))\n+                tcx.mk_box(t)\n             }\n             Rvalue::Aggregate(ref ak, ref ops) => {\n                 match *ak {\n-                    AggregateKind::Array => {\n-                        if let Some(operand) = ops.get(0) {\n-                            let ty = operand.ty(mir, tcx);\n-                            Some(tcx.mk_array(ty, ops.len()))\n-                        } else {\n-                            None\n-                        }\n+                    AggregateKind::Array(ty) => {\n+                        tcx.mk_array(ty, ops.len())\n                     }\n                     AggregateKind::Tuple => {\n-                        Some(tcx.mk_tup(\n+                        tcx.mk_tup(\n                             ops.iter().map(|op| op.ty(mir, tcx)),\n                             false\n-                        ))\n+                        )\n                     }\n                     AggregateKind::Adt(def, _, substs, _) => {\n-                        Some(tcx.item_type(def.did).subst(tcx, substs))\n+                        tcx.item_type(def.did).subst(tcx, substs)\n                     }\n                     AggregateKind::Closure(did, substs) => {\n-                        Some(tcx.mk_closure_from_closure_substs(did, substs))\n+                        tcx.mk_closure_from_closure_substs(did, substs)\n                     }\n                 }\n             }"}, {"sha": "34c69f5c2f7f42d870a38b2e2134e98661bed8f4", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -515,7 +515,8 @@ macro_rules! make_mir_visitor {\n                     Rvalue::Aggregate(ref $($mutability)* kind,\n                                       ref $($mutability)* operands) => {\n                         match *kind {\n-                            AggregateKind::Array => {\n+                            AggregateKind::Array(ref $($mutability)* ty) => {\n+                                self.visit_ty(ty);\n                             }\n                             AggregateKind::Tuple => {\n                             }"}, {"sha": "7c3807a5edca5cb53cd88f4e138a268d36fe6f35", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -148,12 +148,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 //     to the same MIR as `let x = ();`.\n \n                 // first process the set of fields\n+                let el_ty = expr.ty.sequence_element_type(this.hir.tcx());\n                 let fields: Vec<_> =\n                     fields.into_iter()\n                           .map(|f| unpack!(block = this.as_operand(block, f)))\n                           .collect();\n \n-                block.and(Rvalue::Aggregate(AggregateKind::Array, fields))\n+                block.and(Rvalue::Aggregate(AggregateKind::Array(el_ty), fields))\n             }\n             ExprKind::Tuple { fields } => { // see (*) above\n                 // first process the set of fields"}, {"sha": "e998665e035365056fafe6065ce5b694b4371980", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -752,7 +752,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n \n                     if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n-                        let ty = rvalue.ty(self.mir, self.tcx).unwrap();\n+                        let ty = rvalue.ty(self.mir, self.tcx);\n                         self.add_type(ty);\n                         assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n                         // Even if the value inside may not need dropping,"}, {"sha": "c99c4323bb8a1c4c9d4b752a375736e4c8ba199e", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -83,9 +83,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        if let Some(ty) = rvalue.ty(self.mir, self.tcx()) {\n-            self.sanitize_type(rvalue, ty);\n-        }\n+        let rval_ty = rvalue.ty(self.mir, self.tcx());\n+        self.sanitize_type(rvalue, rval_ty);\n     }\n \n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n@@ -356,14 +355,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             StatementKind::Assign(ref lv, ref rv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Some(rv_ty) = rv_ty {\n-                    if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n-                        span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n-                                     lv_ty, rv_ty, terr);\n-                    }\n+                if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n+                    span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n+                                 lv_ty, rv_ty, terr);\n                 }\n-                // FIXME: rvalue with undeterminable type - e.g. AggregateKind::Array branch that\n-                // returns `None`.\n             }\n             StatementKind::SetDiscriminant{ ref lvalue, variant_index } => {\n                 let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);"}, {"sha": "88b06945608320b43829533d2d18556b3b1b1d4e", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -191,7 +191,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                 // AggregateKind is not distinguished by visit API, so\n                 // record it. (`super_rvalue` handles `_operands`.)\n                 self.record(match *kind {\n-                    AggregateKind::Array => \"AggregateKind::Array\",\n+                    AggregateKind::Array(_) => \"AggregateKind::Array\",\n                     AggregateKind::Tuple => \"AggregateKind::Tuple\",\n                     AggregateKind::Adt(..) => \"AggregateKind::Adt\",\n                     AggregateKind::Closure(..) => \"AggregateKind::Closure\","}, {"sha": "d6c1b3f1a874ab26f6d4c5779781f1722cb1ad5a", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -548,7 +548,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 failure?;\n \n                 match *kind {\n-                    mir::AggregateKind::Array => {\n+                    mir::AggregateKind::Array(_) => {\n                         self.const_array(dest_ty, &fields)\n                     }\n                     mir::AggregateKind::Adt(..) |"}, {"sha": "9a20683e8715fd8857aa49b309aaf52b4e66d752", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a14e9e745460e55b149dad0d21cdb221545f184/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=3a14e9e745460e55b149dad0d21cdb221545f184", "patch": "@@ -435,7 +435,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Discriminant(ref lvalue) => {\n                 let discr_lvalue = self.trans_lvalue(&bcx, lvalue);\n                 let enum_ty = discr_lvalue.ty.to_ty(bcx.tcx());\n-                let discr_ty = rvalue.ty(&*self.mir, bcx.tcx()).unwrap();\n+                let discr_ty = rvalue.ty(&*self.mir, bcx.tcx());\n                 let discr_type = type_of::immediate_type_of(bcx.ccx, discr_ty);\n                 let discr = adt::trans_get_discr(&bcx, enum_ty, discr_lvalue.llval,\n                                                   discr_lvalue.alignment, Some(discr_type), true);"}]}