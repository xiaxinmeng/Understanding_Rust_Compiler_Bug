{"sha": "2304917aad2f18ee9a1c6969e1197c96dee907b6", "node_id": "C_kwDOAAsO6NoAKDIzMDQ5MTdhYWQyZjE4ZWU5YTFjNjk2OWUxMTk3Yzk2ZGVlOTA3YjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-16T11:51:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-16T11:51:43Z"}, "message": "Auto merge of #112702 - Dylan-DPC:rollup-12d6qay, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #112163 (fix: inline `predicate_may_hold_fatal` and remove expect call in it)\n - #112399 (Instantiate closure synthetic substs in root universe)\n - #112443 (Opportunistically resolve regions in new solver)\n - #112535 (reorder attributes to make miri-test-libstd work again)\n - #112579 (Fix building libstd documentation on FreeBSD.)\n - #112639 (Fix `dead_code_cgu` computation)\n - #112642 (Handle interpolated literal errors)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2f11e8ea2652f15c434a88175a472b459b63eddf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f11e8ea2652f15c434a88175a472b459b63eddf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2304917aad2f18ee9a1c6969e1197c96dee907b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2304917aad2f18ee9a1c6969e1197c96dee907b6", "html_url": "https://github.com/rust-lang/rust/commit/2304917aad2f18ee9a1c6969e1197c96dee907b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2304917aad2f18ee9a1c6969e1197c96dee907b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99b334696fffe8c08d2e6a978862849d5a89f875", "url": "https://api.github.com/repos/rust-lang/rust/commits/99b334696fffe8c08d2e6a978862849d5a89f875", "html_url": "https://github.com/rust-lang/rust/commit/99b334696fffe8c08d2e6a978862849d5a89f875"}, {"sha": "c2e109744db3322f44ebfbe707847bbb9b9be933", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e109744db3322f44ebfbe707847bbb9b9be933", "html_url": "https://github.com/rust-lang/rust/commit/c2e109744db3322f44ebfbe707847bbb9b9be933"}], "stats": {"total": 295, "additions": 207, "deletions": 88}, "files": [{"sha": "dce426ca2db6afe2f02431467305d177fb810905", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.typeck_root_def_id(expr_def_id.to_def_id()),\n         );\n \n-        let tupled_upvars_ty = self.next_ty_var(TypeVariableOrigin {\n+        let tupled_upvars_ty = self.next_root_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::ClosureSynthetic,\n             span: self.tcx.def_span(expr_def_id),\n         });\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Create a type variable (for now) to represent the closure kind.\n             // It will be unified during the upvar inference phase (`upvar.rs`)\n-            None => self.next_ty_var(TypeVariableOrigin {\n+            None => self.next_root_ty_var(TypeVariableOrigin {\n                 // FIXME(eddyb) distinguish closure kind inference variables from the rest.\n                 kind: TypeVariableOriginKind::ClosureSynthetic,\n                 span: expr_span,"}, {"sha": "630878bbf0c602dca6c2fdad2a78efd46171acc2", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -189,6 +189,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn errors_reported_since_creation(&self) -> bool {\n         self.tcx.sess.err_count() > self.err_count_on_creation\n     }\n+\n+    pub fn next_root_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_ty_var(self.next_ty_var_id_in_universe(origin, ty::UniverseIndex::ROOT))\n+    }\n }\n \n impl<'a, 'tcx> Deref for FnCtxt<'a, 'tcx> {"}, {"sha": "1b19ed9ad148b1d090d440ee39ecc7036400be8d", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -82,15 +82,40 @@ impl CanonicalVarValues<'_> {\n     }\n \n     pub fn is_identity_modulo_regions(&self) -> bool {\n-        self.var_values.iter().enumerate().all(|(bv, arg)| match arg.unpack() {\n-            ty::GenericArgKind::Lifetime(_) => true,\n-            ty::GenericArgKind::Type(ty) => {\n-                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var.as_usize() == bv)\n-            }\n-            ty::GenericArgKind::Const(ct) => {\n-                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc.as_usize() == bv)\n+        let mut var = ty::BoundVar::from_u32(0);\n+        for arg in self.var_values {\n+            match arg.unpack() {\n+                ty::GenericArgKind::Lifetime(r) => {\n+                    if let ty::ReLateBound(ty::INNERMOST, br) = *r\n+                        && var == br.var\n+                    {\n+                        var = var + 1;\n+                    } else {\n+                        // It's ok if this region var isn't unique\n+                    }\n+                },\n+                ty::GenericArgKind::Type(ty) => {\n+                    if let ty::Bound(ty::INNERMOST, bt) = *ty.kind()\n+                        && var == bt.var\n+                    {\n+                        var = var + 1;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                ty::GenericArgKind::Const(ct) => {\n+                    if let ty::ConstKind::Bound(ty::INNERMOST, bc) = ct.kind()\n+                        && var == bc\n+                    {\n+                        var = var + 1;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n             }\n-        })\n+        }\n+\n+        true\n     }\n }\n "}, {"sha": "531644f0b849032d2b29752fbb67c1fbca88fc4d", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 41, "deletions": 44, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -155,14 +155,16 @@ where\n     // functions and statics defined in the local crate.\n     let PlacedRootMonoItems { mut codegen_units, internalization_candidates, unique_inlined_stats } = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        place_root_mono_items(cx, mono_items)\n-    };\n+        let mut placed = place_root_mono_items(cx, mono_items);\n \n-    for cgu in &mut codegen_units {\n-        cgu.create_size_estimate(tcx);\n-    }\n+        for cgu in &mut placed.codegen_units {\n+            cgu.create_size_estimate(tcx);\n+        }\n \n-    debug_dump(tcx, \"ROOTS\", &codegen_units, unique_inlined_stats);\n+        debug_dump(tcx, \"ROOTS\", &placed.codegen_units, placed.unique_inlined_stats);\n+\n+        placed\n+    };\n \n     // Merge until we have at most `max_cgu_count` codegen units.\n     // `merge_codegen_units` is responsible for updating the CGU size\n@@ -179,59 +181,34 @@ where\n     // local functions the definition of which is marked with `#[inline]`.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        place_inlined_mono_items(cx, &mut codegen_units)\n-    };\n+        place_inlined_mono_items(cx, &mut codegen_units);\n \n-    for cgu in &mut codegen_units {\n-        cgu.create_size_estimate(tcx);\n-    }\n+        for cgu in &mut codegen_units {\n+            cgu.create_size_estimate(tcx);\n+        }\n \n-    debug_dump(tcx, \"INLINE\", &codegen_units, unique_inlined_stats);\n+        debug_dump(tcx, \"INLINE\", &codegen_units, unique_inlined_stats);\n+    }\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n         internalize_symbols(cx, &mut codegen_units, internalization_candidates);\n+\n+        debug_dump(tcx, \"INTERNALIZE\", &codegen_units, unique_inlined_stats);\n     }\n \n+    // Mark one CGU for dead code, if necessary.\n     let instrument_dead_code =\n         tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n-\n     if instrument_dead_code {\n-        assert!(\n-            codegen_units.len() > 0,\n-            \"There must be at least one CGU that code coverage data can be generated in.\"\n-        );\n-\n-        // Find the smallest CGU that has exported symbols and put the dead\n-        // function stubs in that CGU. We look for exported symbols to increase\n-        // the likelihood the linker won't throw away the dead functions.\n-        // FIXME(#92165): In order to truly resolve this, we need to make sure\n-        // the object file (CGU) containing the dead function stubs is included\n-        // in the final binary. This will probably require forcing these\n-        // function symbols to be included via `-u` or `/include` linker args.\n-        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n-        cgus.sort_by_key(|cgu| cgu.size_estimate());\n-\n-        let dead_code_cgu =\n-            if let Some(cgu) = cgus.into_iter().rev().find(|cgu| {\n-                cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External)\n-            }) {\n-                cgu\n-            } else {\n-                // If there are no CGUs that have externally linked items,\n-                // then we just pick the first CGU as a fallback.\n-                &mut codegen_units[0]\n-            };\n-        dead_code_cgu.make_code_coverage_dead_code_cgu();\n+        mark_code_coverage_dead_code_cgu(&mut codegen_units);\n     }\n \n     // Ensure CGUs are sorted by name, so that we get deterministic results.\n     assert!(codegen_units.is_sorted_by(|a, b| Some(a.name().as_str().cmp(b.name().as_str()))));\n \n-    debug_dump(tcx, \"FINAL\", &codegen_units, unique_inlined_stats);\n-\n     codegen_units\n }\n \n@@ -363,9 +340,7 @@ fn merge_codegen_units<'tcx>(\n \n         // Move the mono-items from `smallest` to `second_smallest`\n         second_smallest.modify_size_estimate(smallest.size_estimate());\n-        for (k, v) in smallest.items_mut().drain() {\n-            second_smallest.items_mut().insert(k, v);\n-        }\n+        second_smallest.items_mut().extend(smallest.items_mut().drain());\n \n         // Record that `second_smallest` now contains all the stuff that was\n         // in `smallest` before.\n@@ -545,6 +520,28 @@ fn internalize_symbols<'tcx>(\n     }\n }\n \n+fn mark_code_coverage_dead_code_cgu<'tcx>(codegen_units: &mut [CodegenUnit<'tcx>]) {\n+    assert!(!codegen_units.is_empty());\n+\n+    // Find the smallest CGU that has exported symbols and put the dead\n+    // function stubs in that CGU. We look for exported symbols to increase\n+    // the likelihood the linker won't throw away the dead functions.\n+    // FIXME(#92165): In order to truly resolve this, we need to make sure\n+    // the object file (CGU) containing the dead function stubs is included\n+    // in the final binary. This will probably require forcing these\n+    // function symbols to be included via `-u` or `/include` linker args.\n+    let dead_code_cgu = codegen_units\n+        .iter_mut()\n+        .filter(|cgu| cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External))\n+        .min_by_key(|cgu| cgu.size_estimate());\n+\n+    // If there are no CGUs that have externally linked items, then we just\n+    // pick the first CGU as a fallback.\n+    let dead_code_cgu = if let Some(cgu) = dead_code_cgu { cgu } else { &mut codegen_units[0] };\n+\n+    dead_code_cgu.make_code_coverage_dead_code_cgu();\n+}\n+\n fn characteristic_def_id_of_mono_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mono_item: MonoItem<'tcx>,"}, {"sha": "f00bc54589a7f639be9b6b9175d1cc9b89c93bf7", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -2023,17 +2023,14 @@ impl<'a> Parser<'a> {\n         let recovered = self.recover_after_dot();\n         let token = recovered.as_ref().unwrap_or(&self.token);\n         match token::Lit::from_token(token) {\n-            Some(token_lit) => {\n-                match MetaItemLit::from_token_lit(token_lit, token.span) {\n+            Some(lit) => {\n+                match MetaItemLit::from_token_lit(lit, token.span) {\n                     Ok(lit) => {\n                         self.bump();\n                         Some(lit)\n                     }\n                     Err(err) => {\n-                        let span = token.span;\n-                        let token::Literal(lit) = token.kind else {\n-                            unreachable!();\n-                        };\n+                        let span = token.uninterpolated_span();\n                         self.bump();\n                         report_lit_error(&self.sess, err, lit, span);\n                         // Pack possible quotes and prefixes from the original literal into"}, {"sha": "05248cb9d17823e60504be327677e8b06ec0c50f", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -208,8 +208,25 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        let r = self.infcx.shallow_resolve(r);\n+    fn fold_region(&mut self, mut r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match self.canonicalize_mode {\n+            CanonicalizeMode::Input => {\n+                // Don't resolve infer vars in input, since it affects\n+                // caching and may cause trait selection bugs which rely\n+                // on regions to be equal.\n+            }\n+            CanonicalizeMode::Response { .. } => {\n+                if let ty::ReVar(vid) = *r {\n+                    r = self\n+                        .infcx\n+                        .inner\n+                        .borrow_mut()\n+                        .unwrap_region_constraints()\n+                        .opportunistic_resolve_var(self.infcx.tcx, vid);\n+                }\n+            }\n+        }\n+\n         let kind = match *r {\n             ty::ReLateBound(..) => return r,\n "}, {"sha": "8592fc164d04962b4e87eca12c802cccc33f7cd7", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -263,7 +263,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n             let new_canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-            if !new_canonical_response.value.var_values.is_identity() {\n+            // We only check for modulo regions as we convert all regions in\n+            // the input to new existentials, even if they're expected to be\n+            // `'static` or a placeholder region.\n+            if !new_canonical_response.value.var_values.is_identity_modulo_regions() {\n                 bug!(\n                     \"unstable result: re-canonicalized goal={canonical_goal:#?} \\\n                     first_response={canonical_response:#?} \\"}, {"sha": "3193d00e11b2ba8cf311e48ba4f2fc877094cc96", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -292,7 +292,12 @@ fn impl_intersection_has_impossible_obligation<'cx, 'tcx>(\n             Obligation::new(infcx.tcx, ObligationCause::dummy(), param_env, predicate)\n         })\n         .chain(obligations)\n-        .find(|o| !selcx.predicate_may_hold_fatal(o));\n+        .find(|o| {\n+            selcx.evaluate_root_obligation(o).map_or(\n+                false, // Overflow has occurred, and treat the obligation as possibly holding.\n+                |result| !result.may_apply(),\n+            )\n+        });\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);"}, {"sha": "4c5a794bc815bdc035f8fd0fc86b0f22e8385954", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -518,19 +518,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n-    /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n-    pub fn predicate_may_hold_fatal(&mut self, obligation: &PredicateObligation<'tcx>) -> bool {\n-        debug!(?obligation, \"predicate_may_hold_fatal\");\n-\n-        // This fatal query is a stopgap that should only be used in standard mode,\n-        // where we do not expect overflow to be propagated.\n-        assert!(self.query_mode == TraitQueryMode::Standard);\n-\n-        self.evaluate_root_obligation(obligation)\n-            .expect(\"Overflow should be caught earlier in standard query mode\")\n-            .may_apply()\n-    }\n-\n     /// Evaluates whether the obligation `obligation` can be satisfied\n     /// and returns an `EvaluationResult`. This is meant for the\n     /// *initial* call."}, {"sha": "967ad3a0e6901bedb23684e8d2c8e89ee6704ef5", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -56,6 +56,11 @@\n //! [`Rc`]: rc\n //! [`RefCell`]: core::cell\n \n+// To run alloc tests without x.py without ending up with two copies of alloc, Miri needs to be\n+// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n+// rustc itself never sets the feature, so this line has no affect there.\n+#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n+//\n #![allow(unused_attributes)]\n #![stable(feature = \"alloc\", since = \"1.36.0\")]\n #![doc(\n@@ -75,11 +80,6 @@\n ))]\n #![no_std]\n #![needs_allocator]\n-// To run alloc tests without x.py without ending up with two copies of alloc, Miri needs to be\n-// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n-// rustc itself never sets the feature, so this line has no affect there.\n-#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n-//\n // Lints:\n #![deny(unsafe_op_in_unsafe_fn)]\n #![deny(fuzzy_provenance_casts)]"}, {"sha": "da08c018d0e360b0da589ee161dbb7d24a2c0785", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -188,6 +188,13 @@\n //! [array]: prim@array\n //! [slice]: prim@slice\n \n+// To run std tests without x.py without ending up with two copies of std, Miri needs to be\n+// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n+// rustc itself never sets the feature, so this line has no affect there.\n+#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n+// miri-test-libstd also prefers to make std use the sysroot versions of the dependencies.\n+#![cfg_attr(feature = \"miri-test-libstd\", feature(rustc_private))]\n+//\n #![cfg_attr(not(feature = \"restricted-std\"), stable(feature = \"rust1\", since = \"1.0.0\"))]\n #![cfg_attr(feature = \"restricted-std\", unstable(feature = \"restricted_std\", issue = \"none\"))]\n #![doc(\n@@ -202,12 +209,6 @@\n     no_global_oom_handling,\n     not(no_global_oom_handling)\n ))]\n-// To run std tests without x.py without ending up with two copies of std, Miri needs to be\n-// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n-// rustc itself never sets the feature, so this line has no affect there.\n-#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n-// miri-test-libstd also prefers to make std use the sysroot versions of the dependencies.\n-#![cfg_attr(feature = \"miri-test-libstd\", feature(rustc_private))]\n // Don't link to std. We are std.\n #![no_std]\n // Tell the compiler to link to either panic_abort or panic_unwind"}, {"sha": "814f1c7c2838e454c5aac2245b99d3bc82ff35b5", "filename": "library/std/src/os/unix/net/ancillary.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -17,6 +17,7 @@ mod libc {\n     pub use libc::c_int;\n     pub struct ucred;\n     pub struct cmsghdr;\n+    pub struct sockcred2;\n     pub type pid_t = i32;\n     pub type gid_t = u32;\n     pub type uid_t = u32;"}, {"sha": "cff8ee6b40ca67308f3d58a298ab7ca7af3574aa", "filename": "tests/ui/parser/lit-err-in-macro.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Fparser%2Flit-err-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Fparser%2Flit-err-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Flit-err-in-macro.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! f {\n+    ($abi:literal) => {\n+        extern $abi fn f() {}\n+    }\n+}\n+\n+f!(\"Foo\"__);\n+//~^ ERROR suffixes on string literals are invalid\n+\n+fn main() {}"}, {"sha": "a61fb5c85d492f94b5767fbcee4e209d0f7ccbf6", "filename": "tests/ui/parser/lit-err-in-macro.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Fparser%2Flit-err-in-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Fparser%2Flit-err-in-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Flit-err-in-macro.stderr?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -0,0 +1,8 @@\n+error: suffixes on string literals are invalid\n+  --> $DIR/lit-err-in-macro.rs:7:4\n+   |\n+LL | f!(\"Foo\"__);\n+   |    ^^^^^^^ invalid suffix `__`\n+\n+error: aborting due to previous error\n+"}, {"sha": "74c7afd6b9edbb6357d64603fb82c9fb33011f95", "filename": "tests/ui/traits/issue-105231.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Ftraits%2Fissue-105231.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Ftraits%2Fissue-105231.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-105231.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -0,0 +1,9 @@\n+//~ ERROR overflow evaluating the requirement `A<A<A<A<A<A<A<...>>>>>>>: Send`\n+struct A<T>(B<T>);\n+//~^ ERROR recursive types `A` and `B` have infinite size\n+struct B<T>(A<A<T>>);\n+trait Foo {}\n+impl<T> Foo for T where T: Send {}\n+impl Foo for B<u8> {}\n+\n+fn main() {}"}, {"sha": "fe20c47c57a805e407f75c0bb1819eb9dc377541", "filename": "tests/ui/traits/issue-105231.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Ftraits%2Fissue-105231.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Ftraits%2Fissue-105231.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-105231.stderr?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -0,0 +1,29 @@\n+error[E0072]: recursive types `A` and `B` have infinite size\n+  --> $DIR/issue-105231.rs:2:1\n+   |\n+LL | struct A<T>(B<T>);\n+   | ^^^^^^^^^^^ ---- recursive without indirection\n+LL |\n+LL | struct B<T>(A<A<T>>);\n+   | ^^^^^^^^^^^ ------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n+   |\n+LL ~ struct A<T>(Box<B<T>>);\n+LL |\n+LL ~ struct B<T>(Box<A<A<T>>>);\n+   |\n+\n+error[E0275]: overflow evaluating the requirement `A<A<A<A<A<A<A<...>>>>>>>: Send`\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_105231`)\n+note: required because it appears within the type `B<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<A<u8>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+  --> $DIR/issue-105231.rs:4:8\n+   |\n+LL | struct B<T>(A<A<T>>);\n+   |        ^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0072, E0275.\n+For more information about an error, try `rustc --explain E0072`."}, {"sha": "48432f4020f87042baaf3fa3be8a97a95f99cc54", "filename": "tests/ui/traits/new-solver/closure-substs-ambiguity.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Ftraits%2Fnew-solver%2Fclosure-substs-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Ftraits%2Fnew-solver%2Fclosure-substs-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fclosure-substs-ambiguity.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+fn main() {\n+    let mut x: Vec<_> = vec![];\n+    x.extend(Some(1i32).into_iter().map(|x| x));\n+}"}, {"sha": "2610789cd485acbbf2115a39b1c091a08df106f9", "filename": "tests/ui/traits/new-solver/opportunistic-region-resolve.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Ftraits%2Fnew-solver%2Fopportunistic-region-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304917aad2f18ee9a1c6969e1197c96dee907b6/tests%2Fui%2Ftraits%2Fnew-solver%2Fopportunistic-region-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fopportunistic-region-resolve.rs?ref=2304917aad2f18ee9a1c6969e1197c96dee907b6", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_coinductive]\n+trait Trait {}\n+\n+#[rustc_coinductive]\n+trait Indirect {}\n+impl<T: Trait + ?Sized> Indirect for T {}\n+\n+impl<'a> Trait for &'a () where &'a (): Indirect {}\n+\n+fn impls_trait<T: Trait>() {}\n+\n+fn main() {\n+    impls_trait::<&'static ()>();\n+}"}]}