{"sha": "59a329d4f77869a963e725ec414b6867a8d71c7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YTMyOWQ0Zjc3ODY5YTk2M2U3MjVlYzQxNGI2ODY3YThkNzFjN2Y=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-09-13T10:42:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-09-13T13:46:53Z"}, "message": "use catch expression to handle the 'release undef' problem slightly better", "tree": {"sha": "88cc17bea3498d5f25674b5161f22ddd06335bce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88cc17bea3498d5f25674b5161f22ddd06335bce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59a329d4f77869a963e725ec414b6867a8d71c7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59a329d4f77869a963e725ec414b6867a8d71c7f", "html_url": "https://github.com/rust-lang/rust/commit/59a329d4f77869a963e725ec414b6867a8d71c7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59a329d4f77869a963e725ec414b6867a8d71c7f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bac89ae1d875ff3cf28c682c4d34d30058bfa6c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bac89ae1d875ff3cf28c682c4d34d30058bfa6c4", "html_url": "https://github.com/rust-lang/rust/commit/bac89ae1d875ff3cf28c682c4d34d30058bfa6c4"}], "stats": {"total": 405, "additions": 202, "deletions": 203}, "files": [{"sha": "251bd71ffceff2be4c114e742b6cc2f776b6995a", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 201, "deletions": 203, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/59a329d4f77869a963e725ec414b6867a8d71c7f/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a329d4f77869a963e725ec414b6867a8d71c7f/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=59a329d4f77869a963e725ec414b6867a8d71c7f", "patch": "@@ -378,23 +378,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     /// Validate the lvalue at the given type. If `acquire` is false, just do a release of all write locks\n-    #[inline]\n-    fn validate(&mut self, query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx> {\n-        match self.try_validate(query, mode) {\n-            // ReleaseUntil(None) of an uninitalized variable is a NOP.  This is needed because\n-            // we have to release the return value of a function; due to destination-passing-style\n-            // the callee may directly write there.\n-            // TODO: Ideally we would know whether the destination is already initialized, and only\n-            // release if it is.  But of course that can't even always be statically determined.\n-            Err(EvalError { kind: EvalErrorKind::ReadUndefBytes, .. })\n-                if mode == ValidationMode::ReleaseUntil(None) => {\n-                return Ok(());\n-            }\n-            res => res,\n-        }\n-    }\n-\n-    fn try_validate(\n+    fn validate(\n         &mut self,\n         mut query: ValidationQuery<'tcx>,\n         mode: ValidationMode,\n@@ -522,211 +506,225 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n         }\n \n-        match query.ty.sty {\n-            TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n-                // TODO: Make sure these are not undef.\n-                // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n-                Ok(())\n-            }\n-            TyBool | TyFloat(_) | TyChar | TyStr => {\n-                // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n-                Ok(())\n-            }\n-            TyNever => err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n-            TyRef(region,\n-                  ty::TypeAndMut {\n-                      ty: pointee_ty,\n-                      mutbl,\n-                  }) => {\n-                let val = self.read_lvalue(query.lval.1)?;\n-                // Sharing restricts our context\n-                if mutbl == MutImmutable {\n-                    query.mutbl = MutImmutable;\n+        let res = do catch {\n+            match query.ty.sty {\n+                TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n+                    // TODO: Make sure these are not undef.\n+                    // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n+                    Ok(())\n                 }\n-                // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n-                // we record the region of this borrow to the context.\n-                if query.re == None {\n-                    match *region {\n-                        ReScope(scope) => query.re = Some(scope),\n-                        // It is possible for us to encounter erased lifetimes here because the lifetimes in\n-                        // this functions' Subst will be erased.\n-                        _ => {}\n+                TyBool | TyFloat(_) | TyChar | TyStr => {\n+                    // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n+                    Ok(())\n+                }\n+                TyNever => err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n+                TyRef(region,\n+                    ty::TypeAndMut {\n+                        ty: pointee_ty,\n+                        mutbl,\n+                    }) => {\n+                    let val = self.read_lvalue(query.lval.1)?;\n+                    // Sharing restricts our context\n+                    if mutbl == MutImmutable {\n+                        query.mutbl = MutImmutable;\n                     }\n+                    // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n+                    // we record the region of this borrow to the context.\n+                    if query.re == None {\n+                        match *region {\n+                            ReScope(scope) => query.re = Some(scope),\n+                            // It is possible for us to encounter erased lifetimes here because the lifetimes in\n+                            // this functions' Subst will be erased.\n+                            _ => {}\n+                        }\n+                    }\n+                    self.validate_ptr(val, query.lval.0, pointee_ty, query.re, query.mutbl, mode)\n+                }\n+                TyAdt(adt, _) if adt.is_box() => {\n+                    let val = self.read_lvalue(query.lval.1)?;\n+                    self.validate_ptr(val, query.lval.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n+                }\n+                TyFnPtr(_sig) => {\n+                    let ptr = self.read_lvalue(query.lval.1)?\n+                        .into_ptr(&self.memory)?\n+                        .to_ptr()?;\n+                    self.memory.get_fn(ptr)?;\n+                    // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                    Ok(())\n+                }\n+                TyFnDef(..) => {\n+                    // This is a zero-sized type with all relevant data sitting in the type.\n+                    // There is nothing to validate.\n+                    Ok(())\n                 }\n-                self.validate_ptr(val, query.lval.0, pointee_ty, query.re, query.mutbl, mode)\n-            }\n-            TyAdt(adt, _) if adt.is_box() => {\n-                let val = self.read_lvalue(query.lval.1)?;\n-                self.validate_ptr(val, query.lval.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n-            }\n-            TyFnPtr(_sig) => {\n-                let ptr = self.read_lvalue(query.lval.1)?\n-                    .into_ptr(&self.memory)?\n-                    .to_ptr()?;\n-                self.memory.get_fn(ptr)?;\n-                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                Ok(())\n-            }\n-            TyFnDef(..) => {\n-                // This is a zero-sized type with all relevant data sitting in the type.\n-                // There is nothing to validate.\n-                Ok(())\n-            }\n \n-            // Compound types\n-            TySlice(elem_ty) => {\n-                let len = match query.lval.1 {\n-                    Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n-                    _ => {\n-                        bug!(\n-                            \"acquire_valid of a TySlice given non-slice lvalue: {:?}\",\n-                            query.lval\n-                        )\n+                // Compound types\n+                TySlice(elem_ty) => {\n+                    let len = match query.lval.1 {\n+                        Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n+                        _ => {\n+                            bug!(\n+                                \"acquire_valid of a TySlice given non-slice lvalue: {:?}\",\n+                                query.lval\n+                            )\n+                        }\n+                    };\n+                    for i in 0..len {\n+                        let inner_lvalue = self.lvalue_index(query.lval.1, query.ty, i)?;\n+                        self.validate(\n+                            ValidationQuery {\n+                                lval: (query.lval.0.clone().index(i), inner_lvalue),\n+                                ty: elem_ty,\n+                                ..query\n+                            },\n+                            mode,\n+                        )?;\n                     }\n-                };\n-                for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(query.lval.1, query.ty, i)?;\n-                    self.validate(\n-                        ValidationQuery {\n-                            lval: (query.lval.0.clone().index(i), inner_lvalue),\n-                            ty: elem_ty,\n-                            ..query\n-                        },\n-                        mode,\n-                    )?;\n-                }\n-                Ok(())\n-            }\n-            TyArray(elem_ty, len) => {\n-                let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n-                for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(query.lval.1, query.ty, i as u64)?;\n-                    self.validate(\n-                        ValidationQuery {\n-                            lval: (query.lval.0.clone().index(i as u64), inner_lvalue),\n-                            ty: elem_ty,\n-                            ..query\n-                        },\n-                        mode,\n-                    )?;\n+                    Ok(())\n                 }\n-                Ok(())\n-            }\n-            TyDynamic(_data, _region) => {\n-                // Check that this is a valid vtable\n-                let vtable = match query.lval.1 {\n-                    Lvalue::Ptr { extra: LvalueExtra::Vtable(vtable), .. } => vtable,\n-                    _ => {\n-                        bug!(\n-                            \"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\",\n-                            query.lval\n-                        )\n+                TyArray(elem_ty, len) => {\n+                    let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+                    for i in 0..len {\n+                        let inner_lvalue = self.lvalue_index(query.lval.1, query.ty, i as u64)?;\n+                        self.validate(\n+                            ValidationQuery {\n+                                lval: (query.lval.0.clone().index(i as u64), inner_lvalue),\n+                                ty: elem_ty,\n+                                ..query\n+                            },\n+                            mode,\n+                        )?;\n                     }\n-                };\n-                self.read_size_and_align_from_vtable(vtable)?;\n-                // TODO: Check that the vtable contains all the function pointers we expect it to have.\n-                // Trait objects cannot have any operations performed\n-                // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n-                // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n-                // their return values.  So, it doesn't seem like there's anything else to do.\n-                Ok(())\n-            }\n-            TyAdt(adt, subst) => {\n-                if Some(adt.did) == self.tcx.lang_items().unsafe_cell_type() &&\n-                    query.mutbl == MutImmutable\n-                {\n-                    // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n-                    return Ok(());\n+                    Ok(())\n+                }\n+                TyDynamic(_data, _region) => {\n+                    // Check that this is a valid vtable\n+                    let vtable = match query.lval.1 {\n+                        Lvalue::Ptr { extra: LvalueExtra::Vtable(vtable), .. } => vtable,\n+                        _ => {\n+                            bug!(\n+                                \"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\",\n+                                query.lval\n+                            )\n+                        }\n+                    };\n+                    self.read_size_and_align_from_vtable(vtable)?;\n+                    // TODO: Check that the vtable contains all the function pointers we expect it to have.\n+                    // Trait objects cannot have any operations performed\n+                    // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n+                    // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n+                    // their return values.  So, it doesn't seem like there's anything else to do.\n+                    Ok(())\n                 }\n+                TyAdt(adt, subst) => {\n+                    if Some(adt.did) == self.tcx.lang_items().unsafe_cell_type() &&\n+                        query.mutbl == MutImmutable\n+                    {\n+                        // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n+                        return Ok(());\n+                    }\n \n-                match adt.adt_kind() {\n-                    AdtKind::Enum => {\n-                        // TODO: Can we get the discriminant without forcing an allocation?\n-                        let ptr = self.force_allocation(query.lval.1)?.to_ptr()?;\n-                        let discr = self.read_discriminant_value(ptr, query.ty)?;\n-\n-                        // Get variant index for discriminant\n-                        let variant_idx = adt.discriminants(self.tcx).position(|variant_discr| {\n-                            variant_discr.to_u128_unchecked() == discr\n-                        });\n-                        let variant_idx = match variant_idx {\n-                            Some(val) => val,\n-                            None => return err!(InvalidDiscriminant),\n-                        };\n-                        let variant = &adt.variants[variant_idx];\n-\n-                        if variant.fields.len() > 0 {\n-                            // Downcast to this variant, if needed\n-                            let lval = if adt.variants.len() > 1 {\n-                                (\n-                                    query.lval.0.downcast(adt, variant_idx),\n-                                    self.eval_lvalue_projection(\n-                                        query.lval.1,\n-                                        query.ty,\n-                                        &mir::ProjectionElem::Downcast(adt, variant_idx),\n-                                    )?,\n+                    match adt.adt_kind() {\n+                        AdtKind::Enum => {\n+                            // TODO: Can we get the discriminant without forcing an allocation?\n+                            let ptr = self.force_allocation(query.lval.1)?.to_ptr()?;\n+                            let discr = self.read_discriminant_value(ptr, query.ty)?;\n+\n+                            // Get variant index for discriminant\n+                            let variant_idx = adt.discriminants(self.tcx).position(|variant_discr| {\n+                                variant_discr.to_u128_unchecked() == discr\n+                            });\n+                            let variant_idx = match variant_idx {\n+                                Some(val) => val,\n+                                None => return err!(InvalidDiscriminant),\n+                            };\n+                            let variant = &adt.variants[variant_idx];\n+\n+                            if variant.fields.len() > 0 {\n+                                // Downcast to this variant, if needed\n+                                let lval = if adt.variants.len() > 1 {\n+                                    (\n+                                        query.lval.0.downcast(adt, variant_idx),\n+                                        self.eval_lvalue_projection(\n+                                            query.lval.1,\n+                                            query.ty,\n+                                            &mir::ProjectionElem::Downcast(adt, variant_idx),\n+                                        )?,\n+                                    )\n+                                } else {\n+                                    query.lval\n+                                };\n+\n+                                // Recursively validate the fields\n+                                self.validate_variant(\n+                                    ValidationQuery { lval, ..query },\n+                                    variant,\n+                                    subst,\n+                                    mode,\n                                 )\n                             } else {\n-                                query.lval\n-                            };\n-\n-                            // Recursively validate the fields\n-                            self.validate_variant(\n-                                ValidationQuery { lval, ..query },\n-                                variant,\n-                                subst,\n-                                mode,\n-                            )\n-                        } else {\n-                            // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n+                                // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n+                                Ok(())\n+                            }\n+                        }\n+                        AdtKind::Struct => {\n+                            self.validate_variant(query, adt.struct_variant(), subst, mode)\n+                        }\n+                        AdtKind::Union => {\n+                            // No guarantees are provided for union types.\n+                            // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n                             Ok(())\n                         }\n                     }\n-                    AdtKind::Struct => {\n-                        self.validate_variant(query, adt.struct_variant(), subst, mode)\n-                    }\n-                    AdtKind::Union => {\n-                        // No guarantees are provided for union types.\n-                        // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n-                        Ok(())\n+                }\n+                TyTuple(ref types, _) => {\n+                    for (idx, field_ty) in types.iter().enumerate() {\n+                        let field = mir::Field::new(idx);\n+                        let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n+                        self.validate(\n+                            ValidationQuery {\n+                                lval: (query.lval.0.clone().field(field), field_lvalue),\n+                                ty: field_ty,\n+                                ..query\n+                            },\n+                            mode,\n+                        )?;\n                     }\n+                    Ok(())\n                 }\n-            }\n-            TyTuple(ref types, _) => {\n-                for (idx, field_ty) in types.iter().enumerate() {\n-                    let field = mir::Field::new(idx);\n-                    let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n-                    self.validate(\n-                        ValidationQuery {\n-                            lval: (query.lval.0.clone().field(field), field_lvalue),\n-                            ty: field_ty,\n-                            ..query\n-                        },\n-                        mode,\n-                    )?;\n+                TyClosure(def_id, ref closure_substs) => {\n+                    for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n+                        let field = mir::Field::new(idx);\n+                        let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n+                        self.validate(\n+                            ValidationQuery {\n+                                lval: (query.lval.0.clone().field(field), field_lvalue),\n+                                ty: field_ty,\n+                                ..query\n+                            },\n+                            mode,\n+                        )?;\n+                    }\n+                    // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                    // Is there other things we can/should check?  Like vtable pointers?\n+                    Ok(())\n                 }\n-                Ok(())\n+                // FIXME: generators aren't validated right now\n+                TyGenerator(..) => Ok(()),\n+                _ => bug!(\"We already established that this is a type we support. ({})\", query.ty),\n             }\n-            TyClosure(def_id, ref closure_substs) => {\n-                for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n-                    let field = mir::Field::new(idx);\n-                    let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n-                    self.validate(\n-                        ValidationQuery {\n-                            lval: (query.lval.0.clone().field(field), field_lvalue),\n-                            ty: field_ty,\n-                            ..query\n-                        },\n-                        mode,\n-                    )?;\n-                }\n-                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                // Is there other things we can/should check?  Like vtable pointers?\n-                Ok(())\n+        };\n+        match res {\n+            // ReleaseUntil(None) of an uninitalized variable is a NOP.  This is needed because\n+            // we have to release the return value of a function; due to destination-passing-style\n+            // the callee may directly write there.\n+            // TODO: Ideally we would know whether the destination is already initialized, and only\n+            // release if it is.  But of course that can't even always be statically determined.\n+            Err(EvalError { kind: EvalErrorKind::ReadUndefBytes, .. })\n+                if mode == ValidationMode::ReleaseUntil(None) => {\n+                return Ok(());\n             }\n-            // FIXME: generators aren't validated right now\n-            TyGenerator(..) => Ok(()),\n-            _ => bug!(\"We already established that this is a type we support. ({})\", query.ty),\n+            res => res,\n         }\n     }\n }"}, {"sha": "c640932e50e21953955b38c94f6bd5e83b423fa8", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59a329d4f77869a963e725ec414b6867a8d71c7f/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a329d4f77869a963e725ec414b6867a8d71c7f/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=59a329d4f77869a963e725ec414b6867a8d71c7f", "patch": "@@ -3,6 +3,7 @@\n     rustc_private,\n     conservative_impl_trait,\n     never_type,\n+    catch_expr,\n )]\n \n // From rustc."}]}