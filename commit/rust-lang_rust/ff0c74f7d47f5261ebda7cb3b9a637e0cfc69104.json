{"sha": "ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMGM3NGY3ZDQ3ZjUyNjFlYmRhN2NiM2I5YTYzN2UwY2ZjNjkxMDQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-15T03:51:13Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-16T21:00:16Z"}, "message": "test errors", "tree": {"sha": "c4bcf1b5acdae17289fb024987c4f45b00e8fea7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4bcf1b5acdae17289fb024987c4f45b00e8fea7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "html_url": "https://github.com/rust-lang/rust/commit/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2371518c4b03e1770948d9d2429cfeb46e25a20", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2371518c4b03e1770948d9d2429cfeb46e25a20", "html_url": "https://github.com/rust-lang/rust/commit/e2371518c4b03e1770948d9d2429cfeb46e25a20"}], "stats": {"total": 245, "additions": 131, "deletions": 114}, "files": [{"sha": "e33fe9570c024f9bfaac483a1da7c47776a4834b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -1224,7 +1224,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(!sess.can_print_warnings);\n+            assert!(!sess.diagnostic().can_emit_warnings);\n         }\n \n         {\n@@ -1236,7 +1236,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(sess.can_print_warnings);\n+            assert!(sess.diagnostic().can_emit_warnings);\n         }\n \n         {\n@@ -1247,7 +1247,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(sess.can_print_warnings);\n+            assert!(sess.diagnostic().can_emit_warnings);\n         }\n     }\n }"}, {"sha": "df9294a9d5bfb518cbcab55efb94e6b909154294", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -10,8 +10,6 @@\n \n //! # Standalone Tests for the Inference Module\n \n-use diagnostic;\n-use diagnostic::Emitter;\n use driver;\n use rustc_lint;\n use rustc_resolve as resolve;\n@@ -34,9 +32,10 @@ use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::{abi, ast};\n-use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n-use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, Help};\n+use syntax::errors;\n+use syntax::errors::emitter::Emitter;\n+use syntax::errors::{Level, RenderSpan};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n \n@@ -60,8 +59,8 @@ struct ExpectErrorEmitter {\n \n fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     match lvl {\n-        Bug | Fatal | Error => {}\n-        Warning | Note | Help => {\n+        Level::Bug | Level::Fatal | Level::Error => {}\n+        Level::Warning | Level::Note | Level::Help => {\n             return;\n         }\n     }\n@@ -79,14 +78,14 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n \n impl Emitter for ExpectErrorEmitter {\n     fn emit(&mut self,\n-            _cmsp: Option<(&codemap::CodeMap, Span)>,\n+            _sp: Option<Span>,\n             msg: &str,\n             _: Option<&str>,\n             lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n \n-    fn custom_emit(&mut self, _cm: &codemap::CodeMap, _sp: RenderSpan, msg: &str, lvl: Level) {\n+    fn custom_emit(&mut self, _sp: RenderSpan, msg: &str, lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n }\n@@ -105,13 +104,11 @@ fn test_env<F>(source_string: &str,\n     let mut options = config::basic_options();\n     options.debugging_opts.verbose = true;\n     options.unstable_features = UnstableFeatures::Allow;\n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::with_emitter(true, emitter);\n-    let span_diagnostic_handler = diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-    let sess = session::build_session_(options, None, span_diagnostic_handler,\n-                                       cstore.clone());\n+    let sess = session::build_session_(options, None, diagnostic_handler,\n+                                       Rc::new(CodeMap::new()), cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let krate_config = Vec::new();\n     let input = config::Input::Str(source_string.to_string());\n@@ -366,13 +363,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.infcx.glb(true, trace)\n     }\n \n-    pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n-        match self.lub().relate(&t1, &t2) {\n-            Ok(t) => t,\n-            Err(ref e) => panic!(\"unexpected error computing LUB: {}\", e),\n-        }\n-    }\n-\n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {"}, {"sha": "fde8299d2d2e6f5a37a851df388ab52380e93c12", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -225,7 +225,9 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     }\n     let data = Arc::new(Mutex::new(Vec::new()));\n     let codemap = Rc::new(CodeMap::new());\n-    let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()), None, codemap.clone());\n+    let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n+                                                      None,\n+                                                      codemap.clone());\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data, old.unwrap_or(box io::stdout()));\n "}, {"sha": "7fef85a833e251224f3456ed46da1a11a8d270b4", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -45,7 +45,7 @@ impl ColorConfig {\n             ColorConfig::Always => true,\n             ColorConfig::Never  => false,\n             ColorConfig::Auto   => stderr_isatty(),\n-        }        \n+        }\n     }\n }\n \n@@ -619,3 +619,62 @@ impl Write for Destination {\n     }\n }\n \n+\n+#[cfg(test)]\n+mod test {\n+    use errors::Level;\n+    use super::EmitterWriter;\n+    use codemap::{mk_sp, CodeMap};\n+    use std::sync::{Arc, Mutex};\n+    use std::io::{self, Write};\n+    use std::str::from_utf8;\n+    use std::rc::Rc;\n+\n+    // Diagnostic doesn't align properly in span where line number increases by one digit\n+    #[test]\n+    fn test_hilight_suggestion_issue_11715() {\n+        struct Sink(Arc<Mutex<Vec<u8>>>);\n+        impl Write for Sink {\n+            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+                Write::write(&mut *self.0.lock().unwrap(), data)\n+            }\n+            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+        }\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n+        let content = \"abcdefg\n+        koksi\n+        line3\n+        line4\n+        cinq\n+        line6\n+        line7\n+        line8\n+        line9\n+        line10\n+        e-l\u00e4-v\u00e4n\n+        tolv\n+        dreizehn\n+        \";\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", content);\n+        let start = file.lines.borrow()[7];\n+        let end = file.lines.borrow()[11];\n+        let sp = mk_sp(start, end);\n+        let lvl = Level::Error;\n+        println!(\"span_to_lines\");\n+        let lines = cm.span_to_lines(sp);\n+        println!(\"highlight_lines\");\n+        ew.highlight_lines(sp, lvl, lines).unwrap();\n+        println!(\"done\");\n+        let vec = data.lock().unwrap().clone();\n+        let vec: &[u8] = &vec;\n+        let str = from_utf8(vec).unwrap();\n+        println!(\"{}\", str);\n+        assert_eq!(str, \"dummy.txt: 8         line8\\n\\\n+                         dummy.txt: 9         line9\\n\\\n+                         dummy.txt:10         line10\\n\\\n+                         dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n+                         dummy.txt:12         tolv\\n\");\n+    }\n+}"}, {"sha": "f2e61090ba23cfc86b1d72a3e9d2b9fe97b9dc1e", "filename": "src/libsyntax/errors/mod.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -336,61 +336,3 @@ pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n         None => diag.bug(&msg()),\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::Level;\n-    use emitter::EmitterWriter;\n-    use codemap::{mk_sp, CodeMap};\n-    use std::sync::{Arc, Mutex};\n-    use std::io::{self, Write};\n-    use std::str::from_utf8;\n-\n-    // Diagnostic doesn't align properly in span where line number increases by one digit\n-    #[test]\n-    fn test_hilight_suggestion_issue_11715() {\n-        struct Sink(Arc<Mutex<Vec<u8>>>);\n-        impl Write for Sink {\n-            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-                Write::write(&mut *self.0.lock().unwrap(), data)\n-            }\n-            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-        }\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None);\n-        let cm = CodeMap::new();\n-        let content = \"abcdefg\n-        koksi\n-        line3\n-        line4\n-        cinq\n-        line6\n-        line7\n-        line8\n-        line9\n-        line10\n-        e-l\u00e4-v\u00e4n\n-        tolv\n-        dreizehn\n-        \";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", content);\n-        let start = file.lines.borrow()[7];\n-        let end = file.lines.borrow()[11];\n-        let sp = mk_sp(start, end);\n-        let lvl = Level::Error;\n-        println!(\"span_to_lines\");\n-        let lines = cm.span_to_lines(sp);\n-        println!(\"highlight_lines\");\n-        ew.highlight_lines(&cm, sp, lvl, lines).unwrap();\n-        println!(\"done\");\n-        let vec = data.lock().unwrap().clone();\n-        let vec: &[u8] = &vec;\n-        let str = from_utf8(vec).unwrap();\n-        println!(\"{}\", str);\n-        assert_eq!(str, \"dummy.txt: 8         line8\\n\\\n-                         dummy.txt: 9         line9\\n\\\n-                         dummy.txt:10         line10\\n\\\n-                         dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n-                         dummy.txt:12         tolv\\n\");\n-    }\n-}"}, {"sha": "4619410ada7274c44cefe8f08032684bff346d78", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -1422,28 +1422,30 @@ mod tests {\n     use super::*;\n \n     use codemap::{BytePos, CodeMap, Span, NO_EXPANSION};\n-    use diagnostic;\n+    use errors;\n     use parse::token;\n     use parse::token::{str_to_ident};\n     use std::io;\n+    use std::rc::Rc;\n \n-    fn mk_sh() -> diagnostic::Handler {\n+    fn mk_sh(cm: Rc<CodeMap>) -> errors::Handler {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-        let emitter = diagnostic::EmitterWriter::new(Box::new(io::sink()), None);\n-        let handler = diagnostic::Handler::with_emitter(true, Box::new(emitter));\n-        diagnostic::Handler::new(handler, CodeMap::new())\n+        let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()), None, cm);\n+        errors::Handler::with_emitter(true, false, Box::new(emitter))\n     }\n \n     // open a string reader for the given string\n-    fn setup<'a>(span_handler: &'a diagnostic::Handler,\n+    fn setup<'a>(cm: &CodeMap,\n+                 span_handler: &'a errors::Handler,\n                  teststr: String) -> StringReader<'a> {\n-        let fm = span_handler.cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n+        let fm = cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n         StringReader::new(span_handler, fm)\n     }\n \n     #[test] fn t1 () {\n-        let span_handler = mk_sh();\n-        let mut string_reader = setup(&span_handler,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut string_reader = setup(&cm, &sh,\n             \"/* my source file */ \\\n              fn main() { println!(\\\"zebra\\\"); }\\n\".to_string());\n         let id = str_to_ident(\"fn\");\n@@ -1481,70 +1483,90 @@ mod tests {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        check_tokenization(setup(&mk_sh(), \"a b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n                            vec![mk_ident(\"a\", token::Plain),\n                                 token::Whitespace,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_2 () {\n-        check_tokenization(setup(&mk_sh(), \"a::b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n                            vec![mk_ident(\"a\",token::ModName),\n                                 token::ModSep,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_3 () {\n-        check_tokenization(setup(&mk_sh(), \"a ::b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n                            vec![mk_ident(\"a\", token::Plain),\n                                 token::Whitespace,\n                                 token::ModSep,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_4 () {\n-        check_tokenization(setup(&mk_sh(), \"a:: b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n                            vec![mk_ident(\"a\",token::ModName),\n                                 token::ModSep,\n                                 token::Whitespace,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn character_a() {\n-        assert_eq!(setup(&mk_sh(), \"'a'\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\"a\")), None));\n     }\n \n     #[test] fn character_space() {\n-        assert_eq!(setup(&mk_sh(), \"' '\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\" \")), None));\n     }\n \n     #[test] fn character_escaped() {\n-        assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\"\\\\n\")), None));\n     }\n \n     #[test] fn lifetime_name() {\n-        assert_eq!(setup(&mk_sh(), \"'abc\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n                    token::Lifetime(token::str_to_ident(\"'abc\")));\n     }\n \n     #[test] fn raw_string() {\n-        assert_eq!(setup(&mk_sh(),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh,\n                          \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string()).next_token()\n                                                                  .tok,\n                    token::Literal(token::StrRaw(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n     }\n \n     #[test] fn literal_suffixes() {\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n-                assert_eq!(setup(&mk_sh(), format!(\"{}suffix\", $input)).next_token().tok,\n+                assert_eq!(setup(&cm, &sh, format!(\"{}suffix\", $input)).next_token().tok,\n                            token::Literal(token::$tok_type(token::intern($tok_contents)),\n                                           Some(token::intern(\"suffix\"))));\n                 // with a whitespace separator:\n-                assert_eq!(setup(&mk_sh(), format!(\"{} suffix\", $input)).next_token().tok,\n+                assert_eq!(setup(&cm, &sh, format!(\"{} suffix\", $input)).next_token().tok,\n                            token::Literal(token::$tok_type(token::intern($tok_contents)),\n                                           None));\n             }}\n@@ -1560,13 +1582,13 @@ mod tests {\n         test!(\"1.0\", Float, \"1.0\");\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n-        assert_eq!(setup(&mk_sh(), \"2us\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"2us\".to_string()).next_token().tok,\n                    token::Literal(token::Integer(token::intern(\"2\")),\n                                   Some(token::intern(\"us\"))));\n-        assert_eq!(setup(&mk_sh(), \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));\n-        assert_eq!(setup(&mk_sh(), \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::ByteStrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));\n     }\n@@ -1578,8 +1600,9 @@ mod tests {\n     }\n \n     #[test] fn nested_block_comments() {\n-        let sh = mk_sh();\n-        let mut lexer = setup(&sh, \"/* /* */ */'a'\".to_string());\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut lexer = setup(&cm, &sh, \"/* /* */ */'a'\".to_string());\n         match lexer.next_token().tok {\n             token::Comment => { },\n             _ => panic!(\"expected a comment!\")\n@@ -1588,8 +1611,9 @@ mod tests {\n     }\n \n     #[test] fn crlf_comments() {\n-        let sh = mk_sh();\n-        let mut lexer = setup(&sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();\n         assert_eq!(comment.tok, token::Comment);\n         assert_eq!(comment.sp, ::codemap::mk_sp(BytePos(0), BytePos(7)));"}, {"sha": "01dc9662588bfab02877dee362ad170fa407ec99", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -39,7 +39,7 @@ use syntax::parse::token::intern;\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use syntax::diagnostic::FatalError;\n+        use syntax::errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(FatalError) => panic!(FatalError)"}, {"sha": "7c1a45d020b22d61c84a280965eeffd773b31e3e", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -44,7 +44,7 @@ fn with_error_checking_parse<T, F>(s: String, f: F) -> PResult<T> where\n     let mut p = string_to_parser(&ps, s);\n     let x = f(&mut p);\n \n-    if ps.span_diagnostic.handler().has_errors() || p.token != token::Eof {\n+    if ps.span_diagnostic.has_errors() || p.token != token::Eof {\n         return Err(p.fatal(\"parse error\"));\n     }\n "}, {"sha": "e3eeeb863568800949e95c08d3bbe57d9910d2ef", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=ff0c74f7d47f5261ebda7cb3b9a637e0cfc69104", "patch": "@@ -23,7 +23,7 @@ extern crate syntax;\n use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n-use syntax::{diagnostics, diagnostic};\n+use syntax::{diagnostics, errors};\n \n use std::path::PathBuf;\n \n@@ -35,7 +35,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &diagnostics::registry::Registry,\n-                      _: diagnostic::ColorConfig)\n+                      _: errors::emitter::ColorConfig)\n                       -> Compilation {\n         self.count *= 2;\n         Compilation::Continue"}]}