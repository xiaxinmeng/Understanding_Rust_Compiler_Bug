{"sha": "8f4448837b09fe644524ba28d59dee08950ef6b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNDQ0ODgzN2IwOWZlNjQ0NTI0YmEyOGQ1OWRlZTA4OTUwZWY2YjU=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-21T10:58:03Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-21T10:59:25Z"}, "message": "removed str::slice_DBG_UNIQ", "tree": {"sha": "b2920e72e09b75059d9a7a35bf62d0a3c2b14d32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2920e72e09b75059d9a7a35bf62d0a3c2b14d32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f4448837b09fe644524ba28d59dee08950ef6b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f4448837b09fe644524ba28d59dee08950ef6b5", "html_url": "https://github.com/rust-lang/rust/commit/8f4448837b09fe644524ba28d59dee08950ef6b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f4448837b09fe644524ba28d59dee08950ef6b5/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7d296f24c785e359bfd6d9e491fd8854c3ad967", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d296f24c785e359bfd6d9e491fd8854c3ad967", "html_url": "https://github.com/rust-lang/rust/commit/a7d296f24c785e359bfd6d9e491fd8854c3ad967"}], "stats": {"total": 108, "additions": 42, "deletions": 66}, "files": [{"sha": "bba642f9364e5d34d5935ad1b00e5d271a6c1cfc", "filename": "src/libcore/str.rs", "status": "modified", "additions": 42, "deletions": 66, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8f4448837b09fe644524ba28d59dee08950ef6b5/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f4448837b09fe644524ba28d59dee08950ef6b5/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=8f4448837b09fe644524ba28d59dee08950ef6b5", "patch": "@@ -408,19 +408,7 @@ pub pure fn chars(s: &str) -> ~[char] {\n  * `begin`.\n  */\n pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n-    slice_DBG_UNIQ(s, begin, begin + count_bytes(s, begin, n))\n-}\n-\n-/**\n- * Returns a slice of the given string from the byte range [`begin`..`end`)\n- *\n- * Fails when `begin` and `end` do not point to valid characters or\n- * beyond the last character of the string\n- */\n-pub pure fn slice_DBG_UNIQ(s: &str, begin: uint, end: uint) -> ~str {\n-    fail_unless!(is_char_boundary(s, begin));\n-    fail_unless!(is_char_boundary(s, end));\n-    unsafe { raw::slice_DBG_UNIQ_bytes(s, begin, end) }\n+    slice_DBG_BRWD(s, begin, begin + count_bytes(s, begin, n)).to_owned()\n }\n \n /**\n@@ -2287,7 +2275,6 @@ pub trait StrSlice {\n     pure fn is_alphanumeric(&self) -> bool;\n     pure fn len(&self) -> uint;\n     pure fn char_len(&self) -> uint;\n-    pure fn slice_DBG_UNIQ(&self, begin: uint, end: uint) -> ~str;\n     pure fn slice_DBG_BRWD(&self, begin: uint, end: uint) -> &'self str;\n     pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n     pure fn split_char(&self, sep: char) -> ~[~str];\n@@ -2403,17 +2390,6 @@ impl StrSlice for &'self str {\n      * beyond the last character of the string\n      */\n     #[inline]\n-    pure fn slice_DBG_UNIQ(&self, begin: uint, end: uint) -> ~str {\n-        slice_DBG_UNIQ(*self, begin, end)\n-    }\n-    /**\n-     * Returns a slice of the given string from the byte range\n-     * [`begin`..`end`)\n-     *\n-     * Fails when `begin` and `end` do not point to valid characters or\n-     * beyond the last character of the string\n-     */\n-    #[inline]\n     pure fn slice_DBG_BRWD(&self, begin: uint, end: uint) -> &'self str {\n         slice_DBG_BRWD(*self, begin, end)\n     }\n@@ -2472,7 +2448,7 @@ impl StrSlice for &'self str {\n     pure fn trim_right(&self) -> ~str { trim_right(*self) }\n \n     #[inline]\n-    pure fn to_owned(&self) -> ~str { self.slice_DBG_UNIQ(0, self.len()) }\n+    pure fn to_owned(&self) -> ~str { from_slice(*self) }\n \n     #[inline]\n     pure fn to_managed(&self) -> @str {\n@@ -2903,25 +2879,24 @@ mod tests {\n \n     #[test]\n     fn test_unsafe_slice() {\n-        unsafe {\n-            fail_unless!(~\"ab\" == raw::slice_DBG_UNIQ_bytes(~\"abc\", 0, 2));\n-            fail_unless!(~\"bc\" == raw::slice_DBG_UNIQ_bytes(~\"abc\", 1, 3));\n-            fail_unless!(~\"\" == raw::slice_DBG_UNIQ_bytes(~\"abc\", 1, 1));\n-            fn a_million_letter_a() -> ~str {\n-                let mut i = 0;\n-                let mut rs = ~\"\";\n-                while i < 100000 { push_str(&mut rs, ~\"aaaaaaaaaa\"); i += 1; }\n-                rs\n-            }\n-            fn half_a_million_letter_a() -> ~str {\n-                let mut i = 0;\n-                let mut rs = ~\"\";\n-                while i < 100000 { push_str(&mut rs, ~\"aaaaa\"); i += 1; }\n-                rs\n-            }\n-            fail_unless!(half_a_million_letter_a() ==\n-                raw::slice_DBG_UNIQ_bytes(a_million_letter_a(), 0u, 500000));\n+        fail_unless!(\"ab\" == unsafe {raw::slice_DBG_BRWD_bytes(\"abc\", 0, 2)});\n+        fail_unless!(\"bc\" == unsafe {raw::slice_DBG_BRWD_bytes(\"abc\", 1, 3)});\n+        fail_unless!(\"\" == unsafe {raw::slice_DBG_BRWD_bytes(\"abc\", 1, 1)});\n+        fn a_million_letter_a() -> ~str {\n+            let mut i = 0;\n+            let mut rs = ~\"\";\n+            while i < 100000 { push_str(&mut rs, \"aaaaaaaaaa\"); i += 1; }\n+            rs\n         }\n+        fn half_a_million_letter_a() -> ~str {\n+            let mut i = 0;\n+            let mut rs = ~\"\";\n+            while i < 100000 { push_str(&mut rs, \"aaaaa\"); i += 1; }\n+            rs\n+        }\n+        let letters = a_million_letter_a();\n+        fail_unless!(half_a_million_letter_a() ==\n+            unsafe {raw::slice_DBG_BRWD_bytes(letters, 0u, 500000)}.to_owned());\n     }\n \n     #[test]\n@@ -3001,50 +2976,51 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        fail_unless!(~\"ab\" == slice_DBG_UNIQ(~\"abc\", 0, 2));\n-        fail_unless!(~\"bc\" == slice_DBG_UNIQ(~\"abc\", 1, 3));\n-        fail_unless!(~\"\" == slice_DBG_UNIQ(~\"abc\", 1, 1));\n-        fail_unless!(~\"\\u65e5\" == slice_DBG_UNIQ(~\"\\u65e5\\u672c\", 0, 3));\n+        fail_unless!(\"ab\" == slice_DBG_BRWD(\"abc\", 0, 2));\n+        fail_unless!(\"bc\" == slice_DBG_BRWD(\"abc\", 1, 3));\n+        fail_unless!(\"\" == slice_DBG_BRWD(\"abc\", 1, 1));\n+        fail_unless!(\"\\u65e5\" == slice_DBG_BRWD(\"\\u65e5\\u672c\", 0, 3));\n \n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        fail_unless!(~\"\u0e1b\" == slice_DBG_UNIQ(data, 0, 3));\n-        fail_unless!(~\"\u0e23\" == slice_DBG_UNIQ(data, 3, 6));\n-        fail_unless!(~\"\" == slice_DBG_UNIQ(data, 3, 3));\n-        fail_unless!(~\"\u534e\" == slice_DBG_UNIQ(data, 30, 33));\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        fail_unless!(\"\u0e1b\" == slice_DBG_BRWD(data, 0, 3));\n+        fail_unless!(\"\u0e23\" == slice_DBG_BRWD(data, 3, 6));\n+        fail_unless!(\"\" == slice_DBG_BRWD(data, 3, 3));\n+        fail_unless!(\"\u534e\" == slice_DBG_BRWD(data, 30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 {\n-                push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n+                push_str(&mut rs, \"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n             rs\n         }\n         fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n-            while i < 100000 { push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n+            while i < 100000 { push_str(&mut rs, \"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n             rs\n         }\n+        let letters = a_million_letter_X();\n         fail_unless!(half_a_million_letter_X() ==\n-            slice_DBG_UNIQ(a_million_letter_X(), 0u, 3u * 500000u));\n+            slice_DBG_BRWD(letters, 0u, 3u * 500000u).to_owned());\n     }\n \n     #[test]\n     fn test_slice_2() {\n-        let ss = ~\"\u4e2d\u534eVi\u1ec7t Nam\";\n+        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        fail_unless!(~\"\u534e\" == slice_DBG_UNIQ(ss, 3u, 6u));\n-        fail_unless!(~\"Vi\u1ec7t Nam\" == slice_DBG_UNIQ(ss, 6u, 16u));\n+        fail_unless!(\"\u534e\" == slice_DBG_BRWD(ss, 3u, 6u));\n+        fail_unless!(\"Vi\u1ec7t Nam\" == slice_DBG_BRWD(ss, 6u, 16u));\n \n-        fail_unless!(~\"ab\" == slice_DBG_UNIQ(~\"abc\", 0u, 2u));\n-        fail_unless!(~\"bc\" == slice_DBG_UNIQ(~\"abc\", 1u, 3u));\n-        fail_unless!(~\"\" == slice_DBG_UNIQ(~\"abc\", 1u, 1u));\n+        fail_unless!(\"ab\" == slice_DBG_BRWD(\"abc\", 0u, 2u));\n+        fail_unless!(\"bc\" == slice_DBG_BRWD(\"abc\", 1u, 3u));\n+        fail_unless!(\"\" == slice_DBG_BRWD(\"abc\", 1u, 1u));\n \n-        fail_unless!(~\"\u4e2d\" == slice_DBG_UNIQ(ss, 0u, 3u));\n-        fail_unless!(~\"\u534eV\" == slice_DBG_UNIQ(ss, 3u, 7u));\n-        fail_unless!(~\"\" == slice_DBG_UNIQ(ss, 3u, 3u));\n+        fail_unless!(\"\u4e2d\" == slice_DBG_BRWD(ss, 0u, 3u));\n+        fail_unless!(\"\u534eV\" == slice_DBG_BRWD(ss, 3u, 7u));\n+        fail_unless!(\"\" == slice_DBG_BRWD(ss, 3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -3061,7 +3037,7 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_slice_fail() {\n-        slice_DBG_UNIQ(~\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n+        slice_DBG_BRWD(\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n     }\n \n     #[test]"}]}