{"sha": "e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MDUzYjlhN2ZmOTFiNmE2OTIzOGMxZDdkZWE5OWJlMzRiYjdhM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-12T16:12:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-12T16:12:04Z"}, "message": "auto merge of #13932 : MrAlert/rust/win-compat, r=brson\n\nThis addresses #12842 by offering fallback implementations for functions that aren't available.\r\n\r\nIn this case, as Windows XP simply doesn't support symbolic links at all, the fallbacks simply return an error code indicating that the function hasn't been implemented. This should allow programs written in Rust to run under XP while still offering full support for symbolic links under newer versions of Windows with the same binary, but due to LLVM using stderror_s(), which isn't available in msvcrt.dll in XP, rustc itself will not.\r\n\r\nThe fallback implementation is as follows:\r\n\r\nCalling the function instead calls to a mutable function pointer. This in and of itself would not constitute a performance hit because DLL calls are implemented in a similar manner (see Import Address Table). The function pointer initially points to a thunk which tries to get the address of the associated function and write it back to the function pointer. If it fails to find the function, it instead writes the address to a fallback. As this operation is idempotent, reading and writing the pointer simply needs to be atomic. Subsequent calls to the function should be as fast as any other DLL call, as the pointer will then point directly to either the correct function or a fallback.", "tree": {"sha": "d5ab9f71437bebfc7a8d01b1ee50bb218e75f8cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5ab9f71437bebfc7a8d01b1ee50bb218e75f8cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "html_url": "https://github.com/rust-lang/rust/commit/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edae0bdabf75b6acf4f0f0eb5bc2bd3b29d58b81", "url": "https://api.github.com/repos/rust-lang/rust/commits/edae0bdabf75b6acf4f0f0eb5bc2bd3b29d58b81", "html_url": "https://github.com/rust-lang/rust/commit/edae0bdabf75b6acf4f0f0eb5bc2bd3b29d58b81"}, {"sha": "facd1270c636beb7c2c8153424ffd6dda4179d59", "url": "https://api.github.com/repos/rust-lang/rust/commits/facd1270c636beb7c2c8153424ffd6dda4179d59", "html_url": "https://github.com/rust-lang/rust/commit/facd1270c636beb7c2c8153424ffd6dda4179d59"}], "stats": {"total": 121, "additions": 105, "deletions": 16}, "files": [{"sha": "7258569e433154f33ecceb5e4f17b40ac4b1668c", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "patch": "@@ -252,7 +252,6 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use funcs::extra::kernel32::{FlushFileBuffers, SetEndOfFile, CreateFileW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{CreateDirectoryW, FindFirstFileW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{FindNextFileW, FindClose, DeleteFileW};\n-#[cfg(windows)] pub use funcs::extra::kernel32::{GetFinalPathNameByHandleW, CreateSymbolicLinkW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{CreateHardLinkW, CreateEventW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{FlushFileBuffers, CreateNamedPipeW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{SetNamedPipeHandleState, WaitNamedPipeW};\n@@ -1735,6 +1734,7 @@ pub mod consts {\n             pub static ERROR_INVALID_HANDLE : c_int = 6;\n             pub static ERROR_BROKEN_PIPE: c_int = 109;\n             pub static ERROR_DISK_FULL : c_int = 112;\n+            pub static ERROR_CALL_NOT_IMPLEMENTED : c_int = 120;\n             pub static ERROR_INSUFFICIENT_BUFFER : c_int = 122;\n             pub static ERROR_INVALID_NAME : c_int = 123;\n             pub static ERROR_ALREADY_EXISTS : c_int = 183;\n@@ -4189,9 +4189,9 @@ pub mod funcs {\n                                                LPSTARTUPINFO,\n                                                LPPROCESS_INFORMATION,\n                                                LPMEMORY_BASIC_INFORMATION,\n-                                               LPSYSTEM_INFO, BOOLEAN,\n-                                               HANDLE, LPHANDLE, LARGE_INTEGER,\n-                                               PLARGE_INTEGER, LPFILETIME};\n+                                               LPSYSTEM_INFO, HANDLE, LPHANDLE,\n+                                               LARGE_INTEGER, PLARGE_INTEGER,\n+                                               LPFILETIME};\n \n             extern \"system\" {\n                 pub fn GetEnvironmentVariableW(n: LPCWSTR,\n@@ -4301,9 +4301,6 @@ pub mod funcs {\n                 pub fn MoveFileExW(lpExistingFileName: LPCWSTR,\n                                    lpNewFileName: LPCWSTR,\n                                    dwFlags: DWORD) -> BOOL;\n-                pub fn CreateSymbolicLinkW(lpSymlinkFileName: LPCWSTR,\n-                                           lpTargetFileName: LPCWSTR,\n-                                           dwFlags: DWORD) -> BOOLEAN;\n                 pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,\n                                        lpTargetFileName: LPCWSTR,\n                                        lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n@@ -4316,10 +4313,6 @@ pub mod funcs {\n                                    dwCreationDisposition: DWORD,\n                                    dwFlagsAndAttributes: DWORD,\n                                    hTemplateFile: HANDLE) -> HANDLE;\n-                pub fn GetFinalPathNameByHandleW(hFile: HANDLE,\n-                                                 lpszFilePath: LPCWSTR,\n-                                                 cchFilePath: DWORD,\n-                                                 dwFlags: DWORD) -> DWORD;\n                 pub fn ReadFile(hFile: HANDLE,\n                                 lpBuffer: LPVOID,\n                                 nNumberOfBytesToRead: DWORD,"}, {"sha": "93b3ec7ccefbf204f1b1d8ea9c31dc7013440271", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "patch": "@@ -65,3 +65,96 @@ extern \"system\" {\n     pub fn CancelIoEx(hFile: libc::HANDLE,\n                       lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n }\n+\n+pub mod compat {\n+    use std::intrinsics::{atomic_store_relaxed, transmute};\n+    use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n+    use std::os::win32::as_utf16_p;\n+\n+    extern \"system\" {\n+        fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n+        fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n+    }\n+\n+    // store_func() is idempotent, so using relaxed ordering for the atomics should be enough.\n+    // This way, calling a function in this compatibility layer (after it's loaded) shouldn't\n+    // be any slower than a regular DLL call.\n+    unsafe fn store_func<T: Copy>(ptr: *mut T, module: &str, symbol: &str, fallback: T) {\n+        as_utf16_p(module, |module| {\n+            symbol.with_c_str(|symbol| {\n+                let handle = GetModuleHandleW(module);\n+                let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n+                atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n+            })\n+        })\n+    }\n+\n+    /// Macro for creating a compatibility fallback for a Windows function\n+    ///\n+    /// # Example\n+    /// ```\n+    /// compat_fn!(adll32::SomeFunctionW(_arg: LPCWSTR) {\n+    ///     // Fallback implementation\n+    /// })\n+    /// ```\n+    ///\n+    /// Note that arguments unused by the fallback implementation should not be called `_` as\n+    /// they are used to be passed to the real function if available.\n+    macro_rules! compat_fn(\n+        ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n+                                      -> $rettype:ty $fallback:block) => (\n+            #[inline(always)]\n+            pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+                static mut ptr: extern \"system\" fn($($argname: $argtype),*) -> $rettype = thunk;\n+\n+                extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n+                    unsafe {\n+                        ::io::c::compat::store_func(&mut ptr,\n+                                                             stringify!($module),\n+                                                             stringify!($symbol),\n+                                                             fallback);\n+                        ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                    }\n+                }\n+\n+                extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $fallback\n+\n+                ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+            }\n+        );\n+\n+        ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*) $fallback:block) => (\n+            compat_fn!($module::$symbol($($argname: $argtype),*) -> () $fallback)\n+        )\n+    )\n+\n+    /// Compatibility layer for functions in `kernel32.dll`\n+    ///\n+    /// Latest versions of Windows this is needed for:\n+    ///\n+    /// * `CreateSymbolicLinkW`: Windows XP, Windows Server 2003\n+    /// * `GetFinalPathNameByHandleW`: Windows XP, Windows Server 2003\n+    pub mod kernel32 {\n+        use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n+        use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n+\n+        extern \"system\" {\n+            fn SetLastError(dwErrCode: DWORD);\n+        }\n+\n+        compat_fn!(kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n+                                                 _lpTargetFileName: LPCWSTR,\n+                                                 _dwFlags: DWORD) -> BOOLEAN {\n+            unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n+            0\n+        })\n+\n+        compat_fn!(kernel32::GetFinalPathNameByHandleW(_hFile: HANDLE,\n+                                                       _lpszFilePath: LPCWSTR,\n+                                                       _cchFilePath: DWORD,\n+                                                       _dwFlags: DWORD) -> DWORD {\n+            unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n+            0\n+        })\n+    }\n+}"}, {"sha": "707b0c0cf3fd56baec1adc01f4f35bf3d8d05618", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "patch": "@@ -422,6 +422,7 @@ pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n \n pub fn readlink(p: &CString) -> IoResult<Path> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n+    use io::c::compat::kernel32::GetFinalPathNameByHandleW;\n     let handle = unsafe {\n         as_utf16_p(p.as_str().unwrap(), |p| {\n             libc::CreateFileW(p,\n@@ -439,10 +440,10 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     // Specify (sz - 1) because the documentation states that it's the size\n     // without the null pointer\n     let ret = fill_utf16_buf_and_decode(|buf, sz| unsafe {\n-        libc::GetFinalPathNameByHandleW(handle,\n-                                        buf as *u16,\n-                                        sz - 1,\n-                                        libc::VOLUME_NAME_DOS)\n+        GetFinalPathNameByHandleW(handle,\n+                                  buf as *u16,\n+                                  sz - 1,\n+                                  libc::VOLUME_NAME_DOS)\n     });\n     let ret = match ret {\n         Some(ref s) if s.starts_with(r\"\\\\?\\\") => Ok(Path::new(s.slice_from(4))),\n@@ -454,9 +455,10 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n }\n \n pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+    use io::c::compat::kernel32::CreateSymbolicLinkW;\n     super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n         as_utf16_p(dst.as_str().unwrap(), |dst| {\n-            unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n+            unsafe { CreateSymbolicLinkW(dst, src, 0) }\n         }) as libc::BOOL\n     }))\n }"}, {"sha": "3d5f4151a4b7e46d3c3b1699b1a8cc08a99bd34d", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "patch": "@@ -50,6 +50,7 @@\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n #![deny(unused_result, unused_must_use)]\n #![allow(non_camel_case_types)]\n+#![feature(macro_rules)]\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the"}]}