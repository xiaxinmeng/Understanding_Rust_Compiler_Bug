{"sha": "a167c042abed695a049abf3919ce929765e6cc30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNjdjMDQyYWJlZDY5NWEwNDlhYmYzOTE5Y2U5Mjk3NjVlNmNjMzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-17T12:31:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-17T12:31:15Z"}, "message": "Auto merge of #39110 - petrochenkov:sum, r=eddyb\n\nMerge ObjectSum and PolyTraitRef in AST/HIR + some other refactoring\n\n`ObjectSum` and `PolyTraitRef` are the same thing (list of bounds), they exist separately only due to parser quirks. The second commit merges them.\n\nThe first commit replaces `Path` with `Ty` in (not yet supported) equality predicates. They are parsed as types anyway and arbitrary types can always be disguised as paths using aliases, so this doesn't add any new functionality.\n\nThe third commit uses `Vec` instead of `P<[T]>` in AST. AST is not immutable like HIR and `Vec`s are more convenient for it, unnecessary conversions are also avoided.\n\nThe last commit renames `parse_ty_sum` (which is used for parsing types in general) into `parse_ty`, and renames `parse_ty` (which is used restricted contexts where `+` is not permitted due to operator priorities or other reasons) into `parse_ty_no_plus`.\n\nThis is the first part of https://github.com/rust-lang/rust/issues/39085#issuecomment-272743755 and https://github.com/rust-lang/rust/issues/39080 focused on data changes and mechanical renaming, I'll submit a PR with parser changes a bit later.\n\nr? @eddyb", "tree": {"sha": "fc768fdc8b7d00c603a0576656cd37bbd524bddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc768fdc8b7d00c603a0576656cd37bbd524bddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a167c042abed695a049abf3919ce929765e6cc30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a167c042abed695a049abf3919ce929765e6cc30", "html_url": "https://github.com/rust-lang/rust/commit/a167c042abed695a049abf3919ce929765e6cc30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a167c042abed695a049abf3919ce929765e6cc30/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0825c96b14f0b5eb59da1c36f70fe410c7c6fce7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0825c96b14f0b5eb59da1c36f70fe410c7c6fce7", "html_url": "https://github.com/rust-lang/rust/commit/0825c96b14f0b5eb59da1c36f70fe410c7c6fce7"}, {"sha": "66ef5f2bb55f3204d50b5011e3d15385065834c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/66ef5f2bb55f3204d50b5011e3d15385065834c1", "html_url": "https://github.com/rust-lang/rust/commit/66ef5f2bb55f3204d50b5011e3d15385065834c1"}], "stats": {"total": 612, "additions": 239, "deletions": 373}, "files": [{"sha": "7527d7fb318dddc543424d2012f25605e83f2af4", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -562,15 +562,11 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyPath(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.id, typ.span);\n         }\n-        TyObjectSum(ref ty, ref bounds) => {\n-            visitor.visit_ty(ty);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n-        }\n         TyArray(ref ty, length) => {\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(length)\n         }\n-        TyPolyTraitRef(ref bounds) => {\n+        TyTraitObject(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyImplTrait(ref bounds) => {\n@@ -740,12 +736,12 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n             walk_list!(visitor, visit_lifetime, bounds);\n         }\n         &WherePredicate::EqPredicate(WhereEqPredicate{id,\n-                                                      ref path,\n-                                                      ref ty,\n+                                                      ref lhs_ty,\n+                                                      ref rhs_ty,\n                                                       ..}) => {\n             visitor.visit_id(id);\n-            visitor.visit_path(path, id);\n-            visitor.visit_ty(ty);\n+            visitor.visit_ty(lhs_ty);\n+            visitor.visit_ty(rhs_ty);\n         }\n     }\n }"}, {"sha": "69ffbd9968aba97bfdf47c80d9cfcce62f306114", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -308,9 +308,6 @@ impl<'a> LoweringContext<'a> {\n                         span: t.span,\n                     })))\n                 }\n-                TyKind::ObjectSum(ref ty, ref bounds) => {\n-                    hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n-                }\n                 TyKind::Array(ref ty, ref length) => {\n                     let length = self.lower_expr(length);\n                     hir::TyArray(self.lower_ty(ty),\n@@ -320,8 +317,8 @@ impl<'a> LoweringContext<'a> {\n                     let expr = self.lower_expr(expr);\n                     hir::TyTypeof(self.record_body(expr, None))\n                 }\n-                TyKind::PolyTraitRef(ref bounds) => {\n-                    hir::TyPolyTraitRef(self.lower_bounds(bounds))\n+                TyKind::TraitObject(ref bounds) => {\n+                    hir::TyTraitObject(self.lower_bounds(bounds))\n                 }\n                 TyKind::ImplTrait(ref bounds) => {\n                     hir::TyImplTrait(self.lower_bounds(bounds))\n@@ -599,7 +596,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_params(&mut self, tps: &P<[TyParam]>, add_bounds: &NodeMap<Vec<TyParamBound>>)\n+    fn lower_ty_params(&mut self, tps: &Vec<TyParam>, add_bounds: &NodeMap<Vec<TyParamBound>>)\n                        -> hir::HirVec<hir::TyParam> {\n         tps.iter().map(|tp| {\n             self.lower_ty_param(tp, add_bounds.get(&tp.id).map_or(&[][..], |x| &x))\n@@ -719,13 +716,13 @@ impl<'a> LoweringContext<'a> {\n                 })\n             }\n             WherePredicate::EqPredicate(WhereEqPredicate{ id,\n-                                                          ref path,\n-                                                          ref ty,\n+                                                          ref lhs_ty,\n+                                                          ref rhs_ty,\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: id,\n-                    path: self.lower_path(id, path, ParamMode::Explicit, false),\n-                    ty: self.lower_ty(ty),\n+                    lhs_ty: self.lower_ty(lhs_ty),\n+                    rhs_ty: self.lower_ty(rhs_ty),\n                     span: span,\n                 })\n             }"}, {"sha": "b631d67e4736571d8097b309ed2d0efe90993543", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -403,8 +403,8 @@ pub struct WhereRegionPredicate {\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n     pub span: Span,\n-    pub path: Path,\n-    pub ty: P<Ty>,\n+    pub lhs_ty: P<Ty>,\n+    pub rhs_ty: P<Ty>,\n }\n \n pub type CrateConfig = HirVec<P<MetaItem>>;\n@@ -1214,12 +1214,11 @@ pub enum Ty_ {\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     TyPath(QPath),\n-\n-    /// Something like `A+B`. Note that `B` must always be a path.\n-    TyObjectSum(P<Ty>, TyParamBounds),\n-    /// A type like `for<'a> Foo<&'a Bar>`\n-    TyPolyTraitRef(TyParamBounds),\n-    /// An `impl TraitA+TraitB` type.\n+    /// A trait object type `Bound1 + Bound2 + Bound3`\n+    /// where `Bound` is a trait or a lifetime.\n+    TyTraitObject(TyParamBounds),\n+    /// An `impl Bound1 + Bound2 + Bound3` type\n+    /// where `Bound` is a trait or a lifetime.\n     TyImplTrait(TyParamBounds),\n     /// Unused for now\n     TyTypeof(BodyId),"}, {"sha": "377f2ea26aba995da2e0da3fcf7e4112b4d7b68f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -418,11 +418,7 @@ impl<'a> State<'a> {\n             hir::TyPath(ref qpath) => {\n                 self.print_qpath(qpath, false)?\n             }\n-            hir::TyObjectSum(ref ty, ref bounds) => {\n-                self.print_type(&ty)?;\n-                self.print_bounds(\"+\", &bounds[..])?;\n-            }\n-            hir::TyPolyTraitRef(ref bounds) => {\n+            hir::TyTraitObject(ref bounds) => {\n                 self.print_bounds(\"\", &bounds[..])?;\n             }\n             hir::TyImplTrait(ref bounds) => {\n@@ -2023,11 +2019,13 @@ impl<'a> State<'a> {\n                         }\n                     }\n                 }\n-                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    self.print_path(path, false)?;\n+                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref lhs_ty,\n+                                                                        ref rhs_ty,\n+                                                                        ..}) => {\n+                    self.print_type(lhs_ty)?;\n                     space(&mut self.s)?;\n                     self.word_space(\"=\")?;\n-                    self.print_type(&ty)?;\n+                    self.print_type(rhs_ty)?;\n                 }\n             }\n         }"}, {"sha": "dd99aea909faaada82ed1103d70e8f49c7086512", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -323,12 +323,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         self.visit_lifetime(bound);\n                     }\n                 }\n-                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ id,\n-                                                                         ref path,\n-                                                                         ref ty,\n-                                                                         .. }) => {\n-                    self.visit_path(path, id);\n-                    self.visit_ty(&ty);\n+                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref lhs_ty,\n+                                                                        ref rhs_ty,\n+                                                                        .. }) => {\n+                    self.visit_ty(lhs_ty);\n+                    self.visit_ty(rhs_ty);\n                 }\n             }\n         }"}, {"sha": "f0e86e81c076d060e4c3a1a373949026f1d70259", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -441,7 +441,6 @@ enum SawTyComponent {\n     SawTyTup,\n     SawTyPath,\n     SawTyObjectSum,\n-    SawTyPolyTraitRef,\n     SawTyImplTrait,\n     SawTyTypeof,\n     SawTyInfer\n@@ -457,8 +456,7 @@ fn saw_ty(node: &Ty_) -> SawTyComponent {\n       TyNever => SawTyNever,\n       TyTup(..) => SawTyTup,\n       TyPath(_) => SawTyPath,\n-      TyObjectSum(..) => SawTyObjectSum,\n-      TyPolyTraitRef(..) => SawTyPolyTraitRef,\n+      TyTraitObject(..) => SawTyObjectSum,\n       TyImplTrait(..) => SawTyImplTrait,\n       TyTypeof(..) => SawTyTypeof,\n       TyInfer => SawTyInfer"}, {"sha": "b7b027102b2afbd3c999d85f74d9982725fb0277", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -143,8 +143,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     err.emit();\n                 });\n             }\n-            TyKind::ObjectSum(_, ref bounds) |\n-            TyKind::PolyTraitRef(ref bounds) => {\n+            TyKind::TraitObject(ref bounds) => {\n                 self.no_questions_in_bounds(bounds, \"trait object types\", false);\n             }\n             _ => {}"}, {"sha": "ff4c92bb40ef558f07ed163c219a0ce2fc9bbb50", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -853,7 +853,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 }\n                 &hir::WherePredicate::RegionPredicate(_) => {}\n                 &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    self.visit_ty(&eq_pred.ty);\n+                    self.visit_ty(&eq_pred.rhs_ty);\n                 }\n             }\n         }"}, {"sha": "e4529b58f03ce9eeed248127ea8b8a1b0e87f248", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 87, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -73,7 +73,7 @@ use std::iter;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::symbol::{Symbol, keywords};\n-use syntax_pos::{Span, Pos};\n+use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n pub trait AstConv<'gcx, 'tcx> {\n@@ -930,87 +930,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         decl_ty.subst(self.tcx(), substs)\n     }\n \n-    fn ast_ty_to_object_trait_ref(&self,\n-                                  rscope: &RegionScope,\n-                                  span: Span,\n-                                  ty: &hir::Ty,\n-                                  bounds: &[hir::TyParamBound])\n-                                  -> Ty<'tcx>\n-    {\n-        /*!\n-         * In a type like `Foo + Send`, we want to wait to collect the\n-         * full set of bounds before we make the object type, because we\n-         * need them to infer a region bound.  (For example, if we tried\n-         * made a type from just `Foo`, then it wouldn't be enough to\n-         * infer a 'static bound, and hence the user would get an error.)\n-         * So this function is used when we're dealing with a sum type to\n-         * convert the LHS. It only accepts a type that refers to a trait\n-         * name, and reports an error otherwise.\n-         */\n-\n-        let tcx = self.tcx();\n-        match ty.node {\n-            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n-                if let Def::Trait(trait_def_id) = path.def {\n-                    self.trait_path_to_object_type(rscope,\n-                                                   path.span,\n-                                                   trait_def_id,\n-                                                   ty.id,\n-                                                   path.segments.last().unwrap(),\n-                                                   span,\n-                                                   partition_bounds(bounds))\n-                } else {\n-                    struct_span_err!(tcx.sess, ty.span, E0172,\n-                                     \"expected a reference to a trait\")\n-                        .span_label(ty.span, &format!(\"expected a trait\"))\n-                        .emit();\n-                    tcx.types.err\n-                }\n-            }\n-            _ => {\n-                let mut err = struct_span_err!(tcx.sess, ty.span, E0178,\n-                                               \"expected a path on the left-hand side \\\n-                                                of `+`, not `{}`\",\n-                                               tcx.map.node_to_pretty_string(ty.id));\n-                err.span_label(ty.span, &format!(\"expected a path\"));\n-                let hi = bounds.iter().map(|x| match *x {\n-                    hir::TraitTyParamBound(ref tr, _) => tr.span.hi,\n-                    hir::RegionTyParamBound(ref r) => r.span.hi,\n-                }).max_by_key(|x| x.to_usize());\n-                let full_span = hi.map(|hi| Span {\n-                    lo: ty.span.lo,\n-                    hi: hi,\n-                    expn_id: ty.span.expn_id,\n-                });\n-                match (&ty.node, full_span) {\n-                    (&hir::TyRptr(ref lifetime, ref mut_ty), Some(full_span)) => {\n-                        let ty_str = hir::print::to_string(&tcx.map, |s| {\n-                            use syntax::print::pp::word;\n-                            use syntax::print::pprust::PrintState;\n-\n-                            word(&mut s.s, \"&\")?;\n-                            s.print_opt_lifetime(lifetime)?;\n-                            s.print_mutability(mut_ty.mutbl)?;\n-                            s.popen()?;\n-                            s.print_type(&mut_ty.ty)?;\n-                            s.print_bounds(\" +\", bounds)?;\n-                            s.pclose()\n-                        });\n-                        err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n-                                            ty_str);\n-                    }\n-\n-                    _ => {\n-                        help!(&mut err,\n-                                   \"perhaps you forgot parentheses? (per RFC 438)\");\n-                    }\n-                }\n-                err.emit();\n-                tcx.types.err\n-            }\n-        }\n-    }\n-\n     /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n     /// removing the dummy Self type (TRAIT_OBJECT_DUMMY_SELF).\n     fn trait_ref_to_existential(&self, trait_ref: ty::TraitRef<'tcx>)\n@@ -1428,7 +1347,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         match path.def {\n             Def::Trait(trait_def_id) => {\n                 // N.B. this case overlaps somewhat with\n-                // TyObjectSum, see that fn for details\n+                // TyTraitObject, see that fn for details\n \n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n@@ -1534,9 +1453,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TySlice(ref ty) => {\n                 tcx.mk_slice(self.ast_ty_to_ty(rscope, &ty))\n             }\n-            hir::TyObjectSum(ref ty, ref bounds) => {\n-                self.ast_ty_to_object_trait_ref(rscope, ast_ty.span, ty, bounds)\n-            }\n             hir::TyPtr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut {\n                     ty: self.ast_ty_to_ty(rscope, &mt.ty),\n@@ -1609,7 +1525,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n                 tcx.mk_fn_ptr(bare_fn_ty)\n             }\n-            hir::TyPolyTraitRef(ref bounds) => {\n+            hir::TyTraitObject(ref bounds) => {\n                 self.conv_object_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n             }\n             hir::TyImplTrait(ref bounds) => {"}, {"sha": "3617b1f0a7de97722230bcfe6f18496f3559d072", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -1864,55 +1864,6 @@ fn bar(foo: Foo) -> u32 {\n ```\n \"##,\n \n-E0172: r##\"\n-This error means that an attempt was made to specify the type of a variable with\n-a combination of a concrete type and a trait. Consider the following example:\n-\n-```compile_fail,E0172\n-fn foo(bar: i32+std::fmt::Display) {}\n-```\n-\n-The code is trying to specify that we want to receive a signed 32-bit integer\n-which also implements `Display`. This doesn't make sense: when we pass `i32`, a\n-concrete type, it implicitly includes all of the traits that it implements.\n-This includes `Display`, `Debug`, `Clone`, and a host of others.\n-\n-If `i32` implements the trait we desire, there's no need to specify the trait\n-separately. If it does not, then we need to `impl` the trait for `i32` before\n-passing it into `foo`. Either way, a fixed definition for `foo` will look like\n-the following:\n-\n-```\n-fn foo(bar: i32) {}\n-```\n-\n-To learn more about traits, take a look at the Book:\n-\n-https://doc.rust-lang.org/book/traits.html\n-\"##,\n-\n-E0178: r##\"\n-In types, the `+` type operator has low precedence, so it is often necessary\n-to use parentheses.\n-\n-For example:\n-\n-```compile_fail,E0178\n-trait Foo {}\n-\n-struct Bar<'a> {\n-    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)\n-    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)\n-    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)\n-    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)\n-}\n-```\n-\n-More details can be found in [RFC 438].\n-\n-[RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n-\"##,\n-\n E0182: r##\"\n You bound an associated type in an expression path which is not\n allowed.\n@@ -4152,6 +4103,7 @@ register_diagnostics! {\n //  E0163, // merged into E0071\n //  E0167,\n //  E0168,\n+//  E0172, // non-trait found in a type sum, moved to resolve\n //  E0173, // manual implementations of unboxed closure traits are experimental\n //  E0174,\n     E0183,"}, {"sha": "a77485477b1591330dec2162217592e8ccadb12e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -1504,9 +1504,6 @@ pub enum Type {\n     // _\n     Infer,\n \n-    // for<'a> Foo(&'a)\n-    PolyTraitRef(Vec<TyParamBound>),\n-\n     // impl TraitA+TraitB\n     ImplTrait(Vec<TyParamBound>),\n }\n@@ -1768,24 +1765,26 @@ impl Clean<Type> for hir::Ty {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n-            TyObjectSum(ref lhs, ref bounds) => {\n-                let lhs_ty = lhs.clean(cx);\n+            TyTraitObject(ref bounds) => {\n+                let lhs_ty = bounds[0].clean(cx);\n                 match lhs_ty {\n-                    ResolvedPath { path, typarams: None, did, is_generic } => {\n-                        ResolvedPath {\n-                            path: path,\n-                            typarams: Some(bounds.clean(cx)),\n-                            did: did,\n-                            is_generic: is_generic,\n+                    TraitBound(poly_trait, ..) => {\n+                        match poly_trait.trait_ {\n+                            ResolvedPath { path, typarams: None, did, is_generic } => {\n+                                ResolvedPath {\n+                                    path: path,\n+                                    typarams: Some(bounds[1..].clean(cx)),\n+                                    did: did,\n+                                    is_generic: is_generic,\n+                                }\n+                            }\n+                            _ => Infer // shouldn't happen\n                         }\n                     }\n-                    _ => {\n-                        lhs_ty // shouldn't happen\n-                    }\n+                    _ => Infer // shouldn't happen\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyPolyTraitRef(ref bounds) => PolyTraitRef(bounds.clean(cx)),\n             TyImplTrait(ref bounds) => ImplTrait(bounds.clean(cx)),\n             TyInfer => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),"}, {"sha": "d25c4184f3cf9f816d58ae4960355d2eecf8687d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -679,19 +679,6 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                 }\n             }\n         }\n-        clean::PolyTraitRef(ref bounds) => {\n-            for (i, bound) in bounds.iter().enumerate() {\n-                if i != 0 {\n-                    write!(f, \" + \")?;\n-                }\n-                if f.alternate() {\n-                    write!(f, \"{:#}\", *bound)?;\n-                } else {\n-                    write!(f, \"{}\", *bound)?;\n-                }\n-            }\n-            Ok(())\n-        }\n         clean::ImplTrait(ref bounds) => {\n             write!(f, \"impl \")?;\n             for (i, bound) in bounds.iter().enumerate() {"}, {"sha": "58487655ac187289c7b00680315524c90375f96f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -204,11 +204,11 @@ pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n-    pub types: P<[P<Ty>]>,\n+    pub types: Vec<P<Ty>>,\n     /// Bindings (equality constraints) on associated types, if present.\n     ///\n     /// E.g., `Foo<A=Bar>`.\n-    pub bindings: P<[TypeBinding]>,\n+    pub bindings: Vec<TypeBinding>,\n }\n \n impl Into<Option<P<PathParameters>>> for AngleBracketedParameterData {\n@@ -297,7 +297,7 @@ pub enum TraitBoundModifier {\n     Maybe,\n }\n \n-pub type TyParamBounds = P<[TyParamBound]>;\n+pub type TyParamBounds = Vec<TyParamBound>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TyParam {\n@@ -314,7 +314,7 @@ pub struct TyParam {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n     pub lifetimes: Vec<LifetimeDef>,\n-    pub ty_params: P<[TyParam]>,\n+    pub ty_params: Vec<TyParam>,\n     pub where_clause: WhereClause,\n     pub span: Span,\n }\n@@ -344,7 +344,7 @@ impl Default for Generics {\n     fn default() ->  Generics {\n         Generics {\n             lifetimes: Vec::new(),\n-            ty_params: P::new(),\n+            ty_params: Vec::new(),\n             where_clause: WhereClause {\n                 id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n@@ -403,8 +403,8 @@ pub struct WhereRegionPredicate {\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n     pub span: Span,\n-    pub path: Path,\n-    pub ty: P<Ty>,\n+    pub lhs_ty: P<Ty>,\n+    pub rhs_ty: P<Ty>,\n }\n \n /// The set of MetaItems that define the compilation environment of the crate,\n@@ -1357,11 +1357,11 @@ pub enum TyKind {\n     ///\n     /// Type parameters are stored in the Path itself\n     Path(Option<QSelf>, Path),\n-    /// Something like `A+B`. Note that `B` must always be a path.\n-    ObjectSum(P<Ty>, TyParamBounds),\n-    /// A type like `for<'a> Foo<&'a Bar>`\n-    PolyTraitRef(TyParamBounds),\n-    /// An `impl TraitA+TraitB` type.\n+    /// A trait object type `Bound1 + Bound2 + Bound3`\n+    /// where `Bound` is a trait or a lifetime.\n+    TraitObject(TyParamBounds),\n+    /// An `impl Bound1 + Bound2 + Bound3` type\n+    /// where `Bound` is a trait or a lifetime.\n     ImplTrait(TyParamBounds),\n     /// No-op; kept solely so that we can pretty-print faithfully\n     Paren(P<Ty>),"}, {"sha": "2b4d13375046e851c7910765114ce16d38a32f4c", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -15,6 +15,28 @@\n // In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n \n+E0178: r##\"\n+In types, the `+` type operator has low precedence, so it is often necessary\n+to use parentheses.\n+\n+For example:\n+\n+```compile_fail,E0178\n+trait Foo {}\n+\n+struct Bar<'a> {\n+    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)\n+    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)\n+    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)\n+    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)\n+}\n+```\n+\n+More details can be found in [RFC 438].\n+\n+[RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n+\"##,\n+\n E0534: r##\"\n The `inline` attribute was malformed.\n "}, {"sha": "1837fa1e5fee844b2ee957a60e51a69d6c3d3632", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -54,7 +54,6 @@ pub trait AstBuilder {\n \n     fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty>;\n     fn ty_path(&self, ast::Path) -> P<ast::Ty>;\n-    fn ty_sum(&self, ast::Path, ast::TyParamBounds) -> P<ast::Ty>;\n     fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n \n     fn ty_rptr(&self, span: Span,\n@@ -68,9 +67,6 @@ pub trait AstBuilder {\n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n \n-    fn ty_vars(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> ;\n-    fn ty_vars_global(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> ;\n-\n     fn typaram(&self,\n                span: Span,\n                id: ast::Ident,\n@@ -334,8 +330,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         } else {\n             Some(P(ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n-                types: P::from_vec(types),\n-                bindings: P::from_vec(bindings),\n+                types: types,\n+                bindings: bindings,\n             })))\n         };\n         segments.push(ast::PathSegment { identifier: last_identifier, parameters: parameters });\n@@ -370,8 +366,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let mut path = trait_path;\n         let parameters = ast::AngleBracketedParameterData {\n             lifetimes: lifetimes,\n-            types: P::from_vec(types),\n-            bindings: P::from_vec(bindings),\n+            types: types,\n+            bindings: bindings,\n         };\n         path.segments.push(ast::PathSegment {\n             identifier: ident,\n@@ -403,12 +399,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty(path.span, ast::TyKind::Path(None, path))\n     }\n \n-    fn ty_sum(&self, path: ast::Path, bounds: ast::TyParamBounds) -> P<ast::Ty> {\n-        self.ty(path.span,\n-                ast::TyKind::ObjectSum(self.ty_path(path),\n-                                 bounds))\n-    }\n-\n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: Span, ident: ast::Ident)\n@@ -465,20 +455,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    // these are strange, and probably shouldn't be used outside of\n-    // pipes. Specifically, the global version possible generates\n-    // incorrect code.\n-    fn ty_vars(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> {\n-        ty_params.iter().map(|p| self.ty_ident(DUMMY_SP, p.ident)).collect()\n-    }\n-\n-    fn ty_vars_global(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> {\n-        ty_params\n-            .iter()\n-            .map(|p| self.ty_path(self.path_global(DUMMY_SP, vec![p.ident])))\n-            .collect()\n-    }\n-\n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {\n         ast::TraitRef {\n             path: path,"}, {"sha": "26e731e1a5ecb9283262d143ffaf0015a720ff33", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -540,7 +540,7 @@ impl<'a> Parser<'a> {\n             }\n             ExpansionKind::Expr => Expansion::Expr(self.parse_expr()?),\n             ExpansionKind::OptExpr => Expansion::OptExpr(Some(self.parse_expr()?)),\n-            ExpansionKind::Ty => Expansion::Ty(self.parse_ty()?),\n+            ExpansionKind::Ty => Expansion::Ty(self.parse_ty_no_plus()?),\n             ExpansionKind::Pat => Expansion::Pat(self.parse_pat()?),\n         })\n     }"}, {"sha": "c0cbda4ba12269d76e097f59205ccba24302c35d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -388,7 +388,7 @@ pub fn parse_arm_panic(parser: &mut Parser) -> Arm {\n }\n \n pub fn parse_ty_panic(parser: &mut Parser) -> P<Ty> {\n-    panictry!(parser.parse_ty())\n+    panictry!(parser.parse_ty_no_plus())\n }\n \n pub fn parse_stmt_panic(parser: &mut Parser) -> Option<Stmt> {"}, {"sha": "87c8f3efb6355a6e33e35c7a99fb45d8cae9a387", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -522,7 +522,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         },\n         \"pat\" => token::NtPat(panictry!(p.parse_pat())),\n         \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n-        \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n+        \"ty\" => token::NtTy(panictry!(p.parse_ty_no_plus())),\n         // this could be handled like a token, since it is one\n         \"ident\" => match p.token {\n             token::Ident(sn) => {"}, {"sha": "2e5ce739fb34a7221755d986b256c9811711c891", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -225,7 +225,7 @@ pub trait Folder : Sized {\n         noop_fold_ty_param(tp, self)\n     }\n \n-    fn fold_ty_params(&mut self, tps: P<[TyParam]>) -> P<[TyParam]> {\n+    fn fold_ty_params(&mut self, tps: Vec<TyParam>) -> Vec<TyParam> {\n         noop_fold_ty_params(tps, self)\n     }\n \n@@ -380,18 +380,14 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                 });\n                 TyKind::Path(qself, fld.fold_path(path))\n             }\n-            TyKind::ObjectSum(ty, bounds) => {\n-                TyKind::ObjectSum(fld.fold_ty(ty),\n-                            fld.fold_bounds(bounds))\n-            }\n             TyKind::Array(ty, e) => {\n                 TyKind::Array(fld.fold_ty(ty), fld.fold_expr(e))\n             }\n             TyKind::Typeof(expr) => {\n                 TyKind::Typeof(fld.fold_expr(expr))\n             }\n-            TyKind::PolyTraitRef(bounds) => {\n-                TyKind::PolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+            TyKind::TraitObject(bounds) => {\n+                TyKind::TraitObject(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n             }\n             TyKind::ImplTrait(bounds) => {\n                 TyKind::ImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n@@ -678,8 +674,7 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: P<[TyParam]>, fld: &mut T)\n-                                      -> P<[TyParam]> {\n+pub fn noop_fold_ty_params<T: Folder>(tps: Vec<TyParam>, fld: &mut T) -> Vec<TyParam> {\n     tps.move_map(|tp| fld.fold_ty_param(tp))\n }\n \n@@ -766,13 +761,13 @@ pub fn noop_fold_where_predicate<T: Folder>(\n             })\n         }\n         ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n-                                                               path,\n-                                                               ty,\n+                                                               lhs_ty,\n+                                                               rhs_ty,\n                                                                span}) => {\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{\n                 id: fld.new_id(id),\n-                path: fld.fold_path(path),\n-                ty:fld.fold_ty(ty),\n+                lhs_ty: fld.fold_ty(lhs_ty),\n+                rhs_ty: fld.fold_ty(rhs_ty),\n                 span: fld.new_span(span)\n             })\n         }"}, {"sha": "1a1950dc45c619faf63c4626bccccd9345a959b7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -847,7 +847,7 @@ mod tests {\n                                     Abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n-                                        ty_params: P::new(),\n+                                        ty_params: Vec::new(),\n                                         where_clause: ast::WhereClause {\n                                             id: ast::DUMMY_NODE_ID,\n                                             predicates: Vec::new(),"}, {"sha": "d1a683b0bd5b859aaa1aef8fd9f374e610e8e7b1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 109, "deletions": 57, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -40,7 +40,7 @@ use ast::{Visibility, WhereClause};\n use ast::{BinOpKind, UnOp};\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, spanned, respan};\n-use syntax_pos::{self, Span, BytePos, mk_sp};\n+use syntax_pos::{self, Span, Pos, BytePos, mk_sp};\n use errors::{self, DiagnosticBuilder};\n use ext::tt::macro_parser;\n use parse;\n@@ -685,7 +685,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_before_gt_or_return<T, F>(&mut self,\n                                                   sep: Option<token::Token>,\n                                                   mut f: F)\n-                                                  -> PResult<'a, (P<[T]>, bool)>\n+                                                  -> PResult<'a, (Vec<T>, bool)>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a, Option<T>>,\n     {\n         let mut v = Vec::new();\n@@ -706,7 +706,7 @@ impl<'a> Parser<'a> {\n             if i % 2 == 0 {\n                 match f(self)? {\n                     Some(result) => v.push(result),\n-                    None => return Ok((P::from_vec(v), true))\n+                    None => return Ok((v, true))\n                 }\n             } else {\n                 if let Some(t) = sep.as_ref() {\n@@ -715,15 +715,15 @@ impl<'a> Parser<'a> {\n \n             }\n         }\n-        return Ok((P::from_vec(v), false));\n+        return Ok((v, false));\n     }\n \n     /// Parse a sequence bracketed by '<' and '>', stopping\n     /// before the '>'.\n     pub fn parse_seq_to_before_gt<T, F>(&mut self,\n                                         sep: Option<token::Token>,\n                                         mut f: F)\n-                                        -> PResult<'a, P<[T]>> where\n+                                        -> PResult<'a, Vec<T>> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         let (result, returned) = self.parse_seq_to_before_gt_or_return(sep,\n@@ -735,7 +735,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_gt<T, F>(&mut self,\n                                  sep: Option<token::Token>,\n                                  f: F)\n-                                 -> PResult<'a, P<[T]>> where\n+                                 -> PResult<'a, Vec<T>> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         let v = self.parse_seq_to_before_gt(sep, f)?;\n@@ -746,7 +746,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_gt_or_return<T, F>(&mut self,\n                                            sep: Option<token::Token>,\n                                            f: F)\n-                                           -> PResult<'a, (P<[T]>, bool)> where\n+                                           -> PResult<'a, (Vec<T>, bool)> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a, Option<T>>,\n     {\n         let (v, returned) = self.parse_seq_to_before_gt_or_return(sep, f)?;\n@@ -1039,13 +1039,13 @@ impl<'a> Parser<'a> {\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n                 self.parse_ty_param_bounds()?\n             } else {\n-                P::new()\n+                Vec::new()\n             };\n             let all_bounds =\n                 Some(TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)).into_iter()\n-                .chain(other_bounds.into_vec())\n+                .chain(other_bounds)\n                 .collect();\n-            Ok(ast::TyKind::PolyTraitRef(all_bounds))\n+            Ok(ast::TyKind::TraitObject(all_bounds))\n         }\n     }\n \n@@ -1128,7 +1128,7 @@ impl<'a> Parser<'a> {\n                 self.expect_keyword(keywords::Const)?;\n             let ident = self.parse_ident()?;\n             self.expect(&token::Colon)?;\n-            let ty = self.parse_ty_sum()?;\n+            let ty = self.parse_ty()?;\n             let default = if self.check(&token::Eq) {\n                 self.bump();\n                 let expr = self.parse_expr()?;\n@@ -1244,30 +1244,30 @@ impl<'a> Parser<'a> {\n     /// Parse a possibly mutable type\n     pub fn parse_mt(&mut self) -> PResult<'a, MutTy> {\n         let mutbl = self.parse_mutability()?;\n-        let t = self.parse_ty()?;\n+        let t = self.parse_ty_no_plus()?;\n         Ok(MutTy { ty: t, mutbl: mutbl })\n     }\n \n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n-            Ok(FunctionRetTy::Ty(self.parse_ty()?))\n+            Ok(FunctionRetTy::Ty(self.parse_ty_no_plus()?))\n         } else {\n             let pos = self.span.lo;\n             Ok(FunctionRetTy::Default(mk_sp(pos, pos)))\n         }\n     }\n \n-    /// Parse a type in a context where `T1+T2` is allowed.\n-    pub fn parse_ty_sum(&mut self) -> PResult<'a, P<Ty>> {\n+    /// Parse a type.\n+    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n         let lo = self.span.lo;\n-        let lhs = self.parse_ty()?;\n+        let lhs = self.parse_ty_no_plus()?;\n \n         if !self.eat(&token::BinOp(token::Plus)) {\n             return Ok(lhs);\n         }\n \n-        let bounds = self.parse_ty_param_bounds()?;\n+        let mut bounds = self.parse_ty_param_bounds()?;\n \n         // In type grammar, `+` is treated like a binary operator,\n         // and hence both L and R side are required.\n@@ -1277,14 +1277,66 @@ impl<'a> Parser<'a> {\n                           \"at least one type parameter bound \\\n                           must be specified\");\n         }\n+        if let TyKind::Path(None, ref path) = lhs.node {\n+            let poly_trait_ref = PolyTraitRef {\n+                bound_lifetimes: Vec::new(),\n+                trait_ref: TraitRef { path: path.clone(), ref_id: lhs.id },\n+                span: lhs.span,\n+            };\n+            let poly_trait_ref = TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None);\n+            bounds.insert(0, poly_trait_ref);\n+        } else {\n+            let mut err = struct_span_err!(self.sess.span_diagnostic, lhs.span, E0178,\n+                                            \"expected a path on the left-hand side \\\n+                                            of `+`, not `{}`\",\n+                                            pprust::ty_to_string(&lhs));\n+            err.span_label(lhs.span, &format!(\"expected a path\"));\n+            let hi = bounds.iter().map(|x| match *x {\n+                ast::TraitTyParamBound(ref tr, _) => tr.span.hi,\n+                ast::RegionTyParamBound(ref r) => r.span.hi,\n+            }).max_by_key(|x| x.to_usize());\n+            let full_span = hi.map(|hi| Span {\n+                lo: lhs.span.lo,\n+                hi: hi,\n+                expn_id: lhs.span.expn_id,\n+            });\n+            match (&lhs.node, full_span) {\n+                (&TyKind::Rptr(ref lifetime, ref mut_ty), Some(full_span)) => {\n+                    let ty_str = pprust::to_string(|s| {\n+                        use print::pp::word;\n+                        use print::pprust::PrintState;\n+\n+                        word(&mut s.s, \"&\")?;\n+                        s.print_opt_lifetime(lifetime)?;\n+                        s.print_mutability(mut_ty.mutbl)?;\n+                        s.popen()?;\n+                        s.print_type(&mut_ty.ty)?;\n+                        s.print_bounds(\" +\", &bounds)?;\n+                        s.pclose()\n+                    });\n+                    err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n+                                        ty_str);\n+                }\n+\n+                _ => {\n+                    help!(&mut err,\n+                                \"perhaps you forgot parentheses? (per RFC 438)\");\n+                }\n+            }\n+            err.emit();\n+        }\n \n         let sp = mk_sp(lo, self.prev_span.hi);\n-        let sum = ast::TyKind::ObjectSum(lhs, bounds);\n+        let sum = TyKind::TraitObject(bounds);\n         Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: sum, span: sp}))\n     }\n \n-    /// Parse a type.\n-    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n+    /// Parse a type in restricted contexts where `+` is not permitted.\n+    /// Example 1: `&'a TYPE`\n+    ///     `+` is prohibited to maintain operator priority (P(+) < P(&)).\n+    /// Example 2: `value1 as TYPE + value2`\n+    ///     `+` is prohibited to avoid interactions with expression grammar.\n+    pub fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n         maybe_whole!(self, NtTy, |x| x);\n \n         let lo = self.span.lo;\n@@ -1298,7 +1350,7 @@ impl<'a> Parser<'a> {\n             let mut ts = vec![];\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n-                ts.push(self.parse_ty_sum()?);\n+                ts.push(self.parse_ty()?);\n                 if self.check(&token::Comma) {\n                     last_comma = true;\n                     self.bump();\n@@ -1323,7 +1375,7 @@ impl<'a> Parser<'a> {\n         } else if self.check(&token::OpenDelim(token::Bracket)) {\n             // VECTOR\n             self.expect(&token::OpenDelim(token::Bracket))?;\n-            let t = self.parse_ty_sum()?;\n+            let t = self.parse_ty()?;\n \n             // Parse the `; e` in `[ i32; e ]`\n             // where `e` is a const expression\n@@ -1404,7 +1456,7 @@ impl<'a> Parser<'a> {\n                            `*mut T` or `*const T` as appropriate)\");\n             Mutability::Immutable\n         };\n-        let t = self.parse_ty()?;\n+        let t = self.parse_ty_no_plus()?;\n         Ok(MutTy { ty: t, mutbl: mutbl })\n     }\n \n@@ -1451,7 +1503,7 @@ impl<'a> Parser<'a> {\n             })\n         };\n \n-        let t = self.parse_ty_sum()?;\n+        let t = self.parse_ty()?;\n \n         Ok(Arg {\n             ty: t,\n@@ -1469,7 +1521,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> {\n         let pat = self.parse_pat()?;\n         let t = if self.eat(&token::Colon) {\n-            self.parse_ty_sum()?\n+            self.parse_ty()?\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -1610,7 +1662,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_qualified_path(&mut self, mode: PathStyle)\n                                 -> PResult<'a, (QSelf, ast::Path)> {\n         let span = self.prev_span;\n-        let self_type = self.parse_ty_sum()?;\n+        let self_type = self.parse_ty()?;\n         let mut path = if self.eat_keyword(keywords::As) {\n             self.parse_path(PathStyle::Type)?\n         } else {\n@@ -1711,19 +1763,19 @@ impl<'a> Parser<'a> {\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n                 ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n-                    types: P::from_vec(types),\n-                    bindings: P::from_vec(bindings),\n+                    types: types,\n+                    bindings: bindings,\n                 }.into()\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n                 let lo = self.prev_span.lo;\n \n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n                     SeqSep::trailing_allowed(token::Comma),\n-                    |p| p.parse_ty_sum())?;\n+                    |p| p.parse_ty())?;\n \n                 let output_ty = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty()?)\n+                    Some(self.parse_ty_no_plus()?)\n                 } else {\n                     None\n                 };\n@@ -1771,8 +1823,8 @@ impl<'a> Parser<'a> {\n                     identifier: identifier,\n                     parameters: ast::AngleBracketedParameterData {\n                         lifetimes: lifetimes,\n-                        types: P::from_vec(types),\n-                        bindings: P::from_vec(bindings),\n+                        types: types,\n+                        bindings: bindings,\n                     }.into(),\n                 });\n \n@@ -2933,12 +2985,12 @@ impl<'a> Parser<'a> {\n             }\n             // Special cases:\n             if op == AssocOp::As {\n-                let rhs = self.parse_ty()?;\n+                let rhs = self.parse_ty_no_plus()?;\n                 let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n                 lhs = self.mk_expr(lo, hi, ExprKind::Cast(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::Colon {\n-                let rhs = self.parse_ty()?;\n+                let rhs = self.parse_ty_no_plus()?;\n                 let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n                 lhs = self.mk_expr(lo, hi, ExprKind::Type(lhs, rhs), ThinVec::new());\n                 continue\n@@ -3706,7 +3758,7 @@ impl<'a> Parser<'a> {\n \n         let mut ty = None;\n         if self.eat(&token::Colon) {\n-            ty = Some(self.parse_ty_sum()?);\n+            ty = Some(self.parse_ty()?);\n         }\n         let init = self.parse_initializer()?;\n         Ok(P(ast::Local {\n@@ -3727,7 +3779,7 @@ impl<'a> Parser<'a> {\n                          -> PResult<'a, StructField> {\n         let name = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n-        let ty = self.parse_ty_sum()?;\n+        let ty = self.parse_ty()?;\n         Ok(StructField {\n             span: mk_sp(lo, self.prev_span.hi),\n             ident: Some(name),\n@@ -4144,7 +4196,7 @@ impl<'a> Parser<'a> {\n     fn parse_colon_then_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n     {\n         if !self.eat(&token::Colon) {\n-            Ok(P::new())\n+            Ok(Vec::new())\n         } else {\n             self.parse_ty_param_bounds()\n         }\n@@ -4190,7 +4242,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Ok(P::from_vec(result));\n+        return Ok(result);\n     }\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n@@ -4202,7 +4254,7 @@ impl<'a> Parser<'a> {\n \n         let default = if self.check(&token::Eq) {\n             self.bump();\n-            Some(self.parse_ty_sum()?)\n+            Some(self.parse_ty()?)\n         } else {\n             None\n         };\n@@ -4297,7 +4349,7 @@ impl<'a> Parser<'a> {\n             let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n \n             let span_hi = self.span.hi;\n-            let span_hi = match self.parse_ty() {\n+            let span_hi = match self.parse_ty_no_plus() {\n                 Ok(..) => self.span.hi,\n                 Err(ref mut err) => {\n                     self.cancel(err);\n@@ -4320,14 +4372,14 @@ impl<'a> Parser<'a> {\n                 if p.look_ahead(1, |t| t == &token::Eq) {\n                     Ok(None)\n                 } else {\n-                    Ok(Some(p.parse_ty_sum()?))\n+                    Ok(Some(p.parse_ty()?))\n                 }\n             }\n         )?;\n \n         // If we found the `>`, don't continue.\n         if !returned {\n-            return Ok((lifetimes, types.into_vec(), Vec::new()));\n+            return Ok((lifetimes, types, Vec::new()));\n         }\n \n         // Then parse type bindings.\n@@ -4338,7 +4390,7 @@ impl<'a> Parser<'a> {\n                 let lo = p.span.lo;\n                 let ident = p.parse_ident()?;\n                 p.expect(&token::Eq)?;\n-                let ty = p.parse_ty()?;\n+                let ty = p.parse_ty_no_plus()?;\n                 let hi = ty.span.hi;\n                 let span = mk_sp(lo, hi);\n                 return Ok(TypeBinding{id: ast::DUMMY_NODE_ID,\n@@ -4348,7 +4400,7 @@ impl<'a> Parser<'a> {\n                 });\n             }\n         )?;\n-        Ok((lifetimes, types.into_vec(), bindings.into_vec()))\n+        Ok((lifetimes, types, bindings))\n     }\n \n     fn forbid_lifetime(&mut self) -> PResult<'a, ()> {\n@@ -4436,7 +4488,7 @@ impl<'a> Parser<'a> {\n                         vec![]\n                     };\n \n-                    let bounded_ty = self.parse_ty()?;\n+                    let bounded_ty = self.parse_ty_no_plus()?;\n \n                     if self.eat(&token::Colon) {\n                         let bounds = self.parse_ty_param_bounds()?;\n@@ -4459,7 +4511,7 @@ impl<'a> Parser<'a> {\n \n                         parsed_something = true;\n                     } else if self.eat(&token::Eq) {\n-                        // let ty = try!(self.parse_ty());\n+                        // let ty = try!(self.parse_ty_no_plus());\n                         let hi = self.prev_span.hi;\n                         let span = mk_sp(lo, hi);\n                         // where_clause.predicates.push(\n@@ -4631,7 +4683,7 @@ impl<'a> Parser<'a> {\n                     // self: TYPE\n                     let eself_ident = expect_ident(self);\n                     if self.eat(&token::Colon) {\n-                        let ty = self.parse_ty_sum()?;\n+                        let ty = self.parse_ty()?;\n                         (SelfKind::Explicit(ty, Mutability::Immutable), eself_ident)\n                     } else {\n                         (SelfKind::Value(Mutability::Immutable), eself_ident)\n@@ -4643,7 +4695,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     let eself_ident = expect_ident(self);\n                     if self.eat(&token::Colon) {\n-                        let ty = self.parse_ty_sum()?;\n+                        let ty = self.parse_ty()?;\n                         (SelfKind::Explicit(ty, Mutability::Mutable), eself_ident)\n                     } else {\n                         (SelfKind::Value(Mutability::Mutable), eself_ident)\n@@ -4800,14 +4852,14 @@ impl<'a> Parser<'a> {\n         let (name, node) = if self.eat_keyword(keywords::Type) {\n             let name = self.parse_ident()?;\n             self.expect(&token::Eq)?;\n-            let typ = self.parse_ty_sum()?;\n+            let typ = self.parse_ty()?;\n             self.expect(&token::Semi)?;\n             (name, ast::ImplItemKind::Type(typ))\n         } else if self.is_const_item() {\n             self.expect_keyword(keywords::Const)?;\n             let name = self.parse_ident()?;\n             self.expect(&token::Colon)?;\n-            let typ = self.parse_ty_sum()?;\n+            let typ = self.parse_ty()?;\n             self.expect(&token::Eq)?;\n             let expr = self.parse_expr()?;\n             self.expect(&token::Semi)?;\n@@ -4931,7 +4983,7 @@ impl<'a> Parser<'a> {\n         };\n \n         // Parse the trait.\n-        let mut ty = self.parse_ty_sum()?;\n+        let mut ty = self.parse_ty()?;\n \n         // Parse traits, if necessary.\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n@@ -4972,7 +5024,7 @@ impl<'a> Parser<'a> {\n              ItemKind::DefaultImpl(unsafety, opt_trait.unwrap()), None))\n         } else {\n             if opt_trait.is_some() {\n-                ty = self.parse_ty_sum()?;\n+                ty = self.parse_ty()?;\n             }\n             generics.where_clause = self.parse_where_clause()?;\n \n@@ -5124,15 +5176,15 @@ impl<'a> Parser<'a> {\n                 let mut vis = p.parse_visibility(false)?;\n                 let ty_is_interpolated =\n                     p.token.is_interpolated() || p.look_ahead(1, |t| t.is_interpolated());\n-                let mut ty = p.parse_ty_sum()?;\n+                let mut ty = p.parse_ty()?;\n \n                 // Handle `pub(path) type`, in which `vis` will be `pub` and `ty` will be `(path)`.\n                 if vis == Visibility::Public && !ty_is_interpolated &&\n                    p.token != token::Comma && p.token != token::CloseDelim(token::Paren) {\n                     ty = if let TyKind::Paren(ref path_ty) = ty.node {\n                         if let TyKind::Path(None, ref path) = path_ty.node {\n                             vis = Visibility::Restricted { path: P(path.clone()), id: path_ty.id };\n-                            Some(p.parse_ty_sum()?)\n+                            Some(p.parse_ty()?)\n                         } else {\n                             None\n                         }\n@@ -5250,7 +5302,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n         let id = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n-        let ty = self.parse_ty_sum()?;\n+        let ty = self.parse_ty()?;\n         self.expect(&token::Eq)?;\n         let e = self.parse_expr()?;\n         self.expect(&token::Semi)?;\n@@ -5491,7 +5543,7 @@ impl<'a> Parser<'a> {\n \n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n-        let ty = self.parse_ty_sum()?;\n+        let ty = self.parse_ty()?;\n         let hi = self.span.hi;\n         self.expect(&token::Semi)?;\n         Ok(ForeignItem {\n@@ -5580,7 +5632,7 @@ impl<'a> Parser<'a> {\n         let mut tps = self.parse_generics()?;\n         tps.where_clause = self.parse_where_clause()?;\n         self.expect(&token::Eq)?;\n-        let ty = self.parse_ty_sum()?;\n+        let ty = self.parse_ty()?;\n         self.expect(&token::Semi)?;\n         Ok((ident, ItemKind::Ty(ty, tps), None))\n     }"}, {"sha": "baa3ebec854690781840d1ef0b87fb2486b3e948", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -1009,7 +1009,7 @@ impl<'a> State<'a> {\n             ast::TyKind::BareFn(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: P::new(),\n+                    ty_params: Vec::new(),\n                     where_clause: ast::WhereClause {\n                         id: ast::DUMMY_NODE_ID,\n                         predicates: Vec::new(),\n@@ -1028,11 +1028,7 @@ impl<'a> State<'a> {\n             ast::TyKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false)?\n             }\n-            ast::TyKind::ObjectSum(ref ty, ref bounds) => {\n-                self.print_type(&ty)?;\n-                self.print_bounds(\"+\", &bounds[..])?;\n-            }\n-            ast::TyKind::PolyTraitRef(ref bounds) => {\n+            ast::TyKind::TraitObject(ref bounds) => {\n                 self.print_bounds(\"\", &bounds[..])?;\n             }\n             ast::TyKind::ImplTrait(ref bounds) => {\n@@ -2849,11 +2845,13 @@ impl<'a> State<'a> {\n                                                                                ..}) => {\n                     self.print_lifetime_bounds(lifetime, bounds)?;\n                 }\n-                ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    self.print_path(path, false, 0, false)?;\n+                ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref lhs_ty,\n+                                                                       ref rhs_ty,\n+                                                                       ..}) => {\n+                    self.print_type(lhs_ty)?;\n                     space(&mut self.s)?;\n                     self.word_space(\"=\")?;\n-                    self.print_type(&ty)?;\n+                    self.print_type(rhs_ty)?;\n                 }\n             }\n         }\n@@ -2975,7 +2973,7 @@ impl<'a> State<'a> {\n         }\n         let generics = ast::Generics {\n             lifetimes: Vec::new(),\n-            ty_params: P::new(),\n+            ty_params: Vec::new(),\n             where_clause: ast::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),"}, {"sha": "1fcfce1894859c9e10a7de1eb58f24fb8630871f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -342,15 +342,11 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             }\n             visitor.visit_path(path, typ.id);\n         }\n-        TyKind::ObjectSum(ref ty, ref bounds) => {\n-            visitor.visit_ty(ty);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n-        }\n         TyKind::Array(ref ty, ref expression) => {\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expression)\n         }\n-        TyKind::PolyTraitRef(ref bounds) => {\n+        TyKind::TraitObject(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyKind::ImplTrait(ref bounds) => {\n@@ -508,12 +504,11 @@ pub fn walk_generics<'a, V: Visitor<'a>>(visitor: &mut V, generics: &'a Generics\n                 visitor.visit_lifetime(lifetime);\n                 walk_list!(visitor, visit_lifetime, bounds);\n             }\n-            WherePredicate::EqPredicate(WhereEqPredicate{id,\n-                                                         ref path,\n-                                                         ref ty,\n+            WherePredicate::EqPredicate(WhereEqPredicate{ref lhs_ty,\n+                                                         ref rhs_ty,\n                                                          ..}) => {\n-                visitor.visit_path(path, id);\n-                visitor.visit_ty(ty);\n+                visitor.visit_ty(lhs_ty);\n+                visitor.visit_ty(rhs_ty);\n             }\n         }\n     }"}, {"sha": "ce64aef516f493eaf106a03fdfc4575ef3ad1ef9", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -507,9 +507,8 @@ impl<'a> TraitDef<'a> {\n             }\n         });\n \n-        let Generics { mut lifetimes, ty_params, mut where_clause, span } = self.generics\n+        let Generics { mut lifetimes, mut ty_params, mut where_clause, span } = self.generics\n             .to_generics(cx, self.span, type_ident, generics);\n-        let mut ty_params = ty_params.into_vec();\n \n         // Copy the lifetimes\n         lifetimes.extend(generics.lifetimes.iter().cloned());\n@@ -533,7 +532,7 @@ impl<'a> TraitDef<'a> {\n                 bounds.push((*declared_bound).clone());\n             }\n \n-            cx.typaram(self.span, ty_param.ident, vec![], P::from_vec(bounds), None)\n+            cx.typaram(self.span, ty_param.ident, vec![], bounds, None)\n         }));\n \n         // and similarly for where clauses\n@@ -558,8 +557,8 @@ impl<'a> TraitDef<'a> {\n                     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                         id: ast::DUMMY_NODE_ID,\n                         span: self.span,\n-                        path: we.path.clone(),\n-                        ty: we.ty.clone(),\n+                        lhs_ty: we.lhs_ty.clone(),\n+                        rhs_ty: we.rhs_ty.clone(),\n                     })\n                 }\n             }\n@@ -596,7 +595,7 @@ impl<'a> TraitDef<'a> {\n                         span: self.span,\n                         bound_lifetimes: vec![],\n                         bounded_ty: ty,\n-                        bounds: P::from_vec(bounds),\n+                        bounds: bounds,\n                     };\n \n                     let predicate = ast::WherePredicate::BoundPredicate(predicate);\n@@ -607,7 +606,7 @@ impl<'a> TraitDef<'a> {\n \n         let trait_generics = Generics {\n             lifetimes: lifetimes,\n-            ty_params: P::from_vec(ty_params),\n+            ty_params: ty_params,\n             where_clause: where_clause,\n             span: span,\n         };"}, {"sha": "cfd52381538cb6808661071c0363dbf489551410", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -212,7 +212,7 @@ fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>, s\n                -> Generics {\n     Generics {\n         lifetimes: lifetimes,\n-        ty_params: P::from_vec(ty_params),\n+        ty_params: ty_params,\n         where_clause: ast::WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),"}, {"sha": "485a31d96663795a2cbb2eabe73d3ede755fde00", "filename": "src/test/compile-fail/E0172.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0825c96b14f0b5eb59da1c36f70fe410c7c6fce7/src%2Ftest%2Fcompile-fail%2FE0172.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0825c96b14f0b5eb59da1c36f70fe410c7c6fce7/src%2Ftest%2Fcompile-fail%2FE0172.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0172.rs?ref=0825c96b14f0b5eb59da1c36f70fe410c7c6fce7", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn foo(bar: i32+std::fmt::Display) {}\n-    //~^ ERROR E0172\n-    //~| NOTE expected a trait\n-\n-fn main() {\n-}"}, {"sha": "ffc5940c95c98c8bae7412b955d0c06545f08b3d", "filename": "src/test/compile-fail/E0178.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Ftest%2Fcompile-fail%2FE0178.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Ftest%2Fcompile-fail%2FE0178.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0178.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -17,12 +17,15 @@ struct Bar<'a> {\n     x: &'a Foo + 'a,\n     //~^ ERROR E0178\n     //~| NOTE expected a path\n+    //~| ERROR at least one non-builtin trait is required for an object type\n     y: &'a mut Foo + 'a,\n     //~^ ERROR E0178\n     //~| NOTE expected a path\n+    //~| ERROR at least one non-builtin trait is required for an object type\n     z: fn() -> Foo + 'a,\n     //~^ ERROR E0178\n     //~| NOTE expected a path\n+    //~| ERROR at least one non-builtin trait is required for an object type\n }\n \n fn main() {"}, {"sha": "cabe0fd48edf99d0124ef40e19b45060f8ec4cf0", "filename": "src/test/compile-fail/trait-bounds-not-on-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -11,6 +11,6 @@\n \n struct Foo;\n \n-fn foo(_x: Box<Foo + Send>) { } //~ ERROR expected a reference to a trait\n+fn foo(_x: Box<Foo + Send>) { } //~ ERROR expected trait, found struct `Foo`\n \n fn main() { }"}, {"sha": "c009644c5619fe09447ba5067d2934b960ee658e", "filename": "src/test/compile-fail/trait-object-reference-without-parens-suggestion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -13,8 +13,10 @@ fn main() {\n     //~^ ERROR expected a path\n     //~| HELP try adding parentheses\n     //~| SUGGESTION let _: &(Copy + 'static);\n+    //~| ERROR at least one non-builtin trait is required for an object type\n     let _: &'static Copy + 'static;\n     //~^ ERROR expected a path\n     //~| HELP try adding parentheses\n     //~| SUGGESTION let _: &'static (Copy + 'static);\n+    //~| ERROR at least one non-builtin trait is required for an object type\n }"}, {"sha": "651d2b67941cb9ffbdd442d9e035b528948cb0d7", "filename": "src/test/pretty/path-type-bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a167c042abed695a049abf3919ce929765e6cc30/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a167c042abed695a049abf3919ce929765e6cc30/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs?ref=a167c042abed695a049abf3919ce929765e6cc30", "patch": "@@ -16,10 +16,10 @@ trait Tr {\n }\n impl Tr for isize { }\n \n-fn foo<'a>(x: Box<Tr+ Sync + 'a>) -> Box<Tr+ Sync + 'a> { x }\n+fn foo<'a>(x: Box< Tr + Sync + 'a>) -> Box< Tr + Sync + 'a> { x }\n \n fn main() {\n-    let x: Box<Tr+ Sync>;\n+    let x: Box< Tr + Sync>;\n \n-    Box::new(1isize) as Box<Tr+ Sync>;\n+    Box::new(1isize) as Box< Tr + Sync>;\n }"}]}