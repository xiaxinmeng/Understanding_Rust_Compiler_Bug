{"sha": "f11b23608724b24ffe01f03552fd558be2e80d24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMWIyMzYwODcyNGIyNGZmZTAxZjAzNTUyZmQ1NThiZTJlODBkMjQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-05-08T09:34:35Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-05-14T12:04:55Z"}, "message": "mem::discriminant trumps manual discriminant hashing", "tree": {"sha": "8a2f8058b2e686f55212fbbcfe00a3052235e5c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a2f8058b2e686f55212fbbcfe00a3052235e5c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f11b23608724b24ffe01f03552fd558be2e80d24", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEdgbJzPSa+gJi9jP1Acg2tkD/37EFAlzarucACgkQAcg2tkD/\n37G6VA/9FgseF/7d6Ho06IFRd1MtwLCV9nYdUvcPr0/Ai9MJ882jW25LquGlTrmi\nOHadoLSiCuUWJzZnT1yt6fZtAw3pk+8kcegzgkq84cEF2pGKz3ZUPtI47mqDWFnJ\nHKSoMaGsJqs5jqBLK5BOXo5BekwrEnVU9NEo/7Se8dPhjWHIzq7X44Z2r6vfphUi\n96zVs0jTkbyIYm5WFpwobszgK/xrN1RPESFrPBJ/5z2rkpSBE9+Tup8Le8IwoemU\nCGrYv1LZb1oJSM4PiWpqmbzp4+vAJAcvzZCeGMkdBG+tgIOi7R9Jye0DIaybak7Y\nItjMILFHAsSyE6BRUWsil+YXyTpEMwozZpKpSNm6CD/XaMiFCz4s6rnbyA5X7GXQ\nXg9ar80CpYa29uUYYRojGtbStKY/rwFHsE1EolAI0Tn9LAEBJ1eM4RlvRbkkYeoM\nfn3114DdLYMSKgBwaR3GrAzsvPVGhydYmzNk0kYxm1jXbjNhxRA2SuzN96EY8HMB\nGBdNzGIKjRqSUhxNyl+EFDXEEEc25zHsEr1tPaiwHeFE9+f/snBNIyBbeh0k2cKy\nDgJ/BSwl9KsmzmNgcu6HigKqRImwbO3oLH2otttCOze8G9e+3edLNaaJrMqMdmp/\nUrHTh0U0MbqHHUHtK0fskcOConvHQXQY/G11AL4QZ1UtZEfN/to=\n=KqOQ\n-----END PGP SIGNATURE-----", "payload": "tree 8a2f8058b2e686f55212fbbcfe00a3052235e5c6\nparent bc031d4c744f0a1542ce2706f25b843aba205f8c\nauthor Oliver Scherer <github35764891676564198441@oli-obk.de> 1557308075 +0200\ncommitter flip1995 <hello@philkrones.com> 1557835495 +0200\n\nmem::discriminant trumps manual discriminant hashing\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f11b23608724b24ffe01f03552fd558be2e80d24", "html_url": "https://github.com/rust-lang/rust/commit/f11b23608724b24ffe01f03552fd558be2e80d24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f11b23608724b24ffe01f03552fd558be2e80d24/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc031d4c744f0a1542ce2706f25b843aba205f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc031d4c744f0a1542ce2706f25b843aba205f8c", "html_url": "https://github.com/rust-lang/rust/commit/bc031d4c744f0a1542ce2706f25b843aba205f8c"}], "stats": {"total": 78, "additions": 2, "deletions": 76}, "files": [{"sha": "f3525f6adb8aadc766e0c87d7149c60d5ad8726c", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 76, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f11b23608724b24ffe01f03552fd558be2e80d24/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11b23608724b24ffe01f03552fd558be2e80d24/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=f11b23608724b24ffe01f03552fd558be2e80d24", "patch": "@@ -403,51 +403,35 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n         match e.node {\n             ExprKind::AddrOf(m, ref e) => {\n-                let c: fn(_, _) -> _ = ExprKind::AddrOf;\n-                c.hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n             ExprKind::Continue(i) => {\n-                let c: fn(_) -> _ = ExprKind::Continue;\n-                c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n             ExprKind::Yield(ref e) => {\n-                let c: fn(_) -> _ = ExprKind::Yield;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n             ExprKind::Assign(ref l, ref r) => {\n-                let c: fn(_, _) -> _ = ExprKind::Assign;\n-                c.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n             ExprKind::AssignOp(ref o, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::AssignOp;\n-                c.hash(&mut self.s);\n                 o.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n             ExprKind::Block(ref b, _) => {\n-                let c: fn(_, _) -> _ = ExprKind::Block;\n-                c.hash(&mut self.s);\n                 self.hash_block(b);\n             },\n             ExprKind::Binary(op, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::Binary;\n-                c.hash(&mut self.s);\n                 op.node.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n             ExprKind::Break(i, ref j) => {\n-                let c: fn(_, _) -> _ = ExprKind::Break;\n-                c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n@@ -456,25 +440,17 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 }\n             },\n             ExprKind::Box(ref e) => {\n-                let c: fn(_) -> _ = ExprKind::Box;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n             ExprKind::Call(ref fun, ref args) => {\n-                let c: fn(_, _) -> _ = ExprKind::Call;\n-                c.hash(&mut self.s);\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n             ExprKind::Cast(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprKind::Cast;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n             ExprKind::Closure(cap, _, eid, _, _) => {\n-                let c: fn(_, _, _, _, _) -> _ = ExprKind::Closure;\n-                c.hash(&mut self.s);\n                 match cap {\n                     CaptureClause::CaptureByValue => 0,\n                     CaptureClause::CaptureByRef => 1,\n@@ -483,37 +459,24 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n             ExprKind::Field(ref e, ref f) => {\n-                let c: fn(_, _) -> _ = ExprKind::Field;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_name(f.name);\n             },\n             ExprKind::Index(ref a, ref i) => {\n-                let c: fn(_, _) -> _ = ExprKind::Index;\n-                c.hash(&mut self.s);\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n             },\n-            ExprKind::InlineAsm(..) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::InlineAsm;\n-                c.hash(&mut self.s);\n-            },\n+            ExprKind::InlineAsm(..) => {},\n             ExprKind::Lit(ref l) => {\n-                let c: fn(_) -> _ = ExprKind::Lit;\n-                c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n             },\n             ExprKind::Loop(ref b, ref i, _) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::Loop;\n-                c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n             ExprKind::Match(ref e, ref arms, ref s) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::Match;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n \n                 for arm in arms {\n@@ -527,36 +490,25 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 s.hash(&mut self.s);\n             },\n             ExprKind::MethodCall(ref path, ref _tys, ref args) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::MethodCall;\n-                c.hash(&mut self.s);\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n             ExprKind::Repeat(ref e, ref l_id) => {\n-                let c: fn(_, _) -> _ = ExprKind::Repeat;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 let full_table = self.tables;\n                 self.tables = self.cx.tcx.body_tables(l_id.body);\n                 self.hash_expr(&self.cx.tcx.hir().body(l_id.body).value);\n                 self.tables = full_table;\n             },\n             ExprKind::Ret(ref e) => {\n-                let c: fn(_) -> _ = ExprKind::Ret;\n-                c.hash(&mut self.s);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n             ExprKind::Path(ref qpath) => {\n-                let c: fn(_) -> _ = ExprKind::Path;\n-                c.hash(&mut self.s);\n                 self.hash_qpath(qpath);\n             },\n             ExprKind::Struct(ref path, ref fields, ref expr) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::Struct;\n-                c.hash(&mut self.s);\n-\n                 self.hash_qpath(path);\n \n                 for f in fields {\n@@ -569,33 +521,20 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 }\n             },\n             ExprKind::Tup(ref tup) => {\n-                let c: fn(_) -> _ = ExprKind::Tup;\n-                c.hash(&mut self.s);\n                 self.hash_exprs(tup);\n             },\n             ExprKind::Type(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprKind::Type;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n             ExprKind::Unary(lop, ref le) => {\n-                let c: fn(_, _) -> _ = ExprKind::Unary;\n-                c.hash(&mut self.s);\n-\n                 lop.hash(&mut self.s);\n                 self.hash_expr(le);\n             },\n             ExprKind::Array(ref v) => {\n-                let c: fn(_) -> _ = ExprKind::Array;\n-                c.hash(&mut self.s);\n-\n                 self.hash_exprs(v);\n             },\n             ExprKind::While(ref cond, ref b, l) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::While;\n-                c.hash(&mut self.s);\n-\n                 self.hash_expr(cond);\n                 self.hash_block(b);\n                 if let Some(l) = l {\n@@ -604,8 +543,6 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             },\n             ExprKind::Err => {},\n             ExprKind::DropTemps(ref e) => {\n-                let c: fn(_) -> _ = ExprKind::DropTemps;\n-                c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n         }\n@@ -643,24 +580,15 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn hash_stmt(&mut self, b: &Stmt) {\n         match b.node {\n             StmtKind::Local(ref local) => {\n-                let c: fn(_) -> _ = StmtKind::Local;\n-                c.hash(&mut self.s);\n                 if let Some(ref init) = local.init {\n                     self.hash_expr(init);\n                 }\n             },\n-            StmtKind::Item(..) => {\n-                let c: fn(_) -> _ = StmtKind::Item;\n-                c.hash(&mut self.s);\n-            },\n+            StmtKind::Item(..) => {},\n             StmtKind::Expr(ref expr) => {\n-                let c: fn(_) -> _ = StmtKind::Expr;\n-                c.hash(&mut self.s);\n                 self.hash_expr(expr);\n             },\n             StmtKind::Semi(ref expr) => {\n-                let c: fn(_) -> _ = StmtKind::Semi;\n-                c.hash(&mut self.s);\n                 self.hash_expr(expr);\n             },\n         }\n@@ -669,8 +597,6 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn hash_guard(&mut self, g: &Guard) {\n         match g {\n             Guard::If(ref expr) => {\n-                let c: fn(_) -> _ = Guard::If;\n-                c.hash(&mut self.s);\n                 self.hash_expr(expr);\n             },\n         }"}]}