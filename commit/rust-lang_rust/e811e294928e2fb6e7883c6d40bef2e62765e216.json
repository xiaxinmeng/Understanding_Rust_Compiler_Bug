{"sha": "e811e294928e2fb6e7883c6d40bef2e62765e216", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MTFlMjk0OTI4ZTJmYjZlNzg4M2M2ZDQwYmVmMmU2Mjc2NWUyMTY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-22T16:29:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-22T16:29:07Z"}, "message": "Rollup merge of #74454 - lcnr:negative-impls, r=nikomatsakis\n\nsmall coherence cleanup\n\nr? @eddyb", "tree": {"sha": "1cd3a5ecc52d418ac0ffdae6475e6b46b0519685", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cd3a5ecc52d418ac0ffdae6475e6b46b0519685"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e811e294928e2fb6e7883c6d40bef2e62765e216", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGGlUCRBK7hj4Ov3rIwAAdHIIAIaguATTxuT4cT49FjT+pGTw\nMa0YeLTsRCm9fmAT9yymYeDBaokuz4w3t/UKANubE2C7EDf+9m1p2phe1i6MkANB\nfJYtluSe3/GHEFUvNHJCicgA3p+QrZjtJ5sv5qOf4Ah1nzqFo8S79MklebCgVcGA\nuh+t2EzK4TD3BON4VBwNL+FiQksaCHL4hp6Vr46HyxQ96x6WKyjDfr1JTqNt5j8Y\nTKCE0MLEQihJrl5lh5LLTbURnWkSLa85MydFtn8laKQv9/krYVLvXEuLV1clh5Y3\n5cbC5P9i6hmJqBd5l4mI9bD1sVyD5/YKq4bn7Ot341ayAiuBlqf2VDm3gG305uo=\n=ooyo\n-----END PGP SIGNATURE-----\n", "payload": "tree 1cd3a5ecc52d418ac0ffdae6475e6b46b0519685\nparent 216ed3c4ab88f666d5a883b66e31b8fdaa48f211\nparent cfcbca6c697895e86a70127b317c24c1750c8f89\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595435347 -0700\ncommitter GitHub <noreply@github.com> 1595435347 -0700\n\nRollup merge of #74454 - lcnr:negative-impls, r=nikomatsakis\n\nsmall coherence cleanup\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e811e294928e2fb6e7883c6d40bef2e62765e216", "html_url": "https://github.com/rust-lang/rust/commit/e811e294928e2fb6e7883c6d40bef2e62765e216", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e811e294928e2fb6e7883c6d40bef2e62765e216/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "url": "https://api.github.com/repos/rust-lang/rust/commits/216ed3c4ab88f666d5a883b66e31b8fdaa48f211", "html_url": "https://github.com/rust-lang/rust/commit/216ed3c4ab88f666d5a883b66e31b8fdaa48f211"}, {"sha": "cfcbca6c697895e86a70127b317c24c1750c8f89", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfcbca6c697895e86a70127b317c24c1750c8f89", "html_url": "https://github.com/rust-lang/rust/commit/cfcbca6c697895e86a70127b317c24c1750c8f89"}], "stats": {"total": 99, "additions": 47, "deletions": 52}, "files": [{"sha": "b06cf4411d053188e80f90188b4ea1c5125a526f", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 47, "deletions": 52, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e811e294928e2fb6e7883c6d40bef2e62765e216/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e811e294928e2fb6e7883c6d40bef2e62765e216/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=e811e294928e2fb6e7883c6d40bef2e62765e216", "patch": "@@ -289,11 +289,11 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n ///     - but (knowing that `Vec<T>` is non-fundamental, and assuming it's\n ///       not local), `Vec<LocalType>` is bad, because `Vec<->` is between\n ///       the local type and the type parameter.\n-/// 3. Every type parameter before the local key parameter is fully known in C.\n-///     - e.g., `impl<T> T: Trait<LocalType>` is bad, because `T` might be\n-///       an unknown type.\n-///     - but `impl<T> LocalType: Trait<T>` is OK, because `LocalType`\n-///       occurs before `T`.\n+/// 3. Before this local type, no generic type parameter of the impl must\n+///    be reachable through fundamental types.\n+///     - e.g. `impl<T> Trait<LocalType> for Vec<T>` is fine, as `Vec` is not fundamental.\n+///     - while `impl<T> Trait<LocalType for Box<T>` results in an error, as `T` is\n+///       reachable through the fundamental type `Box`.\n /// 4. Every type in the local key parameter not known in C, going\n ///    through the parameter's type tree, must appear only as a subtree of\n ///    a type local to C, with only fundamental types between the type\n@@ -387,9 +387,9 @@ fn orphan_check_trait_ref<'tcx>(\n         ty: Ty<'tcx>,\n         in_crate: InCrate,\n     ) -> Vec<Ty<'tcx>> {\n-        // FIXME(eddyb) figure out if this is redundant with `ty_is_non_local`,\n-        // or maybe if this should be calling `ty_is_non_local_constructor`.\n-        if ty_is_non_local(tcx, ty, in_crate).is_some() {\n+        // FIXME: this is currently somewhat overly complicated,\n+        // but fixing this requires a more complicated refactor.\n+        if !contained_non_local_types(tcx, ty, in_crate).is_empty() {\n             if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n                 return inner_tys\n                     .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n@@ -408,8 +408,8 @@ fn orphan_check_trait_ref<'tcx>(\n         .enumerate()\n     {\n         debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n-        if non_local_tys.is_none() {\n+        let non_local_tys = contained_non_local_types(tcx, input_ty, in_crate);\n+        if non_local_tys.is_empty() {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n             return Ok(());\n         } else if let ty::Param(_) = input_ty.kind {\n@@ -418,37 +418,45 @@ fn orphan_check_trait_ref<'tcx>(\n                 .substs\n                 .types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .find(|ty| ty_is_non_local_constructor(ty, in_crate).is_none());\n+                .find(|ty| ty_is_local_constructor(ty, in_crate));\n \n             debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n \n             return Err(OrphanCheckErr::UncoveredTy(input_ty, local_type));\n         }\n-        if let Some(non_local_tys) = non_local_tys {\n-            for input_ty in non_local_tys {\n-                non_local_spans.push((input_ty, i == 0));\n-            }\n+\n+        for input_ty in non_local_tys {\n+            non_local_spans.push((input_ty, i == 0));\n         }\n     }\n     // If we exit above loop, never found a local type.\n     debug!(\"orphan_check_trait_ref: no local type\");\n     Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-fn ty_is_non_local(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, in_crate: InCrate) -> Option<Vec<Ty<'tcx>>> {\n-    match ty_is_non_local_constructor(ty, in_crate) {\n-        Some(ty) => {\n-            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n-                let tys: Vec<_> = inner_tys\n-                    .filter_map(|ty| ty_is_non_local(tcx, ty, in_crate))\n-                    .flatten()\n-                    .collect();\n-                if tys.is_empty() { None } else { Some(tys) }\n-            } else {\n-                Some(vec![ty])\n+/// Returns a list of relevant non-local types for `ty`.\n+///\n+/// This is just `ty` itself unless `ty` is `#[fundamental]`,\n+/// in which case we recursively look into this type.\n+///\n+/// If `ty` is local itself, this method returns an empty `Vec`.\n+///\n+/// # Examples\n+///\n+/// - `u32` is not local, so this returns `[u32]`.\n+/// - for `Foo<u32>`, where `Foo` is a local type, this returns `[]`.\n+/// - `&mut u32` returns `[u32]`, as `&mut` is a fundamental type, similar to `Box`.\n+/// - `Box<Foo<u32>>` returns `[]`, as `Box` is a fundamental type and `Foo` is local.\n+fn contained_non_local_types(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n+    if ty_is_local_constructor(ty, in_crate) {\n+        Vec::new()\n+    } else {\n+        match fundamental_ty_inner_tys(tcx, ty) {\n+            Some(inner_tys) => {\n+                inner_tys.flat_map(|ty| contained_non_local_types(tcx, ty, in_crate)).collect()\n             }\n+            None => vec![ty],\n         }\n-        None => None,\n     }\n }\n \n@@ -493,9 +501,8 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n     }\n }\n \n-// FIXME(eddyb) this can just return `bool` as it always returns `Some(ty)` or `None`.\n-fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>> {\n-    debug!(\"ty_is_non_local_constructor({:?})\", ty);\n+fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n+    debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.kind {\n         ty::Bool\n@@ -513,29 +520,17 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n         | ty::Never\n         | ty::Tuple(..)\n         | ty::Param(..)\n-        | ty::Projection(..) => Some(ty),\n+        | ty::Projection(..) => false,\n \n         ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) => match in_crate {\n-            InCrate::Local => Some(ty),\n+            InCrate::Local => false,\n             // The inference variable might be unified with a local\n             // type in that remote crate.\n-            InCrate::Remote => None,\n+            InCrate::Remote => true,\n         },\n \n-        ty::Adt(def, _) => {\n-            if def_id_is_local(def.did, in_crate) {\n-                None\n-            } else {\n-                Some(ty)\n-            }\n-        }\n-        ty::Foreign(did) => {\n-            if def_id_is_local(did, in_crate) {\n-                None\n-            } else {\n-                Some(ty)\n-            }\n-        }\n+        ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n+        ty::Foreign(did) => def_id_is_local(did, in_crate),\n         ty::Opaque(..) => {\n             // This merits some explanation.\n             // Normally, opaque types are not involed when performing\n@@ -553,7 +548,7 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n             // the underlying type *within the same crate*. When an\n             // opaque type is used from outside the module\n             // where it is declared, it should be impossible to observe\n-            // anyything about it other than the traits that it implements.\n+            // anything about it other than the traits that it implements.\n             //\n             // The alternative would be to look at the underlying type\n             // to determine whether or not the opaque type itself should\n@@ -562,18 +557,18 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n             // to a remote type. This would violate the rule that opaque\n             // types should be completely opaque apart from the traits\n             // that they implement, so we don't use this behavior.\n-            Some(ty)\n+            false\n         }\n \n         ty::Dynamic(ref tt, ..) => {\n             if let Some(principal) = tt.principal() {\n-                if def_id_is_local(principal.def_id(), in_crate) { None } else { Some(ty) }\n+                def_id_is_local(principal.def_id(), in_crate)\n             } else {\n-                Some(ty)\n+                false\n             }\n         }\n \n-        ty::Error(_) => None,\n+        ty::Error(_) => true,\n \n         ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)"}]}