{"sha": "aab48c963a43b28f88e428ecfe9e31d12530c47c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYjQ4Yzk2M2E0M2IyOGY4OGU0MjhlY2ZlOWUzMWQxMjUzMGM0N2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-28T20:47:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:19Z"}, "message": "opaque_types/mod.rs: rustfmt", "tree": {"sha": "0102e0fa08aa98b852558d56c486bc0cfef5503d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0102e0fa08aa98b852558d56c486bc0cfef5503d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aab48c963a43b28f88e428ecfe9e31d12530c47c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aab48c963a43b28f88e428ecfe9e31d12530c47c", "html_url": "https://github.com/rust-lang/rust/commit/aab48c963a43b28f88e428ecfe9e31d12530c47c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aab48c963a43b28f88e428ecfe9e31d12530c47c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "html_url": "https://github.com/rust-lang/rust/commit/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1"}], "stats": {"total": 141, "additions": 51, "deletions": 90}, "files": [{"sha": "30084668f9aadf8cc959f89635f40aa8f9a51013", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 51, "deletions": 90, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/aab48c963a43b28f88e428ecfe9e31d12530c47c/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab48c963a43b28f88e428ecfe9e31d12530c47c/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=aab48c963a43b28f88e428ecfe9e31d12530c47c", "patch": "@@ -1,15 +1,15 @@\n use rustc_data_structures::fx::FxHashMap;\n use syntax_pos::Span;\n \n-use crate::hir::def_id::DefId;\n use crate::hir;\n+use crate::hir::def_id::DefId;\n use crate::hir::Node;\n-use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n+use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::{self, PredicateObligation};\n-use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n+use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n+use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use crate::util::nodemap::DefIdMap;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n@@ -105,9 +105,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n-        debug!(\"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n-                param_env={:?})\",\n-               value, parent_def_id, body_id, param_env,\n+        debug!(\n+            \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n+             param_env={:?})\",\n+            value, parent_def_id, body_id, param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n@@ -118,10 +119,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             obligations: vec![],\n         };\n         let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk {\n-            value: (value, instantiator.opaque_types),\n-            obligations: instantiator.obligations,\n-        }\n+        InferOk { value: (value, instantiator.opaque_types), obligations: instantiator.obligations }\n     }\n \n     /// Given the map `opaque_types` containing the existential `impl\n@@ -297,18 +295,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // If there are required region bounds, we can use them.\n         if opaque_defn.has_required_region_bounds {\n             let predicates_of = tcx.predicates_of(def_id);\n-            debug!(\n-                \"constrain_opaque_type: predicates: {:#?}\",\n-                predicates_of,\n-            );\n+            debug!(\"constrain_opaque_type: predicates: {:#?}\", predicates_of,);\n             let bounds = predicates_of.instantiate(tcx, opaque_defn.substs);\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n             let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n \n-            let required_region_bounds = tcx.required_region_bounds(\n-                opaque_type,\n-                bounds.predicates,\n-            );\n+            let required_region_bounds = tcx.required_region_bounds(opaque_type, bounds.predicates);\n             debug_assert!(!required_region_bounds.is_empty());\n \n             for region in required_region_bounds {\n@@ -332,7 +324,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         for param in &abstract_type_generics.params {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {}\n-                _ => continue\n+                _ => continue,\n             }\n             // Get the value supplied for this region from the substs.\n             let subst_arg = opaque_defn.substs.region_at(param.index as usize);\n@@ -358,9 +350,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             hir::ExistTyOrigin::AsyncFn => \"async fn\",\n                         };\n                         let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n-                        let mut err = self.tcx\n-                            .sess\n-                            .struct_span_err(span, &msg);\n+                        let mut err = self.tcx.sess.struct_span_err(span, &msg);\n \n                         let lr_name = lr.to_string();\n                         let subst_arg_name = subst_arg.to_string();\n@@ -370,19 +360,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             _ => {\n                                 label_owned = format!(\n                                     \"neither `{}` nor `{}` outlives the other\",\n-                                    lr_name,\n-                                    subst_arg_name,\n+                                    lr_name, subst_arg_name,\n                                 );\n                                 &label_owned\n                             }\n                         };\n                         err.span_label(span, label);\n \n                         if let hir::ExistTyOrigin::AsyncFn = opaque_defn.origin {\n-                            err.note(\"multiple unrelated lifetimes are not allowed in \\\n-                                     `async fn`.\");\n-                            err.note(\"if you're using argument-position elided lifetimes, consider \\\n-                                switching to a single named lifetime.\");\n+                            err.note(\n+                                \"multiple unrelated lifetimes are not allowed in \\\n+                                 `async fn`.\",\n+                            );\n+                            err.note(\n+                                \"if you're using argument-position elided lifetimes, consider \\\n+                                 switching to a single named lifetime.\",\n+                            );\n                         }\n                         err.emit();\n \n@@ -396,11 +389,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let least_region = least_region.unwrap_or(tcx.lifetimes.re_static);\n         debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n-        concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n-            infcx: self,\n-            least_region,\n-            span,\n-        });\n+        concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor { infcx: self, least_region, span });\n     }\n \n     /// Given the fully resolved, instantiated type for an opaque\n@@ -456,18 +445,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty =\n-            instantiated_ty.fold_with(&mut ReverseMapper::new(\n-                self.tcx,\n-                self.is_tainted_by_errors(),\n-                def_id,\n-                map,\n-                instantiated_ty,\n-            ));\n-        debug!(\n-            \"infer_opaque_definition_from_instantiation: definition_ty={:?}\",\n-            definition_ty\n-        );\n+        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n+            self.tcx,\n+            self.is_tainted_by_errors(),\n+            def_id,\n+            map,\n+            instantiated_ty,\n+        ));\n+        debug!(\"infer_opaque_definition_from_instantiation: definition_ty={:?}\", definition_ty);\n \n         definition_ty\n     }\n@@ -642,14 +627,14 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             &mut err,\n                             &format!(\"hidden type `{}` captures \", hidden_ty),\n                             r,\n-                            \"\"\n+                            \"\",\n                         );\n \n                         err.emit();\n                     }\n                 }\n                 self.tcx.lifetimes.re_empty\n-            },\n+            }\n         }\n     }\n \n@@ -681,34 +666,32 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 // during codegen.\n \n                 let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n-                    |(index, &kind)| {\n+                let substs =\n+                    self.tcx.mk_substs(substs.substs.iter().enumerate().map(|(index, &kind)| {\n                         if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n                         } else {\n                             // ...but not elsewhere.\n                             self.fold_kind_normally(kind)\n                         }\n-                    },\n-                ));\n+                    }));\n \n                 self.tcx.mk_closure(def_id, ty::ClosureSubsts { substs })\n             }\n \n             ty::Generator(def_id, substs, movability) => {\n                 let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n-                    |(index, &kind)| {\n+                let substs =\n+                    self.tcx.mk_substs(substs.substs.iter().enumerate().map(|(index, &kind)| {\n                         if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n                         } else {\n                             // ...but not elsewhere.\n                             self.fold_kind_normally(kind)\n                         }\n-                    },\n-                ));\n+                    }));\n \n                 self.tcx.mk_generator(def_id, ty::GeneratorSubsts { substs }, movability)\n             }\n@@ -773,12 +756,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir()\n-                                                .local_def_id_from_hir_id(opaque_parent_hir_id)\n+                            parent_def_id\n+                                == tcx.hir().local_def_id_from_hir_id(opaque_parent_hir_id)\n                         };\n-                        let (in_definition_scope, origin) =\n-                            match tcx.hir().find(opaque_hir_id)\n-                        {\n+                        let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // Anonymous `impl Trait`\n                                 hir::ItemKind::Existential(hir::ExistTy {\n@@ -847,47 +828,30 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n \n-        debug!(\n-            \"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\",\n-            def_id, substs\n-        );\n+        debug!(\"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\", def_id, substs);\n \n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n             return opaque_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span,\n-        });\n+        let ty_var = infcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n \n         let predicates_of = tcx.predicates_of(def_id);\n-        debug!(\n-            \"instantiate_opaque_types: predicates={:#?}\",\n-            predicates_of,\n-        );\n+        debug!(\"instantiate_opaque_types: predicates={:#?}\", predicates_of,);\n         let bounds = predicates_of.instantiate(tcx, substs);\n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n         let required_region_bounds = tcx.required_region_bounds(ty, bounds.predicates.clone());\n-        debug!(\n-            \"instantiate_opaque_types: required_region_bounds={:?}\",\n-            required_region_bounds\n-        );\n+        debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n         // (e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n         // defined by a function like `fn foo<T: Bound>() -> Foo<T>`).\n-        debug!(\n-            \"instantiate_opaque_types: param_env={:#?}\",\n-            self.param_env,\n-        );\n-        debug!(\n-            \"instantiate_opaque_types: generics={:#?}\",\n-            tcx.generics_of(def_id),\n-        );\n+        debug!(\"instantiate_opaque_types: param_env={:#?}\", self.param_env,);\n+        debug!(\"instantiate_opaque_types: generics={:#?}\", tcx.generics_of(def_id),);\n \n         self.opaque_types.insert(\n             def_id,\n@@ -911,8 +875,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n             // Require that the predicate holds for the concrete type.\n             debug!(\"instantiate_opaque_types: predicate={:?}\", predicate);\n-            self.obligations\n-                .push(traits::Obligation::new(cause, self.param_env, predicate));\n+            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n \n         ty_var\n@@ -950,9 +913,7 @@ pub fn may_define_existential_type(\n     );\n \n     // Named existential types can be defined by any siblings or children of siblings.\n-    let scope = tcx.hir()\n-        .get_defining_scope(opaque_hir_id)\n-        .expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);"}]}