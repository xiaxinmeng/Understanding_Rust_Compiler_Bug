{"sha": "347deac455c5365e6e74de3ca44b83ed77de41f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0N2RlYWM0NTVjNTM2NWU2ZTc0ZGUzY2E0NGI4M2VkNzdkZTQxZjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-30T03:32:46Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-30T03:32:46Z"}, "message": "syntax: reorder param  parsing to make more sense.", "tree": {"sha": "8ddfd783dcf489729b4359beef474c8bfed84bfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ddfd783dcf489729b4359beef474c8bfed84bfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/347deac455c5365e6e74de3ca44b83ed77de41f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/347deac455c5365e6e74de3ca44b83ed77de41f3", "html_url": "https://github.com/rust-lang/rust/commit/347deac455c5365e6e74de3ca44b83ed77de41f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/347deac455c5365e6e74de3ca44b83ed77de41f3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0492302dbdef106956545b3faaa4b9ee54d99526", "url": "https://api.github.com/repos/rust-lang/rust/commits/0492302dbdef106956545b3faaa4b9ee54d99526", "html_url": "https://github.com/rust-lang/rust/commit/0492302dbdef106956545b3faaa4b9ee54d99526"}], "stats": {"total": 306, "additions": 153, "deletions": 153}, "files": [{"sha": "cbeaab5a4d3281cfccb8a3d7019dfe0a8fd583ed", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 153, "deletions": 153, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/347deac455c5365e6e74de3ca44b83ed77de41f3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347deac455c5365e6e74de3ca44b83ed77de41f3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=347deac455c5365e6e74de3ca44b83ed77de41f3", "patch": "@@ -954,106 +954,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_named_param(&self) -> bool {\n-        let offset = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n-                _ => 0,\n-            }\n-            token::BinOp(token::And) | token::AndAnd => 1,\n-            _ if self.token.is_keyword(kw::Mut) => 1,\n-            _ => 0,\n-        };\n-\n-        self.look_ahead(offset, |t| t.is_ident()) &&\n-        self.look_ahead(offset + 1, |t| t == &token::Colon)\n-    }\n-\n-    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n-    /// error.\n-    /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(\n-        &mut self,\n-        is_self_allowed: bool,\n-        is_trait_item: bool,\n-        allow_c_variadic: bool,\n-        is_name_required: impl Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, Param> {\n-        let lo = self.token.span;\n-        let attrs = self.parse_outer_attributes()?;\n-\n-        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n-        if let Some(mut param) = self.parse_self_param()? {\n-            param.attrs = attrs.into();\n-            return if is_self_allowed {\n-                Ok(param)\n-            } else {\n-                self.recover_bad_self_param(param, is_trait_item)\n-            };\n-        }\n-\n-        let is_name_required = is_name_required(&self.token);\n-        let (pat, ty) = if is_name_required || self.is_named_param() {\n-            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n-\n-            let pat = self.parse_fn_param_pat()?;\n-            if let Err(mut err) = self.expect(&token::Colon) {\n-                if let Some(ident) = self.parameter_without_type(\n-                    &mut err,\n-                    pat,\n-                    is_name_required,\n-                    is_trait_item,\n-                ) {\n-                    err.emit();\n-                    return Ok(dummy_arg(ident));\n-                } else {\n-                    return Err(err);\n-                }\n-            }\n-\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n-        } else {\n-            debug!(\"parse_param_general ident_to_pat\");\n-            let parser_snapshot_before_ty = self.clone();\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n-            if ty.is_ok() && self.token != token::Comma &&\n-               self.token != token::CloseDelim(token::Paren) {\n-                // This wasn't actually a type, but a pattern looking like a type,\n-                // so we are going to rollback and re-parse for recovery.\n-                ty = self.unexpected();\n-            }\n-            match ty {\n-                Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_span);\n-                    let bm = BindingMode::ByValue(Mutability::Immutable);\n-                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n-                    (pat, ty)\n-                }\n-                // If this is a C-variadic argument and we hit an error, return the error.\n-                Err(err) if self.token == token::DotDotDot => return Err(err),\n-                // Recover from attempting to parse the argument as a type without pattern.\n-                Err(mut err) => {\n-                    err.cancel();\n-                    mem::replace(self, parser_snapshot_before_ty);\n-                    self.recover_arg_parse()?\n-                }\n-            }\n-        };\n-\n-        let span = lo.to(self.token.span);\n-\n-        Ok(Param {\n-            attrs: attrs.into(),\n-            id: ast::DUMMY_NODE_ID,\n-            is_placeholder: false,\n-            pat,\n-            span,\n-            ty,\n-        })\n-    }\n-\n     /// Parses mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(kw::Mut) {\n@@ -1267,49 +1167,112 @@ impl<'a> Parser<'a> {\n         Ok(params)\n     }\n \n-    fn is_isolated_self(&self, n: usize) -> bool {\n-        self.is_keyword_ahead(n, &[kw::SelfLower])\n-        && self.look_ahead(n + 1, |t| t != &token::ModSep)\n-    }\n+    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n+    fn parse_fn_decl_with_self(\n+        &mut self,\n+        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, P<FnDecl>> {\n+        // Parse the arguments, starting out with `self` being allowed...\n+        let mut is_self_allowed = true;\n+        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n+            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n+            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n+            is_self_allowed = false;\n+            res\n+        })?;\n \n-    fn is_isolated_mut_self(&self, n: usize) -> bool {\n-        self.is_keyword_ahead(n, &[kw::Mut])\n-        && self.is_isolated_self(n + 1)\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut inputs);\n+\n+        Ok(P(FnDecl {\n+            inputs,\n+            output: self.parse_ret_ty(true)?,\n+        }))\n     }\n \n-    fn expect_self_ident(&mut self) -> Ident {\n-        match self.token.kind {\n-            // Preserve hygienic context.\n-            token::Ident(name, _) => {\n-                let span = self.token.span;\n-                self.bump();\n-                Ident::new(name, span)\n-            }\n-            _ => unreachable!(),\n+    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n+    /// error.\n+    /// This version of parse param doesn't necessarily require identifier names.\n+    fn parse_param_general(\n+        &mut self,\n+        is_self_allowed: bool,\n+        is_trait_item: bool,\n+        allow_c_variadic: bool,\n+        is_name_required: impl Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, Param> {\n+        let lo = self.token.span;\n+        let attrs = self.parse_outer_attributes()?;\n+\n+        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n+        if let Some(mut param) = self.parse_self_param()? {\n+            param.attrs = attrs.into();\n+            return if is_self_allowed {\n+                Ok(param)\n+            } else {\n+                self.recover_bad_self_param(param, is_trait_item)\n+            };\n         }\n-    }\n \n-    /// Recover for the grammar `*self`, `*const self`, and `*mut self`.\n-    fn recover_self_ptr(&mut self) -> PResult<'a, (ast::SelfKind, Ident, Span)> {\n-        let msg = \"cannot pass `self` by raw pointer\";\n-        let span = self.token.span;\n-        self.struct_span_err(span, msg)\n-            .span_label(span, msg)\n-            .emit();\n+        let is_name_required = is_name_required(&self.token);\n+        let (pat, ty) = if is_name_required || self.is_named_param() {\n+            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n \n-        Ok((SelfKind::Value(Mutability::Immutable), self.expect_self_ident(), self.prev_span))\n-    }\n+            let pat = self.parse_fn_param_pat()?;\n+            if let Err(mut err) = self.expect(&token::Colon) {\n+                if let Some(ident) = self.parameter_without_type(\n+                    &mut err,\n+                    pat,\n+                    is_name_required,\n+                    is_trait_item,\n+                ) {\n+                    err.emit();\n+                    return Ok(dummy_arg(ident));\n+                } else {\n+                    return Err(err);\n+                }\n+            }\n \n-    /// Parse `self` or `self: TYPE`. We already know the current token is `self`.\n-    fn parse_self_possibly_typed(&mut self, m: Mutability) -> PResult<'a, (SelfKind, Ident, Span)> {\n-        let eself_ident = self.expect_self_ident();\n-        let eself_hi = self.prev_span;\n-        let eself = if self.eat(&token::Colon) {\n-            SelfKind::Explicit(self.parse_ty()?, m)\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n         } else {\n-            SelfKind::Value(m)\n+            debug!(\"parse_param_general ident_to_pat\");\n+            let parser_snapshot_before_ty = self.clone();\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n+            if ty.is_ok() && self.token != token::Comma &&\n+               self.token != token::CloseDelim(token::Paren) {\n+                // This wasn't actually a type, but a pattern looking like a type,\n+                // so we are going to rollback and re-parse for recovery.\n+                ty = self.unexpected();\n+            }\n+            match ty {\n+                Ok(ty) => {\n+                    let ident = Ident::new(kw::Invalid, self.prev_span);\n+                    let bm = BindingMode::ByValue(Mutability::Immutable);\n+                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n+                    (pat, ty)\n+                }\n+                // If this is a C-variadic argument and we hit an error, return the error.\n+                Err(err) if self.token == token::DotDotDot => return Err(err),\n+                // Recover from attempting to parse the argument as a type without pattern.\n+                Err(mut err) => {\n+                    err.cancel();\n+                    mem::replace(self, parser_snapshot_before_ty);\n+                    self.recover_arg_parse()?\n+                }\n+            }\n         };\n-        Ok((eself, eself_ident, eself_hi))\n+\n+        let span = lo.to(self.token.span);\n+\n+        Ok(Param {\n+            attrs: attrs.into(),\n+            id: ast::DUMMY_NODE_ID,\n+            is_placeholder: false,\n+            pat,\n+            span,\n+            ty,\n+        })\n     }\n \n     /// Returns the parsed optional self parameter and whether a self shortcut was used.\n@@ -1378,27 +1341,64 @@ impl<'a> Parser<'a> {\n         Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n     }\n \n-    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self(\n-        &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, P<FnDecl>> {\n-        // Parse the arguments, starting out with `self` being allowed...\n-        let mut is_self_allowed = true;\n-        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n-            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n-            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n-            is_self_allowed = false;\n-            res\n-        })?;\n+    fn is_named_param(&self) -> bool {\n+        let offset = match self.token.kind {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n+                _ => 0,\n+            }\n+            token::BinOp(token::And) | token::AndAnd => 1,\n+            _ if self.token.is_keyword(kw::Mut) => 1,\n+            _ => 0,\n+        };\n \n-        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_params_names(&mut inputs);\n+        self.look_ahead(offset, |t| t.is_ident()) &&\n+        self.look_ahead(offset + 1, |t| t == &token::Colon)\n+    }\n \n-        Ok(P(FnDecl {\n-            inputs,\n-            output: self.parse_ret_ty(true)?,\n-        }))\n+    fn is_isolated_self(&self, n: usize) -> bool {\n+        self.is_keyword_ahead(n, &[kw::SelfLower])\n+        && self.look_ahead(n + 1, |t| t != &token::ModSep)\n+    }\n+\n+    fn is_isolated_mut_self(&self, n: usize) -> bool {\n+        self.is_keyword_ahead(n, &[kw::Mut])\n+        && self.is_isolated_self(n + 1)\n+    }\n+\n+    fn expect_self_ident(&mut self) -> Ident {\n+        match self.token.kind {\n+            // Preserve hygienic context.\n+            token::Ident(name, _) => {\n+                let span = self.token.span;\n+                self.bump();\n+                Ident::new(name, span)\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    /// Recover for the grammar `*self`, `*const self`, and `*mut self`.\n+    fn recover_self_ptr(&mut self) -> PResult<'a, (ast::SelfKind, Ident, Span)> {\n+        let msg = \"cannot pass `self` by raw pointer\";\n+        let span = self.token.span;\n+        self.struct_span_err(span, msg)\n+            .span_label(span, msg)\n+            .emit();\n+\n+        Ok((SelfKind::Value(Mutability::Immutable), self.expect_self_ident(), self.prev_span))\n+    }\n+\n+    /// Parse `self` or `self: TYPE`. We already know the current token is `self`.\n+    fn parse_self_possibly_typed(&mut self, m: Mutability) -> PResult<'a, (SelfKind, Ident, Span)> {\n+        let eself_ident = self.expect_self_ident();\n+        let eself_hi = self.prev_span;\n+        let eself = if self.eat(&token::Colon) {\n+            SelfKind::Explicit(self.parse_ty()?, m)\n+        } else {\n+            SelfKind::Value(m)\n+        };\n+        Ok((eself, eself_ident, eself_hi))\n     }\n \n     fn is_crate_vis(&self) -> bool {"}]}