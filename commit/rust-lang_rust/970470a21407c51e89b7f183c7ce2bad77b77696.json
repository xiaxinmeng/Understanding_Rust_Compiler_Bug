{"sha": "970470a21407c51e89b7f183c7ce2bad77b77696", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MDQ3MGEyMTQwN2M1MWU4OWI3ZjE4M2M3Y2UyYmFkNzdiNzc2OTY=", "commit": {"author": {"name": "Christoph Schmidler", "email": "c.schmidler@gmail.com", "date": "2019-12-09T15:50:22Z"}, "committer": {"name": "Christoph Schmidler", "email": "c.schmidler@gmail.com", "date": "2019-12-09T15:50:22Z"}, "message": "Merge branch 'master' of github.com:rust-lang/rust", "tree": {"sha": "ed56abf85c9d0c6a023326c2ff108f2e93252942", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed56abf85c9d0c6a023326c2ff108f2e93252942"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/970470a21407c51e89b7f183c7ce2bad77b77696", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/970470a21407c51e89b7f183c7ce2bad77b77696", "html_url": "https://github.com/rust-lang/rust/commit/970470a21407c51e89b7f183c7ce2bad77b77696", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/970470a21407c51e89b7f183c7ce2bad77b77696/comments", "author": {"login": "TheSamsa", "id": 13667299, "node_id": "MDQ6VXNlcjEzNjY3Mjk5", "avatar_url": "https://avatars.githubusercontent.com/u/13667299?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheSamsa", "html_url": "https://github.com/TheSamsa", "followers_url": "https://api.github.com/users/TheSamsa/followers", "following_url": "https://api.github.com/users/TheSamsa/following{/other_user}", "gists_url": "https://api.github.com/users/TheSamsa/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheSamsa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheSamsa/subscriptions", "organizations_url": "https://api.github.com/users/TheSamsa/orgs", "repos_url": "https://api.github.com/users/TheSamsa/repos", "events_url": "https://api.github.com/users/TheSamsa/events{/privacy}", "received_events_url": "https://api.github.com/users/TheSamsa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TheSamsa", "id": 13667299, "node_id": "MDQ6VXNlcjEzNjY3Mjk5", "avatar_url": "https://avatars.githubusercontent.com/u/13667299?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheSamsa", "html_url": "https://github.com/TheSamsa", "followers_url": "https://api.github.com/users/TheSamsa/followers", "following_url": "https://api.github.com/users/TheSamsa/following{/other_user}", "gists_url": "https://api.github.com/users/TheSamsa/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheSamsa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheSamsa/subscriptions", "organizations_url": "https://api.github.com/users/TheSamsa/orgs", "repos_url": "https://api.github.com/users/TheSamsa/repos", "events_url": "https://api.github.com/users/TheSamsa/events{/privacy}", "received_events_url": "https://api.github.com/users/TheSamsa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9441ad687cd51d4400aab48a1d0a630c5b95738", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9441ad687cd51d4400aab48a1d0a630c5b95738", "html_url": "https://github.com/rust-lang/rust/commit/f9441ad687cd51d4400aab48a1d0a630c5b95738"}, {"sha": "3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "html_url": "https://github.com/rust-lang/rust/commit/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4"}], "stats": {"total": 707, "additions": 660, "deletions": 47}, "files": [{"sha": "113b7e7654e94a8ecc9cb989669c4c8cc97b2a7e", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -2577,9 +2577,9 @@ checksum = \"676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c\"\n \n [[package]]\n name = \"polonius-engine\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"50fa9dbfd0d3d60594da338cfe6f94028433eecae4b11b7e83fd99759227bbfe\"\n+checksum = \"1e478d7c38eb785c6416cbe58df12aa55d7aefa3759b6d3e044b2ed03f423cec\"\n dependencies = [\n  \"datafrog\",\n  \"log\","}, {"sha": "a4536bb6c41f09a3b2617c2ebc628f87dc5004ae", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -20,7 +20,7 @@ scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc-rayon = \"0.3.0\"\n rustc-rayon-core = \"0.3.0\"\n-polonius-engine  = \"0.10.0\"\n+polonius-engine = \"0.11.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "bbf6999b983754c85f68bfd8a7f0bd7b9dd68766", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -373,6 +373,14 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         }\n         matrix\n     }\n+\n+    /// Lists all the base edges in the graph: the initial _non-transitive_ set of element\n+    /// relations, which will be later used as the basis for the transitive closure computation.\n+    pub fn base_edges(&self) -> impl Iterator<Item=(&T, &T)> {\n+        self.edges\n+            .iter()\n+            .map(move |edge| (&self.elements[edge.source.0], &self.elements[edge.target.0]))\n+    }\n }\n \n /// Pare down is used as a step in the LUB computation. It edits the"}, {"sha": "7e3bd98176e6a3479124a4735e36b34842bf3405", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -16,7 +16,7 @@ dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n itertools = \"0.8\"\n log = \"0.4\"\n log_settings = \"0.1.1\"\n-polonius-engine  = \"0.10.0\"\n+polonius-engine = \"0.11.0\"\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "a0f126fb2cb30507f0eb40f8d403ca2d555ed1ab", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -240,15 +240,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let tcx = self.infcx.tcx;\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let param = generics.type_param(&param_ty, tcx);\n-                    let generics = tcx.hir().get_generics(self.mir_def_id).unwrap();\n-                    suggest_constraining_type_param(\n-                        generics,\n-                        &mut err,\n-                        &param.name.as_str(),\n-                        \"Copy\",\n-                        tcx.sess.source_map(),\n-                        span,\n-                    );\n+                    if let Some(generics) = tcx.hir().get_generics(self.mir_def_id) {\n+                        suggest_constraining_type_param(\n+                            generics,\n+                            &mut err,\n+                            &param.name.as_str(),\n+                            \"Copy\",\n+                            tcx.sess.source_map(),\n+                            span,\n+                        );\n+                    }\n                 }\n                 let span = if let Some(local) = place.as_local() {\n                     let decl = &self.body.local_decls[local];"}, {"sha": "57c544fda0c5467f30099bf523dc75e76aebcdac", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -3,16 +3,15 @@\n //! FIXME: this might be better as a \"generic\" fixed-point combinator,\n //! but is not as ugly as it is right now.\n \n-use rustc::mir::{BasicBlock, Local, Location};\n-use rustc::ty::RegionVid;\n+use rustc::mir::{BasicBlock, Location};\n use rustc_index::bit_set::BitIter;\n \n use crate::borrow_check::location::LocationIndex;\n \n-use polonius_engine::Output;\n+use crate::borrow_check::nll::PoloniusOutput;\n \n use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::{HasMoveData, MovePathIndex};\n+use crate::dataflow::move_paths::HasMoveData;\n use crate::dataflow::Borrows;\n use crate::dataflow::EverInitializedPlaces;\n use crate::dataflow::MaybeUninitializedPlaces;\n@@ -21,8 +20,6 @@ use either::Either;\n use std::fmt;\n use std::rc::Rc;\n \n-crate type PoloniusOutput = Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n-\n crate struct Flows<'b, 'tcx> {\n     borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n     pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,"}, {"sha": "a16c36d749f0d704d0d86a6987585d394417d734", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -1,6 +1,6 @@\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n use crate::dataflow::indexes::{BorrowIndex, MovePathIndex};\n-use polonius_engine::AllFacts as PoloniusAllFacts;\n+use polonius_engine::AllFacts as PoloniusFacts;\n use polonius_engine::Atom;\n use rustc::mir::Local;\n use rustc::ty::{RegionVid, TyCtxt};\n@@ -11,7 +11,18 @@ use std::fs::{self, File};\n use std::io::Write;\n use std::path::Path;\n \n-crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n+#[derive(Copy, Clone, Debug)]\n+crate struct RustcFacts;\n+\n+impl polonius_engine::FactTypes for RustcFacts {\n+    type Origin = RegionVid;\n+    type Loan = BorrowIndex;\n+    type Point = LocationIndex;\n+    type Variable = Local;\n+    type Path = MovePathIndex;\n+}\n+\n+crate type AllFacts = PoloniusFacts<RustcFacts>;\n \n crate trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n@@ -55,6 +66,7 @@ impl AllFactsExt for AllFacts {\n             wr.write_facts_to_path(self.[\n                 borrow_region,\n                 universal_region,\n+                placeholder,\n                 cfg_edge,\n                 killed,\n                 outlives,\n@@ -69,6 +81,7 @@ impl AllFactsExt for AllFacts {\n                 initialized_at,\n                 moved_out_at,\n                 path_accessed_at,\n+                known_subset,\n             ])\n         }\n         Ok(())"}, {"sha": "bbcb823c8f91c003551c3f1b7d5bb19b46d13dd4", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -1,10 +1,9 @@\n use crate::borrow_check::borrow_set::BorrowSet;\n-use crate::borrow_check::location::{LocationIndex, LocationTable};\n+use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::facts::AllFactsExt;\n use crate::borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n-use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::{InitLocation, MoveData, MovePathIndex, InitKind};\n+use crate::dataflow::move_paths::{InitLocation, MoveData, InitKind};\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n@@ -43,10 +42,12 @@ crate mod universal_regions;\n crate mod type_check;\n crate mod region_infer;\n \n-use self::facts::AllFacts;\n+use self::facts::{AllFacts, RustcFacts};\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n \n+crate type PoloniusOutput = Output<RustcFacts>;\n+\n /// Rewrites the regions in the MIR to use NLL variables, also\n /// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to\n@@ -170,7 +171,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     errors_buffer: &mut Vec<Diagnostic>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n-    Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>>>,\n+    Option<Rc<PoloniusOutput>>,\n     Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     let mut all_facts = AllFacts::enabled(infcx.tcx).then_some(AllFacts::default());\n@@ -204,6 +205,39 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n             .universal_region\n             .extend(universal_regions.universal_regions());\n         populate_polonius_move_facts(all_facts, move_data, location_table, &body);\n+\n+        // Emit universal regions facts, and their relations, for Polonius.\n+        //\n+        // 1: universal regions are modeled in Polonius as a pair:\n+        // - the universal region vid itself.\n+        // - a \"placeholder loan\" associated to this universal region. Since they don't exist in\n+        //   the `borrow_set`, their `BorrowIndex` are synthesized as the universal region index\n+        //   added to the existing number of loans, as if they succeeded them in the set.\n+        //\n+        let borrow_count = borrow_set.borrows.len();\n+        debug!(\n+            \"compute_regions: polonius placeholders, num_universals={}, borrow_count={}\",\n+            universal_regions.len(),\n+            borrow_count\n+        );\n+\n+        for universal_region in universal_regions.universal_regions() {\n+            let universal_region_idx = universal_region.index();\n+            let placeholder_loan_idx = borrow_count + universal_region_idx;\n+            all_facts.placeholder.push((universal_region, placeholder_loan_idx.into()));\n+        }\n+\n+        // 2: the universal region relations `outlives` constraints are emitted as\n+        //  `known_subset` facts.\n+        for (fr1, fr2) in universal_region_relations.known_outlives() {\n+            if fr1 != fr2 {\n+                debug!(\n+                    \"compute_regions: emitting polonius `known_subset` fr1={:?}, fr2={:?}\",\n+                    fr1, fr2\n+                );\n+                all_facts.known_subset.push((*fr1, *fr2));\n+            }\n+        }\n     }\n \n     // Create the region inference context, taking ownership of the\n@@ -265,7 +299,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n         if infcx.tcx.sess.opts.debugging_opts.polonius {\n             let algorithm = env::var(\"POLONIUS_ALGORITHM\")\n-                .unwrap_or_else(|_| String::from(\"Hybrid\"));\n+                .unwrap_or_else(|_| String::from(\"Naive\"));\n             let algorithm = Algorithm::from_str(&algorithm).unwrap();\n             debug!(\"compute_regions: using polonius algorithm {:?}\", algorithm);\n             Some(Rc::new(Output::compute(\n@@ -279,8 +313,15 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     });\n \n     // Solve the region constraints.\n-    let closure_region_requirements =\n-        regioncx.solve(infcx, &body, local_names, upvars, def_id, errors_buffer);\n+    let closure_region_requirements = regioncx.solve(\n+        infcx,\n+        &body,\n+        local_names,\n+        upvars,\n+        def_id,\n+        errors_buffer,\n+        polonius_output.clone(),\n+    );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging."}, {"sha": "d62537b1ad46581e333d7b2122eea08b4ae27a0c", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 177, "deletions": 18, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -44,7 +44,7 @@ use crate::borrow_check::{\n \n use self::values::{LivenessValues, RegionValueElements, RegionValues};\n use super::universal_regions::UniversalRegions;\n-use super::ToRegionVid;\n+use super::{PoloniusOutput, ToRegionVid};\n \n mod dump_mir;\n mod graphviz;\n@@ -484,6 +484,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> Option<ClosureRegionRequirements<'tcx>> {\n         self.propagate_constraints(body);\n \n@@ -509,16 +510,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // multiple problems.\n         let mut region_naming = RegionErrorNamingCtx::new();\n \n-        self.check_universal_regions(\n-            infcx,\n-            body,\n-            local_names,\n-            upvars,\n-            mir_def_id,\n-            outlives_requirements.as_mut(),\n-            errors_buffer,\n-            &mut region_naming,\n-        );\n+        // In Polonius mode, the errors about missing universal region relations are in the output\n+        // and need to be emitted or propagated. Otherwise, we need to check whether the\n+        // constraints were too strong, and if so, emit or propagate those errors.\n+        if infcx.tcx.sess.opts.debugging_opts.polonius {\n+            self.check_polonius_subset_errors(\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                outlives_requirements.as_mut(),\n+                errors_buffer,\n+                &mut region_naming,\n+                polonius_output.expect(\"Polonius output is unavailable despite `-Z polonius`\"),\n+            );\n+        } else {\n+            self.check_universal_regions(\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                outlives_requirements.as_mut(),\n+                errors_buffer,\n+                &mut region_naming,\n+            );\n+        }\n \n         self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n \n@@ -1372,6 +1390,114 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlives_suggestion.add_suggestion(body, self, infcx, errors_buffer, region_naming);\n     }\n \n+    /// Checks if Polonius has found any unexpected free region relations.\n+    ///\n+    /// In Polonius terms, a \"subset error\" (or \"illegal subset relation error\") is the equivalent\n+    /// of NLL's \"checking if any region constraints were too strong\": a placeholder origin `'a`\n+    /// was unexpectedly found to be a subset of another placeholder origin `'b`, and means in NLL\n+    /// terms that the \"longer free region\" `'a` outlived the \"shorter free region\" `'b`.\n+    ///\n+    /// More details can be found in this blog post by Niko:\n+    /// http://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/\n+    ///\n+    /// In the canonical example\n+    ///\n+    ///     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    ///\n+    /// returning `x` requires `&'a u32 <: &'b u32` and hence we establish (transitively) a\n+    /// constraint that `'a: 'b`. It is an error that we have no evidence that this\n+    /// constraint holds.\n+    ///\n+    /// If `propagated_outlives_requirements` is `Some`, then we will\n+    /// push unsatisfied obligations into there. Otherwise, we'll\n+    /// report them as errors.\n+    fn check_polonius_subset_errors(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n+        upvars: &[Upvar],\n+        mir_def_id: DefId,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n+        polonius_output: Rc<PoloniusOutput>,\n+    ) {\n+        debug!(\n+            \"check_polonius_subset_errors: {} subset_errors\",\n+            polonius_output.subset_errors.len()\n+        );\n+\n+        let mut outlives_suggestion = OutlivesSuggestionBuilder::new(mir_def_id, local_names);\n+\n+        // Similarly to `check_universal_regions`: a free region relation, which was not explicitly\n+        // declared (\"known\") was found by Polonius, so emit an error, or propagate the\n+        // requirements for our caller into the `propagated_outlives_requirements` vector.\n+        //\n+        // Polonius doesn't model regions (\"origins\") as CFG-subsets or durations, but the\n+        // `longer_fr` and `shorter_fr` terminology will still be used here, for consistency with\n+        // the rest of the NLL infrastructure. The \"subset origin\" is the \"longer free region\",\n+        // and the \"superset origin\" is the outlived \"shorter free region\".\n+        //\n+        // Note: Polonius will produce a subset error at every point where the unexpected\n+        // `longer_fr`'s \"placeholder loan\" is contained in the `shorter_fr`. This can be helpful\n+        // for diagnostics in the future, e.g. to point more precisely at the key locations\n+        // requiring this constraint to hold. However, the error and diagnostics code downstream\n+        // expects that these errors are not duplicated (and that they are in a certain order).\n+        // Otherwise, diagnostics messages such as the ones giving names like `'1` to elided or\n+        // anonymous lifetimes for example, could give these names differently, while others like\n+        // the outlives suggestions or the debug output from `#[rustc_regions]` would be\n+        // duplicated. The polonius subset errors are deduplicated here, while keeping the\n+        // CFG-location ordering.\n+        let mut subset_errors: Vec<_> = polonius_output\n+            .subset_errors\n+            .iter()\n+            .flat_map(|(_location, subset_errors)| subset_errors.iter())\n+            .collect();\n+        subset_errors.sort();\n+        subset_errors.dedup();\n+\n+        for (longer_fr, shorter_fr) in subset_errors.into_iter() {\n+            debug!(\"check_polonius_subset_errors: subset_error longer_fr={:?},\\\n+                shorter_fr={:?}\", longer_fr, shorter_fr);\n+\n+            self.report_or_propagate_universal_region_error(\n+                *longer_fr,\n+                *shorter_fr,\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                &mut propagated_outlives_requirements,\n+                &mut outlives_suggestion,\n+                errors_buffer,\n+                region_naming,\n+            );\n+        }\n+\n+        // Handle the placeholder errors as usual, until the chalk-rustc-polonius triumvirate has\n+        // a more complete picture on how to separate this responsibility.\n+        for (fr, fr_definition) in self.definitions.iter_enumerated() {\n+            match fr_definition.origin {\n+                NLLRegionVariableOrigin::FreeRegion => {\n+                    // handled by polonius above\n+                }\n+\n+                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                    self.check_bound_universal_region(infcx, body, mir_def_id, fr, placeholder);\n+                }\n+\n+                NLLRegionVariableOrigin::Existential { .. } => {\n+                    // nothing to check here\n+                }\n+            }\n+        }\n+\n+        // Emit outlives suggestions\n+        outlives_suggestion.add_suggestion(body, self, infcx, errors_buffer, region_naming);\n+    }\n+\n     /// Checks the final value for the free region `fr` to see if it\n     /// grew too large. In particular, examine what `end(X)` points\n     /// wound up in `fr`'s final value; for each `end(X)` where `X !=\n@@ -1471,8 +1597,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n+        self.report_or_propagate_universal_region_error(\n+            longer_fr,\n+            shorter_fr,\n+            infcx,\n+            body,\n+            local_names,\n+            upvars,\n+            mir_def_id,\n+            propagated_outlives_requirements,\n+            outlives_suggestion,\n+            errors_buffer,\n+            region_naming,\n+        )\n+    }\n+\n+    fn report_or_propagate_universal_region_error(\n+        &self,\n+        longer_fr: RegionVid,\n+        shorter_fr: RegionVid,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n+        upvars: &[Upvar],\n+        mir_def_id: DefId,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n+        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n+    ) -> Option<ErrorReported> {\n         debug!(\n-            \"check_universal_region_relation: fr={:?} does not outlive shorter_fr={:?}\",\n+            \"report_or_propagate_universal_region_error: fr={:?} does not outlive shorter_fr={:?}\",\n             longer_fr, shorter_fr,\n         );\n \n@@ -1481,9 +1636,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // We'll call it `fr-` -- it's ever so slightly smaller than\n             // `longer_fr`.\n \n-            if let Some(fr_minus) = self.universal_region_relations.non_local_lower_bound(longer_fr)\n-            {\n-                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+            if let Some(fr_minus) =\n+                self.universal_region_relations.non_local_lower_bound(longer_fr) {\n+                debug!(\"report_or_propagate_universal_region_error: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category =\n                     self.find_outlives_blame_span(body, longer_fr,\n@@ -1492,9 +1647,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // Grow `shorter_fr` until we find some non-local regions. (We\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n                 // so slightly larger than `shorter_fr`.\n-                let shorter_fr_plus =\n-                    self.universal_region_relations.non_local_upper_bounds(&shorter_fr);\n-                debug!(\"check_universal_region: shorter_fr_plus={:?}\", shorter_fr_plus);\n+                let shorter_fr_plus = self\n+                    .universal_region_relations\n+                    .non_local_upper_bounds(&shorter_fr);\n+                debug!(\n+                    \"report_or_propagate_universal_region_error: shorter_fr_plus={:?}\",\n+                    shorter_fr_plus\n+                );\n                 for &&fr in &shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {"}, {"sha": "8bb68383a49baa3da6d18db7ae1bb495336b3af8", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -217,6 +217,11 @@ impl UniversalRegionRelations<'tcx> {\n     crate fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n         self.outlives.reachable_from(&fr1)\n     }\n+\n+    /// Returns the _non-transitive_ set of known `outlives` constraints between free regions.\n+    crate fn known_outlives(&self) -> impl Iterator<Item=(&RegionVid, &RegionVid)> {\n+        self.outlives.base_edges()\n+    }\n }\n \n struct UniversalRegionRelationsBuilder<'this, 'tcx> {"}, {"sha": "c8c2702ec447efd85b05c5d797ecbecb00e586aa", "filename": "src/test/ui/async-await/issues/issue-66958-non-copy-infered-type-arg.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66958-non-copy-infered-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66958-non-copy-infered-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66958-non-copy-infered-type-arg.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,15 @@\n+// edition:2018\n+\n+struct Ia<S>(S);\n+\n+impl<S> Ia<S> {\n+    fn partial(_: S) {}\n+    fn full(self) {}\n+\n+    async fn crash(self) {\n+        Self::partial(self.0);\n+        Self::full(self); //~ ERROR use of moved value: `self`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9177b83dd48d776ac5d7601808db5a6e0233177a", "filename": "src/test/ui/async-await/issues/issue-66958-non-copy-infered-type-arg.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66958-non-copy-infered-type-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66958-non-copy-infered-type-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66958-non-copy-infered-type-arg.stderr?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `self`\n+  --> $DIR/issue-66958-non-copy-infered-type-arg.rs:11:20\n+   |\n+LL |         Self::partial(self.0);\n+   |                       ------ value moved here\n+LL |         Self::full(self);\n+   |                    ^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `self.0` has type `S`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "2a7461fb469b271181f736bfb8d1fc55966143cf", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region.polonius.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.polonius.stderr?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,56 @@\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/expect-region-supply-region.rs:18:9\n+   |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- `f` is declared here, outside of the closure body\n+LL |     closure_expecting_bound(|x| {\n+   |                              - `x` is a reference that is only valid in the closure body\n+LL |         f = Some(x);\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n+\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/expect-region-supply-region.rs:28:9\n+   |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- `f` is declared here, outside of the closure body\n+LL |     closure_expecting_bound(|x: &u32| {\n+   |                              - `x` is a reference that is only valid in the closure body\n+LL |         f = Some(x);\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n+\n+error: lifetime may not live long enough\n+  --> $DIR/expect-region-supply-region.rs:37:30\n+   |\n+LL | fn expect_bound_supply_named<'x>() {\n+   |                              -- lifetime `'x` defined here\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              ^  - let's call the lifetime of this reference `'1`\n+   |                              |\n+   |                              requires that `'1` must outlive `'x`\n+\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/expect-region-supply-region.rs:42:9\n+   |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- `f` is declared here, outside of the closure body\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              - `x` is a reference that is only valid in the closure body\n+...\n+LL |         f = Some(x);\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n+\n+error: lifetime may not live long enough\n+  --> $DIR/expect-region-supply-region.rs:37:30\n+   |\n+LL | fn expect_bound_supply_named<'x>() {\n+   |                              -- lifetime `'x` defined here\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              ^ requires that `'x` must outlive `'static`\n+   |\n+   = help: consider replacing `'x` with `'static`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "558d643cde8958a29af8658a93f88baad8860fa9", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.polonius.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.polonius.stderr?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,68 @@\n+warning: function cannot return without recursing\n+  --> $DIR/hrtb-perfect-forwarding.rs:22:1\n+   |\n+LL | / fn no_hrtb<'b,T>(mut t: T)\n+LL | |     where T : Bar<&'b isize>\n+LL | | {\n+LL | |     // OK -- `T : Bar<&'b isize>`, and thus the impl above ensures that\n+LL | |     // `&mut T : Bar<&'b isize>`.\n+LL | |     no_hrtb(&mut t);\n+   | |     --------------- recursive call site\n+LL | | }\n+   | |_^ cannot return without recursing\n+   |\n+   = note: `#[warn(unconditional_recursion)]` on by default\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+warning: function cannot return without recursing\n+  --> $DIR/hrtb-perfect-forwarding.rs:30:1\n+   |\n+LL | / fn bar_hrtb<T>(mut t: T)\n+LL | |     where T : for<'b> Bar<&'b isize>\n+LL | | {\n+LL | |     // OK -- `T : for<'b> Bar<&'b isize>`, and thus the impl above\n+...  |\n+LL | |     bar_hrtb(&mut t);\n+   | |     ---------------- recursive call site\n+LL | | }\n+   | |_^ cannot return without recursing\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+warning: function cannot return without recursing\n+  --> $DIR/hrtb-perfect-forwarding.rs:39:1\n+   |\n+LL | / fn foo_hrtb_bar_not<'b,T>(mut t: T)\n+LL | |     where T : for<'a> Foo<&'a isize> + Bar<&'b isize>\n+LL | | {\n+LL | |     // Not OK -- The forwarding impl for `Foo` requires that `Bar` also\n+...  |\n+LL | |     foo_hrtb_bar_not(&mut t);\n+   | |     ------------------------ recursive call site\n+LL | | }\n+   | |_^ cannot return without recursing\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-perfect-forwarding.rs:46:5\n+   |\n+LL |     foo_hrtb_bar_not(&mut t);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: function cannot return without recursing\n+  --> $DIR/hrtb-perfect-forwarding.rs:49:1\n+   |\n+LL | / fn foo_hrtb_bar_hrtb<T>(mut t: T)\n+LL | |     where T : for<'a> Foo<&'a isize> + for<'b> Bar<&'b isize>\n+LL | | {\n+LL | |     // OK -- now we have `T : for<'b> Bar&'b isize>`.\n+LL | |     foo_hrtb_bar_hrtb(&mut t);\n+   | |     ------------------------- recursive call site\n+LL | | }\n+   | |_^ cannot return without recursing\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+error: aborting due to previous error\n+"}, {"sha": "72e8fa33d7b4d04c0bb9db797ee5e83448ea6586", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.polonius.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.polonius.stderr?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,12 @@\n+error: lifetime may not live long enough\n+  --> $DIR/error-handling.rs:13:56\n+   |\n+LL | fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+   |        --  -- lifetime `'b` defined here               ^^^^^^^^^ opaque type requires that `'a` must outlive `'b`\n+   |        |\n+   |        lifetime `'a` defined here\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "815744618f62c69e2b51b8157c0bc405b0f74621", "filename": "src/test/ui/nll/outlives-suggestion-simple.polonius.stderr", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fnll%2Foutlives-suggestion-simple.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fnll%2Foutlives-suggestion-simple.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Foutlives-suggestion-simple.polonius.stderr?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,121 @@\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:6:5\n+   |\n+LL | fn foo1<'a, 'b>(x: &'a usize) -> &'b usize {\n+   |         --  -- lifetime `'b` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+LL |     x\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:10:5\n+   |\n+LL | fn foo2<'a>(x: &'a usize) -> &'static usize {\n+   |         -- lifetime `'a` defined here\n+LL |     x\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:14:5\n+   |\n+LL | fn foo3<'a, 'b>(x: &'a usize, y: &'b usize) -> (&'b usize, &'a usize) {\n+   |         --  -- lifetime `'b` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+LL |     (x, y)\n+   |     ^^^^^^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:14:5\n+   |\n+LL | fn foo3<'a, 'b>(x: &'a usize, y: &'b usize) -> (&'b usize, &'a usize) {\n+   |         --  -- lifetime `'b` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+LL |     (x, y)\n+   |     ^^^^^^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+help: `'a` and `'b` must be the same: replace one with the other\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:22:5\n+   |\n+LL | fn foo4<'a, 'b, 'c>(x: &'a usize) -> (&'b usize, &'c usize) {\n+   |         --  -- lifetime `'b` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+...\n+LL |     (x, x)\n+   |     ^^^^^^ returning this value requires that `'a` must outlive `'b`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:22:5\n+   |\n+LL | fn foo4<'a, 'b, 'c>(x: &'a usize) -> (&'b usize, &'c usize) {\n+   |         --      -- lifetime `'c` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+...\n+LL |     (x, x)\n+   |     ^^^^^^ returning this value requires that `'a` must outlive `'c`\n+   |\n+   = help: consider adding the following bound: `'a: 'c`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:31:9\n+   |\n+LL |     pub fn foo<'a>(x: &'a usize) -> Self {\n+   |                -- lifetime `'a` defined here\n+LL |         Foo { x }\n+   |         ^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:41:9\n+   |\n+LL | impl<'a> Bar<'a> {\n+   |      -- lifetime `'a` defined here\n+LL |     pub fn get<'b>(&self) -> &'b usize {\n+   |                -- lifetime `'b` defined here\n+LL |         self.x\n+   |         ^^^^^^ returning this value requires that `'a` must outlive `'b`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:52:9\n+   |\n+LL | impl<'a> Baz<'a> {\n+   |      -- lifetime `'a` defined here\n+LL |     fn get<'b>(&'b self) -> &'a i32 {\n+   |            -- lifetime `'b` defined here\n+LL |         self.x\n+   |         ^^^^^^ returning this value requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/outlives-suggestion-simple.rs:73:9\n+   |\n+LL |     fn get_bar(&self) -> Bar2 {\n+   |                -----\n+   |                |\n+   |                `self` is declared here, outside of the function body\n+   |                `self` is a reference that is only valid in the function body\n+LL |         Bar2::new(&self)\n+   |         ^^^^^^^^^^^^^^^^ `self` escapes the function body here\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "3f6f67ebf4030084cfa22be2421c8dcf49fbae3d", "filename": "src/test/ui/nll/polonius/subset-relations.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.rs?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,30 @@\n+// Checks that Polonius can compute cases of universal regions errors:\n+// \"illegal subset relation errors\", cases where analysis finds that\n+// two free regions outlive each other, without any evidence that this\n+// relation holds.\n+\n+// ignore-compare-mode-nll\n+// compile-flags: -Z borrowck=mir -Zpolonius\n+\n+// returning `y` requires that `'b: 'a`, but it's not known to be true\n+fn missing_subset<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+    y //~ ERROR\n+}\n+\n+// `'b: 'a` is explicitly declared\n+fn valid_subset<'a, 'b: 'a>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+    y\n+}\n+\n+// because of `x`, it is implied that `'b: 'a` holds\n+fn implied_bounds_subset<'a, 'b>(x: &'a &'b mut u32) -> &'a u32 {\n+    x\n+}\n+\n+// `'b: 'a` is declared, and `'a: 'c` is known via implied bounds:\n+// `'b: 'c` is therefore known to hold transitively\n+fn transitively_valid_subset<'a, 'b: 'a, 'c>(x: &'c &'a u32, y: &'b u32) -> &'c u32  {\n+    y\n+}\n+\n+fn main() {}"}, {"sha": "63645106f82c169dc1f4ee2585bebc4e7066d692", "filename": "src/test/ui/nll/polonius/subset-relations.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.stderr?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,14 @@\n+error: lifetime may not live long enough\n+  --> $DIR/subset-relations.rs:11:5\n+   |\n+LL | fn missing_subset<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+   |                   --  -- lifetime `'b` defined here\n+   |                   |\n+   |                   lifetime `'a` defined here\n+LL |     y\n+   |     ^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: aborting due to previous error\n+"}, {"sha": "d5bcdf64441712fd341f95ac6300f0d47172ecdf", "filename": "src/test/ui/nll/user-annotations/closure-substs.polonius.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-substs.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/970470a21407c51e89b7f183c7ce2bad77b77696/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-substs.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-substs.polonius.stderr?ref=970470a21407c51e89b7f183c7ce2bad77b77696", "patch": "@@ -0,0 +1,60 @@\n+error: lifetime may not live long enough\n+  --> $DIR/closure-substs.rs:8:16\n+   |\n+LL | fn foo<'a>() {\n+   |        -- lifetime `'a` defined here\n+...\n+LL |         return x;\n+   |                ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/closure-substs.rs:15:16\n+   |\n+LL |     |x: &i32| -> &'static i32 {\n+   |         - let's call the lifetime of this reference `'1`\n+LL |         return x;\n+   |                ^ returning this value requires that `'1` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/closure-substs.rs:15:16\n+   |\n+LL |     |x: &i32| -> &'static i32 {\n+   |         -        ------------ return type of closure is &'2 i32\n+   |         |\n+   |         let's call the lifetime of this reference `'1`\n+LL |         return x;\n+   |                ^ returning this value requires that `'1` must outlive `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/closure-substs.rs:22:9\n+   |\n+LL | fn bar<'a>() {\n+   |        -- lifetime `'a` defined here\n+...\n+LL |         b(x);\n+   |         ^^^^ argument requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/closure-substs.rs:29:9\n+   |\n+LL |     |x: &i32, b: fn(&'static i32)| {\n+   |      - `x` is a reference that is only valid in the closure body\n+LL |         b(x);\n+   |         ^^^^ `x` escapes the closure body here\n+\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/closure-substs.rs:29:9\n+   |\n+LL |     |x: &i32, b: fn(&'static i32)| {\n+   |      -        - `b` is declared here, outside of the closure body\n+   |      |\n+   |      `x` is a reference that is only valid in the closure body\n+LL |         b(x);\n+   |         ^^^^ `x` escapes the closure body here\n+\n+error: aborting due to 6 previous errors\n+"}]}