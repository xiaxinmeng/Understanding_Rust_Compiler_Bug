{"sha": "d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "node_id": "C_kwDOAAsO6NoAKGQ0YmU4ZWZjNjI5NmJhY2U1YjFlMTY1ZjFiMzRkM2M2ZGE3NmFhOGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-10T09:07:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-10T09:07:02Z"}, "message": "Auto merge of #110137 - Dylan-DPC:rollup-fdruvwp, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #109724 (prioritize param env candidates if they don't guide type inference)\n - #110021 (Fix a couple ICEs in the new `CastKind::Transmute` code)\n - #110044 (Avoid some manual slice length calculation)\n - #110115 (compiletest: Use remap-path-prefix only in CI)\n - #110121 (Fix `x check --stage 1` when download-rustc is enabled)\n - #110124 (Some clippy fixes in the compiler)\n\nFailed merges:\n\n - #109752 (Stall auto trait assembly in new solver for int/float vars)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fa3193661217bb3d2fed15983127eef6eb2c5228", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa3193661217bb3d2fed15983127eef6eb2c5228"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "html_url": "https://github.com/rust-lang/rust/commit/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f7e8fbc99600eeb662a0321a778c56537ee4889", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7e8fbc99600eeb662a0321a778c56537ee4889", "html_url": "https://github.com/rust-lang/rust/commit/7f7e8fbc99600eeb662a0321a778c56537ee4889"}, {"sha": "97921abc068224b29a5b2305f7e69c702ff9e38f", "url": "https://api.github.com/repos/rust-lang/rust/commits/97921abc068224b29a5b2305f7e69c702ff9e38f", "html_url": "https://github.com/rust-lang/rust/commit/97921abc068224b29a5b2305f7e69c702ff9e38f"}], "stats": {"total": 929, "additions": 629, "deletions": 300}, "files": [{"sha": "b0c0ee942ea8f5074cb2e6bfd8792395e8efe411", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1176,7 +1176,7 @@ impl FieldsShape {\n \n     /// Gets source indices of the fields by increasing offsets.\n     #[inline]\n-    pub fn index_by_increasing_offset<'a>(&'a self) -> impl Iterator<Item = usize> + 'a {\n+    pub fn index_by_increasing_offset(&self) -> impl Iterator<Item = usize> + '_ {\n         let mut inverse_small = [0u8; 64];\n         let mut inverse_big = IndexVec::new();\n         let use_small = self.count() <= inverse_small.len();"}, {"sha": "345e058e1134a4a5c1ba516b326f01335addb152", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -22,6 +22,7 @@\n #![feature(strict_provenance)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+#![allow(clippy::mut_from_ref)] // Arena allocators are one of the places where this pattern is fine.\n \n use smallvec::SmallVec;\n \n@@ -568,7 +569,9 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     }\n \n     pub trait ArenaAllocatable<'tcx, C = rustc_arena::IsNotCopy>: Sized {\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_from_iter<'a>(\n             arena: &'a Arena<'tcx>,\n             iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -578,10 +581,12 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     // Any type that impls `Copy` can be arena-allocated in the `DroplessArena`.\n     impl<'tcx, T: Copy> ArenaAllocatable<'tcx, rustc_arena::IsCopy> for T {\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n             arena.dropless.alloc(self)\n         }\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_from_iter<'a>(\n             arena: &'a Arena<'tcx>,\n             iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -601,6 +606,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n             }\n \n             #[inline]\n+            #[allow(clippy::mut_from_ref)]\n             fn allocate_from_iter<'a>(\n                 arena: &'a Arena<'tcx>,\n                 iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -616,19 +622,22 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n \n     impl<'tcx> Arena<'tcx> {\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc<T: ArenaAllocatable<'tcx, C>, C>(&self, value: T) -> &mut T {\n             value.allocate_on(self)\n         }\n \n         // Any type that impls `Copy` can have slices be arena-allocated in the `DroplessArena`.\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc_slice<T: ::std::marker::Copy>(&self, value: &[T]) -> &mut [T] {\n             if value.is_empty() {\n                 return &mut [];\n             }\n             self.dropless.alloc_slice(value)\n         }\n \n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, C>, C>(\n             &'a self,\n             iter: impl ::std::iter::IntoIterator<Item = T>,"}, {"sha": "1389acabfcbd55e34c7a876009b8d821d70f75c5", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -691,7 +691,7 @@ fn validate_generic_param_order(\n                 GenericParamKind::Lifetime => (),\n                 GenericParamKind::Const { ty: _, kw_span: _, default: Some(default) } => {\n                     ordered_params += \" = \";\n-                    ordered_params += &pprust::expr_to_string(&*default.value);\n+                    ordered_params += &pprust::expr_to_string(&default.value);\n                 }\n                 GenericParamKind::Const { ty: _, kw_span: _, default: None } => (),\n             }"}, {"sha": "007d64f681f76d156cab9e4c1afdca08a8626e6c", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -404,11 +404,14 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     );\n                 } else {\n                     // And if it isn't, cancel the early-pass warning.\n-                    self.sess\n+                    if let Some(err) = self\n+                        .sess\n                         .parse_sess\n                         .span_diagnostic\n                         .steal_diagnostic(e.span, StashKey::EarlySyntaxWarning)\n-                        .map(|err| err.cancel());\n+                    {\n+                        err.cancel()\n+                    }\n                 }\n             }\n             ast::ExprKind::TryBlock(_) => {"}, {"sha": "1f6838a02784477720b5c4839b47ea9da5cdf5e0", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -686,7 +686,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn bclose_maybe_open(&mut self, span: rustc_span::Span, empty: bool, close_box: bool) {\n         let has_comment = self.maybe_print_comment(span.hi());\n         if !empty || has_comment {\n-            self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n+            self.break_offset_if_not_bol(1, -INDENT_UNIT);\n         }\n         self.word(\"}\");\n         if close_box {\n@@ -988,7 +988,9 @@ impl<'a> State<'a> {\n \n     pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocConstraint) {\n         self.print_ident(constraint.ident);\n-        constraint.gen_args.as_ref().map(|args| self.print_generic_args(args, false));\n+        if let Some(args) = constraint.gen_args.as_ref() {\n+            self.print_generic_args(args, false)\n+        }\n         self.space();\n         match &constraint.kind {\n             ast::AssocConstraintKind::Equality { term } => {"}, {"sha": "b37797fef4ce3d10a6406247e9be3be250174805", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -259,6 +259,31 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n }\n \n impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n+    /// Returns an `OperandValue` that's generally UB to use in any way.\n+    ///\n+    /// Depending on the `layout`, returns an `Immediate` or `Pair` containing\n+    /// poison value(s), or a `Ref` containing a poison pointer.\n+    ///\n+    /// Supports sized types only.\n+    pub fn poison<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> OperandValue<V> {\n+        assert!(layout.is_sized());\n+        if bx.cx().is_backend_immediate(layout) {\n+            let ibty = bx.cx().immediate_backend_type(layout);\n+            OperandValue::Immediate(bx.const_poison(ibty))\n+        } else if bx.cx().is_backend_scalar_pair(layout) {\n+            let ibty0 = bx.cx().scalar_pair_element_backend_type(layout, 0, true);\n+            let ibty1 = bx.cx().scalar_pair_element_backend_type(layout, 1, true);\n+            OperandValue::Pair(bx.const_poison(ibty0), bx.const_poison(ibty1))\n+        } else {\n+            let bty = bx.cx().backend_type(layout);\n+            let ptr_bty = bx.cx().type_ptr_to(bty);\n+            OperandValue::Ref(bx.const_poison(ptr_bty), None, layout.align.abi)\n+        }\n+    }\n+\n     pub fn store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &mut Bx,"}, {"sha": "d88226f5db05335ee404e996c8fc5c6969b81333", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -158,17 +158,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         debug_assert!(src.layout.is_sized());\n         debug_assert!(dst.layout.is_sized());\n \n-        if src.layout.size != dst.layout.size\n-            || src.layout.abi.is_uninhabited()\n-            || dst.layout.abi.is_uninhabited()\n-        {\n-            // In all of these cases it's UB to run this transmute, but that's\n-            // known statically so might as well trap for it, rather than just\n-            // making it unreachable.\n-            bx.abort();\n-            return;\n-        }\n-\n         if let Some(val) = self.codegen_transmute_operand(bx, src, dst.layout) {\n             val.store(bx, dst);\n             return;\n@@ -202,8 +191,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         operand: OperandRef<'tcx, Bx::Value>,\n         cast: TyAndLayout<'tcx>,\n     ) -> Option<OperandValue<Bx::Value>> {\n-        // Callers already checked that the layout sizes match\n-        debug_assert_eq!(operand.layout.size, cast.size);\n+        // Check for transmutes that are always UB.\n+        if operand.layout.size != cast.size\n+            || operand.layout.abi.is_uninhabited()\n+            || cast.abi.is_uninhabited()\n+        {\n+            if !operand.layout.abi.is_uninhabited() {\n+                // Since this is known statically and the input could have existed\n+                // without already having hit UB, might as well trap for it.\n+                bx.abort();\n+            }\n+\n+            // Because this transmute is UB, return something easy to generate,\n+            // since it's fine that later uses of the value are probably UB.\n+            return Some(OperandValue::poison(bx, cast));\n+        }\n \n         let operand_kind = self.value_kind(operand.layout);\n         let cast_kind = self.value_kind(cast);\n@@ -222,10 +224,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n                 if let OperandValueKind::Immediate(out_scalar) = cast_kind {\n-                    let cast_bty = bx.backend_type(cast);\n-                    Some(OperandValue::Immediate(Self::transmute_immediate(\n-                        bx, imm, in_scalar, out_scalar, cast_bty,\n-                    )))\n+                    match (in_scalar, out_scalar) {\n+                        (ScalarOrZst::Zst, ScalarOrZst::Zst) => {\n+                            Some(OperandRef::new_zst(bx, cast).val)\n+                        }\n+                        (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n+                            if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n+                        {\n+                            let cast_bty = bx.backend_type(cast);\n+                            Some(OperandValue::Immediate(\n+                                self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n+                            ))\n+                        }\n+                        _ => None,\n+                    }\n                 } else {\n                     None\n                 }\n@@ -234,12 +246,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let OperandValueKind::Pair(in_a, in_b) = operand_kind else {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n-                if let OperandValueKind::Pair(out_a, out_b) = cast_kind {\n+                if let OperandValueKind::Pair(out_a, out_b) = cast_kind\n+                    && in_a.size(self.cx) == out_a.size(self.cx)\n+                    && in_b.size(self.cx) == out_b.size(self.cx)\n+                {\n                     let out_a_ibty = bx.scalar_pair_element_backend_type(cast, 0, false);\n                     let out_b_ibty = bx.scalar_pair_element_backend_type(cast, 1, false);\n                     Some(OperandValue::Pair(\n-                        Self::transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n-                        Self::transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n+                        self.transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n+                        self.transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n                     ))\n                 } else {\n                     None\n@@ -254,12 +269,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// `to_backend_ty` must be the *non*-immediate backend type (so it will be\n     /// `i8`, not `i1`, for `bool`-like types.)\n     fn transmute_immediate(\n+        &self,\n         bx: &mut Bx,\n         mut imm: Bx::Value,\n         from_scalar: abi::Scalar,\n         to_scalar: abi::Scalar,\n         to_backend_ty: Bx::Type,\n     ) -> Bx::Value {\n+        debug_assert_eq!(from_scalar.size(self.cx), to_scalar.size(self.cx));\n+\n         use abi::Primitive::*;\n         imm = bx.from_immediate(imm);\n         imm = match (from_scalar.primitive(), to_scalar.primitive()) {\n@@ -831,14 +849,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let operand_ty = operand.ty(self.mir, self.cx.tcx());\n                 let cast_layout = self.cx.layout_of(self.monomorphize(cast_ty));\n                 let operand_layout = self.cx.layout_of(self.monomorphize(operand_ty));\n-                if operand_layout.size != cast_layout.size\n-                    || operand_layout.abi.is_uninhabited()\n-                    || cast_layout.abi.is_uninhabited()\n-                {\n-                    // Send UB cases to the full form so the operand version can\n-                    // `bitcast` without worrying about malformed IR.\n-                    return false;\n-                }\n \n                 match (self.value_kind(operand_layout), self.value_kind(cast_layout)) {\n                     // Can always load from a pointer as needed\n@@ -847,9 +857,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // Need to generate an `alloc` to get a pointer from an immediate\n                     (OperandValueKind::Immediate(..) | OperandValueKind::Pair(..), OperandValueKind::Ref) => false,\n \n-                    // When we have scalar immediates, we can convert them as needed\n-                    (OperandValueKind::Immediate(..), OperandValueKind::Immediate(..)) |\n-                    (OperandValueKind::Pair(..), OperandValueKind::Pair(..)) => true,\n+                    // When we have scalar immediates, we can only convert things\n+                    // where the sizes match, to avoid endianness questions.\n+                    (OperandValueKind::Immediate(a), OperandValueKind::Immediate(b)) =>\n+                        a.size(self.cx) == b.size(self.cx),\n+                    (OperandValueKind::Pair(a0, a1), OperandValueKind::Pair(b0, b1)) =>\n+                        a0.size(self.cx) == b0.size(self.cx) && a1.size(self.cx) == b1.size(self.cx),\n \n                     // Send mixings between scalars and pairs through the memory route\n                     // FIXME: Maybe this could use insertvalue/extractvalue instead?\n@@ -887,13 +900,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if self.cx.is_backend_immediate(layout) {\n             debug_assert!(!self.cx.is_backend_scalar_pair(layout));\n             OperandValueKind::Immediate(match layout.abi {\n-                abi::Abi::Scalar(s) => s,\n-                abi::Abi::Vector { element, .. } => element,\n-                x => bug!(\"Couldn't translate {x:?} as backend immediate\"),\n+                abi::Abi::Scalar(s) => ScalarOrZst::Scalar(s),\n+                abi::Abi::Vector { element, .. } => ScalarOrZst::Scalar(element),\n+                _ if layout.is_zst() => ScalarOrZst::Zst,\n+                x => span_bug!(self.mir.span, \"Couldn't translate {x:?} as backend immediate\"),\n             })\n         } else if self.cx.is_backend_scalar_pair(layout) {\n             let abi::Abi::ScalarPair(s1, s2) = layout.abi else {\n-                bug!(\"Couldn't translate {:?} as backend scalar pair\", layout.abi)\n+                span_bug!(\n+                    self.mir.span,\n+                    \"Couldn't translate {:?} as backend scalar pair\",\n+                    layout.abi,\n+                );\n             };\n             OperandValueKind::Pair(s1, s2)\n         } else {\n@@ -902,9 +920,26 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n+/// The variants of this match [`OperandValue`], giving details about the\n+/// backend values that will be held in that other type.\n #[derive(Debug, Copy, Clone)]\n enum OperandValueKind {\n     Ref,\n-    Immediate(abi::Scalar),\n+    Immediate(ScalarOrZst),\n     Pair(abi::Scalar, abi::Scalar),\n }\n+\n+#[derive(Debug, Copy, Clone)]\n+enum ScalarOrZst {\n+    Zst,\n+    Scalar(abi::Scalar),\n+}\n+\n+impl ScalarOrZst {\n+    pub fn size(self, cx: &impl abi::HasDataLayout) -> abi::Size {\n+        match self {\n+            ScalarOrZst::Zst => abi::Size::ZERO,\n+            ScalarOrZst::Scalar(s) => s.size(cx),\n+        }\n+    }\n+}"}, {"sha": "9ff401c3c7aad19d78a73c057b4001bce31d123e", "filename": "compiler/rustc_data_structures/src/graph/implementation/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -206,17 +206,11 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         AdjacentEdges { graph: self, direction, next: first_edge }\n     }\n \n-    pub fn successor_nodes<'a>(\n-        &'a self,\n-        source: NodeIndex,\n-    ) -> impl Iterator<Item = NodeIndex> + 'a {\n+    pub fn successor_nodes(&self, source: NodeIndex) -> impl Iterator<Item = NodeIndex> + '_ {\n         self.outgoing_edges(source).targets()\n     }\n \n-    pub fn predecessor_nodes<'a>(\n-        &'a self,\n-        target: NodeIndex,\n-    ) -> impl Iterator<Item = NodeIndex> + 'a {\n+    pub fn predecessor_nodes(&self, target: NodeIndex) -> impl Iterator<Item = NodeIndex> + '_ {\n         self.incoming_edges(target).sources()\n     }\n "}, {"sha": "ef37a606f313e59221624f90bd2a8e272b3dea11", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -40,7 +40,7 @@ impl Deref for Mmap {\n \n impl AsRef<[u8]> for Mmap {\n     fn as_ref(&self) -> &[u8] {\n-        &*self.0\n+        &self.0\n     }\n }\n "}, {"sha": "1ed584eafad307f7d2f121d30b9dccf23dd4c952", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -778,7 +778,7 @@ pub fn print_time_passes_entry(\n                 \"rss_start\": start_rss,\n                 \"rss_end\": end_rss,\n             });\n-            eprintln!(\"time: {}\", json.to_string());\n+            eprintln!(\"time: {json}\");\n             return;\n         }\n         TimePassesFormat::Text => (),"}, {"sha": "bd7a86f67800f8d81b306ed3d100fcb8b7ba9fd8", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -140,6 +140,7 @@ pub fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n /// `hash` can be computed with any hasher, so long as that hasher is used\n /// consistently for each `Sharded` instance.\n #[inline]\n+#[allow(clippy::modulo_one)]\n pub fn get_shard_index_by_hash(hash: u64) -> usize {\n     let hash_len = mem::size_of::<usize>();\n     // Ignore the top 7 bits as hashbrown uses these and get the next SHARD_BITS highest bits."}, {"sha": "3ed1de1bc3ca1ebbd712c3f847e95d5c6aca5a95", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -312,14 +312,14 @@ impl<CTX> HashStable<CTX> for ::std::num::NonZeroUsize {\n \n impl<CTX> HashStable<CTX> for f32 {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        let val: u32 = unsafe { ::std::mem::transmute(*self) };\n+        let val: u32 = self.to_bits();\n         val.hash_stable(ctx, hasher);\n     }\n }\n \n impl<CTX> HashStable<CTX> for f64 {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        let val: u64 = unsafe { ::std::mem::transmute(*self) };\n+        let val: u64 = self.to_bits();\n         val.hash_stable(ctx, hasher);\n     }\n }"}, {"sha": "7ff1339c5ab34c554f9ee754f42e403fad0ed79a", "filename": "compiler/rustc_data_structures/src/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -5,7 +5,7 @@ const RED_ZONE: usize = 100 * 1024; // 100k\n \n // Only the first stack that is pushed, grows exponentially (2^n * STACK_PER_RECURSION) from then\n // on. This flag has performance relevant characteristics. Don't set it too high.\n-const STACK_PER_RECURSION: usize = 1 * 1024 * 1024; // 1MB\n+const STACK_PER_RECURSION: usize = 1024 * 1024; // 1MB\n \n /// Grows the stack on demand to prevent stack overflow. Call this in strategic locations\n /// to \"break up\" recursive calls. E.g. almost any call to `visit_expr` or equivalent can benefit"}, {"sha": "1783b4b357257aa5789e2b3601e069d772d79e98", "filename": "compiler/rustc_data_structures/src/sync/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -84,7 +84,7 @@ impl<T: Copy> AppendOnlyVec<T> {\n     }\n \n     pub fn iter(&self) -> impl Iterator<Item = T> + '_ {\n-        (0..).map(|i| self.get(i)).take_while(|o| o.is_some()).filter_map(|o| o)\n+        (0..).map(|i| self.get(i)).take_while(|o| o.is_some()).flatten()\n     }\n }\n "}, {"sha": "6c8d541463158398178f6a9cc927c537c8cd2431", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -224,7 +224,7 @@ impl<V: Eq + Hash> UnordSet<V> {\n     }\n \n     #[inline]\n-    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+    pub fn items(&self) -> UnordItems<&V, impl Iterator<Item = &V>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -415,7 +415,7 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     }\n \n     #[inline]\n-    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n+    pub fn items(&self) -> UnordItems<(&K, &V), impl Iterator<Item = (&K, &V)>> {\n         UnordItems(self.inner.iter())\n     }\n "}, {"sha": "e09ef34b93dbc405ae0a0105bb42c0ff23e318ff", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -956,7 +956,7 @@ impl Diagnostic {\n     // Exact iteration order of diagnostic arguments shouldn't make a difference to output because\n     // they're only used in interpolation.\n     #[allow(rustc::potential_query_instability)]\n-    pub fn args<'a>(&'a self) -> impl Iterator<Item = DiagnosticArg<'a, 'static>> {\n+    pub fn args(&self) -> impl Iterator<Item = DiagnosticArg<'_, 'static>> {\n         self.args.iter()\n     }\n "}, {"sha": "81e8bcbf7cd54995dad10c325589cc7dd5a15109", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1407,7 +1407,7 @@ impl EmitterWriter {\n                 // Account for newlines to align output to its label.\n                 for (line, text) in normalize_whitespace(&text).lines().enumerate() {\n                     buffer.append(\n-                        0 + line,\n+                        line,\n                         &format!(\n                             \"{}{}\",\n                             if line == 0 { String::new() } else { \" \".repeat(label_width) },\n@@ -1918,7 +1918,7 @@ impl EmitterWriter {\n                         let last_line = unhighlighted_lines.pop();\n                         let first_line = unhighlighted_lines.drain(..).next();\n \n-                        first_line.map(|(p, l)| {\n+                        if let Some((p, l)) = first_line {\n                             self.draw_code_line(\n                                 &mut buffer,\n                                 &mut row_num,\n@@ -1930,12 +1930,12 @@ impl EmitterWriter {\n                                 &file_lines,\n                                 is_multiline,\n                             )\n-                        });\n+                        }\n \n                         buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n                         row_num += 1;\n \n-                        last_line.map(|(p, l)| {\n+                        if let Some((p, l)) = last_line {\n                             self.draw_code_line(\n                                 &mut buffer,\n                                 &mut row_num,\n@@ -1947,7 +1947,7 @@ impl EmitterWriter {\n                                 &file_lines,\n                                 is_multiline,\n                             )\n-                        });\n+                        }\n                     }\n                 }\n "}, {"sha": "4ff8e409d88e3f2cb4d90dc3226557256ec23fac", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -466,7 +466,7 @@ impl<'a> StripUnconfigured<'a> {\n         //\n         // N.B., this is intentionally not part of the visit_expr() function\n         //     in order for filter_map_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(*a)) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n             self.sess.emit_err(RemoveExprNotSupported { span: attr.span });\n         }\n "}, {"sha": "fb3a00d86d4f73a45f12b3cc796aa6bb4e388d64", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -41,7 +41,7 @@ impl MetaVarExpr {\n         };\n         check_trailing_token(&mut tts, sess)?;\n         let mut iter = args.trees();\n-        let rslt = match &*ident.as_str() {\n+        let rslt = match ident.as_str() {\n             \"count\" => parse_count(&mut iter, sess, ident.span)?,\n             \"ignore\" => MetaVarExpr::Ignore(parse_ident(&mut iter, sess, ident.span)?),\n             \"index\" => MetaVarExpr::Index(parse_depth(&mut iter, sess, ident.span)?),"}, {"sha": "8f91a96f964aba3bb73297faaa5f23484c188c72", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -49,7 +49,7 @@ impl LanguageItems {\n         self.get(it).ok_or_else(|| LangItemError(it))\n     }\n \n-    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (LangItem, DefId)> + 'a {\n+    pub fn iter(&self) -> impl Iterator<Item = (LangItem, DefId)> + '_ {\n         self.items\n             .iter()\n             .enumerate()"}, {"sha": "ad76e2bed2023ddf1a59192d841223c9a55d8b33", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -302,7 +302,7 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n                         .iter()\n                         .flatten()\n                         .map(|r| r.impl_blocks.len() as isize - avg as isize)\n-                        .map(|v| v.abs() as usize)\n+                        .map(|v| v.unsigned_abs())\n                         .sum::<usize>();\n                     s / connected_regions.len()\n                 },"}, {"sha": "74f5b359021d291fd86b35dd808fa86f0c257b36", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -242,7 +242,7 @@ pub fn enum_def_to_string(\n impl<'a> State<'a> {\n     pub fn bclose_maybe_open(&mut self, span: rustc_span::Span, close_box: bool) {\n         self.maybe_print_comment(span.hi());\n-        self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n+        self.break_offset_if_not_bol(1, -INDENT_UNIT);\n         self.word(\"}\");\n         if close_box {\n             self.end(); // close the outer-box"}, {"sha": "6c2ce62722a548054339b5709df3550305168074", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -538,8 +538,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 // FIXME(rpitit): This will need to be fixed when we move to associated types\n                                 assert!(matches!(\n                                     *trait_pred.trait_ref.self_ty().kind(),\n-                                    ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n-                                    if def_id == rpit_def_id && substs == substs\n+                                    ty::Alias(_, ty::AliasTy { def_id, substs: alias_substs, .. })\n+                                    if def_id == rpit_def_id && substs == alias_substs\n                                 ));\n                                 ty::PredicateKind::Clause(ty::Clause::Trait(\n                                     trait_pred.with_self_ty(self.tcx, ty),\n@@ -548,8 +548,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::PredicateKind::Clause(ty::Clause::Projection(mut proj_pred)) => {\n                                 assert!(matches!(\n                                     *proj_pred.projection_ty.self_ty().kind(),\n-                                    ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n-                                    if def_id == rpit_def_id && substs == substs\n+                                    ty::Alias(_, ty::AliasTy { def_id, substs: alias_substs, .. })\n+                                    if def_id == rpit_def_id && substs == alias_substs\n                                 ));\n                                 proj_pred = proj_pred.with_self_ty(self.tcx, ty);\n                                 ty::PredicateKind::Clause(ty::Clause::Projection(proj_pred))"}, {"sha": "3e0c2bf2a55382635d472e56c8e207e118fc21dc", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -242,8 +242,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let Some(arg) = segment\n             .args()\n             .args\n-            .iter()\n-            .nth(index) else { return false; };\n+            .get(index) else { return false; };\n         error.obligation.cause.span = arg\n             .span()\n             .find_ancestor_in_same_ctxt(error.obligation.cause.span)"}, {"sha": "3e9a9ce1b31147c02a36631834cc7dc7635b243a", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -526,8 +526,9 @@ impl DropRangesBuilder {\n         let mut next = <_>::from(0u32);\n         for value in tracked_values {\n             for_each_consumable(hir, value, |value| {\n-                if !tracked_value_map.contains_key(&value) {\n-                    tracked_value_map.insert(value, next);\n+                if let std::collections::hash_map::Entry::Vacant(e) = tracked_value_map.entry(value)\n+                {\n+                    e.insert(next);\n                     next = next + 1;\n                 }\n             });"}, {"sha": "5faa6ab13dd7de1a9e8149ade04145d7e02cc086", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -313,8 +313,7 @@ pub fn resolve_interior<'a, 'tcx>(\n     // Extract type components to build the witness type.\n     let type_list = fcx.tcx.mk_type_list_from_iter(type_causes.iter().map(|cause| cause.ty));\n     let bound_vars = fcx.tcx.mk_bound_variable_kinds(&bound_vars);\n-    let witness =\n-        fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars.clone()));\n+    let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars));\n \n     drop(typeck_results);\n     // Store the generator types and spans into the typeck results for this generator."}, {"sha": "08cd6085d7f30d6f4e6f818860361b7936fbf90d", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1764,16 +1764,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n-        let steps = self.steps.clone();\n         self.probe(|_| {\n             let mut pcx = ProbeContext::new(\n                 self.fcx,\n                 self.span,\n                 self.mode,\n                 self.method_name,\n                 self.return_type,\n-                &self.orig_steps_var_values,\n-                steps,\n+                self.orig_steps_var_values,\n+                self.steps,\n                 self.scope_expr_id,\n             );\n             pcx.allow_similar_names = true;"}, {"sha": "271ab830694bb522381a569a848253dc7018b53e", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1850,7 +1850,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n-    pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n+    pub fn iter(&self, row: R) -> impl Iterator<Item = C> + '_ {\n         self.row(row).into_iter().flat_map(|r| r.iter())\n     }\n "}, {"sha": "ae2f52c513e9f4398526ad0ebd9a1a97702282c4", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -201,18 +201,15 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn drain<'a, R: RangeBounds<usize>>(\n-        &'a mut self,\n-        range: R,\n-    ) -> impl Iterator<Item = T> + 'a {\n+    pub fn drain<R: RangeBounds<usize>>(&mut self, range: R) -> impl Iterator<Item = T> + '_ {\n         self.raw.drain(range)\n     }\n \n     #[inline]\n-    pub fn drain_enumerated<'a, R: RangeBounds<usize>>(\n-        &'a mut self,\n+    pub fn drain_enumerated<R: RangeBounds<usize>>(\n+        &mut self,\n         range: R,\n-    ) -> impl Iterator<Item = (I, T)> + 'a {\n+    ) -> impl Iterator<Item = (I, T)> + '_ {\n         let begin = match range.start_bound() {\n             std::ops::Bound::Included(i) => *i,\n             std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),"}, {"sha": "a2a7c93a7ca957428f50531e84b55364c8779548", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -266,12 +266,12 @@ impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n         let LintExpectationId::Stable { attr_id: Some(attr_id), hir_id, attr_index, .. } = id else { bug!(\"unstable expectation id should already be mapped\") };\n         let key = LintExpectationId::Unstable { attr_id, lint_index: None };\n \n-        if !self.unstable_to_stable_ids.contains_key(&key) {\n-            self.unstable_to_stable_ids.insert(\n-                key,\n-                LintExpectationId::Stable { hir_id, attr_index, lint_index: None, attr_id: None },\n-            );\n-        }\n+        self.unstable_to_stable_ids.entry(key).or_insert(LintExpectationId::Stable {\n+            hir_id,\n+            attr_index,\n+            lint_index: None,\n+            attr_id: None,\n+        });\n \n         self.expectations.push((id.normalize(), expectation));\n     }"}, {"sha": "ec3cf34d7109f5ab67e1af763374db5bfde2f83d", "filename": "compiler/rustc_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fsrc%2Flib.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -30,7 +30,7 @@ pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(\n     ptr: *const c_char,\n     size: size_t,\n ) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n+    let slice = slice::from_raw_parts(ptr as *const u8, size);\n \n     sr.bytes.borrow_mut().extend_from_slice(slice);\n }"}, {"sha": "4540ded0f41a33dd29a6fcadc7c8e840f9341d96", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -119,7 +119,7 @@ impl DiagnosticDeriveBuilder {\n impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n     /// Generates calls to `code` and similar functions based on the attributes on the type or\n     /// variant.\n-    pub fn preamble<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n+    pub fn preamble(&mut self, variant: &VariantInfo<'_>) -> TokenStream {\n         let ast = variant.ast();\n         let attrs = &ast.attrs;\n         let preamble = attrs.iter().map(|attr| {\n@@ -133,7 +133,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n \n     /// Generates calls to `span_label` and similar functions based on the attributes on fields or\n     /// calls to `set_arg` when no attributes are present.\n-    pub fn body<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n+    pub fn body(&mut self, variant: &VariantInfo<'_>) -> TokenStream {\n         let mut body = quote! {};\n         // Generate `set_arg` calls first..\n         for binding in variant.bindings().iter().filter(|bi| should_generate_set_arg(bi.ast())) {"}, {"sha": "607d51f5608d38ed56e4fc63d3accfac5946d581", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -100,7 +100,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n             Diagnostic::spanned(\n                 resource_span,\n                 Level::Error,\n-                format!(\"could not open Fluent resource: {}\", e.to_string()),\n+                format!(\"could not open Fluent resource: {e}\"),\n             )\n             .emit();\n             return failed(&crate_name);"}, {"sha": "c6af8d6328983a564f05ea6d666308f1433dd000", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -762,14 +762,14 @@ impl<'a> CrateLocator<'a> {\n     }\n \n     pub(crate) fn into_error(self, root: Option<CratePaths>) -> CrateError {\n-        CrateError::LocatorCombined(CombinedLocatorError {\n+        CrateError::LocatorCombined(Box::new(CombinedLocatorError {\n             crate_name: self.crate_name,\n             root,\n             triple: self.triple,\n             dll_prefix: self.target.dll_prefix.to_string(),\n             dll_suffix: self.target.dll_suffix.to_string(),\n             crate_rejections: self.crate_rejections,\n-        })\n+        }))\n     }\n }\n \n@@ -958,7 +958,7 @@ pub(crate) enum CrateError {\n     StableCrateIdCollision(Symbol, Symbol),\n     DlOpen(String),\n     DlSym(String),\n-    LocatorCombined(CombinedLocatorError),\n+    LocatorCombined(Box<CombinedLocatorError>),\n     NonDylibPlugin(Symbol),\n }\n "}, {"sha": "9d97a75a2fa6f96e728b3c64a3ff7ff345a5d6fb", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -74,18 +74,17 @@ impl<'hir> Iterator for ParentHirIterator<'hir> {\n         if self.current_id == CRATE_HIR_ID {\n             return None;\n         }\n-        loop {\n-            // There are nodes that do not have entries, so we need to skip them.\n-            let parent_id = self.map.parent_id(self.current_id);\n \n-            if parent_id == self.current_id {\n-                self.current_id = CRATE_HIR_ID;\n-                return None;\n-            }\n+        // There are nodes that do not have entries, so we need to skip them.\n+        let parent_id = self.map.parent_id(self.current_id);\n \n-            self.current_id = parent_id;\n-            return Some(parent_id);\n+        if parent_id == self.current_id {\n+            self.current_id = CRATE_HIR_ID;\n+            return None;\n         }\n+\n+        self.current_id = parent_id;\n+        return Some(parent_id);\n     }\n }\n "}, {"sha": "b5b712c367d08d36147ab99664e182d5516c116a", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -80,6 +80,18 @@ impl CanonicalVarValues<'_> {\n             }\n         })\n     }\n+\n+    pub fn is_identity_modulo_regions(&self) -> bool {\n+        self.var_values.iter().enumerate().all(|(bv, arg)| match arg.unpack() {\n+            ty::GenericArgKind::Lifetime(_) => true,\n+            ty::GenericArgKind::Type(ty) => {\n+                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var.as_usize() == bv)\n+            }\n+            ty::GenericArgKind::Const(ct) => {\n+                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc.as_usize() == bv)\n+            }\n+        })\n+    }\n }\n \n /// When we canonicalize a value to form a query, we wind up replacing"}, {"sha": "1a8e48264471c51d17a9851ec52183556e51e048", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -109,26 +109,34 @@ const MAX_HASHED_BUFFER_LEN: usize = 2 * MAX_BYTES_TO_HASH;\n // large.\n impl hash::Hash for Allocation {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        let Self {\n+            bytes,\n+            provenance,\n+            init_mask,\n+            align,\n+            mutability,\n+            extra: (), // don't bother hashing ()\n+        } = self;\n+\n         // Partially hash the `bytes` buffer when it is large. To limit collisions with common\n         // prefixes and suffixes, we hash the length and some slices of the buffer.\n-        let byte_count = self.bytes.len();\n+        let byte_count = bytes.len();\n         if byte_count > MAX_HASHED_BUFFER_LEN {\n             // Hash the buffer's length.\n             byte_count.hash(state);\n \n             // And its head and tail.\n-            self.bytes[..MAX_BYTES_TO_HASH].hash(state);\n-            self.bytes[byte_count - MAX_BYTES_TO_HASH..].hash(state);\n+            bytes[..MAX_BYTES_TO_HASH].hash(state);\n+            bytes[byte_count - MAX_BYTES_TO_HASH..].hash(state);\n         } else {\n-            self.bytes.hash(state);\n+            bytes.hash(state);\n         }\n \n         // Hash the other fields as usual.\n-        self.provenance.hash(state);\n-        self.init_mask.hash(state);\n-        self.align.hash(state);\n-        self.mutability.hash(state);\n-        self.extra.hash(state);\n+        provenance.hash(state);\n+        init_mask.hash(state);\n+        align.hash(state);\n+        mutability.hash(state);\n     }\n }\n "}, {"sha": "56755e588cb45604568c04e1781da272e12b60d3", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -915,7 +915,7 @@ pub enum LocalInfo<'tcx> {\n \n impl<'tcx> LocalDecl<'tcx> {\n     pub fn local_info(&self) -> &LocalInfo<'tcx> {\n-        &**self.local_info.as_ref().assert_crate_local()\n+        &self.local_info.as_ref().assert_crate_local()\n     }\n \n     /// Returns `true` only if local is a binding that can itself be"}, {"sha": "f62853c3e740304e661f13aad808280de4d45c30", "filename": "compiler/rustc_middle/src/mir/patch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -133,21 +133,21 @@ impl<'tcx> MirPatch<'tcx> {\n         let mut new_decl = LocalDecl::new(ty, span).internal();\n         **new_decl.local_info.as_mut().assert_crate_local() = local_info;\n         self.new_locals.push(new_decl);\n-        Local::new(index as usize)\n+        Local::new(index)\n     }\n \n     pub fn new_temp(&mut self, ty: Ty<'tcx>, span: Span) -> Local {\n         let index = self.next_local;\n         self.next_local += 1;\n         self.new_locals.push(LocalDecl::new(ty, span));\n-        Local::new(index as usize)\n+        Local::new(index)\n     }\n \n     pub fn new_internal(&mut self, ty: Ty<'tcx>, span: Span) -> Local {\n         let index = self.next_local;\n         self.next_local += 1;\n         self.new_locals.push(LocalDecl::new(ty, span).internal());\n-        Local::new(index as usize)\n+        Local::new(index)\n     }\n \n     pub fn new_block(&mut self, data: BasicBlockData<'tcx>) -> BasicBlock {"}, {"sha": "4f00abf7fabc148e97b54c1c87a0ac04fe70e962", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -98,7 +98,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                     ty::Array(inner, _) if !from_end => tcx.mk_array(*inner, (to - from) as u64),\n                     ty::Array(inner, size) if from_end => {\n                         let size = size.eval_target_usize(tcx, param_env);\n-                        let len = size - (from as u64) - (to as u64);\n+                        let len = size - from - to;\n                         tcx.mk_array(*inner, len)\n                     }\n                     _ => bug!(\"cannot subslice non-array type: `{:?}`\", self),"}, {"sha": "7d247eeb656c2cfe953f77c21c450a062ece2a32", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -178,17 +178,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         // When we yield `B` and call `traverse_successor`, we push `C` to the stack, but\n         // since we've already visited `E`, that child isn't added to the stack. The last\n         // two iterations yield `C` and finally `A` for a final traversal of [E, D, B, C, A]\n-        loop {\n-            let bb = if let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() {\n-                if let Some(bb) = iter.next() {\n-                    bb\n-                } else {\n-                    break;\n-                }\n-            } else {\n-                break;\n-            };\n-\n+        while let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() && let Some(bb) = iter.next() {\n             if self.visited.insert(bb) {\n                 if let Some(term) = &self.basic_blocks[bb].terminator {\n                     self.visit_stack.push((bb, term.successors()));"}, {"sha": "6a8ae525069c0f8eaa65c8f6bb5ea8c76347f938", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -923,7 +923,7 @@ impl ObjectSafetyViolation {\n                 }\n             }\n             ObjectSafetyViolation::SupertraitNonLifetimeBinder(_) => {\n-                format!(\"where clause cannot reference non-lifetime `for<...>` variables\").into()\n+                \"where clause cannot reference non-lifetime `for<...>` variables\".into()\n             }\n             ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(_), _) => {\n                 format!(\"associated function `{}` has no `self` parameter\", name).into()"}, {"sha": "fef2be133e81f2c5914d5b44bdaed9248100333b", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -56,9 +56,19 @@ pub enum Certainty {\n impl Certainty {\n     pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n \n-    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n-    /// use this function to unify the certainty of these goals\n-    pub fn unify_and(self, other: Certainty) -> Certainty {\n+    /// Use this function to merge the certainty of multiple nested subgoals.\n+    ///\n+    /// Given an impl like `impl<T: Foo + Bar> Baz for T {}`, we have 2 nested\n+    /// subgoals whenever we use the impl as a candidate: `T: Foo` and `T: Bar`.\n+    /// If evaluating `T: Foo` results in ambiguity and `T: Bar` results in\n+    /// success, we merge these two responses. This results in ambiguity.\n+    ///\n+    /// If we unify ambiguity with overflow, we return overflow. This doesn't matter\n+    /// inside of the solver as we distinguish ambiguity from overflow. It does\n+    /// however matter for diagnostics. If `T: Foo` resulted in overflow and `T: Bar`\n+    /// in ambiguity without changing the inference state, we still want to tell the\n+    /// user that `T: Baz` results in overflow.\n+    pub fn unify_with(self, other: Certainty) -> Certainty {\n         match (self, other) {\n             (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n             (Certainty::Yes, Certainty::Maybe(_)) => other,\n@@ -105,7 +115,7 @@ impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n     type Target = ExternalConstraintsData<'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        &*self.0\n+        &self.0\n     }\n }\n "}, {"sha": "c0e557d480d3d0a52e399fa0c45dc4b8fcd81f65", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -337,7 +337,7 @@ impl ScalarInt {\n     /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 16 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i128(self) -> Result<i128, Size> {\n-        self.try_to_int(Size::from_bits(128)).map(|v| i128::try_from(v).unwrap())\n+        self.try_to_int(Size::from_bits(128))\n     }\n }\n "}, {"sha": "c312aaf6819aa955530b1485da845724a72955e2", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -924,7 +924,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             crate_name,\n             // Don't print the whole stable crate id. That's just\n             // annoying in debug output.\n-            stable_crate_id.to_u64() >> 8 * 6,\n+            stable_crate_id.to_u64() >> (8 * 6),\n             self.def_path(def_id).to_string_no_crate_verbose()\n         )\n     }\n@@ -2379,7 +2379,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx [TraitCandidate]> {\n         let map = self.in_scope_traits_map(id.owner)?;\n         let candidates = map.get(&id.local_id)?;\n-        Some(&*candidates)\n+        Some(candidates)\n     }\n \n     pub fn named_bound_var(self, id: HirId) -> Option<resolve_bound_vars::ResolvedArg> {"}, {"sha": "5bbd396d6f3b052bf80233be4bc09ef2bdb2e19a", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1891,7 +1891,7 @@ impl<'tcx> Ty<'tcx> {\n                         // The way we evaluate the `N` in `[T; N]` here only works since we use\n                         // `simd_size_and_type` post-monomorphization. It will probably start to ICE\n                         // if we use it in generic code. See the `simd-array-trait` ui test.\n-                        (f0_len.eval_target_usize(tcx, ParamEnv::empty()) as u64, *f0_elem_ty)\n+                        (f0_len.eval_target_usize(tcx, ParamEnv::empty()), *f0_elem_ty)\n                     }\n                     // Otherwise, the fields of this Adt are the SIMD components (and we assume they\n                     // all have the same type)."}, {"sha": "e41d0f7047b3bd8a9bf3e21afdcb4fa5aa8cc713", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -558,8 +558,8 @@ impl<'a> StringReader<'a> {\n         }\n \n         if let Some(possible_offset) = possible_offset {\n-            let lo = start + BytePos(possible_offset as u32);\n-            let hi = lo + BytePos(found_terminators as u32);\n+            let lo = start + BytePos(possible_offset);\n+            let hi = lo + BytePos(found_terminators);\n             let span = self.mk_sp(lo, hi);\n             err.span_suggestion(\n                 span,"}, {"sha": "1f027c08fc3b5fe8e3fd7a52e124ea93d907eaca", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -336,8 +336,8 @@ const ASCII_ARRAY: &[(&str, &str, Option<token::TokenKind>)] = &[\n     (\"\\\"\", \"Quotation Mark\", None),\n ];\n \n-pub(super) fn check_for_substitution<'a>(\n-    reader: &StringReader<'a>,\n+pub(super) fn check_for_substitution(\n+    reader: &StringReader<'_>,\n     pos: BytePos,\n     ch: char,\n     count: usize,"}, {"sha": "f8ef1307c988e187d13ea1035fbf2b3594b94f15", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -53,7 +53,7 @@ impl<'a> Parser<'a> {\n                 let snapshot = self.create_snapshot_for_diagnostic();\n                 match self.parse_ty() {\n                     Ok(p) => {\n-                        if let TyKind::ImplTrait(_, bounds) = &(*p).kind {\n+                        if let TyKind::ImplTrait(_, bounds) = &p.kind {\n                             let span = impl_span.to(self.token.span.shrink_to_lo());\n                             let mut err = self.struct_span_err(\n                                 span,"}, {"sha": "29f6a07e81bebac0b9852753af5ea24197fb1ffa", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -136,7 +136,9 @@ where\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        self.cache.lock().as_ref().map(|value| f(&(), &value.0, value.1));\n+        if let Some(value) = self.cache.lock().as_ref() {\n+            f(&(), &value.0, value.1)\n+        }\n     }\n }\n "}, {"sha": "31ac3f1c151eee95507534a07e8de3227ec82255", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1224,7 +1224,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             lifetime_ribs: Vec::new(),\n             lifetime_elision_candidates: None,\n             current_trait_ref: None,\n-            diagnostic_metadata: Box::new(DiagnosticMetadata::default()),\n+            diagnostic_metadata: Default::default(),\n             // errors at module scope should always be reported\n             in_func_body: false,\n             lifetime_uses: Default::default(),"}, {"sha": "acfb36c97d0c6fd3a3ec0623eea54954a2ae445c", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1426,7 +1426,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n         opt::opt_s(\n             \"\",\n             \"edition\",\n-            &*EDITION_STRING,\n+            &EDITION_STRING,\n             EDITION_NAME_LIST,\n         ),\n         opt::multi_s("}, {"sha": "15e27952cf50f34a873b5fccd6e7c3bd29c08f74", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -84,12 +84,12 @@ impl SymbolGallery {\n \n /// Construct a diagnostic for a language feature error due to the given `span`.\n /// The `feature`'s `Symbol` is the one you used in `active.rs` and `rustc_span::symbols`.\n-pub fn feature_err<'a>(\n-    sess: &'a ParseSess,\n+pub fn feature_err(\n+    sess: &ParseSess,\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n     explain: impl Into<DiagnosticMessage>,\n-) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n     feature_err_issue(sess, feature, span, GateIssue::Language, explain)\n }\n \n@@ -98,20 +98,21 @@ pub fn feature_err<'a>(\n /// This variant allows you to control whether it is a library or language feature.\n /// Almost always, you want to use this for a language feature. If so, prefer `feature_err`.\n #[track_caller]\n-pub fn feature_err_issue<'a>(\n-    sess: &'a ParseSess,\n+pub fn feature_err_issue(\n+    sess: &ParseSess,\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n     issue: GateIssue,\n     explain: impl Into<DiagnosticMessage>,\n-) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n     let span = span.into();\n \n     // Cancel an earlier warning for this same error, if it exists.\n     if let Some(span) = span.primary_span() {\n-        sess.span_diagnostic\n-            .steal_diagnostic(span, StashKey::EarlySyntaxWarning)\n-            .map(|err| err.cancel());\n+        if let Some(err) = sess.span_diagnostic.steal_diagnostic(span, StashKey::EarlySyntaxWarning)\n+        {\n+            err.cancel()\n+        }\n     }\n \n     let mut err = sess.create_err(FeatureGateError { span, explain: explain.into() });"}, {"sha": "aa8859ed1a358e4871209ca000ad8adf4664a051", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1353,16 +1353,16 @@ impl Clone for SourceFile {\n         Self {\n             name: self.name.clone(),\n             src: self.src.clone(),\n-            src_hash: self.src_hash.clone(),\n+            src_hash: self.src_hash,\n             external_src: Lock::new(self.external_src.borrow().clone()),\n-            start_pos: self.start_pos.clone(),\n-            end_pos: self.end_pos.clone(),\n+            start_pos: self.start_pos,\n+            end_pos: self.end_pos,\n             lines: Lock::new(self.lines.borrow().clone()),\n             multibyte_chars: self.multibyte_chars.clone(),\n             non_narrow_chars: self.non_narrow_chars.clone(),\n             normalized_pos: self.normalized_pos.clone(),\n-            name_hash: self.name_hash.clone(),\n-            cnum: self.cnum.clone(),\n+            name_hash: self.name_hash,\n+            cnum: self.cnum,\n         }\n     }\n }\n@@ -2051,13 +2051,13 @@ pub type FileLinesResult = Result<FileLines, SpanLinesError>;\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanLinesError {\n-    DistinctSources(DistinctSources),\n+    DistinctSources(Box<DistinctSources>),\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanSnippetError {\n     IllFormedSpan(Span),\n-    DistinctSources(DistinctSources),\n+    DistinctSources(Box<DistinctSources>),\n     MalformedForSourcemap(MalformedSourceMapPositions),\n     SourceNotAvailable { filename: FileName },\n }"}, {"sha": "88e3674f8994344460913c8486168b1cfba2f3b2", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -542,10 +542,10 @@ impl SourceMap {\n         let hi = self.lookup_char_pos(sp.hi());\n         trace!(?hi);\n         if lo.file.start_pos != hi.file.start_pos {\n-            return Err(SpanLinesError::DistinctSources(DistinctSources {\n+            return Err(SpanLinesError::DistinctSources(Box::new(DistinctSources {\n                 begin: (lo.file.name.clone(), lo.file.start_pos),\n                 end: (hi.file.name.clone(), hi.file.start_pos),\n-            }));\n+            })));\n         }\n         Ok((lo, hi))\n     }\n@@ -603,10 +603,10 @@ impl SourceMap {\n         let local_end = self.lookup_byte_offset(sp.hi());\n \n         if local_begin.sf.start_pos != local_end.sf.start_pos {\n-            Err(SpanSnippetError::DistinctSources(DistinctSources {\n+            Err(SpanSnippetError::DistinctSources(Box::new(DistinctSources {\n                 begin: (local_begin.sf.name.clone(), local_begin.sf.start_pos),\n                 end: (local_end.sf.name.clone(), local_end.sf.start_pos),\n-            }))\n+            })))\n         } else {\n             self.ensure_source_file_source_present(local_begin.sf.clone());\n "}, {"sha": "5582d909f6b10a5326a66e1adddfe98bb8a91fd2", "filename": "compiler/rustc_target/src/spec/abi.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -324,8 +324,6 @@ impl Abi {\n \n impl fmt::Display for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            abi => write!(f, \"\\\"{}\\\"\", abi.name()),\n-        }\n+        write!(f, \"\\\"{}\\\"\", self.name())\n     }\n }"}, {"sha": "12ee80b6722b1f571958baa3f770a33e7cb5b895", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "renamed", "additions": 28, "deletions": 48, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1,11 +1,9 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::search_graph::OverflowHandler;\n-#[cfg(doc)]\n-use super::trait_goals::structural_traits::*;\n use super::{EvalCtxt, SolverMode};\n+use crate::solve::CanonicalResponseExt;\n use crate::traits::coherence;\n-use itertools::Itertools;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n@@ -16,6 +14,8 @@ use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;\n \n+pub(super) mod structural_traits;\n+\n /// A candidate is a possible way to prove a goal.\n ///\n /// It consists of both the `source`, which describes how that goal would be proven,\n@@ -547,61 +547,41 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// If there are multiple ways to prove a trait or projection goal, we have\n+    /// to somehow try to merge the candidates into one. If that fails, we return\n+    /// ambiguity.\n     #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn merge_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(candidates.pop().unwrap().result),\n-            _ => {}\n+        // First try merging all candidates. This is complete and fully sound.\n+        let responses = candidates.iter().map(|c| c.result).collect::<Vec<_>>();\n+        if let Some(result) = self.try_merge_responses(&responses) {\n+            return Ok(result);\n         }\n \n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n-                    {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n+        // We then check whether we should prioritize `ParamEnv` candidates.\n+        //\n+        // Doing so is incomplete and would therefore be unsound during coherence.\n+        match self.solver_mode() {\n+            SolverMode::Coherence => (),\n+            // Prioritize `ParamEnv` candidates only if they do not guide inference.\n+            //\n+            // This is still incomplete as we may add incorrect region bounds.\n+            SolverMode::Normal => {\n+                let param_env_responses = candidates\n+                    .iter()\n+                    .filter(|c| matches!(c.source, CandidateSource::ParamEnv(_)))\n+                    .map(|c| c.result)\n+                    .collect::<Vec<_>>();\n+                if let Some(result) = self.try_merge_responses(&param_env_responses) {\n+                    if result.has_only_region_constraints() {\n+                        return Ok(result);\n                     }\n                 }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                i += 1;\n             }\n-\n-            // If there are *STILL* multiple candidates that have *different* response\n-            // results, give up and report ambiguity.\n-            if candidates.len() > 1 && !candidates.iter().map(|cand| cand.result).all_equal() {\n-                let certainty = if candidates.iter().all(|x| {\n-                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n-                }) {\n-                    Certainty::Maybe(MaybeCause::Overflow)\n-                } else {\n-                    Certainty::AMBIGUOUS\n-                };\n-                return self.evaluate_added_goals_and_make_canonical_response(certainty);\n-            }\n-        }\n-\n-        Ok(candidates.pop().unwrap().result)\n-    }\n-\n-    fn candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::AliasBound, _)\n-            | (CandidateSource::BuiltinImpl, _) => false,\n         }\n+        self.flounder(&responses)\n     }\n }", "previous_filename": "compiler/rustc_trait_selection/src/solve/assembly.rs"}, {"sha": "cbec39d82856e2862d6226c8be03e48dd5c970ea", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "renamed", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -11,7 +11,7 @@ use crate::solve::EvalCtxt;\n //\n // For types with an \"existential\" binder, i.e. generator witnesses, we also\n // instantiate the binder with placeholders eagerly.\n-pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n+pub(in crate::solve) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -87,7 +87,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n     }\n }\n \n-fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n+pub(in crate::solve) fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> ty::Binder<'tcx, Ty<'tcx>> {\n@@ -108,7 +108,7 @@ fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n     ty::Binder::bind_with_vars(ty, bound_vars)\n }\n \n-pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n+pub(in crate::solve) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -158,7 +158,7 @@ pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n     }\n }\n \n-pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n+pub(in crate::solve) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -224,7 +224,7 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n }\n \n // Returns a binder of the tupled inputs types and output type from a builtin callable type.\n-pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n+pub(in crate::solve) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     self_ty: Ty<'tcx>,\n     goal_kind: ty::ClosureKind,\n@@ -337,7 +337,13 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n /// additional step of eagerly folding the associated types in the where\n /// clauses of the impl. In this example, that means replacing\n /// `<Self as Foo>::Bar` with `Ty` in the first impl.\n-pub(crate) fn predicates_for_object_candidate<'tcx>(\n+///\n+// FIXME: This is only necessary as `<Self as Trait>::Assoc: ItemBound`\n+// bounds in impls are trivially proven using the item bound candidates.\n+// This is unsound in general and once that is fixed, we don't need to\n+// normalize eagerly here. See https://github.com/lcnr/solver-woes/issues/9\n+// for more details.\n+pub(in crate::solve) fn predicates_for_object_candidate<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,", "previous_filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs"}, {"sha": "28aca76cceb6696633ba7a725a1d4be9655c4c15", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -357,7 +357,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                             // deal with `has_changed` in the next iteration.\n                             new_goals.normalizes_to_hack_goal =\n                                 Some(this.resolve_vars_if_possible(goal));\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                            has_changed = has_changed.map_err(|c| c.unify_with(certainty));\n                         }\n                     }\n                 }\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n                             new_goals.goals.push(goal);\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                            has_changed = has_changed.map_err(|c| c.unify_with(certainty));\n                         }\n                     }\n                 }"}, {"sha": "861fa0a305ac0184c9beeeab91fa53d58f1e4a85", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         certainty: Certainty,\n     ) -> QueryResult<'tcx> {\n         let goals_certainty = self.try_evaluate_added_goals()?;\n-        let certainty = certainty.unify_and(goals_certainty);\n+        let certainty = certainty.unify_with(goals_certainty);\n \n         let external_constraints = self.compute_external_query_constraints()?;\n "}, {"sha": "19bcbd461447d75c915abbae9b7f8ada593cee9a", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -46,6 +46,8 @@ enum SolverMode {\n \n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n+\n+    fn has_only_region_constraints(&self) -> bool;\n }\n \n impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n@@ -54,6 +56,11 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n             && self.value.var_values.is_identity()\n             && self.value.external_constraints.opaque_types.is_empty()\n     }\n+\n+    fn has_only_region_constraints(&self) -> bool {\n+        self.value.var_values.is_identity_modulo_regions()\n+            && self.value.external_constraints.opaque_types.is_empty()\n+    }\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n@@ -221,12 +228,17 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             (Some(alias_lhs), Some(alias_rhs)) => {\n                 debug!(\"both sides are aliases\");\n \n-                let candidates = vec![\n-                    // LHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No),\n-                    // RHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes),\n-                    // Relate via substs\n+                let mut candidates = Vec::new();\n+                // LHS normalizes-to RHS\n+                candidates.extend(\n+                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No).ok(),\n+                );\n+                // RHS normalizes-to RHS\n+                candidates.extend(\n+                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes).ok(),\n+                );\n+                // Relate via substs\n+                candidates.extend(\n                     self.probe(|ecx| {\n                         let span = tracing::span!(\n                             tracing::Level::DEBUG,\n@@ -247,11 +259,16 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                         }\n \n                         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                    }),\n-                ];\n+                    })\n+                    .ok(),\n+                );\n                 debug!(?candidates);\n \n-                self.try_merge_responses(candidates.into_iter())\n+                if let Some(merged) = self.try_merge_responses(&candidates) {\n+                    Ok(merged)\n+                } else {\n+                    self.flounder(&candidates)\n+                }\n             }\n         }\n     }\n@@ -289,43 +306,51 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n     }\n \n-    #[instrument(level = \"debug\", skip(self, responses))]\n+    /// Try to merge multiple possible ways to prove a goal, if that is not possible returns `None`.\n+    ///\n+    /// In this case we tend to flounder and return ambiguity by calling `[EvalCtxt::flounder]`.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn try_merge_responses(\n         &mut self,\n-        responses: impl Iterator<Item = QueryResult<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        let candidates = responses.into_iter().flatten().collect::<Box<[_]>>();\n-\n-        if candidates.is_empty() {\n-            return Err(NoSolution);\n+        responses: &[CanonicalResponse<'tcx>],\n+    ) -> Option<CanonicalResponse<'tcx>> {\n+        if responses.is_empty() {\n+            return None;\n         }\n \n         // FIXME(-Ztrait-solver=next): We should instead try to find a `Certainty::Yes` response with\n         // a subset of the constraints that all the other responses have.\n-        let one = candidates[0];\n-        if candidates[1..].iter().all(|resp| resp == &one) {\n-            return Ok(one);\n+        let one = responses[0];\n+        if responses[1..].iter().all(|&resp| resp == one) {\n+            return Some(one);\n         }\n \n-        if let Some(response) = candidates.iter().find(|response| {\n-            response.value.certainty == Certainty::Yes\n-                && response.has_no_inference_or_external_constraints()\n-        }) {\n-            return Ok(*response);\n-        }\n+        responses\n+            .iter()\n+            .find(|response| {\n+                response.value.certainty == Certainty::Yes\n+                    && response.has_no_inference_or_external_constraints()\n+            })\n+            .copied()\n+    }\n \n-        let certainty = candidates.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n-            certainty.unify_and(response.value.certainty)\n+    /// If we fail to merge responses we flounder and return overflow or ambiguity.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn flounder(&mut self, responses: &[CanonicalResponse<'tcx>]) -> QueryResult<'tcx> {\n+        if responses.is_empty() {\n+            return Err(NoSolution);\n+        }\n+        let certainty = responses.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n+            certainty.unify_with(response.value.certainty)\n         });\n-        // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n-        // responses and use that for the constraints of this ambiguous response.\n-        debug!(\">1 response, bailing with {certainty:?}\");\n+\n         let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n-        if let Ok(response) = &response {\n+        if let Ok(response) = response {\n             assert!(response.has_no_inference_or_external_constraints());\n+            Ok(response)\n+        } else {\n+            bug!(\"failed to make floundered response: {responses:?}\");\n         }\n-\n-        response\n     }\n }\n "}, {"sha": "2a47da81ec760aedea5abcdbd1f9543e7ccf7e89", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1,7 +1,6 @@\n use crate::traits::specialization_graph;\n \n-use super::assembly;\n-use super::trait_goals::structural_traits;\n+use super::assembly::{self, structural_traits};\n use super::EvalCtxt;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;"}, {"sha": "81f89fd950c8d29e29f2f338ef84ec9ba8ce39d9", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1,6 +1,7 @@\n //! Dealing with trait goals, i.e. `T: Trait<'a, U>`.\n \n-use super::{assembly, EvalCtxt, SolverMode};\n+use super::assembly::{self, structural_traits};\n+use super::{EvalCtxt, SolverMode};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n@@ -11,8 +12,6 @@ use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n \n-pub mod structural_traits;\n-\n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()"}, {"sha": "a93a42987ed5399404ad6ef561f19dbb156f770a", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -149,7 +149,7 @@ mod rustc {\n                     .iter()\n                     .enumerate()\n                     .find(|(_, field_def)| name == field_def.name)\n-                    .expect(&format!(\"There were no fields named `{name}`.\"));\n+                    .unwrap_or_else(|| panic!(\"There were no fields named `{name}`.\"));\n                 fields[field_idx].unwrap_leaf() == ScalarInt::TRUE\n             };\n "}, {"sha": "9c6d48675a6b1ada6dbc5d3b09b4152f75db411e", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1241,13 +1241,9 @@ impl<T> MaybeUninit<T> {\n     /// ```\n     #[unstable(feature = \"maybe_uninit_as_bytes\", issue = \"93092\")]\n     pub fn slice_as_bytes(this: &[MaybeUninit<T>]) -> &[MaybeUninit<u8>] {\n+        let bytes = mem::size_of_val(this);\n         // SAFETY: MaybeUninit<u8> is always valid, even for padding bytes\n-        unsafe {\n-            slice::from_raw_parts(\n-                this.as_ptr() as *const MaybeUninit<u8>,\n-                this.len() * mem::size_of::<T>(),\n-            )\n-        }\n+        unsafe { slice::from_raw_parts(this.as_ptr() as *const MaybeUninit<u8>, bytes) }\n     }\n \n     /// Returns the contents of this mutable slice of `MaybeUninit` as a mutable slice of\n@@ -1274,13 +1270,9 @@ impl<T> MaybeUninit<T> {\n     /// ```\n     #[unstable(feature = \"maybe_uninit_as_bytes\", issue = \"93092\")]\n     pub fn slice_as_bytes_mut(this: &mut [MaybeUninit<T>]) -> &mut [MaybeUninit<u8>] {\n+        let bytes = mem::size_of_val(this);\n         // SAFETY: MaybeUninit<u8> is always valid, even for padding bytes\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                this.as_mut_ptr() as *mut MaybeUninit<u8>,\n-                this.len() * mem::size_of::<T>(),\n-            )\n-        }\n+        unsafe { slice::from_raw_parts_mut(this.as_mut_ptr() as *mut MaybeUninit<u8>, bytes) }\n     }\n }\n "}, {"sha": "f9387a0fc80bf07bda28a1aa5a06415a05be3539", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -271,9 +271,17 @@ impl Step for Rustc {\n             false,\n         );\n \n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(&builder, &libdir, &hostdir, &librustc_stamp(builder, compiler, target));\n+        // HACK: This avoids putting the newly built artifacts in the sysroot if we're using\n+        // `download-rustc`, to avoid \"multiple candidates for `rmeta`\" errors. Technically, that's\n+        // not quite right: people can set `download-rustc = true` to download even if there are\n+        // changes to the compiler, and in that case ideally we would put the *new* artifacts in the\n+        // sysroot, in case there are API changes that should be used by tools.  In practice,\n+        // though, that should be very uncommon, and people can still disable download-rustc.\n+        if !builder.download_rustc() {\n+            let libdir = builder.sysroot_libdir(compiler, target);\n+            let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+            add_to_sysroot(&builder, &libdir, &hostdir, &librustc_stamp(builder, compiler, target));\n+        }\n     }\n }\n "}, {"sha": "a7efe16150eae8286d4b64943c7e40cd20be7312", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -6,6 +6,7 @@ use std::io::BufReader;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use build_helper::ci::CiEnv;\n use tracing::*;\n \n use crate::common::{Config, Debugger, FailMode, Mode, PassMode};\n@@ -276,8 +277,12 @@ impl TestProps {\n     /// `//[foo]`), then the property is ignored unless `cfg` is\n     /// `Some(\"foo\")`.\n     fn load_from(&mut self, testfile: &Path, cfg: Option<&str>, config: &Config) {\n-        // Mode-dependent defaults.\n-        self.remap_src_base = config.mode == Mode::Ui && !config.suite.contains(\"rustdoc\");\n+        // In CI, we've sometimes encountered non-determinism related to truncating very long paths.\n+        // Set a consistent (short) prefix to avoid issues, but only in CI to avoid regressing the\n+        // contributor experience.\n+        if CiEnv::is_ci() {\n+            self.remap_src_base = config.mode == Mode::Ui && !config.suite.contains(\"rustdoc\");\n+        }\n \n         let mut has_edition = false;\n         if !testfile.is_dir() {"}, {"sha": "99d258c62040fed5c5cc72b84d84b759c9352d04", "filename": "tests/codegen/intrinsics/transmute-x64.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+// only-x86_64 (it's using arch-specific types)\n+// min-llvm-version: 15.0 # this test assumes `ptr`s\n+\n+#![crate_type = \"lib\"]\n+\n+use std::arch::x86_64::{__m128, __m128i, __m256i};\n+use std::mem::transmute;\n+\n+// CHECK-LABEL: @check_sse_float_to_int(\n+#[no_mangle]\n+pub unsafe fn check_sse_float_to_int(x: __m128) -> __m128i {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x float>, ptr %x, align 16\n+    // CHECK: store <4 x float> %1, ptr %0, align 16\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_sse_pair_to_avx(\n+#[no_mangle]\n+pub unsafe fn check_sse_pair_to_avx(x: (__m128i, __m128i)) -> __m256i {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x i64>, ptr %x, align 16\n+    // CHECK: store <4 x i64> %1, ptr %0, align 32\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_sse_pair_from_avx(\n+#[no_mangle]\n+pub unsafe fn check_sse_pair_from_avx(x: __m256i) -> (__m128i, __m128i) {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x i64>, ptr %x, align 32\n+    // CHECK: store <4 x i64> %1, ptr %0, align 16\n+    transmute(x)\n+}"}, {"sha": "57f901c6719921b284e79863307ed9462c154b2a", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 130, "deletions": 2, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -8,7 +8,7 @@\n #![feature(inline_const)]\n #![allow(unreachable_code)]\n \n-use std::mem::transmute;\n+use std::mem::{transmute, MaybeUninit};\n \n // Some of the cases here are statically rejected by `mem::transmute`, so\n // we need to generate custom MIR for those cases to get to codegen.\n@@ -54,6 +54,32 @@ pub unsafe fn check_smaller_size(x: u32) -> u16 {\n     }\n }\n \n+// CHECK-LABEL: @check_smaller_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_smaller_array(x: [u32; 7]) -> [u32; 3] {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_bigger_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_bigger_array(x: [u32; 3]) -> [u32; 7] {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_to_uninhabited(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n@@ -71,7 +97,7 @@ pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n pub unsafe fn check_from_uninhabited(x: BigNever) -> u16 {\n-    // CHECK: call void @llvm.trap\n+    // CHECK: ret i16 poison\n     mir!{\n         {\n             RET = CastTransmute(x);\n@@ -301,3 +327,105 @@ pub unsafe fn check_pair_to_array(x: (i64, u64)) -> [u8; 16] {\n     // CHECK: store i64 %x.1, ptr %{{.+}}, align 1\n     transmute(x)\n }\n+\n+// CHECK-LABEL: @check_heterogeneous_integer_pair(\n+#[no_mangle]\n+pub unsafe fn check_heterogeneous_integer_pair(x: (i32, bool)) -> (bool, u32) {\n+    // CHECK: store i32 %x.0\n+    // CHECK: %[[WIDER:.+]] = zext i1 %x.1 to i8\n+    // CHECK: store i8 %[[WIDER]]\n+\n+    // CHECK: %[[BYTE:.+]] = load i8\n+    // CHECK: trunc i8 %[[BYTE:.+]] to i1\n+    // CHECK: load i32\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_heterogeneous_float_pair(\n+#[no_mangle]\n+pub unsafe fn check_heterogeneous_float_pair(x: (f64, f32)) -> (f32, f64) {\n+    // CHECK: store double %x.0\n+    // CHECK: store float %x.1\n+    // CHECK: %[[A:.+]] = load float\n+    // CHECK: %[[B:.+]] = load double\n+    // CHECK: %[[P:.+]] = insertvalue { float, double } poison, float %[[A]], 0\n+    // CHECK: insertvalue { float, double } %[[P]], double %[[B]], 1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_issue_110005(\n+#[no_mangle]\n+pub unsafe fn check_issue_110005(x: (usize, bool)) -> Option<Box<[u8]>> {\n+    // CHECK: store i64 %x.0\n+    // CHECK: %[[WIDER:.+]] = zext i1 %x.1 to i8\n+    // CHECK: store i8 %[[WIDER]]\n+    // CHECK: load ptr\n+    // CHECK: load i64\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_pair_to_dst_ref(\n+#[no_mangle]\n+pub unsafe fn check_pair_to_dst_ref<'a>(x: (usize, usize)) -> &'a [u8] {\n+    // CHECK: %0 = inttoptr i64 %x.0 to ptr\n+    // CHECK: %1 = insertvalue { ptr, i64 } poison, ptr %0, 0\n+    // CHECK: %2 = insertvalue { ptr, i64 } %1, i64 %x.1, 1\n+    // CHECK: ret { ptr, i64 } %2\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_issue_109992(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_issue_109992(x: ()) -> [(); 1] {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK: start\n+    // CHECK-NEXT: ret void\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_maybe_uninit_pair(i16 %x.0, i64 %x.1)\n+#[no_mangle]\n+pub unsafe fn check_maybe_uninit_pair(\n+    x: (MaybeUninit<u16>, MaybeUninit<u64>),\n+) -> (MaybeUninit<i64>, MaybeUninit<i16>) {\n+    // Thanks to `MaybeUninit` this is actually defined behaviour,\n+    // unlike the examples above with pairs of primitives.\n+\n+    // CHECK: store i16 %x.0\n+    // CHECK: store i64 %x.1\n+    // CHECK: load i64\n+    // CHECK-NOT: noundef\n+    // CHECK: load i16\n+    // CHECK-NOT: noundef\n+    // CHECK: ret { i64, i16 }\n+    transmute(x)\n+}\n+\n+#[repr(align(8))]\n+pub struct HighAlignScalar(u8);\n+\n+// CHECK-LABEL: @check_to_overalign(\n+#[no_mangle]\n+pub unsafe fn check_to_overalign(x: u64) -> HighAlignScalar {\n+    // CHECK: %0 = alloca %HighAlignScalar, align 8\n+    // CHECK: store i64 %x, ptr %0, align 8\n+    // CHECK: %1 = load i64, ptr %0, align 8\n+    // CHECK: ret i64 %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_overalign(\n+#[no_mangle]\n+pub unsafe fn check_from_overalign(x: HighAlignScalar) -> u64 {\n+    // CHECK: %x = alloca %HighAlignScalar, align 8\n+    // CHECK: %[[VAL:.+]] = load i64, ptr %x, align 8\n+    // CHECK: ret i64 %[[VAL]]\n+    transmute(x)\n+}"}, {"sha": "bcb201bf0c3796bb0a6c9ac3039ae436b86befcf", "filename": "tests/ui/higher-rank-trait-bounds/issue-95230.new.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.new.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.new.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.new.stderr?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -0,0 +1,18 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-95230.rs:9:13\n+   |\n+LL |     for<'a> &'a mut Self:;\n+   |             ^^^^^^^^^^^^ cannot infer type for mutable reference `&'a mut Bar`\n+   |\n+note: required by a bound in `Bar`\n+  --> $DIR/issue-95230.rs:9:13\n+   |\n+LL | pub struct Bar\n+   |            --- required by a bound in this struct\n+LL | where\n+LL |     for<'a> &'a mut Self:;\n+   |             ^^^^^^^^^^^^ required by this bound in `Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "769b6a9253769a44edf9b1fdc8aa04d3feac63fe", "filename": "tests/ui/higher-rank-trait-bounds/issue-95230.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1,4 +1,8 @@\n-// check-pass\n+// revisions: old new\n+//[new] compile-flags: -Ztrait-solver=next\n+//[old] check-pass\n+//[new] known-bug: #109764\n+\n \n pub struct Bar\n where"}, {"sha": "531203d9c64f7875366240e5a33d0a1dbf9cfd87", "filename": "tests/ui/traits/new-solver/alias_eq_dont_use_normalizes_to_if_substs_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: -Ztrait-solver=next\n \n // check that when computing `alias-eq(<() as Foo<u16, T>>::Assoc, <() as Foo<?0, T>>::Assoc)`\n-//  we do not infer `?0 = u8` via the `for<STOP> (): Foo<u8, STOP>` impl or `?0 = u16` by\n+// we do not infer `?0 = u8` via the `for<STOP> (): Foo<u8, STOP>` impl or `?0 = u16` by\n // relating substs as either could be a valid solution.\n \n trait Foo<T, STOP> {"}, {"sha": "6f8164f3a40f0aaffec91eb308f1571de92c42e9", "filename": "tests/ui/traits/new-solver/prefer-candidate-no-constraints.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Foo {}\n+\n+impl<T> Foo for T {}\n+\n+trait Bar {}\n+\n+struct Wrapper<'a, T>(&'a T);\n+\n+impl<'a, T> Bar for Wrapper<'a, T> where &'a T: Foo {}\n+// We need to satisfy `&'a T: Foo` when checking that this impl is WF\n+// that can either be satisfied via the param-env, or via an impl.\n+//\n+// When satisfied via the param-env, since each lifetime is canonicalized\n+// separately, we end up getting extra region constraints.\n+//\n+// However, when satisfied via the impl, there are no region constraints,\n+// and we can short-circuit a response with no external constraints.\n+\n+fn main() {}"}, {"sha": "909b33ec3d5a508b19c1a85c6cac37da9ba2f2b7", "filename": "tests/ui/traits/new-solver/prefer-param-env-on-ambiguity.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Foo<'a> {}\n+trait Bar<'a> {}\n+\n+impl<'a, T: Bar<'a>> Foo<'a> for T {}\n+impl<T> Bar<'static> for T {}\n+\n+fn main() {}"}, {"sha": "e3a92e85e17e4a846a965cda0d8c4ccf525c08b3", "filename": "tests/ui/traits/new-solver/recursive-self-normalization-2.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1,9 +1,16 @@\n-error[E0282]: type annotations needed\n+error[E0283]: type annotations needed: cannot satisfy `<T as Foo1>::Assoc1: Bar`\n   --> $DIR/recursive-self-normalization-2.rs:15:5\n    |\n LL |     needs_bar::<T::Assoc1>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: cannot satisfy `<T as Foo1>::Assoc1: Bar`\n+note: required by a bound in `needs_bar`\n+  --> $DIR/recursive-self-normalization-2.rs:12:17\n+   |\n+LL | fn needs_bar<S: Bar>() {}\n+   |                 ^^^ required by this bound in `needs_bar`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "773007aebaa63aa0d03236b81dbc7d8c771aae45", "filename": "tests/ui/traits/new-solver/recursive-self-normalization.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr?ref=d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "patch": "@@ -1,9 +1,16 @@\n-error[E0282]: type annotations needed\n+error[E0283]: type annotations needed: cannot satisfy `<T as Foo>::Assoc: Bar`\n   --> $DIR/recursive-self-normalization.rs:11:5\n    |\n LL |     needs_bar::<T::Assoc>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: cannot satisfy `<T as Foo>::Assoc: Bar`\n+note: required by a bound in `needs_bar`\n+  --> $DIR/recursive-self-normalization.rs:8:17\n+   |\n+LL | fn needs_bar<S: Bar>() {}\n+   |                 ^^^ required by this bound in `needs_bar`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0283`."}]}