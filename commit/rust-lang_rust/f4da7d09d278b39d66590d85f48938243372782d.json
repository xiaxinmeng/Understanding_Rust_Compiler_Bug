{"sha": "f4da7d09d278b39d66590d85f48938243372782d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZGE3ZDA5ZDI3OGIzOWQ2NjU5MGQ4NWY0ODkzODI0MzM3Mjc4MmQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-19T02:53:04Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-19T02:53:04Z"}, "message": "Upgrade Rust to rustc 1.5.0-nightly (cff041170 2015-09-17)\n\nLintPass was split and ExprParen was removed from the HIR\n\nFixes #338", "tree": {"sha": "bc13b2026ee19d0e5e13af6521b5f3b9323e6e55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc13b2026ee19d0e5e13af6521b5f3b9323e6e55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4da7d09d278b39d66590d85f48938243372782d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4da7d09d278b39d66590d85f48938243372782d", "html_url": "https://github.com/rust-lang/rust/commit/f4da7d09d278b39d66590d85f48938243372782d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4da7d09d278b39d66590d85f48938243372782d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "862c195fa176f476354727817ea0370e9ddc664b", "url": "https://api.github.com/repos/rust-lang/rust/commits/862c195fa176f476354727817ea0370e9ddc664b", "html_url": "https://github.com/rust-lang/rust/commit/862c195fa176f476354727817ea0370e9ddc664b"}], "stats": {"total": 418, "additions": 238, "deletions": 180}, "files": [{"sha": "4ff702de4a581acf9a21fc5046c8c6e66e7aec18", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.14\"\n+version = \"0.0.15\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\","}, {"sha": "9a186a4f8cdd9ee47bf24685aa2d579db4dda418", "filename": "src/approx_const.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -29,15 +29,17 @@ impl LintPass for ApproxConstant {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(APPROX_CONSTANT)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+impl LateLintPass for ApproxConstant {\n+    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let &ExprLit(ref lit) = &e.node {\n             check_lit(cx, lit, e);\n         }\n     }\n }\n \n-fn check_lit(cx: &Context, lit: &Lit, e: &Expr) {\n+fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     match lit.node {\n         LitFloat(ref str, TyF32) => check_known_consts(cx, e, str, \"f32\"),\n         LitFloat(ref str, TyF64) => check_known_consts(cx, e, str, \"f64\"),\n@@ -47,7 +49,7 @@ fn check_lit(cx: &Context, lit: &Lit, e: &Expr) {\n     }\n }\n \n-fn check_known_consts(cx: &Context, e: &Expr, str: &str, module: &str) {\n+fn check_known_consts(cx: &LateContext, e: &Expr, str: &str, module: &str) {\n     if let Ok(value) = str.parse::<f64>() {\n         for &(constant, name) in KNOWN_CONSTS {\n             if !within_epsilon(constant, value) { continue; }"}, {"sha": "6450cc16195931f7e761ed5128f62dc15f028c74", "filename": "src/attrs.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -19,20 +19,22 @@ impl LintPass for AttrPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(INLINE_ALWAYS)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &Item) {\n+impl LateLintPass for AttrPass {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if is_relevant_item(item) {\n             check_attrs(cx, item.span, &item.ident, &item.attrs)\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n         if is_relevant_impl(item) {\n             check_attrs(cx, item.span, &item.ident, &item.attrs)\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         if is_relevant_trait(item) {\n             check_attrs(cx, item.span, &item.ident, &item.attrs)\n         }\n@@ -75,8 +77,7 @@ fn is_relevant_block(block: &Block) -> bool {\n fn is_relevant_expr(expr: &Expr) -> bool {\n     match expr.node {\n         ExprBlock(ref block) => is_relevant_block(block),\n-        ExprRet(Some(ref e)) | ExprParen(ref e) =>\n-            is_relevant_expr(e),\n+        ExprRet(Some(ref e)) => is_relevant_expr(e),\n         ExprRet(None) | ExprBreak(_) => false,\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(_, ref path) = path_expr.node {\n@@ -87,7 +88,7 @@ fn is_relevant_expr(expr: &Expr) -> bool {\n     }\n }\n \n-fn check_attrs(cx: &Context, span: Span, ident: &Ident,\n+fn check_attrs(cx: &LateContext, span: Span, ident: &Ident,\n         attrs: &[Attribute]) {\n     if in_macro(cx, span) { return; }\n "}, {"sha": "d99497aafe965c419f6cc6cb8fcf010dcf024ece", "filename": "src/bit_mask.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -54,8 +54,10 @@ impl LintPass for BitMask {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BAD_BIT_MASK, INEFFECTIVE_BIT_MASK)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+impl LateLintPass for BitMask {\n+    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             if is_comparison_binop(cmp.node) {\n                 fetch_int_literal(cx, right).map_or_else(||\n@@ -82,9 +84,8 @@ fn invert_cmp(cmp : BinOp_) -> BinOp_ {\n }\n \n \n-fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n+fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n     match bit_op.node {\n-        ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n         ExprBinary(ref op, ref left, ref right) => {\n             if op.node != BiBitAnd && op.node != BiBitOr { return; }\n             fetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n@@ -95,7 +96,7 @@ fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, sp\n     }\n }\n \n-fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n+fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_,\n                   mask_value: u64, cmp_value: u64, span: &Span) {\n     match cmp_op {\n         BiEq | BiNe => match bit_op {\n@@ -163,23 +164,23 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n     }\n }\n \n-fn check_ineffective_lt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n+fn check_ineffective_lt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str) {\n     if c.is_power_of_two() && m < c {\n         span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n             \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n             op, m, c));\n     }\n }\n \n-fn check_ineffective_gt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n+fn check_ineffective_gt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n         span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n             \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n             op, m, c));\n     }\n }\n \n-fn fetch_int_literal(cx: &Context, lit : &Expr) -> Option<u64> {\n+fn fetch_int_literal(cx: &LateContext, lit : &Expr) -> Option<u64> {\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n             if let &LitInt(value, _) = &lit_ptr.node {"}, {"sha": "78e3ec5e35f83dd3f5ef990e32c7d0e33b5faed6", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -32,15 +32,17 @@ impl LintPass for CollapsibleIf {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(COLLAPSIBLE_IF)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for CollapsibleIf {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if !in_macro(cx, expr.span) {\n             check_if(cx, expr)\n         }\n     }\n }\n \n-fn check_if(cx: &Context, e: &Expr) {\n+fn check_if(cx: &LateContext, e: &Expr) {\n     if let ExprIf(ref check, ref then, None) = e.node {\n         if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n             single_stmt_of_block(then) {\n@@ -63,7 +65,7 @@ fn requires_brackets(e: &Expr) -> bool {\n     }\n }\n \n-fn check_to_string(cx: &Context, e: &Expr) -> String {\n+fn check_to_string(cx: &LateContext, e: &Expr) -> String {\n     if requires_brackets(e) {\n         format!(\"({})\", snippet(cx, e.span, \"..\"))\n     } else {"}, {"sha": "d66bfb5b4fc8ddbde448626721024025a0541e09", "filename": "src/consts.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -1,6 +1,6 @@\n #![allow(cast_possible_truncation)]\n \n-use rustc::lint::Context;\n+use rustc::lint::LateContext;\n use rustc::middle::const_eval::lookup_const_by_id;\n use rustc::middle::def::PathResolution;\n use rustc::middle::def::Def::*;\n@@ -287,27 +287,26 @@ fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: bool) ->\n }\n \n \n-pub fn constant(lcx: &Context, e: &Expr) -> Option<(Constant, bool)> {\n-    let mut cx = ConstEvalContext { lcx: Some(lcx), needed_resolution: false };\n+pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n+    let mut cx = ConstEvalLateContext { lcx: Some(lcx), needed_resolution: false };\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n pub fn constant_simple(e: &Expr) -> Option<Constant> {\n-    let mut cx = ConstEvalContext { lcx: None, needed_resolution: false };\n+    let mut cx = ConstEvalLateContext { lcx: None, needed_resolution: false };\n     cx.expr(e)\n }\n \n-struct ConstEvalContext<'c, 'cc: 'c> {\n-    lcx: Option<&'c Context<'c, 'cc>>,\n+struct ConstEvalLateContext<'c, 'cc: 'c> {\n+    lcx: Option<&'c LateContext<'c, 'cc>>,\n     needed_resolution: bool\n }\n \n-impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n+impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n \n     /// simple constant folding: Insert an expression, get a constant or none.\n     fn expr(&mut self, e: &Expr) -> Option<Constant> {\n         match e.node {\n-            ExprParen(ref inner) => self.expr(inner),\n             ExprPath(_, _) => self.fetch_path(e),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) =>"}, {"sha": "6f305b6adf8e14db054f235df0d6042644a75114", "filename": "src/eq_op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -19,8 +19,10 @@ impl LintPass for EqOp {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(EQ_OP)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+impl LateLintPass for EqOp {\n+    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_cmp_or_bit(op) && is_exp_equal(cx, left, right) {\n                 span_lint(cx, EQ_OP, e.span, &format!(\n@@ -31,7 +33,7 @@ impl LintPass for EqOp {\n     }\n }\n \n-pub fn is_exp_equal(cx: &Context, left : &Expr, right : &Expr) -> bool {\n+pub fn is_exp_equal(cx: &LateContext, left : &Expr, right : &Expr) -> bool {\n     if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n         if l == r {\n             return true;\n@@ -42,8 +44,6 @@ pub fn is_exp_equal(cx: &Context, left : &Expr, right : &Expr) -> bool {\n                 &ExprField(ref rfexp, ref rfident)) =>\n             lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp),\n         (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-        (&ExprParen(ref lparen), _) => is_exp_equal(cx, lparen, right),\n-        (_, &ExprParen(ref rparen)) => is_exp_equal(cx, left, rparen),\n         (&ExprPath(ref lqself, ref lsubpath),\n                 &ExprPath(ref rqself, ref rsubpath)) =>\n             both(lqself, rqself, is_qself_equal) &&\n@@ -57,7 +57,7 @@ pub fn is_exp_equal(cx: &Context, left : &Expr, right : &Expr) -> bool {\n     }\n }\n \n-fn is_exps_equal(cx: &Context, left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n+fn is_exps_equal(cx: &LateContext, left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n     over(left, right, |l, r| is_exp_equal(cx, l, r))\n }\n "}, {"sha": "7226a4bad05a696d60c9dffedd4a8e1b12ec5af7", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -16,8 +16,10 @@ impl LintPass for EtaPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(REDUNDANT_CLOSURE)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for EtaPass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         match expr.node {\n             ExprCall(_, ref args) |\n             ExprMethodCall(_, _, ref args) => {\n@@ -30,11 +32,11 @@ impl LintPass for EtaPass {\n     }\n }\n \n-fn is_adjusted(cx: &Context, e: &Expr) -> bool {\n+fn is_adjusted(cx: &LateContext, e: &Expr) -> bool {\n     cx.tcx.tables.borrow().adjustments.get(&e.id).is_some()\n }\n \n-fn check_closure(cx: &Context, expr: &Expr) {\n+fn check_closure(cx: &LateContext, expr: &Expr) {\n     if let ExprClosure(_, ref decl, ref blk) = expr.node {\n         if !blk.stmts.is_empty() {\n             // || {foo(); bar()}; can't be reduced here"}, {"sha": "aee208d624eaf4177ba45c71c172cfb32b2ea20a", "filename": "src/identity_op.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -16,8 +16,10 @@ impl LintPass for IdentityOp {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(IDENTITY_OP)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+impl LateLintPass for IdentityOp {\n+    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if in_macro(cx, e.span) { return; }\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n@@ -44,7 +46,7 @@ impl LintPass for IdentityOp {\n }\n \n \n-fn check(cx: &Context, e: &Expr, m: i8, span: Span, arg: Span) {\n+fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(ConstantInt(v, ty)) = constant_simple(e) {\n         if match m {\n             0 => v == 0,"}, {"sha": "dfd340ef5ea11334fd6576fdb92f03f1b627500c", "filename": "src/len_zero.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -24,8 +24,10 @@ impl LintPass for LenZero {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(LEN_ZERO, LEN_WITHOUT_IS_EMPTY)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &Item) {\n+impl LateLintPass for LenZero {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         match item.node {\n             ItemTrait(_, _, _, ref trait_items) =>\n                 check_trait_items(cx, item, trait_items),\n@@ -35,7 +37,7 @@ impl LintPass for LenZero {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(Spanned{node: cmp, ..}, ref left, ref right) =\n                 expr.node {\n             match cmp {\n@@ -47,7 +49,7 @@ impl LintPass for LenZero {\n     }\n }\n \n-fn check_trait_items(cx: &Context, item: &Item, trait_items: &[P<TraitItem>]) {\n+fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[P<TraitItem>]) {\n     fn is_named_self(item: &TraitItem, name: &str) -> bool {\n         item.ident.name == name && if let MethodTraitItem(ref sig, _) =\n             item.node { is_self_sig(sig) } else { false }\n@@ -66,7 +68,7 @@ fn check_trait_items(cx: &Context, item: &Item, trait_items: &[P<TraitItem>]) {\n     }\n }\n \n-fn check_impl_items(cx: &Context, item: &Item, impl_items: &[P<ImplItem>]) {\n+fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[P<ImplItem>]) {\n     fn is_named_self(item: &ImplItem, name: &str) -> bool {\n         item.ident.name == name && if let MethodImplItem(ref sig, _) =\n             item.node { is_self_sig(sig) } else { false }\n@@ -92,7 +94,7 @@ fn is_self_sig(sig: &MethodSig) -> bool {\n         false } else { sig.decl.inputs.len() == 1 }\n }\n \n-fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, op: &str) {    \n+fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str) {    \n     // check if we are in an is_empty() method \n     if let Some(name) = get_item_name(cx, left) {\n         if name == \"is_empty\" { return; }\n@@ -106,7 +108,7 @@ fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, op: &str) {\n     }\n }\n \n-fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n+fn check_len_zero(cx: &LateContext, span: Span, method: &SpannedIdent,\n                   args: &[P<Expr>], lit: &Lit, op: &str) {\n     if let Spanned{node: LitInt(0, _), ..} = *lit {\n         if method.node.name == \"len\" && args.len() == 1 &&\n@@ -119,9 +121,9 @@ fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n }\n \n /// check if this type has an is_empty method\n-fn has_is_empty(cx: &Context, expr: &Expr) -> bool {\n+fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// get a ImplOrTraitItem and return true if it matches is_empty(self)\n-    fn is_is_empty(cx: &Context, id: &ImplOrTraitItemId) -> bool {\n+    fn is_is_empty(cx: &LateContext, id: &ImplOrTraitItemId) -> bool {\n         if let &MethodTraitItemId(def_id) = id {\n             if let ty::MethodTraitItem(ref method) =\n                 cx.tcx.impl_or_trait_item(def_id) {\n@@ -132,7 +134,7 @@ fn has_is_empty(cx: &Context, expr: &Expr) -> bool {\n     }\n \n     /// check the inherent impl's items for an is_empty(self) method\n-    fn has_is_empty_impl(cx: &Context, id: &DefId) -> bool {\n+    fn has_is_empty_impl(cx: &LateContext, id: &DefId) -> bool {\n         let impl_items = cx.tcx.impl_items.borrow();\n         cx.tcx.inherent_impls.borrow().get(id).map_or(false,\n             |ids| ids.iter().any(|iid| impl_items.get(iid).map_or(false,"}, {"sha": "3c2d870aee2e1622a5eac961f2558bbeb364df2e", "filename": "src/lib.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -18,7 +18,6 @@ extern crate collections;\n extern crate unicode_normalization;\n \n use rustc::plugin::Registry;\n-use rustc::lint::LintPassObject;\n \n #[macro_use]\n pub mod utils;\n@@ -54,39 +53,39 @@ mod reexport {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_lint_pass(box types::TypePass as LintPassObject);\n-    reg.register_lint_pass(box misc::TopLevelRefPass as LintPassObject);\n-    reg.register_lint_pass(box misc::CmpNan as LintPassObject);\n-    reg.register_lint_pass(box eq_op::EqOp as LintPassObject);\n-    reg.register_lint_pass(box bit_mask::BitMask as LintPassObject);\n-    reg.register_lint_pass(box ptr_arg::PtrArg as LintPassObject);\n-    reg.register_lint_pass(box needless_bool::NeedlessBool as LintPassObject);\n-    reg.register_lint_pass(box approx_const::ApproxConstant as LintPassObject);\n-    reg.register_lint_pass(box misc::FloatCmp as LintPassObject);\n-    reg.register_lint_pass(box precedence::Precedence as LintPassObject);\n-    reg.register_lint_pass(box eta_reduction::EtaPass as LintPassObject);\n-    reg.register_lint_pass(box identity_op::IdentityOp as LintPassObject);\n-    reg.register_lint_pass(box mut_mut::MutMut as LintPassObject);\n-    reg.register_lint_pass(box len_zero::LenZero as LintPassObject);\n-    reg.register_lint_pass(box misc::CmpOwned as LintPassObject);\n-    reg.register_lint_pass(box attrs::AttrPass as LintPassObject);\n-    reg.register_lint_pass(box collapsible_if::CollapsibleIf as LintPassObject);\n-    reg.register_lint_pass(box misc::ModuloOne as LintPassObject);\n-    reg.register_lint_pass(box unicode::Unicode as LintPassObject);\n-    reg.register_lint_pass(box strings::StringAdd as LintPassObject);\n-    reg.register_lint_pass(box returns::ReturnPass as LintPassObject);\n-    reg.register_lint_pass(box methods::MethodsPass as LintPassObject);\n-    reg.register_lint_pass(box shadow::ShadowPass as LintPassObject);\n-    reg.register_lint_pass(box types::LetPass as LintPassObject);\n-    reg.register_lint_pass(box types::UnitCmp as LintPassObject);\n-    reg.register_lint_pass(box loops::LoopsPass as LintPassObject);\n-    reg.register_lint_pass(box lifetimes::LifetimePass as LintPassObject);\n-    reg.register_lint_pass(box ranges::StepByZero as LintPassObject);\n-    reg.register_lint_pass(box types::CastPass as LintPassObject);\n-    reg.register_lint_pass(box types::TypeComplexityPass as LintPassObject);\n-    reg.register_lint_pass(box matches::MatchPass as LintPassObject);\n-    reg.register_lint_pass(box misc::PatternPass as LintPassObject);\n-    reg.register_lint_pass(box minmax::MinMaxPass as LintPassObject);\n+    reg.register_late_lint_pass(box types::TypePass);\n+    reg.register_late_lint_pass(box misc::TopLevelRefPass);\n+    reg.register_late_lint_pass(box misc::CmpNan);\n+    reg.register_late_lint_pass(box eq_op::EqOp);\n+    reg.register_late_lint_pass(box bit_mask::BitMask);\n+    reg.register_late_lint_pass(box ptr_arg::PtrArg);\n+    reg.register_late_lint_pass(box needless_bool::NeedlessBool);\n+    reg.register_late_lint_pass(box approx_const::ApproxConstant);\n+    reg.register_late_lint_pass(box misc::FloatCmp);\n+    reg.register_early_lint_pass(box precedence::Precedence);\n+    reg.register_late_lint_pass(box eta_reduction::EtaPass);\n+    reg.register_late_lint_pass(box identity_op::IdentityOp);\n+    reg.register_late_lint_pass(box mut_mut::MutMut);\n+    reg.register_late_lint_pass(box len_zero::LenZero);\n+    reg.register_late_lint_pass(box misc::CmpOwned);\n+    reg.register_late_lint_pass(box attrs::AttrPass);\n+    reg.register_late_lint_pass(box collapsible_if::CollapsibleIf);\n+    reg.register_late_lint_pass(box misc::ModuloOne);\n+    reg.register_late_lint_pass(box unicode::Unicode);\n+    reg.register_late_lint_pass(box strings::StringAdd);\n+    reg.register_late_lint_pass(box returns::ReturnPass);\n+    reg.register_late_lint_pass(box methods::MethodsPass);\n+    reg.register_late_lint_pass(box shadow::ShadowPass);\n+    reg.register_late_lint_pass(box types::LetPass);\n+    reg.register_late_lint_pass(box types::UnitCmp);\n+    reg.register_late_lint_pass(box loops::LoopsPass);\n+    reg.register_late_lint_pass(box lifetimes::LifetimePass);\n+    reg.register_late_lint_pass(box ranges::StepByZero);\n+    reg.register_late_lint_pass(box types::CastPass);\n+    reg.register_late_lint_pass(box types::TypeComplexityPass);\n+    reg.register_late_lint_pass(box matches::MatchPass);\n+    reg.register_late_lint_pass(box misc::PatternPass);\n+    reg.register_late_lint_pass(box minmax::MinMaxPass);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,"}, {"sha": "bfd7125aa4e849daa177f836dad8c372484901db", "filename": "src/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -18,21 +18,23 @@ impl LintPass for LifetimePass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_LIFETIMES)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &Item) {\n+impl LateLintPass for LifetimePass {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n             check_fn_inner(cx, decl, None, &generics, item.span);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n         if let MethodImplItem(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self),\n                            &sig.generics, item.span);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self),\n                            &sig.generics, item.span);\n@@ -49,7 +51,7 @@ enum RefLt {\n }\n use self::RefLt::*;\n \n-fn check_fn_inner(cx: &Context, decl: &FnDecl, slf: Option<&ExplicitSelf>,\n+fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>,\n                   generics: &Generics, span: Span) {\n     if in_external_macro(cx, span) || has_where_lifetimes(&generics.where_clause) {\n         return;"}, {"sha": "497ea8d46c42ca9c6db5c8aab0ac0b7ac9118bca", "filename": "src/loops.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -43,8 +43,10 @@ impl LintPass for LoopsPass {\n         lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP,\n                     WHILE_LET_LOOP, UNUSED_COLLECT, REVERSE_RANGE_LOOP, EXPLICIT_COUNTER_LOOP)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for LoopsPass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let Some((pat, arg, body)) = recover_for_loop(expr) {\n             // check for looping over a range and then indexing a sequence with it\n             // -> the iteratee must be a range literal\n@@ -186,7 +188,7 @@ impl LintPass for LoopsPass {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &Context, stmt: &Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && method.node.name == \"collect\" &&\n@@ -225,7 +227,7 @@ fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n }\n \n struct VarVisitor<'v, 't: 'v> {\n-    cx: &'v Context<'v, 't>, // context reference\n+    cx: &'v LateContext<'v, 't>, // context reference\n     var: Name,               // var name to look for as index\n     indexed: HashSet<Name>,  // indexed variables\n     nonindex: bool,          // has the var been used otherwise?\n@@ -258,7 +260,7 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n \n /// Return true if the type of expr is one that provides IntoIterator impls\n /// for &T and &mut T, such as Vec.\n-fn is_ref_iterable_type(cx: &Context, e: &Expr) -> bool {\n+fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n     let ty = cx.tcx.expr_ty(e);\n@@ -320,7 +322,7 @@ enum VarState {\n \n // Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'v, 't: 'v> {\n-    cx: &'v Context<'v, 't>,      // context reference\n+    cx: &'v LateContext<'v, 't>,      // context reference\n     states: HashMap<NodeId, VarState>,  // incremented variables\n     depth: u32,                         // depth of conditional expressions\n     done: bool\n@@ -376,7 +378,7 @@ impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n \n // Check whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'v, 't: 'v> {\n-    cx: &'v Context<'v, 't>, // context reference\n+    cx: &'v LateContext<'v, 't>, // context reference\n     end_expr: &'v Expr,      // the for loop. Stop scanning here.\n     var_id: NodeId,\n     state: VarState,\n@@ -454,7 +456,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n     }\n }\n \n-fn var_def_id(cx: &Context, expr: &Expr) -> Option<NodeId> {\n+fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n     if let Some(path_res) = cx.tcx.def_map.borrow().get(&expr.id) {\n         if let DefLocal(node_id) = path_res.base_def {\n             return Some(node_id)"}, {"sha": "4e49cd3ff735a5c963828aaff1b1fd22724b0c4c", "filename": "src/matches.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -17,8 +17,10 @@ impl LintPass for MatchPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(SINGLE_MATCH, MATCH_REF_PATS)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for MatchPass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n             // check preconditions for SINGLE_MATCH\n                 // only two arms"}, {"sha": "facedaa3867eb1ea4781562d9e0c5925de08091d", "filename": "src/methods.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -36,8 +36,10 @@ impl LintPass for MethodsPass {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n                     SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for MethodsPass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(ref ident, _, ref args) = expr.node {\n             let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n             if ident.node.name == \"unwrap\" {\n@@ -71,7 +73,7 @@ impl LintPass for MethodsPass {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemImpl(_, _, _, None, ref ty, ref items) = item.node {\n             for implitem in items {\n                 let name = implitem.ident.name;\n@@ -229,7 +231,7 @@ fn is_bool(ty: &Ty) -> bool {\n     false\n }\n \n-fn is_copy(cx: &Context, ast_ty: &Ty, item: &Item) -> bool {\n+fn is_copy(cx: &LateContext, ast_ty: &Ty, item: &Item) -> bool {\n     match cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n         None => false,\n         Some(ty) => {"}, {"sha": "a94b0b42ec1f536f247b0d1c57b2aec6eb5e3244", "filename": "src/minmax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{Context, LintPass, LintArray};\n+use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::ptr::P;\n use std::cmp::PartialOrd;\n@@ -19,8 +19,10 @@ impl LintPass for MinMaxPass {\n     fn get_lints(&self) -> LintArray {\n        lint_array!(MIN_MAX)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for MinMaxPass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let Some((outer_max, outer_c, oe)) = min_max(expr) {\n             if let Some((inner_max, inner_c, _)) = min_max(oe) {\n                 if outer_max == inner_max { return; }"}, {"sha": "20f5d16bbc1a90cb55ad836d0820bd498f8557ee", "filename": "src/misc.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -21,8 +21,10 @@ impl LintPass for TopLevelRefPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(TOPLEVEL_REF_ARG)\n     }\n+}\n \n-    fn check_fn(&mut self, cx: &Context, k: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n+impl LateLintPass for TopLevelRefPass {\n+    fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         if let FnKind::Closure = k {\n             // Does not apply to closures\n             return\n@@ -49,8 +51,10 @@ impl LintPass for CmpNan {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CMP_NAN)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for CmpNan {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             if is_comparison_binop(cmp.node) {\n                 if let &ExprPath(_, ref path) = &left.node {\n@@ -64,7 +68,7 @@ impl LintPass for CmpNan {\n     }\n }\n \n-fn check_nan(cx: &Context, path: &Path, span: Span) {\n+fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n     path.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n         span_lint(cx, CMP_NAN, span,\n             \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n@@ -83,8 +87,10 @@ impl LintPass for FloatCmp {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(FLOAT_CMP)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for FloatCmp {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             let op = cmp.node;\n             if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n@@ -109,7 +115,7 @@ impl LintPass for FloatCmp {\n     }\n }\n \n-fn is_float(cx: &Context, expr: &Expr) -> bool {\n+fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n     if let ty::TyFloat(_) = walk_ptrs_ty(cx.tcx.expr_ty(expr)).sty {\n         true\n     } else {\n@@ -127,8 +133,10 @@ impl LintPass for CmpOwned {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CMP_OWNED)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for CmpOwned {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             if is_comparison_binop(cmp.node) {\n                 check_to_owned(cx, left, right.span);\n@@ -138,7 +146,7 @@ impl LintPass for CmpOwned {\n     }\n }\n \n-fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n+fn check_to_owned(cx: &LateContext, expr: &Expr, other_span: Span) {\n     match expr.node {\n         ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n             let name = ident.name;\n@@ -165,7 +173,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n     }\n }\n \n-fn is_str_arg(cx: &Context, args: &[P<Expr>]) -> bool {\n+fn is_str_arg(cx: &LateContext, args: &[P<Expr>]) -> bool {\n     args.len() == 1 && if let ty::TyStr =\n         walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty { true } else { false }\n }\n@@ -179,8 +187,10 @@ impl LintPass for ModuloOne {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MODULO_ONE)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for ModuloOne {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n             if let &Spanned {node: BinOp_::BiRem, ..} = cmp {\n                 if is_integer_literal(right, 1) {\n@@ -200,8 +210,10 @@ impl LintPass for PatternPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(REDUNDANT_PATTERN)\n     }\n+}\n \n-    fn check_pat(&mut self, cx: &Context, pat: &Pat) {\n+impl LateLintPass for PatternPass {\n+    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n         if let PatIdent(_, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatWild(PatWildSingle) {\n                 cx.span_lint(REDUNDANT_PATTERN, pat.span, &format!("}, {"sha": "9b6a5d9ddcc75d131ae6dde18e28d7fd7c38824c", "filename": "src/mut_mut.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -15,18 +15,20 @@ impl LintPass for MutMut {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MUT_MUT)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for MutMut {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n        check_expr_mut(cx, expr)\n     }\n \n-    fn check_ty(&mut self, cx: &Context, ty: &Ty) {\n+    fn check_ty(&mut self, cx: &LateContext, ty: &Ty) {\n         unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| span_lint(cx, MUT_MUT,\n             ty.span, \"generally you want to avoid `&mut &mut _` if possible\"))\n     }\n }\n \n-fn check_expr_mut(cx: &Context, expr: &Expr) {\n+fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n     if in_external_macro(cx, expr.span) { return; }\n \n     fn unwrap_addr(expr : &Expr) -> Option<&Expr> {"}, {"sha": "c0a99acb71dd92322b259f82f8b64558acf2e14e", "filename": "src/needless_bool.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -23,8 +23,10 @@ impl LintPass for NeedlessBool {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_BOOL)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+impl LateLintPass for NeedlessBool {\n+    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                 (Some(true), Some(true)) => {"}, {"sha": "ce06278b78208880fa4fd507404af9c7a14238b7", "filename": "src/precedence.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-use syntax::ast::Lit_::*;\n+use syntax::ast::*;\n use utils::span_lint;\n \n declare_lint!(pub PRECEDENCE, Warn,\n@@ -15,8 +14,10 @@ impl LintPass for Precedence {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PRECEDENCE)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl EarlyLintPass for Precedence {\n+    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n                 span_lint(cx, PRECEDENCE, expr.span,"}, {"sha": "7c369469ea2d82af24e083b4f618a2de028e97e6", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -23,27 +23,29 @@ impl LintPass for PtrArg {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PTR_ARG)\n     }\n+}\n \n-    fn check_item(&mut self, cx: &Context, item: &Item) {\n+impl LateLintPass for PtrArg {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let &ItemFn(ref decl, _, _, _, _, _) = &item.node {\n             check_fn(cx, decl);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n         if let &MethodImplItem(ref sig, _) = &item.node {\n             check_fn(cx, &sig.decl);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         if let &MethodTraitItem(ref sig, _) = &item.node {\n             check_fn(cx, &sig.decl);\n         }\n     }\n }\n \n-fn check_fn(cx: &Context, decl: &FnDecl) {\n+fn check_fn(cx: &LateContext, decl: &FnDecl) {\n     for arg in &decl.inputs {\n         if let Some(pat_ty) = cx.tcx.pat_ty_opt(&arg.pat) {\n             if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = pat_ty.sty {"}, {"sha": "8ba2440d3619db7556e266c9811d36017eeca3ae", "filename": "src/ranges.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{Context, LintArray, LintPass};\n+use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n use utils::{match_type, is_integer_literal};\n@@ -15,8 +15,10 @@ impl LintPass for StepByZero {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(RANGE_STEP_BY_ZERO)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for StepByZero {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(Spanned { node: ref ident, .. }, _,\n                               ref args) = expr.node {\n             // Only warn on literal ranges.\n@@ -30,7 +32,7 @@ impl LintPass for StepByZero {\n     }\n }\n \n-fn is_range(cx: &Context, expr: &Expr) -> bool {\n+fn is_range(cx: &LateContext, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n     let ty = cx.tcx.expr_ty(expr);"}, {"sha": "7ab5f3364ac2e2637e1dd0e7d75e92c8a2f6fc50", "filename": "src/returns.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -17,7 +17,7 @@ pub struct ReturnPass;\n \n impl ReturnPass {\n     // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &Context, block: &Block) {\n+    fn check_block_return(&mut self, cx: &LateContext, block: &Block) {\n         if let Some(ref expr) = block.expr {\n             self.check_final_expr(cx, expr);\n         } else if let Some(stmt) = block.stmts.last() {\n@@ -30,7 +30,7 @@ impl ReturnPass {\n     }\n \n     // Check a the final expression in a block if it's a return.\n-    fn check_final_expr(&mut self, cx: &Context, expr: &Expr) {\n+    fn check_final_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         match expr.node {\n             // simple return is always \"bad\"\n             ExprRet(Some(ref inner)) => {\n@@ -57,7 +57,7 @@ impl ReturnPass {\n         }\n     }\n \n-    fn emit_return_lint(&mut self, cx: &Context, spans: (Span, Span)) {\n+    fn emit_return_lint(&mut self, cx: &LateContext, spans: (Span, Span)) {\n         if in_external_macro(cx, spans.1) {return;}\n         span_lint(cx, NEEDLESS_RETURN, spans.0, &format!(\n             \"unneeded return statement. Consider using `{}` \\\n@@ -66,7 +66,7 @@ impl ReturnPass {\n     }\n \n     // Check for \"let x = EXPR; x\"\n-    fn check_let_return(&mut self, cx: &Context, block: &Block) {\n+    fn check_let_return(&mut self, cx: &LateContext, block: &Block) {\n         // we need both a let-binding stmt and an expr\n         if_let_chain! {\n             [\n@@ -84,7 +84,7 @@ impl ReturnPass {\n         }\n     }\n \n-    fn emit_let_lint(&mut self, cx: &Context, lint_span: Span, note_span: Span) {\n+    fn emit_let_lint(&mut self, cx: &LateContext, lint_span: Span, note_span: Span) {\n         if in_external_macro(cx, note_span) {return;}\n         span_lint(cx, LET_AND_RETURN, lint_span,\n                   \"returning the result of a let binding. \\\n@@ -100,8 +100,10 @@ impl LintPass for ReturnPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_RETURN, LET_AND_RETURN)\n     }\n+}\n \n-    fn check_fn(&mut self, cx: &Context, _: FnKind, _: &FnDecl,\n+impl LateLintPass for ReturnPass {\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, _: &FnDecl,\n                 block: &Block, _: Span, _: NodeId) {\n         self.check_block_return(cx, block);\n         self.check_let_return(cx, block);"}, {"sha": "f1c09b802c3473923f48deda5c3ebedb592dbd79", "filename": "src/shadow.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -4,7 +4,7 @@ use reexport::*;\n use syntax::codemap::Span;\n use rustc_front::visit::FnKind;\n \n-use rustc::lint::{Context, Level, Lint, LintArray, LintPass};\n+use rustc::lint::*;\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n use utils::{in_external_macro, snippet, span_lint, span_note_and_lint};\n@@ -25,14 +25,17 @@ impl LintPass for ShadowPass {\n         lint_array!(SHADOW_SAME, SHADOW_REUSE, SHADOW_UNRELATED)\n     }\n \n-    fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl,\n+}\n+\n+impl LateLintPass for ShadowPass {\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl,\n             block: &Block, _: Span, _: NodeId) {\n         if in_external_macro(cx, block.span) { return; }\n         check_fn(cx, decl, block);\n     }\n }\n \n-fn check_fn(cx: &Context, decl: &FnDecl, block: &Block) {\n+fn check_fn(cx: &LateContext, decl: &FnDecl, block: &Block) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n         if let PatIdent(_, ident, _) = arg.pat.node {\n@@ -42,7 +45,7 @@ fn check_fn(cx: &Context, decl: &FnDecl, block: &Block) {\n     check_block(cx, block, &mut bindings);\n }\n \n-fn check_block(cx: &Context, block: &Block, bindings: &mut Vec<(Name, Span)>) {\n+fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>) {\n     let len = bindings.len();\n     for stmt in &block.stmts {\n         match stmt.node {\n@@ -55,7 +58,7 @@ fn check_block(cx: &Context, block: &Block, bindings: &mut Vec<(Name, Span)>) {\n     bindings.truncate(len);\n }\n \n-fn check_decl(cx: &Context, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n+fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, decl.span) { return; }\n     if let DeclLocal(ref local) = decl.node {\n         let Local{ ref pat, ref ty, ref init, id: _, span } = **local;\n@@ -69,14 +72,14 @@ fn check_decl(cx: &Context, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n     }\n }\n \n-fn is_binding(cx: &Context, pat: &Pat) -> bool {\n+fn is_binding(cx: &LateContext, pat: &Pat) -> bool {\n     match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n         Some(DefVariant(..)) | Some(DefStruct(..)) => false,\n         _ => true\n     }\n }\n \n-fn check_pat(cx: &Context, pat: &Pat, init: &Option<&Expr>, span: Span,\n+fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n         bindings: &mut Vec<(Name, Span)>) {\n     //TODO: match more stuff / destructuring\n     match pat.node {\n@@ -153,9 +156,9 @@ fn check_pat(cx: &Context, pat: &Pat, init: &Option<&Expr>, span: Span,\n     }\n }\n \n-fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init:\n+fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init:\n         &Option<T>, prev_span: Span) where T: Deref<Target=Expr> {\n-    fn note_orig(cx: &Context, lint: &'static Lint, span: Span) {\n+    fn note_orig(cx: &LateContext, lint: &'static Lint, span: Span) {\n         if cx.current_level(lint) != Level::Allow {\n             cx.sess().span_note(span, \"previous binding is here\");\n         }\n@@ -191,10 +194,10 @@ fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init:\n     }\n }\n \n-fn check_expr(cx: &Context, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n+fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, expr.span) { return; }\n     match expr.node {\n-        ExprUnary(_, ref e) | ExprParen(ref e) | ExprField(ref e, _) |\n+        ExprUnary(_, ref e) | ExprField(ref e, _) |\n         ExprTupField(ref e, _) | ExprAddrOf(_, ref e) | ExprBox(None, ref e)\n             => { check_expr(cx, e, bindings) },\n         ExprBox(Some(ref place), ref e) => {\n@@ -233,7 +236,7 @@ fn check_expr(cx: &Context, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n     }\n }\n \n-fn check_ty(cx: &Context, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n+fn check_ty(cx: &LateContext, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n     match ty.node {\n         TyParen(ref sty) | TyObjectSum(ref sty, _) |\n         TyVec(ref sty) => check_ty(cx, sty, bindings),\n@@ -252,7 +255,6 @@ fn check_ty(cx: &Context, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBox(_, ref inner) |\n-        ExprParen(ref inner) |\n         ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprBlock(ref block) => block.stmts.is_empty() && block.expr.as_ref().\n             map_or(false, |ref e| is_self_shadow(name, e)),\n@@ -275,7 +277,7 @@ fn contains_self(name: Name, expr: &Expr) -> bool {\n         // no subexprs\n         ExprLit(_) => false,\n         // one subexpr\n-        ExprUnary(_, ref e) | ExprParen(ref e) | ExprField(ref e, _) |\n+        ExprUnary(_, ref e) | ExprField(ref e, _) |\n         ExprTupField(ref e, _) | ExprAddrOf(_, ref e) | ExprBox(_, ref e) |\n         ExprCast(ref e, _) =>\n             contains_self(name, e),"}, {"sha": "6bbf94004b0edc25257efe0148f64a700d061e98", "filename": "src/strings.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -30,8 +30,10 @@ impl LintPass for StringAdd {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(STRING_ADD, STRING_ADD_ASSIGN)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+impl LateLintPass for StringAdd {\n+    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) = &e.node {\n             if is_string(cx, left) {\n                 if let Allow = cx.current_level(STRING_ADD_ASSIGN) {\n@@ -59,18 +61,17 @@ impl LintPass for StringAdd {\n     }\n }\n \n-fn is_string(cx: &Context, e: &Expr) -> bool {\n+fn is_string(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &STRING_PATH)\n }\n \n-fn is_add(cx: &Context, src: &Expr, target: &Expr) -> bool {\n+fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n         ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n             is_exp_equal(cx, target, left),\n         ExprBlock(ref block) => block.stmts.is_empty() &&\n             block.expr.as_ref().map_or(false,\n                 |expr| is_add(cx, expr, target)),\n-        ExprParen(ref expr) => is_add(cx, expr, target),\n         _ => false\n     }\n }"}, {"sha": "dd41b4f22399b0fbaebeb672adbe2c9a883a6532", "filename": "src/types.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -26,8 +26,10 @@ impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOX_VEC, LINKEDLIST)\n     }\n+}\n \n-    fn check_ty(&mut self, cx: &Context, ast_ty: &Ty) {\n+impl LateLintPass for TypePass {\n+    fn check_ty(&mut self, cx: &LateContext, ast_ty: &Ty) {\n         if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n             if let ty::TyBox(ref inner) = ty.sty {\n                 if match_type(cx, inner, &VEC_PATH) {\n@@ -53,7 +55,7 @@ pub struct LetPass;\n declare_lint!(pub LET_UNIT_VALUE, Warn,\n               \"creating a let binding to a value of unit type, which usually can't be used afterwards\");\n \n-fn check_let_unit(cx: &Context, decl: &Decl) {\n+fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n         let bindtype = &cx.tcx.pat_ty(&local.pat).sty;\n         if *bindtype == ty::TyTuple(vec![]) {\n@@ -70,8 +72,10 @@ impl LintPass for LetPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(LET_UNIT_VALUE)\n     }\n+}\n \n-    fn check_decl(&mut self, cx: &Context, decl: &Decl) {\n+impl LateLintPass for LetPass {\n+    fn check_decl(&mut self, cx: &LateContext, decl: &Decl) {\n         check_let_unit(cx, decl)\n     }\n }\n@@ -86,8 +90,10 @@ impl LintPass for UnitCmp {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNIT_CMP)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for UnitCmp {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if in_macro(cx, expr.span) { return; }\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n@@ -135,7 +141,7 @@ fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n     }\n }\n \n-fn span_precision_loss_lint(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 {52} else {23};\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -154,7 +160,7 @@ enum ArchSuffix {\n     _32, _64, None\n }\n \n-fn check_truncation_and_wrapping(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n+fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -207,8 +213,10 @@ impl LintPass for CastPass {\n                     CAST_POSSIBLE_TRUNCATION,\n                     CAST_POSSIBLE_WRAP)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for CastPass {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprCast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tcx.expr_ty(ex), cx.tcx.expr_ty(expr));\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n@@ -262,16 +270,18 @@ impl LintPass for TypeComplexityPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(TYPE_COMPLEXITY)\n     }\n+}\n \n-    fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n+impl LateLintPass for TypeComplexityPass {\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         check_fndecl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &Context, field: &StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n         check_type(cx, &field.node.ty);\n     }\n \n-    fn check_variant(&mut self, cx: &Context, var: &Variant, _: &Generics) {\n+    fn check_variant(&mut self, cx: &LateContext, var: &Variant, _: &Generics) {\n         // StructVariant is covered by check_struct_field\n         if let TupleVariantKind(ref args) = var.node.kind {\n             for arg in args {\n@@ -280,7 +290,7 @@ impl LintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &Context, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         match item.node {\n             ItemStatic(ref ty, _, _) |\n             ItemConst(ref ty, _) => check_type(cx, ty),\n@@ -289,7 +299,7 @@ impl LintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         match item.node {\n             ConstTraitItem(ref ty, _) |\n             TypeTraitItem(_, Some(ref ty)) => check_type(cx, ty),\n@@ -299,7 +309,7 @@ impl LintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n         match item.node {\n             ConstImplItem(ref ty, _) |\n             TypeImplItem(ref ty) => check_type(cx, ty),\n@@ -308,14 +318,14 @@ impl LintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_local(&mut self, cx: &Context, local: &Local) {\n+    fn check_local(&mut self, cx: &LateContext, local: &Local) {\n         if let Some(ref ty) = local.ty {\n             check_type(cx, ty);\n         }\n     }\n }\n \n-fn check_fndecl(cx: &Context, decl: &FnDecl) {\n+fn check_fndecl(cx: &LateContext, decl: &FnDecl) {\n     for arg in &decl.inputs {\n         check_type(cx, &arg.ty);\n     }\n@@ -324,7 +334,7 @@ fn check_fndecl(cx: &Context, decl: &FnDecl) {\n     }\n }\n \n-fn check_type(cx: &Context, ty: &Ty) {\n+fn check_type(cx: &LateContext, ty: &Ty) {\n     if in_macro(cx, ty.span) { return; }\n     let score = {\n         let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };"}, {"sha": "3855fafe7be61a854aab459a22826a69f467ebe5", "filename": "src/unicode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -25,8 +25,10 @@ impl LintPass for Unicode {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(ZERO_WIDTH_SPACE, NON_ASCII_LITERAL, UNICODE_NOT_NFC)\n     }\n+}\n \n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+impl LateLintPass for Unicode {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprLit(ref lit) = expr.node {\n             if let LitStr(_, _) = lit.node {\n                 check_str(cx, lit.span)\n@@ -47,7 +49,7 @@ fn escape<T: Iterator<Item=char>>(s: T) -> String {\n     result\n }\n \n-fn check_str(cx: &Context, span: Span) {\n+fn check_str(cx: &LateContext, span: Span) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n         span_help_and_lint(cx, ZERO_WIDTH_SPACE, span,"}, {"sha": "d5566c3a6915bf242fb0652f9be23ec06a892909", "filename": "src/utils.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -16,7 +16,7 @@ pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n \n /// returns true this expn_info was expanded by any macro\n-pub fn in_macro(cx: &Context, span: Span) -> bool {\n+pub fn in_macro(cx: &LateContext, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id,\n             |info| info.map_or(false, |i| {\n         match i.callee.format {\n@@ -28,10 +28,10 @@ pub fn in_macro(cx: &Context, span: Span) -> bool {\n \n /// returns true if the macro that expanded the crate was outside of\n /// the current crate or was a compiler plugin\n-pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n+pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n     /// invokes in_macro with the expansion info of the given span\n     /// slightly heavy, try to use this after other checks have already happened\n-    fn in_macro_ext(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n+    fn in_macro_ext<T: LintContext>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n             match info.callee.format {\n@@ -65,12 +65,12 @@ pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n /// check if a DefId's path matches the given absolute type path\n /// usage e.g. with\n /// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n-pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n+pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n     cx.tcx.with_path(def_id, |iter| iter.zip(path).all(|(nm, p)| nm.name() == p))\n }\n \n /// check if type is struct or enum type with given def path\n-pub fn match_type(cx: &Context, ty: ty::Ty, path: &[&str]) -> bool {\n+pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => {\n             match_def_path(cx, adt.did, path)\n@@ -82,7 +82,7 @@ pub fn match_type(cx: &Context, ty: ty::Ty, path: &[&str]) -> bool {\n }\n \n /// check if method call given in \"expr\" belongs to given trait\n-pub fn match_trait_method(cx: &Context, expr: &Expr, path: &[&str]) -> bool {\n+pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n     let trt_id = cx.tcx.tables\n                        .borrow().method_map.get(&method_call)\n@@ -102,7 +102,7 @@ pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n }\n \n /// get the name of the item the expression is in, if available\n-pub fn get_item_name(cx: &Context, expr: &Expr) -> Option<Name> {\n+pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n     match cx.tcx.map.find(parent_id) {\n         Some(NodeItem(&Item{ ref ident, .. })) |\n@@ -116,21 +116,21 @@ pub fn get_item_name(cx: &Context, expr: &Expr) -> Option<Name> {\n \n /// convert a span to a code snippet if available, otherwise use default, e.g.\n /// `snippet(cx, expr.span, \"..\")`\n-pub fn snippet<'a>(cx: &Context, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or(Cow::Borrowed(default))\n }\n \n /// convert a span (from a block) to a code snippet if available, otherwise use default, e.g.\n /// `snippet(cx, expr.span, \"..\")`\n /// This trims the code of indentation, except for the first line\n /// Use it for blocks or block-like things which need to be printed as such\n-pub fn snippet_block<'a>(cx: &Context, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n     trim_multiline(snip, true)\n }\n \n /// Like snippet_block, but add braces if the expr is not an ExprBlock\n-pub fn expr_block<'a>(cx: &Context, expr: &Expr, default: &'a str) -> Cow<'a, str> {\n+pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, default: &'a str) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     if let ExprBlock(_) = expr.node {\n         code\n@@ -169,7 +169,7 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n }\n \n /// get a parent expr if any \u2013 this is useful to constrain a lint\n-pub fn get_parent_expr<'c>(cx: &'c Context, e: &Expr) -> Option<&'c Expr> {\n+pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.map;\n     let node_id : NodeId = e.id;\n     let parent_id : NodeId = map.get_parent_node(node_id);\n@@ -179,7 +179,7 @@ pub fn get_parent_expr<'c>(cx: &'c Context, e: &Expr) -> Option<&'c Expr> {\n }\n \n #[cfg(not(feature=\"structured_logging\"))]\n-pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n+pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n     cx.span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n         cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n@@ -189,7 +189,7 @@ pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n }\n \n #[cfg(feature=\"structured_logging\")]\n-pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n+pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n     // lint.name / lint.desc is can give details of the lint\n     // cx.sess().codemap() has all these nice functions for line/column/snippet details\n     // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n@@ -201,7 +201,7 @@ pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n     }\n }\n \n-pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n+pub fn span_help_and_lint<T: LintContext>(cx: &T, lint: &'static Lint, span: Span,\n         msg: &str, help: &str) {\n     cx.span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n@@ -211,7 +211,7 @@ pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n     }\n }\n \n-pub fn span_note_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n+pub fn span_note_and_lint<T: LintContext>(cx: &T, lint: &'static Lint, span: Span,\n         msg: &str, note_span: Span, note: &str) {\n     cx.span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {"}, {"sha": "d70f26ed09061b76a4c407a4d04ec0bb0e32e0cc", "filename": "tests/compile-fail/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4da7d09d278b39d66590d85f48938243372782d/tests%2Fcompile-fail%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4da7d09d278b39d66590d85f48938243372782d/tests%2Fcompile-fail%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fshadow.rs?ref=f4da7d09d278b39d66590d85f48938243372782d", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let mut x = 1;\n     let x = &mut x; //~ERROR: x is shadowed by itself in &mut x\n     let x = { x }; //~ERROR: x is shadowed by itself in { x }\n-    let x = (&*x); //~ERROR: x is shadowed by itself in (&*x)\n+    let x = (&*x); //~ERROR: x is shadowed by itself in &*x\n     let x = { *x + 1 }; //~ERROR: x is shadowed by { *x + 1 } which reuses\n     let x = id(x); //~ERROR: x is shadowed by id(x) which reuses\n     let x = (1, x); //~ERROR: x is shadowed by (1, x) which reuses"}]}