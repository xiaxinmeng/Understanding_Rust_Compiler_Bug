{"sha": "f51176df0182f37b71a0f6397ecde590efe4a757", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MTE3NmRmMDE4MmYzN2I3MWEwZjYzOTdlY2RlNTkwZWZlNGE3NTc=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-01-21T22:43:29Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-11T12:51:21Z"}, "message": "dropck: treat parametric types as safe for dropping.\n\nHandles e.g. `impl<T> Drop for Vec<T>` as parametric: If `T` does not\nhave any drop code that could read from borrowed data of lifetime `'a`,\nthen we infer that the drop code for `Vec<T>` also cannot read from\nborrowed data of lifetime `'a`, and therefore we do not need to inject\nthe SafeDestructor constraint for it.\n\nNotably, this enables us to continue storing cyclic structure, without\nany `unsafe` code, in `Vec`, without allowing (unsound) destructors on\nsuch cyclic data. (Later commits have tests illustrating these two\ncases in run-pass and compile-fail, respectively.)\n\n(This is \"Condition (B.)\" in Drop-Check rule described in RFC 769.)", "tree": {"sha": "59286efdd8162afce4632b5b7929306726fa1d7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59286efdd8162afce4632b5b7929306726fa1d7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f51176df0182f37b71a0f6397ecde590efe4a757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f51176df0182f37b71a0f6397ecde590efe4a757", "html_url": "https://github.com/rust-lang/rust/commit/f51176df0182f37b71a0f6397ecde590efe4a757", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f51176df0182f37b71a0f6397ecde590efe4a757/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f90c3864b66ba28c5cda46a32a564d77b0c0f848", "url": "https://api.github.com/repos/rust-lang/rust/commits/f90c3864b66ba28c5cda46a32a564d77b0c0f848", "html_url": "https://github.com/rust-lang/rust/commit/f90c3864b66ba28c5cda46a32a564d77b0c0f848"}], "stats": {"total": 193, "additions": 185, "deletions": 8}, "files": [{"sha": "983c3f52838a8cd9b8eb81ebf1e0f7734a873a05", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 185, "deletions": 8, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/f51176df0182f37b71a0f6397ecde590efe4a757/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51176df0182f37b71a0f6397ecde590efe4a757/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=f51176df0182f37b71a0f6397ecde590efe4a757", "patch": "@@ -12,6 +12,7 @@ use check::regionck::{self, Rcx};\n \n use middle::infer;\n use middle::region;\n+use middle::subst;\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr};\n \n@@ -46,31 +47,207 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n {\n     let origin = |&:| infer::SubregionOrigin::SafeDestructor(span);\n     let mut walker = ty_root.walk();\n+    let opt_phantom_data_def_id = rcx.tcx().lang_items.phantom_data();\n+\n+    let destructor_for_type = rcx.tcx().destructor_for_type.borrow();\n+\n     while let Some(typ) = walker.next() {\n         // Avoid recursing forever.\n         if breadcrumbs.contains(&typ) {\n             continue;\n         }\n         breadcrumbs.push(typ);\n \n-        let has_dtor = match typ.sty {\n-            ty::ty_struct(struct_did, _) => ty::has_dtor(rcx.tcx(), struct_did),\n-            ty::ty_enum(enum_did, _) => ty::has_dtor(rcx.tcx(), enum_did),\n-            _ => false,\n+        // If we encounter `PhantomData<T>`, then we should replace it\n+        // with `T`, the type it represents as owned by the\n+        // surrounding context, before doing further analysis.\n+        let typ = if let ty::ty_struct(struct_did, substs) = typ.sty {\n+            if opt_phantom_data_def_id == Some(struct_did) {\n+                let item_type = ty::lookup_item_type(rcx.tcx(), struct_did);\n+                let tp_def = item_type.generics.types\n+                    .opt_get(subst::TypeSpace, 0).unwrap();\n+                let new_typ = substs.type_for_def(tp_def);\n+                debug!(\"replacing phantom {} with {}\",\n+                       typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n+                new_typ\n+            } else {\n+                typ\n+            }\n+        } else {\n+            typ\n+        };\n+\n+        let opt_type_did = match typ.sty {\n+            ty::ty_struct(struct_did, _) => Some(struct_did),\n+            ty::ty_enum(enum_did, _) => Some(enum_did),\n+            _ => None,\n         };\n \n+        let opt_dtor =\n+            opt_type_did.and_then(|did| destructor_for_type.get(&did));\n+\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}typ: {} scope: {:?} has_dtor: {}\",\n+                {}typ: {} scope: {:?} opt_dtor: {:?}\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               typ.repr(rcx.tcx()), scope, has_dtor);\n+               typ.repr(rcx.tcx()), scope, opt_dtor);\n+\n+        // If `typ` has a destructor, then we must ensure that all\n+        // borrowed data reachable via `typ` must outlive the parent\n+        // of `scope`. This is handled below.\n+        //\n+        // However, there is an important special case: by\n+        // parametricity, any generic type parameters have *no* trait\n+        // bounds in the Drop impl can not be used in any way (apart\n+        // from being dropped), and thus we can treat data borrowed\n+        // via such type parameters remains unreachable.\n+        //\n+        // For example, consider `impl<T> Drop for Vec<T> { ... }`,\n+        // which does have to be able to drop instances of `T`, but\n+        // otherwise cannot read data from `T`.\n+        //\n+        // Of course, for the type expression passed in for any such\n+        // unbounded type parameter `T`, we must resume the recursive\n+        // analysis on `T` (since it would be ignored by\n+        // type_must_outlive).\n+        //\n+        // FIXME (pnkfelix): Long term, we could be smart and actually\n+        // feed which generic parameters can be ignored *into* `fn\n+        // type_must_outlive` (or some generalization thereof). But\n+        // for the short term, it probably covers most cases of\n+        // interest to just special case Drop impls where: (1.) there\n+        // are no generic lifetime parameters and (2.)  *all* generic\n+        // type parameters are unbounded.  If both conditions hold, we\n+        // simply skip the `type_must_outlive` call entirely (but\n+        // resume the recursive checking of the type-substructure).\n+\n+        let has_dtor_of_interest;\n+\n+        if let Some(&dtor_method_did) = opt_dtor {\n+            let impl_did = ty::impl_of_method(rcx.tcx(), dtor_method_did)\n+                .unwrap_or_else(|| {\n+                    rcx.tcx().sess.span_bug(\n+                        span, \"no Drop impl found for drop method\")\n+                });\n+\n+            let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n+            let dtor_generics = dtor_typescheme.generics;\n+\n+            let has_pred_of_interest = dtor_generics.predicates.iter().any(|pred| {\n+                // In `impl<T> Drop where ...`, we automatically\n+                // assume some predicate will be meaningful and thus\n+                // represents a type through which we could reach\n+                // borrowed data. However, there can be implicit\n+                // predicates (namely for Sized), and so we still need\n+                // to walk through and filter out those cases.\n+\n+                let result = match *pred {\n+                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                        let def_id = t_pred.trait_ref.def_id;\n+                        match rcx.tcx().lang_items.to_builtin_kind(def_id) {\n+                            Some(ty::BoundSend) |\n+                            Some(ty::BoundSized) |\n+                            Some(ty::BoundCopy) |\n+                            Some(ty::BoundSync) => false,\n+                            _ => true,\n+                        }\n+                    }\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::Projection(..) => {\n+                        // we assume all of these where-clauses may\n+                        // give the drop implementation the capabilty\n+                        // to access borrowed data.\n+                        true\n+                    }\n+                };\n+\n+                if result {\n+                    debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n+                           typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n+                }\n+\n+                result\n+            });\n+\n+            let has_type_param_of_interest = dtor_generics.types.iter().any(|t| {\n+                let &ty::ParamBounds {\n+                    ref region_bounds, builtin_bounds, ref trait_bounds,\n+                    ref projection_bounds,\n+                } = &t.bounds;\n+\n+                // Belt-and-suspenders: The current set of builtin\n+                // bounds {Send, Sized, Copy, Sync} do not introduce\n+                // any new capability to access borrowed data hidden\n+                // behind a type parameter.\n+                //\n+                // In case new builtin bounds get added that do not\n+                // satisfy that property, ensure `builtin_bounds \\\n+                // {Send,Sized,Copy,Sync}` is empty.\n+\n+                let mut builtin_bounds = builtin_bounds;\n+                builtin_bounds.remove(&ty::BoundSend);\n+                builtin_bounds.remove(&ty::BoundSized);\n+                builtin_bounds.remove(&ty::BoundCopy);\n+                builtin_bounds.remove(&ty::BoundSync);\n+\n+                let has_bounds =\n+                    !region_bounds.is_empty() ||\n+                    !builtin_bounds.is_empty() ||\n+                    !trait_bounds.is_empty() ||\n+                    !projection_bounds.is_empty();\n+\n+                if has_bounds {\n+                    debug!(\"typ: {} has interesting dtor due to \\\n+                            bounds on param {}\",\n+                           typ.repr(rcx.tcx()), t.name);\n+                }\n+\n+                has_bounds\n+\n+            });\n+\n+            // In `impl<'a> Drop ...`, we automatically assume\n+            // `'a` is meaningful and thus represents a bound\n+            // through which we could reach borrowed data.\n+            //\n+            // FIXME (pnkfelix): In the future it would be good to\n+            // extend the language to allow the user to express,\n+            // in the impl signature, that a lifetime is not\n+            // actually used (something like `where 'a: ?Live`).\n+            let has_region_param_of_interest =\n+                dtor_generics.has_region_params(subst::TypeSpace);\n+\n+            has_dtor_of_interest =\n+                has_region_param_of_interest ||\n+                has_type_param_of_interest ||\n+                has_pred_of_interest;\n+\n+            if has_dtor_of_interest {\n+                debug!(\"typ: {} has interesting dtor, due to \\\n+                        region params: {} type params: {} or pred: {}\",\n+                       typ.repr(rcx.tcx()),\n+                       has_region_param_of_interest,\n+                       has_type_param_of_interest,\n+                       has_pred_of_interest);\n+            } else {\n+                debug!(\"typ: {} has dtor, but it is uninteresting\",\n+                       typ.repr(rcx.tcx()));\n+            }\n+\n+        } else {\n+            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n+                   typ.repr(rcx.tcx()));\n+            has_dtor_of_interest = false;\n+        }\n \n-        if has_dtor {\n+        if has_dtor_of_interest {\n             // If `typ` has a destructor, then we must ensure that all\n             // borrowed data reachable via `typ` must outlive the\n             // parent of `scope`. (It does not suffice for it to\n             // outlive `scope` because that could imply that the\n             // borrowed data is torn down in between the end of\n-            // `scope` and when the destructor itself actually runs.\n+            // `scope` and when the destructor itself actually runs.)\n \n             let parent_region =\n                 match rcx.tcx().region_maps.opt_encl_scope(scope) {"}]}