{"sha": "7a87e30f410edac790bffa7ef10d1d184f3733b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhODdlMzBmNDEwZWRhYzc5MGJmZmE3ZWYxMGQxZDE4NGYzNzMzYjk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-16T12:59:33Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-16T22:41:06Z"}, "message": "rustc_resolve: overhaul `#![feature(uniform_paths)]` error reporting.", "tree": {"sha": "4b5069ab9ec8e5c427a802e643cd0abd5af043a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b5069ab9ec8e5c427a802e643cd0abd5af043a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a87e30f410edac790bffa7ef10d1d184f3733b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a87e30f410edac790bffa7ef10d1d184f3733b9", "html_url": "https://github.com/rust-lang/rust/commit/7a87e30f410edac790bffa7ef10d1d184f3733b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a87e30f410edac790bffa7ef10d1d184f3733b9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc323ba160273c3d5867e5920f3861943a49e80a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc323ba160273c3d5867e5920f3861943a49e80a", "html_url": "https://github.com/rust-lang/rust/commit/fc323ba160273c3d5867e5920f3861943a49e80a"}], "stats": {"total": 251, "additions": 195, "deletions": 56}, "files": [{"sha": "c70f52e91dbb6fe36967de867eeb6de354829789", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 95, "deletions": 34, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -11,7 +11,7 @@\n use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n-use Namespace::{self, TypeNS, MacroNS, ValueNS};\n+use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use Resolver;\n use {names_to_string, module_to_string};\n@@ -34,6 +34,8 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n+use std::collections::BTreeMap;\n+use std::fmt::Write;\n use std::{mem, ptr};\n \n /// Contains data for specific types of import directives.\n@@ -615,6 +617,17 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             self.finalize_resolutions_in(module);\n         }\n \n+        #[derive(Default)]\n+        struct UniformPathsCanaryResult {\n+            module_scope: Option<Span>,\n+            block_scopes: Vec<Span>,\n+        }\n+        // Collect all tripped `uniform_paths` canaries separately.\n+        let mut uniform_paths_canaries: BTreeMap<\n+            (Span, NodeId),\n+            (Name, PerNS<UniformPathsCanaryResult>),\n+        > = BTreeMap::new();\n+\n         let mut errors = false;\n         let mut seen_spans = FxHashSet();\n         for i in 0 .. self.determined_imports.len() {\n@@ -624,49 +637,37 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // For a `#![feature(uniform_paths)]` `use self::x as _` canary,\n             // failure is ignored, while success may cause an ambiguity error.\n             if import.is_uniform_paths_canary {\n-                let (name, result) = match import.subclass {\n-                    SingleImport { source, ref result, .. } => {\n-                        let type_ns = result[TypeNS].get().ok();\n-                        let value_ns = result[ValueNS].get().ok();\n-                        (source.name, type_ns.or(value_ns))\n-                    }\n-                    _ => bug!(),\n-                };\n-\n                 if error.is_some() {\n                     continue;\n                 }\n \n-                let is_explicit_self =\n+                let (name, result) = match import.subclass {\n+                    SingleImport { source, ref result, .. } => (source.name, result),\n+                    _ => bug!(),\n+                };\n+\n+                let has_explicit_self =\n                     import.module_path.len() > 0 &&\n                     import.module_path[0].name == keywords::SelfValue.name();\n-                let extern_crate_exists = self.extern_prelude.contains(&name);\n \n-                // A successful `self::x` is ambiguous with an `x` external crate.\n-                if is_explicit_self && !extern_crate_exists {\n-                    continue;\n-                }\n+                let (prev_name, canary_results) =\n+                    uniform_paths_canaries.entry((import.span, import.id))\n+                        .or_insert((name, PerNS::default()));\n \n-                errors = true;\n+                // All the canaries with the same `id` should have the same `name`.\n+                assert_eq!(*prev_name, name);\n \n-                let msg = format!(\"import from `{}` is ambiguous\", name);\n-                let mut err = self.session.struct_span_err(import.span, &msg);\n-                if extern_crate_exists {\n-                    err.span_label(import.span,\n-                        format!(\"could refer to external crate `::{}`\", name));\n-                }\n-                if let Some(result) = result {\n-                    if is_explicit_self {\n-                        err.span_label(result.span,\n-                            format!(\"could also refer to `self::{}`\", name));\n-                    } else {\n-                        err.span_label(result.span,\n-                            format!(\"shadowed by block-scoped `{}`\", name));\n+                self.per_ns(|_, ns| {\n+                    if let Some(result) = result[ns].get().ok() {\n+                        if has_explicit_self {\n+                            // There should only be one `self::x` (module-scoped) canary.\n+                            assert_eq!(canary_results[ns].module_scope, None);\n+                            canary_results[ns].module_scope = Some(result.span);\n+                        } else {\n+                            canary_results[ns].block_scopes.push(result.span);\n+                        }\n                     }\n-                }\n-                err.help(&format!(\"write `::{0}` or `self::{0}` explicitly instead\", name));\n-                err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n-                err.emit();\n+                });\n             } else if let Some((span, err)) = error {\n                 errors = true;\n \n@@ -694,6 +695,66 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n+        for ((span, _), (name, results)) in uniform_paths_canaries {\n+            self.per_ns(|this, ns| {\n+                let results = &results[ns];\n+\n+                let has_external_crate =\n+                    ns == TypeNS && this.extern_prelude.contains(&name);\n+\n+                // An ambiguity requires more than one possible resolution.\n+                let possible_resultions =\n+                    (has_external_crate as usize) +\n+                    (results.module_scope.is_some() as usize) +\n+                    (!results.block_scopes.is_empty() as usize);\n+                if possible_resultions <= 1 {\n+                    return;\n+                }\n+\n+                errors = true;\n+\n+                // Special-case the error when `self::x` finds its own `use x;`.\n+                if has_external_crate &&\n+                   results.module_scope == Some(span) &&\n+                   results.block_scopes.is_empty() {\n+                    let msg = format!(\"`{}` import is redundant\", name);\n+                    this.session.struct_span_err(span, &msg)\n+                        .span_label(span,\n+                            format!(\"refers to external crate `::{}`\", name))\n+                        .span_label(span,\n+                            format!(\"defines `self::{}`, shadowing itself\", name))\n+                        .help(&format!(\"remove or write `::{}` explicitly instead\", name))\n+                        .note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\")\n+                        .emit();\n+                    return;\n+                }\n+\n+                let msg = format!(\"`{}` import is ambiguous\", name);\n+                let mut err = this.session.struct_span_err(span, &msg);\n+                let mut suggestion_choices = String::new();\n+                if has_external_crate {\n+                    write!(suggestion_choices, \"`::{}`\", name);\n+                    err.span_label(span,\n+                        format!(\"can refer to external crate `::{}`\", name));\n+                }\n+                if let Some(span) = results.module_scope {\n+                    if !suggestion_choices.is_empty() {\n+                        suggestion_choices.push_str(\" or \");\n+                    }\n+                    write!(suggestion_choices, \"`self::{}`\", name);\n+                    err.span_label(span,\n+                        format!(\"can refer to `self::{}`\", name));\n+                }\n+                for &span in &results.block_scopes {\n+                    err.span_label(span,\n+                        format!(\"shadowed by block-scoped `{}`\", name));\n+                }\n+                err.help(&format!(\"write {} explicitly instead\", suggestion_choices));\n+                err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n+                err.emit();\n+            });\n+        }\n+\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if !errors {"}, {"sha": "954736dfd907cf0b09cdae6847334c4cd5980273", "filename": "src/test/run-pass/uniform-paths/basic-nested.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -10,7 +10,7 @@\n \n // edition:2018\n \n-#![feature(uniform_paths)]\n+#![feature(decl_macro, uniform_paths)]\n \n // This test is similar to `basic.rs`, but nested in modules.\n \n@@ -40,6 +40,11 @@ mod bar {\n     // item, e.g. the automatically injected `extern crate std;`, which in\n     // the Rust 2018 should no longer be visible through `crate::std`.\n     pub use std::io;\n+\n+    // Also test that items named `std` in other namespaces don't\n+    // cause ambiguity errors for the import from `std` above.\n+    pub fn std() {}\n+    pub macro std() {}\n }\n \n \n@@ -49,4 +54,6 @@ fn main() {\n     foo::local_io(());\n     io::stdout();\n     bar::io::stdout();\n+    bar::std();\n+    bar::std!();\n }"}, {"sha": "e0992c906663248c172273a83d12a542974edd1c", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -16,7 +16,7 @@\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR import from `std` is ambiguous\n+    //~^ ERROR `std` import is ambiguous\n \n     macro_rules! m {\n         () => {"}, {"sha": "154ee412e72825024a5babb822f9d7c7d5ccc623", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -1,13 +1,13 @@\n-error: import from `std` is ambiguous\n+error: `std` import is ambiguous\n   --> $DIR/ambiguity-macros-nested.rs:18:13\n    |\n LL |       pub use std::io;\n-   |               ^^^ could refer to external crate `::std`\n+   |               ^^^ can refer to external crate `::std`\n ...\n LL | /             mod std {\n LL | |                 pub struct io;\n LL | |             }\n-   | |_____________- could also refer to `self::std`\n+   | |_____________- can refer to `self::std`\n    |\n    = help: write `::std` or `self::std` explicitly instead\n    = note: relative `use` paths enabled by `#![feature(uniform_paths)]`"}, {"sha": "9439d92aa710be0470b34d6b6a30891389a19f88", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -15,7 +15,7 @@\n // This test is similar to `ambiguity.rs`, but with macros defining local items.\n \n use std::io;\n-//~^ ERROR import from `std` is ambiguous\n+//~^ ERROR `std` import is ambiguous\n \n macro_rules! m {\n     () => {"}, {"sha": "3c0d5601f9c8a9e22056d85b0bc6f6beaa0c13c2", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -1,13 +1,13 @@\n-error: import from `std` is ambiguous\n+error: `std` import is ambiguous\n   --> $DIR/ambiguity-macros.rs:17:5\n    |\n LL |   use std::io;\n-   |       ^^^ could refer to external crate `::std`\n+   |       ^^^ can refer to external crate `::std`\n ...\n LL | /         mod std {\n LL | |             pub struct io;\n LL | |         }\n-   | |_________- could also refer to `self::std`\n+   | |_________- can refer to `self::std`\n    |\n    = help: write `::std` or `self::std` explicitly instead\n    = note: relative `use` paths enabled by `#![feature(uniform_paths)]`"}, {"sha": "1756acc6057f2dac81da6dcf785ea94671ae1d15", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -16,7 +16,7 @@\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR import from `std` is ambiguous\n+    //~^ ERROR `std` import is ambiguous\n \n     mod std {\n         pub struct io;"}, {"sha": "a607eeb0b43e0afe693f75e6e1266f8fae4e5f5a", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -1,13 +1,13 @@\n-error: import from `std` is ambiguous\n+error: `std` import is ambiguous\n   --> $DIR/ambiguity-nested.rs:18:13\n    |\n LL |       pub use std::io;\n-   |               ^^^ could refer to external crate `::std`\n+   |               ^^^ can refer to external crate `::std`\n ...\n LL | /     mod std {\n LL | |         pub struct io;\n LL | |     }\n-   | |_____- could also refer to `self::std`\n+   | |_____- can refer to `self::std`\n    |\n    = help: write `::std` or `self::std` explicitly instead\n    = note: relative `use` paths enabled by `#![feature(uniform_paths)]`"}, {"sha": "9ae3d79c22cf225e540ead2fe63e0a21d9cdf849", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -13,7 +13,7 @@\n #![feature(uniform_paths)]\n \n use std::io;\n-//~^ ERROR import from `std` is ambiguous\n+//~^ ERROR `std` import is ambiguous\n \n mod std {\n     pub struct io;"}, {"sha": "c65db3072f440d8435e06516d43623149b7c9114", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -1,13 +1,13 @@\n-error: import from `std` is ambiguous\n+error: `std` import is ambiguous\n   --> $DIR/ambiguity.rs:15:5\n    |\n LL |   use std::io;\n-   |       ^^^ could refer to external crate `::std`\n+   |       ^^^ can refer to external crate `::std`\n ...\n LL | / mod std {\n LL | |     pub struct io;\n LL | | }\n-   | |_- could also refer to `self::std`\n+   | |_- can refer to `self::std`\n    |\n    = help: write `::std` or `self::std` explicitly instead\n    = note: relative `use` paths enabled by `#![feature(uniform_paths)]`"}, {"sha": "ee141d444b2cf36e5dc08a5cdf4100d5b347564e", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -14,10 +14,18 @@\n \n enum Foo { A, B }\n \n+struct std;\n+\n fn main() {\n     enum Foo {}\n     use Foo::*;\n-    //~^ ERROR import from `Foo` is ambiguous\n+    //~^ ERROR `Foo` import is ambiguous\n \n     let _ = (A, B);\n+\n+    fn std() {}\n+    enum std {}\n+    use std as foo;\n+    //~^ ERROR `std` import is ambiguous\n+    //~| ERROR `std` import is ambiguous\n }"}, {"sha": "86d95f2ac4567234c60af0942dd13be8b4ec5193", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.stderr", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -1,13 +1,45 @@\n-error: import from `Foo` is ambiguous\n-  --> $DIR/block-scoped-shadow.rs:19:9\n+error: `Foo` import is ambiguous\n+  --> $DIR/block-scoped-shadow.rs:21:9\n    |\n+LL | enum Foo { A, B }\n+   | ----------------- can refer to `self::Foo`\n+...\n LL |     enum Foo {}\n    |     ----------- shadowed by block-scoped `Foo`\n LL |     use Foo::*;\n    |         ^^^\n    |\n-   = help: write `::Foo` or `self::Foo` explicitly instead\n+   = help: write `self::Foo` explicitly instead\n    = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n \n-error: aborting due to previous error\n+error: `std` import is ambiguous\n+  --> $DIR/block-scoped-shadow.rs:28:9\n+   |\n+LL | struct std;\n+   | ----------- can refer to `self::std`\n+...\n+LL |     enum std {}\n+   |     ----------- shadowed by block-scoped `std`\n+LL |     use std as foo;\n+   |         ^^^ can refer to external crate `::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: `std` import is ambiguous\n+  --> $DIR/block-scoped-shadow.rs:28:9\n+   |\n+LL | struct std;\n+   | ----------- can refer to `self::std`\n+...\n+LL |     fn std() {}\n+   |     ----------- shadowed by block-scoped `std`\n+LL |     enum std {}\n+LL |     use std as foo;\n+   |         ^^^\n+   |\n+   = help: write `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "8f384b7e7af6a582fed362980351097fa81eec55", "filename": "src/test/ui/rust-2018/uniform-paths/redundant.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+use std;\n+\n+fn main() {}"}, {"sha": "dd38407e1646b660fc5302f189da85e1cdbf4e99", "filename": "src/test/ui/rust-2018/uniform-paths/redundant.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a87e30f410edac790bffa7ef10d1d184f3733b9/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.stderr?ref=7a87e30f410edac790bffa7ef10d1d184f3733b9", "patch": "@@ -0,0 +1,14 @@\n+error: `std` import is redundant\n+  --> $DIR/redundant.rs:15:5\n+   |\n+LL | use std;\n+   |     ^^^\n+   |     |\n+   |     refers to external crate `::std`\n+   |     defines `self::std`, shadowing itself\n+   |\n+   = help: remove or write `::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}]}