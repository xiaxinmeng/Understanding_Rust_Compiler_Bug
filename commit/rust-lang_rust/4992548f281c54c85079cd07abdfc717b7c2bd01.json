{"sha": "4992548f281c54c85079cd07abdfc717b7c2bd01", "node_id": "C_kwDOAAsO6NoAKDQ5OTI1NDhmMjgxYzU0Yzg1MDc5Y2QwN2FiZGZjNzE3YjdjMmJkMDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-21T15:43:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-21T15:43:57Z"}, "message": "Auto merge of #8271 - Jarcho:ptr_arg_214, r=flip1995\n\nCheck usages in `ptr_arg`\n\nfixes #214\nfixes #1981\nfixes #3381\nfixes #6406\nfixes #6964\n\nThis does not take into account the return type of the function currently, so `(&Vec<_>) -> &Vec<_>` functions may still be false positives.\n\nThe name given for the type also has to match the real type name, so `type Foo = Vec<u32>` won't trigger the lint, but `type Vec = Vec<u32>` will. I'm not sure if this is the best way to handle this, or if a note about the actual type should be added instead.\n\nchangelog: Check if the argument is used in a way which requires the original type in `ptr_arg`\nchangelog: Lint mutable references in `ptr_arg`", "tree": {"sha": "9603da63ab3bef1000b45dd817225e132ab30d85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9603da63ab3bef1000b45dd817225e132ab30d85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4992548f281c54c85079cd07abdfc717b7c2bd01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4992548f281c54c85079cd07abdfc717b7c2bd01", "html_url": "https://github.com/rust-lang/rust/commit/4992548f281c54c85079cd07abdfc717b7c2bd01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4992548f281c54c85079cd07abdfc717b7c2bd01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4709e6f1d57f13a44fc2654f7e0fb7968b20d4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4709e6f1d57f13a44fc2654f7e0fb7968b20d4b", "html_url": "https://github.com/rust-lang/rust/commit/f4709e6f1d57f13a44fc2654f7e0fb7968b20d4b"}, {"sha": "048297b5b265188ca9864d410a8bebb090e2f5ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/048297b5b265188ca9864d410a8bebb090e2f5ba", "html_url": "https://github.com/rust-lang/rust/commit/048297b5b265188ca9864d410a8bebb090e2f5ba"}], "stats": {"total": 975, "additions": 649, "deletions": 326}, "files": [{"sha": "c2ade4f0db764c1db07a630ae6e49c906df4df3a", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 419, "deletions": 194, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -1,59 +1,44 @@\n //! Checks for usage of  `&Vec[_]` and `&String`.\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::ptr::get_spans;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::walk_ptrs_hir_ty;\n-use clippy_utils::{expr_path_res, is_lint_allowed, match_any_diagnostic_items, paths};\n+use clippy_utils::ty::expr_sig;\n+use clippy_utils::{\n+    expr_path_res, get_expr_use_or_unification_node, is_lint_allowed, match_any_diagnostic_items, path_to_local, paths,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def::Res;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::hir_id::HirIdMap;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, BodyId, Expr, ExprKind, FnDecl, FnRetTy, GenericArg, Impl, ImplItem, ImplItemKind, Item, ItemKind,\n-    Lifetime, MutTy, Mutability, Node, PathSegment, QPath, TraitFn, TraitItem, TraitItemKind, Ty, TyKind,\n+    self as hir, AnonConst, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, FnRetTy, GenericArg,\n+    ImplItemKind, ItemKind, Lifetime, LifetimeName, Mutability, Node, Param, ParamName, PatKind, QPath, TraitFn,\n+    TraitItem, TraitItemKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::{self, AssocItems, AssocKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n use rustc_span::{sym, MultiSpan};\n-use std::borrow::Cow;\n+use std::fmt;\n+use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// This lint checks for function arguments of type `&String`\n-    /// or `&Vec` unless the references are mutable. It will also suggest you\n-    /// replace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\n-    /// calls.\n+    /// This lint checks for function arguments of type `&String`, `&Vec`,\n+    /// `&PathBuf`, and `Cow<_>`. It will also suggest you replace `.clone()` calls\n+    /// with the appropriate `.to_owned()`/`to_string()` calls.\n     ///\n     /// ### Why is this bad?\n     /// Requiring the argument to be of the specific size\n     /// makes the function less useful for no benefit; slices in the form of `&[T]`\n     /// or `&str` usually suffice and can be obtained from other types, too.\n     ///\n     /// ### Known problems\n-    /// The lint does not follow data. So if you have an\n-    /// argument `x` and write `let y = x; y.clone()` the lint will not suggest\n-    /// changing that `.clone()` to `.to_owned()`.\n-    ///\n-    /// Other functions called from this function taking a `&String` or `&Vec`\n-    /// argument may also fail to compile if you change the argument. Applying\n-    /// this lint on them will fix the problem, but they may be in other crates.\n-    ///\n-    /// One notable example of a function that may cause issues, and which cannot\n-    /// easily be changed due to being in the standard library is `Vec::contains`.\n-    /// when called on a `Vec<Vec<T>>`. If a `&Vec` is passed to that method then\n-    /// it will compile, but if a `&[T]` is passed then it will not compile.\n-    ///\n-    /// ```ignore\n-    /// fn cannot_take_a_slice(v: &Vec<u8>) -> bool {\n-    ///     let vec_of_vecs: Vec<Vec<u8>> = some_other_fn();\n-    ///\n-    ///     vec_of_vecs.contains(v)\n-    /// }\n-    /// ```\n-    ///\n-    /// Also there may be `fn(&Vec)`-typed references pointing to your function.\n+    /// There may be `fn(&Vec)`-typed references pointing to your function.\n     /// If you have them, you will get a compiler error after applying this lint's\n     /// suggestions. You then have the choice to undo your changes or change the\n     /// type of the reference.\n@@ -155,32 +140,86 @@ declare_clippy_lint! {\n declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF, INVALID_NULL_PTR_USAGE]);\n \n impl<'tcx> LateLintPass<'tcx> for Ptr {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Fn(ref sig, _, body_id) = item.kind {\n-            check_fn(cx, sig.decl, Some(body_id));\n-        }\n-    }\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n+        if let TraitItemKind::Fn(sig, trait_method) = &item.kind {\n+            if matches!(trait_method, TraitFn::Provided(_)) {\n+                // Handled by check body.\n+                return;\n+            }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n-        if let ImplItemKind::Fn(ref sig, body_id) = item.kind {\n-            let parent_item = cx.tcx.hir().get_parent_item(item.hir_id());\n-            if let Some(Node::Item(it)) = cx.tcx.hir().find(parent_item) {\n-                if let ItemKind::Impl(Impl { of_trait: Some(_), .. }) = it.kind {\n-                    return; // ignore trait impls\n-                }\n+            check_mut_from_ref(cx, sig.decl);\n+            for arg in check_fn_args(\n+                cx,\n+                cx.tcx.fn_sig(item.def_id).skip_binder().inputs(),\n+                sig.decl.inputs,\n+                &[],\n+            ) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    PTR_ARG,\n+                    arg.span,\n+                    &arg.build_msg(),\n+                    \"change this to\",\n+                    format!(\"{}{}\", arg.ref_prefix, arg.deref_ty.display(cx)),\n+                    Applicability::Unspecified,\n+                );\n             }\n-            check_fn(cx, sig.decl, Some(body_id));\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n-        if let TraitItemKind::Fn(ref sig, ref trait_method) = item.kind {\n-            let body_id = if let TraitFn::Provided(b) = *trait_method {\n-                Some(b)\n-            } else {\n-                None\n-            };\n-            check_fn(cx, sig.decl, body_id);\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        let hir = cx.tcx.hir();\n+        let mut parents = hir.parent_iter(body.value.hir_id);\n+        let (item_id, decl) = match parents.next() {\n+            Some((_, Node::Item(i))) => {\n+                if let ItemKind::Fn(sig, ..) = &i.kind {\n+                    (i.def_id, sig.decl)\n+                } else {\n+                    return;\n+                }\n+            },\n+            Some((_, Node::ImplItem(i))) => {\n+                if !matches!(parents.next(),\n+                    Some((_, Node::Item(i))) if matches!(&i.kind, ItemKind::Impl(i) if i.of_trait.is_none())\n+                ) {\n+                    return;\n+                }\n+                if let ImplItemKind::Fn(sig, _) = &i.kind {\n+                    (i.def_id, sig.decl)\n+                } else {\n+                    return;\n+                }\n+            },\n+            Some((_, Node::TraitItem(i))) => {\n+                if let TraitItemKind::Fn(sig, _) = &i.kind {\n+                    (i.def_id, sig.decl)\n+                } else {\n+                    return;\n+                }\n+            },\n+            _ => return,\n+        };\n+\n+        check_mut_from_ref(cx, decl);\n+        let sig = cx.tcx.fn_sig(item_id).skip_binder();\n+        let lint_args: Vec<_> = check_fn_args(cx, sig.inputs(), decl.inputs, body.params).collect();\n+        let results = check_ptr_arg_usage(cx, body, &lint_args);\n+\n+        for (result, args) in results.iter().zip(lint_args.iter()).filter(|(r, _)| !r.skip) {\n+            span_lint_and_then(cx, PTR_ARG, args.span, &args.build_msg(), |diag| {\n+                diag.multipart_suggestion(\n+                    \"change this to\",\n+                    iter::once((args.span, format!(\"{}{}\", args.ref_prefix, args.deref_ty.display(cx))))\n+                        .chain(result.replacements.iter().map(|r| {\n+                            (\n+                                r.expr_span,\n+                                format!(\"{}{}\", snippet_opt(cx, r.self_span).unwrap(), r.replacement),\n+                            )\n+                        }))\n+                        .collect(),\n+                    Applicability::Unspecified,\n+                );\n+            });\n         }\n     }\n \n@@ -247,154 +286,206 @@ fn check_invalid_ptr_usage<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     }\n }\n \n-#[allow(clippy::too_many_lines)]\n-fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, opt_body_id: Option<BodyId>) {\n-    let body = opt_body_id.map(|id| cx.tcx.hir().body(id));\n-\n-    for (idx, arg) in decl.inputs.iter().enumerate() {\n-        // Honor the allow attribute on parameters. See issue 5644.\n-        if let Some(body) = &body {\n-            if is_lint_allowed(cx, PTR_ARG, body.params[idx].hir_id) {\n-                continue;\n-            }\n-        }\n+#[derive(Default)]\n+struct PtrArgResult {\n+    skip: bool,\n+    replacements: Vec<PtrArgReplacement>,\n+}\n \n-        let (item_name, path) = if_chain! {\n-            if let TyKind::Rptr(_, MutTy { ty, mutbl: Mutability::Not }) = arg.kind;\n-            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-            if let Res::Def(_, did) = path.res;\n-            if let Some(item_name) = cx.tcx.get_diagnostic_name(did);\n-            then {\n-                (item_name, path)\n-            } else {\n-                continue\n-            }\n-        };\n+struct PtrArgReplacement {\n+    expr_span: Span,\n+    self_span: Span,\n+    replacement: &'static str,\n+}\n \n-        match item_name {\n-            sym::Vec => {\n-                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n-                    span_lint_and_then(\n-                        cx,\n-                        PTR_ARG,\n-                        arg.span,\n-                        \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n-                         with non-Vec-based slices\",\n-                        |diag| {\n-                            if let Some(ref snippet) = get_only_generic_arg_snippet(cx, arg) {\n-                                diag.span_suggestion(\n-                                    arg.span,\n-                                    \"change this to\",\n-                                    format!(\"&[{}]\", snippet),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n-                            for (clonespan, suggestion) in spans {\n-                                diag.span_suggestion(\n-                                    clonespan,\n-                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n-                                        Cow::Owned(format!(\"change `{}` to\", x))\n-                                    }),\n-                                    suggestion.into(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n-                        },\n-                    );\n-                }\n+struct PtrArg<'tcx> {\n+    idx: usize,\n+    span: Span,\n+    ty_did: DefId,\n+    ty_name: Symbol,\n+    method_renames: &'static [(&'static str, &'static str)],\n+    ref_prefix: RefPrefix,\n+    deref_ty: DerefTy<'tcx>,\n+    deref_assoc_items: Option<(DefId, &'tcx AssocItems<'tcx>)>,\n+}\n+impl PtrArg<'_> {\n+    fn build_msg(&self) -> String {\n+        format!(\n+            \"writing `&{}{}` instead of `&{}{}` involves a new object where a slice will do\",\n+            self.ref_prefix.mutability.prefix_str(),\n+            self.ty_name,\n+            self.ref_prefix.mutability.prefix_str(),\n+            self.deref_ty.argless_str(),\n+        )\n+    }\n+}\n+\n+struct RefPrefix {\n+    lt: LifetimeName,\n+    mutability: Mutability,\n+}\n+impl fmt::Display for RefPrefix {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use fmt::Write;\n+        f.write_char('&')?;\n+        match self.lt {\n+            LifetimeName::Param(ParamName::Plain(name)) => {\n+                name.fmt(f)?;\n+                f.write_char(' ')?;\n             },\n-            sym::String => {\n-                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n-                    span_lint_and_then(\n-                        cx,\n-                        PTR_ARG,\n-                        arg.span,\n-                        \"writing `&String` instead of `&str` involves a new object where a slice will do\",\n-                        |diag| {\n-                            diag.span_suggestion(arg.span, \"change this to\", \"&str\".into(), Applicability::Unspecified);\n-                            for (clonespan, suggestion) in spans {\n-                                diag.span_suggestion_short(\n-                                    clonespan,\n-                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n-                                        Cow::Owned(format!(\"change `{}` to\", x))\n-                                    }),\n-                                    suggestion.into(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n-                        },\n-                    );\n+            LifetimeName::Underscore => f.write_str(\"'_ \")?,\n+            LifetimeName::Static => f.write_str(\"'static \")?,\n+            _ => (),\n+        }\n+        f.write_str(self.mutability.prefix_str())\n+    }\n+}\n+\n+struct DerefTyDisplay<'a, 'tcx>(&'a LateContext<'tcx>, &'a DerefTy<'tcx>);\n+impl fmt::Display for DerefTyDisplay<'_, '_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use std::fmt::Write;\n+        match self.1 {\n+            DerefTy::Str => f.write_str(\"str\"),\n+            DerefTy::Path => f.write_str(\"Path\"),\n+            DerefTy::Slice(hir_ty, ty) => {\n+                f.write_char('[')?;\n+                match hir_ty.and_then(|s| snippet_opt(self.0, s)) {\n+                    Some(s) => f.write_str(&s)?,\n+                    None => ty.fmt(f)?,\n                 }\n+                f.write_char(']')\n             },\n-            sym::PathBuf => {\n-                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")]) {\n-                    span_lint_and_then(\n-                        cx,\n-                        PTR_ARG,\n-                        arg.span,\n-                        \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\",\n-                        |diag| {\n-                            diag.span_suggestion(\n-                                arg.span,\n+        }\n+    }\n+}\n+\n+enum DerefTy<'tcx> {\n+    Str,\n+    Path,\n+    Slice(Option<Span>, Ty<'tcx>),\n+}\n+impl<'tcx> DerefTy<'tcx> {\n+    fn argless_str(&self) -> &'static str {\n+        match *self {\n+            Self::Str => \"str\",\n+            Self::Path => \"Path\",\n+            Self::Slice(..) => \"[_]\",\n+        }\n+    }\n+\n+    fn display<'a>(&'a self, cx: &'a LateContext<'tcx>) -> DerefTyDisplay<'a, 'tcx> {\n+        DerefTyDisplay(cx, self)\n+    }\n+}\n+\n+fn check_fn_args<'cx, 'tcx: 'cx>(\n+    cx: &'cx LateContext<'tcx>,\n+    tys: &'tcx [Ty<'_>],\n+    hir_tys: &'tcx [hir::Ty<'_>],\n+    params: &'tcx [Param<'_>],\n+) -> impl Iterator<Item = PtrArg<'tcx>> + 'cx {\n+    tys.iter()\n+        .zip(hir_tys.iter())\n+        .enumerate()\n+        .filter_map(|(i, (ty, hir_ty))| {\n+            if_chain! {\n+                if let ty::Ref(_, ty, mutability) = *ty.kind();\n+                if let ty::Adt(adt, substs) = *ty.kind();\n+\n+                if let TyKind::Rptr(lt, ref ty) = hir_ty.kind;\n+                if let TyKind::Path(QPath::Resolved(None, path)) = ty.ty.kind;\n+\n+                // Check that the name as typed matches the actual name of the type.\n+                // e.g. `fn foo(_: &Foo)` shouldn't trigger the lint when `Foo` is an alias for `Vec`\n+                if let [.., name] = path.segments;\n+                if cx.tcx.item_name(adt.did) == name.ident.name;\n+\n+                if !is_lint_allowed(cx, PTR_ARG, hir_ty.hir_id);\n+                if params.get(i).map_or(true, |p| !is_lint_allowed(cx, PTR_ARG, p.hir_id));\n+\n+                then {\n+                    let (method_renames, deref_ty, deref_impl_id) = match cx.tcx.get_diagnostic_name(adt.did) {\n+                        Some(sym::Vec) => (\n+                            [(\"clone\", \".to_owned()\")].as_slice(),\n+                            DerefTy::Slice(\n+                                name.args\n+                                    .and_then(|args| args.args.first())\n+                                    .and_then(|arg| if let GenericArg::Type(ty) = arg {\n+                                        Some(ty.span)\n+                                    } else {\n+                                        None\n+                                    }),\n+                                substs.type_at(0),\n+                            ),\n+                            cx.tcx.lang_items().slice_impl()\n+                        ),\n+                        Some(sym::String) => (\n+                            [(\"clone\", \".to_owned()\"), (\"as_str\", \"\")].as_slice(),\n+                            DerefTy::Str,\n+                            cx.tcx.lang_items().str_impl()\n+                        ),\n+                        Some(sym::PathBuf) => (\n+                            [(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")].as_slice(),\n+                            DerefTy::Path,\n+                            None,\n+                        ),\n+                        Some(sym::Cow) => {\n+                            let ty_name = name.args\n+                                .and_then(|args| {\n+                                    args.args.iter().find_map(|a| match a {\n+                                        GenericArg::Type(x) => Some(x),\n+                                        _ => None,\n+                                    })\n+                                })\n+                                .and_then(|arg| snippet_opt(cx, arg.span))\n+                                .unwrap_or_else(|| substs.type_at(1).to_string());\n+                            span_lint_and_sugg(\n+                                cx,\n+                                PTR_ARG,\n+                                hir_ty.span,\n+                                \"using a reference to `Cow` is not recommended\",\n                                 \"change this to\",\n-                                \"&Path\".into(),\n+                                format!(\"&{}{}\", mutability.prefix_str(), ty_name),\n                                 Applicability::Unspecified,\n                             );\n-                            for (clonespan, suggestion) in spans {\n-                                diag.span_suggestion_short(\n-                                    clonespan,\n-                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n-                                        Cow::Owned(format!(\"change `{}` to\", x))\n-                                    }),\n-                                    suggestion.into(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n+                            return None;\n                         },\n-                    );\n-                }\n-            },\n-            sym::Cow => {\n-                if_chain! {\n-                    if let [ref bx] = *path.segments;\n-                    if let Some(params) = bx.args;\n-                    if !params.parenthesized;\n-                    if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n-                        GenericArg::Type(ty) => Some(ty),\n-                        _ => None,\n+                        _ => return None,\n+                    };\n+                    return Some(PtrArg {\n+                        idx: i,\n+                        span: hir_ty.span,\n+                        ty_did: adt.did,\n+                        ty_name: name.ident.name,\n+                        method_renames,\n+                        ref_prefix: RefPrefix {\n+                            lt: lt.name,\n+                            mutability,\n+                        },\n+                        deref_ty,\n+                        deref_assoc_items: deref_impl_id.map(|id| (id, cx.tcx.associated_items(id))),\n                     });\n-                    let replacement = snippet_opt(cx, inner.span);\n-                    if let Some(r) = replacement;\n-                    then {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            PTR_ARG,\n-                            arg.span,\n-                            \"using a reference to `Cow` is not recommended\",\n-                            \"change this to\",\n-                            \"&\".to_owned() + &r,\n-                            Applicability::Unspecified,\n-                        );\n-                    }\n                 }\n-            },\n-            _ => {},\n-        }\n-    }\n+            }\n+            None\n+        })\n+}\n \n+fn check_mut_from_ref(cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n     if let FnRetTy::Return(ty) = decl.output {\n         if let Some((out, Mutability::Mut, _)) = get_rptr_lm(ty) {\n             let mut immutables = vec![];\n-            for (_, ref mutbl, ref argspan) in decl\n+            for (_, mutbl, argspan) in decl\n                 .inputs\n                 .iter()\n                 .filter_map(get_rptr_lm)\n                 .filter(|&(lt, _, _)| lt.name == out.name)\n             {\n-                if *mutbl == Mutability::Mut {\n+                if mutbl == Mutability::Mut {\n                     return;\n                 }\n-                immutables.push(*argspan);\n+                immutables.push(argspan);\n             }\n             if immutables.is_empty() {\n                 return;\n@@ -413,24 +504,158 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, opt_body_id: Option<BodyId>\n     }\n }\n \n-fn get_only_generic_arg_snippet(cx: &LateContext<'_>, arg: &Ty<'_>) -> Option<String> {\n-    if_chain! {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = walk_ptrs_hir_ty(arg).kind;\n-        if let Some(&PathSegment{args: Some(parameters), ..}) = path.segments.last();\n-        let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        }).collect();\n-        if types.len() == 1;\n-        then {\n-            snippet_opt(cx, types[0].span)\n-        } else {\n-            None\n+#[allow(clippy::too_many_lines)]\n+fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args: &[PtrArg<'tcx>]) -> Vec<PtrArgResult> {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        /// Map from a local id to which argument it came from (index into `Self::args` and\n+        /// `Self::results`)\n+        bindings: HirIdMap<usize>,\n+        /// The arguments being checked.\n+        args: &'cx [PtrArg<'tcx>],\n+        /// The results for each argument (len should match args.len)\n+        results: Vec<PtrArgResult>,\n+        /// The number of arguments which can't be linted. Used to return early.\n+        skip_count: usize,\n+    }\n+    impl<'tcx> Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+        }\n+\n+        fn visit_anon_const(&mut self, _: &'tcx AnonConst) {}\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.skip_count == self.args.len() {\n+                return;\n+            }\n+\n+            // Check if this is local we care about\n+            let args_idx = match path_to_local(e).and_then(|id| self.bindings.get(&id)) {\n+                Some(&i) => i,\n+                None => return walk_expr(self, e),\n+            };\n+            let args = &self.args[args_idx];\n+            let result = &mut self.results[args_idx];\n+\n+            // Helper function to handle early returns.\n+            let mut set_skip_flag = || {\n+                if result.skip {\n+                    self.skip_count += 1;\n+                }\n+                result.skip = true;\n+            };\n+\n+            match get_expr_use_or_unification_node(self.cx.tcx, e) {\n+                Some((Node::Stmt(_), _)) => (),\n+                Some((Node::Local(l), _)) => {\n+                    // Only trace simple bindings. e.g `let x = y;`\n+                    if let PatKind::Binding(BindingAnnotation::Unannotated, id, _, None) = l.pat.kind {\n+                        self.bindings.insert(id, args_idx);\n+                    } else {\n+                        set_skip_flag();\n+                    }\n+                },\n+                Some((Node::Expr(e), child_id)) => match e.kind {\n+                    ExprKind::Call(f, expr_args) => {\n+                        let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n+                        if expr_sig(self.cx, f)\n+                            .map(|sig| sig.input(i).skip_binder().peel_refs())\n+                            .map_or(true, |ty| match *ty.kind() {\n+                                ty::Param(_) => true,\n+                                ty::Adt(def, _) => def.did == args.ty_did,\n+                                _ => false,\n+                            })\n+                        {\n+                            // Passed to a function taking the non-dereferenced type.\n+                            set_skip_flag();\n+                        }\n+                    },\n+                    ExprKind::MethodCall(name, _, expr_args @ [self_arg, ..], _) => {\n+                        let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n+                        if i == 0 {\n+                            // Check if the method can be renamed.\n+                            let name = name.ident.as_str();\n+                            if let Some((_, replacement)) = args.method_renames.iter().find(|&&(x, _)| x == name) {\n+                                result.replacements.push(PtrArgReplacement {\n+                                    expr_span: e.span,\n+                                    self_span: self_arg.span,\n+                                    replacement,\n+                                });\n+                                return;\n+                            }\n+                        }\n+\n+                        let id = if let Some(x) = self.cx.typeck_results().type_dependent_def_id(e.hir_id) {\n+                            x\n+                        } else {\n+                            set_skip_flag();\n+                            return;\n+                        };\n+\n+                        match *self.cx.tcx.fn_sig(id).skip_binder().inputs()[i].peel_refs().kind() {\n+                            ty::Param(_) => {\n+                                set_skip_flag();\n+                            },\n+                            // If the types match check for methods which exist on both types. e.g. `Vec::len` and\n+                            // `slice::len`\n+                            ty::Adt(def, _)\n+                                if def.did == args.ty_did\n+                                    && (i != 0\n+                                        || self.cx.tcx.trait_of_item(id).is_some()\n+                                        || !args.deref_assoc_items.map_or(false, |(id, items)| {\n+                                            items\n+                                                .find_by_name_and_kind(self.cx.tcx, name.ident, AssocKind::Fn, id)\n+                                                .is_some()\n+                                        })) =>\n+                            {\n+                                set_skip_flag();\n+                            },\n+                            _ => (),\n+                        }\n+                    },\n+                    // Indexing is fine for currently supported types.\n+                    ExprKind::Index(e, _) if e.hir_id == child_id => (),\n+                    _ => set_skip_flag(),\n+                },\n+                _ => set_skip_flag(),\n+            }\n         }\n     }\n+\n+    let mut skip_count = 0;\n+    let mut results = args.iter().map(|_| PtrArgResult::default()).collect::<Vec<_>>();\n+    let mut v = V {\n+        cx,\n+        bindings: args\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, arg)| {\n+                let param = &body.params[arg.idx];\n+                match param.pat.kind {\n+                    PatKind::Binding(BindingAnnotation::Unannotated, id, _, None)\n+                        if !is_lint_allowed(cx, PTR_ARG, param.hir_id) =>\n+                    {\n+                        Some((id, i))\n+                    },\n+                    _ => {\n+                        skip_count += 1;\n+                        results[arg.idx].skip = true;\n+                        None\n+                    },\n+                }\n+            })\n+            .collect(),\n+        args,\n+        results,\n+        skip_count,\n+    };\n+    v.visit_expr(&body.value);\n+    v.results\n }\n \n-fn get_rptr_lm<'tcx>(ty: &'tcx Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability, Span)> {\n+fn get_rptr_lm<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability, Span)> {\n     if let TyKind::Rptr(ref lt, ref m) = ty.kind {\n         Some((lt, m.mutbl, ty.span))\n     } else {"}, {"sha": "1d4fe9cfd3cf40a8ac5459cf206f9c0704f711b0", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -291,7 +291,7 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n fn extend_with_struct_pat(\n     qself1: &Option<ast::QSelf>,\n     path1: &ast::Path,\n-    fps1: &mut Vec<ast::PatField>,\n+    fps1: &mut [ast::PatField],\n     rest1: bool,\n     start: usize,\n     alternatives: &mut Vec<P<Pat>>,\n@@ -332,7 +332,7 @@ fn extend_with_struct_pat(\n /// while also requiring `ps1[..n] ~ ps2[..n]` (pre) and `ps1[n + 1..] ~ ps2[n + 1..]` (post),\n /// where `~` denotes semantic equality.\n fn extend_with_matching_product(\n-    targets: &mut Vec<P<Pat>>,\n+    targets: &mut [P<Pat>],\n     start: usize,\n     alternatives: &mut Vec<P<Pat>>,\n     predicate: impl Fn(&PatKind, &[P<Pat>], usize) -> bool,"}, {"sha": "86603132d5317d9de97d59c6f87cf833e4cad72e", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -1850,7 +1850,8 @@ pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool\n }\n \n /// Gets the node where an expression is either used, or it's type is unified with another branch.\n-pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n+/// Returns both the node and the `HirId` of the closest child node.\n+pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<(Node<'tcx>, HirId)> {\n     let mut child_id = expr.hir_id;\n     let mut iter = tcx.hir().parent_iter(child_id);\n     loop {\n@@ -1862,9 +1863,9 @@ pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>\n                 ExprKind::Match(_, [arm], _) if arm.hir_id == child_id => child_id = expr.hir_id,\n                 ExprKind::Block(..) | ExprKind::DropTemps(_) => child_id = expr.hir_id,\n                 ExprKind::If(_, then_expr, None) if then_expr.hir_id == child_id => break None,\n-                _ => break Some(Node::Expr(expr)),\n+                _ => break Some((Node::Expr(expr), child_id)),\n             },\n-            Some((_, node)) => break Some(node),\n+            Some((_, node)) => break Some((node, child_id)),\n         }\n     }\n }\n@@ -1873,18 +1874,21 @@ pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>\n pub fn is_expr_used_or_unified(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     !matches!(\n         get_expr_use_or_unification_node(tcx, expr),\n-        None | Some(Node::Stmt(Stmt {\n-            kind: StmtKind::Expr(_)\n-                | StmtKind::Semi(_)\n-                | StmtKind::Local(Local {\n-                    pat: Pat {\n-                        kind: PatKind::Wild,\n+        None | Some((\n+            Node::Stmt(Stmt {\n+                kind: StmtKind::Expr(_)\n+                    | StmtKind::Semi(_)\n+                    | StmtKind::Local(Local {\n+                        pat: Pat {\n+                            kind: PatKind::Wild,\n+                            ..\n+                        },\n                         ..\n-                    },\n-                    ..\n-                }),\n-            ..\n-        }))\n+                    }),\n+                ..\n+            }),\n+            _\n+        ))\n     )\n }\n "}, {"sha": "dc24bc8e252391588329609da525d0b097cdbd30", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -5,19 +5,22 @@\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{TyKind, Unsafety};\n+use rustc_hir::{Expr, TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, AdtDef, IntTy, Predicate, Ty, TyCtxt, TypeFoldable, UintTy};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n+use rustc_middle::ty::{\n+    self, AdtDef, Binder, FnSig, IntTy, Predicate, PredicateKind, Ty, TyCtxt, TypeFoldable, UintTy,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n \n-use crate::{match_def_path, must_use_attr};\n+use crate::{expr_path_res, match_def_path, must_use_attr};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -410,3 +413,105 @@ pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(P\n     })\n     .flatten()\n }\n+\n+/// A signature for a function like type.\n+#[derive(Clone, Copy)]\n+pub enum ExprFnSig<'tcx> {\n+    Sig(Binder<'tcx, FnSig<'tcx>>),\n+    Closure(Binder<'tcx, FnSig<'tcx>>),\n+    Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>),\n+}\n+impl<'tcx> ExprFnSig<'tcx> {\n+    /// Gets the argument type at the given offset.\n+    pub fn input(self, i: usize) -> Binder<'tcx, Ty<'tcx>> {\n+        match self {\n+            Self::Sig(sig) => sig.input(i),\n+            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_element_ty(i).unwrap()),\n+            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_element_ty(i).unwrap()),\n+        }\n+    }\n+\n+    /// Gets the result type, if one could be found. Note that the result type of a trait may not be\n+    /// specified.\n+    pub fn output(self) -> Option<Binder<'tcx, Ty<'tcx>>> {\n+        match self {\n+            Self::Sig(sig) | Self::Closure(sig) => Some(sig.output()),\n+            Self::Trait(_, output) => output,\n+        }\n+    }\n+}\n+\n+/// If the expression is function like, get the signature for it.\n+pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnSig<'tcx>> {\n+    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = expr_path_res(cx, expr) {\n+        Some(ExprFnSig::Sig(cx.tcx.fn_sig(id)))\n+    } else {\n+        let ty = cx.typeck_results().expr_ty_adjusted(expr).peel_refs();\n+        match *ty.kind() {\n+            ty::Closure(_, subs) => Some(ExprFnSig::Closure(subs.as_closure().sig())),\n+            ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.fn_sig(id).subst(cx.tcx, subs))),\n+            ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n+            ty::Dynamic(bounds, _) => {\n+                let lang_items = cx.tcx.lang_items();\n+                match bounds.principal() {\n+                    Some(bound)\n+                        if Some(bound.def_id()) == lang_items.fn_trait()\n+                            || Some(bound.def_id()) == lang_items.fn_once_trait()\n+                            || Some(bound.def_id()) == lang_items.fn_mut_trait() =>\n+                    {\n+                        let output = bounds\n+                            .projection_bounds()\n+                            .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n+                            .map(|p| p.map_bound(|p| p.ty));\n+                        Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n+                    },\n+                    _ => None,\n+                }\n+            },\n+            ty::Param(_) | ty::Projection(..) => {\n+                let mut inputs = None;\n+                let mut output = None;\n+                let lang_items = cx.tcx.lang_items();\n+\n+                for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n+                    let mut is_input = false;\n+                    if let Some(ty) = pred\n+                        .kind()\n+                        .map_bound(|pred| match pred {\n+                            PredicateKind::Trait(p)\n+                                if (lang_items.fn_trait() == Some(p.def_id())\n+                                    || lang_items.fn_mut_trait() == Some(p.def_id())\n+                                    || lang_items.fn_once_trait() == Some(p.def_id()))\n+                                    && p.self_ty() == ty =>\n+                            {\n+                                is_input = true;\n+                                Some(p.trait_ref.substs.type_at(1))\n+                            },\n+                            PredicateKind::Projection(p)\n+                                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n+                                    && p.projection_ty.self_ty() == ty =>\n+                            {\n+                                is_input = false;\n+                                Some(p.ty)\n+                            },\n+                            _ => None,\n+                        })\n+                        .transpose()\n+                    {\n+                        if is_input && inputs.is_none() {\n+                            inputs = Some(ty);\n+                        } else if !is_input && output.is_none() {\n+                            output = Some(ty);\n+                        } else {\n+                            // Multiple different fn trait impls. Is this even allowed?\n+                            return None;\n+                        }\n+                    }\n+                }\n+\n+                inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+            },\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "ed72423780821792ae61ea24d6fb322547465e16", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -9,7 +9,6 @@ fn do_vec(x: &Vec<i64>) {\n }\n \n fn do_vec_mut(x: &mut Vec<i64>) {\n-    // no error here\n     //Nothing here\n }\n \n@@ -18,7 +17,6 @@ fn do_str(x: &String) {\n }\n \n fn do_str_mut(x: &mut String) {\n-    // no error here\n     //Nothing here either\n }\n \n@@ -27,7 +25,6 @@ fn do_path(x: &PathBuf) {\n }\n \n fn do_path_mut(x: &mut PathBuf) {\n-    // no error here\n     //Nothing here either\n }\n \n@@ -52,7 +49,7 @@ fn cloned(x: &Vec<u8>) -> Vec<u8> {\n     let e = x.clone();\n     let f = e.clone(); // OK\n     let g = x;\n-    let h = g.clone(); // Alas, we cannot reliably detect this without following data.\n+    let h = g.clone();\n     let i = (e).clone();\n     x.clone()\n }\n@@ -156,6 +153,30 @@ mod issue6509 {\n     }\n }\n \n+fn mut_vec_slice_methods(v: &mut Vec<u32>) {\n+    v.copy_within(1..5, 10);\n+}\n+\n+fn mut_vec_vec_methods(v: &mut Vec<u32>) {\n+    v.clear();\n+}\n+\n+fn vec_contains(v: &Vec<u32>) -> bool {\n+    [vec![], vec![0]].as_slice().contains(v)\n+}\n+\n+fn fn_requires_vec(v: &Vec<u32>) -> bool {\n+    vec_contains(v)\n+}\n+\n+fn impl_fn_requires_vec(v: &Vec<u32>, f: impl Fn(&Vec<u32>)) {\n+    f(v);\n+}\n+\n+fn dyn_fn_requires_vec(v: &Vec<u32>, f: &dyn Fn(&Vec<u32>)) {\n+    f(v);\n+}\n+\n // No error for types behind an alias (#7699)\n type A = Vec<u8>;\n fn aliased(a: &A) {}"}, {"sha": "a9613daadde1023cd3953ff27dd9fdbbf4a0a4b0", "filename": "tests/ui/ptr_arg.stderr", "status": "modified", "additions": 71, "deletions": 87, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.stderr?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -1,175 +1,159 @@\n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n+error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:7:14\n    |\n LL | fn do_vec(x: &Vec<i64>) {\n    |              ^^^^^^^^^ help: change this to: `&[i64]`\n    |\n    = note: `-D clippy::ptr-arg` implied by `-D warnings`\n \n+error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:11:18\n+   |\n+LL | fn do_vec_mut(x: &mut Vec<i64>) {\n+   |                  ^^^^^^^^^^^^^ help: change this to: `&mut [i64]`\n+\n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:16:14\n+  --> $DIR/ptr_arg.rs:15:14\n    |\n LL | fn do_str(x: &String) {\n    |              ^^^^^^^ help: change this to: `&str`\n \n+error: writing `&mut String` instead of `&mut str` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:19:18\n+   |\n+LL | fn do_str_mut(x: &mut String) {\n+   |                  ^^^^^^^^^^^ help: change this to: `&mut str`\n+\n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:25:15\n+  --> $DIR/ptr_arg.rs:23:15\n    |\n LL | fn do_path(x: &PathBuf) {\n    |               ^^^^^^^^ help: change this to: `&Path`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:38:18\n+error: writing `&mut PathBuf` instead of `&mut Path` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:27:19\n+   |\n+LL | fn do_path_mut(x: &mut PathBuf) {\n+   |                   ^^^^^^^^^^^^ help: change this to: `&mut Path`\n+\n+error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:35:18\n    |\n LL |     fn do_vec(x: &Vec<i64>);\n    |                  ^^^^^^^^^ help: change this to: `&[i64]`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:51:14\n+error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:48:14\n    |\n LL | fn cloned(x: &Vec<u8>) -> Vec<u8> {\n    |              ^^^^^^^^\n    |\n help: change this to\n    |\n-LL | fn cloned(x: &[u8]) -> Vec<u8> {\n-   |              ~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let e = x.to_owned();\n-   |             ~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     x.to_owned()\n-   |\n+LL ~ fn cloned(x: &[u8]) -> Vec<u8> {\n+LL ~     let e = x.to_owned();\n+LL |     let f = e.clone(); // OK\n+LL |     let g = x;\n+LL ~     let h = g.to_owned();\n+LL |     let i = (e).clone();\n+ ...\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:60:18\n+  --> $DIR/ptr_arg.rs:57:18\n    |\n LL | fn str_cloned(x: &String) -> String {\n    |                  ^^^^^^^\n    |\n help: change this to\n    |\n-LL | fn str_cloned(x: &str) -> String {\n-   |                  ~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let a = x.to_string();\n-   |             ~~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let b = x.to_string();\n-   |             ~~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     x.to_string()\n+LL ~ fn str_cloned(x: &str) -> String {\n+LL ~     let a = x.to_owned();\n+LL ~     let b = x.to_owned();\n+LL |     let c = b.clone();\n+LL |     let d = a.clone().clone().clone();\n+LL ~     x.to_owned()\n    |\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:68:19\n+  --> $DIR/ptr_arg.rs:65:19\n    |\n LL | fn path_cloned(x: &PathBuf) -> PathBuf {\n    |                   ^^^^^^^^\n    |\n help: change this to\n    |\n-LL | fn path_cloned(x: &Path) -> PathBuf {\n-   |                   ~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let a = x.to_path_buf();\n-   |             ~~~~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     let b = x.to_path_buf();\n-   |             ~~~~~~~~~~~~~~~\n-help: change `x.clone()` to\n-   |\n-LL |     x.to_path_buf()\n+LL ~ fn path_cloned(x: &Path) -> PathBuf {\n+LL ~     let a = x.to_path_buf();\n+LL ~     let b = x.to_path_buf();\n+LL |     let c = b.clone();\n+LL |     let d = a.clone().clone().clone();\n+LL ~     x.to_path_buf()\n    |\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:76:44\n+  --> $DIR/ptr_arg.rs:73:44\n    |\n LL | fn false_positive_capacity(x: &Vec<u8>, y: &String) {\n    |                                            ^^^^^^^\n    |\n help: change this to\n    |\n-LL | fn false_positive_capacity(x: &Vec<u8>, y: &str) {\n-   |                                            ~~~~\n-help: change `y.clone()` to\n+LL ~ fn false_positive_capacity(x: &Vec<u8>, y: &str) {\n+LL |     let a = x.capacity();\n+LL ~     let b = y.to_owned();\n+LL ~     let c = y;\n    |\n-LL |     let b = y.to_string();\n-   |             ~~~~~~~~~~~~~\n-help: change `y.as_str()` to\n-   |\n-LL |     let c = y;\n-   |             ~\n \n error: using a reference to `Cow` is not recommended\n-  --> $DIR/ptr_arg.rs:90:25\n+  --> $DIR/ptr_arg.rs:87:25\n    |\n LL | fn test_cow_with_ref(c: &Cow<[i32]>) {}\n    |                         ^^^^^^^^^^^ help: change this to: `&[i32]`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:143:21\n+error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:140:21\n    |\n LL |     fn foo_vec(vec: &Vec<u8>) {\n    |                     ^^^^^^^^\n    |\n help: change this to\n    |\n-LL |     fn foo_vec(vec: &[u8]) {\n-   |                     ~~~~~\n-help: change `vec.clone()` to\n-   |\n-LL |         let _ = vec.to_owned().pop();\n-   |                 ~~~~~~~~~~~~~~\n-help: change `vec.clone()` to\n+LL ~     fn foo_vec(vec: &[u8]) {\n+LL ~         let _ = vec.to_owned().pop();\n+LL ~         let _ = vec.to_owned().clone();\n    |\n-LL |         let _ = vec.to_owned().clone();\n-   |                 ~~~~~~~~~~~~~~\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:148:23\n+  --> $DIR/ptr_arg.rs:145:23\n    |\n LL |     fn foo_path(path: &PathBuf) {\n    |                       ^^^^^^^^\n    |\n help: change this to\n    |\n-LL |     fn foo_path(path: &Path) {\n-   |                       ~~~~~\n-help: change `path.clone()` to\n+LL ~     fn foo_path(path: &Path) {\n+LL ~         let _ = path.to_path_buf().pop();\n+LL ~         let _ = path.to_path_buf().clone();\n    |\n-LL |         let _ = path.to_path_buf().pop();\n-   |                 ~~~~~~~~~~~~~~~~~~\n-help: change `path.clone()` to\n-   |\n-LL |         let _ = path.to_path_buf().clone();\n-   |                 ~~~~~~~~~~~~~~~~~~\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:153:21\n+  --> $DIR/ptr_arg.rs:150:21\n    |\n LL |     fn foo_str(str: &PathBuf) {\n    |                     ^^^^^^^^\n    |\n help: change this to\n    |\n-LL |     fn foo_str(str: &Path) {\n-   |                     ~~~~~\n-help: change `str.clone()` to\n+LL ~     fn foo_str(str: &Path) {\n+LL ~         let _ = str.to_path_buf().pop();\n+LL ~         let _ = str.to_path_buf().clone();\n    |\n-LL |         let _ = str.to_path_buf().pop();\n-   |                 ~~~~~~~~~~~~~~~~~\n-help: change `str.clone()` to\n+\n+error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:156:29\n    |\n-LL |         let _ = str.to_path_buf().clone();\n-   |                 ~~~~~~~~~~~~~~~~~\n+LL | fn mut_vec_slice_methods(v: &mut Vec<u32>) {\n+   |                             ^^^^^^^^^^^^^ help: change this to: `&mut [u32]`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "767518ab0c0f5e1c345cd2acbee0921cefead3ee", "filename": "tests/ui/search_is_some_fixable_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.rs?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -189,7 +189,7 @@ mod issue7392 {\n         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_none();\n     }\n \n-    fn test_string_1(s: &String) -> bool {\n+    fn test_string_1(s: &str) -> bool {\n         s.is_empty()\n     }\n "}, {"sha": "933ce5cf42d2e227f7897e7ce576f38786880abf", "filename": "tests/ui/search_is_some_fixable_none.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fsearch_is_some_fixable_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fsearch_is_some_fixable_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.stderr?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -251,14 +251,6 @@ error: called `is_none()` after searching an `Iterator` with `find`\n LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y)`\n \n-error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/search_is_some_fixable_none.rs:192:25\n-   |\n-LL |     fn test_string_1(s: &String) -> bool {\n-   |                         ^^^^^^^ help: change this to: `&str`\n-   |\n-   = note: `-D clippy::ptr-arg` implied by `-D warnings`\n-\n error: called `is_none()` after searching an `Iterator` with `find`\n   --> $DIR/search_is_some_fixable_none.rs:208:17\n    |\n@@ -289,5 +281,5 @@ error: called `is_none()` after searching an `Iterator` with `find`\n LL |         let _ = v.iter().find(|fp| test_u32_2(*fp.field)).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|fp| test_u32_2(*fp.field))`\n \n-error: aborting due to 44 previous errors\n+error: aborting due to 43 previous errors\n "}, {"sha": "77fd52e4ce7698402433df5715745557b28d187b", "filename": "tests/ui/search_is_some_fixable_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.rs?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -188,7 +188,7 @@ mod issue7392 {\n         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_some();\n     }\n \n-    fn test_string_1(s: &String) -> bool {\n+    fn test_string_1(s: &str) -> bool {\n         s.is_empty()\n     }\n "}, {"sha": "8b424f18ef5b50c60f10d3c69837d748a0778ff6", "filename": "tests/ui/search_is_some_fixable_some.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fsearch_is_some_fixable_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fsearch_is_some_fixable_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.stderr?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -234,14 +234,6 @@ error: called `is_some()` after searching an `Iterator` with `find`\n LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_some();\n    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|(&x, y)| x == *y)`\n \n-error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/search_is_some_fixable_some.rs:191:25\n-   |\n-LL |     fn test_string_1(s: &String) -> bool {\n-   |                         ^^^^^^^ help: change this to: `&str`\n-   |\n-   = note: `-D clippy::ptr-arg` implied by `-D warnings`\n-\n error: called `is_some()` after searching an `Iterator` with `find`\n   --> $DIR/search_is_some_fixable_some.rs:207:26\n    |\n@@ -272,5 +264,5 @@ error: called `is_some()` after searching an `Iterator` with `find`\n LL |         let _ = v.iter().find(|fp| test_u32_2(*fp.field)).is_some();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|fp| test_u32_2(*fp.field))`\n \n-error: aborting due to 44 previous errors\n+error: aborting due to 43 previous errors\n "}, {"sha": "7e3d357ae50dc6e43bae367593e0e1f79fba4fd1", "filename": "tests/ui/slow_vector_initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992548f281c54c85079cd07abdfc717b7c2bd01/tests%2Fui%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fslow_vector_initialization.rs?ref=4992548f281c54c85079cd07abdfc717b7c2bd01", "patch": "@@ -53,7 +53,7 @@ fn resize_vector() {\n     vec1.resize(10, 0);\n }\n \n-fn do_stuff(vec: &mut Vec<u8>) {}\n+fn do_stuff(vec: &mut [u8]) {}\n \n fn extend_vector_with_manipulations_between() {\n     let len = 300;"}]}