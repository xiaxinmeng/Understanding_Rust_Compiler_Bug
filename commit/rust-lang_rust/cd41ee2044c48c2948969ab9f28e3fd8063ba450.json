{"sha": "cd41ee2044c48c2948969ab9f28e3fd8063ba450", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNDFlZTIwNDRjNDhjMjk0ODk2OWFiOWYyOGUzZmQ4MDYzYmE0NTA=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-04-09T08:16:06Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-04-09T22:43:46Z"}, "message": "Add #[start] attribute to define a new entry point function", "tree": {"sha": "2031206b217a34527077e7562d5e35d35157eb63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2031206b217a34527077e7562d5e35d35157eb63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd41ee2044c48c2948969ab9f28e3fd8063ba450", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd41ee2044c48c2948969ab9f28e3fd8063ba450", "html_url": "https://github.com/rust-lang/rust/commit/cd41ee2044c48c2948969ab9f28e3fd8063ba450", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd41ee2044c48c2948969ab9f28e3fd8063ba450/comments", "author": null, "committer": null, "parents": [{"sha": "412a07055c211f2dec4fb87f25b87d2d71fb13de", "url": "https://api.github.com/repos/rust-lang/rust/commits/412a07055c211f2dec4fb87f25b87d2d71fb13de", "html_url": "https://github.com/rust-lang/rust/commit/412a07055c211f2dec4fb87f25b87d2d71fb13de"}], "stats": {"total": 218, "additions": 173, "deletions": 45}, "files": [{"sha": "d725b7000375487643752fef3fed2599f133c5ae", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cd41ee2044c48c2948969ab9f28e3fd8063ba450", "patch": "@@ -698,7 +698,8 @@ pub fn build_session_(sopts: @session::options,\n         parse_sess: p_s,\n         codemap: cm,\n         // For a library crate, this is always none\n-        main_fn: @mut None,\n+        entry_fn: @mut None,\n+        entry_type: @mut None,\n         span_diagnostic: span_diagnostic_handler,\n         filesearch: filesearch,\n         building_library: @mut false,"}, {"sha": "226905bbab72854273011f95e40c707374d4801b", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=cd41ee2044c48c2948969ab9f28e3fd8063ba450", "patch": "@@ -144,14 +144,25 @@ pub struct crate_metadata {\n     data: ~[u8]\n }\n \n+// The type of entry function, so\n+// users can have their own entry\n+// functions that don't start a\n+// scheduler\n+#[deriving(Eq)]\n+pub enum EntryFnType {\n+    EntryMain,\n+    EntryStart\n+}\n+\n pub struct Session_ {\n     targ_cfg: @config,\n     opts: @options,\n     cstore: @mut metadata::cstore::CStore,\n     parse_sess: @mut ParseSess,\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n-    main_fn: @mut Option<(node_id, codemap::span)>,\n+    entry_fn: @mut Option<(node_id, codemap::span)>,\n+    entry_type: @mut Option<EntryFnType>,\n     span_diagnostic: @diagnostic::span_handler,\n     filesearch: @filesearch::FileSearch,\n     building_library: @mut bool,"}, {"sha": "36f396d4dfc6bc4dcc13d191a2eaf07c5f3135dc", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cd41ee2044c48c2948969ab9f28e3fd8063ba450", "patch": "@@ -801,6 +801,8 @@ pub fn Resolver(session: Session,\n         attr_main_fn: None,\n         main_fns: ~[],\n \n+        start_fn: None,\n+\n         def_map: @mut HashMap::new(),\n         export_map2: @mut HashMap::new(),\n         trait_map: HashMap::new(),\n@@ -860,9 +862,13 @@ pub struct Resolver {\n \n     // The function that has attribute named 'main'\n     attr_main_fn: Option<(node_id, span)>,\n-    // The functions named 'main'\n+\n+    // The functions that could be main functions\n     main_fns: ~[Option<(node_id, span)>],\n \n+    // The function that has the attribute 'start' on it\n+    start_fn: Option<(node_id, span)>,\n+\n     def_map: DefMap,\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n@@ -3538,6 +3544,7 @@ pub impl Resolver {\n             item_fn(ref fn_decl, _, _, ref generics, ref block) => {\n                 // If this is the main function, we must record it in the\n                 // session.\n+\n                 // FIXME #4404 android JNI hacks\n                 if !*self.session.building_library ||\n                     self.session.targ_cfg.os == session::os_android {\n@@ -3557,6 +3564,16 @@ pub impl Resolver {\n                                     ~\"multiple 'main' functions\");\n                         }\n                     }\n+\n+                    if attrs_contains_name(item.attrs, ~\"start\") {\n+                        if self.start_fn.is_none() {\n+                            self.start_fn = Some((item.id, item.span));\n+                        } else {\n+                            self.session.span_err(\n+                                    item.span,\n+                                    ~\"multiple 'start' functions\");\n+                        }\n+                    }\n                 }\n \n                 self.resolve_function(OpaqueFunctionRibKind,\n@@ -5096,7 +5113,7 @@ pub impl Resolver {\n     //\n     fn check_duplicate_main(@mut self) {\n         let this = &mut *self;\n-        if this.attr_main_fn.is_none() {\n+        if this.attr_main_fn.is_none() && this.start_fn.is_none() {\n             if this.main_fns.len() >= 1u {\n                 let mut i = 1u;\n                 while i < this.main_fns.len() {\n@@ -5106,10 +5123,15 @@ pub impl Resolver {\n                         ~\"multiple 'main' functions\");\n                     i += 1;\n                 }\n-                *this.session.main_fn = this.main_fns[0];\n+                *this.session.entry_fn = this.main_fns[0];\n+                *this.session.entry_type = Some(session::EntryMain);\n             }\n+        } else if !this.start_fn.is_none() {\n+            *this.session.entry_fn = this.start_fn;\n+            *this.session.entry_type = Some(session::EntryStart);\n         } else {\n-            *this.session.main_fn = this.attr_main_fn;\n+            *this.session.entry_fn = this.attr_main_fn;\n+            *this.session.entry_type = Some(session::EntryMain);\n         }\n     }\n "}, {"sha": "91b1b50c81ce6bc5ffe3c97801e6682b462f3d01", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 54, "deletions": 33, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cd41ee2044c48c2948969ab9f28e3fd8063ba450", "patch": "@@ -2197,28 +2197,32 @@ pub fn register_fn_fuller(ccx: @CrateContext,\n     ccx.item_symbols.insert(node_id, ps);\n \n     // FIXME #4404 android JNI hacks\n-    let is_main = is_main_fn(&ccx.sess, node_id) &&\n+    let is_entry = is_entry_fn(&ccx.sess, node_id) &&\n                      (!*ccx.sess.building_library ||\n                       (*ccx.sess.building_library &&\n                        ccx.sess.targ_cfg.os == session::os_android));\n-    if is_main { create_main_wrapper(ccx, sp, llfn); }\n+    if is_entry { create_entry_wrapper(ccx, sp, llfn); }\n     llfn\n }\n \n-pub fn is_main_fn(sess: &Session, node_id: ast::node_id) -> bool {\n-    match *sess.main_fn {\n-        Some((main_id, _)) => node_id == main_id,\n+pub fn is_entry_fn(sess: &Session, node_id: ast::node_id) -> bool {\n+    match *sess.entry_fn {\n+        Some((entry_id, _)) => node_id == entry_id,\n         None => false\n     }\n }\n \n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n-pub fn create_main_wrapper(ccx: @CrateContext,\n+pub fn create_entry_wrapper(ccx: @CrateContext,\n                            _sp: span, main_llfn: ValueRef) {\n-\n-    let llfn = create_main(ccx, main_llfn);\n-    create_entry_fn(ccx, llfn);\n+    let et = ccx.sess.entry_type.unwrap();\n+    if et == session::EntryMain {\n+        let llfn = create_main(ccx, main_llfn);\n+        create_entry_fn(ccx, llfn, true);\n+    } else {\n+        create_entry_fn(ccx, main_llfn, false);\n+    }\n \n     fn create_main(ccx: @CrateContext, main_llfn: ValueRef) -> ValueRef {\n         let nt = ty::mk_nil(ccx.tcx);\n@@ -2242,7 +2246,7 @@ pub fn create_main_wrapper(ccx: @CrateContext,\n         return llfdecl;\n     }\n \n-    fn create_entry_fn(ccx: @CrateContext, rust_main: ValueRef) {\n+    fn create_entry_fn(ccx: @CrateContext, rust_main: ValueRef, use_start_lang_item:bool) {\n         let llfty = T_fn(~[ccx.int_type, T_ptr(T_ptr(T_i8()))], ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n@@ -2264,34 +2268,51 @@ pub fn create_main_wrapper(ccx: @CrateContext,\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n         }\n-        let crate_map = ccx.crate_map;\n-        let start_def_id = ccx.tcx.lang_items.start_fn();\n-        let start_fn = if start_def_id.crate == ast::local_crate {\n-            ccx.sess.bug(~\"start lang item is never in the local crate\")\n-        } else {\n-            let start_fn_type = csearch::get_type(ccx.tcx,\n-                                                  start_def_id).ty;\n-            trans_external_path(ccx, start_def_id, start_fn_type)\n-        };\n \n         let retptr = unsafe {\n             llvm::LLVMBuildAlloca(bld, ccx.int_type, noname())\n         };\n \n-        let args = unsafe {\n-            let opaque_rust_main = llvm::LLVMBuildPointerCast(\n-                bld, rust_main, T_ptr(T_i8()), noname());\n-            let opaque_crate_map = llvm::LLVMBuildPointerCast(\n-                bld, crate_map, T_ptr(T_i8()), noname());\n-\n-            ~[\n-                retptr,\n-                C_null(T_opaque_box_ptr(ccx)),\n-                opaque_rust_main,\n-                llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                llvm::LLVMGetParam(llfn, 1 as c_uint),\n-                opaque_crate_map\n-            ]\n+        let crate_map = ccx.crate_map;\n+        let opaque_crate_map = unsafe {llvm::LLVMBuildPointerCast(\n+                bld, crate_map, T_ptr(T_i8()), noname())};\n+\n+        let (start_fn, args) = if use_start_lang_item {\n+            let start_def_id = ccx.tcx.lang_items.start_fn();\n+            let start_fn = if start_def_id.crate == ast::local_crate {\n+                ccx.sess.bug(~\"start lang item is never in the local crate\")\n+            } else {\n+                let start_fn_type = csearch::get_type(ccx.tcx,\n+                        start_def_id).ty;\n+                trans_external_path(ccx, start_def_id, start_fn_type)\n+            };\n+\n+            let args = unsafe {\n+                let opaque_rust_main = llvm::LLVMBuildPointerCast(\n+                        bld, rust_main, T_ptr(T_i8()), noname());\n+\n+                ~[\n+                    retptr,\n+                    C_null(T_opaque_box_ptr(ccx)),\n+                    opaque_rust_main,\n+                    llvm::LLVMGetParam(llfn, 0 as c_uint),\n+                    llvm::LLVMGetParam(llfn, 1 as c_uint),\n+                    opaque_crate_map\n+                 ]\n+            };\n+            (start_fn, args)\n+        } else {\n+            debug!(\"using user-defined start fn\");\n+            let args = unsafe {\n+                ~[ retptr,\n+                   C_null(T_opaque_box_ptr(ccx)),\n+                   llvm::LLVMGetParam(llfn, 0 as c_uint),\n+                   llvm::LLVMGetParam(llfn, 1 as c_uint),\n+                   opaque_crate_map\n+                ]\n+            };\n+\n+            (rust_main, args)\n         };\n \n         unsafe {"}, {"sha": "c10a2c80d7ede374a2620536e3ef827971e82496", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=cd41ee2044c48c2948969ab9f28e3fd8063ba450", "patch": "@@ -50,6 +50,8 @@ independently:\n \n use core::prelude::*;\n \n+use driver::session;\n+\n use middle::resolve;\n use middle::ty;\n use util::common::time;\n@@ -62,7 +64,8 @@ use std::list::List;\n use std::list;\n use syntax::codemap::span;\n use syntax::print::pprust::*;\n-use syntax::{ast, ast_map};\n+use syntax::{ast, ast_map, abi};\n+use syntax::opt_vec;\n \n #[path = \"check/mod.rs\"]\n pub mod check;\n@@ -325,12 +328,68 @@ fn check_main_fn_ty(ccx: @mut CrateCtxt,\n     }\n }\n \n-fn check_for_main_fn(ccx: @mut CrateCtxt) {\n+fn check_start_fn_ty(ccx: @mut CrateCtxt,\n+                     start_id: ast::node_id,\n+                     start_span: span) {\n+\n+    let tcx = ccx.tcx;\n+    let start_t = ty::node_id_to_type(tcx, start_id);\n+    match ty::get(start_t).sty {\n+        ty::ty_bare_fn(_) => {\n+            match tcx.items.find(&start_id) {\n+                Some(&ast_map::node_item(it,_)) => {\n+                    match it.node {\n+                        ast::item_fn(_,_,_,ref ps,_)\n+                        if ps.is_parameterized() => {\n+                            tcx.sess.span_err(\n+                                start_span,\n+                                ~\"start function is not allowed to have type \\\n+                                parameters\");\n+                            return;\n+                        }\n+                        _ => ()\n+                    }\n+                }\n+                _ => ()\n+            }\n+\n+            fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n+                ty::arg {mode: ast::expl(m), ty: ty}\n+            }\n+\n+            let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+                purity: ast::impure_fn,\n+                abis: abi::AbiSet::Rust(),\n+                sig: ty::FnSig {bound_lifetime_names: opt_vec::Empty,\n+                            inputs: ~[arg(ast::by_copy, ty::mk_int(tcx)),\n+                                      arg(ast::by_copy, ty::mk_imm_ptr(tcx,\n+                                                            ty::mk_imm_ptr(tcx, ty::mk_u8(tcx)))),\n+                                      arg(ast::by_copy, ty::mk_imm_ptr(tcx, ty::mk_u8(tcx)))],\n+                            output: ty::mk_int(tcx)}\n+            });\n+\n+            require_same_types(tcx, None, false, start_span, start_t, se_ty,\n+                || fmt!(\"start function expects type: `%s`\", ppaux::ty_to_str(ccx.tcx, se_ty)));\n+\n+        }\n+        _ => {\n+            tcx.sess.span_bug(start_span,\n+                              ~\"start has a non-function type: found `\" +\n+                              ppaux::ty_to_str(tcx, start_t) + ~\"`\");\n+        }\n+    }\n+}\n+\n+fn check_for_entry_fn(ccx: @mut CrateCtxt) {\n     let tcx = ccx.tcx;\n     if !*tcx.sess.building_library {\n-        match *tcx.sess.main_fn {\n-          Some((id, sp)) => check_main_fn_ty(ccx, id, sp),\n-          None => tcx.sess.err(~\"main function not found\")\n+        match *tcx.sess.entry_fn {\n+          Some((id, sp)) => match *tcx.sess.entry_type {\n+              Some(session::EntryMain) => check_main_fn_ty(ccx, id, sp),\n+              Some(session::EntryStart) => check_start_fn_ty(ccx, id, sp),\n+              None => tcx.sess.bug(~\"entry function without a type\")\n+          },\n+          None => tcx.sess.err(~\"entry function not found\")\n         }\n     }\n }\n@@ -357,7 +416,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     time(time_passes, ~\"type checking\", ||\n         check::check_item_types(ccx, crate));\n \n-    check_for_main_fn(ccx);\n+    check_for_entry_fn(ccx);\n     tcx.sess.abort_if_errors();\n     (ccx.method_map, ccx.vtable_map)\n }"}, {"sha": "efbd7da4797e1ca4795e2ee77d451822ab66de97", "filename": "src/test/run-pass/attr-start.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Ftest%2Frun-pass%2Fattr-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd41ee2044c48c2948969ab9f28e3fd8063ba450/src%2Ftest%2Frun-pass%2Fattr-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-start.rs?ref=cd41ee2044c48c2948969ab9f28e3fd8063ba450", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[start]\n+fn start(argc:int, argv: **u8, crate_map: *u8) -> int {\n+    return 0;\n+}"}]}