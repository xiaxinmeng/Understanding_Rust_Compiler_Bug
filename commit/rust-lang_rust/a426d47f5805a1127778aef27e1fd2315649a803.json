{"sha": "a426d47f5805a1127778aef27e1fd2315649a803", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MjZkNDdmNTgwNWExMTI3Nzc4YWVmMjdlMWZkMjMxNTY0OWE4MDM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-22T11:40:23Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-31T08:15:58Z"}, "message": "Group dep node data into a single structure", "tree": {"sha": "8b571a36572bcacea3a2ce592302b422a2a41d87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b571a36572bcacea3a2ce592302b422a2a41d87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a426d47f5805a1127778aef27e1fd2315649a803", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a426d47f5805a1127778aef27e1fd2315649a803", "html_url": "https://github.com/rust-lang/rust/commit/a426d47f5805a1127778aef27e1fd2315649a803", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a426d47f5805a1127778aef27e1fd2315649a803/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f39bd9b9cb71de6650bcf0c5b08e42af6f5df491", "url": "https://api.github.com/repos/rust-lang/rust/commits/f39bd9b9cb71de6650bcf0c5b08e42af6f5df491", "html_url": "https://github.com/rust-lang/rust/commit/f39bd9b9cb71de6650bcf0c5b08e42af6f5df491"}], "stats": {"total": 335, "additions": 165, "deletions": 170}, "files": [{"sha": "070551c0b7b0af8233358f8cfaef54441050b28c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a426d47f5805a1127778aef27e1fd2315649a803/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a426d47f5805a1127778aef27e1fd2315649a803/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a426d47f5805a1127778aef27e1fd2315649a803", "patch": "@@ -423,17 +423,6 @@ impl DefId {\n     }\n }\n \n-impl DepKind {\n-    #[inline]\n-    pub fn fingerprint_needed_for_crate_hash(self) -> bool {\n-        match self {\n-            DepKind::HirBody |\n-            DepKind::Krate => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n define_dep_nodes!( <'tcx>\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,"}, {"sha": "8423c90447a25db1efe43420095645e7afab1cb3", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 80, "deletions": 115, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/a426d47f5805a1127778aef27e1fd2315649a803/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a426d47f5805a1127778aef27e1fd2315649a803/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=a426d47f5805a1127778aef27e1fd2315649a803", "patch": "@@ -21,12 +21,6 @@ use super::prev::PreviousDepGraph;\n #[derive(Clone)]\n pub struct DepGraph {\n     data: Option<Lrc<DepGraphData>>,\n-\n-    // A vector mapping depnodes from the current graph to their associated\n-    // result value fingerprints. Do not rely on the length of this vector\n-    // being the same as the number of nodes in the graph. The vector can\n-    // contain an arbitrary number of zero-entries at the end.\n-    fingerprints: Lrc<Lock<IndexVec<DepNodeIndex, Fingerprint>>>\n }\n \n newtype_index! {\n@@ -81,30 +75,23 @@ impl DepGraph {\n \n     pub fn new(prev_graph: PreviousDepGraph,\n                prev_work_products: FxHashMap<WorkProductId, WorkProduct>) -> DepGraph {\n-        // Pre-allocate the fingerprints array. We over-allocate a little so\n-        // that we hopefully don't have to re-allocate during this compilation\n-        // session.\n         let prev_graph_node_count = prev_graph.node_count();\n \n-        let fingerprints = IndexVec::from_elem_n(Fingerprint::ZERO,\n-                                                 (prev_graph_node_count * 115) / 100);\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: Lock::new(CurrentDepGraph::new()),\n+                current: Lock::new(CurrentDepGraph::new(prev_graph_node_count)),\n                 previous: prev_graph,\n                 colors: Lock::new(DepNodeColorMap::new(prev_graph_node_count)),\n                 loaded_from_cache: Default::default(),\n             })),\n-            fingerprints: Lrc::new(Lock::new(fingerprints)),\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph {\n         DepGraph {\n             data: None,\n-            fingerprints: Lrc::new(Lock::new(IndexVec::new())),\n         }\n     }\n \n@@ -116,12 +103,12 @@ impl DepGraph {\n \n     pub fn query(&self) -> DepGraphQuery {\n         let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n-        let nodes: Vec<_> = current_dep_graph.nodes.iter().cloned().collect();\n+        let nodes: Vec<_> = current_dep_graph.data.iter().map(|n| n.node).collect();\n         let mut edges = Vec::new();\n-        for (index, edge_targets) in current_dep_graph.edges.iter_enumerated() {\n-            let from = current_dep_graph.nodes[index];\n+        for (from, edge_targets) in current_dep_graph.data.iter()\n+                                                           .map(|d| (d.node, &d.edges)) {\n             for &edge_target in edge_targets.iter() {\n-                let to = current_dep_graph.nodes[edge_target];\n+                let to = current_dep_graph.data[edge_target].node;\n                 edges.push((from, to));\n             }\n         }\n@@ -201,7 +188,7 @@ impl DepGraph {\n                 reads: SmallVec::new(),\n                 read_set: Default::default(),\n             })),\n-            |data, key, task| data.borrow_mut().complete_task(key, task))\n+            |data, key, f, task| data.borrow_mut().complete_task(key, task, f))\n     }\n \n     /// Creates a new dep-graph input with value `input`\n@@ -219,7 +206,7 @@ impl DepGraph {\n \n         self.with_task_impl(key, cx, input, true, identity_fn,\n             |_| OpenTask::Ignore,\n-            |data, key, _| data.borrow_mut().alloc_node(key, SmallVec::new()))\n+            |data, key, f, _| data.borrow_mut().alloc_node(key, SmallVec::new(), f))\n     }\n \n     fn with_task_impl<'gcx, C, A, R>(\n@@ -232,6 +219,7 @@ impl DepGraph {\n         create_task: fn(DepNode) -> OpenTask,\n         finish_task_and_alloc_depnode: fn(&Lock<CurrentDepGraph>,\n                                           DepNode,\n+                                          Fingerprint,\n                                           OpenTask) -> DepNodeIndex\n     ) -> (R, DepNodeIndex)\n     where\n@@ -271,26 +259,17 @@ impl DepGraph {\n                 profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n             };\n \n-            let dep_node_index = finish_task_and_alloc_depnode(&data.current, key, open_task);\n-\n             let mut stable_hasher = StableHasher::new();\n             result.hash_stable(&mut hcx, &mut stable_hasher);\n \n             let current_fingerprint = stable_hasher.finish();\n \n-            // Store the current fingerprint\n-            {\n-                let mut fingerprints = self.fingerprints.borrow_mut();\n-\n-                if dep_node_index.index() >= fingerprints.len() {\n-                    fingerprints.resize(dep_node_index.index() + 1, Fingerprint::ZERO);\n-                }\n-\n-                debug_assert!(fingerprints[dep_node_index] == Fingerprint::ZERO,\n-                              \"DepGraph::with_task() - Duplicate fingerprint \\\n-                               insertion for {:?}\", key);\n-                fingerprints[dep_node_index] = current_fingerprint;\n-            }\n+            let dep_node_index = finish_task_and_alloc_depnode(\n+                &data.current,\n+                key,\n+                current_fingerprint,\n+                open_task\n+            );\n \n             // Determine the color of the new DepNode.\n             if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n@@ -312,25 +291,7 @@ impl DepGraph {\n \n             (result, dep_node_index)\n         } else {\n-            if key.kind.fingerprint_needed_for_crate_hash() {\n-                let mut hcx = cx.get_stable_hashing_context();\n-                let result = task(cx, arg);\n-                let mut stable_hasher = StableHasher::new();\n-                result.hash_stable(&mut hcx, &mut stable_hasher);\n-                let fingerprint = stable_hasher.finish();\n-\n-                let mut fingerprints = self.fingerprints.borrow_mut();\n-                let dep_node_index = DepNodeIndex::new(fingerprints.len());\n-                fingerprints.push(fingerprint);\n-\n-                debug_assert!(fingerprints[dep_node_index] == fingerprint,\n-                              \"DepGraph::with_task() - Assigned fingerprint to \\\n-                               unexpected index for {:?}\", key);\n-\n-                (result, dep_node_index)\n-            } else {\n-                (task(cx, arg), DepNodeIndex::INVALID)\n-            }\n+            (task(cx, arg), DepNodeIndex::INVALID)\n         }\n     }\n \n@@ -381,7 +342,7 @@ impl DepGraph {\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n             |key| OpenTask::EvalAlways { node: key },\n-            |data, key, task| data.borrow_mut().complete_eval_always_task(key, task))\n+            |data, key, f, task| data.borrow_mut().complete_eval_always_task(key, task, f))\n     }\n \n     #[inline]\n@@ -427,17 +388,8 @@ impl DepGraph {\n \n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        match self.fingerprints.borrow().get(dep_node_index) {\n-            Some(&fingerprint) => fingerprint,\n-            None => {\n-                if let Some(ref data) = self.data {\n-                    let dep_node = data.current.borrow().nodes[dep_node_index];\n-                    bug!(\"Could not find current fingerprint for {:?}\", dep_node)\n-                } else {\n-                    bug!(\"Could not find current fingerprint for {:?}\", dep_node_index)\n-                }\n-            }\n-        }\n+        let current = self.data.as_ref().expect(\"dep graph enabled\").current.borrow_mut();\n+        current.data[dep_node_index].fingerprint\n     }\n \n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n@@ -498,17 +450,20 @@ impl DepGraph {\n     pub fn serialize(&self) -> SerializedDepGraph {\n         let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n \n-        let fingerprints = self.fingerprints.borrow().clone().convert_index_type();\n-        let nodes = current_dep_graph.nodes.clone().convert_index_type();\n+        let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n+            current_dep_graph.data.iter().map(|d| d.fingerprint).collect();\n+        let nodes: IndexVec<SerializedDepNodeIndex, _> =\n+            current_dep_graph.data.iter().map(|d| d.node).collect();\n \n-        let total_edge_count: usize = current_dep_graph.edges.iter()\n-                                                             .map(|v| v.len())\n-                                                             .sum();\n+        let total_edge_count: usize = current_dep_graph.data.iter()\n+                                                            .map(|d| d.edges.len())\n+                                                            .sum();\n \n         let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n         let mut edge_list_data = Vec::with_capacity(total_edge_count);\n \n-        for (current_dep_node_index, edges) in current_dep_graph.edges.iter_enumerated() {\n+        for (current_dep_node_index, edges) in current_dep_graph.data.iter_enumerated()\n+                                                                .map(|(i, d)| (i, &d.edges)) {\n             let start = edge_list_data.len() as u32;\n             // This should really just be a memcpy :/\n             edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex::new(i.index())));\n@@ -704,31 +659,15 @@ impl DepGraph {\n                 // Someone else allocated it before us\n                 (dep_node_index, false)\n             } else {\n+                // Copy the fingerprint from the previous graph,\n+                // so we don't have to recompute it\n+                let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n                 // We allocating an entry for the node in the current dependency graph and\n                 // adding all the appropriate edges imported from the previous graph\n-                (current.alloc_node(*dep_node, current_deps), true)\n+                (current.alloc_node(*dep_node, current_deps, fingerprint), true)\n             }\n         };\n \n-        // ... copying the fingerprint from the previous graph too, so we don't\n-        // have to recompute it ...\n-        {\n-            let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n-            let mut fingerprints = self.fingerprints.borrow_mut();\n-\n-            if dep_node_index.index() >= fingerprints.len() {\n-                fingerprints.resize(dep_node_index.index() + 1, Fingerprint::ZERO);\n-            }\n-\n-            // Multiple threads can all write the same fingerprint here\n-            #[cfg(not(parallel_queries))]\n-            debug_assert!(fingerprints[dep_node_index] == Fingerprint::ZERO,\n-                \"DepGraph::try_mark_green() - Duplicate fingerprint \\\n-                insertion for {:?}\", dep_node);\n-\n-            fingerprints[dep_node_index] = fingerprint;\n-        }\n-\n         // ... emitting any stored diagnostic ...\n         if did_allocation {\n             // Only the thread which did the allocation emits the error messages\n@@ -814,7 +753,7 @@ impl DepGraph {\n \n     pub fn mark_loaded_from_cache(&self, dep_node_index: DepNodeIndex, state: bool) {\n         debug!(\"mark_loaded_from_cache({:?}, {})\",\n-               self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index],\n+               self.data.as_ref().unwrap().current.borrow().data[dep_node_index].node,\n                state);\n \n         self.data\n@@ -877,9 +816,15 @@ pub enum WorkProductFileKind {\n     BytecodeCompressed,\n }\n \n+#[derive(Clone)]\n+struct DepNodeData {\n+    node: DepNode,\n+    edges: SmallVec<[DepNodeIndex; 8]>,\n+    fingerprint: Fingerprint,\n+}\n+\n pub(super) struct CurrentDepGraph {\n-    nodes: IndexVec<DepNodeIndex, DepNode>,\n-    edges: IndexVec<DepNodeIndex, SmallVec<[DepNodeIndex; 8]>>,\n+    data: IndexVec<DepNodeIndex, DepNodeData>,\n     node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n     forbidden_edge: Option<EdgeFilter>,\n \n@@ -901,7 +846,7 @@ pub(super) struct CurrentDepGraph {\n }\n \n impl CurrentDepGraph {\n-    fn new() -> CurrentDepGraph {\n+    fn new(prev_graph_node_count: usize) -> CurrentDepGraph {\n         use std::time::{SystemTime, UNIX_EPOCH};\n \n         let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n@@ -924,18 +869,30 @@ impl CurrentDepGraph {\n             None\n         };\n \n+        // Pre-allocate the dep node structures. We over-allocate a little so\n+        // that we hopefully don't have to re-allocate during this compilation\n+        // session.\n+        let new_node_count_estimate = (prev_graph_node_count * 115) / 100;\n+\n         CurrentDepGraph {\n-            nodes: IndexVec::new(),\n-            edges: IndexVec::new(),\n-            node_to_node_index: Default::default(),\n+            data: IndexVec::with_capacity(new_node_count_estimate),\n+            node_to_node_index: FxHashMap::with_capacity_and_hasher(\n+                new_node_count_estimate,\n+                Default::default(),\n+            ),\n             anon_id_seed: stable_hasher.finish(),\n             forbidden_edge,\n             total_read_count: 0,\n             total_duplicate_read_count: 0,\n         }\n     }\n \n-    fn complete_task(&mut self, key: DepNode, task: OpenTask) -> DepNodeIndex {\n+    fn complete_task(\n+        &mut self,\n+        key: DepNode,\n+        task: OpenTask,\n+        fingerprint: Fingerprint\n+    ) -> DepNodeIndex {\n         if let OpenTask::Regular(task) = task {\n             let RegularOpenTask {\n                 node,\n@@ -956,17 +913,17 @@ impl CurrentDepGraph {\n                    //            better in general.\n                    node.kind != DepKind::DefSpan &&\n                     reads.iter().any(|&i| {\n-                        !(self.nodes[i].kind == DepKind::CrateMetadata ||\n-                          self.nodes[i].kind == DepKind::Krate)\n+                        !(self.data[i].node.kind == DepKind::CrateMetadata ||\n+                          self.data[i].node.kind == DepKind::Krate)\n                     })\n                 {\n                     bug!(\"Input node {:?} with unexpected reads: {:?}\",\n                         node,\n-                        reads.iter().map(|&i| self.nodes[i]).collect::<Vec<_>>())\n+                        reads.iter().map(|&i| self.data[i].node).collect::<Vec<_>>())\n                 }\n             }\n \n-            self.alloc_node(node, reads)\n+            self.alloc_node(node, reads, fingerprint)\n         } else {\n             bug!(\"complete_task() - Expected regular task to be popped\")\n         }\n@@ -984,7 +941,7 @@ impl CurrentDepGraph {\n             let mut hasher = StableHasher::new();\n \n             for &read in reads.iter() {\n-                let read_dep_node = self.nodes[read];\n+                let read_dep_node = self.data[read].node;\n \n                 ::std::mem::discriminant(&read_dep_node.kind).hash(&mut hasher);\n \n@@ -1004,20 +961,25 @@ impl CurrentDepGraph {\n             if let Some(&index) = self.node_to_node_index.get(&target_dep_node) {\n                 index\n             } else {\n-                self.alloc_node(target_dep_node, reads)\n+                self.alloc_node(target_dep_node, reads, Fingerprint::ZERO)\n             }\n         } else {\n             bug!(\"pop_anon_task() - Expected anonymous task to be popped\")\n         }\n     }\n \n-    fn complete_eval_always_task(&mut self, key: DepNode, task: OpenTask) -> DepNodeIndex {\n+    fn complete_eval_always_task(\n+        &mut self,\n+        key: DepNode,\n+        task: OpenTask,\n+        fingerprint: Fingerprint\n+    ) -> DepNodeIndex {\n         if let OpenTask::EvalAlways {\n             node,\n         } = task {\n             debug_assert_eq!(node, key);\n             let krate_idx = self.node_to_node_index[&DepNode::new_no_params(DepKind::Krate)];\n-            self.alloc_node(node, smallvec![krate_idx])\n+            self.alloc_node(node, smallvec![krate_idx], fingerprint)\n         } else {\n             bug!(\"complete_eval_always_task() - Expected eval always task to be popped\");\n         }\n@@ -1036,7 +998,7 @@ impl CurrentDepGraph {\n                         if cfg!(debug_assertions) {\n                             if let Some(ref forbidden_edge) = self.forbidden_edge {\n                                 let target = &task.node;\n-                                let source = self.nodes[source];\n+                                let source = self.data[source].node;\n                                 if forbidden_edge.test(&source, &target) {\n                                     bug!(\"forbidden edge {:?} -> {:?} created\",\n                                         source,\n@@ -1063,15 +1025,18 @@ impl CurrentDepGraph {\n \n     fn alloc_node(&mut self,\n                   dep_node: DepNode,\n-                  edges: SmallVec<[DepNodeIndex; 8]>)\n+                  edges: SmallVec<[DepNodeIndex; 8]>,\n+                  fingerprint: Fingerprint)\n                   -> DepNodeIndex {\n-        debug_assert_eq!(self.edges.len(), self.nodes.len());\n-        debug_assert_eq!(self.node_to_node_index.len(), self.nodes.len());\n+        debug_assert_eq!(self.node_to_node_index.len(), self.data.len());\n         debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n-        let dep_node_index = DepNodeIndex::new(self.nodes.len());\n-        self.nodes.push(dep_node);\n+        let dep_node_index = DepNodeIndex::new(self.data.len());\n+        self.data.push(DepNodeData {\n+            node: dep_node,\n+            edges,\n+            fingerprint\n+        });\n         self.node_to_node_index.insert(dep_node, dep_node_index);\n-        self.edges.push(edges);\n         dep_node_index\n     }\n }"}, {"sha": "f574b757c40c986819fbfa27ac2e1f3ff24596d0", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 85, "deletions": 44, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a426d47f5805a1127778aef27e1fd2315649a803/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a426d47f5805a1127778aef27e1fd2315649a803/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a426d47f5805a1127778aef27e1fd2315649a803", "patch": "@@ -41,21 +41,69 @@ pub(super) struct NodeCollector<'a, 'hir> {\n \n     // We are collecting DepNode::HirBody hashes here so we can compute the\n     // crate hash from then later on.\n-    hir_body_nodes: Vec<(DefPathHash, DepNodeIndex)>,\n+    hir_body_nodes: Vec<(DefPathHash, Fingerprint)>,\n+}\n+\n+fn input_dep_node_and_hash<'a, I>(\n+    dep_graph: &DepGraph,\n+    hcx: &mut StableHashingContext<'a>,\n+    def_node: DepNode,\n+    input: I,\n+) -> (DepNodeIndex, Fingerprint)\n+where\n+    I: HashStable<StableHashingContext<'a>>,\n+{\n+    let dep_node_index = dep_graph.input_task(def_node, &mut *hcx, &input).1;\n+\n+    let hash = if dep_graph.is_fully_enabled() {\n+        dep_graph.fingerprint_of(dep_node_index)\n+    } else {\n+        let mut stable_hasher = StableHasher::new();\n+        input.hash_stable(hcx, &mut stable_hasher);\n+        stable_hasher.finish()\n+    };\n+\n+    (dep_node_index, hash)\n+}\n+\n+fn hir_dep_nodes<'a, I>(\n+    dep_graph: &DepGraph,\n+    hcx: &mut StableHashingContext<'a>,\n+    def_path_hash: DefPathHash,\n+    item_like: I,\n+    hir_body_nodes: &mut Vec<(DefPathHash, Fingerprint)>,\n+) -> (DepNodeIndex, DepNodeIndex)\n+where\n+    I: HashStable<StableHashingContext<'a>>,\n+{\n+    let sig = dep_graph.input_task(\n+        def_path_hash.to_dep_node(DepKind::Hir),\n+        &mut *hcx,\n+        HirItemLike { item_like: &item_like, hash_bodies: false },\n+    ).1;\n+    let (full, hash) = input_dep_node_and_hash(\n+        dep_graph,\n+        hcx,\n+        def_path_hash.to_dep_node(DepKind::HirBody),\n+        HirItemLike { item_like: &item_like, hash_bodies: true },\n+    );\n+    hir_body_nodes.push((def_path_hash, hash));\n+    (sig, full)\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn root(krate: &'hir Crate,\n                        dep_graph: &'a DepGraph,\n                        definitions: &'a definitions::Definitions,\n-                       hcx: StableHashingContext<'a>,\n+                       mut hcx: StableHashingContext<'a>,\n                        source_map: &'a SourceMap)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n \n+        let mut hir_body_nodes = Vec::new();\n+\n         // Allocate DepNodes for the root module\n-        let (root_mod_sig_dep_index, root_mod_full_dep_index);\n-        {\n+        let (root_mod_sig_dep_index, root_mod_full_dep_index) = {\n             let Crate {\n                 ref module,\n                 // Crate attributes are not copied over to the root `Mod`, so hash\n@@ -73,28 +121,23 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 body_ids: _,\n             } = *krate;\n \n-            root_mod_sig_dep_index = dep_graph.input_task(\n-                root_mod_def_path_hash.to_dep_node(DepKind::Hir),\n-                &hcx,\n-                HirItemLike { item_like: (module, attrs, span), hash_bodies: false },\n-            ).1;\n-            root_mod_full_dep_index = dep_graph.input_task(\n-                root_mod_def_path_hash.to_dep_node(DepKind::HirBody),\n-                &hcx,\n-                HirItemLike { item_like: (module, attrs, span), hash_bodies: true },\n-            ).1;\n-        }\n+            hir_dep_nodes(\n+                dep_graph,\n+                &mut hcx,\n+                root_mod_def_path_hash,\n+                (module, attrs, span),\n+                &mut hir_body_nodes,\n+            )\n+        };\n \n         {\n             dep_graph.input_task(\n                 DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n-                &hcx,\n+                &mut hcx,\n                 &krate.trait_impls,\n             );\n         }\n \n-        let hir_body_nodes = vec![(root_mod_def_path_hash, root_mod_full_dep_index)];\n-\n         let mut collector = NodeCollector {\n             krate,\n             source_map,\n@@ -129,9 +172,9 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         let node_hashes = self\n             .hir_body_nodes\n             .iter()\n-            .fold(Fingerprint::ZERO, |fingerprint, &(def_path_hash, dep_node_index)| {\n+            .fold(Fingerprint::ZERO, |fingerprint, &(def_path_hash, hash)| {\n                 fingerprint.combine(\n-                    def_path_hash.0.combine(self.dep_graph.fingerprint_of(dep_node_index))\n+                    def_path_hash.0.combine(hash)\n                 )\n             });\n \n@@ -159,17 +202,19 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         source_file_names.sort_unstable();\n \n-        let (_, crate_dep_node_index) = self\n-            .dep_graph\n-            .input_task(DepNode::new_no_params(DepKind::Krate),\n-                       &self.hcx,\n-                       (((node_hashes, upstream_crates), source_file_names),\n-                        (commandline_args_hash,\n-                         crate_disambiguator.to_fingerprint())));\n-\n-        let svh = Svh::new(self.dep_graph\n-                               .fingerprint_of(crate_dep_node_index)\n-                               .to_smaller_hash());\n+        let crate_hash_input = (\n+            ((node_hashes, upstream_crates), source_file_names),\n+            (commandline_args_hash, crate_disambiguator.to_fingerprint())\n+        );\n+\n+        let (_, crate_hash) = input_dep_node_and_hash(\n+            self.dep_graph,\n+            &mut self.hcx,\n+            DepNode::new_no_params(DepKind::Krate),\n+            crate_hash_input,\n+        );\n+\n+        let svh = Svh::new(crate_hash.to_smaller_hash());\n         (self.map, svh)\n     }\n \n@@ -251,19 +296,15 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n \n-        self.current_signature_dep_index = self.dep_graph.input_task(\n-            def_path_hash.to_dep_node(DepKind::Hir),\n-            &self.hcx,\n-            HirItemLike { item_like, hash_bodies: false },\n-        ).1;\n-\n-        self.current_full_dep_index = self.dep_graph.input_task(\n-            def_path_hash.to_dep_node(DepKind::HirBody),\n-            &self.hcx,\n-            HirItemLike { item_like, hash_bodies: true },\n-        ).1;\n-\n-        self.hir_body_nodes.push((def_path_hash, self.current_full_dep_index));\n+        let (signature_dep_index, full_dep_index) = hir_dep_nodes(\n+            self.dep_graph,\n+            &mut self.hcx,\n+            def_path_hash,\n+            item_like,\n+            &mut self.hir_body_nodes,\n+        );\n+        self.current_signature_dep_index = signature_dep_index;\n+        self.current_full_dep_index = full_dep_index;\n \n         self.current_dep_node_owner = dep_node_owner;\n         self.currently_in_body = false;"}]}