{"sha": "ab0a96586fd54858106cb6ac112d61eb657426f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMGE5NjU4NmZkNTQ4NTgxMDZjYjZhYzExMmQ2MWViNjU3NDI2ZjY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-19T08:56:39Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-19T08:56:39Z"}, "message": "Merge #1148\n\n1148: Add token_tree_to_xxx functions r=matklad a=edwin0cheng\n\n<del>As discus in  PR #1147 , this PR added a `mbe::MacroKind` .\r\nCurrently only 2 kind of macro are supported, `SourceFile` and `Block`.</del>\r\n\r\nAdded following functions for `tt::TokenTree` and `ast::Node` conversion:\r\n\r\n* token_tree_to_expr\r\n* token_tree_to_pat\r\n* token_tree_to_ty\r\n* token_tree_to_macro_stmts\r\n* token_tree_to_macro_items\r\n\r\nAnd added two new syntax kind:\r\n\r\n* MACRO_ITEMS\r\n* MACRO_STMTS\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "86bbf2601069f6b0007dc181c824ef706d08c60d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86bbf2601069f6b0007dc181c824ef706d08c60d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab0a96586fd54858106cb6ac112d61eb657426f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab0a96586fd54858106cb6ac112d61eb657426f6", "html_url": "https://github.com/rust-lang/rust/commit/ab0a96586fd54858106cb6ac112d61eb657426f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab0a96586fd54858106cb6ac112d61eb657426f6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "d55f1136d6444b1f50b9092c36a976d0e1c26202", "url": "https://api.github.com/repos/rust-lang/rust/commits/d55f1136d6444b1f50b9092c36a976d0e1c26202", "html_url": "https://github.com/rust-lang/rust/commit/d55f1136d6444b1f50b9092c36a976d0e1c26202"}, {"sha": "a6d51e09610989821aaf79871bcab0661c9b0f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6d51e09610989821aaf79871bcab0661c9b0f74", "html_url": "https://github.com/rust-lang/rust/commit/a6d51e09610989821aaf79871bcab0661c9b0f74"}], "stats": {"total": 315, "additions": 295, "deletions": 20}, "files": [{"sha": "9d4744838be6bd67ee513ee61b0a3c41aaf11e6c", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 76, "deletions": 10, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=ab0a96586fd54858106cb6ac112d61eb657426f6", "patch": "@@ -37,9 +37,19 @@ pub enum ExpandError {\n     NoMatchingRule,\n     UnexpectedToken,\n     BindingError(String),\n+    ConversionError,\n }\n \n-pub use crate::syntax_bridge::{ast_to_token_tree, token_tree_to_ast_item_list, syntax_node_to_token_tree};\n+pub use crate::syntax_bridge::{\n+    ast_to_token_tree,\n+    token_tree_to_ast_item_list,\n+    syntax_node_to_token_tree,\n+    token_tree_to_expr,\n+    token_tree_to_pat,\n+    token_tree_to_ty,\n+    token_tree_to_macro_items,\n+    token_tree_to_macro_stmts,\n+};\n \n /// This struct contains AST for a single `macro_rules` definition. What might\n /// be very confusing is that AST has almost exactly the same shape as\n@@ -192,23 +202,26 @@ impl_froms!(TokenTree: Leaf, Subtree);\n     pub(crate) fn expand_to_syntax(\n         rules: &MacroRules,\n         invocation: &str,\n-    ) -> ra_syntax::TreeArc<ast::SourceFile> {\n+    ) -> ra_syntax::TreeArc<ast::MacroItems> {\n         let expanded = expand(rules, invocation);\n-        token_tree_to_ast_item_list(&expanded)\n+        token_tree_to_macro_items(&expanded).unwrap()\n     }\n \n     pub(crate) fn assert_expansion(rules: &MacroRules, invocation: &str, expansion: &str) {\n         let expanded = expand(rules, invocation);\n         assert_eq!(expanded.to_string(), expansion);\n \n-        let tree = token_tree_to_ast_item_list(&expanded);\n+        let tree = token_tree_to_macro_items(&expanded);\n \n         // Eat all white space by parse it back and forth\n         let expansion = ast::SourceFile::parse(expansion);\n         let expansion = syntax_node_to_token_tree(expansion.syntax()).unwrap().0;\n-        let file = token_tree_to_ast_item_list(&expansion);\n+        let file = token_tree_to_macro_items(&expansion);\n \n-        assert_eq!(tree.syntax().debug_dump().trim(), file.syntax().debug_dump().trim());\n+        assert_eq!(\n+            tree.unwrap().syntax().debug_dump().trim(),\n+            file.unwrap().syntax().debug_dump().trim()\n+        );\n     }\n \n     #[test]\n@@ -346,11 +359,11 @@ impl_froms!(TokenTree: Leaf, Subtree);\n             \",\n         );\n         let expansion = expand(&rules, \"structs!(Foo, Bar)\");\n-        let tree = token_tree_to_ast_item_list(&expansion);\n+        let tree = token_tree_to_macro_items(&expansion);\n         assert_eq!(\n-            tree.syntax().debug_dump().trim(),\n+            tree.unwrap().syntax().debug_dump().trim(),\n             r#\"\n-SOURCE_FILE@[0; 40)\n+MACRO_ITEMS@[0; 40)\n   STRUCT_DEF@[0; 20)\n     STRUCT_KW@[0; 6) \"struct\"\n     NAME@[6; 9)\n@@ -444,6 +457,59 @@ SOURCE_FILE@[0; 40)\n         assert_expansion(&rules, \"foo! { foo, bar }\", \"fn foo () {let a = foo ; let b = bar ;}\");\n     }\n \n+    #[test]\n+    fn test_tt_to_stmts() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            () => {\n+                 let a = 0;\n+                 a = 10 + 1;\n+                 a\n+            }\n+        }\n+\"#,\n+        );\n+\n+        let expanded = expand(&rules, \"foo!{}\");\n+        let stmts = token_tree_to_macro_stmts(&expanded);\n+\n+        assert_eq!(\n+            stmts.unwrap().syntax().debug_dump().trim(),\n+            r#\"MACRO_STMTS@[0; 15)\n+  LET_STMT@[0; 7)\n+    LET_KW@[0; 3) \"let\"\n+    BIND_PAT@[3; 4)\n+      NAME@[3; 4)\n+        IDENT@[3; 4) \"a\"\n+    EQ@[4; 5) \"=\"\n+    LITERAL@[5; 6)\n+      INT_NUMBER@[5; 6) \"0\"\n+    SEMI@[6; 7) \";\"\n+  EXPR_STMT@[7; 14)\n+    BIN_EXPR@[7; 13)\n+      PATH_EXPR@[7; 8)\n+        PATH@[7; 8)\n+          PATH_SEGMENT@[7; 8)\n+            NAME_REF@[7; 8)\n+              IDENT@[7; 8) \"a\"\n+      EQ@[8; 9) \"=\"\n+      BIN_EXPR@[9; 13)\n+        LITERAL@[9; 11)\n+          INT_NUMBER@[9; 11) \"10\"\n+        PLUS@[11; 12) \"+\"\n+        LITERAL@[12; 13)\n+          INT_NUMBER@[12; 13) \"1\"\n+    SEMI@[13; 14) \";\"\n+  EXPR_STMT@[14; 15)\n+    PATH_EXPR@[14; 15)\n+      PATH@[14; 15)\n+        PATH_SEGMENT@[14; 15)\n+          NAME_REF@[14; 15)\n+            IDENT@[14; 15) \"a\"\"#,\n+        );\n+    }\n+\n     // The following tests are port from intellij-rust directly\n     // https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n \n@@ -527,7 +593,7 @@ SOURCE_FILE@[0; 40)\n \n         assert_eq!(\n             expand_to_syntax(&rules, \"foo! { 1 + 1  }\").syntax().debug_dump().trim(),\n-            r#\"SOURCE_FILE@[0; 15)\n+            r#\"MACRO_ITEMS@[0; 15)\n   FN_DEF@[0; 15)\n     FN_KW@[0; 2) \"fn\"\n     NAME@[2; 5)"}, {"sha": "5844d3f12c8aedaf41535989e3e4f5ced2f9942b", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=ab0a96586fd54858106cb6ac112d61eb657426f6", "patch": "@@ -5,6 +5,7 @@ use ra_syntax::{\n };\n \n use crate::subtree_source::{SubtreeTokenSource, Querier};\n+use crate::ExpandError;\n \n /// Maps `tt::TokenId` to the relative range of the original token.\n #[derive(Default)]\n@@ -30,6 +31,71 @@ pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> Option<(tt::Subtree, Toke\n     Some((tt, token_map))\n }\n \n+// The following items are what `rustc` macro can be parsed into :\n+// link: https://github.com/rust-lang/rust/blob/9ebf47851a357faa4cd97f4b1dc7835f6376e639/src/libsyntax/ext/expand.rs#L141\n+// * Expr(P<ast::Expr>)                     -> token_tree_to_expr\n+// * Pat(P<ast::Pat>)                       -> token_tree_to_pat\n+// * Ty(P<ast::Ty>)                         -> token_tree_to_ty\n+// * Stmts(SmallVec<[ast::Stmt; 1]>)        -> token_tree_to_stmts\n+// * Items(SmallVec<[P<ast::Item>; 1]>)     -> token_tree_to_items\n+//\n+// * TraitItems(SmallVec<[ast::TraitItem; 1]>)\n+// * ImplItems(SmallVec<[ast::ImplItem; 1]>)\n+// * ForeignItems(SmallVec<[ast::ForeignItem; 1]>\n+//\n+//\n+\n+/// Parses the token tree (result of macro expansion) to an expression\n+pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<TreeArc<ast::Expr>, ExpandError> {\n+    let token_source = SubtreeTokenSource::new(tt);\n+    let mut tree_sink = TtTreeSink::new(token_source.querier());\n+    ra_parser::parse_expr(&token_source, &mut tree_sink);\n+    let syntax = tree_sink.inner.finish();\n+    ast::Expr::cast(&syntax)\n+        .map(|m| m.to_owned())\n+        .ok_or_else(|| crate::ExpandError::ConversionError)\n+}\n+\n+/// Parses the token tree (result of macro expansion) to a Pattern\n+pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<TreeArc<ast::Pat>, ExpandError> {\n+    let token_source = SubtreeTokenSource::new(tt);\n+    let mut tree_sink = TtTreeSink::new(token_source.querier());\n+    ra_parser::parse_pat(&token_source, &mut tree_sink);\n+    let syntax = tree_sink.inner.finish();\n+    ast::Pat::cast(&syntax).map(|m| m.to_owned()).ok_or_else(|| ExpandError::ConversionError)\n+}\n+\n+/// Parses the token tree (result of macro expansion) to a Type\n+pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<TreeArc<ast::TypeRef>, ExpandError> {\n+    let token_source = SubtreeTokenSource::new(tt);\n+    let mut tree_sink = TtTreeSink::new(token_source.querier());\n+    ra_parser::parse_ty(&token_source, &mut tree_sink);\n+    let syntax = tree_sink.inner.finish();\n+    ast::TypeRef::cast(&syntax).map(|m| m.to_owned()).ok_or_else(|| ExpandError::ConversionError)\n+}\n+\n+/// Parses the token tree (result of macro expansion) as a sequence of stmts\n+pub fn token_tree_to_macro_stmts(\n+    tt: &tt::Subtree,\n+) -> Result<TreeArc<ast::MacroStmts>, ExpandError> {\n+    let token_source = SubtreeTokenSource::new(tt);\n+    let mut tree_sink = TtTreeSink::new(token_source.querier());\n+    ra_parser::parse_macro_stmts(&token_source, &mut tree_sink);\n+    let syntax = tree_sink.inner.finish();\n+    ast::MacroStmts::cast(&syntax).map(|m| m.to_owned()).ok_or_else(|| ExpandError::ConversionError)\n+}\n+\n+/// Parses the token tree (result of macro expansion) as a sequence of items\n+pub fn token_tree_to_macro_items(\n+    tt: &tt::Subtree,\n+) -> Result<TreeArc<ast::MacroItems>, ExpandError> {\n+    let token_source = SubtreeTokenSource::new(tt);\n+    let mut tree_sink = TtTreeSink::new(token_source.querier());\n+    ra_parser::parse_macro_items(&token_source, &mut tree_sink);\n+    let syntax = tree_sink.inner.finish();\n+    ast::MacroItems::cast(&syntax).map(|m| m.to_owned()).ok_or_else(|| ExpandError::ConversionError)\n+}\n+\n /// Parses the token tree (result of macro expansion) as a sequence of items\n pub fn token_tree_to_ast_item_list(tt: &tt::Subtree) -> TreeArc<ast::SourceFile> {\n     let token_source = SubtreeTokenSource::new(tt);"}, {"sha": "e1762633e4955767826d1b9e50c6c01375ce5aab", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=ab0a96586fd54858106cb6ac112d61eb657426f6", "patch": "@@ -49,6 +49,27 @@ pub(crate) fn root(p: &mut Parser) {\n     m.complete(p, SOURCE_FILE);\n }\n \n+pub(crate) fn macro_items(p: &mut Parser) {\n+    let m = p.start();\n+    items::mod_contents(p, false);\n+    m.complete(p, MACRO_ITEMS);\n+}\n+\n+pub(crate) fn macro_stmts(p: &mut Parser) {\n+    let m = p.start();\n+\n+    while !p.at(EOF) {\n+        if p.current() == SEMI {\n+            p.bump();\n+            continue;\n+        }\n+\n+        expressions::stmt(p, expressions::StmtWithSemi::Optional);\n+    }\n+\n+    m.complete(p, MACRO_STMTS);\n+}\n+\n pub(crate) fn path(p: &mut Parser) {\n     paths::type_path(p);\n }\n@@ -66,6 +87,11 @@ pub(crate) fn pattern(p: &mut Parser) {\n }\n \n pub(crate) fn stmt(p: &mut Parser, with_semi: bool) {\n+    let with_semi = match with_semi {\n+        true => expressions::StmtWithSemi::Yes,\n+        false => expressions::StmtWithSemi::No,\n+    };\n+\n     expressions::stmt(p, with_semi)\n }\n "}, {"sha": "8df9035e9eb0a8ecce0a6296841d7a748c15ff69", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=ab0a96586fd54858106cb6ac112d61eb657426f6", "patch": "@@ -4,6 +4,12 @@ pub(crate) use self::atom::match_arm_list;\n pub(super) use self::atom::{literal, LITERAL_FIRST};\n use super::*;\n \n+pub(super) enum StmtWithSemi {\n+    Yes,\n+    No,\n+    Optional,\n+}\n+\n const EXPR_FIRST: TokenSet = LHS_FIRST;\n \n pub(super) fn expr(p: &mut Parser) -> BlockLike {\n@@ -48,7 +54,7 @@ fn is_expr_stmt_attr_allowed(kind: SyntaxKind) -> bool {\n     }\n }\n \n-pub(super) fn stmt(p: &mut Parser, with_semi: bool) {\n+pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n     // test block_items\n     // fn a() { fn b() {} }\n     let m = p.start();\n@@ -111,13 +117,23 @@ pub(super) fn stmt(p: &mut Parser, with_semi: bool) {\n         //     }\n         //     test!{}\n         // }\n-        if with_semi {\n-            if blocklike.is_block() {\n-                p.eat(SEMI);\n-            } else {\n-                p.expect(SEMI);\n+\n+        match with_semi {\n+            StmtWithSemi::Yes => {\n+                if blocklike.is_block() {\n+                    p.eat(SEMI);\n+                } else {\n+                    p.expect(SEMI);\n+                }\n+            }\n+            StmtWithSemi::No => {}\n+            StmtWithSemi::Optional => {\n+                if p.at(SEMI) {\n+                    p.eat(SEMI);\n+                }\n             }\n         }\n+\n         m.complete(p, EXPR_STMT);\n     }\n \n@@ -128,7 +144,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: bool) {\n     //     let c = 92;\n     //     let d: i32 = 92;\n     // }\n-    fn let_stmt(p: &mut Parser, m: Marker, with_semi: bool) {\n+    fn let_stmt(p: &mut Parser, m: Marker, with_semi: StmtWithSemi) {\n         assert!(p.at(LET_KW));\n         p.bump();\n         patterns::pattern(p);\n@@ -139,8 +155,16 @@ pub(super) fn stmt(p: &mut Parser, with_semi: bool) {\n             expressions::expr(p);\n         }\n \n-        if with_semi {\n-            p.expect(SEMI);\n+        match with_semi {\n+            StmtWithSemi::Yes => {\n+                p.expect(SEMI);\n+            }\n+            StmtWithSemi::No => {}\n+            StmtWithSemi::Optional => {\n+                if p.at(SEMI) {\n+                    p.eat(SEMI);\n+                }\n+            }\n         }\n         m.complete(p, LET_STMT);\n     }\n@@ -160,7 +184,7 @@ pub(crate) fn expr_block_contents(p: &mut Parser) {\n             continue;\n         }\n \n-        stmt(p, true)\n+        stmt(p, StmtWithSemi::Yes)\n     }\n }\n "}, {"sha": "0ea942b6e022c10da3e18ba2d084576b10a01638", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=ab0a96586fd54858106cb6ac112d61eb657426f6", "patch": "@@ -98,6 +98,14 @@ pub fn parse_item(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink)\n     parse_from_tokens(token_source, tree_sink, grammar::item);\n }\n \n+pub fn parse_macro_items(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, grammar::macro_items);\n+}\n+\n+pub fn parse_macro_stmts(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, grammar::macro_stmts);\n+}\n+\n /// A parsing function for a specific braced-block.\n pub struct Reparser(fn(&mut parser::Parser));\n "}, {"sha": "6f984aea16f4b03cbd2d3cd858e97c6e049669f8", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=ab0a96586fd54858106cb6ac112d61eb657426f6", "patch": "@@ -233,6 +233,8 @@ pub enum SyntaxKind {\n     ARG_LIST,\n     TYPE_BOUND,\n     TYPE_BOUND_LIST,\n+    MACRO_ITEMS,\n+    MACRO_STMTS,\n     // Technical kind so that we can cast from u16 safely\n     #[doc(hidden)]\n     __LAST,\n@@ -592,6 +594,8 @@ impl SyntaxKind {\n             ARG_LIST => &SyntaxInfo { name: \"ARG_LIST\" },\n             TYPE_BOUND => &SyntaxInfo { name: \"TYPE_BOUND\" },\n             TYPE_BOUND_LIST => &SyntaxInfo { name: \"TYPE_BOUND_LIST\" },\n+            MACRO_ITEMS => &SyntaxInfo { name: \"MACRO_ITEMS\" },\n+            MACRO_STMTS => &SyntaxInfo { name: \"MACRO_STMTS\" },\n             TOMBSTONE => &SyntaxInfo { name: \"TOMBSTONE\" },\n             EOF => &SyntaxInfo { name: \"EOF\" },\n             __LAST => &SyntaxInfo { name: \"__LAST\" },"}, {"sha": "17de4f058081d13a74478a158ace4d49bc800399", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=ab0a96586fd54858106cb6ac112d61eb657426f6", "patch": "@@ -1770,6 +1770,72 @@ impl MacroCall {\n     }\n }\n \n+// MacroItems\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct MacroItems {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for MacroItems {\n+    type Repr = rowan::SyntaxNode;\n+}\n+\n+impl AstNode for MacroItems {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            MACRO_ITEMS => Some(MacroItems::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+impl ToOwned for MacroItems {\n+    type Owned = TreeArc<MacroItems>;\n+    fn to_owned(&self) -> TreeArc<MacroItems> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::ModuleItemOwner for MacroItems {}\n+impl ast::FnDefOwner for MacroItems {}\n+impl MacroItems {}\n+\n+// MacroStmts\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct MacroStmts {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for MacroStmts {\n+    type Repr = rowan::SyntaxNode;\n+}\n+\n+impl AstNode for MacroStmts {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            MACRO_STMTS => Some(MacroStmts::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+impl ToOwned for MacroStmts {\n+    type Owned = TreeArc<MacroStmts>;\n+    fn to_owned(&self) -> TreeArc<MacroStmts> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl MacroStmts {\n+    pub fn statements(&self) -> impl Iterator<Item = &Stmt> {\n+        super::children(self)\n+    }\n+\n+    pub fn expr(&self) -> Option<&Expr> {\n+        super::child_opt(self)\n+    }\n+}\n+\n // MatchArm\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]"}, {"sha": "663e3a2f9ec02602571d09b3c6951356540ce1b0", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/ab0a96586fd54858106cb6ac112d61eb657426f6/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=ab0a96586fd54858106cb6ac112d61eb657426f6", "patch": "@@ -247,6 +247,10 @@ Grammar(\n         \"ARG_LIST\",\n         \"TYPE_BOUND\",\n         \"TYPE_BOUND_LIST\",\n+\n+        // macro related\n+        \"MACRO_ITEMS\",\n+        \"MACRO_STMTS\",\n     ],\n     ast: {\n         \"SourceFile\": (\n@@ -668,5 +672,16 @@ Grammar(\n         \"TypeArg\": (options: [\"TypeRef\"]),\n         \"AssocTypeArg\": (options: [\"NameRef\", \"TypeRef\"]),\n         \"LifetimeArg\": (),\n+\n+        \"MacroItems\": (\n+            traits: [ \"ModuleItemOwner\", \"FnDefOwner\" ],            \n+        ),\n+\n+        \"MacroStmts\" : (\n+            options: [ \"Expr\" ],\n+            collections: [\n+                [\"statements\", \"Stmt\"],\n+            ],\n+        )\n     },\n )"}]}