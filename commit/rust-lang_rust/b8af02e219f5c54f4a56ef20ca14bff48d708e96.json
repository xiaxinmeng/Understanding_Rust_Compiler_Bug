{"sha": "b8af02e219f5c54f4a56ef20ca14bff48d708e96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YWYwMmUyMTlmNWM1NGY0YTU2ZWYyMGNhMTRiZmY0OGQ3MDhlOTY=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-08T17:17:02Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-08T22:20:21Z"}, "message": "WIP on issue #1425: mostly infrastructure changes.", "tree": {"sha": "2a7782f874960bd970fdd00210e2571dc8dec65e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a7782f874960bd970fdd00210e2571dc8dec65e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8af02e219f5c54f4a56ef20ca14bff48d708e96", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8af02e219f5c54f4a56ef20ca14bff48d708e96", "html_url": "https://github.com/rust-lang/rust/commit/b8af02e219f5c54f4a56ef20ca14bff48d708e96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8af02e219f5c54f4a56ef20ca14bff48d708e96/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8d76738ecadcd7b8dd5240b719362767bfadf3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d76738ecadcd7b8dd5240b719362767bfadf3a", "html_url": "https://github.com/rust-lang/rust/commit/d8d76738ecadcd7b8dd5240b719362767bfadf3a"}], "stats": {"total": 425, "additions": 314, "deletions": 111}, "files": [{"sha": "61f6210b49d728fb3158c6cf37a96c07aa56f294", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=b8af02e219f5c54f4a56ef20ca14bff48d708e96", "patch": "@@ -346,7 +346,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ret ty::mk_res(st.tcx, def, inner, substs);\n       }\n       'X' {\n-        ret ty::mk_var(st.tcx, ty::ty_vid(parse_int(st) as uint));\n+        ret ty::mk_var(st.tcx, ty::tv_vid(parse_int(st) as uint));\n       }\n       'Y' { ret ty::mk_type(st.tcx); }\n       'C' {"}, {"sha": "5ddfd8620fa6ce1803b2f4e9e13af65d91e4b7d4", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b8af02e219f5c54f4a56ef20ca14bff48d708e96", "patch": "@@ -17,7 +17,7 @@ import middle::lint::{get_warning_level, vecs_not_implicitly_copyable,\n import syntax::ast::*;\n import syntax::print::pprust::*;\n \n-export ty_vid, region_vid, vid;\n+export tv_vid, tvi_vid, region_vid, vid;\n export br_hashmap;\n export is_instantiable;\n export node_id_to_type;\n@@ -302,11 +302,6 @@ enum closure_kind {\n     ck_uniq,\n }\n \n-enum ty_var_kind {\n-    tvk_regular,\n-    tvk_integral,\n-}\n-\n type fn_ty = {purity: ast::purity,\n               proto: ast::proto,\n               inputs: [arg],\n@@ -372,9 +367,9 @@ enum sty {\n     ty_res(def_id, t, substs),\n     ty_tup([t]),\n \n-    ty_var(ty_vid), // type variable during typechecking\n-    ty_var_integral(ty_vid), // type variable during typechecking, for\n-                             // integral types only\n+    ty_var(tv_vid), // type variable during typechecking\n+    ty_var_integral(tvi_vid), // type variable during typechecking, for\n+                              // integral types only\n     ty_param(uint, def_id), // type parameter\n     ty_self, // special, implicit `self` type parameter\n     ty_constr(t, [@type_constr]),\n@@ -429,19 +424,25 @@ enum param_bound {\n     bound_iface(t),\n }\n \n-enum ty_vid = uint;\n+enum tv_vid = uint;\n+enum tvi_vid = uint;\n enum region_vid = uint;\n \n iface vid {\n     fn to_uint() -> uint;\n     fn to_str() -> str;\n }\n \n-impl of vid for ty_vid {\n+impl of vid for tv_vid {\n     fn to_uint() -> uint { *self }\n     fn to_str() -> str { #fmt[\"<V%u>\", self.to_uint()] }\n }\n \n+impl of vid for tvi_vid {\n+    fn to_uint() -> uint { *self }\n+    fn to_str() -> str { #fmt[\"<V (integral) %u>\", self.to_uint()] }\n+}\n+\n impl of vid for region_vid {\n     fn to_uint() -> uint { *self }\n     fn to_str() -> str { #fmt[\"<R%u>\", self.to_uint()] }\n@@ -693,9 +694,11 @@ fn mk_res(cx: ctxt, did: ast::def_id,\n     mk_t(cx, ty_res(did, inner, substs))\n }\n \n-fn mk_var(cx: ctxt, v: ty_vid) -> t { mk_t(cx, ty_var(v)) }\n+fn mk_var(cx: ctxt, v: tv_vid) -> t { mk_t(cx, ty_var(v)) }\n \n-fn mk_var_integral(cx: ctxt, v: ty_vid) -> t { mk_t(cx, ty_var_integral(v)) }\n+fn mk_var_integral(cx: ctxt, v: tvi_vid) -> t {\n+    mk_t(cx, ty_var_integral(v))\n+}\n \n fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n \n@@ -1911,29 +1914,6 @@ fn type_param(ty: t) -> option<uint> {\n     ret none;\n }\n \n-// Returns a vec of all the type variables of kind `tvk` occurring in `ty`. It\n-// may contain duplicates.\n-fn vars_in_type(ty: t, tvk: ty_var_kind) -> [ty_vid] {\n-    let mut rslt = [];\n-    walk_ty(ty) {|ty|\n-        alt get(ty).struct {\n-          ty_var(v) {\n-            alt tvk {\n-              tvk_regular { rslt += [v]; }\n-              _ { }\n-            }\n-          }\n-          ty_var_integral(v) {\n-            alt tvk {\n-              tvk_integral { rslt += [v]; }\n-              _ { }\n-            }\n-          }\n-          _ { } }\n-    }\n-    rslt\n-}\n-\n // Returns the type and mutability of *t.\n //\n // The parameter `expl` indicates if this is an *explicit* dereference.  Some\n@@ -2229,13 +2209,21 @@ fn is_pred_ty(fty: t) -> bool {\n     is_fn_ty(fty) && type_is_bool(ty_fn_ret(fty))\n }\n \n-fn ty_var_id(typ: t) -> ty_vid {\n+fn ty_var_id(typ: t) -> tv_vid {\n     alt get(typ).struct {\n-      ty_var(vid) | ty_var_integral(vid) { ret vid; }\n+      ty_var(vid) { ret vid; }\n       _ { #error(\"ty_var_id called on non-var ty\"); fail; }\n     }\n }\n \n+fn ty_var_integral_id(typ: t) -> tvi_vid {\n+    alt get(typ).struct {\n+      ty_var_integral(vid) { ret vid; }\n+      _ { #error(\"ty_var_integral_id called on ty other than \\\n+                  ty_var_integral\");\n+         fail; }\n+    }\n+}\n \n // Type accessors for AST nodes\n fn block_ty(cx: ctxt, b: ast::blk) -> t {\n@@ -2311,12 +2299,23 @@ fn method_idx(id: ast::ident, meths: [method]) -> option<uint> {\n     ret none;\n }\n \n-fn occurs_check(tcx: ctxt, sp: span, vid: ty_vid, rt: t) {\n+fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n+\n+    // Returns a vec of all the type variables occurring in `ty`. It may\n+    // contain duplicates.  (Integral type vars aren't counted.)\n+    fn vars_in_type(ty: t) -> [tv_vid] {\n+        let mut rslt = [];\n+        walk_ty(ty) {|ty|\n+            alt get(ty).struct { ty_var(v) { rslt += [v]; } _ { } }\n+        }\n+        rslt\n+    }\n+\n     // Fast path\n     if !type_needs_infer(rt) { ret; }\n \n     // Occurs check!\n-    if vec::contains(vars_in_type(rt, tvk_regular), vid) {\n+    if vec::contains(vars_in_type(rt), vid) {\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die."}, {"sha": "51e5886340b2422487954d000945673547a514f6", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=b8af02e219f5c54f4a56ef20ca14bff48d708e96", "patch": "@@ -52,7 +52,6 @@ import pat_util::{pat_is_variant, pat_id_map};\n import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n-import middle::ty::{ty_vid, region_vid, vid};\n import middle::typeck::infer::methods;\n import util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n                      bound_region_to_str, vstore_to_str};"}, {"sha": "50123559f0277987af64dacf9d560bb19247a9b5", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=b8af02e219f5c54f4a56ef20ca14bff48d708e96", "patch": "@@ -69,10 +69,15 @@ type parameter).\n import astconv::{ast_conv, ast_ty_to_ty};\n import collect::{methods}; // ccx.to_ty()\n import method::{methods};  // methods for method::lookup\n-import middle::ty::tys_in_fn_ty;\n+import middle::ty::{tv_vid, vid};\n import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n import rscope::{in_binding_rscope, region_scope, type_rscope};\n+import syntax::ast::{ty_char, ty_i8, ty_i16, ty_i32, ty_i64, ty_i};\n+import typeck::infer::{root, to_str};\n+import typeck::infer::{unify_methods}; // infcx.set()\n+import typeck::infer::{min_8bit_tys, min_16bit_tys, min_32bit_tys,\n+                       min_64bit_tys};\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -84,7 +89,7 @@ type fn_ctxt =\n      indirect_ret_ty: option<ty::t>,\n      purity: ast::purity,\n      infcx: infer::infer_ctxt,\n-     locals: hashmap<ast::node_id, ty_vid>,\n+     locals: hashmap<ast::node_id, tv_vid>,\n \n      mut blocks: [ast::node_id], // stack of blocks in scope, may be empty\n      in_scope_regions: isr_alist,\n@@ -618,22 +623,49 @@ fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n     }\n }\n \n-// Local variable gathering. We gather up all locals and create variable IDs\n-// for them before typechecking the function.\n-type gather_result =\n-    {infcx: infer::infer_ctxt,\n-     locals: hashmap<ast::node_id, ty_vid>,\n-     ty_var_counter: @mut uint};\n-\n // AST fragment checking\n-fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n+fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n+    let tcx = fcx.ccx.tcx;\n+\n     alt lit.node {\n-      ast::lit_str(_) { ty::mk_str(ccx.tcx) }\n-      ast::lit_int(_, t) { ty::mk_mach_int(ccx.tcx, t) }\n-      ast::lit_uint(_, t) { ty::mk_mach_uint(ccx.tcx, t) }\n-      ast::lit_float(_, t) { ty::mk_mach_float(ccx.tcx, t) }\n-      ast::lit_nil { ty::mk_nil(ccx.tcx) }\n-      ast::lit_bool(_) { ty::mk_bool(ccx.tcx) }\n+      ast::lit_str(_) { ty::mk_str(tcx) }\n+      ast::lit_int(v, t) {\n+        alt t {\n+          ty_char | ty_i8 | ty_i16 | ty_i32 | ty_i64 {\n+            // If it's a char or has an explicit suffix, give it the\n+            // appropriate integral type.\n+            ty::mk_mach_int(tcx, t)\n+          }\n+          ty_i {\n+            // Otherwise, an unsuffixed integer literal parses to a\n+            // `ty_i`.  In that case, it could have any integral type,\n+            // so create an integral type variable for it.\n+            let vid = fcx.infcx.next_ty_var_integral_id();\n+\n+            // We need to sniff at the value `v` provided and figure\n+            // out how big of an int it is; that determines the set of\n+            // possibly types it could take on.\n+            let possible_types = alt v {\n+              0i64 to 127i64 { min_8bit_tys() }\n+              128i64 to 65535i64 { min_16bit_tys() }\n+              65536i64 to 4294967295i64 { min_32bit_tys() }\n+              _ { min_64bit_tys() }\n+          };\n+\n+            // Store the set of possible types\n+            fcx.infcx.set(fcx.infcx.tvib, vid,\n+                          root(possible_types));\n+            ty::mk_var_integral(tcx, vid);\n+\n+            // FIXME: remove me when #1425 is finished.\n+            ty::mk_mach_int(tcx, t)\n+          }\n+        }\n+      }\n+      ast::lit_uint(_, t) { ty::mk_mach_uint(tcx, t) }\n+      ast::lit_float(_, t) { ty::mk_mach_float(tcx, t) }\n+      ast::lit_nil { ty::mk_nil(tcx) }\n+      ast::lit_bool(_) { ty::mk_bool(tcx) }\n     }\n }\n \n@@ -1107,7 +1139,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n \n       ast::expr_lit(lit) {\n-        let typ = check_lit(fcx.ccx, lit);\n+        let typ = check_lit(fcx, lit);\n         fcx.write_ty(id, typ);\n       }\n \n@@ -2067,7 +2099,7 @@ fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n                         ast_util::is_self)\n }\n \n-fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ty_vid {\n+fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> tv_vid {\n     alt fcx.locals.find(id) {\n       some(x) { x }\n       _ {"}, {"sha": "a67f515f058e71cf612abc6b6a07d5652e4deda0", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 224, "deletions": 51, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8af02e219f5c54f4a56ef20ca14bff48d708e96/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=b8af02e219f5c54f4a56ef20ca14bff48d708e96", "patch": "@@ -147,7 +147,7 @@ import std::smallintmap::smallintmap;\n import std::smallintmap::map;\n import std::map::hashmap;\n import middle::ty;\n-import middle::ty::{ty_vid, tys_in_fn_ty, region_vid, vid};\n+import middle::ty::{tv_vid, tvi_vid, region_vid, vid};\n import syntax::{ast, ast_util};\n import syntax::ast::{ret_style, purity};\n import util::ppaux::{ty_to_str, mt_to_str};\n@@ -169,9 +169,57 @@ export resolve_shallow;\n export resolve_deep;\n export resolve_deep_var;\n export methods; // for infer_ctxt\n+export unify_methods; // for infer_ctxt\n export compare_tys;\n export fixup_err, fixup_err_to_str;\n export assignment;\n+export root, to_str;\n+export min_8bit_tys, min_16bit_tys, min_32bit_tys, min_64bit_tys;\n+\n+// Bitvector to represent sets of integral types\n+enum int_ty_set = uint;\n+\n+// Constants representing singleton sets containing each of the\n+// integral types\n+const INT_TY_SET_EMPTY : uint = 0b00_0000_0000u;\n+const INT_TY_SET_i8    : uint = 0b00_0000_0001u;\n+const INT_TY_SET_u8    : uint = 0b00_0000_0010u;\n+const INT_TY_SET_i16   : uint = 0b00_0000_0100u;\n+const INT_TY_SET_u16   : uint = 0b00_0000_1000u;\n+const INT_TY_SET_i32   : uint = 0b00_0001_0000u;\n+const INT_TY_SET_u32   : uint = 0b00_0010_0000u;\n+const INT_TY_SET_i64   : uint = 0b00_0100_0000u;\n+const INT_TY_SET_u64   : uint = 0b00_1000_0000u;\n+const INT_TY_SET_i     : uint = 0b01_0000_0000u;\n+const INT_TY_SET_u     : uint = 0b10_0000_0000u;\n+\n+fn mk_int_ty_set() -> int_ty_set { int_ty_set(INT_TY_SET_EMPTY) }\n+\n+fn min_8bit_tys()  -> int_ty_set {\n+    int_ty_set(INT_TY_SET_i8  | INT_TY_SET_u8 |\n+               INT_TY_SET_i16 | INT_TY_SET_u16 |\n+               INT_TY_SET_i32 | INT_TY_SET_u32 |\n+               INT_TY_SET_i64 | INT_TY_SET_u64 |\n+               INT_TY_SET_i   | INT_TY_SET_u)\n+}\n+\n+fn min_16bit_tys() -> int_ty_set {\n+    int_ty_set(INT_TY_SET_i16 | INT_TY_SET_u16 |\n+               INT_TY_SET_i32 | INT_TY_SET_u32 |\n+               INT_TY_SET_i64 | INT_TY_SET_u64 |\n+               INT_TY_SET_i   | INT_TY_SET_u)\n+}\n+\n+fn min_32bit_tys() -> int_ty_set {\n+    int_ty_set(INT_TY_SET_i32 | INT_TY_SET_u32 |\n+               INT_TY_SET_i64 | INT_TY_SET_u64 |\n+               // uh, can we count on ty_i and ty_u being 32 bits?\n+               INT_TY_SET_i   | INT_TY_SET_u)\n+}\n+\n+fn min_64bit_tys() -> int_ty_set {\n+    int_ty_set(INT_TY_SET_i64 | INT_TY_SET_u64)\n+}\n \n // Extra information needed to perform an assignment that may borrow.\n // The `expr_id` is the is of the expression whose type is being\n@@ -183,12 +231,11 @@ type assignment = {\n };\n \n type bound<T:copy> = option<T>;\n-\n type bounds<T:copy> = {lb: bound<T>, ub: bound<T>};\n \n enum var_value<V:copy, T:copy> {\n     redirect(V),\n-    bounded(bounds<T>)\n+    root(T)\n }\n \n type vals_and_bindings<V:copy, T:copy> = {\n@@ -198,18 +245,28 @@ type vals_and_bindings<V:copy, T:copy> = {\n \n enum infer_ctxt = @{\n     tcx: ty::ctxt,\n-    tvb: vals_and_bindings<ty::ty_vid, ty::t>, // for type variables\n-    tvib: vals_and_bindings<ty::ty_vid, ty::t>, // for integral type variables\n-    rb: vals_and_bindings<ty::region_vid, ty::region>, // for region variables\n \n-    // For keeping track of existing type/region variables.\n+    // We instantiate vals_and_bindings with bounds<ty::t> because the\n+    // types that might instantiate a general type variable have an\n+    // order, represented by its upper and lower bounds.\n+    tvb: vals_and_bindings<ty::tv_vid, bounds<ty::t>>,\n+\n+    // The types that might instantiate an integral type variable are\n+    // represented by an int_ty_set.\n+    tvib: vals_and_bindings<ty::tvi_vid, int_ty_set>,\n+\n+    // For region variables.\n+    rb: vals_and_bindings<ty::region_vid, bounds<ty::region>>,\n+\n+    // For keeping track of existing type and region variables.\n     ty_var_counter: @mut uint,\n+    ty_var_integral_counter: @mut uint,\n     region_var_counter: @mut uint,\n };\n \n enum fixup_err {\n-    unresolved_ty(ty_vid),\n-    cyclic_ty(ty_vid),\n+    unresolved_ty(tv_vid),\n+    cyclic_ty(tv_vid),\n     unresolved_region(region_vid),\n     cyclic_region(region_vid)\n }\n@@ -232,6 +289,7 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n                  tvib: {vals: smallintmap::mk(), mut bindings: []},\n                  rb: {vals: smallintmap::mk(), mut bindings: []},\n                  ty_var_counter: @mut 0u,\n+                 ty_var_integral_counter: @mut 0u,\n                  region_var_counter: @mut 0u})}\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n@@ -290,7 +348,7 @@ fn resolve_shallow(cx: infer_ctxt, a: ty::t,\n }\n \n // See comment on the type `resolve_state` below\n-fn resolve_deep_var(cx: infer_ctxt, vid: ty_vid,\n+fn resolve_deep_var(cx: infer_ctxt, vid: tv_vid,\n                     force_vars: bool) -> fres<ty::t> {\n     resolver(cx, true, force_vars).resolve(ty::mk_var(cx.tcx, vid))\n }\n@@ -365,11 +423,19 @@ impl<T:copy to_str> of to_str for bounds<T> {\n     }\n }\n \n+impl of to_str for int_ty_set {\n+    fn to_str(_cx: infer_ctxt) -> str {\n+        alt self {\n+          int_ty_set(v) { uint::to_str(v, 10u) }\n+        }\n+    }\n+}\n+\n impl<V:copy vid, T:copy to_str> of to_str for var_value<V,T> {\n     fn to_str(cx: infer_ctxt) -> str {\n         alt self {\n           redirect(vid) { #fmt(\"redirect(%s)\", vid.to_str()) }\n-          bounded(bnds) { #fmt(\"bounded(%s)\", bnds.to_str(cx)) }\n+          root(pt) { #fmt(\"root(%s)\", pt.to_str(cx)) }\n         }\n     }\n }\n@@ -468,10 +534,12 @@ impl transaction_methods for infer_ctxt {\n }\n \n impl methods for infer_ctxt {\n-    fn next_ty_var_id() -> ty_vid {\n+    fn next_ty_var_id() -> tv_vid {\n         let id = *self.ty_var_counter;\n         *self.ty_var_counter += 1u;\n-        ret ty_vid(id);\n+        self.tvb.vals.insert(id,\n+                             root({lb: none, ub: none}));\n+        ret tv_vid(id);\n     }\n \n     fn next_ty_var() -> ty::t {\n@@ -482,14 +550,29 @@ impl methods for infer_ctxt {\n         vec::from_fn(n) {|_i| self.next_ty_var() }\n     }\n \n+    fn next_ty_var_integral_id() -> tvi_vid {\n+        let id = *self.ty_var_integral_counter;\n+        *self.ty_var_integral_counter += 1u;\n+\n+        self.tvib.vals.insert(id,\n+                              root(mk_int_ty_set()));\n+        ret tvi_vid(id);\n+    }\n+\n+    fn next_ty_var_integral() -> ty::t {\n+        ty::mk_var_integral(self.tcx, self.next_ty_var_integral_id())\n+    }\n+\n     fn next_region_var_id() -> region_vid {\n         let id = *self.region_var_counter;\n         *self.region_var_counter += 1u;\n+        self.rb.vals.insert(id,\n+                            root({lb: none, ub: none}));\n         ret region_vid(id);\n     }\n \n     fn next_region_var() -> ty::region {\n-        ret ty::re_var(self.next_region_var_id());\n+        ty::re_var(self.next_region_var_id())\n     }\n \n     fn ty_to_str(t: ty::t) -> str {\n@@ -521,23 +604,27 @@ impl unify_methods for infer_ctxt {\n \n     fn get<V:copy vid, T:copy>(\n         vb: vals_and_bindings<V, T>, vid: V)\n-        -> {root: V, bounds:bounds<T>} {\n+        -> {root: V, possible_types: T} {\n \n         alt vb.vals.find(vid.to_uint()) {\n           none {\n-            let bnds = {lb: none, ub: none};\n-            vb.vals.insert(vid.to_uint(), bounded(bnds));\n-            {root: vid, bounds: bnds}\n+            #error[\"failed lookup in infcx.get()\"];\n+            fail;\n           }\n-          some(redirect(vid)) {\n-            let {root, bounds} = self.get(vb, vid);\n-            if root != vid {\n-                vb.vals.insert(vid.to_uint(), redirect(root));\n+          some(var_val) {\n+            alt var_val {\n+              redirect(vid) {\n+                let {root: rt, possible_types: pt} = self.get(vb, vid);\n+                if rt != vid {\n+                    // Path compression\n+                    vb.vals.insert(vid.to_uint(), redirect(rt));\n+                }\n+                {root: rt, possible_types: pt}\n+              }\n+              root(pt) {\n+                {root: vid, possible_types: pt}\n+              }\n             }\n-            {root: root, bounds: bounds}\n-          }\n-          some(bounded(bounds)) {\n-            {root: vid, bounds: bounds}\n           }\n         }\n     }\n@@ -596,7 +683,7 @@ impl unify_methods for infer_ctxt {\n     //    b.lb <: c.lb\n     // If this cannot be achieved, the result is failure.\n     fn set_var_to_merged_bounds<V:copy vid, T:copy to_str st>(\n-        vb: vals_and_bindings<V, T>,\n+        vb: vals_and_bindings<V, bounds<T>>,\n         v_id: V, a: bounds<T>, b: bounds<T>) -> ures {\n \n         // Think of the two diamonds, we want to find the\n@@ -638,19 +725,19 @@ impl unify_methods for infer_ctxt {\n             // the new bounds must themselves\n             // be relatable:\n             self.bnds(bnds.lb, bnds.ub).then {||\n-                self.set(vb, v_id, bounded(bnds));\n+                self.set(vb, v_id, root(bnds));\n                 uok()\n-            }\n+        }\n         }}}}}\n     }\n \n     fn vars<V:copy vid, T:copy to_str st>(\n-        vb: vals_and_bindings<V, T>,\n+        vb: vals_and_bindings<V, bounds<T>>,\n         a_id: V, b_id: V) -> ures {\n \n         // Need to make sub_id a subtype of sup_id.\n-        let {root: a_id, bounds: a_bounds} = self.get(vb, a_id);\n-        let {root: b_id, bounds: b_bounds} = self.get(vb, b_id);\n+        let {root: a_id, possible_types: a_bounds} = self.get(vb, a_id);\n+        let {root: b_id, possible_types: b_bounds} = self.get(vb, b_id);\n \n         #debug[\"vars(%s=%s <: %s=%s)\",\n                a_id.to_str(), a_bounds.to_str(self),\n@@ -683,30 +770,52 @@ impl unify_methods for infer_ctxt {\n         }\n     }\n \n+    fn vars_integral<V:copy vid>(\n+        _vb: vals_and_bindings<V, int_ty_set>,\n+        _a_id: V, _b_id: V) -> ures {\n+        // FIXME (#1425): do something real here.\n+        uok()\n+    }\n+\n     fn vart<V: copy vid, T: copy to_str st>(\n-        vb: vals_and_bindings<V, T>,\n+        vb: vals_and_bindings<V, bounds<T>>,\n         a_id: V, b: T) -> ures {\n \n-        let {root: a_id, bounds: a_bounds} = self.get(vb, a_id);\n+        let {root: a_id, possible_types: a_bounds} = self.get(vb, a_id);\n         #debug[\"vart(%s=%s <: %s)\",\n                a_id.to_str(), a_bounds.to_str(self),\n                b.to_str(self)];\n         let b_bounds = {lb: none, ub: some(b)};\n         self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds)\n     }\n \n+    // FIXME (#1425): this is a terrible name.\n+    fn vart_integral<V: copy vid, T: copy to_str st>(\n+        _vb: vals_and_bindings<V, int_ty_set>,\n+        _a_id: V, _b: T) -> ures {\n+        // FIXME (#1425): do something real here.\n+        uok()\n+    }\n+\n     fn tvar<V: copy vid, T: copy to_str st>(\n-        vb: vals_and_bindings<V, T>,\n+        vb: vals_and_bindings<V, bounds<T>>,\n         a: T, b_id: V) -> ures {\n \n         let a_bounds = {lb: some(a), ub: none};\n-        let {root: b_id, bounds: b_bounds} = self.get(vb, b_id);\n+        let {root: b_id, possible_types: b_bounds} = self.get(vb, b_id);\n         #debug[\"tvar(%s <: %s=%s)\",\n                a.to_str(self),\n                b_id.to_str(), b_bounds.to_str(self)];\n         self.set_var_to_merged_bounds(vb, b_id, a_bounds, b_bounds)\n     }\n \n+    fn tvar_integral<V: copy vid, T: copy to_str st>(\n+        _vb: vals_and_bindings<V, int_ty_set>,\n+        _a: T, _b_id: V) -> ures {\n+        // FIXME (#1425): do something real here.\n+        uok()\n+    }\n+\n     fn constrs(\n         expected: @ty::type_constr,\n         actual_constr: @ty::type_constr) -> ures {\n@@ -823,7 +932,7 @@ type resolve_state = @{\n     force_vars: bool,\n     mut err: option<fixup_err>,\n     mut r_seen: [region_vid],\n-    mut v_seen: [ty_vid]\n+    mut v_seen: [tv_vid]\n };\n \n fn resolver(infcx: infer_ctxt, deep: bool, fvars: bool) -> resolve_state {\n@@ -871,6 +980,9 @@ impl methods for resolve_state {\n               ty::ty_var(vid) {\n                 self.resolve_ty_var(vid)\n               }\n+              ty::ty_var_integral(vid) {\n+                self.resolve_ty_var_integral(vid)\n+              }\n               _ if !ty::type_has_regions(typ) && !self.deep {\n                 typ\n               }\n@@ -904,7 +1016,8 @@ impl methods for resolve_state {\n             ret ty::re_var(rid);\n         } else {\n             vec::push(self.r_seen, rid);\n-            let {root:_, bounds} = self.infcx.get(self.infcx.rb, rid);\n+            let {root:_, possible_types: bounds} =\n+                self.infcx.get(self.infcx.rb, rid);\n             let r1 = alt bounds {\n               { ub:_, lb:some(t) } { self.resolve_region(t) }\n               { ub:some(t), lb:_ } { self.resolve_region(t) }\n@@ -920,7 +1033,7 @@ impl methods for resolve_state {\n         }\n     }\n \n-    fn resolve_ty_var(vid: ty_vid) -> ty::t {\n+    fn resolve_ty_var(vid: tv_vid) -> ty::t {\n         if vec::contains(self.v_seen, vid) {\n             self.err = some(cyclic_ty(vid));\n             ret ty::mk_var(self.infcx.tcx, vid);\n@@ -934,7 +1047,8 @@ impl methods for resolve_state {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let {root:_, bounds} = self.infcx.get(self.infcx.tvb, vid);\n+            let {root:_, possible_types: bounds} =\n+                self.infcx.get(self.infcx.tvb, vid);\n             let t1 = alt bounds {\n               { ub:_, lb:some(t) } if !type_is_bot(t) { self.resolve1(t) }\n               { ub:some(t), lb:_ } { self.resolve1(t) }\n@@ -950,6 +1064,17 @@ impl methods for resolve_state {\n             ret t1;\n         }\n     }\n+\n+    fn resolve_ty_var_integral(vid: tvi_vid) -> ty::t {\n+        let {root:_, possible_types: its} =\n+            self.infcx.get(self.infcx.tvib, vid);\n+        let t1 = alt its {\n+          // FIXME (#1425): do something real here.\n+          int_ty_set(_) { ty::mk_int(self.infcx.tcx) }\n+        };\n+        ret t1;\n+    }\n+\n }\n \n // ______________________________________________________________________\n@@ -1027,21 +1152,21 @@ impl assignment for infer_ctxt {\n           }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-            let {root:_, bounds: a_bounds} = self.get(self.tvb, a_id);\n-            let {root:_, bounds: b_bounds} = self.get(self.tvb, b_id);\n+            let {root:_, possible_types: a_bounds} = self.get(self.tvb, a_id);\n+            let {root:_, possible_types: b_bounds} = self.get(self.tvb, b_id);\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n             self.assign_tys_or_sub(anmnt, a, b, a_bnd, b_bnd)\n           }\n \n           (ty::ty_var(a_id), _) {\n-            let {root:_, bounds:a_bounds} = self.get(self.tvb, a_id);\n+            let {root:_, possible_types:a_bounds} = self.get(self.tvb, a_id);\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             self.assign_tys_or_sub(anmnt, a, b, a_bnd, some(b))\n           }\n \n           (_, ty::ty_var(b_id)) {\n-            let {root:_, bounds: b_bounds} = self.get(self.tvb, b_id);\n+            let {root:_, possible_types: b_bounds} = self.get(self.tvb, b_id);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n             self.assign_tys_or_sub(anmnt, a, b, some(a), b_bnd)\n           }\n@@ -1199,6 +1324,7 @@ iface combine {\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n     fn contratys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n+    fn int_tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]>;\n     fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>>;\n     fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs>;\n@@ -1389,6 +1515,12 @@ fn super_fns<C:combine>(\n     }\n }\n \n+fn super_int_tys<C:combine>(\n+    self: C, _a: ty::t, _b: ty::t) -> cres<ty::t> {\n+    // FIXME (#1425): do something real here?\n+    ok(ty::mk_int(self.infcx().tcx))\n+}\n+\n fn super_tys<C:combine>(\n     self: C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n@@ -1654,6 +1786,21 @@ impl of combine for sub {\n               (_, ty::ty_bot) {\n                 err(ty::terr_sorts(b, a))\n               }\n+\n+              // FIXME (#1425): I'm not sure if these three cases\n+              // belong here or if they belong in super_tys.\n+              (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) {\n+                self.infcx().vars_integral(self.tvib, a_id, b_id).then {||\n+                    ok(a) }\n+              }\n+              (ty::ty_var_integral(a_id), _) {\n+                self.infcx().vart_integral(self.tvib, a_id, b).then {||\n+                    ok(a) }\n+              }\n+              (_, ty::ty_var_integral(b_id)) {\n+                self.infcx().tvar_integral(self.tvib, a, b_id).then {||\n+                    ok(a) }\n+              }\n               _ {\n                 super_tys(self, a, b)\n               }\n@@ -1699,6 +1846,10 @@ impl of combine for sub {\n \n     // Traits please:\n \n+    fn int_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        super_int_tys(self, a, b)\n+    }\n+\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n         super_flds(self, a, b)\n     }\n@@ -1877,6 +2028,10 @@ impl of combine for lub {\n \n     // Traits please:\n \n+    fn int_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        super_int_tys(self, a, b)\n+    }\n+\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n         lattice_tys(self, a, b)\n     }\n@@ -2080,6 +2235,10 @@ impl of combine for glb {\n \n     // Traits please:\n \n+    fn int_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        super_int_tys(self, a, b)\n+    }\n+\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n         super_flds(self, a, b)\n     }\n@@ -2173,6 +2332,20 @@ fn lattice_tys<L:lattice_ops combine>(\n             lattice_var_t(self, self.infcx().tvb, b_id, a,\n                           {|x, y| self.tys(x, y) })\n           }\n+          (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) {\n+            // FIXME (#1425): do something real here?\n+            ok(a)\n+          }\n+\n+          (ty::ty_var_integral(a_id), _) {\n+            // FIXME (#1425): do something real here?\n+            ok(a)\n+          }\n+\n+          (_, ty::ty_var_integral(b_id)) {\n+            // FIXME (#1425): do something real here?\n+            ok(a)\n+          }\n \n           _ {\n             super_tys(self, a, b)\n@@ -2210,7 +2383,7 @@ fn lattice_rvars<L:lattice_ops combine>(\n }\n \n fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n-    self: L, vb: vals_and_bindings<V, T>,\n+    self: L, vb: vals_and_bindings<V, bounds<T>>,\n     a_t: T, a_vid: V, b_vid: V,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n \n@@ -2219,8 +2392,8 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     // upper/lower/sub/super/etc.\n \n     // Need to find a type that is a supertype of both a and b:\n-    let {root: a_vid, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n-    let {root: b_vid, bounds: b_bounds} = self.infcx().get(vb, b_vid);\n+    let {root: a_vid, possible_types: a_bounds} = self.infcx().get(vb, a_vid);\n+    let {root: b_vid, possible_types: b_bounds} = self.infcx().get(vb, b_vid);\n \n     #debug[\"%s.lattice_vars(%s=%s <: %s=%s)\",\n            self.tag(),\n@@ -2252,11 +2425,11 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n }\n \n fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n-    self: L, vb: vals_and_bindings<V, T>,\n+    self: L, vb: vals_and_bindings<V, bounds<T>>,\n     a_id: V, b: T,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n \n-    let {root: a_id, bounds: a_bounds} = self.infcx().get(vb, a_id);\n+    let {root: a_id, possible_types: a_bounds} = self.infcx().get(vb, a_id);\n \n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n@@ -2268,7 +2441,7 @@ fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n \n     alt self.bnd(a_bounds) {\n       some(a_bnd) {\n-        // If a has an upper bound, return it.\n+        // If a has an upper bound, return the LUB(a.ub, b)\n         #debug[\"bnd=some(%s)\", a_bnd.to_str(self.infcx())];\n         ret c_ts(a_bnd, b);\n       }\n@@ -2278,7 +2451,7 @@ fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n         #debug[\"bnd=none\"];\n         let a_bounds = self.with_bnd(a_bounds, b);\n         self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n-            self.infcx().set(vb, a_id, bounded(a_bounds));\n+            self.infcx().set(vb, a_id, root(a_bounds));\n             ok(b)\n         }\n       }"}]}