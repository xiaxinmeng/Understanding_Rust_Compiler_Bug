{"sha": "f371482593ea9c7179c76b919ce5ed95aa6956b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNzE0ODI1OTNlYTljNzE3OWM3NmI5MTljZTVlZDk1YWE2OTU2Yjg=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-02T23:24:38Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-02T23:30:56Z"}, "message": "Consolidate environment building/loading between closure types.", "tree": {"sha": "c25b8609c85ac15e86bf0e676d88b596cf5baf2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c25b8609c85ac15e86bf0e676d88b596cf5baf2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f371482593ea9c7179c76b919ce5ed95aa6956b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f371482593ea9c7179c76b919ce5ed95aa6956b8", "html_url": "https://github.com/rust-lang/rust/commit/f371482593ea9c7179c76b919ce5ed95aa6956b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f371482593ea9c7179c76b919ce5ed95aa6956b8/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cf4e17e1d979ad21140a6ebf0d84b868f11432f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf4e17e1d979ad21140a6ebf0d84b868f11432f", "html_url": "https://github.com/rust-lang/rust/commit/4cf4e17e1d979ad21140a6ebf0d84b868f11432f"}], "stats": {"total": 255, "additions": 102, "deletions": 153}, "files": [{"sha": "93b5d145c3e4ef99941716983b88caf23bc34de4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 83, "deletions": 153, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/f371482593ea9c7179c76b919ce5ed95aa6956b8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f371482593ea9c7179c76b919ce5ed95aa6956b8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f371482593ea9c7179c76b919ce5ed95aa6956b8", "patch": "@@ -145,11 +145,7 @@ fn type_of_fn_full(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n         // *input* type of the function we're given as our iter-block\n         // argument.\n         atys +=\n-            ~[T_fn_pair(*cx,\n-                        type_of_fn_full(cx, sp, ast::proto_fn, false,\n-                                        ~[{mode: ty::mo_alias(false),\n-                                           ty: output}], ty::mk_nil(cx.tcx),\n-                                        0u))];\n+            ~[type_of_inner(cx, sp, ty::mk_iter_body_fn(cx.tcx, output))];\n     }\n \n     // ... then explicit args.\n@@ -863,15 +859,13 @@ fn trans_malloc_boxed_raw(cx: &@block_ctxt, t: ty::t) -> result {\n // trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,\n // initializes the reference count to 1, and pulls out the body and rc\n fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) ->\n-    {bcx: @block_ctxt, box: ValueRef, rc: ValueRef, body: ValueRef} {\n+    {bcx: @block_ctxt, box: ValueRef, body: ValueRef} {\n     let res = trans_malloc_boxed_raw(cx, t);\n     let box = res.val;\n-    let rc = res.bcx.build.GEP(box,\n-                               ~[C_int(0), C_int(abi::box_rc_field_refcnt)]);\n+    let rc = GEPi(res.bcx, box, ~[0, abi::box_rc_field_refcnt]);\n     res.bcx.build.Store(C_int(1), rc);\n-    let body = res.bcx.build.GEP(box,\n-                                 ~[C_int(0), C_int(abi::box_rc_field_body)]);\n-    ret {bcx: res.bcx, box: res.val, rc: rc, body: body};\n+    let body = GEPi(res.bcx, box, ~[0, abi::box_rc_field_body]);\n+    ret {bcx: res.bcx, box: res.val, body: body};\n }\n \n // Type descriptor and type glue stuff\n@@ -3645,11 +3639,13 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n \n // Iterator translation\n \n-// build_environment_heap and build_environment are very similar. It\n-// would be nice to unify them.\n-\n-fn build_environment_heap(bcx: @block_ctxt, lltydescs: ValueRef[],\n-                          bound_tys: ty::t[], bound_vals: lval_result[])\n+// Given a block context and a list of tydescs and values to bind\n+// construct a closure out of them. If copying is true, it is a\n+// heap allocated closure that copies the upvars into environment.\n+// Otherwise, it is stack allocated and copies pointers to the upvars.\n+fn build_environment(bcx: @block_ctxt, lltydescs: ValueRef[],\n+                     bound_tys: ty::t[], bound_vals: lval_result[],\n+                     copying: bool)\n     -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n     // Synthesize a closure type.\n \n@@ -3682,18 +3678,29 @@ fn build_environment_heap(bcx: @block_ctxt, lltydescs: ValueRef[],\n     let closure_ty: ty::t = ty::mk_imm_tup(bcx_tcx(bcx), closure_tys);\n \n     // Allocate a box that can hold something closure-sized.\n-    let r = trans_malloc_boxed(bcx, closure_ty);\n+    let r = if copying {\n+        trans_malloc_boxed(bcx, closure_ty)\n+    } else {\n+        // We need to dummy up a box on the stack\n+        let ty = ty::mk_imm_tup(bcx_tcx(bcx),\n+                                ~[ty::mk_int(bcx_tcx(bcx)), closure_ty]);\n+        let r = alloc_ty(bcx, ty);\n+        let body = GEPi(bcx, r.val, ~[0, abi::box_rc_field_body]);\n+        {bcx: r.bcx, box: r.val, body: body}\n+    };\n     bcx = r.bcx;\n     let closure = r.body;\n \n     // Store bindings tydesc.\n-    let bound_tydesc = GEPi(bcx, closure, ~[0, abi::closure_elt_tydesc]);\n-    let ti = none;\n-    let bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-    bcx = bindings_tydesc.bcx;\n-    bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n+    if copying {\n+        let bound_tydesc = GEPi(bcx, closure, ~[0, abi::closure_elt_tydesc]);\n+        let ti = none;\n+        let bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+        bcx = bindings_tydesc.bcx;\n+        bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n+    }\n \n     // Copy expr values into boxed bindings.\n     let i = 0u;\n@@ -3704,8 +3711,13 @@ fn build_environment_heap(bcx: @block_ctxt, lltydescs: ValueRef[],\n     for lv: lval_result  in bound_vals {\n         let bound = GEP_tup_like(bcx, bindings_ty, bindings.val,\n                                  ~[0, i as int]);\n-        bcx = move_val_if_temp(bound.bcx, INIT,\n-                               bound.val, lv, bound_tys.(i)).bcx;\n+        bcx = bound.bcx;\n+        if copying {\n+            bcx = move_val_if_temp(bcx, INIT,\n+                                   bound.val, lv, bound_tys.(i)).bcx;\n+        } else {\n+            bcx.build.Store(lv.res.val, bound.val);\n+        }\n         i += 1u;\n     }\n \n@@ -3725,78 +3737,27 @@ fn build_environment_heap(bcx: @block_ctxt, lltydescs: ValueRef[],\n     ret {ptr: r.box, ptrty: closure_ty, bcx: bcx};\n }\n \n-fn build_copying_closure(cx: &@block_ctxt, upvars: &@ast::node_id[])\n+// Given a context and a list of upvars, build a closure. This just\n+// collects the upvars and packages them up for build_environment.\n+fn build_closure(cx: &@block_ctxt, upvars: &@ast::node_id[], copying: bool)\n     -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n         let closure_vals: lval_result[] = ~[];\n         let closure_tys: ty::t[] = ~[];\n-        for nid: ast::node_id  in *upvars {\n-            closure_vals += ~[trans_var(cx, cx.sp, nid)];\n-            closure_tys += ~[ty::node_id_to_monotype(bcx_tcx(cx), nid)];\n-        }\n-\n-        ret build_environment_heap(cx, cx.fcx.lltydescs,\n-                                   closure_tys, closure_vals);\n-}\n-\n-// Given a block context and a list of upvars, construct a closure that\n-// contains pointers to all of the upvars and all of the tydescs in\n-// scope. Return the ValueRef and TypeRef corresponding to the closure.\n-fn build_environment(cx: &@block_ctxt, upvars: &@ast::node_id[]) ->\n-   {ptr: ValueRef, ptrty: TypeRef} {\n-    let has_iterbody = !option::is_none(cx.fcx.lliterbody);\n-    let llbindingsptr;\n-\n-    if std::ivec::len(*upvars) > 0u || has_iterbody {\n-        // Gather up the upvars.\n-        let llbindings: ValueRef[] = ~[];\n-        let llbindingtys: TypeRef[] = ~[];\n-        if has_iterbody {\n-            llbindings += ~[option::get(cx.fcx.lliterbody)];\n-            llbindingtys += ~[val_ty(llbindings.(0))];\n+        // If we need to, package up the iterator body to call\n+        if !copying && !option::is_none(cx.fcx.lliterbody) {\n+            closure_vals += ~[lval_mem(cx, option::get(cx.fcx.lliterbody))];\n+            closure_tys += ~[option::get(cx.fcx.iterbodyty)];\n         }\n+        // Package up the upvars\n         for nid: ast::node_id  in *upvars {\n-            let llbinding = trans_var(cx, cx.sp, nid).res.val;\n-            llbindings += ~[llbinding];\n-            llbindingtys += ~[val_ty(llbinding)];\n-        }\n-\n-        // Create an array of bindings and copy in aliases to the upvars.\n-        llbindingsptr = alloca(cx, T_struct(llbindingtys));\n-        let upvar_count = std::ivec::len(llbindings);\n-        let i = 0u;\n-        while i < upvar_count {\n-            let llbindingptr = GEPi(cx, llbindingsptr, ~[0, i as int]);\n-            cx.build.Store(llbindings.(i), llbindingptr);\n-            i += 1u;\n+            closure_vals += ~[trans_var(cx, cx.sp, nid)];\n+            let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n+            if !copying { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n+            closure_tys += ~[ty];\n         }\n-    } else {\n-        // Null bindings.\n-        llbindingsptr = C_null(T_ptr(T_i8()));\n-    }\n-\n-    // Create an environment and populate it with the bindings.\n-    let tydesc_count = std::ivec::len(cx.fcx.lltydescs);\n-    let llenvptrty =\n-        T_closure_ptr(*bcx_ccx(cx), val_ty(llbindingsptr), tydesc_count);\n-    let llenvptr = alloca(cx, llvm::LLVMGetElementType(llenvptrty));\n-    let llbindingsptrptr =\n-        GEPi(cx, llenvptr,\n-             ~[0, abi::box_rc_field_body, abi::closure_elt_bindings]);\n-    cx.build.Store(llbindingsptr, llbindingsptrptr);\n-\n-    // Copy in our type descriptors, in case the iterator body needs to refer\n-    // to them.\n-    let lltydescsptr =\n-        GEPi(cx, llenvptr,\n-             ~[0, abi::box_rc_field_body, abi::closure_elt_ty_params]);\n-    let i = 0u;\n-    while i < tydesc_count {\n-        let lltydescptr = GEPi(cx, lltydescsptr, ~[0, i as int]);\n-        cx.build.Store(cx.fcx.lltydescs.(i), lltydescptr);\n-        i += 1u;\n-    }\n \n-    ret {ptr: llenvptr, ptrty: llenvptrty};\n+        ret build_environment(cx, cx.fcx.lltydescs,\n+                              closure_tys, closure_vals, copying);\n }\n \n // Return a pointer to the stored typarams in a closure.\n@@ -3829,8 +3790,12 @@ fn find_environment_tydescs(bcx: &@block_ctxt, envty: &ty::t,\n     }\n }\n \n-fn load_environment_heap(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt,\n-                         envty: &ty::t, upvars: &@ast::node_id[]) {\n+// Given an enclosing block context, a new function context, a closure type,\n+// and a list of upvars, generate code to load and populate the environment\n+// with the upvars and type descriptors.\n+fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt,\n+                    envty: &ty::t, upvars: &@ast::node_id[],\n+                    copying: bool) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n     let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n@@ -3852,54 +3817,25 @@ fn load_environment_heap(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt,\n     // Populate the upvars from the environment.\n     let path = ~[0, abi::box_rc_field_body, abi::closure_elt_bindings];\n     i = 0u;\n-    for upvar_id: ast::node_id  in *upvars {\n-        let llupvarptr =\n-            GEP_tup_like(bcx, ty, llclosure, path + ~[i as int]);\n-        bcx = llupvarptr.bcx;\n-        let def_id = ast::def_id_of_def(bcx_tcx(bcx).def_map.get(upvar_id));\n-        fcx.llupvars.insert(def_id.node, llupvarptr.val);\n+    // If this is an aliasing closure/for-each body, we need to load\n+    // the iterbody.\n+    if !copying && !option::is_none(enclosing_cx.fcx.lliterbody) {\n+        let iterbodyptr = GEP_tup_like(bcx, ty, llclosure, path + ~[0]);\n+        fcx.lliterbody = some(bcx.build.Load(iterbodyptr.val));\n+        bcx = iterbodyptr.bcx;\n         i += 1u;\n     }\n-}\n-\n-\n-// Given an enclosing block context, a new function context, a closure type,\n-// and a list of upvars, generate code to load and populate the environment\n-// with the upvars and type descriptors.\n-fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt,\n-                    llenvptrty: TypeRef, upvars: &@ast::node_id[]) {\n-    let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n-\n-    // Populate the upvars from the environment.\n-    let llenvptr = bcx.build.PointerCast(fcx.llenv, llenvptrty);\n-    llenvptr = GEPi(bcx, llenvptr, ~[0, abi::box_rc_field_body]);\n-    let llbindingsptrptr =\n-        GEPi(bcx, llenvptr, ~[0, abi::closure_elt_bindings]);\n-    let llbindingsptr = bcx.build.Load(llbindingsptrptr);\n-\n-    let i = 0u;\n-    if !option::is_none(enclosing_cx.fcx.lliterbody) {\n-        i += 1u;\n-        let lliterbodyptr = GEPi(bcx, llbindingsptr, ~[0, 0]);\n-        fcx.lliterbody = some(bcx.build.Load(lliterbodyptr));\n-    }\n+    // Load the acutal upvars.\n     for upvar_id: ast::node_id  in *upvars {\n-        let llupvarptrptr = GEPi(bcx, llbindingsptr, ~[0, i as int]);\n-        let llupvarptr = bcx.build.Load(llupvarptrptr);\n+        let upvarptr =\n+            GEP_tup_like(bcx, ty, llclosure, path + ~[i as int]);\n+        bcx = upvarptr.bcx;\n+        let llupvarptr = upvarptr.val;\n+        if !copying { llupvarptr = bcx.build.Load(llupvarptr); }\n         let def_id = ast::def_id_of_def(bcx_tcx(bcx).def_map.get(upvar_id));\n         fcx.llupvars.insert(def_id.node, llupvarptr);\n         i += 1u;\n     }\n-\n-    // Populate the type parameters from the environment.\n-    let lltydescsptr = GEPi(bcx, llenvptr, ~[0, abi::closure_elt_ty_params]);\n-    let tydesc_count = std::ivec::len(enclosing_cx.fcx.lltydescs);\n-    i = 0u;\n-    while i < tydesc_count {\n-        let lltydescptr = GEPi(bcx, lltydescsptr, ~[0, i as int]);\n-        fcx.lltydescs += ~[bcx.build.Load(lltydescptr)];\n-        i += 1u;\n-    }\n }\n \n fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n@@ -3934,7 +3870,7 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     let decl_ty = node_id_type(lcx.ccx, local.node.id);\n     let upvars = get_freevars(lcx.ccx.tcx, body.node.id);\n \n-    let llenv = build_environment(cx, upvars);\n+    let llenv = build_closure(cx, upvars, false);\n \n     // Step 2: Declare foreach body function.\n     let s: str =\n@@ -3946,16 +3882,16 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n     // and pass it in as a first class fn-arg to the iterator.\n     let iter_body_llty =\n-        type_of_fn_full(lcx.ccx, cx.sp, ast::proto_fn, false,\n-                        ~[{mode: ty::mo_alias(false), ty: decl_ty}],\n-                        ty::mk_nil(lcx.ccx.tcx), 0u);\n+        type_of_fn_from_ty(lcx.ccx, cx.sp,\n+                           ty::mk_iter_body_fn(lcx.ccx.tcx, decl_ty), 0u);\n     let lliterbody: ValueRef =\n         decl_internal_fastcall_fn(lcx.ccx.llmod, s, iter_body_llty);\n     let fcx = new_fn_ctxt_w_id(lcx, cx.sp, lliterbody, body.node.id);\n+    fcx.iterbodyty = cx.fcx.iterbodyty;\n \n     // Generate code to load the environment out of the\n     // environment pointer.\n-    load_environment(cx, fcx, llenv.ptrty, upvars);\n+    load_environment(cx, fcx, llenv.ptrty, upvars, false);\n \n     let bcx = new_top_block_ctxt(fcx);\n     // Add bindings for the loop variable alias.\n@@ -4684,8 +4620,8 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     }\n \n     // Actually construct the closure\n-    let closure = build_environment_heap(bcx, lltydescs,\n-                                         bound_tys, bound_vals);\n+    let closure = build_environment(bcx, lltydescs,\n+                                    bound_tys, bound_vals, true);\n     bcx = closure.bcx;\n \n     // Make thunk\n@@ -6236,6 +6172,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: &span, llfndecl: ValueRef,\n           mutable lldynamicallocas: llbbs.da,\n           mutable llself: none[val_self_pair],\n           mutable lliterbody: none[ValueRef],\n+          mutable iterbodyty: none[ty::t],\n           llargs: llargs,\n           llobjfields: llobjfields,\n           lllocals: lllocals,\n@@ -6271,7 +6208,6 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n     // Skip the implicit arguments 0, 1, and 2.  TODO: Pull out 3u and define\n     // it as a constant, since we're using it in several places in trans this\n     // way.\n-\n     let arg_n = 3u;\n     alt ty_self {\n       some(tt) { cx.llself = some[val_self_pair]({v: cx.llenv, t: tt}); }\n@@ -6286,18 +6222,18 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n         }\n       }\n     }\n+\n     // If the function is actually an iter, populate the lliterbody field of\n     // the function context with the ValueRef that we get from\n     // llvm::LLVMGetParam for the iter's body.\n-\n     if proto == ast::proto_iter {\n+        cx.iterbodyty = some(ty::mk_iter_body_fn(fcx_tcx(cx), ret_ty));\n         let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n         assert (llarg as int != 0);\n         cx.lliterbody = some[ValueRef](llarg);\n         arg_n += 1u;\n     }\n \n-\n     // Populate the llargs field of the function context with the ValueRefs\n     // that we get from llvm::LLVMGetParam for each argument.\n     for arg: ast::arg  in args {\n@@ -6468,15 +6404,9 @@ fn trans_closure(bcx_maybe: &option::t[@block_ctxt],\n         let bcx = option::get(bcx_maybe);\n         let upvars = get_freevars(cx.ccx.tcx, id);\n \n-        let env = if (f.proto == ast::proto_block) {\n-            let llenv = build_environment(bcx, upvars);\n-            load_environment(bcx, fcx, llenv.ptrty, upvars);\n-            {ptr: llenv.ptr, bcx: bcx}\n-        } else {\n-            let llenv = build_copying_closure(bcx, upvars);\n-            load_environment_heap(bcx, fcx, llenv.ptrty, upvars);\n-            {ptr: llenv.ptr, bcx: llenv.bcx}\n-        };\n+        let copying = f.proto == ast::proto_closure;\n+        let env = build_closure(bcx, upvars, copying);\n+        load_environment(bcx, fcx, env.ptrty, upvars, copying);\n \n         let closure = create_real_fn_pair(env.bcx, option::get(llfnty),\n                                           llfndecl, env.ptr);"}, {"sha": "67c3baa8fa9eb41c0994936183bad879d631fba6", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f371482593ea9c7179c76b919ce5ed95aa6956b8/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f371482593ea9c7179c76b919ce5ed95aa6956b8/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=f371482593ea9c7179c76b919ce5ed95aa6956b8", "patch": "@@ -205,6 +205,12 @@ type fn_ctxt =\n     // If this function is actually a iter, a block containing the code\n     // called whenever the iter calls 'put'.\n \n+    // If this function is actually a iter, the type of the function\n+    // that that we call when we call 'put'. Having to track this is\n+    // pretty irritating. We have to do it because we need the type if\n+    // we are going to put the iterbody into a closure (if it appears\n+    // in a for-each inside of an iter).\n+\n     // The next four items: hash tables mapping from AST def_ids to\n     // LLVM-stuff-in-the-frame.\n \n@@ -253,6 +259,7 @@ type fn_ctxt =\n      mutable lldynamicallocas: BasicBlockRef,\n      mutable llself: option::t[val_self_pair],\n      mutable lliterbody: option::t[ValueRef],\n+     mutable iterbodyty: option::t[ty::t],\n      llargs: hashmap[ast::node_id, ValueRef],\n      llobjfields: hashmap[ast::node_id, ValueRef],\n      lllocals: hashmap[ast::node_id, ValueRef],\n@@ -412,6 +419,7 @@ fn bcx_tcx(bcx: &@block_ctxt) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n fn bcx_ccx(bcx: &@block_ctxt) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n fn bcx_lcx(bcx: &@block_ctxt) -> @local_ctxt { ret bcx.fcx.lcx; }\n fn bcx_fcx(bcx: &@block_ctxt) -> @fn_ctxt { ret bcx.fcx; }\n+fn fcx_tcx(fcx: &@fn_ctxt)    -> ty::ctxt { ret fcx.lcx.ccx.tcx; }\n fn lcx_ccx(lcx: &@local_ctxt) -> @crate_ctxt { ret lcx.ccx; }\n fn ccx_tcx(ccx: &@crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n "}, {"sha": "3538f35cda9cd06c338cf864527ea65e9ca393a5", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f371482593ea9c7179c76b919ce5ed95aa6956b8/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f371482593ea9c7179c76b919ce5ed95aa6956b8/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f371482593ea9c7179c76b919ce5ed95aa6956b8", "patch": "@@ -68,6 +68,7 @@ export mk_ctxt;\n export mk_float;\n export mk_fn;\n export mk_imm_box;\n+export mk_mut_ptr;\n export mk_imm_vec;\n export mk_int;\n export mk_istr;\n@@ -90,6 +91,7 @@ export mk_type;\n export mk_uint;\n export mk_var;\n export mk_vec;\n+export mk_iter_body_fn;\n export mode;\n export mo_val;\n export mo_alias;\n@@ -559,6 +561,10 @@ fn mk_imm_box(cx: &ctxt, ty: &t) -> t {\n     ret mk_box(cx, {ty: ty, mut: ast::imm});\n }\n \n+fn mk_mut_ptr(cx: &ctxt, ty: &t) -> t {\n+    ret mk_ptr(cx, {ty: ty, mut: ast::mut});\n+}\n+\n fn mk_vec(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_vec(tm)); }\n \n fn mk_ivec(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_ivec(tm)); }\n@@ -614,6 +620,11 @@ fn mk_type(cx: &ctxt) -> t { ret idx_type; }\n \n fn mk_native(cx: &ctxt, did: &def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n \n+fn mk_iter_body_fn(cx: &ctxt, output: &t) -> t {\n+    ret mk_fn(cx, ast::proto_block,\n+              ~[{mode: ty::mo_alias(false), ty: output}],\n+              ty::mk_nil(cx), ast::return, ~[]);\n+}\n \n // Returns the one-level-deep type structure of the given type.\n fn struct(cx: &ctxt, typ: &t) -> sty {"}]}