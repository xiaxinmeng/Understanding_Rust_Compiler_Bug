{"sha": "4b0edb96d080fadccc542dad50e6576c8e11bd85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMGVkYjk2ZDA4MGZhZGNjYzU0MmRhZDUwZTY1NzZjOGUxMWJkODU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-10T11:02:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-31T13:51:17Z"}, "message": "Combine `try` and `commit_if_ok` and make some details of inference\ncontext private.", "tree": {"sha": "2265524607aa0249fe2dcc21ba5ce3493dd67e73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2265524607aa0249fe2dcc21ba5ce3493dd67e73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b0edb96d080fadccc542dad50e6576c8e11bd85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0edb96d080fadccc542dad50e6576c8e11bd85", "html_url": "https://github.com/rust-lang/rust/commit/4b0edb96d080fadccc542dad50e6576c8e11bd85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b0edb96d080fadccc542dad50e6576c8e11bd85/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0939837867e77f478dcd3735f3a6ce8823f5fd48", "url": "https://api.github.com/repos/rust-lang/rust/commits/0939837867e77f478dcd3735f3a6ce8823f5fd48", "html_url": "https://github.com/rust-lang/rust/commit/0939837867e77f478dcd3735f3a6ce8823f5fd48"}], "stats": {"total": 176, "additions": 81, "deletions": 95}, "files": [{"sha": "9280ffd06545ac59d7692fef1bd112c1646f7dbd", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -60,7 +60,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx().commit_if_ok(|snapshot| {\n             // First, we instantiate each bound region in the subtype with a fresh\n             // region variable.\n             let (a_prime, _) =\n@@ -109,7 +109,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx().commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n             let span = self.trace().origin.span();\n             let (a_with_fresh, a_map) =\n@@ -202,7 +202,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n         // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx().commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n             let (a_with_fresh, a_map) =\n                 self.infcx().replace_late_bound_regions_with_fresh_var("}, {"sha": "31ce8503ed0ac44df5adbda5fc80cab31dddbd73", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 37, "deletions": 53, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -265,7 +265,7 @@ pub enum LateBoundRegionConversionTime {\n ///\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n-pub enum RegionVariableOrigin<'tcx> {\n+pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n     MiscVariable(Span),\n@@ -280,7 +280,7 @@ pub enum RegionVariableOrigin<'tcx> {\n     Autoref(Span),\n \n     // Regions created as part of an automatic coercion\n-    Coercion(TypeTrace<'tcx>),\n+    Coercion(Span),\n \n     // Region variables created as the values for early-bound regions\n     EarlyBoundRegion(Span, ast::Name),\n@@ -343,8 +343,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result =\n-        cx.commit_if_ok(|| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n+    let result = cx.commit_if_ok(|_| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -362,9 +361,7 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           -> UnitResult<'tcx>\n {\n     debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(|| {\n-        cx.sub_types(a_is_expected, origin, a, b)\n-    })\n+    cx.sub_types(a_is_expected, origin, a, b)\n }\n \n pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -404,8 +401,7 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          -> UnitResult<'tcx>\n {\n     debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(\n-        || cx.eq_types(a_is_expected, origin, a, b))\n+    cx.commit_if_ok(|_| cx.eq_types(a_is_expected, origin, a, b))\n }\n \n pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -417,8 +413,7 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(\n-        || cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n+    cx.commit_if_ok(|_| cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n fn expected_found<T>(a_is_expected: bool,\n@@ -476,25 +471,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                              -> CombineFields<'b, 'tcx> {\n+    fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                          -> CombineFields<'b, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> Equate<'b, 'tcx> {\n+    fn equate<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                  -> Equate<'b, 'tcx> {\n         Equate(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn sub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Sub<'b, 'tcx> {\n+    fn sub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> Sub<'b, 'tcx> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Lub<'b, 'tcx> {\n+    fn lub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> Lub<'b, 'tcx> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n@@ -558,11 +553,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit the bindings if successful\n+    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce() -> Result<T, E>\n+        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n     {\n-        self.commit_unconditionally(move || self.try(move |_| f()))\n+        debug!(\"commit_if_ok()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f(&snapshot);\n+        debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n+        match r {\n+            Ok(_) => { self.commit_from(snapshot); }\n+            Err(_) => { self.rollback_to(snapshot); }\n+        }\n+        r\n     }\n \n     /// Execute `f` and commit only the region bindings if successful.\n@@ -577,7 +580,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                float_snapshot,\n                                region_vars_snapshot } = self.start_snapshot();\n \n-        let r = self.try(move |_| f());\n+        let r = self.commit_if_ok(|_| f());\n \n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n@@ -598,25 +601,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Execute `f`, unroll bindings on panic\n-    pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n-    {\n-        debug!(\"try()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        debug!(\"try() -- r.is_ok() = {}\", r.is_ok());\n-        match r {\n-            Ok(_) => {\n-                self.commit_from(snapshot);\n-            }\n-            Err(_) => {\n-                self.rollback_to(snapshot);\n-            }\n-        }\n-        r\n-    }\n-\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n         F: FnOnce(&CombinedSnapshot) -> R,\n@@ -643,7 +627,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      -> UnitResult<'tcx>\n     {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n             self.sub(a_is_expected, trace).tys(a, b).map(|_| ())\n         })\n@@ -656,7 +640,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     b: Ty<'tcx>)\n                     -> UnitResult<'tcx>\n     {\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n             self.equate(a_is_expected, trace).tys(a, b).map(|_| ())\n         })\n@@ -672,7 +656,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"sub_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n                b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n@@ -691,7 +675,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"sub_poly_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n                b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n@@ -749,7 +733,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                               span: Span,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n                               -> UnitResult<'tcx> {\n-        self.try(|snapshot| {\n+        self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = EquatePredicate(span);\n@@ -762,7 +746,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                      span: Span,\n                                      predicate: &ty::PolyRegionOutlivesPredicate)\n                                      -> UnitResult<'tcx> {\n-        self.try(|snapshot| {\n+        self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = RelateRegionParamBound(span);\n@@ -801,7 +785,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .new_key(None)\n     }\n \n-    pub fn next_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> ty::Region {\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n         ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n@@ -1253,14 +1237,14 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> RegionVariableOrigin<'tcx> {\n+impl RegionVariableOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n             MiscVariable(a) => a,\n             PatternRegion(a) => a,\n             AddrOfRegion(a) => a,\n             Autoref(a) => a,\n-            Coercion(ref a) => a.span(),\n+            Coercion(a) => a,\n             EarlyBoundRegion(a, _) => a,\n             LateBoundRegion(a, _, _) => a,\n             BoundRegionInCoherence(_) => codemap::DUMMY_SP,\n@@ -1269,7 +1253,7 @@ impl<'tcx> RegionVariableOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n+impl<'tcx> Repr<'tcx> for RegionVariableOrigin {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             MiscVariable(a) => {\n@@ -1282,7 +1266,7 @@ impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n                 format!(\"AddrOfRegion({})\", a.repr(tcx))\n             }\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n-            Coercion(ref a) => format!(\"Coercion({})\", a.repr(tcx)),\n+            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n             EarlyBoundRegion(a, b) => {\n                 format!(\"EarlyBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n             }"}, {"sha": "1d15656fea2507dc3ef60b34d476e2c672b77da1", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -115,7 +115,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// Could not infer a value for `v` because `sub_r <= v` (due to\n     /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n     /// `sub_r <= sup_r` does not hold.\n-    SubSupConflict(RegionVariableOrigin<'tcx>,\n+    SubSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>, Region,\n                    SubregionOrigin<'tcx>, Region),\n \n@@ -124,15 +124,15 @@ pub enum RegionResolutionError<'tcx> {\n     /// Could not infer a value for `v` because `v <= r1` (due to\n     /// `origin1`) and `v <= r2` (due to `origin2`) and\n     /// `r1` and `r2` have no intersection.\n-    SupSupConflict(RegionVariableOrigin<'tcx>,\n+    SupSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>, Region,\n                    SubregionOrigin<'tcx>, Region),\n \n     /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n     /// more specific errors message by suggesting to the user where they\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<RegionVariableOrigin<'tcx>>,\n+    ProcessedErrors(Vec<RegionVariableOrigin>,\n                     Vec<(TypeTrace<'tcx>, ty::type_err<'tcx>)>,\n                     Vec<SameRegions>),\n }\n@@ -168,7 +168,7 @@ pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    var_origins: RefCell<Vec<RegionVariableOrigin<'tcx>>>,\n+    var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n@@ -316,7 +316,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         len as u32\n     }\n \n-    pub fn new_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> RegionVid {\n+    pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n         self.var_origins.borrow_mut().push(origin.clone());\n         let vid = RegionVid { index: id };"}, {"sha": "e27b910f6c26d2f8f5ee467065e22acb43d692d2", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -81,7 +81,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n            obligation.repr(selcx.tcx()));\n \n     let infcx = selcx.infcx();\n-    infcx.try(|snapshot| {\n+    infcx.commit_if_ok(|snapshot| {\n         let (skol_predicate, skol_map) =\n             infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n "}, {"sha": "740bed72d9b2ddd5ff113fd1f6ad62e255e8dafc", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -1242,7 +1242,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        self.infcx.try(|snapshot| {\n+        self.infcx.commit_if_ok(|snapshot| {\n             let bound_self_ty =\n                 self.infcx.resolve_type_vars_if_possible(&obligation.self_ty());\n             let (self_ty, _) =\n@@ -1778,7 +1778,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // For each type, produce a vector of resulting obligations\n         let obligations: Result<Vec<Vec<_>>, _> = bound_types.iter().map(|nested_ty| {\n-            self.infcx.try(|snapshot| {\n+            self.infcx.commit_if_ok(|snapshot| {\n                 let (skol_ty, skol_map) =\n                     self.infcx().skolemize_late_bound_regions(nested_ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n@@ -1888,7 +1888,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     obligation: &TraitObligation<'tcx>)\n     {\n         let _: Result<(),()> =\n-            self.infcx.try(|snapshot| {\n+            self.infcx.commit_if_ok(|snapshot| {\n                 let result =\n                     self.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                                snapshot);\n@@ -2043,7 +2043,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                                 trait_def_id,\n                                                                 nested);\n \n-        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.try(|snapshot| {\n+        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.commit_if_ok(|snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n@@ -2077,7 +2077,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.try(|snapshot| {\n+        self.infcx.commit_if_ok(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n                 self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n             let substs ="}, {"sha": "0765d7294adf2c53a4510bbebdd435063145362e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -76,7 +76,7 @@ use syntax::ast;\n \n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    trace: TypeTrace<'tcx>\n+    origin: infer::TypeOrigin,\n }\n \n type CoerceResult<'tcx> = CombineResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n@@ -87,14 +87,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n-        try!(sub.tys(a, b));\n+        try!(self.fcx.infcx().sub_types(false, self.origin.clone(), a, b));\n         Ok(None) // No coercion required.\n     }\n \n-    fn outlives(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ()> {\n-        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n-        try!(sub.regions(b, a));\n+    fn outlives(&self,\n+                origin: infer::SubregionOrigin<'tcx>,\n+                a: ty::Region,\n+                b: ty::Region)\n+                -> RelateResult<'tcx, ()> {\n+        infer::mk_subr(self.fcx.infcx(), origin, b, a);\n         Ok(())\n     }\n \n@@ -190,7 +192,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => return self.subtype(a, b)\n         }\n \n-        let coercion = Coercion(self.trace.clone());\n+        let coercion = Coercion(self.origin.span());\n         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n         let autoref = Some(AutoPtr(r_borrow, mutbl_b, None));\n \n@@ -214,7 +216,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             let ty = ty::mk_rptr(self.tcx(), r_borrow,\n                                  mt {ty: inner_ty, mutbl: mutbl_b});\n-            if let Err(err) = self.fcx.infcx().try(|_| self.subtype(ty, b)) {\n+            if let Err(err) = self.subtype(ty, b) {\n                 if first_error.is_none() {\n                     first_error = Some(err);\n                 }\n@@ -264,12 +266,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             return Err(ty::terr_mutability);\n                         }\n \n-                        let coercion = Coercion(self.trace.clone());\n+                        let coercion = Coercion(self.origin.span());\n                         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                         let ty = ty::mk_rptr(self.tcx(),\n                                              self.tcx().mk_region(r_borrow),\n                                              ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoPtr(AutoUnsize({:?})))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -290,7 +292,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                         let ty = ty::mk_ptr(self.tcx(),\n                                              ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoPtr(AutoUnsize({:?})))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -306,7 +308,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 match self.unsize_ty(t_a, t_b) {\n                     Some((ty, kind)) => {\n                         let ty = ty::mk_uniq(self.tcx(), ty);\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoUnsizeUniq({:?}))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -365,9 +367,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n \n                             // relate `a1` to `b`\n-                            let result = self.fcx.infcx().try(|_| {\n+                            let result = self.fcx.infcx().commit_if_ok(|_| {\n                                 // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n-                                try!(self.outlives(data_a.bounds.region_bound,\n+                                try!(self.outlives(infer::RelateObjectBound(self.origin.span()),\n+                                                   data_a.bounds.region_bound,\n                                                    data_b.bounds.region_bound));\n                                 self.subtype(ty_a1, ty_b)\n                             });\n@@ -399,7 +402,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let mut result = None;\n                         let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                         for (i, (tp_a, tp_b)) in tps {\n-                            if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n+                            if self.subtype(*tp_a, *tp_b).is_ok() {\n                                 continue;\n                             }\n                             match self.unsize_ty(*tp_a, *tp_b) {\n@@ -408,7 +411,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                     let mut new_substs = substs_a.clone();\n                                     new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n                                     let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                                    if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n+                                    if self.subtype(ty, ty_b).is_err() {\n                                         debug!(\"Unsized type parameter '{}', but still \\\n                                                 could not match types {} and {}\",\n                                                ppaux::ty_to_string(tcx, *tp_a),\n@@ -537,11 +540,10 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              -> CombineResult<'tcx, ()> {\n     debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n     let adjustment = try!(indent(|| {\n-        fcx.infcx().commit_if_ok(|| {\n-            let origin = infer::ExprAssignable(expr.span);\n+        fcx.infcx().commit_if_ok(|_| {\n             Coerce {\n                 fcx: fcx,\n-                trace: infer::TypeTrace::types(origin, false, a, b)\n+                origin: infer::ExprAssignable(expr.span),\n             }.coerce(expr, a, b)\n         })\n     }));"}, {"sha": "532277d75b2e06af52afc2002fffe37f62957b58", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -282,7 +282,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n-    let err = infcx.try(|snapshot| {\n+    let err = infcx.commit_if_ok(|snapshot| {\n         let origin = infer::MethodCompatCheck(impl_m_span);\n \n         let (impl_sig, _) ="}, {"sha": "2f7e0073e1751ad0f99ee08fc7714ee5269749ff", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -95,7 +95,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         ty::lookup_item_type(tcx, self_type_did);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    infcx.try(|snapshot| {\n+    infcx.commit_if_ok(|snapshot| {\n         let (named_type_to_skolem, skol_map) =\n             infcx.construct_skolemized_subst(named_type_generics, snapshot);\n         let named_type_skolem = named_type.subst(tcx, &named_type_to_skolem);"}, {"sha": "9171367468026a8f9226b4537b22500f4ff51394", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -1542,7 +1542,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n             debug!(\"projection_bounds: outlives={} (2)\",\n                    outlives.repr(tcx));\n \n-            let region_result = infcx.try(|_| {\n+            let region_result = infcx.commit_if_ok(|_| {\n                 let (outlives, _) =\n                     infcx.replace_late_bound_regions_with_fresh_var(\n                         span,"}, {"sha": "4fba45e2a66c589f61ff74396997e632b30088ae", "filename": "src/test/compile-fail/object-lifetime-default-elision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -81,8 +81,8 @@ fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n     // which fails to type check.\n \n     ss\n-        //~^ ERROR cannot infer\n-        //~| ERROR mismatched types\n+        //~^ ERROR lifetime of the source pointer does not outlive lifetime bound\n+        //~| ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "7fae530984f898e36b8781d30e7eb577fee63bd4", "filename": "src/test/compile-fail/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -25,7 +25,7 @@ fn load(ss: &mut SomeStruct) -> Box<SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR mismatched types\n+    ss.r //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n }\n \n fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n@@ -38,7 +38,7 @@ fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n fn store1<'b>(ss: &mut SomeStruct, b: Box<SomeTrait+'b>) {\n     // Here we override the lifetimes explicitly, and so naturally we get an error.\n \n-    ss.r = b; //~ ERROR mismatched types\n+    ss.r = b; //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n }\n \n fn main() {"}, {"sha": "10b883d4dc830b8568e8eb3391d5ffe0a0f3e0fc", "filename": "src/test/compile-fail/regions-close-over-type-parameter-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -27,7 +27,7 @@ fn make_object_good2<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'b> {\n \n fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'c> {\n     // A outlives 'a AND 'b...but not 'c.\n-    box v as Box<SomeTrait+'a> //~ ERROR mismatched types\n+    box v as Box<SomeTrait+'a> //~ ERROR lifetime of the source pointer does not outlive\n }\n \n fn main() {"}, {"sha": "f3722690ef8959f27e0e158d3e2329cb7f0b01fd", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0edb96d080fadccc542dad50e6576c8e11bd85/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=4b0edb96d080fadccc542dad50e6576c8e11bd85", "patch": "@@ -22,7 +22,7 @@ fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n \n fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n     // Without knowing 'a:'b, we can't coerce\n-    x //~ ERROR mismatched types\n+    x //~ ERROR lifetime of the source pointer does not outlive\n      //~^ ERROR cannot infer\n }\n "}]}