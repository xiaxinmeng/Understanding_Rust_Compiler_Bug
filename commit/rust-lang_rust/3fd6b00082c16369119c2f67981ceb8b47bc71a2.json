{"sha": "3fd6b00082c16369119c2f67981ceb8b47bc71a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZDZiMDAwODJjMTYzNjkxMTljMmY2Nzk4MWNlYjhiNDdiYzcxYTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-20T20:07:47Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:32Z"}, "message": "rustc_trans: query LLVM types from a layout instead of a Ty.", "tree": {"sha": "3e8f5a9d6084c36aea2880e25b59c5a84488dafb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e8f5a9d6084c36aea2880e25b59c5a84488dafb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fd6b00082c16369119c2f67981ceb8b47bc71a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd6b00082c16369119c2f67981ceb8b47bc71a2", "html_url": "https://github.com/rust-lang/rust/commit/3fd6b00082c16369119c2f67981ceb8b47bc71a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fd6b00082c16369119c2f67981ceb8b47bc71a2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1477119344e750d8cd6a5104ec6ea28cec11e574", "url": "https://api.github.com/repos/rust-lang/rust/commits/1477119344e750d8cd6a5104ec6ea28cec11e574", "html_url": "https://github.com/rust-lang/rust/commit/1477119344e750d8cd6a5104ec6ea28cec11e574"}], "stats": {"total": 230, "additions": 114, "deletions": 116}, "files": [{"sha": "bd9a460846b191f6d4a6f9a8b3d6255f5c877337", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -32,6 +32,7 @@ use cabi_nvptx64;\n use cabi_hexagon;\n use mir::lvalue::LvalueRef;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n@@ -506,7 +507,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     /// Get the LLVM type for an lvalue of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n     pub fn memory_ty(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n-        ccx.llvm_type_of(self.layout.ty)\n+        self.layout.llvm_type(ccx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n@@ -934,7 +935,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         } else if let Some(cast) = self.ret.cast {\n             cast.llvm_type(ccx)\n         } else {\n-            ccx.immediate_llvm_type_of(self.ret.layout.ty)\n+            self.ret.layout.immediate_llvm_type(ccx)\n         };\n \n         {\n@@ -952,7 +953,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 } else if let Some(cast) = arg.cast {\n                     cast.llvm_type(ccx)\n                 } else {\n-                    ccx.immediate_llvm_type_of(arg.layout.ty)\n+                    arg.layout.immediate_llvm_type(ccx)\n                 };\n \n                 llargument_tys.push(llarg_ty);"}, {"sha": "1959fd13ccb294d0fcbda5a667cd0cdcd084bceb", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -13,6 +13,7 @@\n use llvm::{self, ValueRef};\n use common::*;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use builder::Builder;\n \n use rustc::hir;\n@@ -44,7 +45,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n         if out.is_indirect {\n             indirect_outputs.push(lvalue.load(bcx).immediate());\n         } else {\n-            output_types.push(bcx.ccx.llvm_type_of(lvalue.layout.ty));\n+            output_types.push(lvalue.layout.llvm_type(bcx.ccx));\n         }\n     }\n     if !indirect_outputs.is_empty() {"}, {"sha": "545e986d7d10f06ea0e1608d9efc1ba8df4382da", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -40,7 +40,7 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{Align, FullLayout};\n+use rustc::ty::layout::{self, Align, FullLayout, LayoutOf};\n use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepKind, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n@@ -68,7 +68,7 @@ use symbol_names_test;\n use time_graph;\n use trans_item::{TransItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n use type_::Type;\n-use type_of;\n+use type_of::{self, LayoutLlvmExt};\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n@@ -228,13 +228,13 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bcx.ccx.shared().type_is_sized(a));\n-            let ptr_ty = bcx.ccx.llvm_type_of(b).ptr_to();\n+            let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n         (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n             assert!(bcx.ccx.shared().type_is_sized(a));\n-            let ptr_ty = bcx.ccx.llvm_type_of(b).ptr_to();\n+            let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n@@ -371,8 +371,8 @@ pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn to_immediate(bcx: &Builder, val: ValueRef, ty: Ty) -> ValueRef {\n-    if ty.is_bool() {\n+pub fn to_immediate(bcx: &Builder, val: ValueRef, layout: layout::FullLayout) -> ValueRef {\n+    if let layout::Abi::Scalar(layout::Int(layout::I1, _)) = layout.abi {\n         bcx.trunc(val, Type::i1(bcx.ccx))\n     } else {\n         val"}, {"sha": "4afeac2e8f5895380d6c20c7ed22e824a242fc28", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -20,8 +20,11 @@ use consts;\n use declare;\n use llvm::{self, ValueRef};\n use monomorphize::Instance;\n+use type_of::LayoutLlvmExt;\n+\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::layout::LayoutOf;\n use rustc::traits;\n use rustc::ty::subst::Substs;\n use rustc_back::PanicStrategy;\n@@ -55,7 +58,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Create a fn pointer with the substituted signature.\n     let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(ccx, fn_ty));\n-    let llptrty = ccx.llvm_type_of(fn_ptr_ty);\n+    let llptrty = ccx.layout_of(fn_ptr_ty).llvm_type(ccx);\n \n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n         // This is subtle and surprising, but sometimes we have to bitcast"}, {"sha": "ed8f65834068b40bbec5410b1a62265c88104b65", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -24,6 +24,7 @@ use builder::Builder;\n use consts;\n use declare;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -254,7 +255,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false),\n-        cx.llvm_type_of(cx.tcx().mk_str()).ptr_to());\n+        cx.layout_of(cx.tcx().mk_str()).llvm_type(cx).ptr_to());\n     let empty = C_array(Type::i8(cx), &[]);\n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);"}, {"sha": "cfca3b57cb9d7a7a875e71af0d7d5fcbfa018f2a", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -21,8 +21,9 @@ use common::{self, CrateContext, val_ty};\n use declare;\n use monomorphize::Instance;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use rustc::ty;\n-use rustc::ty::layout::Align;\n+use rustc::ty::layout::{Align, LayoutOf};\n \n use rustc::hir;\n \n@@ -112,7 +113,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n     let ty = common::instance_ty(ccx.tcx(), &instance);\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n-        let llty = ccx.llvm_type_of(ty);\n+        let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let (g, attrs) = match ccx.tcx().hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n@@ -157,7 +158,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                         }\n                     };\n                     let llty2 = match ty.sty {\n-                        ty::TyRawPtr(ref mt) => ccx.llvm_type_of(mt.ty),\n+                        ty::TyRawPtr(ref mt) => ccx.layout_of(mt.ty).llvm_type(ccx),\n                         _ => {\n                             ccx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n                         }\n@@ -206,7 +207,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let g = declare::declare_global(ccx, &sym, ccx.llvm_type_of(ty));\n+        let g = declare::declare_global(ccx, &sym, ccx.layout_of(ty).llvm_type(ccx));\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n@@ -266,7 +267,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         let instance = Instance::mono(ccx.tcx(), def_id);\n         let ty = common::instance_ty(ccx.tcx(), &instance);\n-        let llty = ccx.llvm_type_of(ty);\n+        let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let g = if val_llty == llty {\n             g\n         } else {"}, {"sha": "555acaad505f080cc2da4ae34e0d4faeda3114aa", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -24,6 +24,8 @@ use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n+\n use rustc_data_structures::base_n;\n use rustc::middle::trans::Stats;\n use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n@@ -397,7 +399,7 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                     let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n                     str_slice_ty.set_struct_body(&[\n                         Type::array(&Type::i8(&dummy_ccx), 0),\n-                        dummy_ccx.llvm_type_of(shared.tcx.mk_str()).ptr_to(),\n+                        dummy_ccx.layout_of(shared.tcx.mk_str()).llvm_type(&dummy_ccx).ptr_to(),\n                         Type::array(&Type::i8(&dummy_ccx), 0),\n                         Type::isize(&dummy_ccx),\n                         Type::array(&Type::i8(&dummy_ccx), 0)"}, {"sha": "45d2f7c69e94e232a65aeec5f4e6eb91cfb2febd", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -21,6 +21,7 @@ use common::*;\n use declare;\n use glue;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n@@ -104,7 +105,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ret_ty = sig.output();\n     let name = &*tcx.item_name(def_id);\n \n-    let llret_ty = ccx.llvm_type_of(ret_ty);\n+    let llret_ty = ccx.layout_of(ret_ty).llvm_type(ccx);\n     let result = LvalueRef::new_sized(llresult, fn_ty.ret.layout, Alignment::AbiAligned);\n \n     let simple = get_simple_intrinsic(ccx, name);\n@@ -243,7 +244,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             unsafe {\n                 llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty).abi() as u32);\n             }\n-            to_immediate(bcx, load, tp_ty)\n+            to_immediate(bcx, load, ccx.layout_of(tp_ty))\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);"}, {"sha": "401d4d5221638ce7b218bfb650f66156cbfe6cdc", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -662,7 +662,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             if arg.layout.ty == bcx.tcx().types.bool {\n                 llval = bcx.load_range_assert(llval, 0, 2, llvm::False, None);\n                 // We store bools as i8 so we need to truncate to i1.\n-                llval = base::to_immediate(bcx, llval, arg.layout.ty);\n+                llval = base::to_immediate(bcx, llval, arg.layout);\n             } else if let Some(ty) = arg.cast {\n                 llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n                                  (align | Alignment::Packed(arg.layout.align(bcx.ccx)))\n@@ -682,45 +682,37 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 args: &[ArgType<'tcx>]) {\n         let tuple = self.trans_operand(bcx, operand);\n \n-        let arg_types = match tuple.layout.ty.sty {\n-            ty::TyTuple(ref tys, _) => tys,\n-            _ => span_bug!(self.mir.span,\n-                           \"bad final argument to \\\"rust-call\\\" fn {:?}\", tuple.layout.ty)\n-        };\n-\n         // Handle both by-ref and immediate tuples.\n         match tuple.val {\n             Ref(llval, align) => {\n                 let tuple_ptr = LvalueRef::new_sized(llval, tuple.layout, align);\n-                for n in 0..arg_types.len() {\n-                    let field_ptr = tuple_ptr.project_field(bcx, n);\n-                    self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[n]);\n+                for i in 0..tuple.layout.fields.count() {\n+                    let field_ptr = tuple_ptr.project_field(bcx, i);\n+                    self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[i]);\n                 }\n \n             }\n             Immediate(llval) => {\n-                for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = bcx.extract_value(llval, tuple.layout.llvm_field_index(n));\n-                    // Truncate bools to i1, if needed\n-                    elem = base::to_immediate(bcx, elem, ty);\n+                for i in 0..tuple.layout.fields.count() {\n+                    let field = tuple.layout.field(bcx.ccx, i);\n+                    let elem = bcx.extract_value(llval, tuple.layout.llvm_field_index(i));\n                     // If the tuple is immediate, the elements are as well\n                     let op = OperandRef {\n-                        val: Immediate(elem),\n-                        layout: bcx.ccx.layout_of(ty),\n+                        val: Immediate(base::to_immediate(bcx, elem, field)),\n+                        layout: field,\n                     };\n-                    self.trans_argument(bcx, op, llargs, &args[n]);\n+                    self.trans_argument(bcx, op, llargs, &args[i]);\n                 }\n             }\n             Pair(a, b) => {\n                 let elems = [a, b];\n-                for (n, &ty) in arg_types.iter().enumerate() {\n-                    let elem = base::to_immediate(bcx, elems[n], ty);\n+                for i in 0..tuple.layout.fields.count() {\n                     // Pair is always made up of immediates\n                     let op = OperandRef {\n-                        val: Immediate(elem),\n-                        layout: bcx.ccx.layout_of(ty),\n+                        val: Immediate(elems[i]),\n+                        layout: tuple.layout.field(bcx.ccx, i),\n                     };\n-                    self.trans_argument(bcx, op, llargs, &args[n]);\n+                    self.trans_argument(bcx, op, llargs, &args[i]);\n                 }\n             }\n         }\n@@ -891,7 +883,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             src: &mir::Operand<'tcx>,\n                             dst: LvalueRef<'tcx>) {\n         let src = self.trans_operand(bcx, src);\n-        let llty = bcx.ccx.llvm_type_of(src.layout.ty);\n+        let llty = src.layout.llvm_type(bcx.ccx);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let align = src.layout.align(bcx.ccx).min(dst.layout.align(bcx.ccx));\n         src.val.store(bcx,"}, {"sha": "9465118568660393f46b3f130f57f9a9d997b304", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> Const<'tcx> {\n                          cv: &ConstVal,\n                          ty: Ty<'tcx>)\n                          -> Const<'tcx> {\n-        let llty = ccx.llvm_type_of(ty);\n+        let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> Const<'tcx> {\n     }\n \n     pub fn to_operand(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n-        let llty = ccx.immediate_llvm_type_of(self.ty);\n+        let llty = ccx.layout_of(self.ty).immediate_llvm_type(ccx);\n         let llvalty = val_ty(self.llval);\n \n         let val = if llty == llvalty && common::type_is_imm_pair(ccx, self.ty) {\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let llelem = if iv < len as u128 {\n                             const_get_elt(base.llval, iv as u64)\n                         } else {\n-                            C_undef(self.ccx.llvm_type_of(projected_ty))\n+                            C_undef(self.ccx.layout_of(projected_ty).llvm_type(self.ccx))\n                         };\n \n                         (Base::Value(llelem), ptr::null_mut())\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let elem_ty = array_ty.builtin_index().unwrap_or_else(|| {\n             bug!(\"bad array type {:?}\", array_ty)\n         });\n-        let llunitty = self.ccx.llvm_type_of(elem_ty);\n+        let llunitty = self.ccx.layout_of(elem_ty).llvm_type(self.ccx);\n         // If the array contains enums, an LLVM array won't work.\n         let val = if fields.iter().all(|&f| val_ty(f) == llunitty) {\n             C_array(llunitty, fields)\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                         let unsized_ty = cast_ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer target type\").ty;\n-                        let ptr_ty = self.ccx.llvm_type_of(unsized_ty).ptr_to();\n+                        let ptr_ty = self.ccx.layout_of(unsized_ty).llvm_type(self.ccx).ptr_to();\n                         let base = consts::ptrcast(base, ptr_ty);\n                         let info = base::unsized_info(self.ccx, pointee_ty,\n                                                       unsized_ty, old_info);\n@@ -681,7 +681,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         debug_assert!(common::type_is_immediate(self.ccx, cast_ty));\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_out = self.ccx.immediate_llvm_type_of(cast_ty);\n+                        let ll_t_out = self.ccx.layout_of(cast_ty).immediate_llvm_type(self.ccx);\n                         let llval = operand.llval;\n                         let signed = match self.ccx.layout_of(operand.ty).abi {\n                             layout::Abi::Scalar(layout::Int(_, signed)) => signed,\n@@ -734,7 +734,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = self.ccx.immediate_llvm_type_of(cast_ty);\n+                                let llcast_ty = self.ccx.layout_of(cast_ty)\n+                                    .immediate_llvm_type(self.ccx);\n                                 consts::ptrcast(data_ptr, llcast_ty)\n                             }\n                         } else {\n@@ -1041,7 +1042,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let result = result.unwrap_or_else(|_| {\n             // We've errored, so we don't have to produce working code.\n-            let llty = bcx.ccx.llvm_type_of(ty);\n+            let llty = bcx.ccx.layout_of(ty).llvm_type(bcx.ccx);\n             Const::new(C_undef(llty), ty)\n         });\n \n@@ -1100,7 +1101,7 @@ fn trans_const_adt<'a, 'tcx>(\n                 _ => 0,\n             };\n             let discr_ty = l.field(ccx, 0).ty;\n-            let discr = C_int(ccx.llvm_type_of(discr_ty), discr as i64);\n+            let discr = C_int(ccx.layout_of(discr_ty).llvm_type(ccx), discr as i64);\n             if let layout::Abi::Scalar(_) = l.abi {\n                 Const::new(discr, t)\n             } else {\n@@ -1130,7 +1131,7 @@ fn trans_const_adt<'a, 'tcx>(\n             } else {\n                 // Always use null even if it's not the `discrfield`th\n                 // field; see #8506.\n-                Const::new(C_null(ccx.llvm_type_of(t)), t)\n+                Const::new(C_null(ccx.layout_of(t).llvm_type(ccx)), t)\n             }\n         }\n         _ => bug!(\"trans_const_adt: cannot handle type {} repreented as {:#?}\", t, l)"}, {"sha": "0732720bd1a14bb1580cc9b9c20e3bf947eeeae8", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                   -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bcx.alloca(\n-            bcx.ccx.llvm_type_of(layout.ty), name, layout.over_align(bcx.ccx));\n+            layout.llvm_type(bcx.ccx), name, layout.over_align(bcx.ccx));\n         Self::new_sized(tmp, layout, Alignment::AbiAligned)\n     }\n \n@@ -189,7 +189,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             } else {\n                 bcx.load(self.llval, self.alignment.non_abi())\n             };\n-            OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout.ty))\n+            OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout))\n         } else {\n             OperandValue::Ref(self.llval, self.alignment)\n         };\n@@ -223,8 +223,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                     bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n                 } else {\n                     assert_eq!(offset, 0);\n-                    let ty = ccx.llvm_type_of(field.ty);\n-                    bcx.pointercast(self.llval, ty.ptr_to())\n+                    bcx.pointercast(self.llval, field.llvm_type(ccx).ptr_to())\n                 },\n                 llextra: if ccx.shared().type_has_metadata(field.ty) {\n                     self.llextra\n@@ -296,7 +295,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n-        let ll_fty = ccx.llvm_type_of(field.ty);\n+        let ll_fty = field.llvm_type(ccx);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n         LvalueRef {\n@@ -309,7 +308,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n     /// Obtain the actual discriminant of a value.\n     pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n-        let cast_to = bcx.ccx.immediate_llvm_type_of(cast_to);\n+        let cast_to = bcx.ccx.layout_of(cast_to).immediate_llvm_type(bcx.ccx);\n         match *self.layout.layout {\n             layout::Layout::Univariant { .. } |\n             layout::Layout::UntaggedUnion { .. } => return C_uint(cast_to, 0),\n@@ -357,7 +356,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             }\n             layout::Layout::NullablePointer { nndiscr, .. } => {\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                let zero = C_null(bcx.ccx.llvm_type_of(discr.layout.ty));\n+                let zero = C_null(discr.layout.llvm_type(bcx.ccx));\n                 bcx.intcast(bcx.icmp(cmp, lldiscr, zero), cast_to, false)\n             }\n             _ => bug!(\"{} is not an enum\", self.layout.ty)\n@@ -373,7 +372,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         match *self.layout.layout {\n             layout::Layout::General { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n-                bcx.store(C_int(bcx.ccx.llvm_type_of(ptr.layout.ty), to as i64),\n+                bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n                     ptr.llval, ptr.alignment.non_abi());\n             }\n             layout::Layout::NullablePointer { nndiscr, .. } => {\n@@ -394,7 +393,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                         base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                     } else {\n                         let ptr = self.project_field(bcx, 0);\n-                        bcx.store(C_null(bcx.ccx.llvm_type_of(ptr.layout.ty)),\n+                        bcx.store(C_null(ptr.layout.llvm_type(bcx.ccx)),\n                             ptr.llval, ptr.alignment.non_abi());\n                     }\n                 }\n@@ -523,7 +522,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // Cast the lvalue pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n                         subslice.llval = bcx.pointercast(subslice.llval,\n-                            bcx.ccx.llvm_type_of(subslice.layout.ty).ptr_to());\n+                            subslice.layout.llvm_type(bcx.ccx).ptr_to());\n \n                         subslice\n                     }"}, {"sha": "2cad096448497bf0f98ef886f06bfd726dc25ad5", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -23,7 +23,7 @@ use common::{self, CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n use abi::{ArgAttribute, FnType};\n-use type_of;\n+use type_of::{self, LayoutLlvmExt};\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -465,7 +465,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     ty::TyAdt(def, _) if def.is_box() => arg.layout.ty.boxed_ty(),\n                     _ => bug!()\n                 };\n-                let data_llty = bcx.ccx.llvm_type_of(pointee);\n+                let data_llty = bcx.ccx.layout_of(pointee).llvm_type(bcx.ccx);\n                 let meta_llty = type_of::unsized_info_ty(bcx.ccx, pointee);\n \n                 a = bcx.pointercast(a, data_llty.ptr_to());"}, {"sha": "d1922f8bf99b0c0dc1020415ae5fcea048d3cec7", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n                    layout: FullLayout<'tcx>) -> OperandRef<'tcx> {\n         assert!(layout.is_zst());\n-        let llty = ccx.llvm_type_of(layout.ty);\n+        let llty = layout.llvm_type(ccx);\n         // FIXME(eddyb) ZSTs should always be immediate, not pairs.\n         // This hack only exists to unpack a constant undef pair.\n         Const::new(C_undef(llty), layout.ty).to_operand(ccx)\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     /// Immediate aggregate with the two values.\n     pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n-            let llty = bcx.ccx.llvm_type_of(self.layout.ty);\n+            let llty = self.layout.llvm_type(bcx.ccx);\n             debug!(\"Operand::pack_if_pair: packing {:?} into {:?}\", self, llty);\n             // Reconstruct the immediate aggregate.\n             let mut llpair = C_undef(llty);\n@@ -142,10 +142,10 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 debug!(\"Operand::unpack_if_pair: unpacking {:?}\", self);\n \n                 let a = bcx.extract_value(llval, self.layout.llvm_field_index(0));\n-                let a = base::to_immediate(bcx, a, self.layout.field(bcx.ccx, 0).ty);\n+                let a = base::to_immediate(bcx, a, self.layout.field(bcx.ccx, 0));\n \n                 let b = bcx.extract_value(llval, self.layout.llvm_field_index(1));\n-                let b = base::to_immediate(bcx, b, self.layout.field(bcx.ccx, 1).ty);\n+                let b = base::to_immediate(bcx, b, self.layout.field(bcx.ccx, 1));\n \n                 self.val = OperandValue::Pair(a, b);\n             }"}, {"sha": "c7cb69339f7f3caafdcb013b981d37f765e577c3", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -26,7 +26,7 @@ use common::{C_bool, C_u8, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_i\n use consts;\n use monomorphize;\n use type_::Type;\n-use type_of;\n+use type_of::{self, LayoutLlvmExt};\n use value::Value;\n \n use super::{MirContext, LocalRef};\n@@ -259,7 +259,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = bcx.ccx.immediate_llvm_type_of(cast.ty);\n+                                let llcast_ty = cast.immediate_llvm_type(bcx.ccx);\n                                 let llval = bcx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n@@ -272,8 +272,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let r_t_in = CastTy::from_ty(operand.layout.ty)\n                             .expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = bcx.ccx.immediate_llvm_type_of(operand.layout.ty);\n-                        let ll_t_out = bcx.ccx.immediate_llvm_type_of(cast.ty);\n+                        let ll_t_in = operand.layout.immediate_llvm_type(bcx.ccx);\n+                        let ll_t_out = cast.immediate_llvm_type(bcx.ccx);\n                         let llval = operand.immediate();\n \n                         if let Layout::General { ref discr_range, .. } = *operand.layout.layout {\n@@ -453,7 +453,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let llsize = C_usize(bcx.ccx, size.bytes());\n                 let llalign = C_usize(bcx.ccx, align.abi());\n                 let box_layout = bcx.ccx.layout_of(bcx.tcx().mk_box(content_ty));\n-                let llty_ptr = bcx.ccx.llvm_type_of(box_layout.ty);\n+                let llty_ptr = box_layout.llvm_type(bcx.ccx);\n \n                 // Allocate space:\n                 let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {"}, {"sha": "991f99e0f6c9963c74ddc68a75aa6468332d3855", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -23,9 +23,11 @@ use common;\n use declare;\n use llvm;\n use monomorphize::Instance;\n+use type_of::LayoutLlvmExt;\n use rustc::hir;\n use rustc::middle::trans::{Linkage, Visibility};\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::layout::LayoutOf;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n@@ -172,7 +174,7 @@ fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let def_id = ccx.tcx().hir.local_def_id(node_id);\n     let instance = Instance::mono(ccx.tcx(), def_id);\n     let ty = common::instance_ty(ccx.tcx(), &instance);\n-    let llty = ccx.llvm_type_of(ty);\n+    let llty = ccx.layout_of(ty).llvm_type(ccx);\n \n     let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n         ccx.sess().span_fatal(ccx.tcx().hir.span(node_id),"}, {"sha": "60c2b5397391abcb0a7fabe53933613ad393b0a5", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6b00082c16369119c2f67981ceb8b47bc71a2/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=3fd6b00082c16369119c2f67981ceb8b47bc71a2", "patch": "@@ -21,10 +21,10 @@ pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     match ty.sty {\n         ty::TyRef(_, ty::TypeAndMut { ty: t, .. }) |\n         ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) if ccx.shared().type_has_metadata(t) => {\n-            ccx.llvm_type_of(t).ptr_to()\n+            ccx.layout_of(t).llvm_type(ccx).ptr_to()\n         }\n         ty::TyAdt(def, _) if def.is_box() => {\n-            ccx.llvm_type_of(ty.boxed_ty()).ptr_to()\n+            ccx.layout_of(ty.boxed_ty()).llvm_type(ccx).ptr_to()\n         }\n         _ => bug!(\"expected fat ptr ty but got {:?}\", ty)\n     }\n@@ -53,7 +53,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // unsized).\n                 cx.str_slice_type()\n             } else {\n-                let ptr_ty = cx.llvm_type_of(ty).ptr_to();\n+                let ptr_ty = cx.layout_of(ty).llvm_type(cx).ptr_to();\n                 let info_ty = unsized_info_ty(cx, ty);\n                 Type::struct_(cx, &[\n                     Type::array(&Type::i8(cx), 0),\n@@ -64,7 +64,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 ], false)\n             }\n         } else {\n-            cx.llvm_type_of(ty).ptr_to()\n+            cx.layout_of(ty).llvm_type(cx).ptr_to()\n         }\n     };\n     match ty.sty {\n@@ -89,13 +89,15 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             layout::Int(i, _) => Type::from_integer(cx, i),\n             layout::F32 => Type::f32(cx),\n             layout::F64 => Type::f64(cx),\n-            layout::Pointer => cx.llvm_type_of(layout::Pointer.to_ty(cx.tcx()))\n+            layout::Pointer => {\n+                cx.layout_of(layout::Pointer.to_ty(cx.tcx())).llvm_type(cx)\n+            }\n         };\n         return llty;\n     }\n \n     if let layout::Abi::Vector { .. } = layout.abi {\n-        return Type::vector(&cx.llvm_type_of(layout.field(cx, 0).ty),\n+        return Type::vector(&layout.field(cx, 0).llvm_type(cx),\n                             layout.fields.count() as u64);\n     }\n \n@@ -125,7 +127,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(&cx.llvm_type_of(layout.field(cx, 0).ty), count)\n+            Type::array(&layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n@@ -161,8 +163,7 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         result.push(Type::array(&Type::i8(cx), padding.bytes()));\n         debug!(\"    padding before: {:?}\", padding);\n \n-        let llty = cx.llvm_type_of(field.ty);\n-        result.push(llty);\n+        result.push(field.llvm_type(cx));\n \n         if layout.is_packed() {\n             assert_eq!(padding.bytes(), 0);\n@@ -206,12 +207,16 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n         let layout = self.layout_of(ty);\n         (layout.size(self), layout.align(self))\n     }\n+}\n \n-    /// Returns alignment if it is different than the primitive alignment.\n-    pub fn over_align_of(&self, ty: Ty<'tcx>) -> Option<Align> {\n-        self.layout_of(ty).over_align(self)\n-    }\n+pub trait LayoutLlvmExt<'tcx> {\n+    fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n+    fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n+    fn over_align(&self, ccx: &CrateContext) -> Option<Align>;\n+    fn llvm_field_index(&self, index: usize) -> u64;\n+}\n \n+impl<'tcx> LayoutLlvmExt<'tcx> for FullLayout<'tcx> {\n     /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n     /// The pointee type of the pointer in `LvalueRef` is always this type.\n     /// For sized types, it is also the right LLVM type for an `alloca`\n@@ -223,56 +228,45 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    pub fn llvm_type_of(&self, ty: Ty<'tcx>) -> Type {\n+    fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n         // Check the cache.\n-        if let Some(&llty) = self.lltypes().borrow().get(&ty) {\n+        if let Some(&llty) = ccx.lltypes().borrow().get(&self.ty) {\n             return llty;\n         }\n \n-        debug!(\"type_of {:?}\", ty);\n+        debug!(\"llvm_type({:#?})\", self);\n \n-        assert!(!ty.has_escaping_regions(), \"{:?} has escaping regions\", ty);\n+        assert!(!self.ty.has_escaping_regions(), \"{:?} has escaping regions\", self.ty);\n \n         // Make sure lifetimes are erased, to avoid generating distinct LLVM\n         // types for Rust types that only differ in the choice of lifetimes.\n-        let normal_ty = self.tcx().erase_regions(&ty);\n-\n-        if ty != normal_ty {\n-            let llty = self.llvm_type_of(normal_ty);\n-            debug!(\"--> normalized {:?} to {:?} llty={:?}\", ty, normal_ty, llty);\n-            self.lltypes().borrow_mut().insert(ty, llty);\n-            return llty;\n-        }\n+        let normal_ty = ccx.tcx().erase_regions(&self.ty);\n \n         let mut defer = None;\n-        let llty = uncached_llvm_type(self, ty, &mut defer);\n-\n-        debug!(\"--> mapped ty={:?} to llty={:?}\", ty, llty);\n+        let llty = if self.ty != normal_ty {\n+            ccx.layout_of(normal_ty).llvm_type(ccx)\n+        } else {\n+            uncached_llvm_type(ccx, self.ty, &mut defer)\n+        };\n+        debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n \n-        self.lltypes().borrow_mut().insert(ty, llty);\n+        ccx.lltypes().borrow_mut().insert(self.ty, llty);\n \n         if let Some((mut llty, layout)) = defer {\n-            llty.set_struct_body(&struct_llfields(self, layout), layout.is_packed())\n+            llty.set_struct_body(&struct_llfields(ccx, layout), layout.is_packed())\n         }\n \n         llty\n     }\n \n-    pub fn immediate_llvm_type_of(&self, ty: Ty<'tcx>) -> Type {\n-        if ty.is_bool() {\n-            Type::i1(self)\n+    fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+        if let layout::Abi::Scalar(layout::Int(layout::I1, _)) = self.abi {\n+            Type::i1(ccx)\n         } else {\n-            self.llvm_type_of(ty)\n+            self.llvm_type(ccx)\n         }\n     }\n-}\n-\n-pub trait LayoutLlvmExt {\n-    fn over_align(&self, ccx: &CrateContext) -> Option<Align>;\n-    fn llvm_field_index(&self, index: usize) -> u64;\n-}\n \n-impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n     fn over_align(&self, ccx: &CrateContext) -> Option<Align> {\n         let align = self.align(ccx);\n         let primitive_align = self.primitive_align(ccx);"}]}