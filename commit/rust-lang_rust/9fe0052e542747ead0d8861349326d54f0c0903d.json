{"sha": "9fe0052e542747ead0d8861349326d54f0c0903d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZTAwNTJlNTQyNzQ3ZWFkMGQ4ODYxMzQ5MzI2ZDU0ZjBjMDkwM2Q=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-07T01:40:36Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-01T16:01:09Z"}, "message": "rustc: remove the closure ID from hir::Upvar's parent field.", "tree": {"sha": "93d4069bcb28864ae6bcbab0f080560bc7c6447d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93d4069bcb28864ae6bcbab0f080560bc7c6447d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fe0052e542747ead0d8861349326d54f0c0903d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe0052e542747ead0d8861349326d54f0c0903d", "html_url": "https://github.com/rust-lang/rust/commit/9fe0052e542747ead0d8861349326d54f0c0903d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fe0052e542747ead0d8861349326d54f0c0903d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9670a2459fe2b3a8d647d3edefe9fa92299a5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9670a2459fe2b3a8d647d3edefe9fa92299a5a", "html_url": "https://github.com/rust-lang/rust/commit/4b9670a2459fe2b3a8d647d3edefe9fa92299a5a"}], "stats": {"total": 128, "additions": 72, "deletions": 56}, "files": [{"sha": "66535079e1ddb30a6864fff903f51735806451a5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9fe0052e542747ead0d8861349326d54f0c0903d", "patch": "@@ -2497,8 +2497,8 @@ pub struct Upvar<Id = HirId> {\n     /// The variable being captured.\n     pub var_id: Id,\n \n-    /// The parent closure, if this is not a direct capture.\n-    pub parent: Option<ast::NodeId>,\n+    /// Whether this is not a direct capture (comes from parent closure).\n+    pub has_parent: bool,\n \n     // First span where it is accessed (there can be multiple).\n     pub span: Span\n@@ -2508,7 +2508,7 @@ impl<Id: fmt::Debug + Copy> Upvar<Id> {\n     pub fn map_id<R>(self, map: impl FnOnce(Id) -> R) -> Upvar<R> {\n         Upvar {\n             var_id: map(self.var_id),\n-            parent: self.parent,\n+            has_parent: self.has_parent,\n             span: self.span,\n         }\n     }"}, {"sha": "034f60875e7bf59ebdbdc9593cecc97ade052f94", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9fe0052e542747ead0d8861349326d54f0c0903d", "patch": "@@ -961,12 +961,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_ty = self.mc.node_ty(upvar.var_id)?;\n-        let res = upvar.parent.map_or(\n-            Res::Local(upvar.var_id),\n-            |closure_node_id| Res::Upvar(upvar.var_id, closure_node_id),\n-        );\n-        self.mc.cat_res(closure_hir_id, closure_span, var_ty, res)\n+        if upvar.has_parent {\n+            let closure_def_id = self.tcx().hir().local_def_id_from_hir_id(closure_hir_id);\n+            let parent_def_id = self.tcx().parent(closure_def_id).unwrap();\n+            assert!(self.tcx().is_closure(parent_def_id));\n+            let var_nid = self.tcx().hir().hir_to_node_id(upvar.var_id);\n+            self.mc.cat_upvar(closure_hir_id, closure_span, var_nid, parent_def_id)\n+        } else {\n+            let var_ty = self.mc.node_ty(upvar.var_id)?;\n+            self.mc.cat_res(closure_hir_id, closure_span, var_ty, Res::Local(upvar.var_id))\n+        }\n     }\n }\n "}, {"sha": "22930cc198946ee2187c72774a38355c6cdd9ba5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9fe0052e542747ead0d8861349326d54f0c0903d", "patch": "@@ -486,7 +486,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         let closure_def_id = ir.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n         if let Some(upvars) = ir.tcx.upvars(closure_def_id) {\n             call_caps.extend(upvars.iter().filter_map(|upvar| {\n-                if upvar.parent.is_none() {\n+                if !upvar.has_parent {\n                     let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n                     Some(CaptureInfo { ln: upvar_ln, var_hid: upvar.var_id })\n                 } else {"}, {"sha": "7ce729bb7154478b57e9ccce85dd5d813ed66524", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9fe0052e542747ead0d8861349326d54f0c0903d", "patch": "@@ -737,9 +737,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 })\n             }\n \n-            Res::Upvar(var_id, fn_node_id) => {\n+            Res::Upvar(var_id, closure_node_id) => {\n                 let var_nid = self.tcx.hir().hir_to_node_id(var_id);\n-                self.cat_upvar(hir_id, span, var_nid, fn_node_id)\n+                let closure_expr_def_id = self.tcx.hir().local_def_id(closure_node_id);\n+                self.cat_upvar(hir_id, span, var_nid, closure_expr_def_id)\n             }\n \n             Res::Local(vid) => {\n@@ -760,15 +761,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     // Categorize an upvar, complete with invisible derefs of closure\n     // environment and upvar reference as appropriate.\n-    fn cat_upvar(&self,\n-                 hir_id: hir::HirId,\n-                 span: Span,\n-                 var_id: ast::NodeId,\n-                 fn_node_id: ast::NodeId)\n-                 -> McResult<cmt_<'tcx>>\n-    {\n-        let fn_hir_id = self.tcx.hir().node_to_hir_id(fn_node_id);\n-\n+    pub fn cat_upvar(\n+        &self,\n+        hir_id: hir::HirId,\n+        span: Span,\n+        var_id: ast::NodeId,\n+        closure_expr_def_id: DefId,\n+    ) -> McResult<cmt_<'tcx>> {\n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n         // field from the environment.\n@@ -792,6 +791,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n+        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(\n+            LocalDefId::from_def_id(closure_expr_def_id),\n+        );\n         let ty = self.node_ty(fn_hir_id)?;\n         let kind = match ty.sty {\n             ty::Generator(..) => ty::ClosureKind::FnOnce,\n@@ -813,7 +815,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n         };\n \n-        let closure_expr_def_id = self.tcx.hir().local_def_id(fn_node_id);\n         let var_hir_id = self.tcx.hir().node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n             var_path: ty::UpvarPath { hir_id: var_hir_id },"}, {"sha": "4d32f1eec44fc370c0cbcc298f5e486057c44c94", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9fe0052e542747ead0d8861349326d54f0c0903d", "patch": "@@ -6,7 +6,7 @@ use crate::hair::util::UserAnnotatedTyHelpers;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::mir::interpret::{GlobalId, ErrorHandled, ConstValue};\n-use rustc::ty::{self, AdtKind, Ty};\n+use rustc::ty::{self, AdtKind, DefIdTree, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability, PointerCast};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::hir;\n@@ -960,38 +960,50 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Res::Def(DefKind::Static, id) => ExprKind::StaticRef { id },\n \n-        Res::Local(..) | Res::Upvar(..) => convert_var(cx, expr, res),\n+        Res::Local(var_hir_id) => convert_var(cx, expr, var_hir_id),\n+        Res::Upvar(var_hir_id, closure_node_id) => {\n+            let closure_def_id = cx.tcx.hir().local_def_id(closure_node_id);\n+            assert_eq!(cx.body_owner, closure_def_id);\n+            assert!(cx.upvar_indices.contains_key(&var_hir_id));\n+\n+            convert_var(cx, expr, var_hir_id)\n+        }\n \n         _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n     }\n }\n \n-fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                               expr: &'tcx hir::Expr,\n-                               res: Res)\n-                               -> ExprKind<'tcx> {\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+fn convert_var(\n+    cx: &mut Cx<'_, '_, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    var_hir_id: hir::HirId,\n+) -> ExprKind<'tcx> {\n+    let upvar_index = cx.upvar_indices.get(&var_hir_id).cloned();\n \n-    match res {\n-        Res::Local(id) => ExprKind::VarRef { id },\n+    debug!(\"convert_var({:?}): upvar_index={:?}, body_owner={:?}\",\n+           var_hir_id, upvar_index, cx.body_owner);\n+\n+    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n-        Res::Upvar(var_hir_id, closure_expr_id) => {\n-            let index = cx.upvar_indices[&var_hir_id];\n+    match upvar_index {\n+        None => ExprKind::VarRef { id: var_hir_id },\n \n-            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n-                   var_hir_id,\n-                   index,\n-                   closure_expr_id);\n+        Some(upvar_index) => {\n+            let closure_def_id = cx.body_owner;\n+            let upvar_id = ty::UpvarId {\n+                var_path: ty::UpvarPath {hir_id: var_hir_id},\n+                closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n+            };\n             let var_ty = cx.tables().node_type(var_hir_id);\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tables()\n-                               .node_type(cx.tcx.hir().node_to_hir_id(closure_expr_id));\n+            let closure_ty = cx.tables().node_type(\n+                cx.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id),\n+            );\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n-            let closure_def_id = cx.tcx.hir().local_def_id(closure_expr_id);\n             let region = ty::ReFree(ty::FreeRegion {\n                 scope: closure_def_id,\n                 bound_region: ty::BoundRegion::BrAnon(0),\n@@ -1062,15 +1074,11 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // at this point we have `self.n`, which loads up the upvar\n             let field_kind = ExprKind::Field {\n                 lhs: self_expr.to_ref(),\n-                name: Field::new(index),\n+                name: Field::new(upvar_index),\n             };\n \n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n-            let upvar_id = ty::UpvarId {\n-                var_path: ty::UpvarPath {hir_id: var_hir_id},\n-                closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n-            };\n             match cx.tables().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => {\n@@ -1089,8 +1097,6 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 }\n             }\n         }\n-\n-        _ => span_bug!(expr.span, \"type of & not region\"),\n     }\n }\n \n@@ -1190,15 +1196,16 @@ fn capture_upvar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n     let var_ty = cx.tables().node_type(upvar.var_id);\n-    let upvar_res = upvar.parent.map_or(\n-        Res::Local(upvar.var_id),\n-        |closure_node_id| Res::Upvar(upvar.var_id, closure_node_id),\n-    );\n+    if upvar.has_parent {\n+        let closure_def_id = upvar_id.closure_expr_id.to_def_id();\n+        assert_eq!(cx.body_owner, cx.tcx.parent(closure_def_id).unwrap());\n+    }\n+    assert_eq!(upvar.has_parent, cx.upvar_indices.contains_key(&upvar.var_id));\n     let captured_var = Expr {\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n-        kind: convert_var(cx, closure_expr, upvar_res),\n+        kind: convert_var(cx, closure_expr, upvar.var_id),\n     };\n     match upvar_capture {\n         ty::UpvarCapture::ByValue => captured_var.to_ref(),"}, {"sha": "251bc24bbd2399e6140522aab302b4f0926c1ed0", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9fe0052e542747ead0d8861349326d54f0c0903d", "patch": "@@ -39,6 +39,9 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// `const`, or the body of a `const fn`.\n     constness: hir::Constness,\n \n+    /// The `DefId` of the owner of this body.\n+    body_owner: DefId,\n+\n     /// What kind of body is being compiled.\n     pub body_owner_kind: hir::BodyOwnerKind,\n \n@@ -97,6 +100,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n             tables,\n             constness,\n+            body_owner: src_def_id,\n             body_owner_kind,\n             check_overflow,\n             control_flow_destroyed: Vec::new(),"}, {"sha": "790c435663087775c5e433e8ae4ad513982d9979", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe0052e542747ead0d8861349326d54f0c0903d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9fe0052e542747ead0d8861349326d54f0c0903d", "patch": "@@ -4051,9 +4051,9 @@ impl<'a> Resolver<'a> {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n-                            let parent = match res {\n-                                Res::Upvar(_, closure) => Some(closure),\n-                                _ => None,\n+                            let has_parent = match res {\n+                                Res::Upvar(..) => true,\n+                                _ => false,\n                             };\n \n                             let seen = self.upvars_seen\n@@ -4071,7 +4071,7 @@ impl<'a> Resolver<'a> {\n                             if record_used {\n                                 vec.push(Upvar {\n                                     var_id,\n-                                    parent,\n+                                    has_parent,\n                                     span,\n                                 });\n                                 seen.insert(var_id);"}]}