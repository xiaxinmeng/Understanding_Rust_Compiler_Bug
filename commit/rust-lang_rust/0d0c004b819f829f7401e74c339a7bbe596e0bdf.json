{"sha": "0d0c004b819f829f7401e74c339a7bbe596e0bdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMGMwMDRiODE5ZjgyOWY3NDAxZTc0YzMzOWE3YmJlNTk2ZTBiZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-07T13:58:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-07T13:58:33Z"}, "message": "auto merge of #6988 : huonw/rust/deriving-changes, r=bstrie\n\nSeveral minor changes:\r\n - The clean-up I mentioned in #6851 (moving functions from deriving/mod.rs to deriving/generic.rs)\r\n - Move `expand_generic_deriving` to a method\r\n - Reimplement `deriving(Ord)` with no dependence on `Eq`", "tree": {"sha": "fa25758c8f342f78ac66e08be5f6560acd1f78ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa25758c8f342f78ac66e08be5f6560acd1f78ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d0c004b819f829f7401e74c339a7bbe596e0bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d0c004b819f829f7401e74c339a7bbe596e0bdf", "html_url": "https://github.com/rust-lang/rust/commit/0d0c004b819f829f7401e74c339a7bbe596e0bdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d0c004b819f829f7401e74c339a7bbe596e0bdf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af863cf2a4b8d14483d5ba34d29d1040ae740891", "url": "https://api.github.com/repos/rust-lang/rust/commits/af863cf2a4b8d14483d5ba34d29d1040ae740891", "html_url": "https://github.com/rust-lang/rust/commit/af863cf2a4b8d14483d5ba34d29d1040ae740891"}, {"sha": "a965f4981a2adedb6ba10cf210cea6b7887e8267", "url": "https://api.github.com/repos/rust-lang/rust/commits/a965f4981a2adedb6ba10cf210cea6b7887e8267", "html_url": "https://github.com/rust-lang/rust/commit/a965f4981a2adedb6ba10cf210cea6b7887e8267"}], "stats": {"total": 619, "additions": 254, "deletions": 365}, "files": [{"sha": "4fc67f2f52e785bc5318db9e98777279591d9799", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -38,9 +38,7 @@ pub fn expand_deriving_clone(cx: @ExtCtxt,\n         ]\n     };\n \n-    expand_deriving_generic(cx, span,\n-                            mitem, in_items,\n-                            &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n@@ -67,9 +65,7 @@ pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n         ]\n     };\n \n-    expand_deriving_generic(cx, span,\n-                            mitem, in_items,\n-                            &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n fn cs_clone("}, {"sha": "5fc75511e57b4c50635a78fd8ee58bbcfe97a141", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -54,7 +54,5 @@ pub fn expand_deriving_eq(cx: @ExtCtxt,\n             md!(\"ne\", cs_ne)\n         ]\n     };\n-\n-    expand_deriving_generic(cx, span, mitem, in_items,\n-                            &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }"}, {"sha": "c60b589dfc3882eb9c1576824983cae8ba0d6b12", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 41, "deletions": 58, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use ast;\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n@@ -21,104 +22,86 @@ pub fn expand_deriving_ord(cx: @ExtCtxt,\n                            mitem: @meta_item,\n                            in_items: ~[@item]) -> ~[@item] {\n     macro_rules! md (\n-        ($name:expr, $less:expr, $equal:expr) => {\n+        ($name:expr, $op:expr, $equal:expr) => {\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[\"bool\"])),\n                 const_nonmatching: false,\n-                combine_substructure: |cx, span, substr|\n-                    cs_ord($less, $equal, cx, span, substr)\n+                combine_substructure: |cx, span, substr| cs_op($op, $equal, cx, span, substr)\n             }\n         }\n     );\n \n-\n-\n     let trait_def = TraitDef {\n         path: Path::new(~[\"std\", \"cmp\", \"Ord\"]),\n-        // XXX: Ord doesn't imply Eq yet\n-        additional_bounds: ~[Literal(Path::new(~[\"std\", \"cmp\", \"Eq\"]))],\n+        additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n-            md!(\"lt\", true,  false),\n-            md!(\"le\", true,  true),\n+            md!(\"lt\", true, false),\n+            md!(\"le\", true, true),\n             md!(\"gt\", false, false),\n             md!(\"ge\", false, true)\n         ]\n     };\n-\n-    expand_deriving_generic(cx, span, mitem, in_items,\n-                            &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n-/// `less`: is this `lt` or `le`? `equal`: is this `le` or `ge`?\n-fn cs_ord(less: bool, equal: bool,\n-          cx: @ExtCtxt, span: span,\n-          substr: &Substructure) -> @expr {\n-    let binop = if less {\n-        cx.ident_of(\"lt\")\n-    } else {\n-        cx.ident_of(\"gt\")\n-    };\n-    let base = cx.expr_bool(span, equal);\n-\n+/// Strict inequality.\n+fn cs_op(less: bool, equal: bool, cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    let op = if less {ast::lt} else {ast::gt};\n     cs_fold(\n         false, // need foldr,\n         |cx, span, subexpr, self_f, other_fs| {\n             /*\n-\n-            build up a series of nested ifs from the inside out to get\n-            lexical ordering (hence foldr), i.e.\n+            build up a series of chain ||'s and &&'s from the inside\n+            out (hence foldr) to get lexical ordering, i.e. for op ==\n+            `ast::lt`\n \n             ```\n-            if self.f1 `binop` other.f1 {\n-                true\n-            } else if self.f1 == other.f1 {\n-                if self.f2 `binop` other.f2 {\n-                    true\n-                } else if self.f2 == other.f2 {\n-                    `equal`\n-                } else {\n-                    false\n-                }\n-            } else {\n-                false\n-            }\n+            self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n+                (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n+                    (false)\n+                ))\n+            )\n             ```\n \n-            The inner \"`equal`\" case is only reached if the two\n-            items have all fields equal.\n+            The optimiser should remove the redundancy. We explicitly\n+            get use the binops to avoid auto-deref derefencing too many\n+            layers of pointers, if the type includes pointers.\n             */\n-            if other_fs.len() != 1 {\n-                cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\");\n-            }\n+            let other_f = match other_fs {\n+                [o_f] => o_f,\n+                _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\")\n+            };\n+\n+            let cmp = cx.expr_binary(span, op,\n+                                     cx.expr_deref(span, self_f),\n+                                     cx.expr_deref(span, other_f));\n \n-            let cmp = cx.expr_method_call(span,\n-                                          self_f, cx.ident_of(\"eq\"), other_fs.to_owned());\n-            let elseif = cx.expr_if(span, cmp,\n-                                    subexpr, Some(cx.expr_bool(span, false)));\n+            let not_cmp = cx.expr_unary(span, ast::not,\n+                                        cx.expr_binary(span, op,\n+                                                       cx.expr_deref(span, other_f),\n+                                                       cx.expr_deref(span, self_f)));\n \n-            let cmp = cx.expr_method_call(span,\n-                                          self_f, binop, other_fs.to_owned());\n-            cx.expr_if(span, cmp,\n-                        cx.expr_bool(span, true), Some(elseif))\n+            let and = cx.expr_binary(span, ast::and, not_cmp, subexpr);\n+            cx.expr_binary(span, ast::or, cmp, and)\n         },\n-        base,\n+        cx.expr_bool(span, equal),\n         |cx, span, args, _| {\n             // nonmatching enums, order by the order the variants are\n             // written\n             match args {\n                 [(self_var, _, _),\n                  (other_var, _, _)] =>\n                     cx.expr_bool(span,\n-                                   if less {\n-                                       self_var < other_var\n-                                   } else {\n-                                       self_var > other_var\n-                                   }),\n+                                 if less {\n+                                     self_var < other_var\n+                                 } else {\n+                                     self_var > other_var\n+                                 }),\n                 _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\")\n             }\n         },"}, {"sha": "acd2073b2734b5c138b4611839c3735163259d27", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -42,7 +42,5 @@ pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n             }\n         ]\n     };\n-\n-    expand_deriving_generic(cx, span, mitem, in_items,\n-                            &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }"}, {"sha": "94407cd6e7294e55b534267b43bcc5a655d0d59a", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -38,8 +38,7 @@ pub fn expand_deriving_totalord(cx: @ExtCtxt,\n         ]\n     };\n \n-    expand_deriving_generic(cx, span, mitem, in_items,\n-                            &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n "}, {"sha": "2081f262825cedb5ece1eb6d47e4475654d231ae", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -49,8 +49,7 @@ pub fn expand_deriving_decodable(cx: @ExtCtxt,\n         ]\n     };\n \n-    expand_deriving_generic(cx, span, mitem, in_items,\n-                            &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n fn decodable_substructure(cx: @ExtCtxt, span: span,"}, {"sha": "2d24de553d6c3ffa06bb4b9239dc01fb25d4da11", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -109,8 +109,7 @@ pub fn expand_deriving_encodable(cx: @ExtCtxt,\n         ]\n     };\n \n-    expand_deriving_generic(cx, span, mitem, in_items,\n-                            &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n fn encodable_substructure(cx: @ExtCtxt, span: span,"}, {"sha": "52a2d9ff9de4a1600b90a4a05cd5a25a17125dfd", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 202, "deletions": 30, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -169,7 +169,6 @@ use ast::{enum_def, expr, ident, Generics, struct_def};\n \n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use ext::deriving::*;\n use codemap::{span,respan};\n use opt_vec;\n \n@@ -179,25 +178,6 @@ use core::vec;\n pub use self::ty::*;\n mod ty;\n \n-pub fn expand_deriving_generic(cx: @ExtCtxt,\n-                               span: span,\n-                               _mitem: @ast::meta_item,\n-                               in_items: ~[@ast::item],\n-                               trait_def: &TraitDef) -> ~[@ast::item] {\n-    let expand_enum: ExpandDerivingEnumDefFn =\n-        |cx, span, enum_def, type_ident, generics| {\n-        trait_def.expand_enum_def(cx, span, enum_def, type_ident, generics)\n-    };\n-    let expand_struct: ExpandDerivingStructDefFn =\n-        |cx, span, struct_def, type_ident, generics| {\n-        trait_def.expand_struct_def(cx, span, struct_def, type_ident, generics)\n-    };\n-\n-    expand_deriving(cx, span, in_items,\n-                    expand_struct,\n-                    expand_enum)\n-}\n-\n pub struct TraitDef<'self> {\n     /// Path of the trait, including any type parameters\n     path: Path<'self>,\n@@ -301,23 +281,97 @@ pub type EnumNonMatchFunc<'self> =\n \n \n impl<'self> TraitDef<'self> {\n+    pub fn expand(&self, cx: @ExtCtxt,\n+                  span: span,\n+                  _mitem: @ast::meta_item,\n+                  in_items: ~[@ast::item]) -> ~[@ast::item] {\n+        let mut result = ~[];\n+        for in_items.each |item| {\n+            result.push(*item);\n+            match item.node {\n+                ast::item_struct(struct_def, ref generics) => {\n+                    result.push(self.expand_struct_def(cx, span,\n+                                                       struct_def,\n+                                                       item.ident,\n+                                                       generics));\n+                }\n+                ast::item_enum(ref enum_def, ref generics) => {\n+                    result.push(self.expand_enum_def(cx, span,\n+                                                     enum_def,\n+                                                     item.ident,\n+                                                     generics));\n+                }\n+                _ => ()\n+            }\n+        }\n+        result\n+    }\n+\n+    /**\n+     *\n+     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n+     * 'z, A, ..., Z>`, creates an impl like:\n+     *\n+     *      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n+     *\n+     * where B1, B2, ... are the bounds given by `bounds_paths`.'\n+     *\n+     */\n     fn create_derived_impl(&self, cx: @ExtCtxt, span: span,\n                            type_ident: ident, generics: &Generics,\n                            methods: ~[@ast::method]) -> @ast::item {\n         let trait_path = self.path.to_path(cx, span, type_ident, generics);\n \n-        let trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n+        let mut trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n+        // Copy the lifetimes\n+        for generics.lifetimes.each |l| {\n+            trait_generics.lifetimes.push(copy *l)\n+        };\n+        // Create the type parameters.\n+        for generics.ty_params.each |ty_param| {\n+            // I don't think this can be moved out of the loop, since\n+            // a TyParamBound requires an ast id\n+            let mut bounds = opt_vec::from(\n+                // extra restrictions on the generics parameters to the type being derived upon\n+                do self.additional_bounds.map |p| {\n+                    cx.typarambound(p.to_path(cx, span, type_ident, generics))\n+                });\n+            // require the current trait\n+            bounds.push(cx.typarambound(trait_path));\n+\n+            trait_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n+        }\n \n-        let additional_bounds = opt_vec::from(\n-            do self.additional_bounds.map |p| {\n-                p.to_path(cx, span, type_ident, generics)\n-            });\n+        // Create the reference to the trait.\n+        let trait_ref = cx.trait_ref(trait_path);\n+\n+        // Create the type parameters on the `self` path.\n+        let self_ty_params = do generics.ty_params.map |ty_param| {\n+            cx.ty_ident(span, ty_param.ident)\n+        };\n \n-        create_derived_impl(cx, span,\n-                            type_ident, generics,\n-                            methods, trait_path,\n-                            trait_generics,\n-                            additional_bounds)\n+        let self_lifetime = if generics.lifetimes.is_empty() {\n+            None\n+        } else {\n+            Some(@*generics.lifetimes.get(0))\n+        };\n+\n+        // Create the type of `self`.\n+        let self_type = cx.ty_path(cx.path_all(span, false, ~[ type_ident ], self_lifetime,\n+                                               opt_vec::take_vec(self_ty_params)));\n+\n+        let doc_attr = cx.attribute(\n+            span,\n+            cx.meta_name_value(span,\n+                               ~\"doc\", ast::lit_str(@~\"Automatically derived.\")));\n+        cx.item(\n+            span,\n+            ::parse::token::special_idents::clownshoes_extensions,\n+            ~[doc_attr],\n+            ast::item_impl(trait_generics,\n+                           Some(trait_ref),\n+                           self_type,\n+                           methods.map(|x| *x)))\n     }\n \n     fn expand_struct_def(&self, cx: @ExtCtxt,\n@@ -834,6 +888,124 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n     }\n }\n \n+pub fn create_subpatterns(cx: @ExtCtxt,\n+                          span: span,\n+                          field_paths: ~[@ast::Path],\n+                          mutbl: ast::mutability)\n+                   -> ~[@ast::pat] {\n+    do field_paths.map |&path| {\n+        cx.pat(span, ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n+    }\n+}\n+\n+#[deriving(Eq)] // dogfooding!\n+enum StructType {\n+    Unknown, Record, Tuple\n+}\n+\n+fn create_struct_pattern(cx: @ExtCtxt,\n+                             span: span,\n+                             struct_ident: ident,\n+                             struct_def: &struct_def,\n+                             prefix: &str,\n+                             mutbl: ast::mutability)\n+    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n+    if struct_def.fields.is_empty() {\n+        return (\n+            cx.pat_ident_binding_mode(\n+                span, struct_ident, ast::bind_infer),\n+            ~[]);\n+    }\n+\n+    let matching_path = cx.path(span, ~[ struct_ident ]);\n+\n+    let mut paths = ~[];\n+    let mut ident_expr = ~[];\n+    let mut struct_type = Unknown;\n+\n+    for struct_def.fields.eachi |i, struct_field| {\n+        let opt_id = match struct_field.node.kind {\n+            ast::named_field(ident, _) if (struct_type == Unknown ||\n+                                           struct_type == Record) => {\n+                struct_type = Record;\n+                Some(ident)\n+            }\n+            ast::unnamed_field if (struct_type == Unknown ||\n+                                   struct_type == Tuple) => {\n+                struct_type = Tuple;\n+                None\n+            }\n+            _ => {\n+                cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n+            }\n+        };\n+        let path = cx.path_ident(span,\n+                                 cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n+        paths.push(path);\n+        ident_expr.push((opt_id, cx.expr_path(path)));\n+    }\n+\n+    let subpats = create_subpatterns(cx, span, paths, mutbl);\n+\n+    // struct_type is definitely not Unknown, since struct_def.fields\n+    // must be nonempty to reach here\n+    let pattern = if struct_type == Record {\n+        let field_pats = do vec::build |push| {\n+            for vec::each2(subpats, ident_expr) |&pat, &(id, _)| {\n+                // id is guaranteed to be Some\n+                push(ast::field_pat { ident: id.get(), pat: pat })\n+            }\n+        };\n+        cx.pat_struct(span, matching_path, field_pats)\n+    } else {\n+        cx.pat_enum(span, matching_path, subpats)\n+    };\n+\n+    (pattern, ident_expr)\n+}\n+\n+fn create_enum_variant_pattern(cx: @ExtCtxt,\n+                                   span: span,\n+                                   variant: &ast::variant,\n+                                   prefix: &str,\n+                                   mutbl: ast::mutability)\n+    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n+\n+    let variant_ident = variant.node.name;\n+    match variant.node.kind {\n+        ast::tuple_variant_kind(ref variant_args) => {\n+            if variant_args.is_empty() {\n+                return (cx.pat_ident_binding_mode(\n+                    span, variant_ident, ast::bind_infer), ~[]);\n+            }\n+\n+            let matching_path = cx.path_ident(span, variant_ident);\n+\n+            let mut paths = ~[];\n+            let mut ident_expr = ~[];\n+            for uint::range(0, variant_args.len()) |i| {\n+                let path = cx.path_ident(span,\n+                                         cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n+\n+                paths.push(path);\n+                ident_expr.push((None, cx.expr_path(path)));\n+            }\n+\n+            let subpats = create_subpatterns(cx, span, paths, mutbl);\n+\n+            (cx.pat_enum(span, matching_path, subpats),\n+             ident_expr)\n+        }\n+        ast::struct_variant_kind(struct_def) => {\n+            create_struct_pattern(cx, span,\n+                                  variant_ident, struct_def,\n+                                  prefix,\n+                                  mutbl)\n+        }\n+    }\n+}\n+\n+\n \n /* helpful premade recipes */\n "}, {"sha": "13f83b55a4047ce2b176cb42e49a257567f64bcc", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -42,7 +42,7 @@ pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n         ]\n     };\n \n-    expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {"}, {"sha": "1107f21319cb844b9fb54d96414b6f6e4b194c8c", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 254, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -20,16 +20,10 @@ library.\n \n use core::prelude::*;\n \n-use ast;\n-use ast::{Ty, enum_def, expr, ident, item, Generics, meta_item, struct_def};\n+use ast::{enum_def, ident, item, Generics, meta_item, struct_def};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::span;\n-use parse::token::special_idents::clownshoes_extensions;\n-use opt_vec;\n-\n-use core::uint;\n-use core::vec;\n \n pub mod clone;\n pub mod iter_bytes;\n@@ -117,250 +111,3 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n         }\n     }\n }\n-\n-pub fn expand_deriving(cx: @ExtCtxt,\n-                   span: span,\n-                   in_items: ~[@item],\n-                   expand_deriving_struct_def: ExpandDerivingStructDefFn,\n-                   expand_deriving_enum_def: ExpandDerivingEnumDefFn)\n-                -> ~[@item] {\n-    let mut result = ~[];\n-    for in_items.each |item| {\n-        result.push(copy *item);\n-        match item.node {\n-            ast::item_struct(struct_def, ref generics) => {\n-                result.push(expand_deriving_struct_def(cx,\n-                                                       span,\n-                                                       struct_def,\n-                                                       item.ident,\n-                                                       generics));\n-            }\n-            ast::item_enum(ref enum_definition, ref generics) => {\n-                result.push(expand_deriving_enum_def(cx,\n-                                                     span,\n-                                                     enum_definition,\n-                                                     item.ident,\n-                                                     generics));\n-            }\n-            _ => ()\n-        }\n-    }\n-    result\n-}\n-\n-pub fn create_self_type_with_params(cx: @ExtCtxt,\n-                                    span: span,\n-                                    type_ident: ident,\n-                                    generics: &Generics)\n-    -> @Ty {\n-    // Create the type parameters on the `self` path.\n-    let mut self_ty_params = ~[];\n-    for generics.ty_params.each |ty_param| {\n-        let self_ty_param = cx.ty_ident(span, ty_param.ident);\n-        self_ty_params.push(self_ty_param);\n-    }\n-\n-    let lifetime = if generics.lifetimes.is_empty() {\n-        None\n-    } else {\n-        Some(@*generics.lifetimes.get(0))\n-    };\n-\n-\n-    // Create the type of `self`.\n-    cx.ty_path(cx.path_all(span, false, ~[ type_ident ], lifetime, self_ty_params))\n-}\n-\n-pub fn create_derived_impl(cx: @ExtCtxt,\n-                           span: span,\n-                           type_ident: ident,\n-                           generics: &Generics,\n-                           methods: &[@ast::method],\n-                           trait_path: @ast::Path,\n-                           mut impl_generics:  Generics,\n-                           bounds_paths: opt_vec::OptVec<@ast::Path>)\n-                        -> @item {\n-    /*!\n-     *\n-     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n-     * 'z, A, ..., Z>`, creates an impl like:\n-     *\n-     *      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n-     *\n-     * where B1, B2, ... are the bounds given by `bounds_paths`.\n-     *\n-     */\n-\n-    // Copy the lifetimes\n-    for generics.lifetimes.each |l| {\n-        impl_generics.lifetimes.push(copy *l)\n-    };\n-\n-    // Create the type parameters.\n-    for generics.ty_params.each |ty_param| {\n-        // extra restrictions on the generics parameters to the type being derived upon\n-        let mut bounds = do bounds_paths.map |&bound_path| {\n-            cx.typarambound(bound_path)\n-        };\n-\n-        let this_trait_bound = cx.typarambound(trait_path);\n-        bounds.push(this_trait_bound);\n-\n-        impl_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n-    }\n-\n-    // Create the reference to the trait.\n-    let trait_ref = cx.trait_ref(trait_path);\n-\n-    // Create the type of `self`.\n-    let self_type = create_self_type_with_params(cx,\n-                                                 span,\n-                                                 type_ident,\n-                                                 generics);\n-\n-    let doc_attr = cx.attribute(\n-        span,\n-        cx.meta_name_value(span,\n-                           ~\"doc\", ast::lit_str(@~\"Automatically derived.\")));\n-    cx.item(\n-        span,\n-        clownshoes_extensions,\n-        ~[doc_attr],\n-        ast::item_impl(impl_generics,\n-                       Some(trait_ref),\n-                       self_type,\n-                       methods.map(|x| *x)))\n-}\n-\n-pub fn create_subpatterns(cx: @ExtCtxt,\n-                          span: span,\n-                          field_paths: ~[@ast::Path],\n-                          mutbl: ast::mutability)\n-                   -> ~[@ast::pat] {\n-    do field_paths.map |&path| {\n-        cx.pat(span,\n-                      ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n-    }\n-}\n-\n-#[deriving(Eq)] // dogfooding!\n-enum StructType {\n-    Unknown, Record, Tuple\n-}\n-\n-pub fn create_struct_pattern(cx: @ExtCtxt,\n-                             span: span,\n-                             struct_ident: ident,\n-                             struct_def: &struct_def,\n-                             prefix: &str,\n-                             mutbl: ast::mutability)\n-    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n-    if struct_def.fields.is_empty() {\n-        return (\n-            cx.pat_ident_binding_mode(\n-                span, struct_ident, ast::bind_infer),\n-            ~[]);\n-    }\n-\n-    let matching_path = cx.path(span, ~[ struct_ident ]);\n-\n-    let mut paths = ~[];\n-    let mut ident_expr = ~[];\n-    let mut struct_type = Unknown;\n-\n-    for struct_def.fields.eachi |i, struct_field| {\n-        let opt_id = match struct_field.node.kind {\n-            ast::named_field(ident, _) if (struct_type == Unknown ||\n-                                           struct_type == Record) => {\n-                struct_type = Record;\n-                Some(ident)\n-            }\n-            ast::unnamed_field if (struct_type == Unknown ||\n-                                   struct_type == Tuple) => {\n-                struct_type = Tuple;\n-                None\n-            }\n-            _ => {\n-                cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n-            }\n-        };\n-        let path = cx.path_ident(span,\n-                                 cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n-        paths.push(path);\n-        ident_expr.push((opt_id, cx.expr_path(path)));\n-    }\n-\n-    let subpats = create_subpatterns(cx, span, paths, mutbl);\n-\n-    // struct_type is definitely not Unknown, since struct_def.fields\n-    // must be nonempty to reach here\n-    let pattern = if struct_type == Record {\n-        let field_pats = do vec::build |push| {\n-            for vec::each2(subpats, ident_expr) |&pat, &(id, _)| {\n-                // id is guaranteed to be Some\n-                push(ast::field_pat { ident: id.get(), pat: pat })\n-            }\n-        };\n-        cx.pat_struct(span, matching_path, field_pats)\n-    } else {\n-        cx.pat_enum(span, matching_path, subpats)\n-    };\n-\n-    (pattern, ident_expr)\n-}\n-\n-pub fn create_enum_variant_pattern(cx: @ExtCtxt,\n-                                   span: span,\n-                                   variant: &ast::variant,\n-                                   prefix: &str,\n-                                   mutbl: ast::mutability)\n-    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n-\n-    let variant_ident = variant.node.name;\n-    match variant.node.kind {\n-        ast::tuple_variant_kind(ref variant_args) => {\n-            if variant_args.is_empty() {\n-                return (cx.pat_ident_binding_mode(\n-                    span, variant_ident, ast::bind_infer), ~[]);\n-            }\n-\n-            let matching_path = cx.path_ident(span, variant_ident);\n-\n-            let mut paths = ~[];\n-            let mut ident_expr = ~[];\n-            for uint::range(0, variant_args.len()) |i| {\n-                let path = cx.path_ident(span,\n-                                         cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n-\n-                paths.push(path);\n-                ident_expr.push((None, cx.expr_path(path)));\n-            }\n-\n-            let subpats = create_subpatterns(cx, span, paths, mutbl);\n-\n-            (cx.pat_enum(span, matching_path, subpats),\n-             ident_expr)\n-        }\n-        ast::struct_variant_kind(struct_def) => {\n-            create_struct_pattern(cx, span,\n-                                  variant_ident, struct_def,\n-                                  prefix,\n-                                  mutbl)\n-        }\n-    }\n-}\n-\n-pub fn variant_arg_count(_cx: @ExtCtxt, _span: span, variant: &ast::variant) -> uint {\n-    match variant.node.kind {\n-        ast::tuple_variant_kind(ref args) => args.len(),\n-        ast::struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n-    }\n-}\n-\n-pub fn expand_enum_or_struct_match(cx: @ExtCtxt,\n-                               span: span,\n-                               arms: ~[ ast::arm ])\n-                            -> @expr {\n-    let self_expr = cx.expr_deref(span, cx.expr_self(span));\n-    cx.expr_match(span, self_expr, arms)\n-}"}, {"sha": "ab5ac6d78479386718924d76869c17ce40b94cb7", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -47,8 +47,7 @@ pub fn expand_deriving_rand(cx: @ExtCtxt,\n             }\n         ]\n     };\n-\n-    expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {"}, {"sha": "41be3a775c1644803f03c1e7bee95000deb468e8", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0c004b819f829f7401e74c339a7bbe596e0bdf/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=0d0c004b819f829f7401e74c339a7bbe596e0bdf", "patch": "@@ -37,8 +37,7 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n             }\n         ]\n     };\n-\n-    expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n+    trait_def.expand(cx, span, mitem, in_items)\n }\n \n fn to_str_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {"}]}