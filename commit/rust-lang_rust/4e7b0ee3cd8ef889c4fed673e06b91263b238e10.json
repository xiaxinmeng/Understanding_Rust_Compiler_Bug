{"sha": "4e7b0ee3cd8ef889c4fed673e06b91263b238e10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlN2IwZWUzY2Q4ZWY4ODljNGZlZDY3M2UwNmI5MTI2M2IyMzhlMTA=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-07-30T04:07:51Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-02T22:49:00Z"}, "message": "Crypto: Add overflow checking addition functions.\n\nAdded functions to cryptoutil.rs that perform an addition after shifting\nthe 2nd parameter by a specified constant. These function fail!() if integer\noverflow will result. Updated the Sha2 implementation to use these functions.", "tree": {"sha": "c2da11986079d474b418f08449d2e46b309c2914", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2da11986079d474b418f08449d2e46b309c2914"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e7b0ee3cd8ef889c4fed673e06b91263b238e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e7b0ee3cd8ef889c4fed673e06b91263b238e10", "html_url": "https://github.com/rust-lang/rust/commit/4e7b0ee3cd8ef889c4fed673e06b91263b238e10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e7b0ee3cd8ef889c4fed673e06b91263b238e10/comments", "author": null, "committer": null, "parents": [{"sha": "281b79525b31affc7cdf5540e27c629a460cadab", "url": "https://api.github.com/repos/rust-lang/rust/commits/281b79525b31affc7cdf5540e27c629a460cadab", "html_url": "https://github.com/rust-lang/rust/commit/281b79525b31affc7cdf5540e27c629a460cadab"}], "stats": {"total": 126, "additions": 71, "deletions": 55}, "files": [{"sha": "43e3b5c89af484a84f32d08572fcfa830fa5e635", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4e7b0ee3cd8ef889c4fed673e06b91263b238e10/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e7b0ee3cd8ef889c4fed673e06b91263b238e10/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=4e7b0ee3cd8ef889c4fed673e06b91263b238e10", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::num::One;\n use std::vec::bytes::{MutableByteVector, copy_memory};\n \n \n@@ -68,6 +69,56 @@ pub fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n }\n \n \n+/// Returns true if adding the two parameters will result in integer overflow\n+pub fn will_add_overflow<T: Int + Unsigned>(x: T, y: T) -> bool {\n+    // This doesn't handle negative values! Don't copy this code elsewhere without considering if\n+    // negative values are important to you!\n+    let max: T = Bounded::max_value();\n+    return x > max - y;\n+}\n+\n+/// Shifts the second parameter and then adds it to the first. fails!() if there would be unsigned\n+/// integer overflow.\n+pub fn shift_add_check_overflow<T: Int + Unsigned + Clone>(x: T, mut y: T, shift: T) -> T {\n+    if y.leading_zeros() < shift {\n+        fail!(\"Could not add values - integer overflow.\");\n+    }\n+    y = y << shift;\n+\n+    if will_add_overflow(x.clone(), y.clone()) {\n+        fail!(\"Could not add values - integer overflow.\");\n+    }\n+\n+    return x + y;\n+}\n+\n+/// Shifts the second parameter and then adds it to the first, which is a tuple where the first\n+/// element is the high order value. fails!() if there would be unsigned integer overflow.\n+pub fn shift_add_check_overflow_tuple\n+        <T: Int + Unsigned + Clone>\n+        (x: (T, T), mut y: T, shift: T) -> (T, T) {\n+    if y.leading_zeros() < shift {\n+        fail!(\"Could not add values - integer overflow.\");\n+    }\n+    y = y << shift;\n+\n+    match x {\n+        (hi, low) => {\n+            let one: T = One::one();\n+            if will_add_overflow(low.clone(), y.clone()) {\n+                if will_add_overflow(hi.clone(), one.clone()) {\n+                    fail!(\"Could not add values - integer overflow.\");\n+                } else {\n+                    return (hi + one, low + y);\n+                }\n+            } else {\n+                return (hi, low + y);\n+            }\n+        }\n+    }\n+}\n+\n+\n /// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n /// must be processed. The input() method takes care of processing and then clearing the buffer\n /// automatically. However, other methods do not and require the caller to process the buffer. Any"}, {"sha": "d92a4be43c388122bae1bf456f760d5eb61096bb", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 20, "deletions": 55, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4e7b0ee3cd8ef889c4fed673e06b91263b238e10/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e7b0ee3cd8ef889c4fed673e06b91263b238e10/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=4e7b0ee3cd8ef889c4fed673e06b91263b238e10", "patch": "@@ -10,8 +10,8 @@\n \n use std::uint;\n \n-use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, FixedBuffer,\n-    FixedBuffer128, FixedBuffer64, StandardPadding};\n+use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, shift_add_check_overflow,\n+    shift_add_check_overflow_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n use digest::Digest;\n \n \n@@ -34,47 +34,6 @@ macro_rules! sha2_round(\n )\n \n \n-// BitCounter is a specialized structure intended simply for counting the\n-// number of bits that have been processed by the SHA-2 512 family of functions.\n-// It does very little overflow checking since such checking is not necessary\n-// for how it is used. A more generic structure would have to do this checking.\n-// So, don't copy this structure and use it elsewhere!\n-struct BitCounter {\n-    high_bit_count: u64,\n-    low_byte_count: u64\n-}\n-\n-impl BitCounter {\n-    fn new() -> BitCounter {\n-        return BitCounter {\n-            high_bit_count: 0,\n-            low_byte_count: 0\n-        };\n-    }\n-\n-    fn add_bytes(&mut self, bytes: uint) {\n-        self.low_byte_count += bytes as u64;\n-        if(self.low_byte_count > 0x1fffffffffffffffu64) {\n-            self.high_bit_count += (self.low_byte_count >> 61);\n-            self.low_byte_count &= 0x1fffffffffffffffu64;\n-        }\n-    }\n-\n-    fn reset(&mut self) {\n-        self.low_byte_count = 0;\n-        self.high_bit_count = 0;\n-    }\n-\n-    fn get_low_bit_count(&self) -> u64 {\n-        self.low_byte_count << 3\n-    }\n-\n-    fn get_high_bit_count(&self) -> u64 {\n-        self.high_bit_count\n-    }\n-}\n-\n-\n // A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n // functions\n struct Engine512State {\n@@ -223,7 +182,7 @@ static K64: [u64, ..80] = [\n // A structure that keeps track of the state of the Sha-512 operation and contains the logic\n // necessary to perform the final calculations.\n struct Engine512 {\n-    bit_counter: BitCounter,\n+    length_bits: (u64, u64),\n     buffer: FixedBuffer128,\n     state: Engine512State,\n     finished: bool,\n@@ -232,23 +191,24 @@ struct Engine512 {\n impl Engine512 {\n     fn new(h: &[u64, ..8]) -> Engine512 {\n         return Engine512 {\n-            bit_counter: BitCounter::new(),\n+            length_bits: (0, 0),\n             buffer: FixedBuffer128::new(),\n             state: Engine512State::new(h),\n             finished: false\n         }\n     }\n \n     fn reset(&mut self, h: &[u64, ..8]) {\n-        self.bit_counter.reset();\n+        self.length_bits = (0, 0);\n         self.buffer.reset();\n         self.state.reset(h);\n         self.finished = false;\n     }\n \n     fn input(&mut self, input: &[u8]) {\n         assert!(!self.finished)\n-        self.bit_counter.add_bytes(input.len());\n+        // Assumes that input.len() can be converted to u64 without overflow\n+        self.length_bits = shift_add_check_overflow_tuple(self.length_bits, input.len() as u64, 3);\n         self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n     }\n \n@@ -258,8 +218,12 @@ impl Engine512 {\n         }\n \n         self.buffer.standard_padding(16, |input: &[u8]| { self.state.process_block(input) });\n-        write_u64_be(self.buffer.next(8), self.bit_counter.get_high_bit_count());\n-        write_u64_be(self.buffer.next(8), self.bit_counter.get_low_bit_count());\n+        match self.length_bits {\n+            (hi, low) => {\n+                write_u64_be(self.buffer.next(8), hi);\n+                write_u64_be(self.buffer.next(8), low);\n+            }\n+        }\n         self.state.process_block(self.buffer.full_buffer());\n \n         self.finished = true;\n@@ -608,7 +572,7 @@ static K32: [u32, ..64] = [\n // A structure that keeps track of the state of the Sha-256 operation and contains the logic\n // necessary to perform the final calculations.\n struct Engine256 {\n-    length: u64,\n+    length_bits: u64,\n     buffer: FixedBuffer64,\n     state: Engine256State,\n     finished: bool,\n@@ -617,23 +581,24 @@ struct Engine256 {\n impl Engine256 {\n     fn new(h: &[u32, ..8]) -> Engine256 {\n         return Engine256 {\n-            length: 0,\n+            length_bits: 0,\n             buffer: FixedBuffer64::new(),\n             state: Engine256State::new(h),\n             finished: false\n         }\n     }\n \n     fn reset(&mut self, h: &[u32, ..8]) {\n-        self.length = 0;\n+        self.length_bits = 0;\n         self.buffer.reset();\n         self.state.reset(h);\n         self.finished = false;\n     }\n \n     fn input(&mut self, input: &[u8]) {\n         assert!(!self.finished)\n-        self.length += input.len() as u64;\n+        // Assumes that input.len() can be converted to u64 without overflow\n+        self.length_bits = shift_add_check_overflow(self.length_bits, input.len() as u64, 3);\n         self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n     }\n \n@@ -643,8 +608,8 @@ impl Engine256 {\n         }\n \n         self.buffer.standard_padding(8, |input: &[u8]| { self.state.process_block(input) });\n-        write_u32_be(self.buffer.next(4), (self.length >> 29) as u32 );\n-        write_u32_be(self.buffer.next(4), (self.length << 3) as u32);\n+        write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n+        write_u32_be(self.buffer.next(4), self.length_bits as u32);\n         self.state.process_block(self.buffer.full_buffer());\n \n         self.finished = true;"}]}