{"sha": "496836acf74502ed5ae0e20b6e6bc720d7b72ae6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NjgzNmFjZjc0NTAyZWQ1YWUwZTIwYjZlNmJjNzIwZDdiNzJhZTY=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-01-25T01:45:26Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-01-25T01:45:26Z"}, "message": "Improve `rustc_mir_build::matches` docs\n\n- Fix typos\n- Add more information\n- General cleanup", "tree": {"sha": "fe6aed0e19966b6dfbb0e852f27af38982d21789", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe6aed0e19966b6dfbb0e852f27af38982d21789"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/496836acf74502ed5ae0e20b6e6bc720d7b72ae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/496836acf74502ed5ae0e20b6e6bc720d7b72ae6", "html_url": "https://github.com/rust-lang/rust/commit/496836acf74502ed5ae0e20b6e6bc720d7b72ae6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/496836acf74502ed5ae0e20b6e6bc720d7b72ae6/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "html_url": "https://github.com/rust-lang/rust/commit/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8"}], "stats": {"total": 125, "additions": 72, "deletions": 53}, "files": [{"sha": "6b04c53ec07ba2cba4f25c8a8b16d4c7e1d76db5", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 71, "deletions": 52, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/496836acf74502ed5ae0e20b6e6bc720d7b72ae6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496836acf74502ed5ae0e20b6e6bc720d7b72ae6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=496836acf74502ed5ae0e20b6e6bc720d7b72ae6", "patch": "@@ -82,8 +82,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// visible through borrow checking. False edges ensure that the CFG as\n     /// seen by borrow checking doesn't encode this. False edges are added:\n     ///\n-    /// * From each prebinding block to the next prebinding block.\n-    /// * From each otherwise block to the next prebinding block.\n+    /// * From each pre-binding block to the next pre-binding block.\n+    /// * From each otherwise block to the next pre-binding block.\n     crate fn match_expr(\n         &mut self,\n         destination: Place<'tcx>,\n@@ -630,10 +630,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n #[derive(Debug)]\n pub(super) struct Candidate<'pat, 'tcx> {\n-    /// `Span` of the original pattern that gave rise to this candidate\n+    /// [`Span`] of the original pattern that gave rise to this candidate.\n     span: Span,\n \n-    /// This `Candidate` has a guard.\n+    /// Whether this `Candidate` has a guard.\n     has_guard: bool,\n \n     /// All of these must be satisfied...\n@@ -645,14 +645,15 @@ pub(super) struct Candidate<'pat, 'tcx> {\n     /// ...and these types asserted...\n     ascriptions: Vec<Ascription<'tcx>>,\n \n-    /// ... and if this is non-empty, one of these subcandidates also has to match ...\n+    /// ...and if this is non-empty, one of these subcandidates also has to match...\n     subcandidates: Vec<Candidate<'pat, 'tcx>>,\n \n-    /// ...and the guard must be evaluated, if false branch to Block...\n+    /// ...and the guard must be evaluated; if it's `false` then branch to `otherwise_block`.\n     otherwise_block: Option<BasicBlock>,\n \n-    /// ...and the blocks for add false edges between candidates\n+    /// The block before the `bindings` have been established.\n     pre_binding_block: Option<BasicBlock>,\n+    /// The pre-binding block of the next candidate.\n     next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n@@ -737,26 +738,27 @@ crate struct MatchPair<'pat, 'tcx> {\n     pattern: &'pat Pat<'tcx>,\n }\n \n+/// See [`Test`] for more.\n #[derive(Clone, Debug, PartialEq)]\n enum TestKind<'tcx> {\n-    /// Test the branches of enum.\n+    /// Test what enum variant a value is.\n     Switch {\n-        /// The enum being tested\n+        /// The enum type being tested.\n         adt_def: &'tcx ty::AdtDef,\n         /// The set of variants that we should create a branch for. We also\n         /// create an additional \"otherwise\" case.\n         variants: BitSet<VariantIdx>,\n     },\n \n-    /// Test what value an `integer`, `bool` or `char` has.\n+    /// Test what value an integer, `bool`, or `char` has.\n     SwitchInt {\n         /// The type of the value that we're testing.\n         switch_ty: Ty<'tcx>,\n         /// The (ordered) set of values that we test for.\n         ///\n         /// For integers and `char`s we create a branch to each of the values in\n         /// `options`, as well as an \"otherwise\" branch for all other values, even\n-        /// in the (rare) case that options is exhaustive.\n+        /// in the (rare) case that `options` is exhaustive.\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n@@ -776,17 +778,21 @@ enum TestKind<'tcx> {\n     /// Test whether the value falls within an inclusive or exclusive range\n     Range(PatRange<'tcx>),\n \n-    /// Test length of the slice is equal to len\n+    /// Test that the length of the slice is equal to `len`.\n     Len { len: u64, op: BinOp },\n }\n \n+/// A test to perform to determine which [`Candidate`] matches a value.\n+///\n+/// [`Test`] is just the test to perform; it does not include the value\n+/// to be tested.\n #[derive(Debug)]\n crate struct Test<'tcx> {\n     span: Span,\n     kind: TestKind<'tcx>,\n }\n \n-/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n+/// `ArmHasGuard` is a wrapper around a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n crate struct ArmHasGuard(crate bool);\n@@ -801,27 +807,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// candidates are sorted such that the first item in the list\n     /// has the highest priority. When a candidate is found to match\n     /// the value, we will set and generate a branch to the appropriate\n-    /// prebinding block.\n+    /// pre-binding block.\n     ///\n     /// If we find that *NONE* of the candidates apply, we branch to the\n     /// `otherwise_block`, setting it to `Some` if required. In principle, this\n     /// means that the input list was not exhaustive, though at present we\n     /// sometimes are not smart enough to recognize all exhaustive inputs.\n     ///\n-    /// It might be surprising that the input can be inexhaustive.\n+    /// It might be surprising that the input can be non-exhaustive.\n     /// Indeed, initially, it is not, because all matches are\n     /// exhaustive in Rust. But during processing we sometimes divide\n     /// up the list of candidates and recurse with a non-exhaustive\n     /// list. This is important to keep the size of the generated code\n-    /// under control. See `test_candidates` for more details.\n+    /// under control. See [`Builder::test_candidates`] for more details.\n     ///\n-    /// If `fake_borrows` is Some, then places which need fake borrows\n+    /// If `fake_borrows` is `Some`, then places which need fake borrows\n     /// will be added to it.\n     ///\n     /// For an example of a case where we set `otherwise_block`, even for an\n-    /// exhaustive match consider:\n+    /// exhaustive match, consider:\n     ///\n-    /// ```rust\n+    /// ```\n     /// match x {\n     ///     (true, true) => (),\n     ///     (_, false) => (),\n@@ -830,8 +836,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// ```\n     ///\n     /// For this match, we check if `x.0` matches `true` (for the first\n-    /// arm). If that's false, we check `x.1`. If it's `true` we check if\n-    /// `x.0` matches `false` (for the third arm). In the (impossible at\n+    /// arm). If it doesn't match, we check `x.1`. If `x.1` is `true` we check\n+    /// if `x.0` matches `false` (for the third arm). In the (impossible at\n     /// runtime) case when `x.0` is now `true`, we branch to\n     /// `otherwise_block`.\n     fn match_candidates<'pat>(\n@@ -938,26 +944,31 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n     }\n \n-    /// Link up matched candidates. For example, if we have something like\n-    /// this:\n+    /// Link up matched candidates.\n+    ///\n+    /// For example, if we have something like this:\n     ///\n     /// ```rust\n     /// ...\n-    /// Some(x) if cond => ...\n+    /// Some(x) if cond1 => ...\n     /// Some(x) => ...\n-    /// Some(x) if cond => ...\n+    /// Some(x) if cond2 => ...\n     /// ...\n     /// ```\n     ///\n     /// We generate real edges from:\n-    /// * `start_block` to the `prebinding_block` of the first pattern,\n-    /// * the otherwise block of the first pattern to the second pattern,\n-    /// * the otherwise block of the third pattern to the a block with an\n-    ///   Unreachable terminator.\n     ///\n-    /// As well as that we add fake edges from the otherwise blocks to the\n-    /// prebinding block of the next candidate in the original set of\n+    /// * `start_block` to the [pre-binding block] of the first pattern,\n+    /// * the [otherwise block] of the first pattern to the second pattern,\n+    /// * the [otherwise block] of the third pattern to a block with an\n+    ///   [`Unreachable` terminator](TerminatorKind::Unreachable).\n+    ///\n+    /// In addition, we add fake edges from the otherwise blocks to the\n+    /// pre-binding block of the next candidate in the original set of\n     /// candidates.\n+    ///\n+    /// [pre-binding block]: Candidate::pre_binding_block\n+    /// [otherwise block]: Candidate::otherwise_block\n     fn select_matched_candidates(\n         &mut self,\n         matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n@@ -1044,7 +1055,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// forwards to [Builder::test_candidates].\n     ///\n     /// Given a pattern `(P | Q, R | S)` we (in principle) generate a CFG like\n-    /// so\n+    /// so:\n     ///\n     /// ```text\n     /// [ start ]\n@@ -1214,31 +1225,35 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// This is the most subtle part of the matching algorithm. At\n     /// this point, the input candidates have been fully simplified,\n     /// and so we know that all remaining match-pairs require some\n-    /// sort of test. To decide what test to do, we take the highest\n+    /// sort of test. To decide what test to perform, we take the highest\n     /// priority candidate (last one in the list) and extract the\n     /// first match-pair from the list. From this we decide what kind\n-    /// of test is needed using `test`, defined in the `test` module.\n+    /// of test is needed using [`Builder::test`], defined in the\n+    /// [`test` module](mod@test).\n     ///\n     /// *Note:* taking the first match pair is somewhat arbitrary, and\n     /// we might do better here by choosing more carefully what to\n     /// test.\n     ///\n     /// For example, consider the following possible match-pairs:\n     ///\n-    /// 1. `x @ Some(P)` -- we will do a `Switch` to decide what variant `x` has\n-    /// 2. `x @ 22` -- we will do a `SwitchInt`\n-    /// 3. `x @ 3..5` -- we will do a range test\n+    /// 1. `x @ Some(P)` -- we will do a [`Switch`] to decide what variant `x` has\n+    /// 2. `x @ 22` -- we will do a [`SwitchInt`] to decide what value `x` has\n+    /// 3. `x @ 3..5` -- we will do a [`Range`] test to decide what range `x` falls in\n     /// 4. etc.\n     ///\n+    /// [`Switch`]: TestKind::Switch\n+    /// [`SwitchInt`]: TestKind::SwitchInt\n+    /// [`Range`]: TestKind::Range\n+    ///\n     /// Once we know what sort of test we are going to perform, this\n-    /// Tests may also help us with other candidates. So we walk over\n+    /// test may also help us winnow down our candidates. So we walk over\n     /// the candidates (from high to low priority) and check. This\n     /// gives us, for each outcome of the test, a transformed list of\n-    /// candidates. For example, if we are testing the current\n-    /// variant of `x.0`, and we have a candidate `{x.0 @ Some(v), x.1\n-    /// @ 22}`, then we would have a resulting candidate of `{(x.0 as\n-    /// Some).0 @ v, x.1 @ 22}`. Note that the first match-pair is now\n-    /// simpler (and, in fact, irrefutable).\n+    /// candidates. For example, if we are testing `x.0`'s variant,\n+    /// and we have a candidate `(x.0 @ Some(v), x.1 @ 22)`,\n+    /// then we would have a resulting candidate of `((x.0 as Some).0 @ v, x.1 @ 22)`.\n+    /// Note that the first match-pair is now simpler (and, in fact, irrefutable).\n     ///\n     /// But there may also be candidates that the test just doesn't\n     /// apply to. The classical example involves wildcards:\n@@ -1268,7 +1283,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// is trivially NP-complete:\n     ///\n     /// ```rust\n-    ///     match (var0, var1, var2, var3, ..) {\n+    ///     match (var0, var1, var2, var3, ...) {\n     ///         (true, _, _, false, true, ...) => false,\n     ///         (_, true, true, false, _, ...) => false,\n     ///         (false, _, false, false, _, ...) => false,\n@@ -1283,7 +1298,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// That kind of exponential worst-case might not occur in practice, but\n     /// our simplistic treatment of constants and guards would make it occur\n-    /// in very common situations - for example #29740:\n+    /// in very common situations - for example [#29740]:\n     ///\n     /// ```rust\n     /// match x {\n@@ -1294,13 +1309,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// Here we first test the match-pair `x @ \"foo\"`, which is an `Eq` test.\n+    /// [#29740]: https://github.com/rust-lang/rust/issues/29740\n+    ///\n+    /// Here we first test the match-pair `x @ \"foo\"`, which is an [`Eq` test].\n+    ///\n+    /// [`Eq` test]: TestKind::Eq\n     ///\n     /// It might seem that we would end up with 2 disjoint candidate\n-    /// sets, consisting of the first candidate or the other 3, but our\n-    /// algorithm doesn't reason about \"foo\" being distinct from the other\n+    /// sets, consisting of the first candidate or the other two, but our\n+    /// algorithm doesn't reason about `\"foo\"` being distinct from the other\n     /// constants; it considers the latter arms to potentially match after\n-    /// both outcomes, which obviously leads to an exponential amount\n+    /// both outcomes, which obviously leads to an exponential number\n     /// of tests.\n     ///\n     /// To avoid these kinds of problems, our algorithm tries to ensure\n@@ -1312,16 +1331,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// After we perform our test, we branch into the appropriate candidate\n     /// set and recurse with `match_candidates`. These sub-matches are\n-    /// obviously inexhaustive - as we discarded our otherwise set - so\n+    /// obviously non-exhaustive - as we discarded our otherwise set - so\n     /// we set their continuation to do `match_candidates` on the\n-    /// \"unmatched\" set (which is again inexhaustive).\n+    /// \"unmatched\" set (which is again non-exhaustive).\n     ///\n     /// If you apply this to the above test, you basically wind up\n     /// with an if-else-if chain, testing each candidate in turn,\n     /// which is precisely what we want.\n     ///\n     /// In addition to avoiding exponential-time blowups, this algorithm\n-    /// also has nice property that each guard and arm is only generated\n+    /// also has the nice property that each guard and arm is only generated\n     /// once.\n     fn test_candidates<'pat, 'b, 'c>(\n         &mut self,"}, {"sha": "126fb957a6a9945e2c5ff0c00b7e5cf005fa32cf", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/496836acf74502ed5ae0e20b6e6bc720d7b72ae6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496836acf74502ed5ae0e20b6e6bc720d7b72ae6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=496836acf74502ed5ae0e20b6e6bc720d7b72ae6", "patch": "@@ -23,7 +23,7 @@ use std::cmp::Ordering;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n-    /// It is a bug to call this with a simplifiable pattern.\n+    /// It is a bug to call this with a not-fully-simplified pattern.\n     pub(super) fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n             PatKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {"}]}