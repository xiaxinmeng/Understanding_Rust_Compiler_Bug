{"sha": "dca29d7b0832a5d75db18be96833a8885ef2c2a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYTI5ZDdiMDgzMmE1ZDc1ZGIxOGJlOTY4MzNhODg4NWVmMmMyYTY=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2016-05-03T10:54:29Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2016-05-03T21:18:38Z"}, "message": "save-analysis: use a decoupled representation for dumped data\n\nCloses #33348", "tree": {"sha": "e4d04426aa7926679394ddc9f6ad0bf99273bc25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4d04426aa7926679394ddc9f6ad0bf99273bc25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dca29d7b0832a5d75db18be96833a8885ef2c2a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dca29d7b0832a5d75db18be96833a8885ef2c2a6", "html_url": "https://github.com/rust-lang/rust/commit/dca29d7b0832a5d75db18be96833a8885ef2c2a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dca29d7b0832a5d75db18be96833a8885ef2c2a6/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d8100a068151512774caf15a6a88766ca9cf434", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d8100a068151512774caf15a6a88766ca9cf434", "html_url": "https://github.com/rust-lang/rust/commit/7d8100a068151512774caf15a6a88766ca9cf434"}], "stats": {"total": 1590, "additions": 752, "deletions": 838}, "files": [{"sha": "626537a4ae9a0b95f87b33b9a75dd3bcf439fb1e", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 35, "deletions": 84, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=dca29d7b0832a5d75db18be96833a8885ef2c2a6", "patch": "@@ -10,25 +10,20 @@\n \n use std::io::Write;\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n-use syntax::codemap::Span;\n-\n-use super::data::*;\n+use super::external_data::*;\n use super::dump::Dump;\n-use super::span_utils::SpanUtils;\n \n-pub struct CsvDumper<'tcx, 'b, W: 'b> {\n-    output: &'b mut W,\n-    span: SpanUtils<'tcx>\n+pub struct CsvDumper<'b, W: 'b> {\n+    output: &'b mut W\n }\n \n-impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n-    pub fn new(writer: &'b mut W, span: SpanUtils<'a>) -> CsvDumper<'a, 'b, W> {\n-        CsvDumper { output: writer, span: span }\n+impl<'b, W: Write> CsvDumper<'b, W> {\n+    pub fn new(writer: &'b mut W) -> CsvDumper<'b, W> {\n+        CsvDumper { output: writer }\n     }\n \n-    fn record(&mut self, kind: &str, span: Span, values: String) {\n-        let span_str = self.span.extent_str(span);\n+    fn record(&mut self, kind: &str, span: SpanData, values: String) {\n+        let span_str = span_extent_str(span);\n         if let Err(_) = write!(self.output, \"{},{}{}\\n\", kind, span_str, values) {\n             error!(\"Error writing output\");\n         }\n@@ -41,7 +36,7 @@ impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n     }\n }\n \n-impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n+impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     fn crate_prelude(&mut self, data: CratePreludeData) {\n         let values = make_values_str(&[\n             (\"name\", &data.crate_name),\n@@ -93,68 +88,50 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn impl_data(&mut self, data: ImplData) {\n-        let self_ref = data.self_ref.unwrap_or(null_def_id());\n-        let trait_ref = data.trait_ref.unwrap_or(null_def_id());\n-\n         let id = data.id.to_string();\n-        let ref_id = self_ref.index.as_usize().to_string();\n-        let ref_id_crate = self_ref.krate.to_string();\n-        let trait_id = trait_ref.index.as_usize().to_string();\n-        let trait_id_crate = trait_ref.krate.to_string();\n+        let ref_id = data.self_ref.unwrap_or(Id::null()).to_string();\n+        let trait_id = data.trait_ref.unwrap_or(Id::null()).to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_id_crate),\n             (\"traitid\", &trait_id),\n-            (\"traitidcrate\", &trait_id_crate),\n             (\"scopeid\", &scope)\n         ]);\n \n         self.record(\"impl\", data.span, values);\n     }\n \n     fn inheritance(&mut self, data: InheritanceData) {\n-       let base_id = data.base_id.index.as_usize().to_string();\n-       let base_crate = data.base_id.krate.to_string();\n-       let deriv_id = data.deriv_id.to_string();\n-       let deriv_crate = 0.to_string();\n-       let values = make_values_str(&[\n-           (\"base\", &base_id),\n-           (\"basecrate\", &base_crate),\n-           (\"derived\", &deriv_id),\n-           (\"derivedcrate\", &deriv_crate)\n-       ]);\n+        let base_id = data.base_id.to_string();\n+        let deriv_id = data.deriv_id.to_string();\n+        let values = make_values_str(&[\n+            (\"base\", &base_id),\n+            (\"derived\", &deriv_id),\n+        ]);\n \n        self.record(\"inheritance\", data.span, values);\n     }\n \n     fn function(&mut self, data: FunctionData) {\n-        let (decl_id, decl_crate) = match data.declaration {\n-            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n-            None => (String::new(), String::new())\n-        };\n-\n         let id = data.id.to_string();\n+        let decl_id = data.declaration.unwrap_or(Id::null()).to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n             (\"declid\", &decl_id),\n-            (\"declidcrate\", &decl_crate),\n             (\"scopeid\", &scope)\n         ]);\n \n         self.record(\"function\", data.span, values);\n     }\n \n     fn function_ref(&mut self, data: FunctionRefData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n+        let ref_id = data.ref_id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n             (\"qualname\", \"\"),\n             (\"scopeid\", &scope)\n         ]);\n@@ -163,13 +140,11 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn function_call(&mut self, data: FunctionCallData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n+        let ref_id = data.ref_id.to_string();\n         let qualname = String::new();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n             (\"qualname\", &qualname),\n             (\"scopeid\", &scope)\n         ]);\n@@ -190,21 +165,12 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn method_call(&mut self, data: MethodCallData) {\n-        let (dcn, dck) = match data.decl_id {\n-            Some(declid) => (declid.index.as_usize().to_string(), declid.krate.to_string()),\n-            None => (String::new(), String::new()),\n-        };\n-\n-        let ref_id = data.ref_id.unwrap_or(null_def_id());\n-\n-        let def_id = ref_id.index.as_usize().to_string();\n-        let def_crate = ref_id.krate.to_string();\n+        let decl_id = data.decl_id.unwrap_or(Id::null()).to_string();\n+        let ref_id = data.ref_id.unwrap_or(Id::null()).to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n-            (\"refid\", &def_id),\n-            (\"refidcrate\", &def_crate),\n-            (\"declid\", &dcn),\n-            (\"declidcrate\", &dck),\n+            (\"refid\", &ref_id),\n+            (\"declid\", &decl_id),\n             (\"scopeid\", &scope)\n         ]);\n \n@@ -245,15 +211,11 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn mod_ref(&mut self, data: ModRefData) {\n-        let (ref_id, ref_crate) = match data.ref_id {\n-            Some(rid) => (rid.index.as_usize().to_string(), rid.krate.to_string()),\n-            None => (0.to_string(), 0.to_string())\n-        };\n+        let ref_id = data.ref_id.unwrap_or(Id::null()).to_string();\n \n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n             (\"qualname\", &data.qualname),\n             (\"scopeid\", &scope)\n         ]);\n@@ -320,15 +282,10 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn type_ref(&mut self, data: TypeRefData) {\n-        let (ref_id, ref_crate) = match data.ref_id {\n-            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n-            None => (0.to_string(), 0.to_string())\n-        };\n-\n+        let ref_id = data.ref_id.unwrap_or(Id::null()).to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n             (\"qualname\", &data.qualname),\n             (\"scopeid\", &scope)\n         ]);\n@@ -348,16 +305,12 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn use_data(&mut self, data: UseData) {\n-        let mod_id = data.mod_id.unwrap_or(null_def_id());\n-\n         let id = data.id.to_string();\n-        let ref_id = mod_id.index.as_usize().to_string();\n-        let ref_crate = mod_id.krate.to_string();\n+        let mod_id = data.mod_id.unwrap_or(Id::null()).to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n+            (\"mod_id\", &mod_id),\n             (\"name\", &data.name),\n             (\"scopeid\", &scope)\n         ]);\n@@ -395,12 +348,10 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn variable_ref(&mut self, data: VariableRefData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n+        let id = data.ref_id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n+            (\"id\", &id),\n             (\"qualname\", \"\"),\n             (\"scopeid\", &scope)\n         ]);\n@@ -431,9 +382,9 @@ fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n     })\n }\n \n-fn null_def_id() -> DefId {\n-    DefId {\n-        krate: 0,\n-        index: DefIndex::new(0),\n-    }\n+fn span_extent_str(span: SpanData) -> String {\n+    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{}\\\n+             file_line_end,{},file_col_end,{},byte_end,{}\",\n+             span.file_name, span.line_start, span.column_start, span.byte_start,\n+             span.line_end, span.column_end, span.byte_end)\n }"}, {"sha": "d13e01cffd4cf220b61a7240434e304e60f01f9c", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 1, "deletions": 87, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=dca29d7b0832a5d75db18be96833a8885ef2c2a6", "patch": "@@ -16,39 +16,8 @@\n use std::hash::Hasher;\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n use syntax::ast::{CrateNum, NodeId};\n-use syntax::codemap::{Span, CodeMap};\n-\n-#[derive(Debug, Clone, RustcEncodable)]\n-pub struct SpanData {\n-    file_name: String,\n-    byte_start: u32,\n-    byte_end: u32,\n-    /// 1-based.\n-    line_start: usize,\n-    line_end: usize,\n-    /// 1-based, character offset.\n-    column_start: usize,\n-    column_end: usize,\n-}\n-\n-impl SpanData {\n-    pub fn from_span(span: Span, cm: &CodeMap) -> SpanData {\n-        let start = cm.lookup_char_pos(span.lo);\n-        let end = cm.lookup_char_pos(span.hi);\n-\n-        SpanData {\n-            file_name: start.file.name.clone(),\n-            byte_start: span.lo.0,\n-            byte_end: span.hi.0,\n-            line_start: start.line,\n-            line_end: end.line,\n-            column_start: start.col.0 + 1,\n-            column_end: end.col.0 + 1,\n-        }\n-    }\n-}\n+use syntax::codemap::Span;\n \n pub struct CrateData {\n     pub name: String,\n@@ -359,58 +328,3 @@ pub struct VariableRefData {\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n-\n-// Emitted ids are used to cross-reference items across crates. DefIds and\n-// NodeIds do not usually correspond in any way. The strategy is to use the\n-// index from the DefId as a crate-local id. However, within a crate, DefId\n-// indices and NodeIds can overlap. So, we must adjust the NodeIds. If an\n-// item can be identified by a DefId as well as a NodeId, then we use the\n-// DefId index as the id. If it can't, then we have to use the NodeId, but\n-// need to adjust it so it will not clash with any possible DefId index.\n-pub fn normalize_node_id<'a>(tcx: &ty::TyCtxt<'a>, id: NodeId) -> usize {\n-    match tcx.map.opt_local_def_id(id) {\n-        Some(id) => id.index.as_usize(),\n-        None => id as usize + tcx.map.num_local_def_ids()\n-    }\n-}\n-\n-// Macro to implement a normalize() function (see below for usage)\n-macro_rules! impl_normalize {\n-    ($($t:ty => $($field:ident),*);*) => {\n-        $(\n-            impl $t {\n-                pub fn normalize<'a>(mut self, tcx: &ty::TyCtxt<'a>) -> $t {\n-                    $(\n-                        self.$field = normalize_node_id(tcx, self.$field) as u32;\n-                    )*\n-                    self\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-impl_normalize! {\n-    EnumData => id, scope;\n-    ExternCrateData => id, scope;\n-    FunctionCallData => scope;\n-    FunctionData => id, scope;\n-    FunctionRefData => scope;\n-    ImplData => id, scope;\n-    InheritanceData => deriv_id;\n-    MacroUseData => scope;\n-    MethodCallData => scope;\n-    MethodData => id, scope;\n-    ModData => id, scope;\n-    ModRefData => scope;\n-    StructData => ctor_id, id, scope;\n-    StructVariantData => id, scope;\n-    TupleVariantData => id, scope;\n-    TraitData => id, scope;\n-    TypedefData => id;\n-    TypeRefData => scope;\n-    UseData => id, scope;\n-    UseGlobData => id, scope;\n-    VariableData => id;\n-    VariableRefData => scope\n-}"}, {"sha": "adbf1e0a35ec1be9d82ccf87caa18e8369303a28", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=dca29d7b0832a5d75db18be96833a8885ef2c2a6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::data::*;\n+use super::external_data::*;\n \n pub trait Dump {\n     fn crate_prelude(&mut self, CratePreludeData) {}"}, {"sha": "7a411969363e9e40f95ed016f0d20e8e18363fb3", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=dca29d7b0832a5d75db18be96833a8885ef2c2a6", "patch": "@@ -45,6 +45,7 @@ use syntax::ptr::P;\n use super::{escape, generated_code, SaveContext, PathCollector};\n use super::data::*;\n use super::dump::Dump;\n+use super::external_data::Lower;\n use super::span_utils::SpanUtils;\n use super::recorder;\n \n@@ -133,7 +134,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             span: krate.span,\n         };\n \n-        self.dumper.crate_prelude(data);\n+        self.dumper.crate_prelude(data.lower(self.tcx));\n     }\n \n     // Return all non-empty prefixes of a path.\n@@ -203,7 +204,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname,\n                 scope: self.cur_scope,\n                 ref_id: None\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n     }\n \n@@ -228,7 +229,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname,\n                 scope: self.cur_scope,\n                 ref_id: None\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n     }\n \n@@ -249,7 +250,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             span: *span,\n             qualname: qualname.to_owned(),\n             scope: 0\n-        });\n+        }.lower(self.tcx));\n \n         // write the other sub-paths\n         if len <= 2 {\n@@ -262,7 +263,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname.to_owned(),\n                 scope: self.cur_scope,\n                 ref_id: None\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n     }\n \n@@ -304,7 +305,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     ref_id: Some(def_id),\n                     scope: scope,\n                     qualname: String::new()\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n             Def::Struct(..) |\n             Def::Enum(..) |\n@@ -316,7 +317,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     ref_id: Some(def_id),\n                     scope: scope,\n                     qualname: String::new()\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n             Def::Static(_, _) |\n             Def::Const(_) |\n@@ -329,14 +330,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     ref_id: def_id,\n                     scope: scope,\n                     name: String::new()\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n             Def::Fn(..) => {\n                 self.dumper.function_ref(FunctionRefData {\n                     span: sub_span.expect(\"No span found for fn ref\"),\n                     ref_id: def_id,\n                     scope: scope\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n             Def::SelfTy(..) |\n             Def::Label(_) |\n@@ -371,7 +372,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         type_value: typ,\n                         value: String::new(),\n                         scope: 0\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n             }\n         }\n@@ -389,7 +390,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n             if body.is_some() {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.function(method_data.clone().normalize(&self.tcx));\n+                    self.dumper.function(method_data.clone().lower(self.tcx));\n                 }\n                 self.process_formals(&sig.decl.inputs, &method_data.qualname);\n             } else {\n@@ -399,7 +400,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         span: method_data.span,\n                         scope: method_data.scope,\n                         qualname: method_data.qualname.clone(),\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n             }\n             self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n@@ -424,7 +425,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n         if let Some(trait_ref_data) = trait_ref_data {\n             if !self.span.filter_generated(Some(trait_ref_data.span), trait_ref.path.span) {\n-                self.dumper.type_ref(trait_ref_data.normalize(&self.tcx));\n+                self.dumper.type_ref(trait_ref_data.lower(self.tcx));\n             }\n \n             visit::walk_path(self, &trait_ref.path);\n@@ -435,9 +436,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(mut field_data) = field_data {\n             if !self.span.filter_generated(Some(field_data.span), field.span) {\n-                field_data.scope = normalize_node_id(&self.tcx, field_data.scope) as u32;\n                 field_data.value = String::new();\n-                self.dumper.variable(field_data.normalize(&self.tcx));\n+                self.dumper.variable(field_data.lower(self.tcx));\n             }\n         }\n     }\n@@ -466,7 +466,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     id: param.id,\n                     qualname: name,\n                     value: String::new()\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n         }\n         self.visit_generics(generics);\n@@ -480,7 +480,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(fn_data, FunctionData, item.span);\n             if !self.span.filter_generated(Some(fn_data.span), item.span) {\n-                self.dumper.function(fn_data.clone().normalize(&self.tcx));\n+                self.dumper.function(fn_data.clone().lower(self.tcx));\n             }\n \n             self.process_formals(&decl.inputs, &fn_data.qualname);\n@@ -502,9 +502,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(var_data, VariableData, item.span);\n             if !self.span.filter_generated(Some(var_data.span), item.span) {\n-                let mut var_data = var_data;\n-                var_data.scope = normalize_node_id(&self.tcx, var_data.scope) as u32;\n-                self.dumper.variable(var_data.normalize(&self.tcx));\n+                self.dumper.variable(var_data.lower(self.tcx));\n             }\n         }\n         self.visit_ty(&typ);\n@@ -529,8 +527,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname,\n                 value: self.span.snippet(expr.span),\n                 type_value: ty_to_string(&typ),\n-                scope: normalize_node_id(&self.tcx, self.cur_scope) as u32\n-            }.normalize(&self.tcx));\n+                scope: self.cur_scope\n+            }.lower(self.tcx));\n         }\n \n         // walk type and init value\n@@ -554,7 +552,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n                 value: val\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n \n \n@@ -577,9 +575,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Some(data) => data,\n         };\n         down_cast_data!(enum_data, EnumData, item.span);\n-        let normalized = enum_data.clone().normalize(&self.tcx);\n-        if !self.span.filter_generated(Some(normalized.span), item.span) {\n-            self.dumper.enum_data(normalized);\n+        if !self.span.filter_generated(Some(enum_data.span), item.span) {\n+            self.dumper.enum_data(enum_data.clone().lower(self.tcx));\n         }\n \n         for variant in &enum_definition.variants {\n@@ -600,7 +597,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n                             scope: enum_data.scope\n-                        }.normalize(&self.tcx));\n+                        }.lower(self.tcx));\n                     }\n                 }\n                 _ => {\n@@ -614,7 +611,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n                             scope: enum_data.scope\n-                        }.normalize(&self.tcx));\n+                        }.lower(self.tcx));\n                     }\n                 }\n             }\n@@ -640,12 +637,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if let Some(ref self_ref) = impl_data.self_ref {\n                 has_self_ref = true;\n                 if !self.span.filter_generated(Some(self_ref.span), item.span) {\n-                    self.dumper.type_ref(self_ref.clone().normalize(&self.tcx));\n+                    self.dumper.type_ref(self_ref.clone().lower(self.tcx));\n                 }\n             }\n             if let Some(ref trait_ref_data) = impl_data.trait_ref {\n                 if !self.span.filter_generated(Some(trait_ref_data.span), item.span) {\n-                    self.dumper.type_ref(trait_ref_data.clone().normalize(&self.tcx));\n+                    self.dumper.type_ref(trait_ref_data.clone().lower(self.tcx));\n                 }\n \n                 visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n@@ -658,7 +655,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     scope: impl_data.scope,\n                     trait_ref: impl_data.trait_ref.map(|d| d.ref_id.unwrap()),\n                     self_ref: impl_data.self_ref.map(|d| d.ref_id.unwrap())\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n         }\n         if !has_self_ref {\n@@ -685,7 +682,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n                 value: val\n-            }.normalize(&self.tcx));\n+            }.lower(self.tcx));\n         }\n \n         // super-traits\n@@ -708,7 +705,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         ref_id: Some(id),\n                         scope: self.cur_scope,\n                         qualname: String::new()\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n \n                 if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n@@ -717,7 +714,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         span: sub_span,\n                         base_id: id,\n                         deriv_id: item.id\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n             }\n         }\n@@ -734,7 +731,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, ModData, item.span);\n             if !self.span.filter_generated(Some(mod_data.span), item.span) {\n-                self.dumper.mod_data(mod_data.normalize(&self.tcx));\n+                self.dumper.mod_data(mod_data.lower(self.tcx));\n             }\n         }\n     }\n@@ -765,42 +762,42 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                 ref_id: Some(vrd.ref_id),\n                                 scope: vrd.scope,\n                                 qualname: String::new()\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         Some(recorder::FnRef) => {\n                             self.dumper.function_ref(FunctionRefData {\n                                 span: vrd.span,\n                                 ref_id: vrd.ref_id,\n                                 scope: vrd.scope\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         Some(recorder::ModRef) => {\n                             self.dumper.mod_ref( ModRefData {\n                                 span: vrd.span,\n                                 ref_id: Some(vrd.ref_id),\n                                 scope: vrd.scope,\n                                 qualname: String::new()\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         Some(recorder::VarRef) | None\n-                            => self.dumper.variable_ref(vrd.normalize(&self.tcx))\n+                            => self.dumper.variable_ref(vrd.lower(self.tcx))\n                     }\n                 }\n \n             }\n             Data::TypeRefData(trd) => {\n                 if !self.span.filter_generated(Some(trd.span), path.span) {\n-                    self.dumper.type_ref(trd.normalize(&self.tcx));\n+                    self.dumper.type_ref(trd.lower(self.tcx));\n                 }\n             }\n             Data::MethodCallData(mcd) => {\n                 if !self.span.filter_generated(Some(mcd.span), path.span) {\n-                    self.dumper.method_call(mcd.normalize(&self.tcx));\n+                    self.dumper.method_call(mcd.lower(self.tcx));\n                 }\n             }\n             Data::FunctionCallData(fcd) => {\n                 if !self.span.filter_generated(Some(fcd.span), path.span) {\n-                    self.dumper.function_call(fcd.normalize(&self.tcx));\n+                    self.dumper.function_call(fcd.lower(self.tcx));\n                 }\n             }\n             _ => {\n@@ -842,7 +839,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n             if !self.span.filter_generated(Some(struct_lit_data.span), ex.span) {\n-                self.dumper.type_ref(struct_lit_data.normalize(&self.tcx));\n+                self.dumper.type_ref(struct_lit_data.lower(self.tcx));\n             }\n \n             let scope = self.save_ctxt.enclosing_scope(ex.id);\n@@ -852,7 +849,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                               .get_field_ref_data(field, variant, scope) {\n \n                     if !self.span.filter_generated(Some(field_data.span), field.ident.span) {\n-                        self.dumper.variable_ref(field_data.normalize(&self.tcx));\n+                        self.dumper.variable_ref(field_data.lower(self.tcx));\n                     }\n                 }\n \n@@ -867,7 +864,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, MethodCallData, ex.span);\n             if !self.span.filter_generated(Some(mcd.span), ex.span) {\n-                self.dumper.method_call(mcd.normalize(&self.tcx));\n+                self.dumper.method_call(mcd.lower(self.tcx));\n             }\n         }\n \n@@ -892,7 +889,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                 ref_id: f.did,\n                                 scope: self.cur_scope,\n                                 name: String::new()\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                     }\n                     self.visit_pat(&field.pat);\n@@ -931,7 +928,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     value: value,\n                     type_value: typ,\n                     scope: 0\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n         }\n     }\n@@ -961,7 +958,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     span: sub_span,\n                     name: data.name.clone(),\n                     qualname: qualname.clone()\n-                });\n+                }.lower(self.tcx));\n             }\n         }\n         if !self.mac_uses.contains(&data.span) {\n@@ -974,7 +971,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     scope: data.scope,\n                     callee_span: data.callee_span,\n                     imported: data.imported\n-                }.normalize(&self.tcx));\n+                }.lower(self.tcx));\n             }\n         }\n     }\n@@ -1014,7 +1011,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                 mod_id: mod_id,\n                                 name: ident.to_string(),\n                                 scope: self.cur_scope\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         self.write_sub_paths_truncated(path, true);\n                     }\n@@ -1037,7 +1034,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                 id: item.id,\n                                 names: names,\n                                 scope: self.cur_scope\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                         self.write_sub_paths(path, true);\n                     }\n@@ -1081,7 +1078,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                         location: location,\n                         span: alias_span.expect(\"No span found for extern crate\"),\n                         scope: self.cur_scope,\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n             }\n             Fn(ref decl, _, _, _, ref ty_params, ref body) =>\n@@ -1115,7 +1112,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                         id: item.id,\n                         qualname: qualname.clone(),\n                         value: value\n-                    }.normalize(&self.tcx));\n+                    }.lower(self.tcx));\n                 }\n \n                 self.visit_ty(&ty);\n@@ -1195,7 +1192,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                             ref_id: Some(id),\n                             scope: self.cur_scope,\n                             qualname: String::new()\n-                        }.normalize(&self.tcx));\n+                        }.lower(self.tcx));\n                     }\n                 }\n \n@@ -1232,7 +1229,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n                     down_cast_data!(field_data, VariableRefData, ex.span);\n                     if !self.span.filter_generated(Some(field_data.span), ex.span) {\n-                        self.dumper.variable_ref(field_data.normalize(&self.tcx));\n+                        self.dumper.variable_ref(field_data.lower(self.tcx));\n                     }\n                 }\n             }\n@@ -1250,7 +1247,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                 ref_id: def.struct_variant().fields[idx.node].did,\n                                 scope: self.cur_scope,\n                                 name: String::new()\n-                            }.normalize(&self.tcx));\n+                            }.lower(self.tcx));\n                         }\n                     }\n                     ty::TyTuple(_) => {}\n@@ -1343,7 +1340,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                             value: value,\n                             type_value: String::new(),\n                             scope: 0\n-                        }.normalize(&self.tcx));\n+                        }.lower(self.tcx));\n                     }\n                 }\n                 Def::Variant(..) | Def::Enum(..) |"}, {"sha": "13923d4646426b88ec7b42efc7dbd15cda144ef5", "filename": "src/librustc_save_analysis/external_data.rs", "status": "added", "additions": 640, "deletions": 0, "changes": 640, "blob_url": "https://github.com/rust-lang/rust/blob/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=dca29d7b0832a5d75db18be96833a8885ef2c2a6", "patch": "@@ -0,0 +1,640 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::{self, Display, Formatter};\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map::Map;\n+use rustc::ty::TyCtxt;\n+use syntax::ast::{CrateNum, NodeId};\n+use syntax::codemap::{Span, CodeMap};\n+\n+use super::data;\n+\n+// FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n+pub trait Lower {\n+    type Target;\n+    fn lower(self, tcx: &TyCtxt) -> Self::Target;\n+}\n+\n+// We use a newtype to enforce conversion of all NodeIds (which are u32s as well)\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable)]\n+pub struct Id(u32);\n+\n+impl Id {\n+    pub fn from_def_id(id: DefId) -> Id {\n+        Id(id.index.as_u32())\n+    }\n+\n+    // FIXME: this function is called with non-local NodeIds. This means that they\n+    // cannot be mapped to a DefId. We should remove those calls. In the meantime,\n+    // we return a \"null Id\" when the NodeId is invalid.\n+    pub fn from_node_id(id: NodeId, map: &Map) -> Id {\n+        map.opt_local_def_id(id).map(|id| Id(id.index.as_u32()))\n+                                .unwrap_or(Id::null())\n+    }\n+\n+    pub fn null() -> Id {\n+        Id(u32::max_value())\n+    }\n+}\n+\n+impl Display for Id {\n+    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct SpanData {\n+    pub file_name: String,\n+    pub byte_start: u32,\n+    pub byte_end: u32,\n+    /// 1-based.\n+    pub line_start: usize,\n+    pub line_end: usize,\n+    /// 1-based, character offset.\n+    pub column_start: usize,\n+    pub column_end: usize,\n+}\n+\n+impl SpanData {\n+    pub fn from_span(span: Span, cm: &CodeMap) -> SpanData {\n+        let start = cm.lookup_char_pos(span.lo);\n+        let end = cm.lookup_char_pos(span.hi);\n+\n+        SpanData {\n+            file_name: start.file.name.clone(),\n+            byte_start: span.lo.0,\n+            byte_end: span.hi.0,\n+            line_start: start.line,\n+            line_end: end.line,\n+            column_start: start.col.0 + 1,\n+            column_end: end.col.0 + 1,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct CratePreludeData {\n+    pub crate_name: String,\n+    pub crate_root: String,\n+    pub external_crates: Vec<data::ExternalCrateData>,\n+    pub span: SpanData,\n+}\n+\n+impl Lower for data::CratePreludeData {\n+    type Target = CratePreludeData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> CratePreludeData {\n+        CratePreludeData {\n+            crate_name: self.crate_name,\n+            crate_root: self.crate_root,\n+            external_crates: self.external_crates,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+        }\n+    }\n+}\n+\n+/// Data for enum declarations.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct EnumData {\n+    pub id: Id,\n+    pub value: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::EnumData {\n+    type Target = EnumData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> EnumData {\n+        EnumData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            value: self.value,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data for extern crates.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ExternCrateData {\n+    pub id: Id,\n+    pub name: String,\n+    pub crate_num: CrateNum,\n+    pub location: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::ExternCrateData {\n+    type Target = ExternCrateData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> ExternCrateData {\n+        ExternCrateData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            name: self.name,\n+            crate_num: self.crate_num,\n+            location: self.location,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data about a function call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct FunctionCallData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Id,\n+}\n+\n+impl Lower for data::FunctionCallData {\n+    type Target = FunctionCallData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> FunctionCallData {\n+        FunctionCallData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            ref_id: Id::from_def_id(self.ref_id),\n+        }\n+    }\n+}\n+\n+/// Data for all kinds of functions and methods.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct FunctionData {\n+    pub id: Id,\n+    pub name: String,\n+    pub qualname: String,\n+    pub declaration: Option<Id>,\n+    pub span: SpanData,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::FunctionData {\n+    type Target = FunctionData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> FunctionData {\n+        FunctionData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            name: self.name,\n+            qualname: self.qualname,\n+            declaration: self.declaration.map(Id::from_def_id),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data about a function call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct FunctionRefData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Id,\n+}\n+\n+impl Lower for data::FunctionRefData {\n+    type Target = FunctionRefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> FunctionRefData {\n+        FunctionRefData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            ref_id: Id::from_def_id(self.ref_id),\n+        }\n+    }\n+}\n+#[derive(Debug, RustcEncodable)]\n+pub struct ImplData {\n+    pub id: Id,\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub trait_ref: Option<Id>,\n+    pub self_ref: Option<Id>,\n+}\n+\n+impl Lower for data::ImplData {\n+    type Target = ImplData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> ImplData {\n+        ImplData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            trait_ref: self.trait_ref.map(Id::from_def_id),\n+            self_ref: self.self_ref.map(Id::from_def_id),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct InheritanceData {\n+    pub span: SpanData,\n+    pub base_id: Id,\n+    pub deriv_id: Id\n+}\n+\n+impl Lower for data::InheritanceData {\n+    type Target = InheritanceData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> InheritanceData {\n+        InheritanceData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            base_id: Id::from_def_id(self.base_id),\n+            deriv_id: Id::from_node_id(self.deriv_id, &tcx.map)\n+        }\n+    }\n+}\n+\n+/// Data about a macro declaration.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MacroData {\n+    pub span: SpanData,\n+    pub name: String,\n+    pub qualname: String,\n+}\n+\n+impl Lower for data::MacroData {\n+    type Target = MacroData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> MacroData {\n+        MacroData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+/// Data about a macro use.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MacroUseData {\n+    pub span: SpanData,\n+    pub name: String,\n+    pub qualname: String,\n+    // Because macro expansion happens before ref-ids are determined,\n+    // we use the callee span to reference the associated macro definition.\n+    pub callee_span: SpanData,\n+    pub scope: Id,\n+    pub imported: bool,\n+}\n+\n+impl Lower for data::MacroUseData {\n+    type Target = MacroUseData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> MacroUseData {\n+        MacroUseData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n+            qualname: self.qualname,\n+            callee_span: SpanData::from_span(self.callee_span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            imported: self.imported,\n+        }\n+    }\n+}\n+\n+/// Data about a method call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MethodCallData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Option<Id>,\n+    pub decl_id: Option<Id>,\n+}\n+\n+impl Lower for data::MethodCallData {\n+    type Target = MethodCallData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> MethodCallData {\n+        MethodCallData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id.map(Id::from_def_id),\n+            decl_id: self.decl_id.map(Id::from_def_id),\n+        }\n+    }\n+}\n+\n+/// Data for method declarations (methods with a body are treated as functions).\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct MethodData {\n+    pub id: Id,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::MethodData {\n+    type Target = MethodData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> MethodData {\n+        MethodData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+/// Data for modules.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ModData {\n+    pub id: Id,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub filename: String,\n+}\n+\n+impl Lower for data::ModData {\n+    type Target = ModData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> ModData {\n+        ModData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            name: self.name,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            filename: self.filename,\n+        }\n+    }\n+}\n+\n+/// Data for a reference to a module.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ModRefData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Option<Id>,\n+    pub qualname: String\n+}\n+\n+impl Lower for data::ModRefData {\n+    type Target = ModRefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> ModRefData {\n+        ModRefData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id.map(Id::from_def_id),\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct StructData {\n+    pub span: SpanData,\n+    pub id: Id,\n+    pub ctor_id: Id,\n+    pub qualname: String,\n+    pub scope: Id,\n+    pub value: String\n+}\n+\n+impl Lower for data::StructData {\n+    type Target = StructData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> StructData {\n+        StructData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            ctor_id: Id::from_node_id(self.ctor_id, &tcx.map),\n+            qualname: self.qualname,\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            value: self.value\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct StructVariantData {\n+    pub span: SpanData,\n+    pub id: Id,\n+    pub qualname: String,\n+    pub type_value: String,\n+    pub value: String,\n+    pub scope: Id\n+}\n+\n+impl Lower for data::StructVariantData {\n+    type Target = StructVariantData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> StructVariantData {\n+        StructVariantData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            qualname: self.qualname,\n+            type_value: self.type_value,\n+            value: self.value,\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct TraitData {\n+    pub span: SpanData,\n+    pub id: Id,\n+    pub qualname: String,\n+    pub scope: Id,\n+    pub value: String\n+}\n+\n+impl Lower for data::TraitData {\n+    type Target = TraitData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> TraitData {\n+        TraitData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            qualname: self.qualname,\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            value: self.value,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct TupleVariantData {\n+    pub span: SpanData,\n+    pub id: Id,\n+    pub name: String,\n+    pub qualname: String,\n+    pub type_value: String,\n+    pub value: String,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::TupleVariantData {\n+    type Target = TupleVariantData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> TupleVariantData {\n+        TupleVariantData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            name: self.name,\n+            qualname: self.qualname,\n+            type_value: self.type_value,\n+            value: self.value,\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data for a typedef.\n+#[derive(Debug, RustcEncodable)]\n+pub struct TypedefData {\n+    pub id: Id,\n+    pub span: SpanData,\n+    pub qualname: String,\n+    pub value: String,\n+}\n+\n+impl Lower for data::TypedefData {\n+    type Target = TypedefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> TypedefData {\n+        TypedefData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            qualname: self.qualname,\n+            value: self.value,\n+        }\n+    }\n+}\n+\n+/// Data for a reference to a type or trait.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct TypeRefData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Option<Id>,\n+    pub qualname: String,\n+}\n+\n+impl Lower for data::TypeRefData {\n+    type Target = TypeRefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> TypeRefData {\n+        TypeRefData {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id.map(Id::from_def_id),\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct UseData {\n+    pub id: Id,\n+    pub span: SpanData,\n+    pub name: String,\n+    pub mod_id: Option<Id>,\n+    pub scope: Id\n+}\n+\n+impl Lower for data::UseData {\n+    type Target = UseData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> UseData {\n+        UseData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            name: self.name,\n+            mod_id: self.mod_id.map(Id::from_def_id),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct UseGlobData {\n+    pub id: Id,\n+    pub span: SpanData,\n+    pub names: Vec<String>,\n+    pub scope: Id\n+}\n+\n+impl Lower for data::UseGlobData {\n+    type Target = UseGlobData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> UseGlobData {\n+        UseGlobData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            names: self.names,\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+        }\n+    }\n+}\n+\n+/// Data for local and global variables (consts and statics).\n+#[derive(Debug, RustcEncodable)]\n+pub struct VariableData {\n+    pub id: Id,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub value: String,\n+    pub type_value: String,\n+}\n+\n+impl Lower for data::VariableData {\n+    type Target = VariableData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> VariableData {\n+        VariableData {\n+            id: Id::from_node_id(self.id, &tcx.map),\n+            name: self.name,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            value: self.value,\n+            type_value: self.type_value,\n+        }\n+    }\n+}\n+\n+/// Data for the use of some item (e.g., the use of a local variable, which\n+/// will refer to that variables declaration (by ref_id)).\n+#[derive(Debug, RustcEncodable)]\n+pub struct VariableRefData {\n+    pub name: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Id,\n+}\n+\n+impl Lower for data::VariableRefData {\n+    type Target = VariableRefData;\n+\n+    fn lower(self, tcx: &TyCtxt) -> VariableRefData {\n+        VariableRefData {\n+            name: self.name,\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            scope: Id::from_node_id(self.scope, &tcx.map),\n+            ref_id: Id::from_def_id(self.ref_id),\n+        }\n+    }\n+}"}, {"sha": "9ad2bcef4ed46601ebfde2496404d18973c093aa", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 8, "deletions": 577, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=dca29d7b0832a5d75db18be96833a8885ef2c2a6", "patch": "@@ -11,29 +11,25 @@\n use std::io::Write;\n \n use rustc_serialize::json::as_json;\n-use syntax::codemap::CodeMap;\n \n-use syntax::ast::CrateNum;\n-\n-use super::data::{self, SpanData};\n+use super::external_data::*;\n use super::dump::Dump;\n \n-pub struct JsonDumper<'a, 'b, W: Write + 'b> {\n+pub struct JsonDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n-    codemap: &'a CodeMap,\n     first: bool,\n }\n \n-impl<'a, 'b, W: Write> JsonDumper<'a, 'b, W> {\n-    pub fn new(writer: &'b mut W, codemap: &'a CodeMap) -> JsonDumper<'a, 'b, W> {\n+impl<'b, W: Write> JsonDumper<'b, W> {\n+    pub fn new(writer: &'b mut W) -> JsonDumper<'b, W> {\n         if let Err(_) = write!(writer, \"[\") {\n             error!(\"Error writing output\");\n         }\n-        JsonDumper { output: writer, codemap:codemap, first: true }\n+        JsonDumper { output: writer, first: true }\n     }\n }\n \n-impl<'a, 'b, W: Write> Drop for JsonDumper<'a, 'b, W> {\n+impl<'b, W: Write> Drop for JsonDumper<'b, W> {\n     fn drop(&mut self) {\n         if let Err(_) = write!(self.output, \"]\") {\n             error!(\"Error writing output\");\n@@ -43,23 +39,22 @@ impl<'a, 'b, W: Write> Drop for JsonDumper<'a, 'b, W> {\n \n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident) => {\n-        fn $fn_name(&mut self, data: data::$data_type) {\n+        fn $fn_name(&mut self, data: $data_type) {\n             if self.first {\n                 self.first = false;\n             } else {\n                 if let Err(_) = write!(self.output, \",\") {\n                     error!(\"Error writing output\");\n                 }\n             }\n-            let data = data.lower(self.codemap);\n             if let Err(_) = write!(self.output, \"{}\", as_json(&data)) {\n                 error!(\"Error writing output '{}'\", as_json(&data));\n             }\n         }\n     }\n }\n \n-impl<'a, 'b, W: Write + 'b> Dump for JsonDumper<'a, 'b, W> {\n+impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n     impl_fn!(crate_prelude, CratePreludeData);\n     impl_fn!(enum_data, EnumData);\n     impl_fn!(extern_crate, ExternCrateData);\n@@ -85,567 +80,3 @@ impl<'a, 'b, W: Write + 'b> Dump for JsonDumper<'a, 'b, W> {\n     impl_fn!(variable, VariableData);\n     impl_fn!(variable_ref, VariableRefData);\n }\n-\n-trait Lower {\n-    type Target;\n-    fn lower(self, cm: &CodeMap) -> Self::Target;\n-}\n-\n-pub type Id = u32;\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct CratePreludeData {\n-    pub crate_name: String,\n-    pub crate_root: String,\n-    pub external_crates: Vec<data::ExternalCrateData>,\n-    pub span: SpanData,\n-}\n-\n-impl Lower for data::CratePreludeData {\n-    type Target = CratePreludeData;\n-\n-    fn lower(self, cm: &CodeMap) -> CratePreludeData {\n-        CratePreludeData {\n-            crate_name: self.crate_name,\n-            crate_root: self.crate_root,\n-            external_crates: self.external_crates,\n-            span: SpanData::from_span(self.span, cm),\n-        }\n-    }\n-}\n-\n-/// Data for enum declarations.\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct EnumData {\n-    pub id: Id,\n-    pub value: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::EnumData {\n-    type Target = EnumData;\n-\n-    fn lower(self, cm: &CodeMap) -> EnumData {\n-        EnumData {\n-            id: self.id,\n-            value: self.value,\n-            qualname: self.qualname,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data for extern crates.\n-#[derive(Debug, RustcEncodable)]\n-pub struct ExternCrateData {\n-    pub id: Id,\n-    pub name: String,\n-    pub crate_num: CrateNum,\n-    pub location: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::ExternCrateData {\n-    type Target = ExternCrateData;\n-\n-    fn lower(self, cm: &CodeMap) -> ExternCrateData {\n-        ExternCrateData {\n-            id: self.id,\n-            name: self.name,\n-            crate_num: self.crate_num,\n-            location: self.location,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n-pub struct FunctionCallData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n-}\n-\n-impl Lower for data::FunctionCallData {\n-    type Target = FunctionCallData;\n-\n-    fn lower(self, cm: &CodeMap) -> FunctionCallData {\n-        FunctionCallData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.index.as_u32(),\n-        }\n-    }\n-}\n-\n-/// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct FunctionData {\n-    pub id: Id,\n-    pub name: String,\n-    pub qualname: String,\n-    pub declaration: Option<Id>,\n-    pub span: SpanData,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::FunctionData {\n-    type Target = FunctionData;\n-\n-    fn lower(self, cm: &CodeMap) -> FunctionData {\n-        FunctionData {\n-            id: self.id,\n-            name: self.name,\n-            qualname: self.qualname,\n-            declaration: self.declaration.map(|id| id.index.as_u32()),\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n-pub struct FunctionRefData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n-}\n-\n-impl Lower for data::FunctionRefData {\n-    type Target = FunctionRefData;\n-\n-    fn lower(self, cm: &CodeMap) -> FunctionRefData {\n-        FunctionRefData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.index.as_u32(),\n-        }\n-    }\n-}\n-#[derive(Debug, RustcEncodable)]\n-pub struct ImplData {\n-    pub id: Id,\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub trait_ref: Option<Id>,\n-    pub self_ref: Option<Id>,\n-}\n-\n-impl Lower for data::ImplData {\n-    type Target = ImplData;\n-\n-    fn lower(self, cm: &CodeMap) -> ImplData {\n-        ImplData {\n-            id: self.id,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            trait_ref: self.trait_ref.map(|id| id.index.as_u32()),\n-            self_ref: self.self_ref.map(|id| id.index.as_u32()),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct InheritanceData {\n-    pub span: SpanData,\n-    pub base_id: Id,\n-    pub deriv_id: Id\n-}\n-\n-impl Lower for data::InheritanceData {\n-    type Target = InheritanceData;\n-\n-    fn lower(self, cm: &CodeMap) -> InheritanceData {\n-        InheritanceData {\n-            span: SpanData::from_span(self.span, cm),\n-            base_id: self.base_id.index.as_u32(),\n-            deriv_id: self.deriv_id\n-        }\n-    }\n-}\n-\n-/// Data about a macro declaration.\n-#[derive(Debug, RustcEncodable)]\n-pub struct MacroData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub qualname: String,\n-}\n-\n-impl Lower for data::MacroData {\n-    type Target = MacroData;\n-\n-    fn lower(self, cm: &CodeMap) -> MacroData {\n-        MacroData {\n-            span: SpanData::from_span(self.span, cm),\n-            name: self.name,\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-/// Data about a macro use.\n-#[derive(Debug, RustcEncodable)]\n-pub struct MacroUseData {\n-    pub span: SpanData,\n-    pub name: String,\n-    pub qualname: String,\n-    // Because macro expansion happens before ref-ids are determined,\n-    // we use the callee span to reference the associated macro definition.\n-    pub callee_span: SpanData,\n-    pub scope: Id,\n-    pub imported: bool,\n-}\n-\n-impl Lower for data::MacroUseData {\n-    type Target = MacroUseData;\n-\n-    fn lower(self, cm: &CodeMap) -> MacroUseData {\n-        MacroUseData {\n-            span: SpanData::from_span(self.span, cm),\n-            name: self.name,\n-            qualname: self.qualname,\n-            callee_span: SpanData::from_span(self.callee_span, cm),\n-            scope: self.scope,\n-            imported: self.imported,\n-        }\n-    }\n-}\n-\n-/// Data about a method call.\n-#[derive(Debug, RustcEncodable)]\n-pub struct MethodCallData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n-    pub decl_id: Option<Id>,\n-}\n-\n-impl Lower for data::MethodCallData {\n-    type Target = MethodCallData;\n-\n-    fn lower(self, cm: &CodeMap) -> MethodCallData {\n-        MethodCallData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n-            decl_id: self.decl_id.map(|id| id.index.as_u32()),\n-        }\n-    }\n-}\n-\n-/// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct MethodData {\n-    pub id: Id,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::MethodData {\n-    type Target = MethodData;\n-\n-    fn lower(self, cm: &CodeMap) -> MethodData {\n-        MethodData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            id: self.id,\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-/// Data for modules.\n-#[derive(Debug, RustcEncodable)]\n-pub struct ModData {\n-    pub id: Id,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub filename: String,\n-}\n-\n-impl Lower for data::ModData {\n-    type Target = ModData;\n-\n-    fn lower(self, cm: &CodeMap) -> ModData {\n-        ModData {\n-            id: self.id,\n-            name: self.name,\n-            qualname: self.qualname,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            filename: self.filename,\n-        }\n-    }\n-}\n-\n-/// Data for a reference to a module.\n-#[derive(Debug, RustcEncodable)]\n-pub struct ModRefData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n-    pub qualname: String\n-}\n-\n-impl Lower for data::ModRefData {\n-    type Target = ModRefData;\n-\n-    fn lower(self, cm: &CodeMap) -> ModRefData {\n-        ModRefData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct StructData {\n-    pub span: SpanData,\n-    pub id: Id,\n-    pub ctor_id: Id,\n-    pub qualname: String,\n-    pub scope: Id,\n-    pub value: String\n-}\n-\n-impl Lower for data::StructData {\n-    type Target = StructData;\n-\n-    fn lower(self, cm: &CodeMap) -> StructData {\n-        StructData {\n-            span: SpanData::from_span(self.span, cm),\n-            id: self.id,\n-            ctor_id: self.ctor_id,\n-            qualname: self.qualname,\n-            scope: self.scope,\n-            value: self.value\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct StructVariantData {\n-    pub span: SpanData,\n-    pub id: Id,\n-    pub qualname: String,\n-    pub type_value: String,\n-    pub value: String,\n-    pub scope: Id\n-}\n-\n-impl Lower for data::StructVariantData {\n-    type Target = StructVariantData;\n-\n-    fn lower(self, cm: &CodeMap) -> StructVariantData {\n-        StructVariantData {\n-            span: SpanData::from_span(self.span, cm),\n-            id: self.id,\n-            qualname: self.qualname,\n-            type_value: self.type_value,\n-            value: self.value,\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct TraitData {\n-    pub span: SpanData,\n-    pub id: Id,\n-    pub qualname: String,\n-    pub scope: Id,\n-    pub value: String\n-}\n-\n-impl Lower for data::TraitData {\n-    type Target = TraitData;\n-\n-    fn lower(self, cm: &CodeMap) -> TraitData {\n-        TraitData {\n-            span: SpanData::from_span(self.span, cm),\n-            id: self.id,\n-            qualname: self.qualname,\n-            scope: self.scope,\n-            value: self.value,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct TupleVariantData {\n-    pub span: SpanData,\n-    pub id: Id,\n-    pub name: String,\n-    pub qualname: String,\n-    pub type_value: String,\n-    pub value: String,\n-    pub scope: Id,\n-}\n-\n-impl Lower for data::TupleVariantData {\n-    type Target = TupleVariantData;\n-\n-    fn lower(self, cm: &CodeMap) -> TupleVariantData {\n-        TupleVariantData {\n-            span: SpanData::from_span(self.span, cm),\n-            id: self.id,\n-            name: self.name,\n-            qualname: self.qualname,\n-            type_value: self.type_value,\n-            value: self.value,\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data for a typedef.\n-#[derive(Debug, RustcEncodable)]\n-pub struct TypedefData {\n-    pub id: Id,\n-    pub span: SpanData,\n-    pub qualname: String,\n-    pub value: String,\n-}\n-\n-impl Lower for data::TypedefData {\n-    type Target = TypedefData;\n-\n-    fn lower(self, cm: &CodeMap) -> TypedefData {\n-        TypedefData {\n-            id: self.id,\n-            span: SpanData::from_span(self.span, cm),\n-            qualname: self.qualname,\n-            value: self.value,\n-        }\n-    }\n-}\n-\n-/// Data for a reference to a type or trait.\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct TypeRefData {\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n-    pub qualname: String,\n-}\n-\n-impl Lower for data::TypeRefData {\n-    type Target = TypeRefData;\n-\n-    fn lower(self, cm: &CodeMap) -> TypeRefData {\n-        TypeRefData {\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n-            qualname: self.qualname,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct UseData {\n-    pub id: Id,\n-    pub span: SpanData,\n-    pub name: String,\n-    pub mod_id: Option<Id>,\n-    pub scope: Id\n-}\n-\n-impl Lower for data::UseData {\n-    type Target = UseData;\n-\n-    fn lower(self, cm: &CodeMap) -> UseData {\n-        UseData {\n-            id: self.id,\n-            span: SpanData::from_span(self.span, cm),\n-            name: self.name,\n-            mod_id: self.mod_id.map(|id| id.index.as_u32()),\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct UseGlobData {\n-    pub id: Id,\n-    pub span: SpanData,\n-    pub names: Vec<String>,\n-    pub scope: Id\n-}\n-\n-impl Lower for data::UseGlobData {\n-    type Target = UseGlobData;\n-\n-    fn lower(self, cm: &CodeMap) -> UseGlobData {\n-        UseGlobData {\n-            id: self.id,\n-            span: SpanData::from_span(self.span, cm),\n-            names: self.names,\n-            scope: self.scope,\n-        }\n-    }\n-}\n-\n-/// Data for local and global variables (consts and statics).\n-#[derive(Debug, RustcEncodable)]\n-pub struct VariableData {\n-    pub id: Id,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub value: String,\n-    pub type_value: String,\n-}\n-\n-impl Lower for data::VariableData {\n-    type Target = VariableData;\n-\n-    fn lower(self, cm: &CodeMap) -> VariableData {\n-        VariableData {\n-            id: self.id,\n-            name: self.name,\n-            qualname: self.qualname,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            value: self.value,\n-            type_value: self.type_value,\n-        }\n-    }\n-}\n-\n-/// Data for the use of some item (e.g., the use of a local variable, which\n-/// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug, RustcEncodable)]\n-pub struct VariableRefData {\n-    pub name: String,\n-    pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n-}\n-\n-impl Lower for data::VariableRefData {\n-    type Target = VariableRefData;\n-\n-    fn lower(self, cm: &CodeMap) -> VariableRefData {\n-        VariableRefData {\n-            name: self.name,\n-            span: SpanData::from_span(self.span, cm),\n-            scope: self.scope,\n-            ref_id: self.ref_id.index.as_u32(),\n-        }\n-    }\n-}"}, {"sha": "906923e5cad9586da1f860b02f1dcb829ec54717", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=dca29d7b0832a5d75db18be96833a8885ef2c2a6", "patch": "@@ -28,6 +28,15 @@\n #[macro_use] extern crate syntax;\n extern crate serialize as rustc_serialize;\n \n+mod csv_dumper;\n+mod json_dumper;\n+mod data;\n+mod dump;\n+mod dump_visitor;\n+pub mod external_data;\n+#[macro_use]\n+pub mod span_utils;\n+\n use rustc::hir;\n use rustc::hir::map::NodeItem;\n use rustc::hir::def::Def;\n@@ -45,14 +54,6 @@ use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n-mod csv_dumper;\n-mod json_dumper;\n-mod data;\n-mod dump;\n-mod dump_visitor;\n-#[macro_use]\n-pub mod span_utils;\n-\n pub use self::csv_dumper::CsvDumper;\n pub use self::json_dumper::JsonDumper;\n pub use self::data::*;\n@@ -748,7 +749,6 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     root_path.pop();\n     let output = &mut output_file;\n \n-    let utils: SpanUtils<'tcx> = SpanUtils::new(&tcx.sess);\n     let save_ctxt = SaveContext::new(tcx);\n \n     macro_rules! dump {\n@@ -762,8 +762,8 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     }\n \n     match format {\n-        Format::Csv => dump!(CsvDumper::new(output, utils)),\n-        Format::Json => dump!(JsonDumper::new(output, utils.sess.codemap())),\n+        Format::Csv => dump!(CsvDumper::new(output)),\n+        Format::Json => dump!(JsonDumper::new(output)),\n     }\n }\n "}, {"sha": "3028fb1bfa423e87cb924aff05ae4bef36ea9b9f", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca29d7b0832a5d75db18be96833a8885ef2c2a6/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=dca29d7b0832a5d75db18be96833a8885ef2c2a6", "patch": "@@ -18,10 +18,8 @@ use std::path::Path;\n \n use syntax::ast;\n use syntax::codemap::*;\n-use syntax::parse::lexer;\n-use syntax::parse::lexer::{Reader, StringReader};\n-use syntax::parse::token;\n-use syntax::parse::token::{keywords, Token};\n+use syntax::parse::lexer::{self, Reader, StringReader};\n+use syntax::parse::token::{self, keywords, Token};\n \n #[derive(Clone)]\n pub struct SpanUtils<'a> {\n@@ -48,23 +46,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    // Standard string for extents/location.\n-    #[rustfmt_skip]\n-    pub fn extent_str(&self, span: Span) -> String {\n-        let lo_loc = self.sess.codemap().lookup_char_pos(span.lo);\n-        let hi_loc = self.sess.codemap().lookup_char_pos(span.hi);\n-        let lo_pos = self.sess.codemap().bytepos_to_file_charpos(span.lo);\n-        let hi_pos = self.sess.codemap().bytepos_to_file_charpos(span.hi);\n-        let lo_pos_byte = self.sess.codemap().lookup_byte_offset(span.lo).pos;\n-        let hi_pos_byte = self.sess.codemap().lookup_byte_offset(span.hi).pos;\n-\n-        format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n-                 file_line_end,{},file_col_end,{},extent_end,{},extent_end_bytes,{}\",\n-                SpanUtils::make_path_string(&lo_loc.file.name),\n-                lo_loc.line, lo_loc.col.to_usize(), lo_pos.to_usize(), lo_pos_byte.to_usize(),\n-                hi_loc.line, hi_loc.col.to_usize(), hi_pos.to_usize(), hi_pos_byte.to_usize())\n-    }\n-\n     // sub_span starts at span.lo, so we need to adjust the positions etc.\n     // If sub_span is None, we don't need to adjust.\n     pub fn make_sub_span(&self, span: Span, sub_span: Option<Span>) -> Option<Span> {"}]}