{"sha": "cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMjY5MTliNGRjZmJiMzFhMGViOTAyZThjZjNlMDA5YTkzZTVhYzg=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2020-12-30T21:52:15Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-01-08T20:49:59Z"}, "message": "Add unnecessary symbol string lint", "tree": {"sha": "46fb4166ac279067aff2259bfdf8436694df54ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46fb4166ac279067aff2259bfdf8436694df54ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "html_url": "https://github.com/rust-lang/rust/commit/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76ccfb4ae24e1b6f3398e5cca350e41e76723fb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/76ccfb4ae24e1b6f3398e5cca350e41e76723fb1", "html_url": "https://github.com/rust-lang/rust/commit/76ccfb4ae24e1b6f3398e5cca350e41e76723fb1"}], "stats": {"total": 235, "additions": 233, "deletions": 2}, "files": [{"sha": "f12994c7a605e21a7e8cafde3bd1cd7d489672c5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "patch": "@@ -526,6 +526,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n         #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::PRODUCE_ICE,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n         &approx_const::APPROX_CONSTANT,\n         &arithmetic::FLOAT_ARITHMETIC,\n         &arithmetic::INTEGER_ARITHMETIC,\n@@ -1372,6 +1374,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n         LintId::of(&utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n         LintId::of(&utils::internal_lints::PRODUCE_ICE),\n+        LintId::of(&utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n     ]);\n \n     store.register_group(true, \"clippy::all\", Some(\"clippy\"), vec!["}, {"sha": "59a1852aba9219563ee1e36b8ee970ca210cbc33", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 151, "deletions": 2, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "patch": "@@ -13,7 +13,9 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n+use rustc_hir::{\n+    BinOpKind, Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind, UnOp,\n+};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::mir::interpret::ConstValue;\n@@ -273,6 +275,28 @@ declare_clippy_lint! {\n     \"interning a symbol that is pre-interned and defined as a constant\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for unnecessary conversion from Symbol to a string.\n+    ///\n+    /// **Why is this bad?** It's faster use symbols directly intead of strings.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// symbol.as_str() == \"clippy\";\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// symbol == sym::clippy;\n+    /// ```\n+    pub UNNECESSARY_SYMBOL_STR,\n+    internal,\n+    \"unnecessary conversion between Symbol and string\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -873,7 +897,7 @@ pub struct InterningDefinedSymbol {\n     symbol_map: FxHashMap<u32, DefId>,\n }\n \n-impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL]);\n+impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n \n impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n     fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n@@ -919,5 +943,130 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n                 );\n             }\n         }\n+        if let ExprKind::Binary(op, left, right) = expr.kind {\n+            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n+                let data = [\n+                    (left, self.symbol_str_expr(left, cx)),\n+                    (right, self.symbol_str_expr(right, cx)),\n+                ];\n+                match data {\n+                    // both operands are a symbol string\n+                    [(_, Some(left)), (_, Some(right))] => {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_SYMBOL_STR,\n+                            expr.span,\n+                            \"unnecessary `Symbol` to string conversion\",\n+                            \"try\",\n+                            format!(\n+                                \"{} {} {}\",\n+                                left.as_symbol_snippet(cx),\n+                                op.node.as_str(),\n+                                right.as_symbol_snippet(cx),\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                    // one of the operands is a symbol string\n+                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n+                        // creating an owned string for comparison\n+                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                UNNECESSARY_SYMBOL_STR,\n+                                expr.span,\n+                                \"unnecessary string allocation\",\n+                                \"try\",\n+                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    },\n+                    // nothing found\n+                    [(_, None), (_, None)] => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl InterningDefinedSymbol {\n+    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n+        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n+        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n+            &paths::SYMBOL_AS_STR,\n+            &paths::SYMBOL_TO_IDENT_STRING,\n+            &paths::TO_STRING_METHOD,\n+        ];\n+        // SymbolStr might be de-referenced: `&*symbol.as_str()`\n+        let call = if_chain! {\n+            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n+            if let ExprKind::Unary(UnOp::UnDeref, e) = e.kind;\n+            then { e } else { expr }\n+        };\n+        if_chain! {\n+            // is a method call\n+            if let ExprKind::MethodCall(_, _, [item], _) = call.kind;\n+            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n+            let ty = cx.typeck_results().expr_ty(item);\n+            // ...on either an Ident or a Symbol\n+            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n+                Some(false)\n+            } else if match_type(cx, ty, &paths::IDENT) {\n+                Some(true)\n+            } else {\n+                None\n+            };\n+            // ...which converts it to a string\n+            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n+            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n+            then {\n+                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n+                return Some(SymbolStrExpr::Expr {\n+                    item,\n+                    is_ident,\n+                    is_to_owned,\n+                });\n+            }\n+        }\n+        // is a string constant\n+        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n+            let value = Symbol::intern(&s).as_u32();\n+            // ...which matches a symbol constant\n+            if let Some(&def_id) = self.symbol_map.get(&value) {\n+                return Some(SymbolStrExpr::Const(def_id));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+enum SymbolStrExpr<'tcx> {\n+    /// a string constant with a corresponding symbol constant\n+    Const(DefId),\n+    /// a \"symbol to string\" expression like `symbol.as_str()`\n+    Expr {\n+        /// part that evaluates to `Symbol` or `Ident`\n+        item: &'tcx Expr<'tcx>,\n+        is_ident: bool,\n+        /// whether an owned `String` is created like `to_ident_string()`\n+        is_to_owned: bool,\n+    },\n+}\n+\n+impl<'tcx> SymbolStrExpr<'tcx> {\n+    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n+    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n+        match *self {\n+            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n+            Self::Expr { item, is_ident, .. } => {\n+                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n+                if is_ident {\n+                    // get `Ident.name`\n+                    snip.to_mut().push_str(\".name\");\n+                }\n+                snip\n+            },\n+        }\n     }\n }"}, {"sha": "c0b203b5388dce969ecb3a77662022d32d2532b8", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "patch": "@@ -54,6 +54,10 @@ pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n@@ -150,8 +154,12 @@ pub const STR_STARTS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"starts_wit\n #[cfg(feature = \"internal-lints\")]\n pub const SYMBOL: [&str; 3] = [\"rustc_span\", \"symbol\", \"Symbol\"];\n #[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"as_str\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const SYMBOL_INTERN: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"intern\"];\n #[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL_TO_IDENT_STRING: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"to_ident_string\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const SYM_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"sym\"];\n #[cfg(feature = \"internal-lints\")]\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];"}, {"sha": "2ec0efe4c10a5125ed60d9220ebdb419bc78214a", "filename": "tests/ui-internal/unnecessary_symbol_str.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/tests%2Fui-internal%2Funnecessary_symbol_str.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/tests%2Fui-internal%2Funnecessary_symbol_str.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.fixed?ref=cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![feature(rustc_private)]\n+#![deny(clippy::internal)]\n+#![allow(clippy::unnecessary_operation, unused_must_use)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+fn main() {\n+    Symbol::intern(\"foo\") == rustc_span::sym::clippy;\n+    Symbol::intern(\"foo\") == rustc_span::symbol::kw::SelfLower;\n+    Symbol::intern(\"foo\") != rustc_span::symbol::kw::SelfUpper;\n+    Ident::invalid().name == rustc_span::sym::clippy;\n+    rustc_span::sym::clippy == Ident::invalid().name;\n+}"}, {"sha": "87e1b3a2ee76a9ebd8d53268d29835a5a3904a34", "filename": "tests/ui-internal/unnecessary_symbol_str.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/tests%2Fui-internal%2Funnecessary_symbol_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/tests%2Fui-internal%2Funnecessary_symbol_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.rs?ref=cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![feature(rustc_private)]\n+#![deny(clippy::internal)]\n+#![allow(clippy::unnecessary_operation, unused_must_use)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+fn main() {\n+    Symbol::intern(\"foo\").as_str() == \"clippy\";\n+    Symbol::intern(\"foo\").to_string() == \"self\";\n+    Symbol::intern(\"foo\").to_ident_string() != \"Self\";\n+    &*Ident::invalid().as_str() == \"clippy\";\n+    \"clippy\" == Ident::invalid().to_string();\n+}"}, {"sha": "b1284b7c8ffd036393046ea09ab8dcebd6abe0cd", "filename": "tests/ui-internal/unnecessary_symbol_str.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/tests%2Fui-internal%2Funnecessary_symbol_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8/tests%2Fui-internal%2Funnecessary_symbol_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.stderr?ref=cc26919b4dcfbb31a0eb902e8cf3e009a93e5ac8", "patch": "@@ -0,0 +1,39 @@\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:11:5\n+   |\n+LL |     Symbol::intern(\"foo\").as_str() == \"clippy\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") == rustc_span::sym::clippy`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unnecessary_symbol_str.rs:3:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::unnecessary_symbol_str)]` implied by `#[deny(clippy::internal)]`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:12:5\n+   |\n+LL |     Symbol::intern(\"foo\").to_string() == \"self\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") == rustc_span::symbol::kw::SelfLower`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:13:5\n+   |\n+LL |     Symbol::intern(\"foo\").to_ident_string() != \"Self\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") != rustc_span::symbol::kw::SelfUpper`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:14:5\n+   |\n+LL |     &*Ident::invalid().as_str() == \"clippy\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Ident::invalid().name == rustc_span::sym::clippy`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:15:5\n+   |\n+LL |     \"clippy\" == Ident::invalid().to_string();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::clippy == Ident::invalid().name`\n+\n+error: aborting due to 5 previous errors\n+"}]}