{"sha": "47b05278d0679802f271e3f73cb22979dfc229de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YjA1Mjc4ZDA2Nzk4MDJmMjcxZTNmNzNjYjIyOTc5ZGZjMjI5ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-20T11:11:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-20T11:11:48Z"}, "message": "auto merge of #12397 : alexcrichton/rust/send-off-the-runtime, r=brson\n\nThe fairness yield mistakenly called `Local::take()` which meant that it would\r\nonly work if a local task was available. In theory sending on a channel (or calling try_recv) requires\r\nno runtime because it never blocks, so there's no reason it shouldn't support\r\nsuch a use case.\r\n\r\nCloses #12391", "tree": {"sha": "a5b2e125d87e11968285c52a2c7ed37651e99b84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5b2e125d87e11968285c52a2c7ed37651e99b84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47b05278d0679802f271e3f73cb22979dfc229de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47b05278d0679802f271e3f73cb22979dfc229de", "html_url": "https://github.com/rust-lang/rust/commit/47b05278d0679802f271e3f73cb22979dfc229de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47b05278d0679802f271e3f73cb22979dfc229de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25ba057fad54da946bb3d72925c9a93b0abe61ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/25ba057fad54da946bb3d72925c9a93b0abe61ac", "html_url": "https://github.com/rust-lang/rust/commit/25ba057fad54da946bb3d72925c9a93b0abe61ac"}, {"sha": "765a4e9fe35014eed3c7f60f8c7030ecb537871b", "url": "https://api.github.com/repos/rust-lang/rust/commits/765a4e9fe35014eed3c7f60f8c7030ecb537871b", "html_url": "https://github.com/rust-lang/rust/commit/765a4e9fe35014eed3c7f60f8c7030ecb537871b"}], "stats": {"total": 59, "additions": 49, "deletions": 10}, "files": [{"sha": "145bee50a203696548b2b916eeb7262a8663e4ea", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/47b05278d0679802f271e3f73cb22979dfc229de/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b05278d0679802f271e3f73cb22979dfc229de/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=47b05278d0679802f271e3f73cb22979dfc229de", "patch": "@@ -385,17 +385,17 @@ impl<T: Send> Chan<T> {\n     pub fn try_send(&self, t: T) -> bool {\n         // In order to prevent starvation of other tasks in situations where\n         // a task sends repeatedly without ever receiving, we occassionally\n-        // yield instead of doing a send immediately.  Only doing this if\n-        // we're doing a rescheduling send, otherwise the caller is\n-        // expecting not to context switch.\n+        // yield instead of doing a send immediately.\n         //\n-        // Note that we don't unconditionally attempt to yield because the\n-        // TLS overhead can be a bit much.\n+        // Don't unconditionally attempt to yield because the TLS overhead can\n+        // be a bit much, and also use `try_take` instead of `take` because\n+        // there's no reason that this send shouldn't be usable off the\n+        // runtime.\n         let cnt = self.sends.get() + 1;\n         self.sends.set(cnt);\n         if cnt % (RESCHED_FREQ as uint) == 0 {\n-            let task: ~Task = Local::take();\n-            task.maybe_yield();\n+            let task: Option<~Task> = Local::try_take();\n+            task.map(|t| t.maybe_yield());\n         }\n \n         let (new_inner, ret) = match self.inner {\n@@ -521,12 +521,13 @@ impl<T: Send> Port<T> {\n     pub fn try_recv(&self) -> TryRecvResult<T> {\n         // If a thread is spinning in try_recv, we should take the opportunity\n         // to reschedule things occasionally. See notes above in scheduling on\n-        // sends for why this doesn't always hit TLS.\n+        // sends for why this doesn't always hit TLS, and also for why this uses\n+        // `try_take` instead of `take`.\n         let cnt = self.receives.get() + 1;\n         self.receives.set(cnt);\n         if cnt % (RESCHED_FREQ as uint) == 0 {\n-            let task: ~Task = Local::take();\n-            task.maybe_yield();\n+            let task: Option<~Task> = Local::try_take();\n+            task.map(|t| t.maybe_yield());\n         }\n \n         loop {\n@@ -1203,4 +1204,42 @@ mod test {\n         // wait for the child task to exit before we exit\n         p1.recv();\n     })\n+\n+    test!(fn sends_off_the_runtime() {\n+        use rt::thread::Thread;\n+\n+        let (p, c) = Chan::new();\n+        let t = Thread::start(proc() {\n+            for _ in range(0, 1000) {\n+                c.send(());\n+            }\n+        });\n+        for _ in range(0, 1000) {\n+            p.recv();\n+        }\n+        t.join();\n+    })\n+\n+    test!(fn try_recvs_off_the_runtime() {\n+        use rt::thread::Thread;\n+\n+        let (p, c) = Chan::new();\n+        let (pdone, cdone) = Chan::new();\n+        let t = Thread::start(proc() {\n+            let mut hits = 0;\n+            while hits < 10 {\n+                match p.try_recv() {\n+                    Data(()) => { hits += 1; }\n+                    Empty => { Thread::yield_now(); }\n+                    Disconnected => return,\n+                }\n+            }\n+            cdone.send(());\n+        });\n+        for _ in range(0, 10) {\n+            c.send(());\n+        }\n+        t.join();\n+        pdone.recv();\n+    })\n }"}]}