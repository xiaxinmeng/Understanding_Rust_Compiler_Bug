{"sha": "1acb556907027622a07189aefa627502f6500b5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhY2I1NTY5MDcwMjc2MjJhMDcxODlhZWZhNjI3NTAyZjY1MDBiNWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-08T20:37:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T20:37:14Z"}, "message": "Merge #4379\n\n4379: Handle coercing function types to function pointers in match r=matklad a=flodiebold\n\nE.g. in\r\n```rust\r\nmatch x {\r\n    1 => function1,\r\n    2 => function2,\r\n}\r\n```\r\nwe need to try coercing both to pointers. Turns out this is a special case in\r\nrustc as well (see the link in the comment).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "e82b33ba64c1e0b36b33470d4d516200c2924d49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e82b33ba64c1e0b36b33470d4d516200c2924d49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1acb556907027622a07189aefa627502f6500b5a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetcL6CRBK7hj4Ov3rIwAAdHIIABcG3hstYSFjl7/dfov9muuv\n9XyHAnjBQGibTztLCGxBQSlT8NO8RR3dXQwjCvnWBP7+BTqyacz/dzhfRfeG8XTq\nYh8bKkj+wQ16ZDKskalSclr36gJkul63InSGTl2fl7toq1ygOhnz3OgwTLjM00n3\nfufXgSmRg7KYMD8fXaWc24KttFGW3Tw4EbB3BpL+28XQbJthLbUTzI6HmRvjYr5B\nKe7MRUwOQ+Z/CI/UW8irOOWGZ/gLnG2ZHtQ4myogJ/Znh1HdZWSXg7akutIFPnw8\nl/OZBsSMip6OetW72E2XqnJYdTRM0LA/CU2eu+0BSKwFLKpEk+MDnBsSbxc5BQA=\n=+Xex\n-----END PGP SIGNATURE-----\n", "payload": "tree e82b33ba64c1e0b36b33470d4d516200c2924d49\nparent f9ec7cebef732fbc9d4849d87d325efef5faadea\nparent a3d866e776f43c1ae717740bf0c507f4d9fe47cb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588970234 +0000\ncommitter GitHub <noreply@github.com> 1588970234 +0000\n\nMerge #4379\n\n4379: Handle coercing function types to function pointers in match r=matklad a=flodiebold\n\nE.g. in\r\n```rust\r\nmatch x {\r\n    1 => function1,\r\n    2 => function2,\r\n}\r\n```\r\nwe need to try coercing both to pointers. Turns out this is a special case in\r\nrustc as well (see the link in the comment).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1acb556907027622a07189aefa627502f6500b5a", "html_url": "https://github.com/rust-lang/rust/commit/1acb556907027622a07189aefa627502f6500b5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1acb556907027622a07189aefa627502f6500b5a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9ec7cebef732fbc9d4849d87d325efef5faadea", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ec7cebef732fbc9d4849d87d325efef5faadea", "html_url": "https://github.com/rust-lang/rust/commit/f9ec7cebef732fbc9d4849d87d325efef5faadea"}, {"sha": "a3d866e776f43c1ae717740bf0c507f4d9fe47cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d866e776f43c1ae717740bf0c507f4d9fe47cb", "html_url": "https://github.com/rust-lang/rust/commit/a3d866e776f43c1ae717740bf0c507f4d9fe47cb"}], "stats": {"total": 83, "additions": 72, "deletions": 11}, "files": [{"sha": "173ec59edf6ceebb646524a4f5e5a89ca2f68b2a", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1acb556907027622a07189aefa627502f6500b5a/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acb556907027622a07189aefa627502f6500b5a/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=1acb556907027622a07189aefa627502f6500b5a", "patch": "@@ -20,21 +20,35 @@ impl<'a> InferenceContext<'a> {\n         self.coerce_inner(from_ty, &to_ty)\n     }\n \n-    /// Merge two types from different branches, with possible implicit coerce.\n+    /// Merge two types from different branches, with possible coercion.\n     ///\n-    /// Note that it is only possible that one type are coerced to another.\n-    /// Coercing both types to another least upper bound type is not possible in rustc,\n-    /// which will simply result in \"incompatible types\" error.\n+    /// Mostly this means trying to coerce one to the other, but\n+    ///  - if we have two function types for different functions, we need to\n+    ///    coerce both to function pointers;\n+    ///  - if we were concerned with lifetime subtyping, we'd need to look for a\n+    ///    least upper bound.\n     pub(super) fn coerce_merge_branch(&mut self, ty1: &Ty, ty2: &Ty) -> Ty {\n         if self.coerce(ty1, ty2) {\n             ty2.clone()\n         } else if self.coerce(ty2, ty1) {\n             ty1.clone()\n         } else {\n-            tested_by!(coerce_merge_fail_fallback);\n-            // For incompatible types, we use the latter one as result\n-            // to be better recovery for `if` without `else`.\n-            ty2.clone()\n+            if let (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnDef(_))) = (ty1, ty2) {\n+                tested_by!(coerce_fn_reification);\n+                // Special case: two function types. Try to coerce both to\n+                // pointers to have a chance at getting a match. See\n+                // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n+                let sig1 = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let sig2 = ty2.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let ptr_ty1 = Ty::fn_ptr(sig1);\n+                let ptr_ty2 = Ty::fn_ptr(sig2);\n+                self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n+            } else {\n+                tested_by!(coerce_merge_fail_fallback);\n+                // For incompatible types, we use the latter one as result\n+                // to be better recovery for `if` without `else`.\n+                ty2.clone()\n+            }\n         }\n     }\n \n@@ -84,9 +98,7 @@ impl<'a> InferenceContext<'a> {\n                 match from_ty.callable_sig(self.db) {\n                     None => return false,\n                     Some(sig) => {\n-                        let num_args = sig.params_and_return.len() as u16 - 1;\n-                        from_ty =\n-                            Ty::apply(TypeCtor::FnPtr { num_args }, Substs(sig.params_and_return));\n+                        from_ty = Ty::fn_ptr(sig);\n                     }\n                 }\n             }"}, {"sha": "e8f3482fe4634fdd54544578ac3bfb560fc70ead", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1acb556907027622a07189aefa627502f6500b5a/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acb556907027622a07189aefa627502f6500b5a/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=1acb556907027622a07189aefa627502f6500b5a", "patch": "@@ -683,6 +683,12 @@ impl Ty {\n     pub fn unit() -> Self {\n         Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n     }\n+    pub fn fn_ptr(sig: FnSig) -> Self {\n+        Ty::apply(\n+            TypeCtor::FnPtr { num_args: sig.params().len() as u16 },\n+            Substs(sig.params_and_return),\n+        )\n+    }\n \n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self {"}, {"sha": "a397401434bfc4e3c07ee404b64d08056112fb01", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1acb556907027622a07189aefa627502f6500b5a/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acb556907027622a07189aefa627502f6500b5a/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=1acb556907027622a07189aefa627502f6500b5a", "patch": "@@ -7,5 +7,6 @@ test_utils::marks!(\n     impl_self_type_match_without_receiver\n     match_ergonomics_ref\n     coerce_merge_fail_fallback\n+    coerce_fn_reification\n     trait_self_implements_self\n );"}, {"sha": "6dc4b2cd1d24f31f826ed00fff1c164f6e35c6dc", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1acb556907027622a07189aefa627502f6500b5a/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1acb556907027622a07189aefa627502f6500b5a/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=1acb556907027622a07189aefa627502f6500b5a", "patch": "@@ -545,6 +545,48 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn coerce_fn_items_in_match_arms() {\n+    covers!(coerce_fn_reification);\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+fn foo1(x: u32) -> isize { 1 }\n+fn foo2(x: u32) -> isize { 2 }\n+fn foo3(x: u32) -> isize { 3 }\n+fn test() {\n+    let x = match 1 {\n+        1 => foo1,\n+        2 => foo2,\n+        _ => foo3,\n+    };\n+}\n+\"#, true),\n+        @r###\"\n+    9..10 'x': u32\n+    26..31 '{ 1 }': isize\n+    28..29 '1': isize\n+    40..41 'x': u32\n+    57..62 '{ 2 }': isize\n+    59..60 '2': isize\n+    71..72 'x': u32\n+    88..93 '{ 3 }': isize\n+    90..91 '3': isize\n+    104..193 '{     ...  }; }': ()\n+    114..115 'x': fn(u32) -> isize\n+    118..190 'match ...     }': fn(u32) -> isize\n+    124..125 '1': i32\n+    136..137 '1': i32\n+    136..137 '1': i32\n+    141..145 'foo1': fn foo1(u32) -> isize\n+    155..156 '2': i32\n+    155..156 '2': i32\n+    160..164 'foo2': fn foo2(u32) -> isize\n+    174..175 '_': i32\n+    179..183 'foo3': fn foo3(u32) -> isize\n+    \"###\n+    );\n+}\n+\n #[test]\n fn coerce_closure_to_fn_ptr() {\n     assert_snapshot!("}]}