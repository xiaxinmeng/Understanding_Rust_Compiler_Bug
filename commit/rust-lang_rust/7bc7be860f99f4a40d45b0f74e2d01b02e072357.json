{"sha": "7bc7be860f99f4a40d45b0f74e2d01b02e072357", "node_id": "C_kwDOAAsO6NoAKDdiYzdiZTg2MGY5OWY0YTQwZDQ1YjBmNzRlMmQwMWIwMmUwNzIzNTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-18T09:58:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-18T09:58:39Z"}, "message": "Auto merge of #87648 - JulianKnodt:const_eq_constrain, r=oli-obk\n\nallow eq constraints on associated constants\n\nUpdates #70256\n\n(cc `@varkor,` `@Centril)`", "tree": {"sha": "bae7d965ae2524594d217ae3022513e7c929ea2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bae7d965ae2524594d217ae3022513e7c929ea2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc7be860f99f4a40d45b0f74e2d01b02e072357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc7be860f99f4a40d45b0f74e2d01b02e072357", "html_url": "https://github.com/rust-lang/rust/commit/7bc7be860f99f4a40d45b0f74e2d01b02e072357", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc7be860f99f4a40d45b0f74e2d01b02e072357/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7531d2fdd49966d83830a7b4596c95587b1e9573", "url": "https://api.github.com/repos/rust-lang/rust/commits/7531d2fdd49966d83830a7b4596c95587b1e9573", "html_url": "https://github.com/rust-lang/rust/commit/7531d2fdd49966d83830a7b4596c95587b1e9573"}, {"sha": "b77bb5cb2589246cf684431ad2a184466940633d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b77bb5cb2589246cf684431ad2a184466940633d", "html_url": "https://github.com/rust-lang/rust/commit/b77bb5cb2589246cf684431ad2a184466940633d"}], "stats": {"total": 1158, "additions": 776, "deletions": 382}, "files": [{"sha": "529e17b158fc83b8e8bc867a212320be6470b6b2", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -335,7 +335,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap 3.0.6\",\n+ \"clap\",\n  \"crates-io\",\n  \"crossbeam-utils\",\n  \"curl\",\n@@ -615,28 +615,13 @@ dependencies = [\n  \"ansi_term 0.12.1\",\n  \"atty\",\n  \"bitflags\",\n- \"strsim 0.8.0\",\n- \"textwrap 0.11.0\",\n+ \"strsim\",\n+ \"textwrap\",\n  \"unicode-width\",\n  \"vec_map\",\n  \"yaml-rust 0.3.5\",\n ]\n \n-[[package]]\n-name = \"clap\"\n-version = \"3.0.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1957aa4a5fb388f0a0a73ce7556c5b42025b874e5cdc2c670775e346e97adec0\"\n-dependencies = [\n- \"atty\",\n- \"bitflags\",\n- \"indexmap\",\n- \"os_str_bytes\",\n- \"strsim 0.10.0\",\n- \"termcolor\",\n- \"textwrap 0.14.2\",\n-]\n-\n [[package]]\n name = \"clippy\"\n version = \"0.1.60\"\n@@ -669,7 +654,7 @@ version = \"0.0.1\"\n dependencies = [\n  \"bytecount\",\n  \"cargo_metadata 0.14.0\",\n- \"clap 2.34.0\",\n+ \"clap\",\n  \"indoc\",\n  \"itertools 0.10.1\",\n  \"opener\",\n@@ -1751,7 +1736,7 @@ name = \"installer\"\n version = \"0.0.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap 2.34.0\",\n+ \"clap\",\n  \"flate2\",\n  \"lazy_static\",\n  \"num_cpus\",\n@@ -2190,7 +2175,7 @@ dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap 2.34.0\",\n+ \"clap\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.7.1\",\n  \"handlebars\",\n@@ -2521,15 +2506,6 @@ dependencies = [\n  \"winapi\",\n ]\n \n-[[package]]\n-name = \"os_str_bytes\"\n-version = \"6.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e22443d1643a904602595ba1cd8f7d896afe56d26712531c5ff73a15b2fbf64\"\n-dependencies = [\n- \"memchr\",\n-]\n-\n [[package]]\n name = \"output_vt100\"\n version = \"0.1.2\"\n@@ -2934,7 +2910,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b0b4b5faaf07040474e8af74a9e19ff167d5d204df5db5c5c765edecfb900358\"\n dependencies = [\n  \"bitflags\",\n- \"clap 2.34.0\",\n+ \"clap\",\n  \"derive_more\",\n  \"env_logger 0.7.1\",\n  \"humantime 2.0.1\",\n@@ -3282,7 +3258,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.34.0\",\n+ \"clap\",\n  \"env_logger 0.7.1\",\n  \"mdbook\",\n ]\n@@ -4898,19 +4874,13 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \n-[[package]]\n-name = \"strsim\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n-\n [[package]]\n name = \"structopt\"\n version = \"0.3.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"40b9788f4202aa75c240ecc9c15c65185e6a39ccdeb0fd5d008b98825464c87c\"\n dependencies = [\n- \"clap 2.34.0\",\n+ \"clap\",\n  \"lazy_static\",\n  \"structopt-derive\",\n ]\n@@ -5081,12 +5051,6 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n-[[package]]\n-name = \"textwrap\"\n-version = \"0.14.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0066c8d12af8b5acd21e00547c3797fde4e8677254a7ee429176ccebbe93dd80\"\n-\n [[package]]\n name = \"thiserror\"\n version = \"1.0.30\""}, {"sha": "d0732b35b6e9ebfaf11a06a178052f6404cd8992", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -224,7 +224,7 @@ pub enum AngleBracketedArg {\n     /// Argument for a generic parameter.\n     Arg(GenericArg),\n     /// Constraint for an associated item.\n-    Constraint(AssocTyConstraint),\n+    Constraint(AssocConstraint),\n }\n \n impl AngleBracketedArg {\n@@ -1843,19 +1843,38 @@ impl UintTy {\n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`).\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct AssocTyConstraint {\n+pub struct AssocConstraint {\n     pub id: NodeId,\n     pub ident: Ident,\n     pub gen_args: Option<GenericArgs>,\n-    pub kind: AssocTyConstraintKind,\n+    pub kind: AssocConstraintKind,\n     pub span: Span,\n }\n \n-/// The kinds of an `AssocTyConstraint`.\n+/// The kinds of an `AssocConstraint`.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum AssocTyConstraintKind {\n-    /// E.g., `A = Bar` in `Foo<A = Bar>`.\n-    Equality { ty: P<Ty> },\n+pub enum Term {\n+    Ty(P<Ty>),\n+    Const(AnonConst),\n+}\n+\n+impl From<P<Ty>> for Term {\n+    fn from(v: P<Ty>) -> Self {\n+        Term::Ty(v)\n+    }\n+}\n+\n+impl From<AnonConst> for Term {\n+    fn from(v: AnonConst) -> Self {\n+        Term::Const(v)\n+    }\n+}\n+\n+/// The kinds of an `AssocConstraint`.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub enum AssocConstraintKind {\n+    /// E.g., `A = Bar`, `A = 3` in `Foo<A = Bar>` where A is an associated type.\n+    Equality { term: Term },\n     /// E.g. `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`.\n     Bound { bounds: GenericBounds },\n }"}, {"sha": "a81a227629539a06f52f55a639378b99cff9945d", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -165,8 +165,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_lifetime(l, self);\n     }\n \n-    fn visit_ty_constraint(&mut self, t: &mut AssocTyConstraint) {\n-        noop_visit_ty_constraint(t, self);\n+    fn visit_constraint(&mut self, t: &mut AssocConstraint) {\n+        noop_visit_constraint(t, self);\n     }\n \n     fn visit_foreign_mod(&mut self, nm: &mut ForeignMod) {\n@@ -430,8 +430,8 @@ pub fn noop_flat_map_arm<T: MutVisitor>(mut arm: Arm, vis: &mut T) -> SmallVec<[\n     smallvec![arm]\n }\n \n-pub fn noop_visit_ty_constraint<T: MutVisitor>(\n-    AssocTyConstraint { id, ident, gen_args, kind, span }: &mut AssocTyConstraint,\n+pub fn noop_visit_constraint<T: MutVisitor>(\n+    AssocConstraint { id, ident, gen_args, kind, span }: &mut AssocConstraint,\n     vis: &mut T,\n ) {\n     vis.visit_id(id);\n@@ -440,12 +440,11 @@ pub fn noop_visit_ty_constraint<T: MutVisitor>(\n         vis.visit_generic_args(gen_args);\n     }\n     match kind {\n-        AssocTyConstraintKind::Equality { ref mut ty } => {\n-            vis.visit_ty(ty);\n-        }\n-        AssocTyConstraintKind::Bound { ref mut bounds } => {\n-            visit_bounds(bounds, vis);\n-        }\n+        AssocConstraintKind::Equality { ref mut term } => match term {\n+            Term::Ty(ty) => vis.visit_ty(ty),\n+            Term::Const(c) => vis.visit_anon_const(c),\n+        },\n+        AssocConstraintKind::Bound { ref mut bounds } => visit_bounds(bounds, vis),\n     }\n     vis.visit_span(span);\n }\n@@ -555,7 +554,7 @@ pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(\n     let AngleBracketedArgs { args, span } = data;\n     visit_vec(args, |arg| match arg {\n         AngleBracketedArg::Arg(arg) => vis.visit_generic_arg(arg),\n-        AngleBracketedArg::Constraint(constraint) => vis.visit_ty_constraint(constraint),\n+        AngleBracketedArg::Constraint(constraint) => vis.visit_constraint(constraint),\n     });\n     vis.visit_span(span);\n }"}, {"sha": "73e9297549cd4877de19f41d92d5cb5711a84bfb", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -190,8 +190,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_generic_arg(&mut self, generic_arg: &'ast GenericArg) {\n         walk_generic_arg(self, generic_arg)\n     }\n-    fn visit_assoc_ty_constraint(&mut self, constraint: &'ast AssocTyConstraint) {\n-        walk_assoc_ty_constraint(self, constraint)\n+    fn visit_assoc_constraint(&mut self, constraint: &'ast AssocConstraint) {\n+        walk_assoc_constraint(self, constraint)\n     }\n     fn visit_attribute(&mut self, attr: &'ast Attribute) {\n         walk_attribute(self, attr)\n@@ -464,7 +464,7 @@ where\n             for arg in &data.args {\n                 match arg {\n                     AngleBracketedArg::Arg(a) => visitor.visit_generic_arg(a),\n-                    AngleBracketedArg::Constraint(c) => visitor.visit_assoc_ty_constraint(c),\n+                    AngleBracketedArg::Constraint(c) => visitor.visit_assoc_constraint(c),\n                 }\n             }\n         }\n@@ -486,19 +486,17 @@ where\n     }\n }\n \n-pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(\n-    visitor: &mut V,\n-    constraint: &'a AssocTyConstraint,\n-) {\n+pub fn walk_assoc_constraint<'a, V: Visitor<'a>>(visitor: &mut V, constraint: &'a AssocConstraint) {\n     visitor.visit_ident(constraint.ident);\n     if let Some(ref gen_args) = constraint.gen_args {\n         visitor.visit_generic_args(gen_args.span(), gen_args);\n     }\n     match constraint.kind {\n-        AssocTyConstraintKind::Equality { ref ty } => {\n-            visitor.visit_ty(ty);\n-        }\n-        AssocTyConstraintKind::Bound { ref bounds } => {\n+        AssocConstraintKind::Equality { ref term } => match term {\n+            Term::Ty(ty) => visitor.visit_ty(ty),\n+            Term::Const(c) => visitor.visit_anon_const(c),\n+        },\n+        AssocConstraintKind::Bound { ref bounds } => {\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n     }"}, {"sha": "47b610670555c9767da887ce5582a3c0b4fc6ded", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -960,7 +960,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// returns a `hir::TypeBinding` representing `Item`.\n     fn lower_assoc_ty_constraint(\n         &mut self,\n-        constraint: &AssocTyConstraint,\n+        constraint: &AssocConstraint,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n@@ -997,10 +997,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n \n         let kind = match constraint.kind {\n-            AssocTyConstraintKind::Equality { ref ty } => {\n-                hir::TypeBindingKind::Equality { ty: self.lower_ty(ty, itctx) }\n+            AssocConstraintKind::Equality { ref term } => {\n+                let term = match term {\n+                    Term::Ty(ref ty) => self.lower_ty(ty, itctx).into(),\n+                    Term::Const(ref c) => self.lower_anon_const(c).into(),\n+                };\n+                hir::TypeBindingKind::Equality { term }\n             }\n-            AssocTyConstraintKind::Bound { ref bounds } => {\n+            AssocConstraintKind::Bound { ref bounds } => {\n                 let mut capturable_lifetimes;\n                 let mut parent_def_id = self.current_hir_id_owner;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n@@ -1078,7 +1082,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             itctx,\n                         );\n \n-                        hir::TypeBindingKind::Equality { ty }\n+                        hir::TypeBindingKind::Equality { term: ty.into() }\n                     })\n                 } else {\n                     // Desugar `AssocTy: Bounds` into a type binding where the"}, {"sha": "79262235cd9f250584e1556c7145a415eb2cf982", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -420,7 +420,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ty: &'hir hir::Ty<'hir>,\n     ) -> hir::TypeBinding<'hir> {\n         let ident = Ident::with_dummy_span(hir::FN_OUTPUT_NAME);\n-        let kind = hir::TypeBindingKind::Equality { ty };\n+        let kind = hir::TypeBindingKind::Equality { term: ty.into() };\n         let args = arena_vec![self;];\n         let bindings = arena_vec![self;];\n         let gen_args = self.arena.alloc(hir::GenericArgs {"}, {"sha": "eb7c75cac0520ab0018a2acff5f19adee5ce9253", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -138,10 +138,10 @@ impl<'a> AstValidator<'a> {\n         self.outer_impl_trait = old;\n     }\n \n-    fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n+    fn visit_assoc_constraint_from_generic_args(&mut self, constraint: &'a AssocConstraint) {\n         match constraint.kind {\n-            AssocTyConstraintKind::Equality { .. } => {}\n-            AssocTyConstraintKind::Bound { .. } => {\n+            AssocConstraintKind::Equality { .. } => {}\n+            AssocConstraintKind::Bound { .. } => {\n                 if self.is_assoc_ty_bound_banned {\n                     self.err_handler().span_err(\n                         constraint.span,\n@@ -150,7 +150,7 @@ impl<'a> AstValidator<'a> {\n                 }\n             }\n         }\n-        self.visit_assoc_ty_constraint(constraint);\n+        self.visit_assoc_constraint(constraint);\n     }\n \n     // Mirrors `visit::walk_ty`, but tracks relevant state.\n@@ -1277,7 +1277,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         // are allowed to contain nested `impl Trait`.\n                         AngleBracketedArg::Constraint(constraint) => {\n                             self.with_impl_trait(None, |this| {\n-                                this.visit_assoc_ty_constraint_from_generic_args(constraint);\n+                                this.visit_assoc_constraint_from_generic_args(constraint);\n                             });\n                         }\n                     }\n@@ -1586,12 +1586,12 @@ fn deny_equality_constraints(\n                                     let len = assoc_path.segments.len() - 1;\n                                     let gen_args = args.as_ref().map(|p| (**p).clone());\n                                     // Build `<Bar = RhsTy>`.\n-                                    let arg = AngleBracketedArg::Constraint(AssocTyConstraint {\n+                                    let arg = AngleBracketedArg::Constraint(AssocConstraint {\n                                         id: rustc_ast::node_id::DUMMY_NODE_ID,\n                                         ident: *ident,\n                                         gen_args,\n-                                        kind: AssocTyConstraintKind::Equality {\n-                                            ty: predicate.rhs_ty.clone(),\n+                                        kind: AssocConstraintKind::Equality {\n+                                            term: predicate.rhs_ty.clone().into(),\n                                         },\n                                         span: ident.span,\n                                     });"}, {"sha": "89671788255a97f7d6488caf8845b1834c328ba5", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n-use rustc_ast::{AssocTyConstraint, AssocTyConstraintKind, NodeId};\n+use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd, VariantData};\n use rustc_errors::struct_span_err;\n use rustc_feature::{AttributeGate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n@@ -622,16 +622,16 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_fn(self, fn_kind, span)\n     }\n \n-    fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n-        if let AssocTyConstraintKind::Bound { .. } = constraint.kind {\n+    fn visit_assoc_constraint(&mut self, constraint: &'a AssocConstraint) {\n+        if let AssocConstraintKind::Bound { .. } = constraint.kind {\n             gate_feature_post!(\n                 &self,\n                 associated_type_bounds,\n                 constraint.span,\n                 \"associated type bounds are unstable\"\n             )\n         }\n-        visit::walk_assoc_ty_constraint(self, constraint)\n+        visit::walk_assoc_constraint(self, constraint)\n     }\n \n     fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n@@ -724,6 +724,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(half_open_range_patterns, \"half-open range patterns are unstable\");\n     gate_all!(inline_const, \"inline-const is experimental\");\n     gate_all!(inline_const_pat, \"inline-const in pattern position is experimental\");\n+    gate_all!(associated_const_equality, \"associated const equality is incomplete\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "a4a48cc8e8a7f1d279cadb2dc2daf4953865134f", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -126,9 +126,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_generic_args(self, path_span, generic_args)\n     }\n-    fn visit_assoc_ty_constraint(&mut self, constraint: &AssocTyConstraint) {\n+    fn visit_assoc_constraint(&mut self, constraint: &AssocConstraint) {\n         self.count += 1;\n-        walk_assoc_ty_constraint(self, constraint)\n+        walk_assoc_constraint(self, constraint)\n     }\n     fn visit_attribute(&mut self, _attr: &Attribute) {\n         self.count += 1;"}, {"sha": "17941058ed6f0ce7e21e58da0ec86c322446c361", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,14 +1,14 @@\n use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n \n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, BinOpToken, CommentKind, DelimToken, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n+use rustc_ast::{attr, Term};\n use rustc_ast::{GenericArg, MacArgs, ModKind};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n@@ -952,18 +952,19 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocTyConstraint) {\n+    pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocConstraint) {\n         self.print_ident(constraint.ident);\n         constraint.gen_args.as_ref().map(|args| self.print_generic_args(args, false));\n         self.space();\n         match &constraint.kind {\n-            ast::AssocTyConstraintKind::Equality { ty } => {\n+            ast::AssocConstraintKind::Equality { term } => {\n                 self.word_space(\"=\");\n-                self.print_type(ty);\n-            }\n-            ast::AssocTyConstraintKind::Bound { bounds } => {\n-                self.print_type_bounds(\":\", &*bounds);\n+                match term {\n+                    Term::Ty(ty) => self.print_type(ty),\n+                    Term::Const(c) => self.print_expr_anon_const(c),\n+                }\n             }\n+            ast::AssocConstraintKind::Bound { bounds } => self.print_type_bounds(\":\", &*bounds),\n         }\n     }\n "}, {"sha": "01cc72121c7d4d5cfc9ad03787ee2f363578c12b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -779,7 +779,10 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                                     [\n                                         hir::TypeBinding {\n                                             ident: Ident { name: sym::Output, .. },\n-                                            kind: hir::TypeBindingKind::Equality { ty },\n+                                            kind:\n+                                                hir::TypeBindingKind::Equality {\n+                                                    term: hir::Term::Ty(ty),\n+                                                },\n                                             ..\n                                         },\n                                     ],"}, {"sha": "9687fd09a53bc091bf86ef6c6de488a7304f463d", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -203,8 +203,9 @@ fn push_debuginfo_type_name<'tcx>(\n                 let projection_bounds: SmallVec<[_; 4]> = trait_data\n                     .projection_bounds()\n                     .map(|bound| {\n-                        let ExistentialProjection { item_def_id, ty, .. } = bound.skip_binder();\n-                        (item_def_id, ty)\n+                        let ExistentialProjection { item_def_id, term, .. } = bound.skip_binder();\n+                        // FIXME(associated_const_equality): allow for consts here\n+                        (item_def_id, term.ty().unwrap())\n                     })\n                     .collect();\n "}, {"sha": "47010ea3ab61392acd961f35e2bdd4dbd8f97d7d", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -288,6 +288,8 @@ declare_features! (\n     (active, asm_sym, \"1.58.0\", Some(72016), None),\n     /// Allows the `may_unwind` option in inline assembly.\n     (active, asm_unwind, \"1.58.0\", Some(72016), None),\n+    /// Allows users to enforce equality of associated constants `TraitImpl<AssocConst=3>`.\n+    (active, associated_const_equality, \"1.58.0\", Some(92827), None),\n     /// Allows the user of associated type bounds.\n     (active, associated_type_bounds, \"1.34.0\", Some(52662), None),\n     /// Allows associated type defaults."}, {"sha": "43aa0ae265a095eacc0a7ed3a67175f3b580d950", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -377,7 +377,7 @@ impl GenericArgs<'_> {\n             GenericArg::Type(ty) => matches!(ty.kind, TyKind::Err),\n             _ => false,\n         }) || self.bindings.iter().any(|arg| match arg.kind {\n-            TypeBindingKind::Equality { ty } => matches!(ty.kind, TyKind::Err),\n+            TypeBindingKind::Equality { term: Term::Ty(ty) } => matches!(ty.kind, TyKind::Err),\n             _ => false,\n         })\n     }\n@@ -2129,19 +2129,37 @@ pub struct TypeBinding<'hir> {\n     pub span: Span,\n }\n \n+#[derive(Debug, HashStable_Generic)]\n+pub enum Term<'hir> {\n+    Ty(&'hir Ty<'hir>),\n+    Const(AnonConst),\n+}\n+\n+impl<'hir> From<&'hir Ty<'hir>> for Term<'hir> {\n+    fn from(ty: &'hir Ty<'hir>) -> Self {\n+        Term::Ty(ty)\n+    }\n+}\n+\n+impl<'hir> From<AnonConst> for Term<'hir> {\n+    fn from(c: AnonConst) -> Self {\n+        Term::Const(c)\n+    }\n+}\n+\n // Represents the two kinds of type bindings.\n #[derive(Debug, HashStable_Generic)]\n pub enum TypeBindingKind<'hir> {\n     /// E.g., `Foo<Bar: Send>`.\n     Constraint { bounds: &'hir [GenericBound<'hir>] },\n-    /// E.g., `Foo<Bar = ()>`.\n-    Equality { ty: &'hir Ty<'hir> },\n+    /// E.g., `Foo<Bar = ()>`, `Foo<Bar = ()>`\n+    Equality { term: Term<'hir> },\n }\n \n impl TypeBinding<'_> {\n     pub fn ty(&self) -> &Ty<'_> {\n         match self.kind {\n-            TypeBindingKind::Equality { ref ty } => ty,\n+            TypeBindingKind::Equality { term: Term::Ty(ref ty) } => ty,\n             _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n         }\n     }"}, {"sha": "cfdcd1618ba426a05285fe4327c36c06a024314a", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -801,12 +801,11 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n     visitor.visit_ident(type_binding.ident);\n     visitor.visit_generic_args(type_binding.span, type_binding.gen_args);\n     match type_binding.kind {\n-        TypeBindingKind::Equality { ref ty } => {\n-            visitor.visit_ty(ty);\n-        }\n-        TypeBindingKind::Constraint { bounds } => {\n-            walk_list!(visitor, visit_param_bound, bounds);\n-        }\n+        TypeBindingKind::Equality { ref term } => match term {\n+            Term::Ty(ref ty) => visitor.visit_ty(ty),\n+            Term::Const(ref c) => visitor.visit_anon_const(c),\n+        },\n+        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n     }\n }\n "}, {"sha": "a301c5e34565cabd107e279828293ab846d2c690", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -6,7 +6,7 @@ use rustc_ast_pretty::pp::Breaks::{Consistent, Inconsistent};\n use rustc_ast_pretty::pp::{self, Breaks};\n use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_hir as hir;\n-use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node};\n+use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node, Term};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n@@ -1752,9 +1752,12 @@ impl<'a> State<'a> {\n                 self.print_generic_args(binding.gen_args, false, false);\n                 self.space();\n                 match generic_args.bindings[0].kind {\n-                    hir::TypeBindingKind::Equality { ref ty } => {\n+                    hir::TypeBindingKind::Equality { ref term } => {\n                         self.word_space(\"=\");\n-                        self.print_type(ty);\n+                        match term {\n+                            Term::Ty(ref ty) => self.print_type(ty),\n+                            Term::Const(ref c) => self.print_anon_const(c),\n+                        }\n                     }\n                     hir::TypeBindingKind::Constraint { bounds } => {\n                         self.print_bounds(\":\", bounds);"}, {"sha": "e98b9c3b03c5acd3306dbe6f005f2003d1966d57", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1780,7 +1780,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 {\n                     if projection_predicate.projection_ty.item_def_id == item_def_id {\n                         // We don't account for multiple `Future::Output = Ty` contraints.\n-                        return Some(projection_predicate.ty);\n+                        return projection_predicate.term.ty();\n                     }\n                 }\n             }"}, {"sha": "3fa71d1a3d8171204636aade006a54da3fd1bd14", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -122,8 +122,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             {\n                                 for type_binding in generic_args.bindings.iter() {\n                                     if type_binding.ident.name == rustc_span::sym::Output {\n-                                        if let hir::TypeBindingKind::Equality { ty } =\n-                                            type_binding.kind\n+                                        if let hir::TypeBindingKind::Equality {\n+                                            term: hir::Term::Ty(ty),\n+                                        } = type_binding.kind\n                                         {\n                                             return Some(ty);\n                                         }"}, {"sha": "4851e637d3a62eeb3f440bba63776549497b7107", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -584,8 +584,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n-                if projection.ty.references_error() {\n-                    // No point on adding these obligations since there's a type error involved.\n+                if projection.term.references_error() {\n                     return tcx.ty_error();\n                 }\n             }"}, {"sha": "b45a6514d79347e05f8e1e47320901227486c2c1", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -26,7 +26,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             kind: TypeVariableOriginKind::NormalizeProjectionType,\n             span: self.tcx.def_span(def_id),\n         });\n-        let projection = ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, ty: ty_var });\n+        let projection =\n+            ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, term: ty_var.into() });\n         let obligation = Obligation::with_depth(\n             cause,\n             recursion_depth,"}, {"sha": "3921187baa55eda5c3ebe94ec0e758c9fe4ccf1d", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,7 +1,7 @@\n use libloading::Library;\n use rustc_ast::mut_visit::{visit_clobber, MutVisitor, *};\n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, AttrVec, BlockCheckMode};\n+use rustc_ast::{self as ast, AttrVec, BlockCheckMode, Term};\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n #[cfg(parallel_compiler)]\n@@ -738,9 +738,14 @@ impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n                                         | ast::GenericArg::Const(_) => false,\n                                     },\n                                     ast::AngleBracketedArg::Constraint(c) => match c.kind {\n-                                        ast::AssocTyConstraintKind::Bound { .. } => true,\n-                                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n-                                            involves_impl_trait(ty)\n+                                        ast::AssocConstraintKind::Bound { .. } => true,\n+                                        ast::AssocConstraintKind::Equality { ref term } => {\n+                                            match term {\n+                                                Term::Ty(ty) => involves_impl_trait(ty),\n+                                                // FIXME(...): This should check if the constant\n+                                                // involves a trait impl, but for now ignore.\n+                                                Term::Const(_) => false,\n+                                            }\n                                         }\n                                     },\n                                 })"}, {"sha": "2776370ba6f465809b4a128928ae68d2cb799e60", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -152,6 +152,19 @@ impl<'tcx> AssocItems<'tcx> {\n             .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n     }\n \n+    /// Returns the associated item with the given name and any of `AssocKind`, if one exists.\n+    pub fn find_by_name_and_kinds(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        kinds: &[AssocKind],\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| kinds.contains(&item.kind))\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n     /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n     pub fn find_by_name_and_namespace(\n         &self,"}, {"sha": "d6c35dfef8888339b07d5fdf5e169c65dfb58564", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -86,10 +86,14 @@ impl<'tcx> Const<'tcx> {\n         if let Some(lit_input) = lit_input {\n             // If an error occurred, ignore that it's a literal and leave reporting the error up to\n             // mir.\n-            if let Ok(c) = tcx.at(expr.span).lit_to_const(lit_input) {\n-                return Some(c);\n-            } else {\n-                tcx.sess.delay_span_bug(expr.span, \"Const::from_anon_const: couldn't lit_to_const\");\n+            match tcx.at(expr.span).lit_to_const(lit_input) {\n+                Ok(c) => return Some(c),\n+                Err(e) => {\n+                    tcx.sess.delay_span_bug(\n+                        expr.span,\n+                        &format!(\"Const::from_anon_const: couldn't lit_to_const {:?}\", e),\n+                    );\n+                }\n             }\n         }\n "}, {"sha": "d68c5514821a9b3904d57c1250501ea43093fb19", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -4,7 +4,7 @@ use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::TyKind::*;\n use crate::ty::{\n     ConstKind, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, InferTy,\n-    ProjectionTy, TyCtxt, TyS, TypeAndMut,\n+    ProjectionTy, Term, TyCtxt, TyS, TypeAndMut,\n };\n \n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -105,8 +105,14 @@ impl<'tcx> TyS<'tcx> {\n                 ExistentialPredicate::Trait(ExistentialTraitRef { substs, .. }) => {\n                     substs.iter().all(generic_arg_is_suggestible)\n                 }\n-                ExistentialPredicate::Projection(ExistentialProjection { substs, ty, .. }) => {\n-                    ty.is_suggestable() && substs.iter().all(generic_arg_is_suggestible)\n+                ExistentialPredicate::Projection(ExistentialProjection {\n+                    substs, term, ..\n+                }) => {\n+                    let term_is_suggestable = match term {\n+                        Term::Ty(ty) => ty.is_suggestable(),\n+                        Term::Const(c) => const_is_suggestable(c.val),\n+                    };\n+                    term_is_suggestable && substs.iter().all(generic_arg_is_suggestible)\n                 }\n                 _ => true,\n             }),"}, {"sha": "f06a1b09cd82ab236553403b81ba572fd2d65dc6", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::subst::{GenericArg, GenericArgKind};\n-use crate::ty::{self, InferConst, Ty, TypeFlags};\n+use crate::ty::{self, InferConst, Term, Ty, TypeFlags};\n use std::slice;\n \n #[derive(Debug)]\n@@ -241,9 +241,12 @@ impl FlagComputation {\n                 self.add_ty(a);\n                 self.add_ty(b);\n             }\n-            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n                 self.add_projection_ty(projection_ty);\n-                self.add_ty(ty);\n+                match term {\n+                    Term::Ty(ty) => self.add_ty(ty),\n+                    Term::Const(c) => self.add_const(c),\n+                }\n             }\n             ty::PredicateKind::WellFormed(arg) => {\n                 self.add_substs(slice::from_ref(&arg));\n@@ -317,7 +320,10 @@ impl FlagComputation {\n \n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection<'_>) {\n         self.add_substs(projection.substs);\n-        self.add_ty(projection.ty);\n+        match projection.term {\n+            ty::Term::Ty(ty) => self.add_ty(ty),\n+            ty::Term::Const(ct) => self.add_const(ct),\n+        }\n     }\n \n     fn add_projection_ty(&mut self, projection_ty: ty::ProjectionTy<'_>) {"}, {"sha": "4bc3e23f4a588cb26b1e9218edfe29a2324a57e9", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -484,7 +484,7 @@ crate struct PredicateInner<'tcx> {\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(PredicateInner<'_>, 48);\n+static_assert_size!(PredicateInner<'_>, 56);\n \n #[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n@@ -795,6 +795,31 @@ pub struct CoercePredicate<'tcx> {\n }\n pub type PolyCoercePredicate<'tcx> = ty::Binder<'tcx, CoercePredicate<'tcx>>;\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+#[derive(HashStable, TypeFoldable)]\n+pub enum Term<'tcx> {\n+    Ty(Ty<'tcx>),\n+    Const(&'tcx Const<'tcx>),\n+}\n+\n+impl<'tcx> From<Ty<'tcx>> for Term<'tcx> {\n+    fn from(ty: Ty<'tcx>) -> Self {\n+        Term::Ty(ty)\n+    }\n+}\n+\n+impl<'tcx> From<&'tcx Const<'tcx>> for Term<'tcx> {\n+    fn from(c: &'tcx Const<'tcx>) -> Self {\n+        Term::Const(c)\n+    }\n+}\n+\n+impl<'tcx> Term<'tcx> {\n+    pub fn ty(&self) -> Option<Ty<'tcx>> {\n+        if let Term::Ty(ty) = self { Some(ty) } else { None }\n+    }\n+}\n+\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n@@ -811,7 +836,7 @@ pub type PolyCoercePredicate<'tcx> = ty::Binder<'tcx, CoercePredicate<'tcx>>;\n #[derive(HashStable, TypeFoldable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n-    pub ty: Ty<'tcx>,\n+    pub term: Term<'tcx>,\n }\n \n pub type PolyProjectionPredicate<'tcx> = Binder<'tcx, ProjectionPredicate<'tcx>>;\n@@ -836,8 +861,8 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.map_bound(|predicate| predicate.projection_ty.trait_ref(tcx))\n     }\n \n-    pub fn ty(&self) -> Binder<'tcx, Ty<'tcx>> {\n-        self.map_bound(|predicate| predicate.ty)\n+    pub fn term(&self) -> Binder<'tcx, Term<'tcx>> {\n+        self.map_bound(|predicate| predicate.term)\n     }\n \n     /// The `DefId` of the `TraitItem` for the associated type."}, {"sha": "bbdaf248a9e7216a3c994c7debbab5cc1ee8b129", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,6 +1,6 @@\n use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Provenance, Scalar};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n-use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Term, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sso::SsoHashSet;\n@@ -799,7 +799,7 @@ pub trait PrettyPrinter<'tcx>:\n                     let trait_ref = proj_ref.required_poly_trait_ref(self.tcx());\n \n                     // Projection type entry -- the def-id for naming, and the ty.\n-                    let proj_ty = (proj_ref.projection_def_id(), proj_ref.ty());\n+                    let proj_ty = (proj_ref.projection_def_id(), proj_ref.term());\n \n                     self.insert_trait_and_projection(\n                         trait_ref,\n@@ -850,8 +850,10 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n \n                     p!(\")\");\n-                    if !return_ty.skip_binder().is_unit() {\n-                        p!(\"-> \", print(return_ty));\n+                    if let Term::Ty(ty) = return_ty.skip_binder() {\n+                        if !ty.is_unit() {\n+                            p!(\"-> \", print(return_ty));\n+                        }\n                     }\n                     p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n \n@@ -902,23 +904,28 @@ pub trait PrettyPrinter<'tcx>:\n                     first = false;\n                 }\n \n-                for (assoc_item_def_id, ty) in assoc_items {\n+                for (assoc_item_def_id, term) in assoc_items {\n                     if !first {\n                         p!(\", \");\n                     }\n                     p!(write(\"{} = \", self.tcx().associated_item(assoc_item_def_id).ident));\n \n-                    // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks\n-                    match ty.skip_binder().kind() {\n-                        ty::Projection(ty::ProjectionTy { item_def_id, .. })\n-                            if Some(*item_def_id) == self.tcx().lang_items().generator_return() =>\n-                        {\n-                            p!(\"[async output]\")\n+                    match term.skip_binder() {\n+                        Term::Ty(ty) => {\n+                            // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks\n+                            if matches!(\n+                              ty.kind(), ty::Projection(ty::ProjectionTy { item_def_id, .. })\n+                              if Some(*item_def_id) == self.tcx().lang_items().generator_return()\n+                            ) {\n+                                p!(\"[async output]\")\n+                            } else {\n+                                p!(print(ty))\n+                            }\n                         }\n-                        _ => {\n-                            p!(print(ty))\n+                        Term::Const(c) => {\n+                            p!(print(c));\n                         }\n-                    }\n+                    };\n \n                     first = false;\n                 }\n@@ -943,8 +950,11 @@ pub trait PrettyPrinter<'tcx>:\n     fn insert_trait_and_projection(\n         &mut self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-        proj_ty: Option<(DefId, ty::Binder<'tcx, Ty<'tcx>>)>,\n-        traits: &mut BTreeMap<ty::PolyTraitRef<'tcx>, BTreeMap<DefId, ty::Binder<'tcx, Ty<'tcx>>>>,\n+        proj_ty: Option<(DefId, ty::Binder<'tcx, Term<'tcx>>)>,\n+        traits: &mut BTreeMap<\n+            ty::PolyTraitRef<'tcx>,\n+            BTreeMap<DefId, ty::Binder<'tcx, Term<'tcx>>>,\n+        >,\n         fn_traits: &mut BTreeMap<ty::PolyTraitRef<'tcx>, OpaqueFnEntry<'tcx>>,\n     ) {\n         let trait_def_id = trait_ref.def_id();\n@@ -1019,7 +1029,11 @@ pub trait PrettyPrinter<'tcx>:\n                         let mut projections = predicates.projection_bounds();\n                         if let (Some(proj), None) = (projections.next(), projections.next()) {\n                             let tys: Vec<_> = args.iter().map(|k| k.expect_ty()).collect();\n-                            p!(pretty_fn_sig(&tys, false, proj.skip_binder().ty));\n+                            p!(pretty_fn_sig(\n+                                &tys,\n+                                false,\n+                                proj.skip_binder().term.ty().expect(\"Return type was a const\")\n+                            ));\n                             resugared = true;\n                         }\n                     }\n@@ -2442,7 +2456,7 @@ define_print_and_forward_display! {\n \n     ty::ExistentialProjection<'tcx> {\n         let name = cx.tcx().associated_item(self.item_def_id).ident;\n-        p!(write(\"{} = \", name), print(self.ty))\n+        p!(write(\"{} = \", name), print(self.term))\n     }\n \n     ty::ExistentialPredicate<'tcx> {\n@@ -2499,7 +2513,14 @@ define_print_and_forward_display! {\n     }\n \n     ty::ProjectionPredicate<'tcx> {\n-        p!(print(self.projection_ty), \" == \", print(self.ty))\n+        p!(print(self.projection_ty), \" == \", print(self.term))\n+    }\n+\n+    ty::Term<'tcx> {\n+      match self {\n+        ty::Term::Ty(ty) => p!(print(ty)),\n+        ty::Term::Const(c) => p!(print(c)),\n+      }\n     }\n \n     ty::ProjectionTy<'tcx> {\n@@ -2709,5 +2730,5 @@ pub struct OpaqueFnEntry<'tcx> {\n     has_fn_once: bool,\n     fn_mut_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n     fn_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n-    return_ty: Option<ty::Binder<'tcx, Ty<'tcx>>>,\n+    return_ty: Option<ty::Binder<'tcx, Term<'tcx>>>,\n }"}, {"sha": "bb040acd2703d6e91db73855a38224eaa14b6eef", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -7,7 +7,7 @@\n use crate::mir::interpret::{get_slice_bytes, ConstValue, GlobalAlloc, Scalar};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, Term, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n use rustc_span::DUMMY_SP;\n@@ -291,19 +291,19 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 b.item_def_id,\n             )))\n         } else {\n-            let ty = relation.relate_with_variance(\n+            let term = relation.relate_with_variance(\n                 ty::Invariant,\n                 ty::VarianceDiagInfo::default(),\n-                a.ty,\n-                b.ty,\n+                a.term,\n+                b.term,\n             )?;\n             let substs = relation.relate_with_variance(\n                 ty::Invariant,\n                 ty::VarianceDiagInfo::default(),\n                 a.substs,\n                 b.substs,\n             )?;\n-            Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, ty })\n+            Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, term })\n         }\n     }\n }\n@@ -833,6 +833,20 @@ impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::Term<'tcx> {\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: Self,\n+        b: Self,\n+    ) -> RelateResult<'tcx, Self> {\n+        Ok(match (a, b) {\n+            (Term::Ty(a), Term::Ty(b)) => relation.relate(a, b)?.into(),\n+            (Term::Const(a), Term::Const(b)) => relation.relate(a, b)?.into(),\n+            _ => return Err(TypeError::Mismatch),\n+        })\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n@@ -841,7 +855,7 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n     ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>> {\n         Ok(ty::ProjectionPredicate {\n             projection_ty: relation.relate(a.projection_ty, b.projection_ty)?,\n-            ty: relation.relate(a.ty, b.ty)?,\n+            term: relation.relate(a.term, b.term)?.into(),\n         })\n     }\n }"}, {"sha": "1c5bc7860db2de7280f0446399e3f3ec796fa051", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -6,7 +6,7 @@ use crate::mir::interpret;\n use crate::mir::ProjectionKind;\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeVisitor};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n-use crate::ty::{self, InferConst, Lift, Ty, TyCtxt};\n+use crate::ty::{self, InferConst, Lift, Term, Ty, TyCtxt};\n use rustc_data_structures::functor::IdFunctor;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::CRATE_DEF_INDEX;\n@@ -158,7 +158,7 @@ impl<'tcx> fmt::Debug for ty::TraitPredicate<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::ProjectionPredicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ProjectionPredicate({:?}, {:?})\", self.projection_ty, self.ty)\n+        write!(f, \"ProjectionPredicate({:?}, {:?})\", self.projection_ty, self.term)\n     }\n }\n \n@@ -356,6 +356,16 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for Term<'a> {\n+    type Lifted = ty::Term<'tcx>;\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        Some(match self {\n+            Term::Ty(ty) => Term::Ty(tcx.lift(ty)?),\n+            Term::Const(c) => Term::Const(tcx.lift(c)?),\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n@@ -403,8 +413,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n-        tcx.lift((self.projection_ty, self.ty))\n-            .map(|(projection_ty, ty)| ty::ProjectionPredicate { projection_ty, ty })\n+        tcx.lift((self.projection_ty, self.term))\n+            .map(|(projection_ty, term)| ty::ProjectionPredicate { projection_ty, term })\n     }\n }\n \n@@ -413,7 +423,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(self.substs).map(|substs| ty::ExistentialProjection {\n             substs,\n-            ty: tcx.lift(self.ty).expect(\"type must lift when substs do\"),\n+            term: tcx.lift(self.term).expect(\"type must lift when substs do\"),\n             item_def_id: self.item_def_id,\n         })\n     }"}, {"sha": "20db25f7899ddc3082062efc1b1a6f145d8633cb", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -8,7 +8,7 @@ use crate::infer::canonical::Canonical;\n use crate::ty::fold::ValidateBoundVars;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::InferTy::{self, *};\n-use crate::ty::{self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable};\n+use crate::ty::{self, AdtDef, DefIdTree, Discr, Term, Ty, TyCtxt, TypeFlags, TypeFoldable};\n use crate::ty::{DelaySpanBugEmitted, List, ParamEnv, TyS};\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n@@ -1540,7 +1540,7 @@ impl From<BoundVar> for BoundTy {\n pub struct ExistentialProjection<'tcx> {\n     pub item_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n-    pub ty: Ty<'tcx>,\n+    pub term: Term<'tcx>,\n }\n \n pub type PolyExistentialProjection<'tcx> = Binder<'tcx, ExistentialProjection<'tcx>>;\n@@ -1570,7 +1570,7 @@ impl<'tcx> ExistentialProjection<'tcx> {\n                 item_def_id: self.item_def_id,\n                 substs: tcx.mk_substs_trait(self_ty, self.substs),\n             },\n-            ty: self.ty,\n+            term: self.term,\n         }\n     }\n \n@@ -1584,7 +1584,7 @@ impl<'tcx> ExistentialProjection<'tcx> {\n         Self {\n             item_def_id: projection_predicate.projection_ty.item_def_id,\n             substs: tcx.intern_substs(&projection_predicate.projection_ty.substs[1..]),\n-            ty: projection_predicate.ty,\n+            term: projection_predicate.term,\n         }\n     }\n }"}, {"sha": "38aa76333851f76007966ce0738f9aa323942ca4", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -157,15 +157,18 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 stack.extend(obj.iter().rev().flat_map(|predicate| {\n                     let (substs, opt_ty) = match predicate.skip_binder() {\n                         ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n-                        ty::ExistentialPredicate::Projection(p) => (p.substs, Some(p.ty)),\n+                        ty::ExistentialPredicate::Projection(p) => (p.substs, Some(p.term)),\n                         ty::ExistentialPredicate::AutoTrait(_) =>\n                         // Empty iterator\n                         {\n                             (ty::InternalSubsts::empty(), None)\n                         }\n                     };\n \n-                    substs.iter().rev().chain(opt_ty.map(|ty| ty.into()))\n+                    substs.iter().rev().chain(opt_ty.map(|term| match term {\n+                        ty::Term::Ty(ty) => ty.into(),\n+                        ty::Term::Const(ct) => ct.into(),\n+                    }))\n                 }));\n             }\n             ty::Adt(_, substs)"}, {"sha": "4e60b7593c65167f95a4e9e5d050459c7b463014", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -4,8 +4,8 @@ use crate::maybe_whole;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_ast::{\n-    self as ast, AngleBracketedArg, AngleBracketedArgs, AnonConst, AssocTyConstraint,\n-    AssocTyConstraintKind, BlockCheckMode, GenericArg, GenericArgs, Generics, ParenthesizedArgs,\n+    self as ast, AngleBracketedArg, AngleBracketedArgs, AnonConst, AssocConstraint,\n+    AssocConstraintKind, BlockCheckMode, GenericArg, GenericArgs, Generics, ParenthesizedArgs,\n     Path, PathSegment, QSelf,\n };\n use rustc_errors::{pluralize, Applicability, PResult};\n@@ -469,24 +469,21 @@ impl<'a> Parser<'a> {\n                         // Parse associated type constraint bound.\n \n                         let bounds = self.parse_generic_bounds(Some(self.prev_token.span))?;\n-                        AssocTyConstraintKind::Bound { bounds }\n+                        AssocConstraintKind::Bound { bounds }\n                     } else if self.eat(&token::Eq) {\n-                        // Parse associated type equality constraint\n-\n-                        let ty = self.parse_assoc_equality_term(ident, self.prev_token.span)?;\n-                        AssocTyConstraintKind::Equality { ty }\n+                        self.parse_assoc_equality_term(ident, self.prev_token.span)?\n                     } else {\n                         unreachable!();\n                     };\n \n                     let span = lo.to(self.prev_token.span);\n \n                     // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n-                    if let AssocTyConstraintKind::Bound { .. } = kind {\n+                    if let AssocConstraintKind::Bound { .. } = kind {\n                         self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n                     }\n                     let constraint =\n-                        AssocTyConstraint { id: ast::DUMMY_NODE_ID, ident, gen_args, kind, span };\n+                        AssocConstraint { id: ast::DUMMY_NODE_ID, ident, gen_args, kind, span };\n                     Ok(Some(AngleBracketedArg::Constraint(constraint)))\n                 } else {\n                     Ok(Some(AngleBracketedArg::Arg(arg)))\n@@ -499,22 +496,25 @@ impl<'a> Parser<'a> {\n     /// Parse the term to the right of an associated item equality constraint.\n     /// That is, parse `<term>` in `Item = <term>`.\n     /// Right now, this only admits types in `<term>`.\n-    fn parse_assoc_equality_term(&mut self, ident: Ident, eq: Span) -> PResult<'a, P<ast::Ty>> {\n+    fn parse_assoc_equality_term(\n+        &mut self,\n+        ident: Ident,\n+        eq: Span,\n+    ) -> PResult<'a, AssocConstraintKind> {\n         let arg = self.parse_generic_arg(None)?;\n         let span = ident.span.to(self.prev_token.span);\n-        match arg {\n-            Some(GenericArg::Type(ty)) => return Ok(ty),\n-            Some(GenericArg::Const(expr)) => {\n-                self.struct_span_err(span, \"cannot constrain an associated constant to a value\")\n-                    .span_label(ident.span, \"this associated constant...\")\n-                    .span_label(expr.value.span, \"...cannot be constrained to this value\")\n-                    .emit();\n+        let term = match arg {\n+            Some(GenericArg::Type(ty)) => ty.into(),\n+            Some(GenericArg::Const(c)) => {\n+                self.sess.gated_spans.gate(sym::associated_const_equality, span);\n+                c.into()\n             }\n             Some(GenericArg::Lifetime(lt)) => {\n                 self.struct_span_err(span, \"associated lifetimes are not supported\")\n                     .span_label(lt.ident.span, \"the lifetime is given here\")\n                     .help(\"if you meant to specify a trait object, write `dyn Trait + 'lifetime`\")\n                     .emit();\n+                self.mk_ty(span, ast::TyKind::Err).into()\n             }\n             None => {\n                 let after_eq = eq.shrink_to_hi();\n@@ -542,8 +542,8 @@ impl<'a> Parser<'a> {\n                 };\n                 return Err(err);\n             }\n-        }\n-        Ok(self.mk_ty(span, ast::TyKind::Err))\n+        };\n+        Ok(AssocConstraintKind::Equality { term })\n     }\n \n     /// We do not permit arbitrary expressions as const arguments. They must be one of:"}, {"sha": "6cf1aa480d298e1d64eefeb00cc95b23fe913fab", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -332,9 +332,9 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_path_segment(self, path_span, path_segment)\n     }\n \n-    fn visit_assoc_ty_constraint(&mut self, constraint: &'v ast::AssocTyConstraint) {\n-        self.record(\"AssocTyConstraint\", Id::None, constraint);\n-        ast_visit::walk_assoc_ty_constraint(self, constraint)\n+    fn visit_assoc_constraint(&mut self, constraint: &'v ast::AssocConstraint) {\n+        self.record(\"AssocConstraint\", Id::None, constraint);\n+        ast_visit::walk_assoc_constraint(self, constraint)\n     }\n \n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {"}, {"sha": "2c96899197351836e835ab4d36a9f489bf71d79a", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -127,8 +127,8 @@ where\n                 constness: _,\n                 polarity: _,\n             }) => self.visit_trait(trait_ref),\n-            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n-                ty.visit_with(self)?;\n+            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n+                term.visit_with(self)?;\n                 self.visit_projection_ty(projection_ty)\n             }\n             ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n@@ -1185,10 +1185,10 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             }\n \n             for (poly_predicate, _) in bounds.projection_bounds {\n-                if self.visit(poly_predicate.skip_binder().ty).is_break()\n-                    || self\n-                        .visit_projection_ty(poly_predicate.skip_binder().projection_ty)\n-                        .is_break()\n+                let pred = poly_predicate.skip_binder();\n+                let poly_pred_term = self.visit(pred.term);\n+                if poly_pred_term.is_break()\n+                    || self.visit_projection_ty(pred.projection_ty).is_break()\n                 {\n                     return;\n                 }"}, {"sha": "075a9764d4c7fbb644ca3917beb1d771d6ce7f39", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -343,6 +343,7 @@ symbols! {\n         assert_receiver_is_total_eq,\n         assert_uninit_valid,\n         assert_zero_valid,\n+        associated_const_equality,\n         associated_consts,\n         associated_type_bounds,\n         associated_type_defaults,"}, {"sha": "809b9732529742663d94b487fb33dd1a32099dc5", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -559,7 +559,10 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                         let name = cx.tcx.associated_item(projection.item_def_id).ident;\n                         cx.push(\"p\");\n                         cx.push_ident(name.as_str());\n-                        cx = projection.ty.print(cx)?;\n+                        cx = match projection.term {\n+                            ty::Term::Ty(ty) => ty.print(cx),\n+                            ty::Term::Const(c) => c.print(cx),\n+                        }?;\n                     }\n                     ty::ExistentialPredicate::AutoTrait(def_id) => {\n                         cx = cx.print_def_path(*def_id, &[])?;"}, {"sha": "f2ed5ae26a3c268569cf3174c25ef9d77e04407a", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -6,7 +6,7 @@ use super::*;\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::{Region, RegionVid};\n+use rustc_middle::ty::{Region, RegionVid, Term};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n@@ -606,7 +606,11 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     }\n \n     fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n-        matches!(*p.ty().skip_binder().kind(), ty::Projection(proj) if proj == p.skip_binder().projection_ty)\n+        if let Term::Ty(ty) = p.term().skip_binder() {\n+            matches!(ty.kind(), ty::Projection(proj) if proj == &p.skip_binder().projection_ty)\n+        } else {\n+            false\n+        }\n     }\n \n     fn evaluate_nested_obligations(\n@@ -663,7 +667,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                     // Additionally, we check if we've seen this predicate before,\n                     // to avoid rendering duplicate bounds to the user.\n                     if self.is_param_no_infer(p.skip_binder().projection_ty.substs)\n-                        && !p.ty().skip_binder().has_infer_types()\n+                        && !p.term().skip_binder().has_infer_types()\n                         && is_new_pred\n                     {\n                         debug!(\n@@ -752,7 +756,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                             // when we started out trying to unify\n                             // some inference variables. See the comment above\n                             // for more infomration\n-                            if p.ty().skip_binder().has_infer_types() {\n+                            if p.term().skip_binder().has_infer_types() {\n                                 if !self.evaluate_nested_obligations(\n                                     ty,\n                                     v.into_iter(),\n@@ -774,7 +778,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                             // However, we should always make progress (either by generating\n                             // subobligations or getting an error) when we started off with\n                             // inference variables\n-                            if p.ty().skip_binder().has_infer_types() {\n+                            if p.term().skip_binder().has_infer_types() {\n                                 panic!(\"Unexpected result when selecting {:?} {:?}\", ty, obligation)\n                             }\n                         }"}, {"sha": "0760f62685127a26354cb0dadd02f25c927a591d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1304,7 +1304,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n \n                 debug!(\n                     \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n-                    normalized_ty, data.ty\n+                    normalized_ty, data.term,\n                 );\n \n                 let is_normalized_ty_expected = !matches!(\n@@ -1314,16 +1314,17 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                         | ObligationCauseCode::ObjectCastObligation(_)\n                         | ObligationCauseCode::OpaqueType\n                 );\n-\n+                // FIXME(associated_const_equality): Handle Consts here\n+                let data_ty = data.term.ty().unwrap();\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n                     is_normalized_ty_expected,\n                     normalized_ty,\n-                    data.ty,\n+                    data_ty,\n                 ) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n                         is_normalized_ty_expected,\n                         normalized_ty,\n-                        data.ty,\n+                        data_ty,\n                     )));\n \n                     err_buf = error;\n@@ -1803,11 +1804,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             ty::PredicateKind::Projection(data) => {\n                 let self_ty = data.projection_ty.self_ty();\n-                let ty = data.ty;\n+                let term = data.term;\n                 if predicate.references_error() || self.is_tainted_by_errors() {\n                     return;\n                 }\n-                if self_ty.needs_infer() && ty.needs_infer() {\n+                if self_ty.needs_infer() && term.needs_infer() {\n                     // We do this for the `foo.collect()?` case to produce a suggestion.\n                     let mut err = self.emit_inference_failure_err(\n                         body_id,"}, {"sha": "7bfedecbdc7c9b240c4d7a014c8093000f7b2118", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -571,7 +571,7 @@ fn object_ty_for_trait<'tcx>(\n         // `trait MyTrait: for<'s> OtherTrait<&'s T, Output=bool>`.\n         super_trait_ref.map_bound(|super_trait_ref| {\n             ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n-                ty: tcx.mk_projection(item.def_id, super_trait_ref.substs),\n+                term: tcx.mk_projection(item.def_id, super_trait_ref.substs).into(),\n                 item_def_id: item.def_id,\n                 substs: super_trait_ref.substs,\n             })"}, {"sha": "f49f53351aac8dc6a129eea5683a3fa095ec2811", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -212,10 +212,9 @@ fn project_and_unify_type<'cx, 'tcx>(\n     debug!(?normalized_ty, ?obligations, \"project_and_unify_type result\");\n \n     let infcx = selcx.infcx();\n-    match infcx\n-        .at(&obligation.cause, obligation.param_env)\n-        .eq(normalized_ty, obligation.predicate.ty)\n-    {\n+    // FIXME(associated_const_equality): Handle consts here as well as types.\n+    let obligation_pred_ty = obligation.predicate.term.ty().unwrap();\n+    match infcx.at(&obligation.cause, obligation.param_env).eq(normalized_ty, obligation_pred_ty) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Ok(Some(obligations)))\n@@ -1615,7 +1614,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n                 substs: trait_ref.substs,\n                 item_def_id: obligation.predicate.item_def_id,\n             },\n-            ty,\n+            term: ty.into(),\n         }\n     });\n \n@@ -1641,7 +1640,7 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n \n     let predicate = ty::ProjectionPredicate {\n         projection_ty: ty::ProjectionTy { substs, item_def_id: discriminant_def_id },\n-        ty: self_ty.discriminant_ty(tcx),\n+        term: self_ty.discriminant_ty(tcx).into(),\n     };\n \n     // We get here from `poly_project_and_unify_type` which replaces bound vars\n@@ -1674,7 +1673,7 @@ fn confirm_pointee_candidate<'cx, 'tcx>(\n \n     let predicate = ty::ProjectionPredicate {\n         projection_ty: ty::ProjectionTy { substs, item_def_id: metadata_def_id },\n-        ty: metadata_ty,\n+        term: metadata_ty.into(),\n     };\n \n     confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n@@ -1747,7 +1746,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n             substs: trait_ref.substs,\n             item_def_id: fn_once_output_def_id,\n         },\n-        ty: ret_type,\n+        term: ret_type.into(),\n     });\n \n     confirm_param_env_candidate(selcx, obligation, predicate, true)\n@@ -1803,7 +1802,9 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n         Ok(InferOk { value: _, obligations }) => {\n             nested_obligations.extend(obligations);\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);\n-            Progress { ty: cache_entry.ty, obligations: nested_obligations }\n+            // FIXME(associated_const_equality): Handle consts here as well? Maybe this progress type should just take\n+            // a term instead.\n+            Progress { ty: cache_entry.term.ty().unwrap(), obligations: nested_obligations }\n         }\n         Err(e) => {\n             let msg = format!("}, {"sha": "aea44841b8f128b9345c128c2019b9155d221199", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn update<'tcx, T>(\n     if let ty::PredicateKind::Projection(predicate) = obligation.predicate.kind().skip_binder() {\n         // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n         // we need to make it into one.\n-        if let Some(vid) = predicate.ty.ty_vid() {\n+        if let Some(vid) = predicate.term.ty().and_then(|ty| ty.ty_vid()) {\n             debug!(\"relationship: {:?}.output = true\", vid);\n             engine.relationships().entry(vid).or_default().output = true;\n         }"}, {"sha": "6a355b567e0916538d82ff32a3a7bcc8e5f89397", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -116,7 +116,10 @@ pub fn predicate_obligations<'a, 'tcx>(\n         }\n         ty::PredicateKind::Projection(t) => {\n             wf.compute_projection(t.projection_ty);\n-            wf.compute(t.ty.into());\n+            wf.compute(match t.term {\n+                ty::Term::Ty(ty) => ty.into(),\n+                ty::Term::Const(c) => c.into(),\n+            })\n         }\n         ty::PredicateKind::WellFormed(arg) => {\n             wf.compute(arg);\n@@ -219,7 +222,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            if let ty::Projection(projection_ty) = proj.ty.kind() {\n+            if let Some(ty::Projection(projection_ty)) = proj.term.ty().map(|ty| ty.kind()) {\n                 if let Some(&impl_item_id) =\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n                 {"}, {"sha": "67d0ba39667d31127bb910d1283bace99b87356c", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -226,13 +226,26 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n     for rustc_middle::ty::ProjectionPredicate<'tcx>\n {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::AliasEq<RustInterner<'tcx>> {\n+        // FIXME(associated_const_equality): teach chalk about terms for alias eq.\n         chalk_ir::AliasEq {\n-            ty: self.ty.lower_into(interner),\n+            ty: self.term.ty().unwrap().lower_into(interner),\n             alias: self.projection_ty.lower_into(interner),\n         }\n     }\n }\n \n+/*\n+// FIXME(...): Where do I add this to Chalk? I can't find it in the rustc repo anywhere.\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Term<RustInterner<'tcx>>> for rustc_middle::ty::Term<'tcx> {\n+  fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::Term<RustInterner<'tcx>> {\n+    match self {\n+      ty::Term::Ty(ty) => ty.lower_into(interner).into(),\n+      ty::Term::Const(c) => c.lower_into(interner).into(),\n+    }\n+  }\n+}\n+*/\n+\n impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n         let int = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(i));\n@@ -651,7 +664,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n                                 .mk_substs_trait(self_ty, predicate.substs)\n                                 .lower_into(interner),\n                         }),\n-                        ty: predicate.ty.lower_into(interner),\n+                        // FIXME(associated_const_equality): teach chalk about terms for alias eq.\n+                        ty: predicate.term.ty().unwrap().lower_into(interner),\n                     }),\n                 ),\n                 ty::ExistentialPredicate::AutoTrait(def_id) => chalk_ir::Binders::new(\n@@ -787,7 +801,7 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n             trait_bound: trait_ref.lower_into(interner),\n             associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.item_def_id),\n             parameters: own_substs.iter().map(|arg| arg.lower_into(interner)).collect(),\n-            value: self.ty.lower_into(interner),\n+            value: self.term.ty().unwrap().lower_into(interner),\n         }\n     }\n }"}, {"sha": "b532c41642c6e88b814b41cc79e804ed0afad937", "filename": "compiler/rustc_typeck/src/astconv/errors.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -151,8 +151,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .bindings\n                     .iter()\n                     .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n-                        (true, hir::TypeBindingKind::Equality { ty }) => {\n-                            sess.source_map().span_to_snippet(ty.span).ok()\n+                        (true, hir::TypeBindingKind::Equality { term }) => {\n+                            let span = match term {\n+                                hir::Term::Ty(ty) => ty.span,\n+                                hir::Term::Const(c) => self.tcx().hir().span(c.hir_id),\n+                            };\n+                            sess.source_map().span_to_snippet(span).ok()\n                         }\n                         _ => None,\n                     })"}, {"sha": "7c53e49e280d6e7cd849c6d10f05124a8b3e9975", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -123,7 +123,7 @@ struct ConvertedBinding<'a, 'tcx> {\n \n #[derive(Debug)]\n enum ConvertedBindingKind<'a, 'tcx> {\n-    Equality(Ty<'tcx>),\n+    Equality(ty::Term<'tcx>),\n     Constraint(&'a [hir::GenericBound<'a>]),\n }\n \n@@ -601,10 +601,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .iter()\n             .map(|binding| {\n                 let kind = match binding.kind {\n-                    hir::TypeBindingKind::Equality { ty } => {\n-                        ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty))\n-                    }\n-                    hir::TypeBindingKind::Constraint { bounds } => {\n+                    hir::TypeBindingKind::Equality { ref term } => match term {\n+                        hir::Term::Ty(ref ty) => {\n+                            ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty).into())\n+                        }\n+                        hir::Term::Const(ref c) => {\n+                            let local_did = self.tcx().hir().local_def_id(c.hir_id);\n+                            let c = Const::from_anon_const(self.tcx(), local_did);\n+                            ConvertedBindingKind::Equality(c.into())\n+                        }\n+                    },\n+                    hir::TypeBindingKind::Constraint { ref bounds } => {\n                         ConvertedBindingKind::Constraint(bounds)\n                     }\n                 };\n@@ -867,6 +874,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, trait_def_id)\n             .is_some()\n     }\n+    fn trait_defines_associated_named(&self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n+        self.tcx()\n+            .associated_items(trait_def_id)\n+            .find_by_name_and_kinds(\n+                self.tcx(),\n+                assoc_name,\n+                &[ty::AssocKind::Type, ty::AssocKind::Const],\n+                trait_def_id,\n+            )\n+            .is_some()\n+    }\n \n     // Sets `implicitly_sized` to true on `Bounds` if necessary\n     pub(crate) fn add_implicitly_sized<'hir>(\n@@ -1118,9 +1136,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .associated_items(candidate.def_id())\n             .filter_by_name_unhygienic(assoc_ident.name)\n             .find(|i| {\n-                i.kind == ty::AssocKind::Type && i.ident.normalize_to_macros_2_0() == assoc_ident\n+                (i.kind == ty::AssocKind::Type || i.kind == ty::AssocKind::Const)\n+                    && i.ident.normalize_to_macros_2_0() == assoc_ident\n             })\n             .expect(\"missing associated type\");\n+        // FIXME(associated_const_equality): need to handle assoc_consts here as well.\n+        if assoc_ty.kind == ty::AssocKind::Const {\n+            tcx.sess\n+                .struct_span_err(path_span, &format!(\"associated const equality is incomplete\"))\n+                .span_label(path_span, \"cannot yet relate associated const\")\n+                .emit();\n+            return Err(ErrorReported);\n+        }\n \n         if !assoc_ty.vis.is_accessible_from(def_scope, tcx) {\n             tcx.sess\n@@ -1215,18 +1242,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         match binding.kind {\n-            ConvertedBindingKind::Equality(ty) => {\n+            ConvertedBindingKind::Equality(term) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n                 // the \"projection predicate\" for:\n                 //\n                 // `<T as Iterator>::Item = u32`\n                 bounds.projection_bounds.push((\n-                    projection_ty.map_bound(|projection_ty| {\n-                        debug!(\n-                            \"add_predicates_for_ast_type_binding: projection_ty {:?}, substs: {:?}\",\n-                            projection_ty, projection_ty.substs\n-                        );\n-                        ty::ProjectionPredicate { projection_ty, ty }\n+                    projection_ty.map_bound(|projection_ty| ty::ProjectionPredicate {\n+                        projection_ty,\n+                        term: term,\n                     }),\n                     binding.span,\n                 ));\n@@ -1377,8 +1401,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         let pred = bound_predicate.rebind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n-                        let references_self =\n-                            pred.skip_binder().ty.walk().any(|arg| arg == dummy_self.into());\n+                        let references_self = match pred.skip_binder().term {\n+                            ty::Term::Ty(ty) => ty.walk().any(|arg| arg == dummy_self.into()),\n+                            ty::Term::Const(c) => c.ty.walk().any(|arg| arg == dummy_self.into()),\n+                        };\n \n                         // If the projection output contains `Self`, force the user to\n                         // elaborate it explicitly to avoid a lot of complexity.\n@@ -1601,7 +1627,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n     {\n         let mut matching_candidates = all_candidates()\n-            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_name));\n+            .filter(|r| self.trait_defines_associated_named(r.def_id(), assoc_name));\n \n         let bound = match matching_candidates.next() {\n             Some(bound) => bound,"}, {"sha": "6a28bb16a20acf2945f940d3f376d957529c3adf", "filename": "compiler/rustc_typeck/src/bounds.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -48,14 +48,19 @@ impl<'tcx> Bounds<'tcx> {\n     /// where-clauses). Because some of our bounds listings (e.g.,\n     /// regions) don't include the self-type, you must supply the\n     /// self-type here (the `param_ty` parameter).\n-    pub fn predicates(\n-        &self,\n+    pub fn predicates<'out, 's>(\n+        &'s self,\n         tcx: TyCtxt<'tcx>,\n         param_ty: Ty<'tcx>,\n-    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n+        // the output must live shorter than the duration of the borrow of self and 'tcx.\n+    ) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> + 'out\n+    where\n+        'tcx: 'out,\n+        's: 'out,\n+    {\n         // If it could be sized, and is, add the `Sized` predicate.\n         let sized_predicate = self.implicitly_sized.and_then(|span| {\n-            tcx.lang_items().sized_trait().map(|sized| {\n+            tcx.lang_items().sized_trait().map(move |sized| {\n                 let trait_ref = ty::Binder::dummy(ty::TraitRef {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[]),\n@@ -64,25 +69,22 @@ impl<'tcx> Bounds<'tcx> {\n             })\n         });\n \n-        sized_predicate\n-            .into_iter()\n-            .chain(self.region_bounds.iter().map(|&(region_bound, span)| {\n-                (\n-                    region_bound\n-                        .map_bound(|region_bound| ty::OutlivesPredicate(param_ty, region_bound))\n-                        .to_predicate(tcx),\n-                    span,\n-                )\n-            }))\n-            .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n+        let region_preds = self.region_bounds.iter().map(move |&(region_bound, span)| {\n+            let pred = region_bound\n+                .map_bound(|region_bound| ty::OutlivesPredicate(param_ty, region_bound))\n+                .to_predicate(tcx);\n+            (pred, span)\n+        });\n+        let trait_bounds =\n+            self.trait_bounds.iter().map(move |&(bound_trait_ref, span, constness)| {\n                 let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n                 (predicate, span)\n-            }))\n-            .chain(\n-                self.projection_bounds\n-                    .iter()\n-                    .map(|&(projection, span)| (projection.to_predicate(tcx), span)),\n-            )\n-            .collect()\n+            });\n+        let projection_bounds = self\n+            .projection_bounds\n+            .iter()\n+            .map(move |&(projection, span)| (projection.to_predicate(tcx), span));\n+\n+        sized_predicate.into_iter().chain(region_preds).chain(trait_bounds).chain(projection_bounds)\n     }\n }"}, {"sha": "e88099afa03539ce855f6e40d2320a40c968677c", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -279,7 +279,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         };\n \n-        let ret_param_ty = projection.skip_binder().ty;\n+        // Since this is a return parameter type it is safe to unwrap.\n+        let ret_param_ty = projection.skip_binder().term.ty().unwrap();\n         let ret_param_ty = self.resolve_vars_if_possible(ret_param_ty);\n         debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n \n@@ -706,9 +707,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Extract the type from the projection. Note that there can\n         // be no bound variables in this type because the \"self type\"\n         // does not have any regions in it.\n-        let output_ty = self.resolve_vars_if_possible(predicate.ty);\n+        let output_ty = self.resolve_vars_if_possible(predicate.term);\n         debug!(\"deduce_future_output_from_projection: output_ty={:?}\", output_ty);\n-        Some(output_ty)\n+        // This is a projection on a Fn trait so will always be a type.\n+        Some(output_ty.ty().unwrap())\n     }\n \n     /// Converts the types that the user supplied, in case that doing"}, {"sha": "94648d5702c89f81fffb3529510f7d34688e09d6", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1353,7 +1353,7 @@ pub fn check_type_bounds<'tcx>(\n                             item_def_id: trait_ty.def_id,\n                             substs: rebased_substs,\n                         },\n-                        ty: impl_ty_value,\n+                        term: impl_ty_value.into(),\n                     },\n                     bound_vars,\n                 )"}, {"sha": "56f4d5afe400d8c1d3e05338364d4f5111d33c42", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -789,10 +789,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     item_def_id: projection_ty.item_def_id,\n                                 };\n \n-                                let ty = pred.skip_binder().ty;\n+                                let term = pred.skip_binder().term;\n \n-                                let obligation = format!(\"{} = {}\", projection_ty, ty);\n-                                let quiet = format!(\"{} = {}\", quiet_projection_ty, ty);\n+                                let obligation = format!(\"{} = {}\", projection_ty, term);\n+                                let quiet = format!(\"{} = {}\", quiet_projection_ty, term);\n \n                                 bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                                 Some((obligation, projection_ty.self_ty()))"}, {"sha": "34caabe44d6d9a02e42a0c09ee4475c96f024184", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -716,7 +716,11 @@ fn bounds_from_generic_predicates<'tcx>(\n         // insert the associated types where they correspond, but for now let's be \"lazy\" and\n         // propose this instead of the following valid resugaring:\n         // `T: Trait, Trait::Assoc = K` \u2192 `T: Trait<Assoc = K>`\n-        where_clauses.push(format!(\"{} = {}\", tcx.def_path_str(p.projection_ty.item_def_id), p.ty));\n+        where_clauses.push(format!(\n+            \"{} = {}\",\n+            tcx.def_path_str(p.projection_ty.item_def_id),\n+            p.term,\n+        ));\n     }\n     let where_clauses = if where_clauses.is_empty() {\n         String::new()"}, {"sha": "403aa16689fcfdc5049dc79caa572ec402a94b08", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -659,7 +659,11 @@ impl<'tcx> ItemCtxt<'tcx> {\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n-                GenericParamKind::Type { .. } if param.hir_id == param_id => Some(&param.bounds),\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. }\n+                    if param.hir_id == param_id =>\n+                {\n+                    Some(&param.bounds)\n+                }\n                 _ => None,\n             })\n             .flat_map(|bounds| bounds.iter())\n@@ -2527,7 +2531,7 @@ fn predicates_from_bound<'tcx>(\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     let mut bounds = Bounds::default();\n     astconv.add_bounds(param_ty, [bound].into_iter(), &mut bounds, bound_vars);\n-    bounds.predicates(astconv.tcx(), param_ty)\n+    bounds.predicates(astconv.tcx(), param_ty).collect()\n }\n \n fn compute_sig_of_foreign_fn_decl<'tcx>("}, {"sha": "87a67c4a4e060ed147802f1cacd9c298bdbfc667", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -67,11 +67,7 @@ fn opaque_type_bounds<'tcx>(\n         let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n         // Opaque types are implicitly sized unless a `?Sized` bound is found\n         <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, ast_bounds, None, span);\n-        let bounds = bounds.predicates(tcx, item_ty);\n-\n-        debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n-\n-        tcx.arena.alloc_slice(&bounds)\n+        tcx.arena.alloc_from_iter(bounds.predicates(tcx, item_ty))\n     })\n }\n "}, {"sha": "a0c8fc822dffd88769c78094b71dda48211d0125", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -203,7 +203,7 @@ pub fn setup_constraining_predicates<'tcx>(\n                 if !relies_only_on_inputs {\n                     continue;\n                 }\n-                input_parameters.extend(parameters_for(&projection.ty, false));\n+                input_parameters.extend(parameters_for(&projection.term, false));\n             } else {\n                 continue;\n             }"}, {"sha": "d87e670a8fb5a7bf912ea64031a9b1a5d70e4944", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -199,7 +199,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n         if let ty::PredicateKind::Projection(proj) = predicate.kind().skip_binder() {\n             let projection_ty = proj.projection_ty;\n-            let projected_ty = proj.ty;\n+            let projected_ty = proj.term;\n \n             let unbound_trait_ref = projection_ty.trait_ref(tcx);\n             if Some(unbound_trait_ref) == impl_trait_ref {"}, {"sha": "7c504a0d89c59aa98b6348a0d7aa55a48bd9390d", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -308,11 +308,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n \n                 for projection in data.projection_bounds() {\n-                    self.add_constraints_from_ty(\n-                        current,\n-                        projection.skip_binder().ty,\n-                        self.invariant,\n-                    );\n+                    match projection.skip_binder().term {\n+                        ty::Term::Ty(ty) => {\n+                            self.add_constraints_from_ty(current, ty, self.invariant);\n+                        }\n+                        ty::Term::Const(c) => {\n+                            self.add_constraints_from_const(current, c, self.invariant)\n+                        }\n+                    }\n                 }\n             }\n "}, {"sha": "de1717b3f3f9a983ecc145ffb19f71c6f807c1b1", "filename": "src/etc/check_missing_items.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -83,7 +83,9 @@ def check_type(ty):\n                         check_type(arg[\"const\"][\"type\"])\n                 for binding in args[\"angle_bracketed\"][\"bindings\"]:\n                     if \"equality\" in binding[\"binding\"]:\n-                        check_type(binding[\"binding\"][\"equality\"])\n+                        term = binding[\"binding\"][\"equality\"]\n+                        if \"type\" in term: check_type(term[\"type\"])\n+                        elif \"const\" in term: check_type(term[\"const\"])\n                     elif \"constraint\" in binding[\"binding\"]:\n                         for bound in binding[\"binding\"][\"constraint\"]:\n                             check_generic_bound(bound)"}, {"sha": "18a4d8a475380f328ec17ef2792a5114c1e66231", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -553,8 +553,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             if self.is_fn_trait(trait_) && left_name == sym::Output {\n                                 ty_to_fn\n                                     .entry(*ty.clone())\n-                                    .and_modify(|e| *e = (e.0.clone(), Some(rhs.clone())))\n-                                    .or_insert((None, Some(rhs)));\n+                                    .and_modify(|e| {\n+                                        *e = (e.0.clone(), Some(rhs.ty().unwrap().clone()))\n+                                    })\n+                                    .or_insert((None, Some(rhs.ty().unwrap().clone())));\n                                 continue;\n                             }\n \n@@ -570,7 +572,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                 GenericArgs::AngleBracketed { ref mut bindings, .. } => {\n                                     bindings.push(TypeBinding {\n                                         name: left_name,\n-                                        kind: TypeBindingKind::Equality { ty: rhs },\n+                                        kind: TypeBindingKind::Equality { term: rhs },\n                                     });\n                                 }\n                                 GenericArgs::Parenthesized { .. } => {"}, {"sha": "e759baa045892d3bbe1a6e97f42bc6a5fe6e3b42", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -272,9 +272,10 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n                 bounds: wrp.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n             },\n \n-            hir::WherePredicate::EqPredicate(ref wrp) => {\n-                WherePredicate::EqPredicate { lhs: wrp.lhs_ty.clean(cx), rhs: wrp.rhs_ty.clean(cx) }\n-            }\n+            hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {\n+                lhs: wrp.lhs_ty.clean(cx),\n+                rhs: wrp.rhs_ty.clean(cx).into(),\n+            },\n         }\n     }\n }\n@@ -352,10 +353,31 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     }\n }\n \n+impl<'tcx> Clean<Term> for ty::Term<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Term {\n+        match self {\n+            ty::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n+            ty::Term::Const(c) => Term::Constant(c.clean(cx)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<Term> for hir::Term<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Term {\n+        match self {\n+            hir::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n+            hir::Term::Const(c) => {\n+                let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n+                Term::Constant(ty::Const::from_anon_const(cx.tcx, def_id).clean(cx))\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n-        let ty::ProjectionPredicate { projection_ty, ty } = self;\n-        WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n+        let ty::ProjectionPredicate { projection_ty, term } = self;\n+        WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: term.clean(cx) }\n     }\n }\n \n@@ -613,7 +635,7 @@ fn clean_ty_generics(\n \n             if let Some(param_idx) = param_idx {\n                 if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                    let p = p.clean(cx)?;\n+                    let p: WherePredicate = p.clean(cx)?;\n \n                     b.extend(\n                         p.get_bounds()\n@@ -624,11 +646,16 @@ fn clean_ty_generics(\n                     );\n \n                     let proj = projection\n-                        .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().ty));\n+                        .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().term));\n                     if let Some(((_, trait_did, name), rhs)) =\n                         proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n                     {\n-                        impl_trait_proj.entry(param_idx).or_default().push((trait_did, name, rhs));\n+                        // FIXME(...): Remove this unwrap()\n+                        impl_trait_proj.entry(param_idx).or_default().push((\n+                            trait_did,\n+                            name,\n+                            rhs.ty().unwrap(),\n+                        ));\n                     }\n \n                     return None;\n@@ -647,7 +674,7 @@ fn clean_ty_generics(\n             if let Some(proj) = impl_trait_proj.remove(&idx) {\n                 for (trait_did, name, rhs) in proj {\n                     let rhs = rhs.clean(cx);\n-                    simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n+                    simplify::merge_bounds(cx, &mut bounds, trait_did, name, &Term::Type(rhs));\n                 }\n             }\n         } else {\n@@ -1495,7 +1522,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 for pb in obj.projection_bounds() {\n                     bindings.push(TypeBinding {\n                         name: cx.tcx.associated_item(pb.item_def_id()).ident.name,\n-                        kind: TypeBindingKind::Equality { ty: pb.skip_binder().ty.clean(cx) },\n+                        kind: TypeBindingKind::Equality {\n+                            term: pb.skip_binder().term.clean(cx).into(),\n+                        },\n                     });\n                 }\n \n@@ -1566,7 +1595,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                                 .ident\n                                                 .name,\n                                             kind: TypeBindingKind::Equality {\n-                                                ty: proj.ty.clean(cx),\n+                                                term: proj.term.clean(cx),\n                                             },\n                                         })\n                                     } else {\n@@ -2114,10 +2143,10 @@ impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> TypeBindingKind {\n         match *self {\n-            hir::TypeBindingKind::Equality { ref ty } => {\n-                TypeBindingKind::Equality { ty: ty.clean(cx) }\n+            hir::TypeBindingKind::Equality { ref term } => {\n+                TypeBindingKind::Equality { term: term.clean(cx) }\n             }\n-            hir::TypeBindingKind::Constraint { bounds } => TypeBindingKind::Constraint {\n+            hir::TypeBindingKind::Constraint { ref bounds } => TypeBindingKind::Constraint {\n                 bounds: bounds.iter().filter_map(|b| b.clean(cx)).collect(),\n             },\n         }"}, {"sha": "0bad153280822f971d101f4aad49b5e651e6ffd3", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -92,7 +92,7 @@ crate fn merge_bounds(\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,\n     name: Symbol,\n-    rhs: &clean::Type,\n+    rhs: &clean::Term,\n ) -> bool {\n     !bounds.iter_mut().any(|b| {\n         let trait_ref = match *b {\n@@ -110,14 +110,14 @@ crate fn merge_bounds(\n             PP::AngleBracketed { ref mut bindings, .. } => {\n                 bindings.push(clean::TypeBinding {\n                     name,\n-                    kind: clean::TypeBindingKind::Equality { ty: rhs.clone() },\n+                    kind: clean::TypeBindingKind::Equality { term: rhs.clone() },\n                 });\n             }\n             PP::Parenthesized { ref mut output, .. } => match output {\n-                Some(o) => assert_eq!(o.as_ref(), rhs),\n+                Some(o) => assert_eq!(&clean::Term::Type(o.as_ref().clone()), rhs),\n                 None => {\n-                    if *rhs != clean::Type::Tuple(Vec::new()) {\n-                        *output = Some(Box::new(rhs.clone()));\n+                    if *rhs != clean::Term::Type(clean::Type::Tuple(Vec::new())) {\n+                        *output = Some(Box::new(rhs.ty().unwrap().clone()));\n                     }\n                 }\n             },"}, {"sha": "fac1a0817e03300dc94d5c2b2df4e31dc1738ce8", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1212,7 +1212,7 @@ impl Lifetime {\n crate enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound>, bound_params: Vec<Lifetime> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n-    EqPredicate { lhs: Type, rhs: Type },\n+    EqPredicate { lhs: Type, rhs: Term },\n }\n \n impl WherePredicate {\n@@ -1308,7 +1308,9 @@ impl FnDecl {\n             FnRetTy::Return(Type::ImplTrait(bounds)) => match &bounds[0] {\n                 GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n                     let bindings = trait_.bindings().unwrap();\n-                    FnRetTy::Return(bindings[0].ty().clone())\n+                    let ret_ty = bindings[0].term();\n+                    let ty = ret_ty.ty().expect(\"Unexpected constant return term\");\n+                    FnRetTy::Return(ty.clone())\n                 }\n                 _ => panic!(\"unexpected desugaring of async function\"),\n             },\n@@ -2121,6 +2123,24 @@ crate struct Constant {\n     crate kind: ConstantKind,\n }\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+crate enum Term {\n+    Type(Type),\n+    Constant(Constant),\n+}\n+\n+impl Term {\n+    crate fn ty(&self) -> Option<&Type> {\n+        if let Term::Type(ty) = self { Some(ty) } else { None }\n+    }\n+}\n+\n+impl From<Type> for Term {\n+    fn from(ty: Type) -> Self {\n+        Term::Type(ty)\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n crate enum ConstantKind {\n     /// This is the wrapper around `ty::Const` for a non-local constant. Because it doesn't have a\n@@ -2283,14 +2303,14 @@ crate struct TypeBinding {\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate enum TypeBindingKind {\n-    Equality { ty: Type },\n+    Equality { term: Term },\n     Constraint { bounds: Vec<GenericBound> },\n }\n \n impl TypeBinding {\n-    crate fn ty(&self) -> &Type {\n+    crate fn term(&self) -> &Term {\n         match self.kind {\n-            TypeBindingKind::Equality { ref ty } => ty,\n+            TypeBindingKind::Equality { ref term } => term,\n             _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n         }\n     }"}, {"sha": "08840626259dc31eabda7e5a2a6678b54a3fd877", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1442,11 +1442,11 @@ impl clean::TypeBinding {\n         display_fn(move |f| {\n             f.write_str(self.name.as_str())?;\n             match self.kind {\n-                clean::TypeBindingKind::Equality { ref ty } => {\n+                clean::TypeBindingKind::Equality { ref term } => {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print(cx))?;\n+                        write!(f, \" = {:#}\", term.print(cx))?;\n                     } else {\n-                        write!(f, \" = {}\", ty.print(cx))?;\n+                        write!(f, \" = {}\", term.print(cx))?;\n                     }\n                 }\n                 clean::TypeBindingKind::Constraint { ref bounds } => {\n@@ -1492,6 +1492,18 @@ impl clean::GenericArg {\n     }\n }\n \n+impl clean::types::Term {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        match self {\n+            clean::types::Term::Type(ty) => ty.print(cx),\n+            _ => todo!(),\n+        }\n+    }\n+}\n+\n crate fn display_fn(f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result) -> impl fmt::Display {\n     struct WithFormatter<F>(Cell<Option<F>>);\n "}, {"sha": "e77bd5c9223138ddc81b0a3faf07d0ade82cd450", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -162,7 +162,7 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     fn from_tcx(kind: clean::TypeBindingKind, tcx: TyCtxt<'_>) -> Self {\n         use clean::TypeBindingKind::*;\n         match kind {\n-            Equality { ty } => TypeBindingKind::Equality(ty.into_tcx(tcx)),\n+            Equality { term } => TypeBindingKind::Equality(term.into_tcx(tcx)),\n             Constraint { bounds } => {\n                 TypeBindingKind::Constraint(bounds.into_iter().map(|a| a.into_tcx(tcx)).collect())\n             }\n@@ -452,6 +452,15 @@ impl FromWithTcx<clean::Type> for Type {\n     }\n }\n \n+impl FromWithTcx<clean::Term> for Term {\n+    fn from_tcx(term: clean::Term, tcx: TyCtxt<'_>) -> Term {\n+        match term {\n+            clean::Term::Type(ty) => Term::Type(FromWithTcx::from_tcx(ty, tcx)),\n+            clean::Term::Constant(c) => Term::Constant(FromWithTcx::from_tcx(c, tcx)),\n+        }\n+    }\n+}\n+\n impl FromWithTcx<clean::BareFunctionDecl> for FunctionPointer {\n     fn from_tcx(bare_decl: clean::BareFunctionDecl, tcx: TyCtxt<'_>) -> Self {\n         let clean::BareFunctionDecl { unsafety, generic_params, decl, abi } = bare_decl;"}, {"sha": "6b3dbcc81a470e5da84576d63fcfc19e3b1154cd", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1 +1 @@\n-Subproject commit 2abffbf977a9e8c6ca4174a08fe5c4d7781f0aac\n+Subproject commit 6b3dbcc81a470e5da84576d63fcfc19e3b1154cd"}, {"sha": "618c8aab86a19416986712912d64f3cb853cbb65", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -148,7 +148,7 @@ pub struct TypeBinding {\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n #[serde(rename_all = \"snake_case\")]\n pub enum TypeBindingKind {\n-    Equality(Type),\n+    Equality(Term),\n     Constraint(Vec<GenericBound>),\n }\n \n@@ -335,7 +335,7 @@ pub enum GenericParamDefKind {\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n     RegionPredicate { lifetime: String, bounds: Vec<GenericBound> },\n-    EqPredicate { lhs: Type, rhs: Type },\n+    EqPredicate { lhs: Type, rhs: Term },\n }\n \n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n@@ -359,6 +359,13 @@ pub enum TraitBoundModifier {\n     MaybeConst,\n }\n \n+#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"snake_case\")]\n+pub enum Term {\n+    Type(Type),\n+    Constant(Constant),\n+}\n+\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n #[serde(rename_all = \"snake_case\")]\n #[serde(tag = \"kind\", content = \"inner\")]"}, {"sha": "cd4b42f9f84c8089123ee96a5f6e87df0e978379", "filename": "src/test/ui/associated-consts/assoc-const.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -0,0 +1,21 @@\n+#![feature(associated_const_equality)]\n+\n+pub trait Foo {\n+  const N: usize;\n+}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {\n+  const N: usize = 3;\n+}\n+\n+const TEST:usize = 3;\n+\n+\n+fn foo<F: Foo<N=3>>() {}\n+//~^ ERROR associated const equality is incomplete\n+fn bar<F: Foo<N={TEST}>>() {}\n+//~^ ERROR associated const equality is incomplete\n+\n+fn main() {}"}, {"sha": "ccaa6fa8ee8847156bd2170cba80504468f6ce05", "filename": "src/test/ui/associated-consts/assoc-const.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassoc-const.stderr?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -0,0 +1,14 @@\n+error: associated const equality is incomplete\n+  --> $DIR/assoc-const.rs:16:15\n+   |\n+LL | fn foo<F: Foo<N=3>>() {}\n+   |               ^^^ cannot yet relate associated const\n+\n+error: associated const equality is incomplete\n+  --> $DIR/assoc-const.rs:18:15\n+   |\n+LL | fn bar<F: Foo<N={TEST}>>() {}\n+   |               ^^^^^^^^ cannot yet relate associated const\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b126b24853ff72a0213b9a26b8116accc9b8bb23", "filename": "src/test/ui/const-generics/parser-error-recovery/issue-89013-no-kw.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013-no-kw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013-no-kw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013-no-kw.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -7,8 +7,9 @@ struct Bar;\n const T: usize = 42;\n \n impl Foo<N = 3> for Bar {\n-//~^ ERROR cannot constrain an associated constant to a value\n+//~^ ERROR this trait takes 1 generic argument but 0 generic arguments were supplied\n //~| ERROR associated type bindings are not allowed here\n+//~| ERROR associated const equality is incomplete\n     fn do_x(&self) -> [u8; 3] {\n         [0u8; 3]\n     }"}, {"sha": "59ba054aa11277dc10b5ad0a4d3da9a2befced58", "filename": "src/test/ui/const-generics/parser-error-recovery/issue-89013-no-kw.stderr", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013-no-kw.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013-no-kw.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013-no-kw.stderr?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,18 +1,35 @@\n-error: cannot constrain an associated constant to a value\n+error[E0658]: associated const equality is incomplete\n   --> $DIR/issue-89013-no-kw.rs:9:10\n    |\n LL | impl Foo<N = 3> for Bar {\n-   |          -^^^-\n-   |          |   |\n-   |          |   ...cannot be constrained to this value\n-   |          this associated constant...\n+   |          ^^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n+  --> $DIR/issue-89013-no-kw.rs:9:6\n+   |\n+LL | impl Foo<N = 3> for Bar {\n+   |      ^^^ expected 1 generic argument\n+   |\n+note: trait defined here, with 1 generic parameter: `N`\n+  --> $DIR/issue-89013-no-kw.rs:1:7\n+   |\n+LL | trait Foo<const N: usize> {\n+   |       ^^^       -\n+help: add missing generic argument\n+   |\n+LL | impl Foo<N, N = 3> for Bar {\n+   |          ++\n \n error[E0229]: associated type bindings are not allowed here\n   --> $DIR/issue-89013-no-kw.rs:9:10\n    |\n LL | impl Foo<N = 3> for Bar {\n    |          ^^^^^ associated type not allowed here\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0229`.\n+Some errors have detailed explanations: E0107, E0229, E0658.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "9431779faf8590771e3ed30287c1f60d3333136e", "filename": "src/test/ui/const-generics/parser-error-recovery/issue-89013.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -8,8 +8,9 @@ const T: usize = 42;\n \n impl Foo<N = const 3> for Bar {\n //~^ ERROR expected lifetime, type, or constant, found keyword `const`\n-//~| ERROR cannot constrain an associated constant to a value\n+//~| ERROR this trait takes 1 generic\n //~| ERROR associated type bindings are not allowed here\n+//~| ERROR associated const equality is incomplete\n     fn do_x(&self) -> [u8; 3] {\n         [0u8; 3]\n     }"}, {"sha": "9d4739926700bbb296e317fbb5a343ef0b04504b", "filename": "src/test/ui/const-generics/parser-error-recovery/issue-89013.stderr", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fparser-error-recovery%2Fissue-89013.stderr?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -10,21 +10,38 @@ LL - impl Foo<N = const 3> for Bar {\n LL + impl Foo<N = 3> for Bar {\n    | \n \n-error: cannot constrain an associated constant to a value\n+error[E0658]: associated const equality is incomplete\n   --> $DIR/issue-89013.rs:9:10\n    |\n LL | impl Foo<N = const 3> for Bar {\n-   |          -^^^^^^^^^-\n-   |          |         |\n-   |          |         ...cannot be constrained to this value\n-   |          this associated constant...\n+   |          ^^^^^^^^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n+  --> $DIR/issue-89013.rs:9:6\n+   |\n+LL | impl Foo<N = const 3> for Bar {\n+   |      ^^^ expected 1 generic argument\n+   |\n+note: trait defined here, with 1 generic parameter: `N`\n+  --> $DIR/issue-89013.rs:1:7\n+   |\n+LL | trait Foo<const N: usize> {\n+   |       ^^^       -\n+help: add missing generic argument\n+   |\n+LL | impl Foo<N, N = const 3> for Bar {\n+   |          ++\n \n error[E0229]: associated type bindings are not allowed here\n   --> $DIR/issue-89013.rs:9:10\n    |\n LL | impl Foo<N = const 3> for Bar {\n    |          ^^^^^^^^^^^ associated type not allowed here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0229`.\n+Some errors have detailed explanations: E0107, E0229, E0658.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "b51ead2a188661ae2a55a7d407ab069286272e20", "filename": "src/test/ui/feature-gates/feature-gate-associated_const_equality.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -0,0 +1,16 @@\n+pub trait TraitWAssocConst {\n+  const A: usize;\n+}\n+pub struct Demo {}\n+\n+impl TraitWAssocConst for Demo {\n+  const A: usize = 32;\n+}\n+\n+fn foo<A: TraitWAssocConst<A=32>>() {}\n+//~^ ERROR associated const equality\n+//~| ERROR associated const equality\n+\n+fn main() {\n+  foo::<Demo>();\n+}"}, {"sha": "f4db49c4af88436c77f9c23b21647435a844bec5", "filename": "src/test/ui/feature-gates/feature-gate-associated_const_equality.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_const_equality.stderr?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -0,0 +1,18 @@\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/feature-gate-associated_const_equality.rs:10:28\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {}\n+   |                            ^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error: associated const equality is incomplete\n+  --> $DIR/feature-gate-associated_const_equality.rs:10:28\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {}\n+   |                            ^^^^ cannot yet relate associated const\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "1453e6cb5cd7c654a71af7d82449103c42901d32", "filename": "src/test/ui/parser/recover-assoc-const-constraint.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,7 +1,9 @@\n #[cfg(FALSE)]\n fn syntax() {\n-    bar::<Item = 42>(); //~ ERROR cannot constrain an associated constant to a value\n-    bar::<Item = { 42 }>(); //~ ERROR cannot constrain an associated constant to a value\n+    bar::<Item = 42>();\n+    //~^ ERROR associated const equality is incomplete\n+    bar::<Item = { 42 }>();\n+    //~^ ERROR associated const equality is incomplete\n }\n \n fn main() {}"}, {"sha": "2d36ce4e98632d950f7e1793cc06fe40a2ba2156", "filename": "src/test/ui/parser/recover-assoc-const-constraint.stderr", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.stderr?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,20 +1,21 @@\n-error: cannot constrain an associated constant to a value\n+error[E0658]: associated const equality is incomplete\n   --> $DIR/recover-assoc-const-constraint.rs:3:11\n    |\n LL |     bar::<Item = 42>();\n-   |           ----^^^--\n-   |           |      |\n-   |           |      ...cannot be constrained to this value\n-   |           this associated constant...\n+   |           ^^^^^^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n \n-error: cannot constrain an associated constant to a value\n-  --> $DIR/recover-assoc-const-constraint.rs:4:11\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/recover-assoc-const-constraint.rs:5:11\n    |\n LL |     bar::<Item = { 42 }>();\n-   |           ----^^^------\n-   |           |      |\n-   |           |      ...cannot be constrained to this value\n-   |           this associated constant...\n+   |           ^^^^^^^^^^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ad51707070f9f0f84e7503217fbce9b2363a2741", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,4 +1,4 @@\n-error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[HASH]::Id::This) }, (I,)), [])`\n+error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[HASH]::Id::This) }, Ty((I,))), [])`\n   --> $DIR/repeated_projection_type.rs:19:1\n    |\n LL | / impl<I, V: Id<This = (I,)>> X for V {"}, {"sha": "358e79fe56fe374649275ca7aebaafd57ade0e8d", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1 +1 @@\n-Subproject commit 06b9d31743210b788b130c8a484c2838afa6fc27\n+Subproject commit 358e79fe56fe374649275ca7aebaafd57ade0e8d"}, {"sha": "2af3555e370a4b8ec15f0c4204e24276abe324c1", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -6,7 +6,7 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericArg, GenericBound, HirId,\n+    Term, AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericArg, GenericBound, HirId,\n     IsAsync, ItemKind, LifetimeName, TraitRef, Ty, TyKind, TypeBindingKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n@@ -140,7 +140,7 @@ fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'t\n         if args.bindings.len() == 1;\n         let binding = &args.bindings[0];\n         if binding.ident.name == sym::Output;\n-        if let TypeBindingKind::Equality{ty: output} = binding.kind;\n+        if let TypeBindingKind::Equality{term: Term::Ty(output)} = binding.kind;\n         then {\n             return Some(output)\n         }"}, {"sha": "a9a06c3db75545703a387dd16d86efa763841408", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -2178,12 +2178,16 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 // one of the associated types must be Self\n                 for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n                     if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n+                        let assoc_ty = match projection_predicate.term {\n+                          ty::Term::Ty(ty) => ty,\n+                          ty::Term::Const(_c) => continue,\n+                        };\n                         // walk the associated type and check for Self\n                         if let Some(self_adt) = self_ty.ty_adt_def() {\n-                            if contains_adt_constructor(projection_predicate.ty, self_adt) {\n+                            if contains_adt_constructor(assoc_ty, self_adt) {\n                                 return;\n                             }\n-                        } else if contains_ty(projection_predicate.ty, self_ty) {\n+                        } else if contains_ty(assoc_ty, self_ty) {\n                             return;\n                         }\n                     }"}, {"sha": "9162de3cceafa3b377c67020154ece42f4c170cd", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -243,9 +243,10 @@ fn check_other_call_arg<'tcx>(\n         if if trait_predicate.def_id() == deref_trait_id {\n             if let [projection_predicate] = projection_predicates[..] {\n                 let normalized_ty =\n-                    cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.ty);\n+                    cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.term);\n                 implements_trait(cx, receiver_ty, deref_trait_id, &[])\n-                    && get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(normalized_ty)\n+                    && get_associated_type(cx, receiver_ty, deref_trait_id,\n+                    \"Target\").map_or(false, |ty| ty::Term::Ty(ty) == normalized_ty)\n             } else {\n                 false\n             }"}, {"sha": "68156df2ecea879c1067e9c184131cbd53579d28", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -98,9 +98,10 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n                         if trait_pred.self_ty() == inp;\n                         if let Some(return_ty_pred) = get_projection_pred(cx, generics, *trait_pred);\n                         then {\n-                            if ord_preds.iter().any(|ord| ord.self_ty() == return_ty_pred.ty) {\n+                            if ord_preds.iter().any(|ord| Some(ord.self_ty()) ==\n+                            return_ty_pred.term.ty()) {\n                                 args_to_check.push((i, \"Ord\".to_string()));\n-                            } else if partial_ord_preds.iter().any(|pord| pord.self_ty() == return_ty_pred.ty) {\n+                            } else if partial_ord_preds.iter().any(|pord| pord.self_ty() == return_ty_pred.term.ty().unwrap()) {\n                                 args_to_check.push((i, \"PartialOrd\".to_string()));\n                             }\n                         }"}, {"sha": "604c95d2bc81f17c4a3fe86ea71337bf8fb158e1", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -645,11 +645,19 @@ pub fn eq_generic_bound(l: &GenericBound, r: &GenericBound) -> bool {\n     }\n }\n \n-pub fn eq_assoc_constraint(l: &AssocTyConstraint, r: &AssocTyConstraint) -> bool {\n-    use AssocTyConstraintKind::*;\n+fn eq_term(l: &Term, r: &Term) -> bool {\n+  match (l, r) {\n+    (Term::Ty(l), Term::Ty(r)) => eq_ty(l,r),\n+    (Term::Const(l), Term::Const(r)) => eq_anon_const(l,r),\n+    _ => false,\n+  }\n+}\n+\n+pub fn eq_assoc_constraint(l: &AssocConstraint, r: &AssocConstraint) -> bool {\n+    use AssocConstraintKind::*;\n     eq_id(l.ident, r.ident)\n         && match (&l.kind, &r.kind) {\n-            (Equality { ty: l }, Equality { ty: r }) => eq_ty(l, r),\n+            (Equality { term: l }, Equality { term: r }) => eq_term(l, r),\n             (Bound { bounds: l }, Bound { bounds: r }) => over(l, r, eq_generic_bound),\n             _ => false,\n         }"}, {"sha": "8e9ccbf97a70259b6c6576e8fd7d77d28238737e", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1 +1 @@\n-Subproject commit 0f8c96c92689af8378dbe9f466c6bf15a3a27458\n+Subproject commit 8e9ccbf97a70259b6c6576e8fd7d77d28238737e"}, {"sha": "5de30129266a385cdca831ee0b0c582d8980343c", "filename": "src/tools/rustfmt/src/types.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc7be860f99f4a40d45b0f74e2d01b02e072357/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs?ref=7bc7be860f99f4a40d45b0f74e2d01b02e072357", "patch": "@@ -1,7 +1,7 @@\n use std::iter::ExactSizeIterator;\n use std::ops::Deref;\n \n-use rustc_ast::ast::{self, FnRetTy, Mutability};\n+use rustc_ast::ast::{self, FnRetTy, Mutability, Term};\n use rustc_ast::ptr;\n use rustc_span::{symbol::kw, BytePos, Pos, Span};\n \n@@ -141,7 +141,7 @@ pub(crate) enum SegmentParam<'a> {\n     Const(&'a ast::AnonConst),\n     LifeTime(&'a ast::Lifetime),\n     Type(&'a ast::Ty),\n-    Binding(&'a ast::AssocTyConstraint),\n+    Binding(&'a ast::AssocConstraint),\n }\n \n impl<'a> SegmentParam<'a> {\n@@ -176,9 +176,9 @@ impl<'a> Rewrite for SegmentParam<'a> {\n     }\n }\n \n-impl Rewrite for ast::AssocTyConstraint {\n+impl Rewrite for ast::AssocConstraint {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n-        use ast::AssocTyConstraintKind::{Bound, Equality};\n+        use ast::AssocConstraintKind::{Bound, Equality};\n \n         let mut result = String::with_capacity(128);\n         result.push_str(rewrite_ident(context, self.ident));\n@@ -206,11 +206,14 @@ impl Rewrite for ast::AssocTyConstraint {\n     }\n }\n \n-impl Rewrite for ast::AssocTyConstraintKind {\n+impl Rewrite for ast::AssocConstraintKind {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self {\n-            ast::AssocTyConstraintKind::Equality { ty } => ty.rewrite(context, shape),\n-            ast::AssocTyConstraintKind::Bound { bounds } => bounds.rewrite(context, shape),\n+            ast::AssocConstraintKind::Equality { term } => match term {\n+                Term::Ty(ty) => ty.rewrite(context, shape),\n+                Term::Const(c) => c.rewrite(context, shape),\n+            },\n+            ast::AssocConstraintKind::Bound { bounds } => bounds.rewrite(context, shape),\n         }\n     }\n }"}]}