{"sha": "8033c3c27d520c034603ef4abafae24dea5adc01", "node_id": "C_kwDOAAsO6NoAKDgwMzNjM2MyN2Q1MjBjMDM0NjAzZWY0YWJhZmFlMjRkZWE1YWRjMDE", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-08-29T06:00:08Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-08-29T14:59:21Z"}, "message": "Various changes to logging of borrowck-related code", "tree": {"sha": "e561bb25dd47bea1d5d2f073ee18ea782058c44b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e561bb25dd47bea1d5d2f073ee18ea782058c44b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8033c3c27d520c034603ef4abafae24dea5adc01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8033c3c27d520c034603ef4abafae24dea5adc01", "html_url": "https://github.com/rust-lang/rust/commit/8033c3c27d520c034603ef4abafae24dea5adc01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8033c3c27d520c034603ef4abafae24dea5adc01/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c142a61373eda083cec64de383cf79e9a173f16", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c142a61373eda083cec64de383cf79e9a173f16", "html_url": "https://github.com/rust-lang/rust/commit/7c142a61373eda083cec64de383cf79e9a173f16"}], "stats": {"total": 125, "additions": 41, "deletions": 84}, "files": [{"sha": "c94dfe39b6903aea57a90c87d3871358e04531a1", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -105,8 +105,8 @@ impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             formatter,\n-            \"({:?}: {:?}) due to {:?} ({:?})\",\n-            self.sup, self.sub, self.locations, self.variance_info\n+            \"({:?}: {:?}) due to {:?} ({:?}) ({:?})\",\n+            self.sup, self.sub, self.locations, self.variance_info, self.category,\n         )\n     }\n }"}, {"sha": "5971f7623f215a4c3ed8c1a1832d8b31f32ba134", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -1119,20 +1119,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// short a lifetime. (But sometimes it is more useful to report\n     /// it as a more direct conflict between the execution of a\n     /// `Drop::drop` with an aliasing borrow.)\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         place_span: (Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n-        debug!(\n-            \"report_borrowed_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, borrow, place_span, kind\n-        );\n-\n         let drop_span = place_span.1;\n         let root_place =\n             self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n@@ -1189,10 +1183,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n         let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n \n-        debug!(\n-            \"report_borrowed_value_does_not_live_long_enough(place_desc: {:?}, explanation: {:?})\",\n-            place_desc, explanation\n-        );\n+        debug!(?place_desc, ?explanation);\n+\n         let err = match (place_desc, explanation) {\n             // If the outlives constraint comes from inside the closure,\n             // for example:\n@@ -1464,6 +1456,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn report_temporary_value_does_not_live_long_enough(\n         &mut self,\n         location: Location,\n@@ -1473,13 +1466,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         proper_span: Span,\n         explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n-        debug!(\n-            \"report_temporary_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, borrow, drop_span, proper_span\n-        );\n-\n         if let BorrowExplanation::MustBeValidFor { category, span, from_closure: false, .. } =\n             explanation\n         {"}, {"sha": "1c31d2f74459937278b676b75ee32216e6d480c5", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -336,26 +336,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///   - second half is the place being accessed\n     ///\n     /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn explain_why_borrow_contains_point(\n         &self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, Place<'tcx>)>,\n     ) -> BorrowExplanation<'tcx> {\n-        debug!(\n-            \"explain_why_borrow_contains_point(location={:?}, borrow={:?}, kind_place={:?})\",\n-            location, borrow, kind_place\n-        );\n-\n         let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n-        debug!(\"explain_why_borrow_contains_point: borrow_region_vid={:?}\", borrow_region_vid);\n+        debug!(?borrow_region_vid);\n \n         let region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n-        debug!(\"explain_why_borrow_contains_point: region_sub={:?}\", region_sub);\n+        debug!(?region_sub);\n \n         match find_use::find(body, regioncx, tcx, region_sub, location) {\n             Some(Cause::LiveVar(local, location)) => {\n@@ -408,17 +404,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             opt_place_desc,\n                         }\n                     } else {\n-                        debug!(\n-                            \"explain_why_borrow_contains_point: \\\n-                             Could not generate a region name\"\n-                        );\n+                        debug!(\"Could not generate a region name\");\n                         BorrowExplanation::Unexplained\n                     }\n                 } else {\n-                    debug!(\n-                        \"explain_why_borrow_contains_point: \\\n-                         Could not generate an error region vid\"\n-                    );\n+                    debug!(\"Could not generate an error region vid\");\n                     BorrowExplanation::Unexplained\n                 }\n             }"}, {"sha": "362c45ecd7e670637de4156eb0175870aded9641", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -975,6 +975,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, flow_state))]\n     fn check_access_for_conflict(\n         &mut self,\n         location: Location,\n@@ -983,11 +984,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'tcx>,\n     ) -> bool {\n-        debug!(\n-            \"check_access_for_conflict(location={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n-            location, place_span, sd, rw,\n-        );\n-\n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n@@ -1451,13 +1447,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Checks whether a borrow of this place is invalidated when the function\n     /// exits\n+    #[instrument(level = \"debug\", skip(self))]\n     fn check_for_invalidation_at_exit(\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         span: Span,\n     ) {\n-        debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = borrow.borrowed_place;\n         let mut root_place = PlaceRef { local: place.local, projection: &[] };\n "}, {"sha": "6e5a96bee97e69031aebbf99662632eb9807249b", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -44,6 +44,7 @@ pub(crate) fn places_conflict<'tcx>(\n /// access depth. The `bias` parameter is used to determine how the unknowable (comparing runtime\n /// array indices, for example) should be interpreted - this depends on what the caller wants in\n /// order to make the conservative choice and preserve soundness.\n+#[instrument(level = \"debug\", skip(tcx, body))]\n pub(super) fn borrow_conflicts_with_place<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n@@ -53,11 +54,6 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n-    debug!(\n-        \"borrow_conflicts_with_place({:?}, {:?}, {:?}, {:?})\",\n-        borrow_place, access_place, access, bias,\n-    );\n-\n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n     if let Some(l1) = borrow_place.as_local() && let Some(l2) = access_place.as_local() {\n@@ -140,10 +136,9 @@ fn place_components_conflict<'tcx>(\n     for (i, (borrow_c, &access_c)) in\n         iter::zip(borrow_place.projection, access_place.projection).enumerate()\n     {\n-        debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n-        let borrow_proj_base = &borrow_place.projection[..i];\n+        debug!(?borrow_c, ?access_c);\n \n-        debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n+        let borrow_proj_base = &borrow_place.projection[..i];\n \n         // Borrow and access path both have more components.\n         //\n@@ -180,7 +175,7 @@ fn place_components_conflict<'tcx>(\n                 // idea, at least for now, so just give up and\n                 // report a conflict. This is unsafe code anyway so\n                 // the user could always use raw pointers.\n-                debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                debug!(\"arbitrary -> conflict\");\n                 return true;\n             }\n             Overlap::EqualOrDisjoint => {\n@@ -189,7 +184,7 @@ fn place_components_conflict<'tcx>(\n             Overlap::Disjoint => {\n                 // We have proven the borrow disjoint - further\n                 // projections will remain disjoint.\n-                debug!(\"borrow_conflicts_with_place: disjoint\");\n+                debug!(\"disjoint\");\n                 return false;\n             }\n         }"}, {"sha": "f5bd5cd3beaed0ab0006c2ba688a5fc8009f743a", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -1167,8 +1167,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Therefore, this method should only be used in diagnostic code,\n     /// where displaying *some* named universal region is better than\n     /// falling back to 'static.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn approx_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\"approx_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n+        debug!(\"{}\", self.region_value_str(r));\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n@@ -1177,7 +1178,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let static_r = self.universal_regions.fr_static;\n         for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n             let new_lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n-            debug!(\"approx_universal_upper_bound: ur={:?} lub={:?} new_lub={:?}\", ur, lub, new_lub);\n+            debug!(?ur, ?lub, ?new_lub);\n             // The upper bound of two non-static regions is static: this\n             // means we know nothing about the relationship between these\n             // two regions. Pick a 'better' one to use when constructing\n@@ -1201,7 +1202,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        debug!(\"approx_universal_upper_bound: r={:?} lub={:?}\", r, lub);\n+        debug!(?r, ?lub);\n \n         lub\n     }\n@@ -2048,23 +2049,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// creating a constraint path that forces `R` to outlive\n     /// `from_region`, and then finding the best choices within that\n     /// path to blame.\n+    #[instrument(level = \"debug\", skip(self, target_test))]\n     pub(crate) fn best_blame_constraint(\n         &self,\n         body: &Body<'tcx>,\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> BlameConstraint<'tcx> {\n-        debug!(\n-            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n-            from_region, from_region_origin\n-        );\n-\n         // Find all paths\n         let (path, target_region) =\n             self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n         debug!(\n-            \"best_blame_constraint: path={:#?}\",\n+            \"path={:#?}\",\n             path.iter()\n                 .map(|c| format!(\n                     \"{:?} ({:?}: {:?})\",\n@@ -2116,7 +2113,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             })\n             .collect();\n-        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n+        debug!(\"categorized_path={:#?}\", categorized_path);\n \n         // To find the best span to cite, we first try to look for the\n         // final constraint that is interesting and where the `sup` is\n@@ -2214,10 +2211,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let best_choice =\n             if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n \n-        debug!(\n-            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n-            best_choice, blame_source\n-        );\n+        debug!(?best_choice, ?blame_source);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n@@ -2254,7 +2248,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // appears to be the most interesting point to report to the\n         // user via an even more ad-hoc guess.\n         categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n-        debug!(\"best_blame_constraint: sorted_path={:#?}\", categorized_path);\n+        debug!(\"sorted_path={:#?}\", categorized_path);\n \n         categorized_path.remove(0)\n     }"}, {"sha": "29195b3922fcdb24dc8734caa8f03dcb5f9ce230", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// **Any `rustc_infer::infer` operations that might generate region\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n-    #[instrument(skip(self, category, op), level = \"trace\")]\n+    #[instrument(skip(self, op), level = \"trace\")]\n     pub(super) fn fully_perform_op<R, Op>(\n         &mut self,\n         locations: Locations,"}, {"sha": "4d620a3aa476bcfeef4a6b5dff150d4831084ce4", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -1043,6 +1043,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n             let annotation = self.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n+            debug!(?annotation);\n             match annotation {\n                 UserType::Ty(mut ty) => {\n                     ty = self.normalize(ty, Locations::All(span));"}, {"sha": "46f8c0e8d8b9acad49d334fcc9d3dc04852b53b8", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -372,7 +372,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 debug!(\n                     \"canonical: region var found with vid {:?}, \\\n                      opportunistically resolved to {:?}\",\n-                    vid, r\n+                    vid, resolved_vid\n                 );\n                 let r = self.tcx.reuse_or_mk_region(r, ty::ReVar(resolved_vid));\n                 self.canonicalize_mode.canonicalize_free_region(self, r)"}, {"sha": "64c759f73d410323cc08d6eeb8c688c5b5d7942f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -63,8 +63,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n+        debug!(\"query_response = {:#?}\", query_response);\n         let canonical_result = self.canonicalize_response(query_response);\n-\n         debug!(\"canonical_result = {:#?}\", canonical_result);\n \n         Ok(self.tcx.arena.alloc(canonical_result))\n@@ -125,13 +125,15 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         debug!(\"ambig_errors = {:#?}\", ambig_errors);\n \n         let region_obligations = self.take_registered_region_obligations();\n+        debug!(?region_obligations);\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n                 region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n                 region_constraints,\n             )\n         });\n+        debug!(?region_constraints);\n \n         let certainty =\n             if ambig_errors.is_empty() { Certainty::Proven } else { Certainty::Ambiguous };\n@@ -632,6 +634,8 @@ pub fn make_query_region_constraints<'tcx>(\n     assert!(verifys.is_empty());\n     assert!(givens.is_empty());\n \n+    debug!(?constraints);\n+\n     let outlives: Vec<_> = constraints\n         .iter()\n         .map(|(k, _)| match *k {"}, {"sha": "4689ebb6cee2429a1c8a8388515c3f488ba43130", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -504,7 +504,7 @@ pub enum FixupError<'tcx> {\n }\n \n /// See the `region_obligations` field for more information.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct RegionObligation<'tcx> {\n     pub sub_region: ty::Region<'tcx>,\n     pub sup_type: Ty<'tcx>,\n@@ -2027,16 +2027,6 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-            self.sub_region, self.sup_type\n-        )\n-    }\n-}\n-\n /// Replaces substs that reference param or infer variables with suitable\n /// placeholders. This function is meant to remove these param and infer\n /// substs when they're not actually needed to evaluate a constant."}, {"sha": "fe78890ff6ed7648b309d0b095b284b25c0dd4b3", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -92,6 +92,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         sub_region: Region<'tcx>,\n         cause: &ObligationCause<'tcx>,\n     ) {\n+        debug!(?sup_type, ?sub_region, ?cause);\n         let origin = SubregionOrigin::from_obligation_cause(cause, || {\n             infer::RelateParamBound(\n                 cause.span,\n@@ -248,14 +249,13 @@ where\n     /// - `origin`, the reason we need this constraint\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn type_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n     ) {\n-        debug!(\"type_must_outlive(ty={:?}, region={:?}, origin={:?})\", ty, region, origin);\n-\n         assert!(!ty.has_escaping_bound_vars());\n \n         let mut components = smallvec![];"}, {"sha": "60e9b88107dd698a258c044d6042436bbdb9c74a", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8033c3c27d520c034603ef4abafae24dea5adc01/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=8033c3c27d520c034603ef4abafae24dea5adc01", "patch": "@@ -120,6 +120,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         EarlyBinder(value).subst(self.tcx(), substs)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn relate_mir_and_user_ty(\n         &mut self,\n         mir_ty: Ty<'tcx>,\n@@ -132,8 +133,8 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n \n         let ty = tcx.type_of(def_id);\n         let ty = self.subst(ty, substs);\n-        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n         let ty = self.normalize(ty);\n+        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n         self.relate(mir_ty, Variance::Invariant, ty)?;\n \n@@ -144,7 +145,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // outlives\" error messages.\n         let instantiated_predicates =\n             self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n-        debug!(?instantiated_predicates.predicates);\n+        debug!(?instantiated_predicates);\n         for instantiated_predicate in instantiated_predicates.predicates {\n             let instantiated_predicate = self.normalize(instantiated_predicate);\n             self.prove_predicate(instantiated_predicate, span);"}]}