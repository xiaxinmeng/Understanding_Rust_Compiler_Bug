{"sha": "4a788a2003d6ad66b768f520a13f251c6800ab7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNzg4YTIwMDNkNmFkNjZiNzY4ZjUyMGExM2YyNTFjNjgwMGFiN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-21T22:41:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-21T22:41:00Z"}, "message": "Auto merge of #26479 - arielb1:expr-kind, r=eddyb\n\nPreviously it also tried to find out the best way to translate the\r\nexpression, which could ICE during type-checking.\r\n\r\nFixes #23173\r\nFixes #24322\r\nFixes #25757\r\n\r\nr? @eddyb", "tree": {"sha": "7da5333279ecff140ea1eb30dcc5e6f1591c9c22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7da5333279ecff140ea1eb30dcc5e6f1591c9c22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a788a2003d6ad66b768f520a13f251c6800ab7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a788a2003d6ad66b768f520a13f251c6800ab7d", "html_url": "https://github.com/rust-lang/rust/commit/4a788a2003d6ad66b768f520a13f251c6800ab7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a788a2003d6ad66b768f520a13f251c6800ab7d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd874cd02e3a17b0050467559da0ed053f9dbe3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd874cd02e3a17b0050467559da0ed053f9dbe3a", "html_url": "https://github.com/rust-lang/rust/commit/fd874cd02e3a17b0050467559da0ed053f9dbe3a"}, {"sha": "59be7535448e5c92b17307e2e4cf1f1980f7252a", "url": "https://api.github.com/repos/rust-lang/rust/commits/59be7535448e5c92b17307e2e4cf1f1980f7252a", "html_url": "https://github.com/rust-lang/rust/commit/59be7535448e5c92b17307e2e4cf1f1980f7252a"}], "stats": {"total": 396, "additions": 256, "deletions": 140}, "files": [{"sha": "3497a8d690479b78a90749692003fa0b292c5fc6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 129, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4a788a2003d6ad66b768f520a13f251c6800ab7d", "patch": "@@ -20,7 +20,6 @@ pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n pub use self::Representability::*;\n pub use self::AutoRef::*;\n-pub use self::ExprKind::*;\n pub use self::DtorKind::*;\n pub use self::ExplicitSelfCategory::*;\n pub use self::FnOutput::*;\n@@ -87,7 +86,7 @@ use syntax::abi;\n use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n-use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n+use syntax::ast_util::{self, is_local, local_def};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n@@ -5106,104 +5105,35 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     }\n }\n \n-pub fn expr_is_lval(tcx: &ctxt, e: &ast::Expr) -> bool {\n-    match expr_kind(tcx, e) {\n-        LvalueExpr => true,\n-        RvalueDpsExpr | RvalueDatumExpr | RvalueStmtExpr => false\n-    }\n-}\n-\n-/// We categorize expressions into three kinds.  The distinction between\n-/// lvalue/rvalue is fundamental to the language.  The distinction between the\n-/// two kinds of rvalues is an artifact of trans which reflects how we will\n-/// generate code for that kind of expression.  See trans/expr.rs for more\n-/// information.\n-#[derive(Copy, Clone)]\n-pub enum ExprKind {\n-    LvalueExpr,\n-    RvalueDpsExpr,\n-    RvalueDatumExpr,\n-    RvalueStmtExpr\n-}\n-\n-pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n-    if tcx.method_map.borrow().contains_key(&MethodCall::expr(expr.id)) {\n-        // Overloaded operations are generally calls, and hence they are\n-        // generated via DPS, but there are a few exceptions:\n-        return match expr.node {\n-            // `a += b` has a unit result.\n-            ast::ExprAssignOp(..) => RvalueStmtExpr,\n-\n-            // the deref method invoked for `*a` always yields an `&T`\n-            ast::ExprUnary(ast::UnDeref, _) => LvalueExpr,\n-\n-            // the index method invoked for `a[i]` always yields an `&T`\n-            ast::ExprIndex(..) => LvalueExpr,\n-\n-            // in the general case, result could be any type, use DPS\n-            _ => RvalueDpsExpr\n-        };\n-    }\n-\n-    match expr.node {\n+pub fn expr_is_lval(tcx: &ctxt, expr: &ast::Expr) -> bool {\n+     match expr.node {\n         ast::ExprPath(..) => {\n-            match resolve_expr(tcx, expr) {\n-                def::DefVariant(tid, vid, _) => {\n-                    let variant_info = enum_variant_with_id(tcx, tid, vid);\n-                    if !variant_info.args.is_empty() {\n-                        // N-ary variant.\n-                        RvalueDatumExpr\n-                    } else {\n-                        // Nullary variant.\n-                        RvalueDpsExpr\n-                    }\n+            // We can't use resolve_expr here, as this needs to run on broken\n+            // programs. We don't need to through - associated items are all\n+            // rvalues.\n+            match tcx.def_map.borrow().get(&expr.id) {\n+                Some(&def::PathResolution {\n+                    base_def: def::DefStatic(..), ..\n+                }) | Some(&def::PathResolution {\n+                    base_def: def::DefUpvar(..), ..\n+                }) | Some(&def::PathResolution {\n+                    base_def: def::DefLocal(..), ..\n+                }) => {\n+                    true\n                 }\n \n-                def::DefStruct(_) => {\n-                    match tcx.node_types.borrow().get(&expr.id) {\n-                        Some(ty) => match ty.sty {\n-                            TyBareFn(..) => RvalueDatumExpr,\n-                            _ => RvalueDpsExpr\n-                        },\n-                        // See ExprCast below for why types might be missing.\n-                        None => RvalueDatumExpr\n-                     }\n-                }\n+                Some(..) => false,\n \n-                // Special case: A unit like struct's constructor must be called without () at the\n-                // end (like `UnitStruct`) which means this is an ExprPath to a DefFn. But in case\n-                // of unit structs this is should not be interpreted as function pointer but as\n-                // call to the constructor.\n-                def::DefFn(_, true) => RvalueDpsExpr,\n-\n-                // Fn pointers are just scalar values.\n-                def::DefFn(..) | def::DefMethod(..) => RvalueDatumExpr,\n-\n-                // Note: there is actually a good case to be made that\n-                // DefArg's, particularly those of immediate type, ought to\n-                // considered rvalues.\n-                def::DefStatic(..) |\n-                def::DefUpvar(..) |\n-                def::DefLocal(..) => LvalueExpr,\n-\n-                def::DefConst(..) |\n-                def::DefAssociatedConst(..) => RvalueDatumExpr,\n-\n-                def => {\n-                    tcx.sess.span_bug(\n-                        expr.span,\n-                        &format!(\"uncategorized def for expr {}: {:?}\",\n-                                expr.id,\n-                                def));\n-                }\n+                None => tcx.sess.span_bug(expr.span, &format!(\n+                    \"no def for path {}\", expr.id))\n             }\n         }\n \n         ast::ExprUnary(ast::UnDeref, _) |\n         ast::ExprField(..) |\n         ast::ExprTupField(..) |\n         ast::ExprIndex(..) => {\n-            LvalueExpr\n+            true\n         }\n \n         ast::ExprCall(..) |\n@@ -5216,60 +5146,29 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprClosure(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n-        ast::ExprVec(..) => {\n-            RvalueDpsExpr\n-        }\n-\n-        ast::ExprIfLet(..) => {\n-            tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n-        }\n-        ast::ExprWhileLet(..) => {\n-            tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n-        }\n-\n-        ast::ExprForLoop(..) => {\n-            tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n-        }\n-\n-        ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n-            RvalueDpsExpr\n-        }\n-\n+        ast::ExprVec(..) |\n         ast::ExprBreak(..) |\n         ast::ExprAgain(..) |\n         ast::ExprRet(..) |\n         ast::ExprWhile(..) |\n         ast::ExprLoop(..) |\n         ast::ExprAssign(..) |\n         ast::ExprInlineAsm(..) |\n-        ast::ExprAssignOp(..) => {\n-            RvalueStmtExpr\n-        }\n-\n-        ast::ExprLit(_) | // Note: LitStr is carved out above\n+        ast::ExprAssignOp(..) |\n+        ast::ExprLit(_) |\n         ast::ExprUnary(..) |\n-        ast::ExprBox(None, _) |\n+        ast::ExprBox(..) |\n         ast::ExprAddrOf(..) |\n         ast::ExprBinary(..) |\n         ast::ExprCast(..) => {\n-            RvalueDatumExpr\n-        }\n-\n-        ast::ExprBox(Some(ref place), _) => {\n-            // Special case `Box<T>` for now:\n-            let def_id = match tcx.def_map.borrow().get(&place.id) {\n-                Some(def) => def.def_id(),\n-                None => panic!(\"no def for place\"),\n-            };\n-            if tcx.lang_items.exchange_heap() == Some(def_id) {\n-                RvalueDatumExpr\n-            } else {\n-                RvalueDpsExpr\n-            }\n+            false\n         }\n \n-        ast::ExprParen(ref e) => expr_kind(tcx, &**e),\n+        ast::ExprParen(ref e) => expr_is_lval(tcx, e),\n \n+        ast::ExprIfLet(..) |\n+        ast::ExprWhileLet(..) |\n+        ast::ExprForLoop(..) |\n         ast::ExprMac(..) => {\n             tcx.sess.span_bug(\n                 expr.span,"}, {"sha": "5ee7159493534dcedc202ca3c45faf8adc044f2e", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 165, "deletions": 11, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=4a788a2003d6ad66b768f520a13f251c6800ab7d", "patch": "@@ -188,15 +188,15 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                                           false);\n     bcx.fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n \n-    let kind = ty::expr_kind(bcx.tcx(), expr);\n+    let kind = expr_kind(bcx.tcx(), expr);\n     bcx = match kind {\n-        ty::LvalueExpr | ty::RvalueDatumExpr => {\n+        ExprKind::Lvalue | ExprKind::RvalueDatum => {\n             trans_unadjusted(bcx, expr).store_to_dest(dest, expr.id)\n         }\n-        ty::RvalueDpsExpr => {\n+        ExprKind::RvalueDps => {\n             trans_rvalue_dps_unadjusted(bcx, expr, dest)\n         }\n-        ty::RvalueStmtExpr => {\n+        ExprKind::RvalueStmt => {\n             trans_rvalue_stmt_unadjusted(bcx, expr)\n         }\n     };\n@@ -582,21 +582,21 @@ fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n-    return match ty::expr_kind(bcx.tcx(), expr) {\n-        ty::LvalueExpr | ty::RvalueDatumExpr => {\n+    return match expr_kind(bcx.tcx(), expr) {\n+        ExprKind::Lvalue | ExprKind::RvalueDatum => {\n             let datum = unpack_datum!(bcx, {\n                 trans_datum_unadjusted(bcx, expr)\n             });\n \n             DatumBlock {bcx: bcx, datum: datum}\n         }\n \n-        ty::RvalueStmtExpr => {\n+        ExprKind::RvalueStmt => {\n             bcx = trans_rvalue_stmt_unadjusted(bcx, expr);\n             nil(bcx, expr_ty(bcx, expr))\n         }\n \n-        ty::RvalueDpsExpr => {\n+        ExprKind::RvalueDps => {\n             let ty = expr_ty(bcx, expr);\n             if type_is_zero_size(bcx.ccx(), ty) {\n                 bcx = trans_rvalue_dps_unadjusted(bcx, expr, Ignore);\n@@ -1531,11 +1531,13 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // Second, trans the base to the dest.\n         assert_eq!(discr, 0);\n \n-        match ty::expr_kind(bcx.tcx(), &*base.expr) {\n-            ty::RvalueDpsExpr | ty::RvalueDatumExpr if !bcx.fcx.type_needs_drop(ty) => {\n+        match expr_kind(bcx.tcx(), &*base.expr) {\n+            ExprKind::RvalueDps | ExprKind::RvalueDatum if !bcx.fcx.type_needs_drop(ty) => {\n                 bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n             },\n-            ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\"),\n+            ExprKind::RvalueStmt => {\n+                bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n+            }\n             _ => {\n                 let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n                 for &(i, t) in &base.fields {\n@@ -2592,3 +2594,155 @@ fn with_overflow_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, oop: OverflowOp, info\n         (bcx, res)\n     }\n }\n+\n+/// We categorize expressions into three kinds.  The distinction between\n+/// lvalue/rvalue is fundamental to the language.  The distinction between the\n+/// two kinds of rvalues is an artifact of trans which reflects how we will\n+/// generate code for that kind of expression.  See trans/expr.rs for more\n+/// information.\n+#[derive(Copy, Clone)]\n+enum ExprKind {\n+    Lvalue,\n+    RvalueDps,\n+    RvalueDatum,\n+    RvalueStmt\n+}\n+\n+fn expr_kind(tcx: &ty::ctxt, expr: &ast::Expr) -> ExprKind {\n+    if tcx.method_map.borrow().contains_key(&MethodCall::expr(expr.id)) {\n+        // Overloaded operations are generally calls, and hence they are\n+        // generated via DPS, but there are a few exceptions:\n+        return match expr.node {\n+            // `a += b` has a unit result.\n+            ast::ExprAssignOp(..) => ExprKind::RvalueStmt,\n+\n+            // the deref method invoked for `*a` always yields an `&T`\n+            ast::ExprUnary(ast::UnDeref, _) => ExprKind::Lvalue,\n+\n+            // the index method invoked for `a[i]` always yields an `&T`\n+            ast::ExprIndex(..) => ExprKind::Lvalue,\n+\n+            // in the general case, result could be any type, use DPS\n+            _ => ExprKind::RvalueDps\n+        };\n+    }\n+\n+    match expr.node {\n+        ast::ExprPath(..) => {\n+            match ty::resolve_expr(tcx, expr) {\n+                def::DefStruct(_) | def::DefVariant(..) => {\n+                    if let ty::TyBareFn(..) = ty::node_id_to_type(tcx, expr.id).sty {\n+                        // ctor function\n+                        ExprKind::RvalueDatum\n+                    } else {\n+                        ExprKind::RvalueDps\n+                    }\n+                }\n+\n+                // Special case: A unit like struct's constructor must be called without () at the\n+                // end (like `UnitStruct`) which means this is an ExprPath to a DefFn. But in case\n+                // of unit structs this is should not be interpreted as function pointer but as\n+                // call to the constructor.\n+                def::DefFn(_, true) => ExprKind::RvalueDps,\n+\n+                // Fn pointers are just scalar values.\n+                def::DefFn(..) | def::DefMethod(..) => ExprKind::RvalueDatum,\n+\n+                // Note: there is actually a good case to be made that\n+                // DefArg's, particularly those of immediate type, ought to\n+                // considered rvalues.\n+                def::DefStatic(..) |\n+                def::DefUpvar(..) |\n+                def::DefLocal(..) => ExprKind::Lvalue,\n+\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => ExprKind::RvalueDatum,\n+\n+                def => {\n+                    tcx.sess.span_bug(\n+                        expr.span,\n+                        &format!(\"uncategorized def for expr {}: {:?}\",\n+                                expr.id,\n+                                def));\n+                }\n+            }\n+        }\n+\n+        ast::ExprUnary(ast::UnDeref, _) |\n+        ast::ExprField(..) |\n+        ast::ExprTupField(..) |\n+        ast::ExprIndex(..) => {\n+            ExprKind::Lvalue\n+        }\n+\n+        ast::ExprCall(..) |\n+        ast::ExprMethodCall(..) |\n+        ast::ExprStruct(..) |\n+        ast::ExprRange(..) |\n+        ast::ExprTup(..) |\n+        ast::ExprIf(..) |\n+        ast::ExprMatch(..) |\n+        ast::ExprClosure(..) |\n+        ast::ExprBlock(..) |\n+        ast::ExprRepeat(..) |\n+        ast::ExprVec(..) => {\n+            ExprKind::RvalueDps\n+        }\n+\n+        ast::ExprIfLet(..) => {\n+            tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+        }\n+        ast::ExprWhileLet(..) => {\n+            tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n+        }\n+\n+        ast::ExprForLoop(..) => {\n+            tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+        }\n+\n+        ast::ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {\n+            ExprKind::RvalueDps\n+        }\n+\n+        ast::ExprBreak(..) |\n+        ast::ExprAgain(..) |\n+        ast::ExprRet(..) |\n+        ast::ExprWhile(..) |\n+        ast::ExprLoop(..) |\n+        ast::ExprAssign(..) |\n+        ast::ExprInlineAsm(..) |\n+        ast::ExprAssignOp(..) => {\n+            ExprKind::RvalueStmt\n+        }\n+\n+        ast::ExprLit(_) | // Note: LitStr is carved out above\n+        ast::ExprUnary(..) |\n+        ast::ExprBox(None, _) |\n+        ast::ExprAddrOf(..) |\n+        ast::ExprBinary(..) |\n+        ast::ExprCast(..) => {\n+            ExprKind::RvalueDatum\n+        }\n+\n+        ast::ExprBox(Some(ref place), _) => {\n+            // Special case `Box<T>` for now:\n+            let def_id = match tcx.def_map.borrow().get(&place.id) {\n+                Some(def) => def.def_id(),\n+                None => panic!(\"no def for place\"),\n+            };\n+            if tcx.lang_items.exchange_heap() == Some(def_id) {\n+                ExprKind::RvalueDatum\n+            } else {\n+                ExprKind::RvalueDps\n+            }\n+        }\n+\n+        ast::ExprParen(ref e) => expr_kind(tcx, &**e),\n+\n+        ast::ExprMac(..) => {\n+            tcx.sess.span_bug(\n+                expr.span,\n+                \"macro expression remains after expansion\");\n+        }\n+    }\n+}"}, {"sha": "946e4b9e96e473c20a4b29e60204274e3a2f2148", "filename": "src/test/compile-fail/issue-23173.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Ftest%2Fcompile-fail%2Fissue-23173.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Ftest%2Fcompile-fail%2Fissue-23173.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23173.rs?ref=4a788a2003d6ad66b768f520a13f251c6800ab7d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Token { LeftParen, RightParen, Plus, Minus, /* etc */ }\n+\n+fn use_token(token: &Token) { unimplemented!() }\n+\n+fn main() {\n+    use_token(&Token::Homura); //~ ERROR no associated item named\n+}"}, {"sha": "bb726aca921106a9a1ee9a3e6e4972fc04a8afd5", "filename": "src/test/compile-fail/issue-24322.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Ftest%2Fcompile-fail%2Fissue-24322.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Ftest%2Fcompile-fail%2Fissue-24322.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24322.rs?ref=4a788a2003d6ad66b768f520a13f251c6800ab7d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct B;\n+\n+impl B {\n+    fn func(&self) -> u32 { 42 }\n+}\n+\n+fn main() {\n+    let x: &fn(&B) -> u32 = &B::func; //~ ERROR mismatched types\n+}"}, {"sha": "8deb2e244ae08111d2ec4f432698f70087ae8dde", "filename": "src/test/run-pass/issue-25757.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Ftest%2Frun-pass%2Fissue-25757.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a788a2003d6ad66b768f520a13f251c6800ab7d/src%2Ftest%2Frun-pass%2Fissue-25757.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25757.rs?ref=4a788a2003d6ad66b768f520a13f251c6800ab7d", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    a: u32\n+}\n+\n+impl Foo {\n+    fn x(&mut self) {\n+        self.a = 5;\n+    }\n+}\n+\n+const FUNC: &'static Fn(&mut Foo) -> () = &Foo::x;\n+\n+fn main() {\n+    let mut foo = Foo { a: 137 };\n+    FUNC(&mut foo); //~ ERROR bad\n+    assert_eq!(foo.a, 5);\n+}"}]}