{"sha": "927f454ac115c7d19f34951914b269ce356a1ca6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyN2Y0NTRhYzExNWM3ZDE5ZjM0OTUxOTE0YjI2OWNlMzU2YTFjYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-28T00:22:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-28T00:22:42Z"}, "message": "auto merge of #7432 : michaelwoerister/rust/WP3, r=jdm", "tree": {"sha": "e8e26fa9efad74110bbe5c7c322f9f8554fc319c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8e26fa9efad74110bbe5c7c322f9f8554fc319c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/927f454ac115c7d19f34951914b269ce356a1ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/927f454ac115c7d19f34951914b269ce356a1ca6", "html_url": "https://github.com/rust-lang/rust/commit/927f454ac115c7d19f34951914b269ce356a1ca6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/927f454ac115c7d19f34951914b269ce356a1ca6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "url": "https://api.github.com/repos/rust-lang/rust/commits/63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "html_url": "https://github.com/rust-lang/rust/commit/63afb8ccc8dd945e35fa43ca319aeaa5fba78134"}, {"sha": "2f5e33d02f0103a40de2493f824627effaedc6e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f5e33d02f0103a40de2493f824627effaedc6e0", "html_url": "https://github.com/rust-lang/rust/commit/2f5e33d02f0103a40de2493f824627effaedc6e0"}], "stats": {"total": 1414, "additions": 1317, "deletions": 97}, "files": [{"sha": "a42f20ea39ca3e6b050e6c7851e6b324bc316c03", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 177, "deletions": 68, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -56,7 +56,7 @@ use util::ppaux::ty_to_str;\n \n use core::hashmap::HashMap;\n use core::libc;\n-use core::libc::c_uint;\n+use core::libc::{c_uint, c_ulonglong};\n use core::cmp;\n use core::ptr;\n use core::str::as_c_str;\n@@ -211,9 +211,17 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n             let mdnode = do as_c_str(name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(DIB(cx),\n-                    ArgVariableTag as u32, context, name,\n-                    filemd, loc.line as c_uint, tymd, false, 0, 0)\n+                llvm::LLVMDIBuilderCreateLocalVariable(\n+                    DIB(cx),\n+                    ArgVariableTag as u32,\n+                    context,\n+                    name,\n+                    filemd,\n+                    loc.line as c_uint,\n+                    tymd,\n+                    false,\n+                    0,\n+                    0)\n                     // XXX need to pass in a real argument number\n             }};\n \n@@ -290,16 +298,17 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => ptr::null(),\n-          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n-                         ret_ty.span)\n+          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n         }\n     } else {\n         ptr::null()\n     };\n \n     let fn_ty = unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx),\n-            file_md, create_DIArray(DIB(cx), [ret_ty_md]))\n+        llvm::LLVMDIBuilderCreateSubroutineType(\n+            DIB(cx),\n+            file_md,\n+            create_DIArray(DIB(cx), [ret_ty_md]))\n     };\n \n     let fn_md =\n@@ -308,13 +317,19 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n             llvm::LLVMDIBuilderCreateFunction(\n                 DIB(cx),\n                 file_md,\n-                name, linkage,\n-                file_md, loc.line as c_uint,\n-                fn_ty, false, true,\n+                name,\n+                linkage,\n+                file_md,\n+                loc.line as c_uint,\n+                fn_ty,\n+                false,\n+                true,\n                 loc.line as c_uint,\n                 FlagPrototyped as c_uint,\n                 cx.sess.opts.optimize != session::No,\n-                fcx.llfn, ptr::null(), ptr::null())\n+                fcx.llfn,\n+                ptr::null(),\n+                ptr::null())\n             }}};\n \n     dbg_cx(cx).created_functions.insert(id, fn_md);\n@@ -337,6 +352,9 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n fn create_compile_unit(cx: @mut CrateContext) {\n     let dcx = dbg_cx(cx);\n     let crate_name: &str = dcx.crate_file;\n+\n+    debug!(\"create_compile_unit: %?\", crate_name);\n+\n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n \n@@ -352,7 +370,7 @@ fn create_compile_unit(cx: @mut CrateContext) {\n     }}}}}};\n }\n \n-fn create_file(cx: @mut CrateContext, full_path: &str) -> DIFile {\n+fn create_file(cx: &mut CrateContext, full_path: &str) -> DIFile {\n     match dbg_cx(cx).created_files.find_equiv(&full_path) {\n         Some(file_md) => return *file_md,\n         None => ()\n@@ -422,7 +440,7 @@ fn create_block(bcx: block) -> DILexicalBlock {\n \n \n \n-fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n+fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n     match dbg_cx(cx).created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n@@ -460,8 +478,11 @@ fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n     let (size, align) = size_and_align_of(cx, t);\n     let ty_md = do as_c_str(name) |name| { unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n-                DIB(cx), name,\n-                size * 8 as u64, align * 8 as u64, encoding as c_uint)\n+                DIB(cx),\n+                name,\n+                bytes_to_bits(size),\n+                bytes_to_bits(align),\n+                encoding as c_uint)\n         }};\n \n     // One could think that this call is not necessary, as the create_ty() function will insert the\n@@ -471,12 +492,16 @@ fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n     return ty_md;\n }\n \n-fn create_pointer_type(cx: @mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n+fn create_pointer_type(cx: &mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n     let (size, align) = size_and_align_of(cx, t);\n     let name = ty_to_str(cx.tcx, t);\n     let ptr_md = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreatePointerType(DIB(cx),\n-                pointee, size * 8 as u64, align * 8 as u64, name)\n+        llvm::LLVMDIBuilderCreatePointerType(\n+            DIB(cx),\n+            pointee,\n+            bytes_to_bits(size),\n+            bytes_to_bits(align),\n+            name)\n     }};\n     return ptr_md;\n }\n@@ -492,9 +517,9 @@ struct StructContext {\n }\n \n impl StructContext {\n-    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> ~StructContext {\n+    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> StructContext {\n         debug!(\"StructContext::create: %s\", name);\n-        let scx = ~StructContext {\n+        return StructContext {\n             builder: DIB(cx),\n             file: file,\n             name: name,\n@@ -503,48 +528,75 @@ impl StructContext {\n             total_size: 0,\n             align: 1\n         };\n-        return scx;\n     }\n \n     fn add_member(&mut self, name: &str, line: uint, size: uint, align: uint, ty: DIType) {\n-        debug!(\"StructContext(%s)::add_member: %s, size=%u, align=%u\",\n-                self.name, name, size, align);\n         let offset = roundup(self.total_size, align);\n+\n+        debug!(\"StructContext(%s)::add_member: %s, size=%u, align=%u, offset=%u\",\n+                self.name, name, size, align, offset);\n+\n         let mem_t = do as_c_str(name) |name| { unsafe {\n             llvm::LLVMDIBuilderCreateMemberType(\n-                self.builder, ptr::null(), name, self.file, line as c_uint,\n-                size * 8 as u64, align * 8 as u64, offset * 8 as u64,\n-                0, ty)\n+                self.builder,\n+                self.file,\n+                name,\n+                self.file,\n+                line as c_uint,\n+                bytes_to_bits(size),\n+                bytes_to_bits(align),\n+                bytes_to_bits(offset),\n+                0,\n+                ty)\n             }};\n         self.members.push(mem_t);\n         self.total_size = offset + size;\n         // struct alignment is the max alignment of its' members\n         self.align = cmp::max(self.align, align);\n     }\n \n+    fn get_total_size_with_alignment(&self) -> uint {\n+        roundup(self.total_size, self.align)\n+    }\n+\n     fn finalize(&self) -> DICompositeType {\n         debug!(\"StructContext(%s)::finalize: total_size=%u, align=%u\",\n                 self.name, self.total_size, self.align);\n         let members_md = create_DIArray(self.builder, self.members);\n \n+        // The size of the struct/tuple must be rounded to the next multiple of its alignment.\n+        // Otherwise gdb has trouble reading the struct correctly when it is embedded into another\n+        // data structure. This is also the value `sizeof` in C would give.\n+        let actual_total_size = self.get_total_size_with_alignment();\n+\n         let struct_md =\n             do as_c_str(self.name) |name| { unsafe {\n                 llvm::LLVMDIBuilderCreateStructType(\n-                    self.builder, self.file, name,\n-                    self.file, self.line as c_uint,\n-                    self.total_size * 8 as u64, self.align * 8 as u64, 0, ptr::null(),\n-                    members_md, 0, ptr::null())\n+                    self.builder,\n+                    self.file,\n+                    name,\n+                    self.file,\n+                    self.line as c_uint,\n+                    bytes_to_bits(actual_total_size),\n+                    bytes_to_bits(self.align),\n+                    0,\n+                    ptr::null(),\n+                    members_md,\n+                    0,\n+                    ptr::null())\n             }};\n         return struct_md;\n     }\n }\n \n-fn create_struct(cx: @mut CrateContext, t: ty::t, fields: ~[ty::field], span: span)\n+fn create_struct(cx: &mut CrateContext, struct_type: ty::t, fields: ~[ty::field], span: span)\n                 -> DICompositeType {\n+    debug!(\"create_struct: %?\", ty::get(struct_type));\n+\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n \n-    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, t), file_md, loc.line);\n+    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, struct_type), file_md, loc.line);\n     for fields.iter().advance |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n@@ -555,18 +607,24 @@ fn create_struct(cx: @mut CrateContext, t: ty::t, fields: ~[ty::field], span: sp\n }\n \n // returns (void* type as a ValueRef, size in bytes, align in bytes)\n-fn voidptr(cx: @mut CrateContext) -> (DIDerivedType, uint, uint) {\n+fn voidptr(cx: &mut CrateContext) -> (DIDerivedType, uint, uint) {\n     let size = sys::size_of::<ValueRef>();\n     let align = sys::min_align_of::<ValueRef>();\n     let vp = do as_c_str(\"*void\") |name| { unsafe {\n-            llvm::LLVMDIBuilderCreatePointerType(DIB(cx), ptr::null(),\n-                size*8 as u64, align*8 as u64, name)\n+            llvm::LLVMDIBuilderCreatePointerType(\n+                DIB(cx),\n+                ptr::null(),\n+                bytes_to_bits(size),\n+                bytes_to_bits(align),\n+                name)\n         }};\n     return (vp, size, align);\n }\n \n-fn create_tuple(cx: @mut CrateContext, _t: ty::t, elements: &[ty::t], span: span)\n+fn create_tuple(cx: &mut CrateContext, tuple_type: ty::t, elements: &[ty::t], span: span)\n                 -> DICompositeType {\n+    debug!(\"create_tuple: %?\", ty::get(tuple_type));\n+\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n \n@@ -580,8 +638,10 @@ fn create_tuple(cx: @mut CrateContext, _t: ty::t, elements: &[ty::t], span: span\n     return scx.finalize();\n }\n \n-fn create_boxed_type(cx: @mut CrateContext, contents: ty::t,\n+fn create_boxed_type(cx: &mut CrateContext, contents: ty::t,\n                      span: span, boxed: DIType) -> DICompositeType {\n+    debug!(\"create_boxed_type: %?\", ty::get(contents));\n+\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n     let int_t = ty::mk_int();\n@@ -602,8 +662,10 @@ fn create_boxed_type(cx: @mut CrateContext, contents: ty::t,\n     return scx.finalize();\n }\n \n-fn create_fixed_vec(cx: @mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n+fn create_fixed_vec(cx: &mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n                     len: uint, span: span) -> DIType {\n+    debug!(\"create_fixed_vec: %?\", ty::get(_vec_t));\n+\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let (size, align) = size_and_align_of(cx, elem_t);\n \n@@ -613,23 +675,40 @@ fn create_fixed_vec(cx: @mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n     return unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(DIB(cx),\n-            size * len * 8 as u64, align * 8 as u64, elem_ty_md, subscripts)\n+        llvm::LLVMDIBuilderCreateArrayType(\n+            DIB(cx),\n+            bytes_to_bits(size * len),\n+            bytes_to_bits(align),\n+            elem_ty_md,\n+            subscripts)\n     };\n }\n \n-fn create_boxed_vec(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n+fn create_boxed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n                     vec_ty_span: span) -> DICompositeType {\n+    debug!(\"create_boxed_vec: %?\", ty::get(vec_t));\n+\n     let loc = span_start(cx, vec_ty_span);\n     let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n \n     let mut vec_scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n-    vec_scx.add_member(\"fill\", 0, sys::size_of::<libc::size_t>(),\n-               sys::min_align_of::<libc::size_t>(), size_t_type);\n-    vec_scx.add_member(\"alloc\", 0, sys::size_of::<libc::size_t>(),\n-               sys::min_align_of::<libc::size_t>(), size_t_type);\n+\n+    vec_scx.add_member(\n+        \"fill\",\n+        0,\n+        sys::size_of::<libc::size_t>(),\n+        sys::min_align_of::<libc::size_t>(),\n+        size_t_type);\n+\n+    vec_scx.add_member(\n+        \"alloc\",\n+        0,\n+        sys::size_of::<libc::size_t>(),\n+        sys::min_align_of::<libc::size_t>(),\n+        size_t_type);\n+\n     let subrange = unsafe {\n         llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, 0_i64)\n     };\n@@ -638,18 +717,32 @@ fn create_boxed_vec(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n     let data_ptr = unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(DIB(cx),\n-            arr_size * 8 as u64, arr_align * 8 as u64, elem_ty_md, subscripts)\n+        llvm::LLVMDIBuilderCreateArrayType(\n+            DIB(cx),\n+            bytes_to_bits(arr_size),\n+            bytes_to_bits(arr_align),\n+            elem_ty_md,\n+            subscripts)\n     };\n-    vec_scx.add_member(\"data\", 0, 0, // clang says the size should be 0\n-               sys::min_align_of::<u8>(), data_ptr);\n+    vec_scx.add_member(\n+        \"data\",\n+        0,\n+        0, // clang says the size should be 0\n+        sys::min_align_of::<u8>(), data_ptr);\n+\n     let vec_md = vec_scx.finalize();\n \n     let mut box_scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n-    box_scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n-               sys::min_align_of::<uint>(), refcount_type);\n+\n+    box_scx.add_member(\n+        \"refcnt\",\n+        0,\n+        sys::size_of::<uint>(),\n+        sys::min_align_of::<uint>(),\n+        refcount_type);\n+\n     let (vp, vpsize, vpalign) = voidptr(cx);\n     box_scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n     box_scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n@@ -661,8 +754,10 @@ fn create_boxed_vec(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n     return mdval;\n }\n \n-fn create_vec_slice(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n+fn create_vec_slice(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n                     -> DICompositeType {\n+    debug!(\"create_vec_slice: %?\", ty::get(vec_t));\n+\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n@@ -672,13 +767,14 @@ fn create_vec_slice(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: sp\n     let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n     let (_, ptr_size, ptr_align) = voidptr(cx);\n     scx.add_member(\"vec\", 0, ptr_size, ptr_align, elem_ptr);\n-    scx.add_member(\"length\", 0, sys::size_of::<uint>(),\n-                    sys::min_align_of::<uint>(), uint_type);\n+    scx.add_member(\"length\", 0, sys::size_of::<uint>(), sys::min_align_of::<uint>(), uint_type);\n     return scx.finalize();\n }\n \n-fn create_fn_ty(cx: @mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n+fn create_fn_ty(cx: &mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n                 span: span) -> DICompositeType {\n+    debug!(\"create_fn_ty: %?\", ty::get(_fn_ty));\n+\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n     let (vp, _, _) = voidptr(cx);\n@@ -688,22 +784,29 @@ fn create_fn_ty(cx: @mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output:\n     let members = ~[output_ptr_md, vp] + inputs_vals;\n \n     return unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_md,\n+        llvm::LLVMDIBuilderCreateSubroutineType(\n+            DIB(cx),\n+            file_md,\n             create_DIArray(DIB(cx), members))\n     };\n }\n \n-fn create_unimpl_ty(cx: @mut CrateContext, t: ty::t) -> DIType {\n+fn create_unimpl_ty(cx: &mut CrateContext, t: ty::t) -> DIType {\n+    debug!(\"create_unimpl_ty: %?\", ty::get(t));\n+\n     let name = ty_to_str(cx.tcx, t);\n     let md = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| { unsafe {\n         llvm::LLVMDIBuilderCreateBasicType(\n-            DIB(cx), name,\n-            0_u64, 8_u64, DW_ATE_unsigned as c_uint)\n+            DIB(cx),\n+            name,\n+            0_u64,\n+            8_u64,\n+            DW_ATE_unsigned as c_uint)\n         }};\n     return md;\n }\n \n-fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n+fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n     match dbg_cx(cx).created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n@@ -758,9 +861,9 @@ fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n             let pointee = create_ty(cx, mt.ty, span);\n             create_pointer_type(cx, t, span, pointee)\n         },\n-        ty::ty_rptr(ref _region, ref _mt) => {\n-            cx.sess.span_note(span, \"debuginfo for rptr NYI\");\n-            create_unimpl_ty(cx, t)\n+        ty::ty_rptr(_, ref mt) => {\n+            let pointee = create_ty(cx, mt.ty, span);\n+            create_pointer_type(cx, t, span, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             let inputs = barefnty.sig.inputs.map(|a| *a);\n@@ -799,8 +902,10 @@ fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: ui\n     let elems = ~[C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n     unsafe {\n         let dbg_loc = llvm::LLVMMDNodeInContext(\n-                dbg_cx(cx).llcontext, vec::raw::to_ptr(elems),\n-                elems.len() as libc::c_uint);\n+                dbg_cx(cx).llcontext,\n+                vec::raw::to_ptr(elems),\n+                elems.len() as c_uint);\n+\n         llvm::LLVMSetCurrentDebugLocation(cx.builder.B, dbg_loc);\n     }\n }\n@@ -819,14 +924,18 @@ fn roundup(x: uint, a: uint) -> uint {\n \n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n-    return cx.sess.codemap.lookup_char_pos(span.lo);\n+    cx.sess.codemap.lookup_char_pos(span.lo)\n }\n \n-fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n+fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (uint, uint) {\n     let llty = type_of::type_of(cx, t);\n     (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n }\n \n+fn bytes_to_bits(bytes: uint) -> c_ulonglong {\n+    (bytes * 8) as c_ulonglong\n+}\n+\n #[inline]\n fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n     cx.dbg_cx.get_mut_ref()"}, {"sha": "7125ebe8d564ca2001aa73aceed70383ac67dcaf", "filename": "src/test/debug-info/basic-types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -26,8 +26,8 @@\n // check:$2 = -1\n // debugger:print c\n // check:$3 = 97\n-// debugger:print i8\n-// check:$4 = 68 'D'\n+// debugger:print/d i8\n+// check:$4 = 68\n // debugger:print i16\n // check:$5 = -16\n // debugger:print i32\n@@ -36,8 +36,8 @@\n // check:$7 = -64\n // debugger:print u\n // check:$8 = 1\n-// debugger:print u8\n-// check:$9 = 100 'd'\n+// debugger:print/d u8\n+// check:$9 = 100\n // debugger:print u16\n // check:$10 = 16\n // debugger:print u32"}, {"sha": "bf53d95b588d05edea01f868cbc1a20644961064", "filename": "src/test/debug-info/destructured-local.rs", "status": "renamed", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -8,19 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+// xfail-test\n+\n+// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n+// value.\n \n // compile-flags:-Z extra-debug-info\n-// debugger:set print pretty off\n-// debugger:break _zzz\n+// debugger:break zzz\n // debugger:run\n // debugger:finish\n-// debugger:print t\n-// check:$1 = {4, 5.5, true}\n+\n+// debugger:print a\n+// check:$1 = 9898\n+\n+// debugger:print b\n+// check:$2 = false\n \n fn main() {\n-    let t = (4, 5.5, true);\n-    _zzz();\n+    let (a, b) : (int, bool) = (9898, false);\n+\n+    zzz();\n }\n \n-fn _zzz() {()}\n\\ No newline at end of file\n+fn zzz() {()}\n\\ No newline at end of file", "previous_filename": "src/test/debug-info/tuple.rs"}, {"sha": "f5563cda259e9f6c8a44d37aa9ad4cb90bcd4656", "filename": "src/test/debug-info/function-arguments.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test\n+\n+// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n+// value.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print x\n+// check:$1 = 111102\n+// debugger:print y\n+// check:$2 = true\n+\n+// debugger:continue\n+// debugger:finish\n+\n+// debugger:print a\n+// check:$3 = 2000\n+// debugger:print b\n+// check:$4 = 3000\n+\n+fn main() {\n+\n+    fun(111102, true);\n+    nested(2000, 3000);\n+\n+    fn nested(a: i32, b: i64) -> (i32, i64) {\n+        zzz()\n+        (a, b)\n+    }\n+}\n+\n+fn fun(x: int, y: bool) -> (int, bool) {\n+    zzz();\n+\n+    (x, y)\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "dfd0fbf865557746eece33093ad86e1d371e424b", "filename": "src/test/debug-info/reference-to-basic.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Freference-to-basic.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// Caveats - gdb prints any 8-bit value (meaning rust i8 and u8 values)\n+// as its numerical value along with its associated ASCII char, there\n+// doesn't seem to be any way around this. Also, gdb doesn't know\n+// about UTF-32 character encoding and will print a rust char as only\n+// its numerical value.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+// debugger:print *bool_ref\n+// check:$1 = true\n+\n+// debugger:print *int_ref\n+// check:$2 = -1\n+\n+// debugger:print *char_ref\n+// check:$3 = 97\n+\n+// debugger:print *i8_ref\n+// check:$4 = 68 'D'\n+\n+// debugger:print *i16_ref\n+// check:$5 = -16\n+\n+// debugger:print *i32_ref\n+// check:$6 = -32\n+\n+// debugger:print *i64_ref\n+// check:$7 = -64\n+\n+// debugger:print *uint_ref\n+// check:$8 = 1\n+\n+// debugger:print *u8_ref\n+// check:$9 = 100 'd'\n+\n+// debugger:print *u16_ref\n+// check:$10 = 16\n+\n+// debugger:print *u32_ref\n+// check:$11 = 32\n+\n+// debugger:print *u64_ref\n+// check:$12 = 64\n+\n+// debugger:print *float_ref\n+// check:$13 = 1.5\n+\n+// debugger:print *f32_ref\n+// check:$14 = 2.5\n+\n+// debugger:print *f64_ref\n+// check:$15 = 3.5\n+\n+fn main() {\n+    let bool_val: bool = true;\n+    let bool_ref : &bool = &bool_val;\n+\n+    let int_val: int = -1;\n+    let int_ref : &int = &int_val;\n+\n+    let char_val: char = 'a';\n+    let char_ref : &char = &char_val;\n+\n+    let i8_val: i8 = 68;\n+    let i8_ref : &i8 = &i8_val;\n+\n+    let i16_val: i16 = -16;\n+    let i16_ref : &i16 = &i16_val;\n+\n+    let i32_val: i32 = -32;\n+    let i32_ref : &i32 = &i32_val;\n+\n+    let uint_val: i64 = -64;\n+    let i64_ref : &i64 = &uint_val;\n+\n+    let uint_val: uint = 1;\n+    let uint_ref : &uint = &uint_val;\n+\n+    let u8_val: u8 = 100;\n+    let u8_ref : &u8 = &u8_val;\n+\n+    let u16_val: u16 = 16;\n+    let u16_ref : &u16 = &u16_val;\n+\n+    let u32_val: u32 = 32;\n+    let u32_ref : &u32 = &u32_val;\n+\n+    let u64_val: u64 = 64;\n+    let u64_ref : &u64 = &u64_val;\n+\n+    let float_val: float = 1.5;\n+    let float_ref : &float = &float_val;\n+\n+    let f32_val: f32 = 2.5;\n+    let f32_ref : &f32 = &f32_val;\n+\n+    let f64_val: f64 = 3.5;\n+    let f64_ref : &f64 = &f64_val;\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "e3951c94b6f86885e6921a5cb58506804dbe53ca", "filename": "src/test/debug-info/reference-to-managed-basic.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-managed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-managed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Freference-to-managed-basic.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// Gdb doesn't know about UTF-32 character encoding and will print a rust char as only\n+// its numerical value.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+// debugger:print *bool_ref\n+// check:$1 = true\n+\n+// debugger:print *int_ref\n+// check:$2 = -1\n+\n+// debugger:print *char_ref\n+// check:$3 = 97\n+\n+// debugger:print/d *i8_ref\n+// check:$4 = 68\n+\n+// debugger:print *i16_ref\n+// check:$5 = -16\n+\n+// debugger:print *i32_ref\n+// check:$6 = -32\n+\n+// debugger:print *i64_ref\n+// check:$7 = -64\n+\n+// debugger:print *uint_ref\n+// check:$8 = 1\n+\n+// debugger:print/d *u8_ref\n+// check:$9 = 100\n+\n+// debugger:print *u16_ref\n+// check:$10 = 16\n+\n+// debugger:print *u32_ref\n+// check:$11 = 32\n+\n+// debugger:print *u64_ref\n+// check:$12 = 64\n+\n+// debugger:print *float_ref\n+// check:$13 = 1.5\n+\n+// debugger:print *f32_ref\n+// check:$14 = 2.5\n+\n+// debugger:print *f64_ref\n+// check:$15 = 3.5\n+\n+\n+fn main() {\n+    let bool_box: @bool = @true;\n+    let bool_ref : &bool = bool_box;\n+\n+    let int_box: @int = @-1;\n+    let int_ref : &int = int_box;\n+\n+    let char_box: @char = @'a';\n+    let char_ref : &char = char_box;\n+\n+    let i8_box: @i8 = @68;\n+    let i8_ref : &i8 = i8_box;\n+\n+    let i16_box: @i16 = @-16;\n+    let i16_ref : &i16 = i16_box;\n+\n+    let i32_box: @i32 = @-32;\n+    let i32_ref : &i32 = i32_box;\n+\n+    let i64_box: @i64 = @-64;\n+    let i64_ref : &i64 = i64_box;\n+\n+    let uint_box: @uint = @1;\n+    let uint_ref : &uint = uint_box;\n+\n+    let u8_box: @u8 = @100;\n+    let u8_ref : &u8 = u8_box;\n+\n+    let u16_box: @u16 = @16;\n+    let u16_ref : &u16 = u16_box;\n+\n+    let u32_box: @u32 = @32;\n+    let u32_ref : &u32 = u32_box;\n+\n+    let u64_box: @u64 = @64;\n+    let u64_ref : &u64 = u64_box;\n+\n+    let float_box: @float = @1.5;\n+    let float_ref : &float = float_box;\n+\n+    let f32_box: @f32 = @2.5;\n+    let f32_ref : &f32 = f32_box;\n+\n+    let f64_box: @f64 = @3.5;\n+    let f64_ref : &f64 = f64_box;\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "f00872c00b0e49d4ff994d47d481f73608f6133a", "filename": "src/test/debug-info/reference-to-struct.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Freference-to-struct.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n+// value.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print *stack_val_ref\n+// check:$1 = {x = 10, y = 23.5}\n+\n+// debugger:print *stack_val_interior_ref_1\n+// check:$2 = 10\n+\n+// debugger:print *stack_val_interior_ref_2\n+// check:$3 = 23.5\n+\n+// debugger:print *ref_to_unnamed\n+// check:$4 = {x = 11, y = 24.5}\n+\n+// debugger:print *managed_val_ref\n+// check:$5 = {x = 12, y = 25.5}\n+\n+// debugger:print *managed_val_interior_ref_1\n+// check:$6 = 12\n+\n+// debugger:print *managed_val_interior_ref_2\n+// check:$7 = 25.5\n+\n+// debugger:print *unique_val_ref\n+// check:$8 = {x = 13, y = 26.5}\n+\n+// debugger:print *unique_val_interior_ref_1\n+// check:$9 = 13\n+\n+// debugger:print *unique_val_interior_ref_2\n+// check:$10 = 26.5\n+\n+\n+\n+struct SomeStruct {\n+    x: int,\n+    y: f64\n+}\n+\n+fn main() {\n+    let stack_val: SomeStruct = SomeStruct { x: 10, y: 23.5 };\n+    let stack_val_ref : &SomeStruct = &stack_val;\n+    let stack_val_interior_ref_1 : &int = &stack_val.x;\n+    let stack_val_interior_ref_2 : &f64 = &stack_val.y;\n+    let ref_to_unnamed : &SomeStruct = &SomeStruct { x: 11, y: 24.5 };\n+\n+    let managed_val = @SomeStruct { x: 12, y: 25.5 };\n+    let managed_val_ref : &SomeStruct = managed_val;\n+    let managed_val_interior_ref_1 : &int = &managed_val.x;\n+    let managed_val_interior_ref_2 : &f64 = &managed_val.y;\n+\n+    let unique_val = ~SomeStruct { x: 13, y: 26.5 };\n+    let unique_val_ref : &SomeStruct = unique_val;\n+    let unique_val_interior_ref_1 : &int = &unique_val.x;\n+    let unique_val_interior_ref_2 : &f64 = &unique_val.y;\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "86d02185bdae7839a68b35c086d15db4d2a7ac8e", "filename": "src/test/debug-info/reference-to-tuple.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Freference-to-tuple.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n+// value.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print *stack_val_ref\n+// check:$1 = {-14, -19}\n+\n+// debugger:print *ref_to_unnamed\n+// check:$2 = {-15, -20}\n+\n+// debugger:print *managed_val_ref\n+// check:$3 = {-16, -21}\n+\n+// debugger:print *unique_val_ref\n+// check:$4 = {-17, -22}\n+\n+fn main() {\n+    let stack_val: (i16, f32) = (-14, -19f32);\n+    let stack_val_ref : &(i16, f32) = &stack_val;\n+    let ref_to_unnamed : &(i16, f32) = &(-15, -20f32);\n+\n+    let managed_val : @(i16, f32) = @(-16, -21f32);\n+    let managed_val_ref : &(i16, f32) = managed_val;\n+\n+    let unique_val: ~(i16, f32) = ~(-17, -22f32);\n+    let unique_val_ref : &(i16, f32) = unique_val;\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "ce5b50459f660c5dcba3f32d469d8421c65de0a9", "filename": "src/test/debug-info/reference-to-unique-basic.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-unique-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Freference-to-unique-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Freference-to-unique-basic.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// Gdb doesn't know\n+// about UTF-32 character encoding and will print a rust char as only\n+// its numerical value.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+// debugger:print *bool_ref\n+// check:$1 = true\n+\n+// debugger:print *int_ref\n+// check:$2 = -1\n+\n+// debugger:print *char_ref\n+// check:$3 = 97\n+\n+// debugger:print/d *i8_ref\n+// check:$4 = 68\n+\n+// debugger:print *i16_ref\n+// check:$5 = -16\n+\n+// debugger:print *i32_ref\n+// check:$6 = -32\n+\n+// debugger:print *i64_ref\n+// check:$7 = -64\n+\n+// debugger:print *uint_ref\n+// check:$8 = 1\n+\n+// debugger:print/d *u8_ref\n+// check:$9 = 100\n+\n+// debugger:print *u16_ref\n+// check:$10 = 16\n+\n+// debugger:print *u32_ref\n+// check:$11 = 32\n+\n+// debugger:print *u64_ref\n+// check:$12 = 64\n+\n+// debugger:print *float_ref\n+// check:$13 = 1.5\n+\n+// debugger:print *f32_ref\n+// check:$14 = 2.5\n+\n+// debugger:print *f64_ref\n+// check:$15 = 3.5\n+\n+\n+fn main() {\n+    let bool_box: ~bool = ~true;\n+    let bool_ref : &bool = bool_box;\n+\n+    let int_box: ~int = ~-1;\n+    let int_ref : &int = int_box;\n+\n+    let char_box: ~char = ~'a';\n+    let char_ref : &char = char_box;\n+\n+    let i8_box: ~i8 = ~68;\n+    let i8_ref : &i8 = i8_box;\n+\n+    let i16_box: ~i16 = ~-16;\n+    let i16_ref : &i16 = i16_box;\n+\n+    let i32_box: ~i32 = ~-32;\n+    let i32_ref : &i32 = i32_box;\n+\n+    let i64_box: ~i64 = ~-64;\n+    let i64_ref : &i64 = i64_box;\n+\n+    let uint_box: ~uint = ~1;\n+    let uint_ref : &uint = uint_box;\n+\n+    let u8_box: ~u8 = ~100;\n+    let u8_ref : &u8 = u8_box;\n+\n+    let u16_box: ~u16 = ~16;\n+    let u16_ref : &u16 = u16_box;\n+\n+    let u32_box: ~u32 = ~32;\n+    let u32_ref : &u32 = u32_box;\n+\n+    let u64_box: ~u64 = ~64;\n+    let u64_ref : &u64 = u64_box;\n+\n+    let float_box: ~float = ~1.5;\n+    let float_ref : &float = float_box;\n+\n+    let f32_box: ~f32 = ~2.5;\n+    let f32_ref : &f32 = f32_box;\n+\n+    let f64_box: ~f64 = ~3.5;\n+    let f64_ref : &f64 = f64_box;\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "49e7bc255c10ffe2df5cd5981c56fc95eb719f85", "filename": "src/test/debug-info/simple-struct.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print no_padding16\n+// check:$1 = {x = 10000, y = -10001}\n+\n+// debugger:print no_padding32\n+// check:$2 = {x = -10002, y = -10003.5, z = 10004}\n+\n+// debugger:print no_padding64\n+// check:$3 = {x = -10005.5, y = 10006, z = 10007}\n+\n+// debugger:print no_padding163264\n+// check:$4 = {a = -10008, b = 10009, c = 10010, d = 10011}\n+\n+// debugger:print internal_padding\n+// check:$5 = {x = 10012, y = -10013}\n+\n+// debugger:print padding_at_end\n+// check:$6 = {x = -10014, y = 10015}\n+\n+\n+struct NoPadding16 {\n+    x: u16,\n+    y: i16\n+}\n+\n+struct NoPadding32 {\n+    x: i32,\n+    y: f32,\n+    z: u32\n+}\n+\n+struct NoPadding64 {\n+    x: f64,\n+    y: i64,\n+    z: u64\n+}\n+\n+struct NoPadding163264 {\n+    a: i16,\n+    b: u16,\n+    c: i32,\n+    d: u64\n+}\n+\n+struct InternalPadding {\n+    x: u16,\n+    y: i64\n+}\n+\n+struct PaddingAtEnd {\n+    x: i64,\n+    y: u16\n+}\n+\n+fn main() {\n+    let no_padding16 = NoPadding16 { x: 10000, y: -10001 };\n+    let no_padding32 = NoPadding32 { x: -10002, y: -10003.5, z: 10004 };\n+    let no_padding64 = NoPadding64 { x: -10005.5, y: 10006, z: 10007 };\n+    let no_padding163264 = NoPadding163264 { a: -10008, b: 10009, c: 10010, d: 10011 };\n+\n+    let internal_padding = InternalPadding { x: 10012, y: -10013 };\n+    let padding_at_end = PaddingAtEnd { x: -10014, y: 10015 };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "84c736fab6b014c77059c57bdcd0e4c2248013b5", "filename": "src/test/debug-info/simple-tuple.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print/d noPadding8\n+// check:$1 = {-100, 100}\n+// debugger:print noPadding16\n+// check:$2 = {0, 1, 2}\n+// debugger:print noPadding32\n+// check:$3 = {3, 4.5, 5}\n+// debugger:print noPadding64\n+// check:$4 = {6, 7.5, 8}\n+\n+// debugger:print internalPadding1\n+// check:$5 = {9, 10}\n+// debugger:print internalPadding2\n+// check:$6 = {11, 12, 13, 14}\n+\n+// debugger:print paddingAtEnd\n+// check:$7 = {15, 16}\n+\n+\n+fn main() {\n+    let noPadding8 : (i8, u8) = (-100, 100);\n+    let noPadding16 : (i16, i16, u16) = (0, 1, 2);\n+    let noPadding32 : (i32, f32, u32) = (3, 4.5, 5);\n+    let noPadding64 : (i64, f64, u64) = (6, 7.5, 8);\n+\n+    let internalPadding1 : (i16, i32) = (9, 10);\n+    let internalPadding2 : (i16, i32, u32, u64) = (11, 12, 13, 14);\n+\n+    let paddingAtEnd : (i32, i16) = (15, 16);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "04c5eec610b73599147aac068d015b7335a53172", "filename": "src/test/debug-info/struct-in-struct.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fstruct-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fstruct-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-in-struct.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print three_simple_structs\n+// check:$1 = {x = {x = 1}, y = {x = 2}, z = {x = 3}}\n+\n+// debugger:print internal_padding_parent\n+// check:$2 = {x = {x = 4, y = 5}, y = {x = 6, y = 7}, z = {x = 8, y = 9}}\n+\n+// debugger:print padding_at_end_parent\n+// check:$3 = {x = {x = 10, y = 11}, y = {x = 12, y = 13}, z = {x = 14, y = 15}}\n+\n+\n+struct Simple {\n+    x: i32\n+}\n+\n+struct InternalPadding {\n+    x: i32,\n+    y: i64\n+}\n+\n+struct PaddingAtEnd {\n+    x: i64,\n+    y: i32\n+}\n+\n+struct ThreeSimpleStructs {\n+    x: Simple,\n+    y: Simple,\n+    z: Simple\n+}\n+\n+struct InternalPaddingParent {\n+    x: InternalPadding,\n+    y: InternalPadding,\n+    z: InternalPadding\n+}\n+\n+struct PaddingAtEndParent {\n+    x: PaddingAtEnd,\n+    y: PaddingAtEnd,\n+    z: PaddingAtEnd\n+}\n+\n+struct Mixed {\n+    x: PaddingAtEnd,\n+    y: InternalPadding,\n+    z: Simple,\n+    w: i16\n+}\n+\n+struct Bag {\n+    x: Simple\n+}\n+\n+struct BagInBag {\n+    x: Bag\n+}\n+\n+struct ThatsJustOverkill {\n+    x: BagInBag\n+}\n+\n+struct Tree {\n+    x: Simple,\n+    y: InternalPaddingParent,\n+    z: BagInBag\n+}\n+\n+fn main() {\n+\n+    let three_simple_structs = ThreeSimpleStructs {\n+        x: Simple { x: 1 },\n+        y: Simple { x: 2 },\n+        z: Simple { x: 3 }\n+    };\n+\n+    let internal_padding_parent = InternalPaddingParent {\n+        x: InternalPadding { x: 4, y: 5 },\n+        y: InternalPadding { x: 6, y: 7 },\n+        z: InternalPadding { x: 8, y: 9 }\n+    };\n+\n+    let padding_at_end_parent = PaddingAtEndParent {\n+        x: PaddingAtEnd { x: 10, y: 11 },\n+        y: PaddingAtEnd { x: 12, y: 13 },\n+        z: PaddingAtEnd { x: 14, y: 15 }\n+    };\n+\n+    let mixed = Mixed {\n+        x: PaddingAtEnd { x: 16, y: 17 },\n+        y: InternalPadding { x: 18, y: 19 },\n+        z: Simple { x: 20 },\n+        w: 21\n+    };\n+\n+    let bag = Bag { x: Simple { x: 22 } };\n+    let bag_in_bag = BagInBag {\n+        x: Bag {\n+            x: Simple { x: 23 }\n+        }\n+    };\n+\n+    let tjo = ThatsJustOverkill {\n+        x: BagInBag {\n+            x: Bag {\n+                x: Simple { x: 24 }\n+            }\n+        }\n+    };\n+\n+    let tree = Tree {\n+        x: Simple { x: 25 },\n+        y: InternalPaddingParent {\n+            x: InternalPadding { x: 26, y: 27 },\n+            y: InternalPadding { x: 28, y: 29 },\n+            z: InternalPadding { x: 30, y: 31 }\n+        },\n+        z: BagInBag {\n+            x: Bag {\n+                x: Simple { x: 32 }\n+            }\n+        }\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "f8281bba49e9f44e1152458508be897fa57f72df", "filename": "src/test/debug-info/struct-with-destructor.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+// debugger:print simple\n+// check:$1 = {x = 10, y = 20}\n+\n+// debugger:print noDestructor\n+// check:$2 = {a = {x = 10, y = 20}, guard = -1}\n+\n+// debugger:print withDestructor\n+// check:$3 = {a = {x = 10, y = 20}, guard = -1}\n+\n+struct NoDestructor {\n+    x : i32,\n+    y : i64\n+}\n+\n+struct WithDestructor {\n+    x : i32,\n+    y : i64\n+}\n+\n+impl Drop for WithDestructor {\n+    fn finalize(&self) {}\n+}\n+\n+struct NoDestructorGuarded {\n+    a: NoDestructor,\n+    guard: i64\n+}\n+\n+struct WithDestructorGuarded {\n+    a: WithDestructor,\n+    guard: i64\n+}\n+\n+\n+// The compiler adds a 'destructed' boolean field to structs implementing Drop. This field is used\n+// at runtime to prevent drop() to be executed more than once (see middle::trans::adt).\n+// This field must be incorporated by the debug info generation. Otherwise the debugger assumes a\n+// wrong size/layout for the struct.\n+fn main() {\n+\n+    let simple = WithDestructor { x: 10, y: 20 };\n+\n+    let noDestructor = NoDestructorGuarded {\n+        a: NoDestructor { x: 10, y: 20 },\n+        guard: -1\n+    };\n+\n+    // If the destructor flag field is not incorporated into the debug info for 'WithDestructor'\n+    // then the debugger will have an invalid offset for the field 'guard' and thus should not be\n+    // able to read its value correctly (dots are padding bytes, D is the boolean destructor flag):\n+    //\n+    // NoDestructorGuarded = 0000....00000000FFFFFFFF\n+    //                       <--------------><------>\n+    //                         NoDestructor   guard\n+    //\n+    //\n+    // withDestructorGuarded = 0000....00000000D.......FFFFFFFF\n+    //                         <--------------><------>          // How debug info says it is\n+    //                          WithDestructor  guard\n+    //\n+    //                         <----------------------><------>  // How it actually is\n+    //                              WithDestructor      guard\n+    //\n+    let withDestructor = WithDestructorGuarded {\n+        a: WithDestructor { x: 10, y: 20 },\n+        guard: -1\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}"}, {"sha": "369c9fd28ccdf23f55b39c6cca7e950c3d2d7bb8", "filename": "src/test/debug-info/tuple-in-struct.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Ftuple-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Ftuple-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple-in-struct.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print no_padding1\n+// check:$1 = {x = {0, 1}, y = 2, z = {3, 4, 5}}\n+// debugger:print no_padding2\n+// check:$2 = {x = {6, 7}, y = {{8, 9}, 10}}\n+\n+// debugger:print tuple_internal_padding\n+// check:$3 = {x = {11, 12}, y = {13, 14}}\n+// debugger:print struct_internal_padding\n+// check:$4 = {x = {15, 16}, y = {17, 18}}\n+// debugger:print both_internally_padded\n+// check:$5 = {x = {19, 20, 21}, y = {22, 23}}\n+\n+// debugger:print single_tuple\n+// check:$6 = {x = {24, 25, 26}}\n+\n+// debugger:print tuple_padded_at_end\n+// check:$7 = {x = {27, 28}, y = {29, 30}}\n+// debugger:print struct_padded_at_end\n+// check:$8 = {x = {31, 32}, y = {33, 34}}\n+// debugger:print both_padded_at_end\n+// check:$9 = {x = {35, 36, 37}, y = {38, 39}}\n+\n+// debugger:print mixed_padding\n+// check:$10 = {x = {{40, 41, 42}, {43, 44}}, y = {45, 46, 47, 48}}\n+\n+struct NoPadding1 {\n+    x: (i32, i32),\n+    y: i32,\n+    z: (i32, i32, i32)\n+}\n+\n+struct NoPadding2 {\n+    x: (i32, i32),\n+    y: ((i32, i32), i32)\n+}\n+\n+struct TupleInternalPadding {\n+    x: (i16, i32),\n+    y: (i32, i64)\n+}\n+\n+struct StructInternalPadding {\n+    x: (i16, i16),\n+    y: (i64, i64)\n+}\n+\n+struct BothInternallyPadded {\n+    x: (i16, i32, i32),\n+    y: (i32, i64)\n+}\n+\n+struct SingleTuple {\n+    x: (i16, i32, i64)\n+}\n+\n+struct TuplePaddedAtEnd {\n+    x: (i32, i16),\n+    y: (i64, i32)\n+}\n+\n+struct StructPaddedAtEnd {\n+    x: (i64, i64),\n+    y: (i16, i16)\n+}\n+\n+struct BothPaddedAtEnd {\n+    x: (i32, i32, i16),\n+    y: (i64, i32)\n+}\n+\n+// Data-layout (padding signified by dots, one column = 2 bytes):\n+// [a.bbc...ddddee..ffffg.hhi...]\n+struct MixedPadding {\n+    x: ((i16, i32, i16), (i64, i32)),\n+    y: (i64, i16, i32, i16)\n+}\n+\n+\n+fn main() {\n+    let no_padding1 = NoPadding1 {\n+        x: (0, 1),\n+        y: 2,\n+        z: (3, 4, 5)\n+    };\n+\n+    let no_padding2 = NoPadding2 {\n+        x: (6, 7),\n+        y: ((8, 9), 10)\n+    };\n+\n+    let tuple_internal_padding = TupleInternalPadding {\n+        x: (11, 12),\n+        y: (13, 14)\n+    };\n+\n+    let struct_internal_padding = StructInternalPadding {\n+        x: (15, 16),\n+        y: (17, 18)\n+    };\n+\n+    let both_internally_padded = BothInternallyPadded {\n+        x: (19, 20, 21),\n+        y: (22, 23)\n+    };\n+\n+    let single_tuple = SingleTuple {\n+        x: (24, 25, 26)\n+    };\n+\n+    let tuple_padded_at_end = TuplePaddedAtEnd {\n+        x: (27, 28),\n+        y: (29, 30)\n+    };\n+\n+    let struct_padded_at_end = StructPaddedAtEnd {\n+        x: (31, 32),\n+        y: (33, 34)\n+    };\n+\n+    let both_padded_at_end = BothPaddedAtEnd {\n+        x: (35, 36, 37),\n+        y: (38, 39)\n+    };\n+\n+    let mixed_padding = MixedPadding {\n+        x: ((40, 41, 42), (43, 44)),\n+        y: (45, 46, 47, 48)\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "13f8719694e5feb56520f8f839bae4b44dd89665", "filename": "src/test/debug-info/tuple-in-tuple.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print no_padding1\n+// check:$1 = {{0, 1}, 2, 3}\n+// debugger:print no_padding2\n+// check:$2 = {4, {5, 6}, 7}\n+// debugger:print no_padding3\n+// check:$3 = {8, 9, {10, 11}}\n+\n+// debugger:print internal_padding1\n+// check:$4 = {12, {13, 14}}\n+// debugger:print internal_padding2\n+// check:$5 = {15, {16, 17}}\n+\n+// debugger:print padding_at_end1\n+// check:$6 = {18, {19, 20}}\n+// debugger:print padding_at_end2\n+// check:$7 = {{21, 22}, 23}\n+\n+fn main() {\n+    let no_padding1 : ((u32, u32), u32, u32) = ((0, 1), 2, 3);\n+    let no_padding2 : (u32, (u32, u32), u32) = (4, (5, 6), 7);\n+    let no_padding3 : (u32, u32, (u32, u32)) = (8, 9, (10, 11));\n+\n+    let internal_padding1 : (i16, (i32, i32)) = (12, (13, 14));\n+    let internal_padding2 : (i16, (i16, i32)) = (15, (16, 17));\n+\n+    let padding_at_end1 : (i32, (i32, i16)) = (18, (19, 20));\n+    let padding_at_end2 : ((i32, i16), i32) = ((21, 22), 23);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "dd3a1671b7858daa173624b6dba4e9994255b671", "filename": "src/test/debug-info/variable-scope.rs", "status": "renamed", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fvariable-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927f454ac115c7d19f34951914b269ce356a1ca6/src%2Ftest%2Fdebug-info%2Fvariable-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvariable-scope.rs?ref=927f454ac115c7d19f34951914b269ce356a1ca6", "patch": "@@ -8,28 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+// xfail-test\n \n // compile-flags:-Z extra-debug-info\n-// debugger:set print pretty off\n-// debugger:break _zzz\n+// debugger:break zzz\n // debugger:run\n // debugger:finish\n-// debugger:print pair\n-// check:$1 = {x = 1, y = 2}\n-// debugger:print pair.x\n-// check:$2 = 1\n-// debugger:print pair.y\n-// check:$3 = 2\n-\n-struct Pair {\n-    x: int,\n-    y: int\n-}\n+// debugger:print x\n+// check:$1 = false\n+// debugger:print y\n+// check:$2 = true\n+\n+// debugger:continue\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 10\n+\n+// debugger:continue\n+// debugger:finish\n+// debugger:print x\n+// check:$4 = false\n+// debugger:print y\n+// check:$5 = 11\n \n fn main() {\n-    let pair = Pair { x: 1, y: 2 };\n-    _zzz();\n+    let x = false;\n+    let y = true;\n+\n+    zzz();\n+\n+    {\n+        let x = 10;\n+        zzz();\n+    }\n+\n+    let y = 11;\n+    zzz();\n }\n \n-fn _zzz() {()}\n\\ No newline at end of file\n+fn zzz() {()}", "previous_filename": "src/test/debug-info/struct.rs"}]}