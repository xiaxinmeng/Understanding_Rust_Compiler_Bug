{"sha": "3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNWMzMTFkYzFkY2I1YmZlNjVkNmVlY2QwZGZkYTA0ZDc3Yzc1OTQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-17T15:58:01Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-20T11:39:30Z"}, "message": "rustc: simplify TypeContents drastically.", "tree": {"sha": "f52e83a3ae2f24c924f7032f26284572dcdb7ec4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f52e83a3ae2f24c924f7032f26284572dcdb7ec4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594", "html_url": "https://github.com/rust-lang/rust/commit/3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa6b50fc6282a2c64814b35b16464a22f4ae9265", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6b50fc6282a2c64814b35b16464a22f4ae9265", "html_url": "https://github.com/rust-lang/rust/commit/fa6b50fc6282a2c64814b35b16464a22f4ae9265"}], "stats": {"total": 190, "additions": 42, "deletions": 148}, "files": [{"sha": "c690795b3421dfb82d3e6eaddeccdf5627d49730", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 41, "deletions": 147, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594", "patch": "@@ -8,118 +8,45 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::{DefId};\n use ty::{self, Ty, TyCtxt};\n use util::common::MemoizationMap;\n use util::nodemap::FxHashMap;\n \n-use std::fmt;\n-use std::ops;\n-\n-use syntax::ast;\n-\n-/// Type contents is how the type checker reasons about kinds.\n-/// They track what kinds of things are found within a type.  You can\n-/// think of them as kind of an \"anti-kind\".  They track the kinds of values\n-/// and thinks that are contained in types.  Having a larger contents for\n-/// a type tends to rule that type *out* from various kinds.  For example,\n-/// a type that contains a reference is not sendable.\n-///\n-/// The reason we compute type contents and not kinds is that it is\n-/// easier for me (nmatsakis) to think about what is contained within\n-/// a type than to think about what is *not* contained within a type.\n-#[derive(Clone, Copy)]\n-pub struct TypeContents {\n-    pub bits: u64\n-}\n-\n-macro_rules! def_type_content_sets {\n-    (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n-        #[allow(non_snake_case)]\n-        mod $mname {\n-            use super::TypeContents;\n-            $(\n-                #[allow(non_upper_case_globals)]\n-                pub const $name: TypeContents = TypeContents { bits: $bits };\n-             )+\n-        }\n-    }\n-}\n-\n-def_type_content_sets! {\n-    mod TC {\n-        None                                = 0b0000_0000__0000_0000__0000,\n-\n-        // Things that are interior to the value (first nibble):\n-        InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n-        InteriorParam                       = 0b0000_0000__0000_0000__0100,\n-        // InteriorAll                         = 0b00000000__00000000__1111,\n-\n-        // Things that are owned by the value (second and third nibbles):\n-        OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n-        // OwnsAll                             = 0b0000_0000__1111_1111__0000,\n-\n-        // All bits\n-        All                                 = 0b1111_1111__1111_1111__1111\n+bitflags! {\n+    /// Type contents is how the type checker reasons about kinds.\n+    /// They track what kinds of things are found within a type.  You can\n+    /// think of them as kind of an \"anti-kind\".  They track the kinds of values\n+    /// and thinks that are contained in types.  Having a larger contents for\n+    /// a type tends to rule that type *out* from various kinds.  For example,\n+    /// a type that contains a reference is not sendable.\n+    ///\n+    /// The reason we compute type contents and not kinds is that it is\n+    /// easier for me (nmatsakis) to think about what is contained within\n+    /// a type than to think about what is *not* contained within a type.\n+    flags TypeContents: u8 {\n+        const INTERIOR_UNSAFE   = 0b01,\n+        const OWNS_DTOR         = 0b10,\n     }\n }\n \n impl TypeContents {\n     pub fn when(&self, cond: bool) -> TypeContents {\n-        if cond {*self} else {TC::None}\n-    }\n-\n-    pub fn intersects(&self, tc: TypeContents) -> bool {\n-        (self.bits & tc.bits) != 0\n-    }\n-\n-    pub fn interior_param(&self) -> bool {\n-        self.intersects(TC::InteriorParam)\n+        if cond {*self} else {TypeContents::empty()}\n     }\n \n     pub fn interior_unsafe(&self) -> bool {\n-        self.intersects(TC::InteriorUnsafe)\n+        self.intersects(TypeContents::INTERIOR_UNSAFE)\n     }\n \n     pub fn needs_drop(&self, _: TyCtxt) -> bool {\n-        self.intersects(TC::OwnsDtor)\n+        self.intersects(TypeContents::OWNS_DTOR)\n     }\n \n     pub fn union<I, T, F>(v: I, mut f: F) -> TypeContents where\n         I: IntoIterator<Item=T>,\n         F: FnMut(T) -> TypeContents,\n     {\n-        v.into_iter().fold(TC::None, |tc, ty| tc | f(ty))\n-    }\n-}\n-\n-impl ops::BitOr for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn bitor(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits | other.bits}\n-    }\n-}\n-\n-impl ops::BitAnd for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn bitand(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & other.bits}\n-    }\n-}\n-\n-impl ops::Sub for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn sub(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & !other.bits}\n-    }\n-}\n-\n-impl fmt::Debug for TypeContents {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeContents({:b})\", self.bits)\n+        v.into_iter().fold(TypeContents::empty(), |tc, ty| tc | f(ty))\n     }\n }\n \n@@ -139,52 +66,34 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             //\n             // When computing the type contents of such a type, we wind up deeply\n             // recursing as we go.  So when we encounter the recursive reference\n-            // to List, we temporarily use TC::None as its contents.  Later we'll\n+            // to List, we temporarily use TypeContents::empty() as its contents.  Later we'll\n             // patch up the cache with the correct value, once we've computed it\n             // (this is basically a co-inductive process, if that helps).  So in\n-            // the end we'll compute TC::OwnsOwned, in this case.\n+            // the end we'll compute TypeContents::OwnsOwned, in this case.\n             //\n             // The problem is, as we are doing the computation, we will also\n             // compute an *intermediate* contents for, e.g., Option<List> of\n-            // TC::None.  This is ok during the computation of List itself, but if\n+            // TypeContents::empty().  This is ok during the computation of List itself, but if\n             // we stored this intermediate value into tcx.tc_cache, then later\n-            // requests for the contents of Option<List> would also yield TC::None\n+            // requests for the contents of Option<List> would also yield TypeContents::empty()\n             // which is incorrect.  This value was computed based on the crutch\n             // value for the type contents of list.  The correct value is\n-            // TC::OwnsOwned.  This manifested as issue #4821.\n+            // TypeContents::OwnsOwned.  This manifested as issue #4821.\n             if let Some(tc) = cache.get(&ty) {\n                 return *tc;\n             }\n             // Must check both caches!\n             if let Some(tc) = tcx.tc_cache.borrow().get(&ty) {\n                 return *tc;\n             }\n-            cache.insert(ty, TC::None);\n+            cache.insert(ty, TypeContents::empty());\n \n             let result = match ty.sty {\n-                // usize and isize are ffi-unsafe\n-                ty::TyUint(ast::UintTy::Us) | ty::TyInt(ast::IntTy::Is) => {\n-                    TC::None\n-                }\n-\n-                // Scalar and unique types are sendable, and durable\n                 ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n                 ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar => {\n-                    TC::None\n-                }\n-\n-                ty::TyDynamic(..) => {\n-                    TC::All - TC::InteriorParam\n-                }\n-\n-                ty::TyRawPtr(_) => {\n-                    TC::None\n-                }\n-\n-                ty::TyRef(..) => {\n-                    TC::None\n-                }\n+                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+                ty::TyRawPtr(_) | ty::TyRef(..) |\n+                ty::TyStr => TypeContents::empty(),\n \n                 ty::TyArray(ty, _) => {\n                     tc_ty(tcx, ty, cache)\n@@ -193,7 +102,6 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 ty::TySlice(ty) => {\n                     tc_ty(tcx, ty, cache)\n                 }\n-                ty::TyStr => TC::None,\n \n                 ty::TyClosure(def_id, ref substs) => {\n                     TypeContents::union(\n@@ -207,29 +115,25 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 }\n \n                 ty::TyAdt(def, substs) => {\n-                    let mut res =\n-                        TypeContents::union(&def.variants, |v| {\n-                            TypeContents::union(&v.fields, |f| {\n-                                tc_ty(tcx, f.ty(tcx, substs), cache)\n-                            })\n-                        });\n-\n-                    if def.is_union() {\n-                        // unions don't have destructors regardless of the child types\n-                        res = res - TC::OwnsDtor;\n-                    }\n-\n-                    if def.has_dtor(tcx) {\n-                        res = res | TC::OwnsDtor;\n-                    }\n-\n-                    apply_lang_items(tcx, def.did, res)\n+                    TypeContents::union(&def.variants, |v| {\n+                        TypeContents::union(&v.fields, |f| {\n+                            tc_ty(tcx, f.ty(tcx, substs), cache)\n+                        })\n+                    })\n+\n+                    // unions don't have destructors regardless of the child types\n+                        - TypeContents::OWNS_DTOR.when(def.is_union())\n+                        | TypeContents::OWNS_DTOR.when(def.has_dtor(tcx))\n+                        | TypeContents::INTERIOR_UNSAFE.when(\n+                            Some(def.did) == tcx.lang_items.unsafe_cell_type())\n                 }\n \n+\n+                ty::TyDynamic(..) |\n                 ty::TyProjection(..) |\n                 ty::TyParam(_) |\n                 ty::TyAnon(..) => {\n-                    TC::All\n+                    TypeContents::INTERIOR_UNSAFE | TypeContents::OWNS_DTOR\n                 }\n \n                 ty::TyInfer(_) |\n@@ -241,15 +145,5 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             cache.insert(ty, result);\n             result\n         }\n-\n-        fn apply_lang_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      did: DefId, tc: TypeContents)\n-                                      -> TypeContents {\n-            if Some(did) == tcx.lang_items.unsafe_cell_type() {\n-                tc | TC::InteriorUnsafe\n-            } else {\n-                tc\n-            }\n-        }\n     }\n }"}, {"sha": "78d3885bb988aefca22d1fe06b6762d47e4df7e3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3f5c311dc1dcb5bfe65d6eecd0dfda04d77c7594", "patch": "@@ -2405,7 +2405,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // destructor (e.g. zero its memory on move).\n \n         let contents = ty.type_contents(tcx);\n-        debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n+        debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents.bits());\n         contents.needs_drop(tcx)\n     }\n "}]}