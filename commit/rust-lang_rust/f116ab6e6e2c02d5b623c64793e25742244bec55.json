{"sha": "f116ab6e6e2c02d5b623c64793e25742244bec55", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMTZhYjZlNmUyYzAyZDViNjIzYzY0NzkzZTI1NzQyMjQ0YmVjNTU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-05T19:39:05Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-15T20:24:16Z"}, "message": "proc_macro: Properly support raw identifiers", "tree": {"sha": "1234326f7f1cacaf298a70c70ff6481832859681", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1234326f7f1cacaf298a70c70ff6481832859681"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f116ab6e6e2c02d5b623c64793e25742244bec55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f116ab6e6e2c02d5b623c64793e25742244bec55", "html_url": "https://github.com/rust-lang/rust/commit/f116ab6e6e2c02d5b623c64793e25742244bec55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f116ab6e6e2c02d5b623c64793e25742244bec55/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "html_url": "https://github.com/rust-lang/rust/commit/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3"}], "stats": {"total": 27, "additions": 13, "deletions": 14}, "files": [{"sha": "798cc52cea0cc5bc7be6764419a581cead90c029", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f116ab6e6e2c02d5b623c64793e25742244bec55/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f116ab6e6e2c02d5b623c64793e25742244bec55/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=f116ab6e6e2c02d5b623c64793e25742244bec55", "patch": "@@ -797,12 +797,6 @@ impl fmt::Display for Punct {\n /// REVIEW We should guarantee that `Ident` contains a valid identifier permitted by\n /// REVIEW the language and not a random unicode string, at least for a start.\n ///\n-/// REVIEW We need to support raw identifiers here (`r#ident`) or at least be future compatible\n-/// REVIEW with them. Currently they are supported using \"string typing\" - if string \"r#ident\" is\n-/// REVIEW passed to `Ident::new` it will be interpreted as a raw identifier later on, we should add\n-/// REVIEW a field `is_raw` and a separate constructor for it (`Ident::new_raw` or something) and\n-/// REVIEW keep it unstable until raw identifiers are stabilized.\n-///\n /// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n /// REVIEW Do we want to guarantee `Ident` to be `Copy`?\n #[derive(Copy, Clone, Debug)]\n@@ -811,6 +805,7 @@ pub struct Ident {\n     // REVIEW(INTERNAL) Symbol + Span is actually `ast::Ident`! We can use it here.\n     sym: Symbol,\n     span: Span,\n+    is_raw: bool,\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -844,9 +839,18 @@ impl Ident {\n         Ident {\n             sym: Symbol::intern(string),\n             span,\n+            is_raw: false,\n         }\n     }\n \n+    /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn new_raw(string: &str, span: Span) -> Ident {\n+        let mut ident = Ident::new(string, span);\n+        ident.is_raw = true;\n+        ident\n+    }\n+\n     // FIXME: Remove this, do not stabilize\n     /// Get a reference to the interned string.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -1230,7 +1234,7 @@ impl TokenTree {\n                 tt!(self::Ident::new(&ident.name.as_str(), Span(span)))\n             }\n             Ident(ident, true) => {\n-                tt!(self::Ident::new(&format!(\"r#{}\", ident), Span(span)))\n+                tt!(self::Ident::new_raw(&ident.name.as_str(), Span(span)))\n             }\n             Literal(lit, suffix) => tt!(self::Literal { lit, suffix, span: Span(span) }),\n             DocComment(c) => {\n@@ -1275,15 +1279,10 @@ impl TokenTree {\n             },\n             self::TokenTree::Ident(tt) => {\n                 let ident = ast::Ident::new(tt.sym, tt.span.0);\n-                let sym_str = tt.sym.to_string();\n-                let token = if sym_str.starts_with(\"'\") {\n+                let token = if tt.sym.as_str().starts_with(\"'\") {\n                     Lifetime(ident)\n-                } else if sym_str.starts_with(\"r#\") {\n-                    let name = Symbol::intern(&sym_str[2..]);\n-                    let ident = ast::Ident::new(name, ident.span);\n-                    Ident(ident, true)\n                 } else {\n-                    Ident(ident, false)\n+                    Ident(ident, tt.is_raw)\n                 };\n                 return TokenTree::Token(tt.span.0, token).into();\n             }"}]}