{"sha": "9ad8a1f46566ddcd705cc918863cee2946d8b946", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZDhhMWY0NjU2NmRkY2Q3MDVjYzkxODg2M2NlZTI5NDZkOGI5NDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-16T06:06:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-16T06:06:48Z"}, "message": "auto merge of #4973 : thestinger/rust/rt, r=brson", "tree": {"sha": "bdd554efe19e59236431f0d3c339355188ba20b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd554efe19e59236431f0d3c339355188ba20b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ad8a1f46566ddcd705cc918863cee2946d8b946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad8a1f46566ddcd705cc918863cee2946d8b946", "html_url": "https://github.com/rust-lang/rust/commit/9ad8a1f46566ddcd705cc918863cee2946d8b946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ad8a1f46566ddcd705cc918863cee2946d8b946/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "354da4108a483ece3b6424ea7d92e3b6e91d4239", "url": "https://api.github.com/repos/rust-lang/rust/commits/354da4108a483ece3b6424ea7d92e3b6e91d4239", "html_url": "https://github.com/rust-lang/rust/commit/354da4108a483ece3b6424ea7d92e3b6e91d4239"}, {"sha": "f34dd565d9316e1a0241512d9c2527ae05d1975e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f34dd565d9316e1a0241512d9c2527ae05d1975e", "html_url": "https://github.com/rust-lang/rust/commit/f34dd565d9316e1a0241512d9c2527ae05d1975e"}], "stats": {"total": 1256, "additions": 0, "deletions": 1256}, "files": [{"sha": "3d3ce7562b5ed2ace3441ac3935c3fdd2fd1d75d", "filename": "src/rt/rust_globals.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ad8a1f46566ddcd705cc918863cee2946d8b946/src%2Frt%2Frust_globals.h", "raw_url": "https://github.com/rust-lang/rust/raw/9ad8a1f46566ddcd705cc918863cee2946d8b946/src%2Frt%2Frust_globals.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_globals.h?ref=9ad8a1f46566ddcd705cc918863cee2946d8b946", "patch": "@@ -37,8 +37,6 @@\n #include <math.h>\n #include <assert.h>\n \n-#include \"uthash.h\"\n-\n #if defined(__WIN32__)\n extern \"C\" {\n #include <windows.h>"}, {"sha": "ec0515faeafc030d0153accbce981bf4ac823ba1", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ad8a1f46566ddcd705cc918863cee2946d8b946/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/9ad8a1f46566ddcd705cc918863cee2946d8b946/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=9ad8a1f46566ddcd705cc918863cee2946d8b946", "patch": "@@ -49,7 +49,6 @@\n #include \"rust_log.h\"\n #include \"rust_sched_reaper.h\"\n #include \"rust_type.h\"\n-#include \"util/hash_map.h\"\n #include \"sync/lock_and_signal.h\"\n \n class rust_scheduler;"}, {"sha": "28021b61611910dd28fd7650936c7a651f5fa457", "filename": "src/rt/uthash/uthash.h", "status": "removed", "additions": 0, "deletions": 766, "changes": 766, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Frt%2Futhash%2Futhash.h", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Frt%2Futhash%2Futhash.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futhash%2Futhash.h?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -1,766 +0,0 @@\n-/*\n-Copyright (c) 2003-2009, Troy D. Hanson     http://uthash.sourceforge.net\n-All rights reserved.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are met:\n-\n-    * Redistributions of source code must retain the above copyright\n-      notice, this list of conditions and the following disclaimer.\n-\n-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n-IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n-TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n-PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER\n-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#ifndef UTHASH_H\n-#define UTHASH_H \n-\n-#include <string.h>   /* memcmp,strlen */\n-#include <stddef.h>   /* ptrdiff_t */\n-#include <inttypes.h> /* uint32_t etc */\n-\n-#define UTHASH_VERSION 1.6\n-\n-/* C++ requires extra stringent casting */\n-#if defined __cplusplus\n-#define TYPEOF(x) (typeof(x))\n-#else\n-#define TYPEOF(x)\n-#endif\n-\n-\n-#define uthash_fatal(msg) exit(-1)        /* fatal error (out of memory,etc) */\n-#define uthash_bkt_malloc(sz) malloc(sz)  /* malloc fcn for UT_hash_bucket's */\n-#define uthash_bkt_free(ptr) free(ptr)    /* free fcn for UT_hash_bucket's   */\n-#define uthash_tbl_malloc(sz) malloc(sz)  /* malloc fcn for UT_hash_table    */\n-#define uthash_tbl_free(ptr) free(ptr)    /* free fcn for UT_hash_table      */\n-\n-#define uthash_noexpand_fyi(tbl)          /* can be defined to log noexpand  */\n-#define uthash_expand_fyi(tbl)            /* can be defined to log expands   */\n-\n-/* initial number of buckets */\n-#define HASH_INITIAL_NUM_BUCKETS 32      /* initial number of buckets        */\n-#define HASH_INITIAL_NUM_BUCKETS_LOG2 5  /* lg2 of initial number of buckets */\n-#define HASH_BKT_CAPACITY_THRESH 10      /* expand when bucket count reaches */\n-\n-/* calculate the element whose hash handle address is hhe */\n-#define ELMT_FROM_HH(tbl,hhp) ((void*)(((char*)hhp) - (tbl)->hho))\n-\n-#define HASH_FIND(hh,head,keyptr,keylen,out)                                   \\\n-do {                                                                           \\\n-  unsigned _hf_bkt,_hf_hashv;                                                  \\\n-  out=TYPEOF(out)head;                                                         \\\n-  if (head) {                                                                  \\\n-     HASH_FCN(keyptr,keylen, (head)->hh.tbl->num_buckets, _hf_hashv, _hf_bkt); \\\n-     HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[ _hf_bkt ],  \\\n-                      keyptr,keylen,out);                                      \\\n-  }                                                                            \\\n-} while (0)\n-\n-#define HASH_MAKE_TABLE(hh,head)                                               \\\n-do {                                                                           \\\n-  (head)->hh.tbl = (UT_hash_table*)uthash_tbl_malloc(                          \\\n-                  sizeof(UT_hash_table));                                      \\\n-  if (!((head)->hh.tbl))  { uthash_fatal( \"out of memory\"); }                  \\\n-  memset((head)->hh.tbl, 0, sizeof(UT_hash_table));                            \\\n-  (head)->hh.tbl->tail = &((head)->hh);                                        \\\n-  (head)->hh.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS;                      \\\n-  (head)->hh.tbl->log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2;            \\\n-  (head)->hh.tbl->hho = (char*)(&(head)->hh) - (char*)(head);                  \\\n-  (head)->hh.tbl->buckets = (UT_hash_bucket*)uthash_bkt_malloc(                \\\n-          HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));             \\\n-  if (! (head)->hh.tbl->buckets) { uthash_fatal( \"out of memory\"); }           \\\n-  memset((head)->hh.tbl->buckets, 0,                                           \\\n-          HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));             \\\n-} while(0)\n-\n-#define HASH_ADD(hh,head,fieldname,keylen_in,add)                              \\\n-        HASH_ADD_KEYPTR(hh,head,&add->fieldname,keylen_in,add)\n- \n-#define HASH_ADD_KEYPTR(hh,head,keyptr,keylen_in,add)                          \\\n-do {                                                                           \\\n- unsigned _ha_bkt;                                                             \\\n- (add)->hh.next = NULL;                                                        \\\n- (add)->hh.key = (char*)keyptr;                                                \\\n- (add)->hh.keylen = keylen_in;                                                 \\\n- if (!(head)) {                                                                \\\n-    head = (add);                                                              \\\n-    (head)->hh.prev = NULL;                                                    \\\n-    HASH_MAKE_TABLE(hh,head);                                                  \\\n- } else {                                                                      \\\n-    (head)->hh.tbl->tail->next = (add);                                        \\\n-    (add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail);       \\\n-    (head)->hh.tbl->tail = &((add)->hh);                                       \\\n- }                                                                             \\\n- (head)->hh.tbl->num_items++;                                                  \\\n- (add)->hh.tbl = (head)->hh.tbl;                                               \\\n- HASH_FCN(keyptr,keylen_in, (head)->hh.tbl->num_buckets,                       \\\n-         (add)->hh.hashv, _ha_bkt);                                            \\\n- HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt],&(add)->hh);                 \\\n- HASH_EMIT_KEY(hh,head,keyptr,keylen_in);                                      \\\n- HASH_FSCK(hh,head);                                                           \\\n-} while(0)\n-\n-#define HASH_TO_BKT( hashv, num_bkts, bkt )                                    \\\n-do {                                                                           \\\n-  bkt = ((hashv) & ((num_bkts) - 1));                                          \\\n-} while(0)\n-\n-/* delete \"delptr\" from the hash table.\n- * \"the usual\" patch-up process for the app-order doubly-linked-list.\n- * The use of _hd_hh_del below deserves special explanation.\n- * These used to be expressed using (delptr) but that led to a bug\n- * if someone used the same symbol for the head and deletee, like\n- *  HASH_DELETE(hh,users,users);\n- * We want that to work, but by changing the head (users) below\n- * we were forfeiting our ability to further refer to the deletee (users)\n- * in the patch-up process. Solution: use scratch space in the table to\n- * copy the deletee pointer, then the latter references are via that\n- * scratch pointer rather than through the repointed (users) symbol.\n- */\n-#define HASH_DELETE(hh,head,delptr)                                            \\\n-do {                                                                           \\\n-    unsigned _hd_bkt;                                                          \\\n-    struct UT_hash_handle *_hd_hh_del;                                         \\\n-    if ( ((delptr)->hh.prev == NULL) && ((delptr)->hh.next == NULL) )  {       \\\n-        uthash_bkt_free((head)->hh.tbl->buckets );                             \\\n-        uthash_tbl_free((head)->hh.tbl);                                       \\\n-        head = NULL;                                                           \\\n-    } else {                                                                   \\\n-        _hd_hh_del = &((delptr)->hh);                                          \\\n-        if ((delptr) == ELMT_FROM_HH((head)->hh.tbl,(head)->hh.tbl->tail)) {   \\\n-            (head)->hh.tbl->tail =                                             \\\n-                (UT_hash_handle*)((char*)((delptr)->hh.prev) +                 \\\n-                (head)->hh.tbl->hho);                                          \\\n-        }                                                                      \\\n-        if ((delptr)->hh.prev) {                                               \\\n-            ((UT_hash_handle*)((char*)((delptr)->hh.prev) +                    \\\n-                    (head)->hh.tbl->hho))->next = (delptr)->hh.next;           \\\n-        } else {                                                               \\\n-            head = TYPEOF(head)((delptr)->hh.next);                            \\\n-        }                                                                      \\\n-        if (_hd_hh_del->next) {                                                \\\n-            ((UT_hash_handle*)((char*)_hd_hh_del->next +                       \\\n-                    (head)->hh.tbl->hho))->prev =                              \\\n-                    _hd_hh_del->prev;                                          \\\n-        }                                                                      \\\n-        HASH_TO_BKT( _hd_hh_del->hashv, (head)->hh.tbl->num_buckets, _hd_bkt); \\\n-        HASH_DEL_IN_BKT(hh,(head)->hh.tbl->buckets[_hd_bkt], _hd_hh_del);      \\\n-        (head)->hh.tbl->num_items--;                                           \\\n-    }                                                                          \\\n-    HASH_FSCK(hh,head);                                                        \\\n-} while (0)\n-\n-\n-/* convenience forms of HASH_FIND/HASH_ADD/HASH_DEL */\n-#define HASH_FIND_STR(head,findstr,out)                                        \\\n-    HASH_FIND(hh,head,findstr,strlen(findstr),out)\n-#define HASH_ADD_STR(head,strfield,add)                                        \\\n-    HASH_ADD(hh,head,strfield,strlen(add->strfield),add)\n-#define HASH_FIND_INT(head,findint,out)                                        \\\n-    HASH_FIND(hh,head,findint,sizeof(int),out)\n-#define HASH_ADD_INT(head,intfield,add)                                        \\\n-    HASH_ADD(hh,head,intfield,sizeof(int),add)\n-#define HASH_DEL(head,delptr)                                                  \\\n-    HASH_DELETE(hh,head,delptr)\n-\n-/* HASH_FSCK checks hash integrity on every add/delete when HASH_DEBUG is defined.\n- * This is for uthash developer only; it compiles away if HASH_DEBUG isn't defined.\n- */\n-#ifdef HASH_DEBUG\n-#define HASH_OOPS(...) do { fprintf(stderr,__VA_ARGS__); exit(-1); } while (0)\n-#define HASH_FSCK(hh,head)                                                     \\\n-do {                                                                           \\\n-    unsigned _bkt_i;                                                           \\\n-    unsigned _count, _bkt_count;                                               \\\n-    char *_prev;                                                               \\\n-    struct UT_hash_handle *_thh;                                               \\\n-    if (head) {                                                                \\\n-        _count = 0;                                                            \\\n-        for( _bkt_i = 0; _bkt_i < (head)->hh.tbl->num_buckets; _bkt_i++) {     \\\n-            _bkt_count = 0;                                                    \\\n-            _thh = (head)->hh.tbl->buckets[_bkt_i].hh_head;                    \\\n-            _prev = NULL;                                                      \\\n-            while (_thh) {                                                     \\\n-               if (_prev != (char*)(_thh->hh_prev)) {                          \\\n-                   HASH_OOPS(\"invalid hh_prev %p, actual %p\\n\",                \\\n-                    _thh->hh_prev, _prev );                                    \\\n-               }                                                               \\\n-               _bkt_count++;                                                   \\\n-               _prev = (char*)(_thh);                                          \\\n-               _thh = _thh->hh_next;                                           \\\n-            }                                                                  \\\n-            _count += _bkt_count;                                              \\\n-            if ((head)->hh.tbl->buckets[_bkt_i].count !=  _bkt_count) {        \\\n-               HASH_OOPS(\"invalid bucket count %d, actual %d\\n\",               \\\n-                (head)->hh.tbl->buckets[_bkt_i].count, _bkt_count);            \\\n-            }                                                                  \\\n-        }                                                                      \\\n-        if (_count != (head)->hh.tbl->num_items) {                             \\\n-            HASH_OOPS(\"invalid hh item count %d, actual %d\\n\",                 \\\n-                (head)->hh.tbl->num_items, _count );                           \\\n-        }                                                                      \\\n-        /* traverse hh in app order; check next/prev integrity, count */       \\\n-        _count = 0;                                                            \\\n-        _prev = NULL;                                                          \\\n-        _thh =  &(head)->hh;                                                   \\\n-        while (_thh) {                                                         \\\n-           _count++;                                                           \\\n-           if (_prev !=(char*)(_thh->prev)) {                                  \\\n-              HASH_OOPS(\"invalid prev %p, actual %p\\n\",                        \\\n-                    _thh->prev, _prev );                                       \\\n-           }                                                                   \\\n-           _prev = (char*)ELMT_FROM_HH((head)->hh.tbl, _thh);                  \\\n-           _thh = ( _thh->next ?  (UT_hash_handle*)((char*)(_thh->next) +      \\\n-                                  (head)->hh.tbl->hho) : NULL );               \\\n-        }                                                                      \\\n-        if (_count != (head)->hh.tbl->num_items) {                             \\\n-            HASH_OOPS(\"invalid app item count %d, actual %d\\n\",                \\\n-                (head)->hh.tbl->num_items, _count );                           \\\n-        }                                                                      \\\n-    }                                                                          \\\n-} while (0)\n-#else\n-#define HASH_FSCK(hh,head) \n-#endif\n-\n-/* When compiled with -DHASH_EMIT_KEYS, length-prefixed keys are emitted to \n- * the descriptor to which this macro is defined for tuning the hash function.\n- * The app can #include <unistd.h> to get the prototype for write(2). */\n-#ifdef HASH_EMIT_KEYS\n-#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)                                 \\\n-do {                                                                           \\\n-    unsigned _klen = fieldlen;                                                 \\\n-    write(HASH_EMIT_KEYS, &_klen, sizeof(_klen));                              \\\n-    write(HASH_EMIT_KEYS, keyptr, fieldlen);                                   \\\n-} while (0)\n-#else \n-#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)                    \n-#endif\n-\n-/* default to MurmurHash unless overridden e.g. DHASH_FUNCTION=HASH_SAX */\n-#ifdef HASH_FUNCTION \n-#define HASH_FCN HASH_FUNCTION\n-#else\n-#define HASH_FCN HASH_MUR\n-#endif\n-\n-/* The Bernstein hash function, used in Perl prior to v5.6 */\n-#define HASH_BER(key,keylen,num_bkts,hashv,bkt)                                \\\n-do {                                                                           \\\n-  unsigned _hb_keylen=keylen;                                                  \\\n-  char *_hb_key=(char*)key;                                                    \\\n-  (hashv) = 0;                                                                 \\\n-  while (_hb_keylen--)  { (hashv) = ((hashv) * 33) + *_hb_key++; }             \\\n-  bkt = (hashv) & (num_bkts-1);                                                \\\n-} while (0)\n-\n-\n-/* SAX/FNV/OAT/JEN hash functions are macro variants of those listed at \n- * http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx */\n-#define HASH_SAX(key,keylen,num_bkts,hashv,bkt)                                \\\n-do {                                                                           \\\n-  unsigned _sx_i;                                                              \\\n-  char *_hs_key=(char*)key;                                                    \\\n-  hashv = 0;                                                                   \\\n-  for(_sx_i=0; _sx_i < keylen; _sx_i++)                                        \\\n-      hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i];                   \\\n-  bkt = hashv & (num_bkts-1);                                                  \\\n-} while (0)\n-\n-#define HASH_FNV(key,keylen,num_bkts,hashv,bkt)                                \\\n-do {                                                                           \\\n-  unsigned _fn_i;                                                              \\\n-  char *_hf_key=(char*)key;                                                    \\\n-  hashv = 2166136261UL;                                                        \\\n-  for(_fn_i=0; _fn_i < keylen; _fn_i++)                                        \\\n-      hashv = (hashv * 16777619) ^ _hf_key[_fn_i];                             \\\n-  bkt = hashv & (num_bkts-1);                                                  \\\n-} while(0);\n- \n-#define HASH_OAT(key,keylen,num_bkts,hashv,bkt)                                \\\n-do {                                                                           \\\n-  unsigned _ho_i;                                                              \\\n-  char *_ho_key=(char*)key;                                                    \\\n-  hashv = 0;                                                                   \\\n-  for(_ho_i=0; _ho_i < keylen; _ho_i++) {                                      \\\n-      hashv += _ho_key[_ho_i];                                                 \\\n-      hashv += (hashv << 10);                                                  \\\n-      hashv ^= (hashv >> 6);                                                   \\\n-  }                                                                            \\\n-  hashv += (hashv << 3);                                                       \\\n-  hashv ^= (hashv >> 11);                                                      \\\n-  hashv += (hashv << 15);                                                      \\\n-  bkt = hashv & (num_bkts-1);                                                  \\\n-} while(0)\n-\n-#define HASH_JEN_MIX(a,b,c)                                                    \\\n-do {                                                                           \\\n-  a -= b; a -= c; a ^= ( c >> 13 );                                            \\\n-  b -= c; b -= a; b ^= ( a << 8 );                                             \\\n-  c -= a; c -= b; c ^= ( b >> 13 );                                            \\\n-  a -= b; a -= c; a ^= ( c >> 12 );                                            \\\n-  b -= c; b -= a; b ^= ( a << 16 );                                            \\\n-  c -= a; c -= b; c ^= ( b >> 5 );                                             \\\n-  a -= b; a -= c; a ^= ( c >> 3 );                                             \\\n-  b -= c; b -= a; b ^= ( a << 10 );                                            \\\n-  c -= a; c -= b; c ^= ( b >> 15 );                                            \\\n-} while (0)\n-\n-#define HASH_JEN(key,keylen,num_bkts,hashv,bkt)                                \\\n-do {                                                                           \\\n-  unsigned _hj_i,_hj_j,_hj_k;                                                  \\\n-  char *_hj_key=(char*)key;                                                    \\\n-  hashv = 0xfeedbeef;                                                          \\\n-  _hj_i = _hj_j = 0x9e3779b9;                                                  \\\n-  _hj_k = keylen;                                                              \\\n-  while (_hj_k >= 12) {                                                        \\\n-    _hj_i +=    (_hj_key[0] + ( (unsigned)_hj_key[1] << 8 )                    \\\n-        + ( (unsigned)_hj_key[2] << 16 )                                       \\\n-        + ( (unsigned)_hj_key[3] << 24 ) );                                    \\\n-    _hj_j +=    (_hj_key[4] + ( (unsigned)_hj_key[5] << 8 )                    \\\n-        + ( (unsigned)_hj_key[6] << 16 )                                       \\\n-        + ( (unsigned)_hj_key[7] << 24 ) );                                    \\\n-    hashv += (_hj_key[8] + ( (unsigned)_hj_key[9] << 8 )                       \\\n-        + ( (unsigned)_hj_key[10] << 16 )                                      \\\n-        + ( (unsigned)_hj_key[11] << 24 ) );                                   \\\n-                                                                               \\\n-     HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                        \\\n-                                                                               \\\n-     _hj_key += 12;                                                            \\\n-     _hj_k -= 12;                                                              \\\n-  }                                                                            \\\n-  hashv += keylen;                                                             \\\n-  switch ( _hj_k ) {                                                           \\\n-     case 11: hashv += ( (unsigned)_hj_key[10] << 24 );                        \\\n-     case 10: hashv += ( (unsigned)_hj_key[9] << 16 );                         \\\n-     case 9:  hashv += ( (unsigned)_hj_key[8] << 8 );                          \\\n-     case 8:  _hj_j += ( (unsigned)_hj_key[7] << 24 );                         \\\n-     case 7:  _hj_j += ( (unsigned)_hj_key[6] << 16 );                         \\\n-     case 6:  _hj_j += ( (unsigned)_hj_key[5] << 8 );                          \\\n-     case 5:  _hj_j += _hj_key[4];                                             \\\n-     case 4:  _hj_i += ( (unsigned)_hj_key[3] << 24 );                         \\\n-     case 3:  _hj_i += ( (unsigned)_hj_key[2] << 16 );                         \\\n-     case 2:  _hj_i += ( (unsigned)_hj_key[1] << 8 );                          \\\n-     case 1:  _hj_i += _hj_key[0];                                             \\\n-  }                                                                            \\\n-  HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                           \\\n-  bkt = hashv & (num_bkts-1);                                                  \\\n-} while(0)\n-\n-/* The Paul Hsieh hash function */\n-#undef get16bits\n-#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__)           \\\n-  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)\n-#define get16bits(d) (*((const uint16_t *) (d)))\n-#endif\n-\n-#if !defined (get16bits)\n-#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\\\n-                       +(uint32_t)(((const uint8_t *)(d))[0]) )\n-#endif\n-#define HASH_SFH(key,keylen,num_bkts,hashv,bkt)                                \\\n-do {                                                                           \\\n-  char *_sfh_key=(char*)key;                                                   \\\n-  hashv = 0xcafebabe;                                                          \\\n-  uint32_t _sfh_tmp, _sfh_len = keylen;                                        \\\n-                                                                               \\\n-  int _sfh_rem = _sfh_len & 3;                                                 \\\n-  _sfh_len >>= 2;                                                              \\\n-                                                                               \\\n-  /* Main loop */                                                              \\\n-  for (;_sfh_len > 0; _sfh_len--) {                                            \\\n-    hashv    += get16bits (_sfh_key);                                          \\\n-    _sfh_tmp       = (get16bits (_sfh_key+2) << 11) ^ hashv;                   \\\n-    hashv     = (hashv << 16) ^ _sfh_tmp;                                      \\\n-    _sfh_key += 2*sizeof (uint16_t);                                           \\\n-    hashv    += hashv >> 11;                                                   \\\n-  }                                                                            \\\n-                                                                               \\\n-  /* Handle end cases */                                                       \\\n-  switch (_sfh_rem) {                                                          \\\n-    case 3: hashv += get16bits (_sfh_key);                                     \\\n-            hashv ^= hashv << 16;                                              \\\n-            hashv ^= _sfh_key[sizeof (uint16_t)] << 18;                        \\\n-            hashv += hashv >> 11;                                              \\\n-            break;                                                             \\\n-    case 2: hashv += get16bits (_sfh_key);                                     \\\n-            hashv ^= hashv << 11;                                              \\\n-            hashv += hashv >> 17;                                              \\\n-            break;                                                             \\\n-    case 1: hashv += *_sfh_key;                                                \\\n-            hashv ^= hashv << 10;                                              \\\n-            hashv += hashv >> 1;                                               \\\n-  }                                                                            \\\n-                                                                               \\\n-    /* Force \"avalanching\" of final 127 bits */                                \\\n-    hashv ^= hashv << 3;                                                       \\\n-    hashv += hashv >> 5;                                                       \\\n-    hashv ^= hashv << 4;                                                       \\\n-    hashv += hashv >> 17;                                                      \\\n-    hashv ^= hashv << 25;                                                      \\\n-    hashv += hashv >> 6;                                                       \\\n-    bkt = hashv & (num_bkts-1);                                                \\\n-} while(0);\n-\n-/* Austin Appleby's MurmurHash */\n-#define HASH_MUR(key,keylen,num_bkts,hashv,bkt)                                \\\n-do {                                                                           \\\n-  const unsigned int _mur_m = 0x5bd1e995;                                      \\\n-  const int _mur_r = 24;                                                       \\\n-  hashv = 0xcafebabe ^ keylen;                                                 \\\n-  char *_mur_key = (char *)key;                                                \\\n-  uint32_t _mur_tmp, _mur_len = keylen;                                        \\\n-                                                                               \\\n-  for (;_mur_len >= 4; _mur_len-=4) {                                          \\\n-    _mur_tmp = *(uint32_t *)_mur_key;                                          \\\n-    _mur_tmp *= _mur_m;                                                        \\\n-    _mur_tmp ^= _mur_tmp >> _mur_r;                                            \\\n-    _mur_tmp *= _mur_m;                                                        \\\n-    hashv *= _mur_m;                                                           \\\n-    hashv ^= _mur_tmp;                                                         \\\n-    _mur_key += 4;                                                             \\\n-  }                                                                            \\\n-                                                                               \\\n-  switch(_mur_len)                                                             \\\n-  {                                                                            \\\n-    case 3: hashv ^= _mur_key[2] << 16;                                        \\\n-    case 2: hashv ^= _mur_key[1] << 8;                                         \\\n-    case 1: hashv ^= _mur_key[0];                                              \\\n-            hashv *= _mur_m;                                                   \\\n-  };                                                                           \\\n-                                                                               \\\n-  hashv ^= hashv >> 13;                                                        \\\n-  hashv *= _mur_m;                                                             \\\n-  hashv ^= hashv >> 15;                                                        \\\n-                                                                               \\\n-  bkt = hashv & (num_bkts-1);                                                  \\\n-} while(0)\n-\n-/* key comparison function; return 0 if keys equal */\n-#define HASH_KEYCMP(a,b,len) memcmp(a,b,len) \n-\n-/* iterate over items in a known bucket to find desired item */\n-#define HASH_FIND_IN_BKT(tbl,hh,head,keyptr,keylen_in,out)                     \\\n-out = TYPEOF(out)((head.hh_head) ? ELMT_FROM_HH(tbl,head.hh_head) : NULL);     \\\n-while (out) {                                                                  \\\n-    if (out->hh.keylen == keylen_in) {                                         \\\n-        if ((HASH_KEYCMP(out->hh.key,keyptr,keylen_in)) == 0) break;           \\\n-    }                                                                          \\\n-    out= TYPEOF(out)((out->hh.hh_next) ?                                       \\\n-                     ELMT_FROM_HH(tbl,out->hh.hh_next) : NULL);                \\\n-}\n-\n-/* add an item to a bucket  */\n-#define HASH_ADD_TO_BKT(head,addhh)                                            \\\n-do {                                                                           \\\n- head.count++;                                                                 \\\n- (addhh)->hh_next = head.hh_head;                                              \\\n- (addhh)->hh_prev = NULL;                                                      \\\n- if (head.hh_head) { (head).hh_head->hh_prev = (addhh); }                      \\\n- (head).hh_head=addhh;                                                         \\\n- if (head.count >= ((head.expand_mult+1) * HASH_BKT_CAPACITY_THRESH)           \\\n-     && (addhh)->tbl->noexpand != 1) {                                         \\\n-       HASH_EXPAND_BUCKETS((addhh)->tbl);                                      \\\n- }                                                                             \\\n-} while(0)\n-\n-/* remove an item from a given bucket */\n-#define HASH_DEL_IN_BKT(hh,head,hh_del)                                        \\\n-    (head).count--;                                                            \\\n-    if ((head).hh_head == hh_del) {                                            \\\n-      (head).hh_head = hh_del->hh_next;                                        \\\n-    }                                                                          \\\n-    if (hh_del->hh_prev) {                                                     \\\n-        hh_del->hh_prev->hh_next = hh_del->hh_next;                            \\\n-    }                                                                          \\\n-    if (hh_del->hh_next) {                                                     \\\n-        hh_del->hh_next->hh_prev = hh_del->hh_prev;                            \\\n-    }                                                                \n-\n-/* Bucket expansion has the effect of doubling the number of buckets\n- * and redistributing the items into the new buckets. Ideally the\n- * items will distribute more or less evenly into the new buckets\n- * (the extent to which this is true is a measure of the quality of\n- * the hash function as it applies to the key domain). \n- * \n- * With the items distributed into more buckets, the chain length\n- * (item count) in each bucket is reduced. Thus by expanding buckets\n- * the hash keeps a bound on the chain length. This bounded chain \n- * length is the essence of how a hash provides constant time lookup.\n- * \n- * The calculation of tbl->ideal_chain_maxlen below deserves some\n- * explanation. First, keep in mind that we're calculating the ideal\n- * maximum chain length based on the *new* (doubled) bucket count.\n- * In fractions this is just n/b (n=number of items,b=new num buckets).\n- * Since the ideal chain length is an integer, we want to calculate \n- * ceil(n/b). We don't depend on floating point arithmetic in this\n- * hash, so to calculate ceil(n/b) with integers we could write\n- * \n- *      ceil(n/b) = (n/b) + ((n%b)?1:0)\n- * \n- * and in fact a previous version of this hash did just that.\n- * But now we have improved things a bit by recognizing that b is\n- * always a power of two. We keep its base 2 log handy (call it lb),\n- * so now we can write this with a bit shift and logical AND:\n- * \n- *      ceil(n/b) = (n>>lb) + ( (n & (b-1)) ? 1:0)\n- * \n- */\n-#define HASH_EXPAND_BUCKETS(tbl)                                               \\\n-do {                                                                           \\\n-    unsigned _he_bkt;                                                          \\\n-    unsigned _he_bkt_i;                                                        \\\n-    struct UT_hash_handle *_he_thh, *_he_hh_nxt;                               \\\n-    UT_hash_bucket *_he_new_buckets, *_he_newbkt;                              \\\n-    _he_new_buckets = (UT_hash_bucket*)uthash_bkt_malloc(                      \\\n-             2 * tbl->num_buckets * sizeof(struct UT_hash_bucket));            \\\n-    if (!_he_new_buckets) { uthash_fatal( \"out of memory\"); }                  \\\n-    memset(_he_new_buckets, 0,                                                 \\\n-            2 * tbl->num_buckets * sizeof(struct UT_hash_bucket));             \\\n-    tbl->ideal_chain_maxlen =                                                  \\\n-       (tbl->num_items >> (tbl->log2_num_buckets+1)) +                         \\\n-       ((tbl->num_items & ((tbl->num_buckets*2)-1)) ? 1 : 0);                  \\\n-    tbl->nonideal_items = 0;                                                   \\\n-    for(_he_bkt_i = 0; _he_bkt_i < tbl->num_buckets; _he_bkt_i++)              \\\n-    {                                                                          \\\n-        _he_thh = tbl->buckets[ _he_bkt_i ].hh_head;                           \\\n-        while (_he_thh) {                                                      \\\n-           _he_hh_nxt = _he_thh->hh_next;                                      \\\n-           HASH_TO_BKT( _he_thh->hashv, tbl->num_buckets*2, _he_bkt);          \\\n-           _he_newbkt = &(_he_new_buckets[ _he_bkt ]);                         \\\n-           if (++(_he_newbkt->count) > tbl->ideal_chain_maxlen) {              \\\n-             tbl->nonideal_items++;                                            \\\n-             _he_newbkt->expand_mult = _he_newbkt->count /                     \\\n-                                        tbl->ideal_chain_maxlen;               \\\n-           }                                                                   \\\n-           _he_thh->hh_prev = NULL;                                            \\\n-           _he_thh->hh_next = _he_newbkt->hh_head;                             \\\n-           if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev =             \\\n-                _he_thh;                                                       \\\n-           _he_newbkt->hh_head = _he_thh;                                      \\\n-           _he_thh = _he_hh_nxt;                                               \\\n-        }                                                                      \\\n-    }                                                                          \\\n-    tbl->num_buckets *= 2;                                                     \\\n-    tbl->log2_num_buckets++;                                                   \\\n-    uthash_bkt_free( tbl->buckets );                                           \\\n-    tbl->buckets = _he_new_buckets;                                            \\\n-    tbl->ineff_expands = (tbl->nonideal_items > (tbl->num_items >> 1)) ?       \\\n-        (tbl->ineff_expands+1) : 0;                                            \\\n-    if (tbl->ineff_expands > 1) {                                              \\\n-        tbl->noexpand=1;                                                       \\\n-        uthash_noexpand_fyi(tbl);                                              \\\n-    }                                                                          \\\n-    uthash_expand_fyi(tbl);                                                    \\\n-} while(0)\n-\n-\n-/* This is an adaptation of Simon Tatham's O(n log(n)) mergesort */\n-/* Note that HASH_SORT assumes the hash handle name to be hh. \n- * HASH_SRT was added to allow the hash handle name to be passed in. */\n-#define HASH_SORT(head,cmpfcn) HASH_SRT(hh,head,cmpfcn)\n-#define HASH_SRT(hh,head,cmpfcn)                                               \\\n-do {                                                                           \\\n-  unsigned _hs_i;                                                              \\\n-  unsigned _hs_looping,_hs_nmerges,_hs_insize,_hs_psize,_hs_qsize;             \\\n-  struct UT_hash_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail;          \\\n-  if (head) {                                                                  \\\n-      _hs_insize = 1;                                                          \\\n-      _hs_looping = 1;                                                         \\\n-      _hs_list = &((head)->hh);                                                \\\n-      while (_hs_looping) {                                                    \\\n-          _hs_p = _hs_list;                                                    \\\n-          _hs_list = NULL;                                                     \\\n-          _hs_tail = NULL;                                                     \\\n-          _hs_nmerges = 0;                                                     \\\n-          while (_hs_p) {                                                      \\\n-              _hs_nmerges++;                                                   \\\n-              _hs_q = _hs_p;                                                   \\\n-              _hs_psize = 0;                                                   \\\n-              for ( _hs_i = 0; _hs_i  < _hs_insize; _hs_i++ ) {                \\\n-                  _hs_psize++;                                                 \\\n-                  _hs_q = (UT_hash_handle*)((_hs_q->next) ?                    \\\n-                          ((void*)((char*)(_hs_q->next) +                      \\\n-                          (head)->hh.tbl->hho)) : NULL);                       \\\n-                  if (! (_hs_q) ) break;                                       \\\n-              }                                                                \\\n-              _hs_qsize = _hs_insize;                                          \\\n-              while ((_hs_psize > 0) || ((_hs_qsize > 0) && _hs_q )) {         \\\n-                  if (_hs_psize == 0) {                                        \\\n-                      _hs_e = _hs_q;                                           \\\n-                      _hs_q = (UT_hash_handle*)((_hs_q->next) ?                \\\n-                              ((void*)((char*)(_hs_q->next) +                  \\\n-                              (head)->hh.tbl->hho)) : NULL);                   \\\n-                      _hs_qsize--;                                             \\\n-                  } else if ( (_hs_qsize == 0) || !(_hs_q) ) {                 \\\n-                      _hs_e = _hs_p;                                           \\\n-                      _hs_p = (UT_hash_handle*)((_hs_p->next) ?                \\\n-                              ((void*)((char*)(_hs_p->next) +                  \\\n-                              (head)->hh.tbl->hho)) : NULL);                   \\\n-                      _hs_psize--;                                             \\\n-                  } else if ((                                                 \\\n-                      cmpfcn(TYPEOF(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_p)), \\\n-                            TYPEOF(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_q)))  \\\n-                             ) <= 0) {                                         \\\n-                      _hs_e = _hs_p;                                           \\\n-                      _hs_p = (UT_hash_handle*)((_hs_p->next) ?                \\\n-                              ((void*)((char*)(_hs_p->next) +                  \\\n-                              (head)->hh.tbl->hho)) : NULL);                   \\\n-                      _hs_psize--;                                             \\\n-                  } else {                                                     \\\n-                      _hs_e = _hs_q;                                           \\\n-                      _hs_q = (UT_hash_handle*)((_hs_q->next) ?                \\\n-                              ((void*)((char*)(_hs_q->next) +                  \\\n-                              (head)->hh.tbl->hho)) : NULL);                   \\\n-                      _hs_qsize--;                                             \\\n-                  }                                                            \\\n-                  if ( _hs_tail ) {                                            \\\n-                      _hs_tail->next = ((_hs_e) ?                              \\\n-                            ELMT_FROM_HH((head)->hh.tbl,_hs_e) : NULL);        \\\n-                  } else {                                                     \\\n-                      _hs_list = _hs_e;                                        \\\n-                  }                                                            \\\n-                  _hs_e->prev = ((_hs_tail) ?                                  \\\n-                     ELMT_FROM_HH((head)->hh.tbl,_hs_tail) : NULL);            \\\n-                  _hs_tail = _hs_e;                                            \\\n-              }                                                                \\\n-              _hs_p = _hs_q;                                                   \\\n-          }                                                                    \\\n-          _hs_tail->next = NULL;                                               \\\n-          if ( _hs_nmerges <= 1 ) {                                            \\\n-              _hs_looping=0;                                                   \\\n-              (head)->hh.tbl->tail = _hs_tail;                                 \\\n-              (head) = TYPEOF(head)ELMT_FROM_HH((head)->hh.tbl, _hs_list);     \\\n-          }                                                                    \\\n-          _hs_insize *= 2;                                                     \\\n-      }                                                                        \\\n-      HASH_FSCK(hh,head);                                                      \\\n- }                                                                             \\\n-} while (0)\n-\n-/* This function selects items from one hash into another hash. \n- * The end result is that the selected items have dual presence \n- * in both hashes. There is no copy of the items made; rather \n- * they are added into the new hash through a secondary hash \n- * hash handle that must be present in the structure. */\n-#define HASH_SELECT(hh_dst, dst, hh_src, src, cond)                            \\\n-do {                                                                           \\\n-  unsigned _src_bkt, _dst_bkt;                                                 \\\n-  void *_last_elt=NULL, *_elt;                                                 \\\n-  UT_hash_handle *_src_hh, *_dst_hh, *_last_elt_hh=NULL;                       \\\n-  ptrdiff_t _dst_hho = ((char*)(&(dst)->hh_dst) - (char*)(dst));               \\\n-  if (src) {                                                                   \\\n-    for(_src_bkt=0; _src_bkt < (src)->hh_src.tbl->num_buckets; _src_bkt++) {   \\\n-      for(_src_hh = (src)->hh_src.tbl->buckets[_src_bkt].hh_head;              \\\n-          _src_hh;                                                             \\\n-          _src_hh = _src_hh->hh_next) {                                        \\\n-          _elt = ELMT_FROM_HH((src)->hh_src.tbl, _src_hh);                     \\\n-          if (cond(_elt)) {                                                    \\\n-            _dst_hh = (UT_hash_handle*)(((char*)_elt) + _dst_hho);             \\\n-            _dst_hh->key = _src_hh->key;                                       \\\n-            _dst_hh->keylen = _src_hh->keylen;                                 \\\n-            _dst_hh->hashv = _src_hh->hashv;                                   \\\n-            _dst_hh->prev = _last_elt;                                         \\\n-            _dst_hh->next = NULL;                                              \\\n-            if (_last_elt_hh) { _last_elt_hh->next = _elt; }                   \\\n-            if (!dst) {                                                        \\\n-              dst = TYPEOF(dst)_elt;                                           \\\n-              HASH_MAKE_TABLE(hh_dst,dst);                                     \\\n-            } else {                                                           \\\n-              _dst_hh->tbl = (dst)->hh_dst.tbl;                                \\\n-            }                                                                  \\\n-            HASH_TO_BKT(_dst_hh->hashv, _dst_hh->tbl->num_buckets, _dst_bkt);  \\\n-            HASH_ADD_TO_BKT(_dst_hh->tbl->buckets[_dst_bkt],_dst_hh);          \\\n-            (dst)->hh_dst.tbl->num_items++;                                    \\\n-            _last_elt = _elt;                                                  \\\n-            _last_elt_hh = _dst_hh;                                            \\\n-          }                                                                    \\\n-      }                                                                        \\\n-    }                                                                          \\\n-  }                                                                            \\\n-  HASH_FSCK(hh_dst,dst);                                                       \\\n-} while (0)\n-\n-#define HASH_CLEAR(hh,head)                                                    \\\n-do {                                                                           \\\n-  if (head) {                                                                  \\\n-    uthash_bkt_free((head)->hh.tbl->buckets );                                 \\\n-    uthash_tbl_free((head)->hh.tbl);                                           \\\n-    (head)=NULL;                                                               \\\n-  }                                                                            \\\n-} while(0)\n-\n-/* obtain a count of items in the hash */\n-#define HASH_COUNT(head) HASH_CNT(hh,head) \n-#define HASH_CNT(hh,head) (head?(head->hh.tbl->num_items):0)\n-\n-typedef struct UT_hash_bucket {\n-   struct UT_hash_handle *hh_head;\n-   unsigned count;\n-\n-   /* expand_mult is normally set to 0. In this situation, the max chain length\n-    * threshold is enforced at its default value, HASH_BKT_CAPACITY_THRESH. (If\n-    * the bucket's chain exceeds this length, bucket expansion is triggered). \n-    * However, setting expand_mult to a non-zero value delays bucket expansion\n-    * (that would be triggered by additions to this particular bucket)\n-    * until its chain length reaches a *multiple* of HASH_BKT_CAPACITY_THRESH.\n-    * (The multiplier is simply expand_mult+1). The whole idea of this\n-    * multiplier is to reduce bucket expansions, since they are expensive, in\n-    * situations where we know that a particular bucket tends to be overused.\n-    * It is better to let its chain length grow to a longer yet-still-bounded\n-    * value, than to do an O(n) bucket expansion too often. \n-    */\n-   unsigned expand_mult;\n-\n-} UT_hash_bucket;\n-\n-typedef struct UT_hash_table {\n-   UT_hash_bucket *buckets;\n-   unsigned num_buckets, log2_num_buckets;\n-   unsigned num_items;\n-   struct UT_hash_handle *tail; /* tail hh in app order, for fast append    */\n-   ptrdiff_t hho; /* hash handle offset (byte pos of hash handle in element */\n-\n-   /* in an ideal situation (all buckets used equally), no bucket would have\n-    * more than ceil(#items/#buckets) items. that's the ideal chain length. */\n-   unsigned ideal_chain_maxlen;\n-\n-   /* nonideal_items is the number of items in the hash whose chain position\n-    * exceeds the ideal chain maxlen. these items pay the penalty for an uneven\n-    * hash distribution; reaching them in a chain traversal takes >ideal steps */\n-   unsigned nonideal_items;\n-\n-   /* ineffective expands occur when a bucket doubling was performed, but \n-    * afterward, more than half the items in the hash had nonideal chain\n-    * positions. If this happens on two consecutive expansions we inhibit any\n-    * further expansion, as it's not helping; this happens when the hash\n-    * function isn't a good fit for the key domain. When expansion is inhibited\n-    * the hash will still work, albeit no longer in constant time. */\n-   unsigned ineff_expands, noexpand;\n-\n-\n-} UT_hash_table;\n-\n-\n-typedef struct UT_hash_handle {\n-   struct UT_hash_table *tbl;\n-   void *prev;                       /* prev element in app order      */\n-   void *next;                       /* next element in app order      */\n-   struct UT_hash_handle *hh_prev;   /* previous hh in bucket order    */\n-   struct UT_hash_handle *hh_next;   /* next hh in bucket order        */\n-   void *key;                        /* ptr to enclosing struct's key  */\n-   unsigned keylen;                  /* enclosing struct's key len     */\n-   unsigned hashv;                   /* result of hash-fcn(key)        */\n-} UT_hash_handle;\n-\n-#endif /* UTHASH_H */"}, {"sha": "a33615e1ba05456850425423077b82a6043d1ef1", "filename": "src/rt/uthash/utlist.h", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Frt%2Futhash%2Futlist.h", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Frt%2Futhash%2Futlist.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futhash%2Futlist.h?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -1,280 +0,0 @@\n-/*\n-Copyright (c) 2007-2009, Troy D. Hanson\n-All rights reserved.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are met:\n-\n-    * Redistributions of source code must retain the above copyright\n-      notice, this list of conditions and the following disclaimer.\n-\n-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n-IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n-TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n-PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER\n-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#ifndef UTLIST_H\n-#define UTLIST_H\n-\n-#define UTLIST_VERSION 1.0\n-\n-/* C++ requires extra stringent casting */\n-#if defined __cplusplus\n-#define LTYPEOF(x) (typeof(x))\n-#else\n-#define LTYPEOF(x)\n-#endif\n-/* \n- * This file contains macros to manipulate singly and doubly-linked lists.\n- *\n- * 1. LL_ macros:  singly-linked lists.\n- * 2. DL_ macros:  doubly-linked lists.\n- * 3. CDL_ macros: circular doubly-linked lists.\n- *\n- * To use singly-linked lists, your structure must have a \"next\" pointer.\n- * To use doubly-linked lists, your structure must \"prev\" and \"next\" pointers.\n- * Either way, the pointer to the head of the list must be initialized to NULL.\n- * \n- * ----------------.EXAMPLE -------------------------\n- * struct item {\n- *      int id;\n- *      struct item *prev, *next;\n- * }\n- *\n- * struct item *list = NULL:\n- *\n- * int main() {\n- *      struct item *item;\n- *      ... allocate and populate item ...\n- *      DL_APPEND(list, item);\n- * }\n- * --------------------------------------------------\n- *\n- * For doubly-linked lists, the append and delete macros are O(1)\n- * For singly-linked lists, append and delete are O(n) but prepend is O(1)\n- * The sort macro is O(n log(n)) for all types of single/double/circular lists.\n- */\n-\n-/******************************************************************************\n- * The SORT macros                                                            *\n- *****************************************************************************/\n-#define LL_SORT(l,cmp)                                                           \\\n- LISTSORT(l,0,0,FIELD_OFFSET(l,next),cmp)\n-#define DL_SORT(l,cmp)                                                           \\\n- LISTSORT(l,0,FIELD_OFFSET(l,prev),FIELD_OFFSET(l,next),cmp)\n-#define CDL_SORT(l,cmp)                                                          \\\n- LISTSORT(l,1,FIELD_OFFSET(l,prev),FIELD_OFFSET(l,next),cmp)\n-\n-/* The macros can't assume or cast to the caller's list element type. So we use\n- * a couple tricks when we need to deal with those element's prev/next pointers.\n- * Basically we use char pointer arithmetic to get those field offsets. */\n-#define FIELD_OFFSET(ptr,field) ((char*)&((ptr)->field) - (char*)(ptr))\n-#define LNEXT(e,no) (*(char**)(((char*)e) + no))\n-#define LPREV(e,po) (*(char**)(((char*)e) + po))\n-/******************************************************************************\n- * The LISTSORT macro is an adaptation of Simon Tatham's O(n log(n)) mergesort*\n- * Unwieldy variable names used here to avoid shadowing passed-in variables.  *\n- *****************************************************************************/\n-#define LISTSORT(list, is_circular, po, no, cmp)                                 \\\n-do {                                                                             \\\n-  void *_ls_p, *_ls_q, *_ls_e, *_ls_tail, *_ls_oldhead;                          \\\n-  int _ls_insize, _ls_nmerges, _ls_psize, _ls_qsize, _ls_i, _ls_looping;         \\\n-  int _ls_is_double = (po==0) ? 0 : 1;                                           \\\n-  if (list) {                                                                    \\\n-    _ls_insize = 1;                                                              \\\n-    _ls_looping = 1;                                                             \\\n-    while (_ls_looping) {                                                        \\\n-      _ls_p = list;                                                              \\\n-      _ls_oldhead = list;                                                        \\\n-      list = NULL;                                                               \\\n-      _ls_tail = NULL;                                                           \\\n-      _ls_nmerges = 0;                                                           \\\n-      while (_ls_p) {                                                            \\\n-        _ls_nmerges++;                                                           \\\n-        _ls_q = _ls_p;                                                           \\\n-        _ls_psize = 0;                                                           \\\n-        for (_ls_i = 0; _ls_i < _ls_insize; _ls_i++) {                           \\\n-          _ls_psize++;                                                           \\\n-          if (is_circular)  {                                                    \\\n-            _ls_q = ((LNEXT(_ls_q,no) == _ls_oldhead) ? NULL : LNEXT(_ls_q,no)); \\\n-          } else  {                                                              \\\n-            _ls_q = LNEXT(_ls_q,no);                                             \\\n-          }                                                                      \\\n-          if (!_ls_q) break;                                                     \\\n-        }                                                                        \\\n-        _ls_qsize = _ls_insize;                                                  \\\n-        while (_ls_psize > 0 || (_ls_qsize > 0 && _ls_q)) {                      \\\n-          if (_ls_psize == 0) {                                                  \\\n-            _ls_e = _ls_q; _ls_q = LNEXT(_ls_q,no); _ls_qsize--;                 \\\n-            if (is_circular && _ls_q == _ls_oldhead) { _ls_q = NULL; }           \\\n-          } else if (_ls_qsize == 0 || !_ls_q) {                                 \\\n-            _ls_e = _ls_p; _ls_p = LNEXT(_ls_p,no); _ls_psize--;                 \\\n-            if (is_circular && (_ls_p == _ls_oldhead)) { _ls_p = NULL; }         \\\n-          } else if (cmp(LTYPEOF(list)_ls_p,LTYPEOF(list)_ls_q) <= 0) {          \\\n-            _ls_e = _ls_p; _ls_p = LNEXT(_ls_p,no); _ls_psize--;                 \\\n-            if (is_circular && (_ls_p == _ls_oldhead)) { _ls_p = NULL; }         \\\n-          } else {                                                               \\\n-            _ls_e = _ls_q; _ls_q = LNEXT(_ls_q,no); _ls_qsize--;                 \\\n-            if (is_circular && (_ls_q == _ls_oldhead)) { _ls_q = NULL; }         \\\n-          }                                                                      \\\n-          if (_ls_tail) {                                                        \\\n-            LNEXT(_ls_tail,no) = (char*)_ls_e;                                   \\\n-          } else {                                                               \\\n-            list = LTYPEOF(list)_ls_e;                                           \\\n-          }                                                                      \\\n-          if (_ls_is_double) {                                                   \\\n-            LPREV(_ls_e,po) = (char*)_ls_tail;                                   \\\n-          }                                                                      \\\n-          _ls_tail = _ls_e;                                                      \\\n-        }                                                                        \\\n-        _ls_p = _ls_q;                                                           \\\n-      }                                                                          \\\n-      if (is_circular) {                                                         \\\n-        LNEXT(_ls_tail,no) = (char*)list;                                        \\\n-        if (_ls_is_double) {                                                     \\\n-          LPREV(list,po) = (char*)_ls_tail;                                      \\\n-        }                                                                        \\\n-      } else  {                                                                  \\\n-        LNEXT(_ls_tail,no) = NULL;                                               \\\n-      }                                                                          \\\n-      if (_ls_nmerges <= 1) {                                                    \\\n-        _ls_looping=0;                                                           \\\n-      }                                                                          \\\n-      _ls_insize *= 2;                                                           \\\n-    }                                                                            \\\n-  }                                                                              \\\n-} while (0)\n-\n-/******************************************************************************\n- * singly linked list macros (non-circular)                                   *\n- *****************************************************************************/\n-#define LL_PREPEND(head,add)                                                     \\\n-do {                                                                             \\\n-  (add)->next = head;                                                            \\\n-  head = add;                                                                    \\\n-} while (0)\n-\n-#define LL_APPEND(head,add)                                                      \\\n-do {                                                                             \\\n-  (add)->next=NULL;                                                              \\\n-  if (head) {                                                                    \\\n-    char *_lla_el = (char*)(head);                                               \\\n-    unsigned _lla_no = FIELD_OFFSET(head,next);                                  \\\n-    while (LNEXT(_lla_el,_lla_no)) { _lla_el = LNEXT(_lla_el,_lla_no); }         \\\n-    LNEXT(_lla_el,_lla_no)=(char*)(add);                                         \\\n-  } else {                                                                       \\\n-    (head)=(add);                                                                \\\n-  }                                                                              \\\n-} while (0)\n-\n-#define LL_DELETE(head,del)                                                      \\\n-do {                                                                             \\\n-  if ((head) == (del)) {                                                         \\\n-    (head)=(head)->next;                                                         \\\n-  } else {                                                                       \\\n-    char *_lld_el = (char*)(head);                                               \\\n-    unsigned _lld_no = FIELD_OFFSET(head,next);                                  \\\n-    while (LNEXT(_lld_el,_lld_no) && (LNEXT(_lld_el,_lld_no) != (char*)(del))) { \\\n-      _lld_el = LNEXT(_lld_el,_lld_no);                                          \\\n-    }                                                                            \\\n-    if (LNEXT(_lld_el,_lld_no)) {                                                \\\n-      LNEXT(_lld_el,_lld_no) = (char*)((del)->next);                             \\\n-    }                                                                            \\\n-  }                                                                              \\\n-} while (0)\n-\n-#define LL_FOREACH(head,el)                                                      \\\n-    for(el=head;el;el=el->next)\n-\n-/******************************************************************************\n- * doubly linked list macros (non-circular)                                   *\n- *****************************************************************************/\n-#define DL_PREPEND(head,add)                                                     \\\n-do {                                                                             \\\n- (add)->next = head;                                                             \\\n- if (head) {                                                                     \\\n-   (add)->prev = (head)->prev;                                                   \\\n-   (head)->prev = (add);                                                         \\\n- } else {                                                                        \\\n-   (add)->prev = (add);                                                          \\\n- }                                                                               \\\n- (head) = (add);                                                                 \\\n-} while (0)\n-\n-#define DL_APPEND(head,add)                                                      \\\n-do {                                                                             \\\n-  if (head) {                                                                    \\\n-      (add)->prev = (head)->prev;                                                \\\n-      (head)->prev->next = (add);                                                \\\n-      (head)->prev = (add);                                                      \\\n-      (add)->next = NULL;                                                        \\\n-  } else {                                                                       \\\n-      (head)=(add);                                                              \\\n-      (head)->prev = (head);                                                     \\\n-      (head)->next = NULL;                                                       \\\n-  }                                                                              \\\n-} while (0);\n-\n-#define DL_DELETE(head,del)                                                      \\\n-do {                                                                             \\\n-  if ((del)->prev == (del)) {                                                    \\\n-      (head)=NULL;                                                               \\\n-  } else if ((del)==(head)) {                                                    \\\n-      (del)->next->prev = (del)->prev;                                           \\\n-      (head) = (del)->next;                                                      \\\n-  } else {                                                                       \\\n-      (del)->prev->next = (del)->next;                                           \\\n-      if ((del)->next) {                                                         \\\n-          (del)->next->prev = (del)->prev;                                       \\\n-      } else {                                                                   \\\n-          (head)->prev = (del)->prev;                                            \\\n-      }                                                                          \\\n-  }                                                                              \\\n-} while (0);\n-\n-\n-#define DL_FOREACH(head,el)                                                      \\\n-    for(el=head;el;el=el->next)\n-\n-/******************************************************************************\n- * circular doubly linked list macros                                         *\n- *****************************************************************************/\n-#define CDL_PREPEND(head,add)                                                    \\\n-do {                                                                             \\\n- if (head) {                                                                     \\\n-   (add)->prev = (head)->prev;                                                   \\\n-   (add)->next = (head);                                                         \\\n-   (head)->prev = (add);                                                         \\\n-   (add)->prev->next = (add);                                                    \\\n- } else {                                                                        \\\n-   (add)->prev = (add);                                                          \\\n-   (add)->next = (add);                                                          \\\n- }                                                                               \\\n-(head)=(add);                                                                    \\\n-} while (0)\n-\n-#define CDL_DELETE(head,del)                                                     \\\n-do {                                                                             \\\n-  if ( ((head)==(del)) && ((head)->next == (head))) {                            \\\n-      (head) = 0L;                                                               \\\n-  } else {                                                                       \\\n-     (del)->next->prev = (del)->prev;                                            \\\n-     (del)->prev->next = (del)->next;                                            \\\n-     if ((del) == (head)) (head)=(del)->next;                                    \\\n-  }                                                                              \\\n-} while (0);\n-\n-#define CDL_FOREACH(head,el)                                                     \\\n-    for(el=head;el;el= (el->next==head ? 0L : el->next)) \n-\n-\n-#endif /* UTLIST_H */\n-"}, {"sha": "e5bef45c1c3c57afdd6b3006daa3e66a303ec874", "filename": "src/rt/util/hash_map.h", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Frt%2Futil%2Fhash_map.h", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Frt%2Futil%2Fhash_map.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Fhash_map.h?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -1,207 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/**\n- * A C++ wrapper around uthash.\n- */\n-\n-#ifndef HASH_MAP\n-#define HASH_MAP\n-\n-#include <assert.h>\n-#include \"../uthash/uthash.h\"\n-\n-template<typename K, typename V> class hash_map {\n-    struct map_entry {\n-        K key;\n-        V value;\n-        UT_hash_handle hh;\n-    };\n-    map_entry * _head;\n-private:\n-    // private and left undefined to disable copying\n-    hash_map(const hash_map& rhs);\n-    hash_map& operator=(const hash_map& rhs);\n-public:\n-    hash_map();\n-    ~hash_map();\n-\n-    /**\n-     * Associates a value with the specified key in this hash map.\n-     * If a mapping already exists the old value is replaced.\n-     *\n-     * returns:\n-     * true if the mapping was successfully created and false otherwise.\n-     */\n-    bool put(K key, V value);\n-\n-    /**\n-     * Updates the value associated with the specified key in this hash map.\n-     *\n-     * returns:\n-     * true if the value was updated, or false if the key was not found.\n-     */\n-    bool set(K key, V value);\n-\n-    /**\n-     * Gets the value associated with the specified key in this hash map.\n-     *\n-     * returns:\n-     * true if the value was found and updates the specified *value parameter\n-     * with the associated value, or false otherwise.\n-     */\n-    bool get(K key, V *value) const;\n-\n-    /**\n-     * Removes a key-value pair from this hash map.\n-     *\n-     * returns:\n-     * true if a key-value pair exists and updates the specified\n-     * *key and *value parameters, or false otherwise.\n-     */\n-    bool pop(K *key, V *value);\n-\n-    /**\n-     * Checks if the specified key exists in this hash map.\n-     *\n-     * returns:\n-     * true if the specified key exists in this hash map, or false otherwise.\n-     */\n-    bool contains(K key) const;\n-\n-    /**\n-     * Removes the value associated with the specified key from this hash map.\n-     *\n-     * returns:\n-     * true if the specified key exists and updates the specified *old_value\n-     * parameter with the associated value, or false otherwise.\n-     */\n-    bool remove(K key, V *old_value);\n-    bool remove(K key);\n-\n-    /**\n-     * Returns the number of key-value pairs in this hash map.\n-     */\n-    size_t count() const;\n-\n-    bool is_empty() const {\n-        return count() == 0;\n-    }\n-\n-    /**\n-     * Clears all the key-value pairs in this hash map.\n-     *\n-     * returns:\n-     * the number of deleted key-value pairs.\n-     */\n-    size_t clear();\n-};\n-\n-template<typename K, typename V>\n-hash_map<K,V>::hash_map() {\n-    _head = NULL;\n-}\n-\n-template<typename K, typename V>\n-hash_map<K,V>::~hash_map() {\n-    clear();\n-}\n-\n-template<typename K, typename V> bool\n-hash_map<K,V>::put(K key, V value) {\n-    if (contains(key)) {\n-        return set(key, value);\n-    }\n-    map_entry *entry = (map_entry *) malloc(sizeof(map_entry));\n-    entry->key = key;\n-    entry->value = value;\n-    HASH_ADD(hh, _head, key, sizeof(K), entry);\n-    return true;\n-}\n-\n-template<typename K, typename V> bool\n-hash_map<K,V>::get(K key, V *value) const {\n-    map_entry *entry = NULL;\n-    HASH_FIND(hh, _head, &key, sizeof(K), entry);\n-    if (entry == NULL) {\n-        return false;\n-    }\n-    *value = entry->value;\n-    return true;\n-}\n-\n-template<typename K, typename V> bool\n-hash_map<K,V>::set(K key, V value) {\n-    map_entry *entry = NULL;\n-    HASH_FIND(hh, _head, &key, sizeof(K), entry);\n-    if (entry == NULL) {\n-        return false;\n-    }\n-    entry->value = value;\n-    return true;\n-}\n-\n-template<typename K, typename V> bool\n-hash_map<K,V>::contains(K key) const {\n-    V value;\n-    return get(key, &value);\n-}\n-\n-template<typename K, typename V> bool\n-hash_map<K,V>::remove(K key, V *old_value) {\n-    map_entry *entry = NULL;\n-    HASH_FIND(hh, _head, &key, sizeof(K), entry);\n-    if (entry == NULL) {\n-        return false;\n-    }\n-    *old_value = entry->value;\n-    HASH_DEL(_head, entry);\n-    free(entry);\n-    return true;\n-}\n-\n-template<typename K, typename V> bool\n-hash_map<K,V>::pop(K *key, V *value) {\n-    if (is_empty()) {\n-        return false;\n-    }\n-    map_entry *entry = _head;\n-    HASH_DEL(_head, entry);\n-    *key = entry->key;\n-    *value = entry->value;\n-    free(entry);\n-    return true;\n-}\n-\n-template<typename K, typename V> bool\n-hash_map<K,V>::remove(K key) {\n-    V old_value;\n-    return remove(key, &old_value);\n-}\n-\n-template<typename K, typename V> size_t\n-hash_map<K,V>::count() const {\n-    return HASH_CNT(hh, _head);\n-}\n-\n-template<typename K, typename V> size_t\n-hash_map<K,V>::clear() {\n-    size_t deleted_entries = 0;\n-    while (_head != NULL) {\n-        map_entry *entry = _head;\n-        HASH_DEL(_head, entry);\n-        free(entry);\n-        deleted_entries ++;\n-    }\n-    assert(count() == 0);\n-    return deleted_entries;\n-}\n-\n-#endif /* HASH_MAP */"}]}