{"sha": "31298b41d65093b2ea260d8fe8820da6db6dac94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMjk4YjQxZDY1MDkzYjJlYTI2MGQ4ZmU4ODIwZGE2ZGI2ZGFjOTQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-10T17:24:37Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-22T19:01:45Z"}, "message": "Invert implementations for TokenKind.\n\nAlso export a bunch of Token-related impls.", "tree": {"sha": "2a792a21b0dcb3834272399e6827ddb2443c8d9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a792a21b0dcb3834272399e6827ddb2443c8d9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31298b41d65093b2ea260d8fe8820da6db6dac94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31298b41d65093b2ea260d8fe8820da6db6dac94", "html_url": "https://github.com/rust-lang/rust/commit/31298b41d65093b2ea260d8fe8820da6db6dac94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31298b41d65093b2ea260d8fe8820da6db6dac94/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0073d3be97707b34f747c2633ac02e8c9ea89452", "url": "https://api.github.com/repos/rust-lang/rust/commits/0073d3be97707b34f747c2633ac02e8c9ea89452", "html_url": "https://github.com/rust-lang/rust/commit/0073d3be97707b34f747c2633ac02e8c9ea89452"}], "stats": {"total": 107, "additions": 55, "deletions": 52}, "files": [{"sha": "a37e014d2bd9f0d9dfc164720c6a1ae69daeb1b5", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 9, "deletions": 49, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=31298b41d65093b2ea260d8fe8820da6db6dac94", "patch": "@@ -9,15 +9,13 @@ use std::mem;\n use syntax::ast;\n use syntax::feature_gate;\n use syntax::token;\n-use syntax::tokenstream;\n use syntax_pos::SourceFile;\n \n use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n-impl<'ctx> syntax::StableHashingContextLike for StableHashingContext<'ctx> {}\n impl<'ctx> rustc_target::StableHashingContextLike for StableHashingContext<'ctx> {}\n \n impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n@@ -47,11 +45,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     }\n }\n \n-impl_stable_hash_for!(struct ::syntax::ast::AttrItem {\n-    path,\n-    tokens,\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n@@ -69,38 +62,10 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for tokenstream::TokenTree {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            tokenstream::TokenTree::Token(ref token) => {\n-                token.hash_stable(hcx, hasher);\n-            }\n-            tokenstream::TokenTree::Delimited(span, delim, ref tts) => {\n-                span.hash_stable(hcx, hasher);\n-                std_hash::Hash::hash(&delim, hasher);\n-                for sub_tt in tts.trees() {\n-                    sub_tt.hash_stable(hcx, hasher);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>>\n-for tokenstream::TokenStream {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        for sub_tt in self.trees() {\n-            sub_tt.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for token::TokenKind {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n+impl<'ctx> syntax::StableHashingContextLike for StableHashingContext<'ctx> {\n+    fn hash_stable_tokenkind(&mut self, tokenkind: &token::TokenKind, hasher: &mut StableHasher) {\n+        mem::discriminant(tokenkind).hash_stable(self, hasher);\n+        match *tokenkind {\n             token::Eq |\n             token::Lt |\n             token::Le |\n@@ -141,30 +106,25 @@ impl<'a> HashStable<StableHashingContext<'a>> for token::TokenKind {\n             token::CloseDelim(delim_token) => {\n                 std_hash::Hash::hash(&delim_token, hasher);\n             }\n-            token::Literal(lit) => lit.hash_stable(hcx, hasher),\n+            token::Literal(lit) => lit.hash_stable(self, hasher),\n \n             token::Ident(name, is_raw) => {\n-                name.hash_stable(hcx, hasher);\n-                is_raw.hash_stable(hcx, hasher);\n+                name.hash_stable(self, hasher);\n+                is_raw.hash_stable(self, hasher);\n             }\n-            token::Lifetime(name) => name.hash_stable(hcx, hasher),\n+            token::Lifetime(name) => name.hash_stable(self, hasher),\n \n             token::Interpolated(_) => {\n                 bug!(\"interpolated tokens should not be present in the HIR\")\n             }\n \n             token::DocComment(val) |\n             token::Shebang(val) |\n-            token::Unknown(val) => val.hash_stable(hcx, hasher),\n+            token::Unknown(val) => val.hash_stable(self, hasher),\n         }\n     }\n }\n \n-impl_stable_hash_for!(struct token::Token {\n-    kind,\n-    span\n-});\n-\n impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItem {\n     MetaItem(meta_item),\n     Literal(lit)"}, {"sha": "3cc6a043e3b244d1164b71923614bbdc6f19f5c3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=31298b41d65093b2ea260d8fe8820da6db6dac94", "patch": "@@ -2276,7 +2276,7 @@ impl rustc_serialize::Decodable for AttrId {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n     pub tokens: TokenStream,"}, {"sha": "939e1877b4a45182742233fe9c72b90d4b8318d9", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=31298b41d65093b2ea260d8fe8820da6db6dac94", "patch": "@@ -20,6 +20,7 @@\n #![recursion_limit=\"256\"]\n \n pub use errors;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::Lock;\n use rustc_index::bit_set::GrowableBitSet;\n pub use rustc_data_structures::thin_vec::ThinVec;\n@@ -114,4 +115,6 @@ pub mod early_buffered_lints;\n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n /// instead of implementing everything in librustc.\n-pub trait StableHashingContextLike: syntax_pos::StableHashingContextLike {}\n+pub trait StableHashingContextLike: syntax_pos::StableHashingContextLike {\n+    fn hash_stable_tokenkind(&mut self, tokenkind: &token::TokenKind, hasher: &mut StableHasher);\n+}"}, {"sha": "305db739399f5915d5bfe5543ef4f8e44330e257", "filename": "src/libsyntax/token.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibsyntax%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibsyntax%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftoken.rs?ref=31298b41d65093b2ea260d8fe8820da6db6dac94", "patch": "@@ -14,6 +14,7 @@ use syntax_pos::{self, Span, DUMMY_SP};\n \n use std::fmt;\n use std::mem;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n \n@@ -262,7 +263,15 @@ pub enum TokenKind {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenKind, 16);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+impl<CTX> HashStable<CTX> for TokenKind\n+    where CTX: crate::StableHashingContextLike\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        hcx.hash_stable_tokenkind(self, hasher)\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Token {\n     pub kind: TokenKind,\n     pub span: Span,"}, {"sha": "6de9a0fb0701f0c4c63e0a5c366942df25abb0c4", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31298b41d65093b2ea260d8fe8820da6db6dac94/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=31298b41d65093b2ea260d8fe8820da6db6dac94", "patch": "@@ -16,6 +16,7 @@\n use crate::token::{self, DelimToken, Token, TokenKind};\n \n use syntax_pos::{Span, DUMMY_SP};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use smallvec::{SmallVec, smallvec};\n \n@@ -51,6 +52,26 @@ where\n     TokenStream: Send + Sync,\n {}\n \n+impl<CTX> HashStable<CTX> for TokenTree\n+    where CTX: crate::StableHashingContextLike\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            TokenTree::Token(ref token) => {\n+                token.hash_stable(hcx, hasher);\n+            }\n+            TokenTree::Delimited(span, delim, ref tts) => {\n+                span.hash_stable(hcx, hasher);\n+                std::hash::Hash::hash(&delim, hasher);\n+                for sub_tt in tts.trees() {\n+                    sub_tt.hash_stable(hcx, hasher);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl TokenTree {\n     /// Checks if this TokenTree is equal to the other, regardless of span information.\n     pub fn eq_unspanned(&self, other: &TokenTree) -> bool {\n@@ -115,6 +136,16 @@ impl TokenTree {\n     }\n }\n \n+impl<CTX> HashStable<CTX> for TokenStream\n+    where CTX: crate::StableHashingContextLike\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        for sub_tt in self.trees() {\n+            sub_tt.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n /// A `TokenStream` is an abstract sequence of tokens, organized into `TokenTree`s.\n ///\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s"}]}