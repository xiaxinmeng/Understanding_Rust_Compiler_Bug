{"sha": "9b3f55ee61e781ef3360ddfaa436746bb7e40df5", "node_id": "C_kwDOAAsO6NoAKDliM2Y1NWVlNjFlNzgxZWYzMzYwZGRmYWE0MzY3NDZiYjdlNDBkZjU", "commit": {"author": {"name": "Nathaniel Hamovitz", "email": "18648574+nhamovitz@users.noreply.github.com", "date": "2021-10-17T00:49:13Z"}, "committer": {"name": "Nathaniel Hamovitz", "email": "18648574+nhamovitz@users.noreply.github.com", "date": "2021-10-18T10:05:19Z"}, "message": "tried to simplify but it doesn't work :/", "tree": {"sha": "c10ad5fff2f7dfdb3dbd5c9593671048b68eb2f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c10ad5fff2f7dfdb3dbd5c9593671048b68eb2f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b3f55ee61e781ef3360ddfaa436746bb7e40df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3f55ee61e781ef3360ddfaa436746bb7e40df5", "html_url": "https://github.com/rust-lang/rust/commit/9b3f55ee61e781ef3360ddfaa436746bb7e40df5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b3f55ee61e781ef3360ddfaa436746bb7e40df5/comments", "author": {"login": "nhamovitz", "id": 18648574, "node_id": "MDQ6VXNlcjE4NjQ4NTc0", "avatar_url": "https://avatars.githubusercontent.com/u/18648574?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nhamovitz", "html_url": "https://github.com/nhamovitz", "followers_url": "https://api.github.com/users/nhamovitz/followers", "following_url": "https://api.github.com/users/nhamovitz/following{/other_user}", "gists_url": "https://api.github.com/users/nhamovitz/gists{/gist_id}", "starred_url": "https://api.github.com/users/nhamovitz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nhamovitz/subscriptions", "organizations_url": "https://api.github.com/users/nhamovitz/orgs", "repos_url": "https://api.github.com/users/nhamovitz/repos", "events_url": "https://api.github.com/users/nhamovitz/events{/privacy}", "received_events_url": "https://api.github.com/users/nhamovitz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nhamovitz", "id": 18648574, "node_id": "MDQ6VXNlcjE4NjQ4NTc0", "avatar_url": "https://avatars.githubusercontent.com/u/18648574?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nhamovitz", "html_url": "https://github.com/nhamovitz", "followers_url": "https://api.github.com/users/nhamovitz/followers", "following_url": "https://api.github.com/users/nhamovitz/following{/other_user}", "gists_url": "https://api.github.com/users/nhamovitz/gists{/gist_id}", "starred_url": "https://api.github.com/users/nhamovitz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nhamovitz/subscriptions", "organizations_url": "https://api.github.com/users/nhamovitz/orgs", "repos_url": "https://api.github.com/users/nhamovitz/repos", "events_url": "https://api.github.com/users/nhamovitz/events{/privacy}", "received_events_url": "https://api.github.com/users/nhamovitz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fdf93415bfd59a7cd61ebec20f0a4e4fec78164", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fdf93415bfd59a7cd61ebec20f0a4e4fec78164", "html_url": "https://github.com/rust-lang/rust/commit/5fdf93415bfd59a7cd61ebec20f0a4e4fec78164"}], "stats": {"total": 143, "additions": 61, "deletions": 82}, "files": [{"sha": "913812126a9bd290d7080b1d50802f8d2959776e", "filename": "clippy_lints/src/trailing_zero_sized_array_without_repr_c.rs", "status": "modified", "additions": 34, "deletions": 75, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9b3f55ee61e781ef3360ddfaa436746bb7e40df5/clippy_lints%2Fsrc%2Ftrailing_zero_sized_array_without_repr_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3f55ee61e781ef3360ddfaa436746bb7e40df5/clippy_lints%2Fsrc%2Ftrailing_zero_sized_array_without_repr_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrailing_zero_sized_array_without_repr_c.rs?ref=9b3f55ee61e781ef3360ddfaa436746bb7e40df5", "patch": "@@ -1,14 +1,11 @@\n use clippy_utils::consts::{miri_to_const, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::Attribute;\n-use rustc_hir::def_id::LocalDefId;\n use rustc_hir::{Item, ItemKind, VariantData};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::dep_graph::DepContext;\n-use rustc_middle::ty as ty_mod;\n-use rustc_middle::ty::ReprFlags;\n+use rustc_middle::ty::Const;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -43,93 +40,55 @@ declare_lint_pass!(TrailingZeroSizedArrayWithoutReprC => [TRAILING_ZERO_SIZED_AR\n \n impl<'tcx> LateLintPass<'tcx> for TrailingZeroSizedArrayWithoutReprC {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n-        dbg!(item.ident);\n-        if is_struct_with_trailing_zero_sized_array(cx, item) && !has_repr_attr(cx, item.def_id) {\n-            // span_lint_and_help(\n-            //     cx,\n-            //     TRAILING_ZERO_SIZED_ARRAY_WITHOUT_REPR_C,\n-            //     item.span,\n-            //     \"trailing zero-sized array in a struct which is not marked `#[repr(C)]`\",\n-            //     None,\n-            //     \"consider annotating the struct definition with `#[repr(C)]` (or another `repr` attribute)\",\n-            // );\n-            eprintln!(\"\u2014 consider yourself linted \u2014 \ud83e\udd80\")\n+        if is_struct_with_trailing_zero_sized_array(cx, item) {\n+            let attrs = cx.tcx.get_attrs(item.def_id.to_def_id());\n+            let first_attr = attrs.first(); // Actually, I've no idea if this is guaranteed to be the first one in the source code.\n+\n+            let lint_span = if let Some(first_attr) = first_attr {\n+                first_attr.span.until(item.span)\n+            } else {\n+                item.span\n+            };\n+\n+            if !has_repr_attr(cx, attrs) {\n+                span_lint_and_help(\n+                    cx,\n+                    TRAILING_ZERO_SIZED_ARRAY_WITHOUT_REPR_C,\n+                    lint_span,\n+                    \"trailing zero-sized array in a struct which is not marked `#[repr(C)]`\",\n+                    None,\n+                    \"consider annotating the struct definition with `#[repr(C)]` (or another `repr` attribute)\",\n+                );\n+            }\n         }\n     }\n }\n \n fn is_struct_with_trailing_zero_sized_array(cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) -> bool {\n     if_chain! {\n-        if let ItemKind::Struct(data, _generics) = &item.kind;\n+        // Check if last field is an array\n+        if let ItemKind::Struct(data, _) = &item.kind;\n         if let VariantData::Struct(field_defs, _) = data;\n         if let Some(last_field) = field_defs.last();\n-        if let rustc_hir::TyKind::Array(_, aconst) = last_field.ty.kind;\n-        let aconst_def_id = cx.tcx.hir().body_owner_def_id(aconst.body).to_def_id();\n-        let ty = cx.tcx.type_of(aconst_def_id);\n-        let constant = cx\n-            .tcx\n-            // NOTE: maybe const_eval_resolve?\n-            .const_eval_poly(aconst_def_id)\n-            .ok()\n-            .map(|val| rustc_middle::ty::Const::from_value(cx.tcx, val, ty));\n-        if let Some(Constant::Int(val)) = constant.and_then(miri_to_const);\n-        if val == 0;\n-        then {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-fn has_repr_attr(cx: &LateContext<'tcx>, def_id: LocalDefId) -> bool {\n-    let attrs_get_attrs = get_attrs_get_attrs(cx, def_id);\n-    let attrs_hir_map = get_attrs_hir_map(cx, def_id);\n+        if let rustc_hir::TyKind::Array(_, length) = last_field.ty.kind;\n \n-    let b11 = includes_repr_attr_using_sym(attrs_get_attrs);\n-    let b12 = includes_repr_attr_using_sym(attrs_hir_map);\n-    let b21 = includes_repr_attr_using_helper(cx, attrs_get_attrs);\n-    let b22 = includes_repr_attr_using_helper(cx, attrs_hir_map);\n-    let b3 =  has_repr_attr_using_adt(cx, def_id);\n-    let all_same = (b11 && b12 && b21 && b22 && b3) || (!b11 && !b12 && !b21 && !b22 && !b3);\n-    dbg!(all_same);\n+        // Check if that that array zero-sized.\n+        let length_ldid = cx.tcx.hir().local_def_id(length.hir_id);\n+        let length = Const::from_anon_const(cx.tcx, length_ldid);\n+        if let Some(Constant::Int(length)) = miri_to_const(length);\n+        if length == 0;\n \n-    b21\n-}\n-\n-fn get_attrs_get_attrs(cx: &LateContext<'tcx>, def_id: LocalDefId) -> &'tcx [Attribute] {\n-    cx.tcx.get_attrs(def_id.to_def_id())\n-}\n-\n-fn get_attrs_hir_map(cx: &LateContext<'tcx>, def_id: LocalDefId) -> &'tcx [Attribute] {\n-    let hir_map = cx.tcx.hir();\n-    let hir_id = hir_map.local_def_id_to_hir_id(def_id);\n-    hir_map.attrs(hir_id)\n-}\n-\n-// Don't like this because it's so dependent on the current list of `repr` flags and it would have\n-// to be manually updated if that ever expanded. idk if there's any mechanism in `bitflag!` or\n-// elsewhere for requiring that sort of exhaustiveness\n-fn has_repr_attr_using_adt(cx: &LateContext<'tcx>, def_id: LocalDefId) -> bool {\n-    let ty = cx.tcx.type_of(def_id.to_def_id());\n-    if let ty_mod::Adt(adt, _) = ty.kind() {\n-        if adt.is_struct() {\n-            let repr = adt.repr;\n-            let repr_attr = ReprFlags::IS_C | ReprFlags::IS_TRANSPARENT | ReprFlags::IS_SIMD | ReprFlags::IS_LINEAR;\n-            repr.int.is_some() || repr.align.is_some() || repr.pack.is_some() || repr.flags.intersects(repr_attr)\n+        then {\n+            true\n         } else {\n             false\n         }\n-    } else {\n-        false\n     }\n }\n \n-fn includes_repr_attr_using_sym(attrs: &'tcx [Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(sym::repr))\n-}\n-\n-fn includes_repr_attr_using_helper(cx: &LateContext<'tcx>, attrs: &'tcx [Attribute]) -> bool {\n+fn has_repr_attr(cx: &LateContext<'tcx>, attrs: &[Attribute]) -> bool {\n+    // NOTE: there's at least four other ways to do this but I liked this one the best. (All five agreed\n+    // on all testcases.) Happy to use another; they're in the commit history.\n     attrs\n         .iter()\n         .any(|attr| !rustc_attr::find_repr_attrs(cx.tcx.sess(), attr).is_empty())"}, {"sha": "6ab96c2ebf6376aa8a54647e0f113a136761bd9c", "filename": "tests/ui/trailing_zero_sized_array_without_repr_c.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9b3f55ee61e781ef3360ddfaa436746bb7e40df5/tests%2Fui%2Ftrailing_zero_sized_array_without_repr_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3f55ee61e781ef3360ddfaa436746bb7e40df5/tests%2Fui%2Ftrailing_zero_sized_array_without_repr_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zero_sized_array_without_repr_c.rs?ref=9b3f55ee61e781ef3360ddfaa436746bb7e40df5", "patch": "@@ -8,7 +8,7 @@ struct RarelyUseful {\n     last: [usize; 0],\n }\n \n-struct OnlyFieldIsZeroSizeArray {\n+struct OnlyField {\n     first_and_last: [usize; 0],\n }\n \n@@ -18,19 +18,19 @@ struct GenericArrayType<T> {\n }\n \n #[derive(Debug)]\n-struct PlayNiceWithOtherAttributesDerive {\n+struct OnlyAnotherAttributeDerive {\n     field: i32,\n     last: [usize; 0],\n }\n \n #[must_use]\n-struct PlayNiceWithOtherAttributesMustUse {\n+struct OnlyAnotherAttributeMustUse {\n     field: i32,\n     last: [usize; 0],\n }\n \n const ZERO: usize = 0;\n-struct ZeroSizedFromExternalConst {\n+struct ZeroSizedWithConst {\n     field: i32,\n     last: [usize; ZERO],\n }\n@@ -39,7 +39,7 @@ struct ZeroSizedFromExternalConst {\n const fn compute_zero() -> usize {\n     (4 + 6) - (2 * 5)\n }\n-struct UsingFunction {\n+struct ZeroSizedWithConstFunction {\n     field: i32,\n     last: [usize; compute_zero()],\n }\n@@ -72,17 +72,36 @@ struct GoodReason {\n     last: [usize; 0],\n }\n \n+#[repr(C)]\n+struct OnlyFieldWithReprC {\n+    first_and_last: [usize; 0],\n+}\n+\n struct NonZeroSizedArray {\n     field: i32,\n     last: [usize; 1],\n }\n \n const ONE: usize = 1;\n-struct NonZeroSizedFromExternalConst {\n+struct NonZeroSizedWithConst {\n     field: i32,\n     last: [usize; ONE],\n }\n \n+#[derive(Debug)]\n+#[repr(C)]\n+struct OtherAttributesDerive {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+#[must_use]\n+#[repr(C)]\n+struct OtherAttributesMustUse {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n #[repr(packed)]\n struct ReprPacked {\n     field: i32,\n@@ -129,5 +148,6 @@ enum DontLintAnonymousStructsFromDesuraging {\n // }\n \n fn main() {\n-    let _ = PlayNiceWithOtherAttributesMustUse { field: 0, last: [] };\n+    let _ = OnlyAnotherAttributeMustUse { field: 0, last: [] };\n+    let _ = OtherAttributesMustUse { field: 0, last: [] };\n }"}]}