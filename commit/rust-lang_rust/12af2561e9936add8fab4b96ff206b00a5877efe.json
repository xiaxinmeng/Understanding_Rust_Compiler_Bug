{"sha": "12af2561e9936add8fab4b96ff206b00a5877efe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYWYyNTYxZTk5MzZhZGQ4ZmFiNGI5NmZmMjA2YjAwYTU4NzdlZmU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-29T23:49:01Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-10T20:02:18Z"}, "message": "Point at method call when type annotations are needed", "tree": {"sha": "b5b5410af50110a0231f489451b3611ab6adf644", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5b5410af50110a0231f489451b3611ab6adf644"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12af2561e9936add8fab4b96ff206b00a5877efe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12af2561e9936add8fab4b96ff206b00a5877efe", "html_url": "https://github.com/rust-lang/rust/commit/12af2561e9936add8fab4b96ff206b00a5877efe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12af2561e9936add8fab4b96ff206b00a5877efe/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dbfb0a8ca4ab74ee3111e57a024f9e6257ce37c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dbfb0a8ca4ab74ee3111e57a024f9e6257ce37c", "html_url": "https://github.com/rust-lang/rust/commit/7dbfb0a8ca4ab74ee3111e57a024f9e6257ce37c"}], "stats": {"total": 152, "additions": 108, "deletions": 44}, "files": [{"sha": "118fd186b1c8c27682832d61fac53622d684628e", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -6,6 +6,7 @@ use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::ty::{self, Ty, Infer, TyVar};\n use crate::ty::print::Print;\n use syntax::source_map::DesugaringKind;\n+use syntax::symbol::kw;\n use syntax_pos::Span;\n use errors::{Applicability, DiagnosticBuilder};\n \n@@ -19,6 +20,7 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n     found_closure: Option<&'tcx ExprKind>,\n+    found_method_call: Option<&'tcx ExprKind>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n@@ -35,6 +37,7 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n             found_arg_pattern: None,\n             found_ty: None,\n             found_closure: None,\n+            found_method_call: None,\n         }\n     }\n \n@@ -93,11 +96,12 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n-            &expr.kind,\n-            self.node_matches_type(expr.hir_id),\n-        ) {\n-            self.found_closure = Some(&expr.kind);\n+        if self.node_matches_type(expr.hir_id).is_some() {\n+            match expr.kind {\n+                ExprKind::Closure(..) => self.found_closure = Some(&expr.kind),\n+                ExprKind::MethodCall(..) => self.found_method_call = Some(&expr.kind),\n+                _ => {}\n+            }\n         }\n         intravisit::walk_expr(self, expr);\n     }\n@@ -157,7 +161,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let ty_vars = self.type_variables.borrow();\n             let var_origin = ty_vars.var_origin(ty_vid);\n             if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n-                return (name.to_string(), Some(var_origin.span));\n+                if name != kw::SelfUpper {\n+                    return (name.to_string(), Some(var_origin.span));\n+                }\n             }\n         }\n \n@@ -175,6 +181,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         body_id: Option<hir::BodyId>,\n         span: Span,\n         ty: Ty<'tcx>,\n+        is_projection: bool,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let (name, name_sp) = self.extract_type_name(&ty, None);\n@@ -210,6 +217,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // 3 |     let _ = x.sum() as f64;\n             //   |               ^^^ cannot infer type for `S`\n             span\n+        } else if let Some(ExprKind::MethodCall(_, call_span, _)) = local_visitor.found_method_call {\n+            // Point at the call instead of the whole expression:\n+            // error[E0284]: type annotations needed\n+            //  --> file.rs:2:5\n+            //   |\n+            // 2 |     vec![Ok(2)].into_iter().collect()?;\n+            //   |                             ^^^^^^^ cannot infer type\n+            //   |\n+            //   = note: cannot resolve `<_ as std::ops::Try>::Ok == _`\n+            if span.contains(*call_span) {\n+                *call_span\n+            } else {\n+                span\n+            }\n         } else {\n             span\n         };\n@@ -247,13 +268,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n         //   |         the type parameter `E` is specified\n         // ```\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            err_span,\n-            E0282,\n-            \"type annotations needed{}\",\n-            ty_msg,\n-        );\n+        let mut err = if is_projection {\n+            struct_span_err!(self.tcx.sess, err_span, E0284, \"type annotations needed{}\", ty_msg)\n+        } else {\n+            struct_span_err!(self.tcx.sess, err_span, E0282, \"type annotations needed{}\", ty_msg)\n+        };\n \n         let suffix = match local_visitor.found_ty {\n             Some(ty::TyS { kind: ty::Closure(def_id, substs), .. }) => {\n@@ -334,6 +353,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 format!(\"consider giving this pattern {}\", suffix)\n             };\n             err.span_label(pattern.span, msg);\n+        } else if let Some(ExprKind::MethodCall(segment, ..)) = local_visitor.found_method_call {\n+            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(segment.ident.span) {\n+                if segment.args.is_none() {\n+                    err.span_suggestion(\n+                        segment.ident.span,\n+                        \"consider specifying the type argument in the method call\",\n+                        // FIXME: we don't know how many type arguments should be set here.\n+                        format!(\"{}::<_>\", snippet),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+            }\n         }\n         // Instead of the following:\n         // error[E0282]: type annotations needed\n@@ -351,7 +382,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |               ^^^ cannot infer type for `S`\n         //   |\n         //   = note: type must be known at this point\n-        let span = name_sp.unwrap_or(span);\n+        let span = name_sp.unwrap_or(err_span);\n         if !err.span.span_labels().iter().any(|span_label| {\n                 span_label.label.is_some() && span_label.span == span\n             }) && local_visitor.found_arg_pattern.is_none()"}, {"sha": "2b00861188e820ec1dbcd6659cb1789aaee59887", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -1989,7 +1989,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.lang_items().sized_trait()\n                     .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                 {\n-                    self.need_type_info_err(body_id, span, self_ty).emit();\n+                    self.need_type_info_err(body_id, span, self_ty, false).emit();\n                 } else {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n@@ -2007,7 +2007,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if !ty.references_error() && !self.tcx.sess.has_errors() {\n-                    self.need_type_info_err(body_id, span, ty).emit();\n+                    let mut err = self.need_type_info_err(body_id, span, ty, false);\n+                    self.note_obligation_cause(&mut err, obligation);\n+                    err.emit();\n                 }\n             }\n \n@@ -2018,21 +2020,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n                     // both must be type variables, or the other would've been instantiated\n                     assert!(a.is_ty_var() && b.is_ty_var());\n-                    self.need_type_info_err(body_id,\n-                                            obligation.cause.span,\n-                                            a).emit();\n+                    let mut err = self.need_type_info_err(body_id, span, a, false);\n+                    self.note_obligation_cause(&mut err, obligation);\n+                    err.emit();\n+                }\n+            }\n+            ty::Predicate::Projection(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+                let self_ty = trait_ref.self_ty();\n+                if predicate.references_error() {\n+                    return;\n                 }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, true);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                self.note_obligation_cause(&mut err, obligation);\n+                err.emit();\n             }\n \n             _ => {\n                 if !self.tcx.sess.has_errors() {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n-                        obligation.cause.span,\n+                        span,\n                         E0284,\n                         \"type annotations needed: cannot resolve `{}`\",\n                         predicate,\n                     );\n+                    err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n                     self.note_obligation_cause(&mut err, obligation);\n                     err.emit();\n                 }"}, {"sha": "c8f1e025baeb86babfea630b1df3a15a4747e2ef", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -5359,7 +5359,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty\n         } else {\n             if !self.is_tainted_by_errors() {\n-                self.need_type_info_err((**self).body_id, sp, ty)\n+                self.need_type_info_err((**self).body_id, sp, ty, false)\n                     .note(\"type must be known at this point\")\n                     .emit();\n             }"}, {"sha": "e5f1e2cc34cee38a2c6c7cebbdc3e3db6081b7b0", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -717,7 +717,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n     fn report_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n-                .need_type_info_err(Some(self.body.id()), self.span.to_span(self.tcx), t)\n+                .need_type_info_err(Some(self.body.id()), self.span.to_span(self.tcx), t, false)\n                 .emit();\n         }\n     }"}, {"sha": "dd6bde0c14d00114bef085b5efc9e9c7f793bfaf", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.stderr", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -1,18 +1,23 @@\n-error[E0284]: type annotations needed: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n+error[E0284]: type annotations needed\n   --> $DIR/associated-types-overridden-binding.rs:4:1\n    |\n LL | trait Foo: Iterator<Item = i32> {}\n    | ------------------------------- required by `Foo`\n LL | trait Bar: Foo<Item = u32> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for `Self`\n+   |\n+   = note: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n \n-error[E0282]: type annotations needed\n+error[E0284]: type annotations needed\n   --> $DIR/associated-types-overridden-binding.rs:7:1\n    |\n+LL | trait I32Iterator = Iterator<Item = i32>;\n+   | ----------------------------------------- required by `I32Iterator`\n LL | trait U32Iterator = I32Iterator<Item = u32>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for `Self`\n+   |\n+   = note: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0282, E0284.\n-For more information about an error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "14ce4836f97f8253f5f33b89d4991431116d4f26", "filename": "src/test/ui/associated-types/associated-types-unconstrained.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -1,8 +1,10 @@\n-error[E0284]: type annotations needed: cannot resolve `<_ as Foo>::A == _`\n+error[E0284]: type annotations needed\n   --> $DIR/associated-types-unconstrained.rs:14:20\n    |\n LL |     let x: isize = Foo::bar();\n-   |                    ^^^^^^^^\n+   |                    ^^^^^^^^ cannot infer type\n+   |\n+   = note: cannot resolve `<_ as Foo>::A == _`\n \n error: aborting due to previous error\n "}, {"sha": "5f23b4f559fadcc4ba02065080dcf29098c9f336", "filename": "src/test/ui/issues/issue-12028.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -1,8 +1,10 @@\n-error[E0284]: type annotations needed: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n+error[E0284]: type annotations needed\n   --> $DIR/issue-12028.rs:27:14\n    |\n LL |         self.input_stream(&mut stream);\n-   |              ^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^ cannot infer type for `H`\n+   |\n+   = note: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n \n error: aborting due to previous error\n "}, {"sha": "905c5ae9461d04be6d386d981f60a5225e21cede", "filename": "src/test/ui/issues/issue-65611.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -2,7 +2,10 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-65611.rs:59:20\n    |\n LL |     let x = buffer.last().unwrap().0.clone();\n-   |                    ^^^^ cannot infer type for `T`\n+   |                    ^^^^\n+   |                    |\n+   |                    cannot infer type for `T`\n+   |                    help: consider specifying the type argument in the method call: `last::<_>`\n    |\n    = note: type must be known at this point\n "}, {"sha": "2ef8618192f6b8d14570544c74ab45db51e2aead", "filename": "src/test/ui/question-mark-type-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -9,7 +9,7 @@ fn f(x: &i32) -> Result<i32, ()> {\n \n fn g() -> Result<Vec<i32>, ()> {\n     let l = [1, 2, 3, 4];\n-    l.iter().map(f).collect()? //~ ERROR type annotations needed: cannot resolve\n+    l.iter().map(f).collect()? //~ ERROR type annotations needed\n }\n \n fn main() {"}, {"sha": "d32d94976451ab6791c74cda487928efd8d2c28f", "filename": "src/test/ui/question-mark-type-infer.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -1,8 +1,13 @@\n-error[E0284]: type annotations needed: cannot resolve `<_ as std::ops::Try>::Ok == _`\n-  --> $DIR/question-mark-type-infer.rs:12:5\n+error[E0284]: type annotations needed\n+  --> $DIR/question-mark-type-infer.rs:12:21\n    |\n LL |     l.iter().map(f).collect()?\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     ^^^^^^^\n+   |                     |\n+   |                     cannot infer type\n+   |                     help: consider specifying the type argument in the method call: `collect::<_>`\n+   |\n+   = note: cannot resolve `<_ as std::ops::Try>::Ok == _`\n \n error: aborting due to previous error\n "}, {"sha": "d3292bbecbaaa4974e23fb1e2222d1d36fa6af98", "filename": "src/test/ui/span/issue-42234-unknown-receiver-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -9,8 +9,8 @@ fn shines_a_beacon_through_the_darkness() {\n }\n \n fn courier_to_des_moines_and_points_west(data: &[u32]) -> String {\n-    data.iter() //~ ERROR type annotations needed\n-        .sum::<_>()\n+    data.iter()\n+        .sum::<_>() //~ ERROR type annotations needed\n         .to_string()\n }\n "}, {"sha": "093a6f6f3ebac17afef2a673fa264ea69cf88a04", "filename": "src/test/ui/span/issue-42234-unknown-receiver-type.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.stderr?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -9,11 +9,10 @@ LL |     x.unwrap().method_that_could_exist_on_some_type();\n    = note: type must be known at this point\n \n error[E0282]: type annotations needed\n-  --> $DIR/issue-42234-unknown-receiver-type.rs:12:5\n+  --> $DIR/issue-42234-unknown-receiver-type.rs:13:10\n    |\n-LL | /     data.iter()\n-LL | |         .sum::<_>()\n-   | |___________________^ cannot infer type\n+LL |         .sum::<_>()\n+   |          ^^^ cannot infer type\n    |\n    = note: type must be known at this point\n "}, {"sha": "1efb2720e0c555531892c49961ca65f1a1c58532", "filename": "src/test/ui/span/type-annotations-needed-expr.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12af2561e9936add8fab4b96ff206b00a5877efe/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr?ref=12af2561e9936add8fab4b96ff206b00a5877efe", "patch": "@@ -2,7 +2,10 @@ error[E0282]: type annotations needed\n   --> $DIR/type-annotations-needed-expr.rs:2:39\n    |\n LL |     let _ = (vec![1,2,3]).into_iter().sum() as f64;\n-   |                                       ^^^ cannot infer type for `S`\n+   |                                       ^^^\n+   |                                       |\n+   |                                       cannot infer type for `S`\n+   |                                       help: consider specifying the type argument in the method call: `sum::<_>`\n    |\n    = note: type must be known at this point\n "}]}