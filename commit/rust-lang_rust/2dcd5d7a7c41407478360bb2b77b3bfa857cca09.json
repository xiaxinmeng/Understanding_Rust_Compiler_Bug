{"sha": "2dcd5d7a7c41407478360bb2b77b3bfa857cca09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkY2Q1ZDdhN2M0MTQwNzQ3ODM2MGJiMmI3N2IzYmZhODU3Y2NhMDk=", "commit": {"author": {"name": "Domantas Jadenkus", "email": "djadenkus@gmail.com", "date": "2021-02-14T10:06:42Z"}, "committer": {"name": "Domantas Jadenkus", "email": "djadenkus@gmail.com", "date": "2021-02-27T10:05:59Z"}, "message": "add generate_enum_into_method assist", "tree": {"sha": "de72733961b940716addf1bd66d0ce2312b24c3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de72733961b940716addf1bd66d0ce2312b24c3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dcd5d7a7c41407478360bb2b77b3bfa857cca09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dcd5d7a7c41407478360bb2b77b3bfa857cca09", "html_url": "https://github.com/rust-lang/rust/commit/2dcd5d7a7c41407478360bb2b77b3bfa857cca09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dcd5d7a7c41407478360bb2b77b3bfa857cca09/comments", "author": {"login": "jDomantas", "id": 8329015, "node_id": "MDQ6VXNlcjgzMjkwMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8329015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jDomantas", "html_url": "https://github.com/jDomantas", "followers_url": "https://api.github.com/users/jDomantas/followers", "following_url": "https://api.github.com/users/jDomantas/following{/other_user}", "gists_url": "https://api.github.com/users/jDomantas/gists{/gist_id}", "starred_url": "https://api.github.com/users/jDomantas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jDomantas/subscriptions", "organizations_url": "https://api.github.com/users/jDomantas/orgs", "repos_url": "https://api.github.com/users/jDomantas/repos", "events_url": "https://api.github.com/users/jDomantas/events{/privacy}", "received_events_url": "https://api.github.com/users/jDomantas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jDomantas", "id": 8329015, "node_id": "MDQ6VXNlcjgzMjkwMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8329015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jDomantas", "html_url": "https://github.com/jDomantas", "followers_url": "https://api.github.com/users/jDomantas/followers", "following_url": "https://api.github.com/users/jDomantas/following{/other_user}", "gists_url": "https://api.github.com/users/jDomantas/gists{/gist_id}", "starred_url": "https://api.github.com/users/jDomantas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jDomantas/subscriptions", "organizations_url": "https://api.github.com/users/jDomantas/orgs", "repos_url": "https://api.github.com/users/jDomantas/repos", "events_url": "https://api.github.com/users/jDomantas/events{/privacy}", "received_events_url": "https://api.github.com/users/jDomantas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ab285a8e5326211c142e8c772d364a35fbbc409", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ab285a8e5326211c142e8c772d364a35fbbc409", "html_url": "https://github.com/rust-lang/rust/commit/4ab285a8e5326211c142e8c772d364a35fbbc409"}], "stats": {"total": 295, "additions": 275, "deletions": 20}, "files": [{"sha": "25565d4cc4c60f580a90bcbd1957d1519d0308b5", "filename": "crates/ide_assists/src/handlers/generate_enum_match_method.rs", "status": "modified", "additions": 245, "deletions": 20, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/2dcd5d7a7c41407478360bb2b77b3bfa857cca09/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcd5d7a7c41407478360bb2b77b3bfa857cca09/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs?ref=2dcd5d7a7c41407478360bb2b77b3bfa857cca09", "patch": "@@ -1,3 +1,4 @@\n+use itertools::Itertools;\n use stdx::{format_to, to_lower_snake_case};\n use syntax::ast::VisibilityOwner;\n use syntax::ast::{self, AstNode, NameOwner};\n@@ -88,14 +89,104 @@ pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext) ->\n     )\n }\n \n+// Assist: generate_enum_into_method\n+//\n+// Generate an `into_` method for an enum variant.\n+//\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String)$0,\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String),\n+// }\n+//\n+// impl Value {\n+//     fn into_text(self) -> Option<String> {\n+//         if let Self::Text(v) = self {\n+//             Some(v)\n+//         } else {\n+//             None\n+//         }\n+//     }\n+// }\n+// ```\n+pub(crate) fn generate_enum_into_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n+    let variant_name = variant.name()?;\n+    let parent_enum = ast::Adt::Enum(variant.parent_enum());\n+    let variant_kind = variant_kind(&variant);\n+\n+    let fn_name = format!(\"into_{}\", &to_lower_snake_case(variant_name.text()));\n+\n+    // Return early if we've found an existing new fn\n+    let impl_def = find_struct_impl(\n+        &ctx,\n+        &parent_enum,\n+        &fn_name,\n+    )?;\n+\n+    let field_type = variant_kind.single_field_type()?;\n+    let (pattern_suffix, bound_name) = variant_kind.binding_pattern()?;\n+\n+    let target = variant.syntax().text_range();\n+    acc.add(\n+        AssistId(\"generate_enum_into_method\", AssistKind::Generate),\n+        \"Generate an `into_` method for an enum variant\",\n+        target,\n+        |builder| {\n+            let mut buf = String::with_capacity(512);\n+\n+            if impl_def.is_some() {\n+                buf.push('\\n');\n+            }\n+\n+            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+            format_to!(\n+                buf,\n+                \"    {}fn {}(self) -> Option<{}> {{\n+        if let Self::{}{} = self {{\n+            Some({})\n+        }} else {{\n+            None\n+        }}\n+    }}\",\n+                vis,\n+                fn_name,\n+                field_type.syntax(),\n+                variant_name,\n+                pattern_suffix,\n+                bound_name,\n+            );\n+\n+            let start_offset = impl_def\n+                .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))\n+                .unwrap_or_else(|| {\n+                    buf = generate_impl_text(&parent_enum, &buf);\n+                    parent_enum.syntax().text_range().end()\n+                });\n+\n+            builder.insert(start_offset, buf);\n+        },\n+    )\n+}\n+\n enum VariantKind {\n     Unit,\n     /// Tuple with a single field\n-    NewtypeTuple,\n+    NewtypeTuple { ty: Option<ast::Type> },\n     /// Tuple with 0 or more than 2 fields\n     Tuple,\n     /// Record with a single field\n-    NewtypeRecord { field_name: Option<ast::Name> },\n+    NewtypeRecord {\n+        field_name: Option<ast::Name>,\n+        field_type: Option<ast::Type>,\n+    },\n     /// Record with 0 or more than 2 fields\n     Record,\n }\n@@ -104,27 +195,57 @@ impl VariantKind {\n     fn pattern_suffix(&self) -> &'static str {\n         match self {\n             VariantKind::Unit => \"\",\n-            VariantKind::NewtypeTuple |\n+            VariantKind::NewtypeTuple { .. } |\n             VariantKind::Tuple => \"(..)\",\n             VariantKind::NewtypeRecord { .. } |\n             VariantKind::Record => \" { .. }\",\n         }\n     }\n+\n+    fn binding_pattern(&self) -> Option<(String, String)> {\n+        match self {\n+            VariantKind::Unit |\n+            VariantKind::Tuple |\n+            VariantKind::Record |\n+            VariantKind::NewtypeRecord { field_name: None, .. } => None,\n+            VariantKind::NewtypeTuple { .. } => {\n+                Some((\"(v)\".to_owned(), \"v\".to_owned()))\n+            }\n+            VariantKind::NewtypeRecord { field_name: Some(name), .. } => {\n+                Some((\n+                    format!(\" {{ {} }}\", name.syntax()),\n+                    name.syntax().to_string(),\n+                ))\n+            }\n+        }\n+    }\n+\n+    fn single_field_type(&self) -> Option<&ast::Type> {\n+        match self {\n+            VariantKind::Unit |\n+            VariantKind::Tuple |\n+            VariantKind::Record => None,\n+            VariantKind::NewtypeTuple { ty } => ty.as_ref(),\n+            VariantKind::NewtypeRecord { field_type, .. } => field_type.as_ref(),\n+        }\n+    }\n }\n \n fn variant_kind(variant: &ast::Variant) -> VariantKind {\n     match variant.kind() {\n         ast::StructKind::Record(record) => {\n-            if record.fields().count() == 1 {\n-                let field_name = record.fields().nth(0).unwrap().name();\n-                VariantKind::NewtypeRecord { field_name }\n+            if let Some((single_field,)) = record.fields().collect_tuple() {\n+                let field_name = single_field.name();\n+                let field_type = single_field.ty();\n+                VariantKind::NewtypeRecord { field_name, field_type }\n             } else {\n                 VariantKind::Record\n             }\n         }\n         ast::StructKind::Tuple(tuple) => {\n-            if tuple.fields().count() == 1 {\n-                VariantKind::NewtypeTuple\n+            if let Some((single_field,)) = tuple.fields().collect_tuple() {\n+                let ty = single_field.ty();\n+                VariantKind::NewtypeTuple { ty }\n             } else {\n                 VariantKind::Tuple\n             }\n@@ -139,12 +260,8 @@ mod tests {\n \n     use super::*;\n \n-    fn check_not_applicable(ra_fixture: &str) {\n-        check_assist_not_applicable(generate_enum_is_method, ra_fixture)\n-    }\n-\n     #[test]\n-    fn test_generate_enum_match_from_variant() {\n+    fn test_generate_enum_is_from_variant() {\n         check_assist(\n             generate_enum_is_method,\n             r#\"\n@@ -169,8 +286,9 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_generate_enum_match_already_implemented() {\n-        check_not_applicable(\n+    fn test_generate_enum_is_already_implemented() {\n+        check_assist_not_applicable(\n+            generate_enum_is_method,\n             r#\"\n enum Variant {\n     Undefined,\n@@ -187,7 +305,7 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_generate_enum_match_from_tuple_variant() {\n+    fn test_generate_enum_is_from_tuple_variant() {\n         check_assist(\n             generate_enum_is_method,\n             r#\"\n@@ -212,7 +330,7 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_generate_enum_match_from_record_variant() {\n+    fn test_generate_enum_is_from_record_variant() {\n         check_assist(\n             generate_enum_is_method,\n             r#\"\n@@ -237,7 +355,7 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_generate_enum_match_from_variant_with_one_variant() {\n+    fn test_generate_enum_is_from_variant_with_one_variant() {\n         check_assist(\n             generate_enum_is_method,\n             r#\"enum Variant { Undefi$0ned }\"#,\n@@ -254,7 +372,7 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_generate_enum_match_from_variant_with_visibility_marker() {\n+    fn test_generate_enum_is_from_variant_with_visibility_marker() {\n         check_assist(\n             generate_enum_is_method,\n             r#\"\n@@ -279,7 +397,7 @@ impl Variant {\n     }\n \n     #[test]\n-    fn test_multiple_generate_enum_match_from_variant() {\n+    fn test_multiple_generate_enum_is_from_variant() {\n         check_assist(\n             generate_enum_is_method,\n             r#\"\n@@ -311,6 +429,113 @@ impl Variant {\n     fn is_major(&self) -> bool {\n         matches!(self, Self::Major)\n     }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_tuple_variant() {\n+        check_assist(\n+            generate_enum_into_method,\n+            r#\"\n+enum Value {\n+    Number(i32),\n+    Text(String)$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+}\n+\n+impl Value {\n+    fn into_text(self) -> Option<String> {\n+        if let Self::Text(v) = self {\n+            Some(v)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_already_implemented() {\n+        check_assist_not_applicable(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String)$0,\n+}\n+\n+impl Value {\n+    fn into_text(self) -> Option<String> {\n+        if let Self::Text(v) = self {\n+            Some(v)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_unit_variant() {\n+        check_assist_not_applicable(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+    Unit$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_record_with_multiple_fields() {\n+        check_assist_not_applicable(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+    Both { first: i32, second: String }$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_tuple_with_multiple_fields() {\n+        check_assist_not_applicable(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String, String)$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_record_variant() {\n+        check_assist(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String }$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String },\n+}\n+\n+impl Value {\n+    fn into_text(self) -> Option<String> {\n+        if let Self::Text { text } = self {\n+            Some(text)\n+        } else {\n+            None\n+        }\n+    }\n }\"#,\n         );\n     }"}, {"sha": "2ce59e39a9211ffb933500b9dfe408d3ee95619a", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dcd5d7a7c41407478360bb2b77b3bfa857cca09/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcd5d7a7c41407478360bb2b77b3bfa857cca09/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=2dcd5d7a7c41407478360bb2b77b3bfa857cca09", "patch": "@@ -190,6 +190,7 @@ mod handlers {\n             generate_default_from_enum_variant::generate_default_from_enum_variant,\n             generate_derive::generate_derive,\n             generate_enum_match_method::generate_enum_is_method,\n+            generate_enum_match_method::generate_enum_into_method,\n             generate_from_impl_for_enum::generate_from_impl_for_enum,\n             generate_function::generate_function,\n             generate_getter::generate_getter,"}, {"sha": "39f48dd760592404ff50b1a7d745aabcf3413ccd", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2dcd5d7a7c41407478360bb2b77b3bfa857cca09/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcd5d7a7c41407478360bb2b77b3bfa857cca09/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=2dcd5d7a7c41407478360bb2b77b3bfa857cca09", "patch": "@@ -482,6 +482,35 @@ struct Point {\n     )\n }\n \n+#[test]\n+fn doctest_generate_enum_into_method() {\n+    check_doc_test(\n+        \"generate_enum_into_method\",\n+        r#####\"\n+enum Value {\n+ Number(i32),\n+ Text(String)$0,\n+}\n+\"#####,\n+        r#####\"\n+enum Value {\n+ Number(i32),\n+ Text(String),\n+}\n+\n+impl Value {\n+    fn into_text(self) -> Option<String> {\n+        if let Self::Text(v) = self {\n+            Some(v)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_generate_enum_is_method() {\n     check_doc_test("}]}