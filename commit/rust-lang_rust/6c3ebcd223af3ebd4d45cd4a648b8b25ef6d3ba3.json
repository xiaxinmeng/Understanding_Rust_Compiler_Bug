{"sha": "6c3ebcd223af3ebd4d45cd4a648b8b25ef6d3ba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjM2ViY2QyMjNhZjNlYmQ0ZDQ1Y2Q0YTY0OGI4YjI1ZWY2ZDNiYTM=", "commit": {"author": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-05-30T19:00:37Z"}, "committer": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-05-30T19:00:37Z"}, "message": "make Layout's align a NonZeroUsize", "tree": {"sha": "46931af1cd75955b6d9dffac113dc49a7a0e4c5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46931af1cd75955b6d9dffac113dc49a7a0e4c5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c3ebcd223af3ebd4d45cd4a648b8b25ef6d3ba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c3ebcd223af3ebd4d45cd4a648b8b25ef6d3ba3", "html_url": "https://github.com/rust-lang/rust/commit/6c3ebcd223af3ebd4d45cd4a648b8b25ef6d3ba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c3ebcd223af3ebd4d45cd4a648b8b25ef6d3ba3/comments", "author": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74d09399c1289a20b1c258153f005f2604f9ec46", "url": "https://api.github.com/repos/rust-lang/rust/commits/74d09399c1289a20b1c258153f005f2604f9ec46", "html_url": "https://github.com/rust-lang/rust/commit/74d09399c1289a20b1c258153f005f2604f9ec46"}], "stats": {"total": 74, "additions": 38, "deletions": 36}, "files": [{"sha": "064c7514112b50d20e9a6d2880c18f383cfd2888", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6c3ebcd223af3ebd4d45cd4a648b8b25ef6d3ba3/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3ebcd223af3ebd4d45cd4a648b8b25ef6d3ba3/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=6c3ebcd223af3ebd4d45cd4a648b8b25ef6d3ba3", "patch": "@@ -20,6 +20,7 @@ use fmt;\n use mem;\n use usize;\n use ptr::{self, NonNull};\n+use num::NonZeroUsize;\n \n extern {\n     /// An opaque, unsized type. Used for pointers to allocated memory.\n@@ -66,7 +67,7 @@ fn size_align<T>() -> (usize, usize) {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Layout {\n     // size of the requested block of memory, measured in bytes.\n-    size: usize,\n+    size_: usize,\n \n     // alignment of the requested block of memory, measured in bytes.\n     // we ensure that this is always a power-of-two, because API's\n@@ -75,17 +76,12 @@ pub struct Layout {\n     //\n     // (However, we do not analogously require `align >= sizeof(void*)`,\n     //  even though that is *also* a requirement of `posix_memalign`.)\n-    align: usize,\n+    align_: NonZeroUsize,\n }\n \n-\n-// FIXME: audit default implementations for overflow errors,\n-// (potentially switching to overflowing_add and\n-//  overflowing_mul as necessary).\n-\n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `None` if either of the following conditions\n+    /// or returns `LayoutErr` if either of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must be a power of two,\n@@ -126,23 +122,23 @@ impl Layout {\n     ///\n     /// # Safety\n     ///\n-    /// This function is unsafe as it does not verify that `align` is\n-    /// a power-of-two nor `size` aligned to `align` fits within the\n-    /// address space (i.e. the `Layout::from_size_align` preconditions).\n+    /// This function is unsafe as it does not verify the preconditions from\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n     #[inline]\n     pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        Layout { size: size, align: align }\n+        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n     #[inline]\n-    pub fn size(&self) -> usize { self.size }\n+    pub fn size(&self) -> usize { self.size_ }\n \n     /// The minimum byte alignment for a memory block of this layout.\n     #[inline]\n-    pub fn align(&self) -> usize { self.align }\n+    pub fn align(&self) -> usize { self.align_.get() }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n+    #[inline]\n     pub fn new<T>() -> Self {\n         let (size, align) = size_align::<T>();\n         // Note that the align is guaranteed by rustc to be a power of two and\n@@ -158,6 +154,7 @@ impl Layout {\n     /// Produces layout describing a record that could be used to\n     /// allocate backing structure for `T` (which could be a trait\n     /// or other unsized type like a slice).\n+    #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n         // See rationale in `new` for why this us using an unsafe variant below\n@@ -181,18 +178,19 @@ impl Layout {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the combination of `self.size` and the given `align`\n-    /// violates the conditions listed in `from_size_align`.\n+    /// Panics if the combination of `self.size()` and the given `align`\n+    /// violates the conditions listed in\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n     #[inline]\n     pub fn align_to(&self, align: usize) -> Self {\n-        Layout::from_size_align(self.size, cmp::max(self.align, align)).unwrap()\n+        Layout::from_size_align(self.size(), cmp::max(self.align(), align)).unwrap()\n     }\n \n     /// Returns the amount of padding we must insert after `self`\n     /// to ensure that the following address will satisfy `align`\n     /// (measured in bytes).\n     ///\n-    /// E.g. if `self.size` is 9, then `self.padding_needed_for(4)`\n+    /// E.g. if `self.size()` is 9, then `self.padding_needed_for(4)`\n     /// returns 3, because that is the minimum number of bytes of\n     /// padding required to get a 4-aligned address (assuming that the\n     /// corresponding memory block starts at a 4-aligned address).\n@@ -203,9 +201,12 @@ impl Layout {\n     /// Note that the utility of the returned value requires `align`\n     /// to be less than or equal to the alignment of the starting\n     /// address for the whole allocated block of memory. One way to\n-    /// satisfy this constraint is to ensure `align <= self.align`.\n+    /// satisfy this constraint is to ensure `align <= self.align()`.\n     #[inline]\n     pub fn padding_needed_for(&self, align: usize) -> usize {\n+        // **FIXME**: This function is only called with proper power-of-two\n+        // alignments. Maybe we should turn this into a real assert!.\n+        debug_assert!(align.is_power_of_two());\n         let len = self.size();\n \n         // Rounded up value is:\n@@ -227,7 +228,8 @@ impl Layout {\n         // size and padding overflow in the above manner should cause\n         // the allocator to yield an error anyway.)\n \n-        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n+        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1)\n+            & !align.wrapping_sub(1);\n         return len_rounded_up.wrapping_sub(len);\n     }\n \n@@ -238,14 +240,14 @@ impl Layout {\n     /// layout of the array and `offs` is the distance between the start\n     /// of each element in the array.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n-        let padded_size = self.size.checked_add(self.padding_needed_for(self.align))\n+        let padded_size = self.size().checked_add(self.padding_needed_for(self.align()))\n             .ok_or(LayoutErr { private: () })?;\n         let alloc_size = padded_size.checked_mul(n)\n             .ok_or(LayoutErr { private: () })?;\n-        Ok((Layout::from_size_align(alloc_size, self.align)?, padded_size))\n+        Ok((Layout::from_size_align(alloc_size, self.align())?, padded_size))\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -258,16 +260,16 @@ impl Layout {\n     /// start of the `next` embedded within the concatenated record\n     /// (assuming that the record itself starts at offset 0).\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n     pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n-        let new_align = cmp::max(self.align, next.align);\n-        let realigned = Layout::from_size_align(self.size, new_align)?;\n+        let new_align = cmp::max(self.align(), next.align());\n+        let realigned = Layout::from_size_align(self.size(), new_align)?;\n \n-        let pad = realigned.padding_needed_for(next.align);\n+        let pad = realigned.padding_needed_for(next.align());\n \n-        let offset = self.size.checked_add(pad)\n+        let offset = self.size().checked_add(pad)\n             .ok_or(LayoutErr { private: () })?;\n-        let new_size = offset.checked_add(next.size)\n+        let new_size = offset.checked_add(next.size())\n             .ok_or(LayoutErr { private: () })?;\n \n         let layout = Layout::from_size_align(new_size, new_align)?;\n@@ -285,10 +287,10 @@ impl Layout {\n     /// guaranteed that all elements in the array will be properly\n     /// aligned.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n     pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n         let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n-        Layout::from_size_align(size, self.align)\n+        Layout::from_size_align(size, self.align())\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -305,17 +307,17 @@ impl Layout {\n     ///  signature out of convenience in matching the signature of\n     ///  `extend`.)\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n     pub fn extend_packed(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_size = self.size().checked_add(next.size())\n             .ok_or(LayoutErr { private: () })?;\n-        let layout = Layout::from_size_align(new_size, self.align)?;\n+        let layout = Layout::from_size_align(new_size, self.align())?;\n         Ok((layout, self.size()))\n     }\n \n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n     pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n         Layout::new::<T>()\n             .repeat(n)\n@@ -834,7 +836,7 @@ pub unsafe trait Alloc {\n                             layout: Layout,\n                             new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size >= layout.size);\n+        debug_assert!(new_size >= layout.size());\n         let (_l, u) = self.usable_size(&layout);\n         // _l <= layout.size()                       [guaranteed by usable_size()]\n         //       layout.size() <= new_layout.size()  [required by this method]\n@@ -889,7 +891,7 @@ pub unsafe trait Alloc {\n                               layout: Layout,\n                               new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size <= layout.size);\n+        debug_assert!(new_size <= layout.size());\n         let (l, _u) = self.usable_size(&layout);\n         //                      layout.size() <= _u  [guaranteed by usable_size()]\n         // new_layout.size() <= layout.size()        [required by this method]"}]}