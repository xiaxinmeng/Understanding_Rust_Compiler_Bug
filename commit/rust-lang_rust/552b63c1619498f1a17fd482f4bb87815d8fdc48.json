{"sha": "552b63c1619498f1a17fd482f4bb87815d8fdc48", "node_id": "C_kwDOAAsO6NoAKDU1MmI2M2MxNjE5NDk4ZjFhMTdmZDQ4MmY0YmI4NzgxNWQ4ZmRjNDg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-05T12:55:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-05T12:55:36Z"}, "message": "Auto merge of #2715 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "3463b86894affc4a8aee0f10ac9dcfbe0cdc4de1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3463b86894affc4a8aee0f10ac9dcfbe0cdc4de1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/552b63c1619498f1a17fd482f4bb87815d8fdc48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/552b63c1619498f1a17fd482f4bb87815d8fdc48", "html_url": "https://github.com/rust-lang/rust/commit/552b63c1619498f1a17fd482f4bb87815d8fdc48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/552b63c1619498f1a17fd482f4bb87815d8fdc48/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faec28970f86f52ca37e0e8cec0a447ba2f1393b", "url": "https://api.github.com/repos/rust-lang/rust/commits/faec28970f86f52ca37e0e8cec0a447ba2f1393b", "html_url": "https://github.com/rust-lang/rust/commit/faec28970f86f52ca37e0e8cec0a447ba2f1393b"}, {"sha": "7481ba7746fc5f5b82aaff0fe20cbf55c48d8fd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7481ba7746fc5f5b82aaff0fe20cbf55c48d8fd9", "html_url": "https://github.com/rust-lang/rust/commit/7481ba7746fc5f5b82aaff0fe20cbf55c48d8fd9"}], "stats": {"total": 5900, "additions": 3309, "deletions": 2591}, "files": [{"sha": "b93166b80a570846a57782b7d2758e6eab859aca", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -309,7 +309,7 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-apple-various\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n@@ -320,7 +320,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-x86_64-apple-alt\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n@@ -331,7 +331,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-apple-1\n             env:\n               SCRIPT: \"./x.py --stage 2 test --exclude src/test/ui --exclude src/test/rustdoc --exclude src/test/run-make-fulldeps\"\n@@ -342,7 +342,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-apple-2\n             env:\n               SCRIPT: \"./x.py --stage 2 test src/test/ui src/test/rustdoc src/test/run-make-fulldeps\"\n@@ -353,7 +353,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-aarch64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n@@ -368,7 +368,7 @@ jobs:\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n               JEMALLOC_SYS_WITH_LG_PAGE: 14\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\""}, {"sha": "dae79e5bc260c4ea78f31ef73b5147120f5dcb0a", "filename": "Cargo.lock", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -92,6 +92,15 @@ version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n+[[package]]\n+name = \"ar_archive_writer\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"276881980556fdadeb88aa1ffc667e4d2e8fe72531dfabcb7a82bb3c9ea9ba31\"\n+dependencies = [\n+ \"object\",\n+]\n+\n [[package]]\n name = \"array_tool\"\n version = \"1.0.3\"\n@@ -906,9 +915,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"cpufeatures\"\n-version = \"0.2.1\"\n+version = \"0.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95059428f66df56b63431fdb4e1947ed2190586af5c5a8a8b71122bdf5a7f469\"\n+checksum = \"28d997bd5e24a5928dd43e46dc529867e207907fe0b239c3477d924f7f2ca320\"\n dependencies = [\n  \"libc\",\n ]\n@@ -1085,12 +1094,6 @@ version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8\"\n \n-[[package]]\n-name = \"difference\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n-\n [[package]]\n name = \"digest\"\n version = \"0.10.2\"\n@@ -1162,6 +1165,12 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"dissimilar\"\n+version = \"1.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8c97b9233581d84b8e1e689cdd3a47b6f69770084fc246e86a7f78b0d9c1d4a5\"\n+\n [[package]]\n name = \"dlmalloc\"\n version = \"0.2.3\"\n@@ -1283,11 +1292,11 @@ dependencies = [\n \n [[package]]\n name = \"expect-test\"\n-version = \"1.0.1\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ceb96f3eaa0d4e8769c52dacfd4eb60183b817ed2f176171b3c691d5022b0f2e\"\n+checksum = \"1d4661aca38d826eb7c72fe128e4238220616de4c0cc00db7bfc38e2e1364dd3\"\n dependencies = [\n- \"difference\",\n+ \"dissimilar\",\n  \"once_cell\",\n ]\n \n@@ -3495,6 +3504,7 @@ dependencies = [\n name = \"rustc_codegen_ssa\"\n version = \"0.0.0\"\n dependencies = [\n+ \"ar_archive_writer\",\n  \"bitflags\",\n  \"cc\",\n  \"itertools\","}, {"sha": "fa4b725a0ee50ef723ce5292865e54de7b0bfca4", "filename": "LICENSES/LLVM-exception.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/LICENSES%2FLLVM-exception.txt", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/LICENSES%2FLLVM-exception.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FLLVM-exception.txt?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,15 @@\n+---- LLVM Exceptions to the Apache 2.0 License ----\n+\n+   As an exception, if, as a result of your compiling your source code, portions\n+   of this Software are embedded into an Object form of such source code, you\n+   may redistribute such embedded portions in such Object form without complying\n+   with the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n+\n+   In addition, if you combine or link compiled forms of this Software with\n+   software that is licensed under the GPLv2 (\"Combined Software\") and if a\n+   court of competent jurisdiction determines that the patent provision (Section\n+   3), the indemnity provision (Section 9) or other Section of the License\n+   conflicts with the conditions of the GPLv2, you may retroactively and\n+   prospectively choose to deem waived or otherwise exclude such Section(s) of\n+   the License, but only in their entirety and only with respect to the Combined\n+   Software."}, {"sha": "9c2cf58efed4a30ef37d0f522a1b6d6ba96c6e03", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -354,7 +354,7 @@ pub trait LayoutCalculator {\n                 if !always_sized { StructKind::MaybeUnsized } else { StructKind::AlwaysSized }\n             };\n \n-            let mut st = self.univariant(dl, &variants[v], &repr, kind)?;\n+            let mut st = self.univariant(dl, &variants[v], repr, kind)?;\n             st.variants = Variants::Single { index: v };\n \n             if is_unsafe_cell {\n@@ -457,7 +457,7 @@ pub trait LayoutCalculator {\n             let mut variant_layouts = variants\n                 .iter_enumerated()\n                 .map(|(j, v)| {\n-                    let mut st = self.univariant(dl, v, &repr, StructKind::AlwaysSized)?;\n+                    let mut st = self.univariant(dl, v, repr, StructKind::AlwaysSized)?;\n                     st.variants = Variants::Single { index: j };\n \n                     align = align.max(st.align);\n@@ -647,8 +647,8 @@ pub trait LayoutCalculator {\n             .map(|(i, field_layouts)| {\n                 let mut st = self.univariant(\n                     dl,\n-                    &field_layouts,\n-                    &repr,\n+                    field_layouts,\n+                    repr,\n                     StructKind::Prefixed(min_ity.size(), prefix_align),\n                 )?;\n                 st.variants = Variants::Single { index: i };\n@@ -755,7 +755,7 @@ pub trait LayoutCalculator {\n             // Try to use a ScalarPair for all tagged enums.\n             let mut common_prim = None;\n             let mut common_prim_initialized_in_all_variants = true;\n-            for (field_layouts, layout_variant) in iter::zip(&*variants, &layout_variants) {\n+            for (field_layouts, layout_variant) in iter::zip(variants, &layout_variants) {\n                 let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n                     panic!();\n                 };"}, {"sha": "4d80f904ac461beafd03f212c83931e981fa1cff", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1179,7 +1179,7 @@ impl Expr {\n     pub fn peel_parens(&self) -> &Expr {\n         let mut expr = self;\n         while let ExprKind::Paren(inner) = &expr.kind {\n-            expr = &inner;\n+            expr = inner;\n         }\n         expr\n     }\n@@ -1312,8 +1312,10 @@ pub struct Closure {\n     pub movability: Movability,\n     pub fn_decl: P<FnDecl>,\n     pub body: P<Expr>,\n-    /// The span of the argument block `|...|`.\n+    /// The span of the declaration block: 'move |...| -> ...'\n     pub fn_decl_span: Span,\n+    /// The span of the argument block `|...|`\n+    pub fn_arg_span: Span,\n }\n \n /// Limit types of a range (inclusive or exclusive)\n@@ -2027,7 +2029,7 @@ impl Ty {\n     pub fn peel_refs(&self) -> &Self {\n         let mut final_ty = self;\n         while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n-            final_ty = &ty;\n+            final_ty = ty;\n         }\n         final_ty\n     }"}, {"sha": "a45ee6067bbaedb5c541d91dd2ccff91f23228e1", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -736,8 +736,7 @@ pub fn visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n             return; // Avoid visiting the span for the second time.\n         }\n         token::Interpolated(nt) => {\n-            let mut nt = Lrc::make_mut(nt);\n-            visit_nonterminal(&mut nt, vis);\n+            visit_nonterminal(Lrc::make_mut(nt), vis);\n         }\n         _ => {}\n     }\n@@ -1368,6 +1367,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             fn_decl,\n             body,\n             fn_decl_span,\n+            fn_arg_span: _,\n         }) => {\n             vis.visit_closure_binder(binder);\n             vis.visit_asyncness(asyncness);"}, {"sha": "482c302950f01ae7e20b16002afb4b4e114e97f1", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -64,7 +64,7 @@ impl TokenTree {\n         match (self, other) {\n             (TokenTree::Token(token, _), TokenTree::Token(token2, _)) => token.kind == token2.kind,\n             (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n-                delim == delim2 && tts.eq_unspanned(&tts2)\n+                delim == delim2 && tts.eq_unspanned(tts2)\n             }\n             _ => false,\n         }\n@@ -402,7 +402,7 @@ impl TokenStream {\n         let mut t1 = self.trees();\n         let mut t2 = other.trees();\n         for (t1, t2) in iter::zip(&mut t1, &mut t2) {\n-            if !t1.eq_unspanned(&t2) {\n+            if !t1.eq_unspanned(t2) {\n                 return false;\n             }\n         }\n@@ -475,7 +475,7 @@ impl TokenStream {\n             token::Interpolated(nt) => TokenTree::Delimited(\n                 DelimSpan::from_single(token.span),\n                 Delimiter::Invisible,\n-                TokenStream::from_nonterminal_ast(&nt).flattened(),\n+                TokenStream::from_nonterminal_ast(nt).flattened(),\n             ),\n             _ => TokenTree::Token(token.clone(), spacing),\n         }\n@@ -511,7 +511,7 @@ impl TokenStream {\n     fn try_glue_to_last(vec: &mut Vec<TokenTree>, tt: &TokenTree) -> bool {\n         if let Some(TokenTree::Token(last_tok, Spacing::Joint)) = vec.last()\n             && let TokenTree::Token(tok, spacing) = tt\n-            && let Some(glued_tok) = last_tok.glue(&tok)\n+            && let Some(glued_tok) = last_tok.glue(tok)\n         {\n             // ...then overwrite the last token tree in `vec` with the\n             // glued token, and skip the first token tree from `stream`."}, {"sha": "cdc244c12181d78e6209006a85d4abf71f962660", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -21,6 +21,7 @@ pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n             | ast::ExprKind::Loop(..)\n             | ast::ExprKind::ForLoop(..)\n             | ast::ExprKind::TryBlock(..)\n+            | ast::ExprKind::ConstBlock(..)\n     )\n }\n "}, {"sha": "35454c3a6709224ce20ca3a20d2d915824047895", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -110,7 +110,7 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         } else {\n             &mut lines\n         };\n-        if let Some(horizontal) = get_horizontal_trim(&lines, kind) {\n+        if let Some(horizontal) = get_horizontal_trim(lines, kind) {\n             changes = true;\n             // remove a \"[ \\t]*\\*\" block from each line, if possible\n             for line in lines.iter_mut() {\n@@ -147,7 +147,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n \n fn trim_whitespace_prefix(s: &str, col: CharPos) -> &str {\n     let len = s.len();\n-    match all_whitespace(&s, col) {\n+    match all_whitespace(s, col) {\n         Some(col) => {\n             if col < len {\n                 &s[col..]"}, {"sha": "f6f186b51073b788d46438e87583c6afbcb755bc", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -52,14 +52,14 @@ impl LitKind {\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the token.\n                 let s = symbol.as_str();\n-                let symbol = if s.contains(&['\\\\', '\\r']) {\n+                let symbol = if s.contains(['\\\\', '\\r']) {\n                     let mut buf = String::with_capacity(s.len());\n                     let mut error = Ok(());\n                     // Force-inlining here is aggressive but the closure is\n                     // called on every char in the string, so it can be\n                     // hot in programs with many long strings.\n                     unescape_literal(\n-                        &s,\n+                        s,\n                         Mode::Str,\n                         &mut #[inline(always)]\n                         |_, unescaped_char| match unescaped_char {\n@@ -85,7 +85,7 @@ impl LitKind {\n                     if s.contains('\\r') {\n                         let mut buf = String::with_capacity(s.len());\n                         let mut error = Ok(());\n-                        unescape_literal(&s, Mode::RawStr, &mut |_, unescaped_char| {\n+                        unescape_literal(s, Mode::RawStr, &mut |_, unescaped_char| {\n                             match unescaped_char {\n                                 Ok(c) => buf.push(c),\n                                 Err(err) => {\n@@ -106,7 +106,7 @@ impl LitKind {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_literal(&s, Mode::ByteStr, &mut |_, c| match c {\n+                unescape_literal(s, Mode::ByteStr, &mut |_, c| match c {\n                     Ok(c) => buf.push(byte_from_char(c)),\n                     Err(err) => {\n                         if err.is_fatal() {\n@@ -122,7 +122,7 @@ impl LitKind {\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_literal(&s, Mode::RawByteStr, &mut |_, c| match c {\n+                    unescape_literal(s, Mode::RawByteStr, &mut |_, c| match c {\n                         Ok(c) => buf.push(byte_from_char(c)),\n                         Err(err) => {\n                             if err.is_fatal() {"}, {"sha": "819f1884a06922ca5861679de032dde2b2db47a7", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -384,7 +384,7 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n         | ast::ExprKind::AssignOp(_, lhs, rhs)\n         | ast::ExprKind::Binary(_, lhs, rhs) => {\n             // X { y: 1 } + X { y: 2 }\n-            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+            contains_exterior_struct_lit(lhs) || contains_exterior_struct_lit(rhs)\n         }\n         ast::ExprKind::Await(x)\n         | ast::ExprKind::Unary(_, x)\n@@ -393,12 +393,12 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n         | ast::ExprKind::Field(x, _)\n         | ast::ExprKind::Index(x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n-            contains_exterior_struct_lit(&x)\n+            contains_exterior_struct_lit(x)\n         }\n \n         ast::ExprKind::MethodCall(box ast::MethodCall { receiver, .. }) => {\n             // X { y: 1 }.bar(...)\n-            contains_exterior_struct_lit(&receiver)\n+            contains_exterior_struct_lit(receiver)\n         }\n \n         _ => false,"}, {"sha": "0eae791b25e1c66e8da0b93bdfefa0ce7c5585bb", "filename": "compiler/rustc_ast/src/util/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -17,7 +17,7 @@ pub fn contains_text_flow_control_chars(s: &str) -> bool {\n     // U+2069 - E2 81 A9\n     let mut bytes = s.as_bytes();\n     loop {\n-        match core::slice::memchr::memchr(0xE2, &bytes) {\n+        match core::slice::memchr::memchr(0xE2, bytes) {\n             Some(idx) => {\n                 // bytes are valid UTF-8 -> E2 must be followed by two bytes\n                 let ch = &bytes[idx..idx + 3];"}, {"sha": "991eb489f6ba3ee115fbf7f8b8dcf691226adf48", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -840,6 +840,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             fn_decl,\n             body,\n             fn_decl_span: _,\n+            fn_arg_span: _,\n         }) => {\n             visitor.visit_fn(FnKind::Closure(binder, fn_decl, body), expression.span, expression.id)\n         }"}, {"sha": "dfef6ec70fcf772c5f1186200f76709dff5cd5e2", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -222,7 +222,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n                             let node_id = self.next_node_id();\n-                            self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst);\n+                            self.create_def(\n+                                parent_def_id.def_id,\n+                                node_id,\n+                                DefPathData::AnonConst,\n+                                *op_sp,\n+                            );\n                             let anon_const = AnonConst { id: node_id, value: P(expr) };\n                             hir::InlineAsmOperand::SymFn {\n                                 anon_const: self.lower_anon_const(&anon_const),"}, {"sha": "4260805f1dd1fdfed90cdc8cce97aa605b2f8965", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -176,6 +176,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     fn_decl,\n                     body,\n                     fn_decl_span,\n+                    fn_arg_span,\n                 }) => {\n                     if let Async::Yes { closure_id, .. } = asyncness {\n                         self.lower_expr_async_closure(\n@@ -186,6 +187,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             fn_decl,\n                             body,\n                             *fn_decl_span,\n+                            *fn_arg_span,\n                         )\n                     } else {\n                         self.lower_expr_closure(\n@@ -196,6 +198,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             fn_decl,\n                             body,\n                             *fn_decl_span,\n+                            *fn_arg_span,\n                         )\n                     }\n                 }\n@@ -365,7 +368,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let node_id = self.next_node_id();\n \n                 // Add a definition for the in-band const def.\n-                self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst);\n+                self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst, f.span);\n \n                 let anon_const = AnonConst { id: node_id, value: arg };\n                 generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));\n@@ -642,6 +645,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: self.lower_span(span),\n+                fn_arg_span: None,\n                 movability: Some(hir::Movability::Static),\n             });\n \n@@ -898,6 +902,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n+        fn_arg_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         let (binder_clause, generic_params) = self.lower_closure_binder(binder);\n \n@@ -928,6 +933,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             fn_decl,\n             body: body_id,\n             fn_decl_span: self.lower_span(fn_decl_span),\n+            fn_arg_span: Some(self.lower_span(fn_arg_span)),\n             movability: generator_option,\n         });\n \n@@ -984,6 +990,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n+        fn_arg_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         if let &ClosureBinder::For { span, .. } = binder {\n             self.tcx.sess.emit_err(NotSupportedForLifetimeBinderAsyncClosure { span });\n@@ -1038,6 +1045,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             fn_decl,\n             body,\n             fn_decl_span: self.lower_span(fn_decl_span),\n+            fn_arg_span: Some(self.lower_span(fn_arg_span)),\n             movability: None,\n         });\n         hir::ExprKind::Closure(c)"}, {"sha": "0258f8fd2d9ab12ad7b1cf45b0abad80b954f526", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -487,6 +487,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         parent: LocalDefId,\n         node_id: ast::NodeId,\n         data: DefPathData,\n+        span: Span,\n     ) -> LocalDefId {\n         debug_assert_ne!(node_id, ast::DUMMY_NODE_ID);\n         assert!(\n@@ -497,7 +498,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.tcx.hir().def_key(self.local_def_id(node_id)),\n         );\n \n-        let def_id = self.tcx.create_def(parent, data).def_id();\n+        let def_id = self.tcx.at(span).create_def(parent, data).def_id();\n \n         debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n         self.resolver.node_id_to_def_id.insert(node_id, def_id);\n@@ -823,6 +824,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     self.current_hir_id_owner.def_id,\n                     param,\n                     DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                    ident.span,\n                 );\n                 debug!(?_def_id);\n \n@@ -1151,15 +1153,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                                 let parent_def_id = self.current_hir_id_owner;\n                                 let node_id = self.next_node_id();\n+                                let span = self.lower_span(ty.span);\n \n                                 // Add a definition for the in-band const def.\n                                 let def_id = self.create_def(\n                                     parent_def_id.def_id,\n                                     node_id,\n                                     DefPathData::AnonConst,\n+                                    span,\n                                 );\n \n-                                let span = self.lower_span(ty.span);\n                                 let path_expr = Expr {\n                                     id: ty.id,\n                                     kind: ExprKind::Path(qself.clone(), path.clone()),\n@@ -1353,12 +1356,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         itctx,\n                     ),\n                     ImplTraitContext::Universal => {\n+                        let span = t.span;\n                         self.create_def(\n                             self.current_hir_id_owner.def_id,\n                             *def_node_id,\n                             DefPathData::ImplTrait,\n+                            span,\n                         );\n-                        let span = t.span;\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         let (param, bounds, path) =\n                             self.lower_generic_and_bounds(*def_node_id, span, ident, bounds);\n@@ -1455,6 +1459,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.current_hir_id_owner.def_id,\n             opaque_ty_node_id,\n             DefPathData::ImplTrait,\n+            opaque_ty_span,\n         );\n         debug!(?opaque_ty_def_id);\n \n@@ -1608,6 +1613,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             parent_def_id,\n                             node_id,\n                             DefPathData::LifetimeNs(lifetime.ident.name),\n+                            lifetime.ident.span,\n                         );\n                         remapping.insert(old_def_id, new_def_id);\n \n@@ -1624,6 +1630,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             parent_def_id,\n                             node_id,\n                             DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                            lifetime.ident.span,\n                         );\n                         remapping.insert(old_def_id, new_def_id);\n \n@@ -1806,7 +1813,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let fn_def_id = self.local_def_id(fn_node_id);\n \n         let opaque_ty_def_id =\n-            self.create_def(fn_def_id, opaque_ty_node_id, DefPathData::ImplTrait);\n+            self.create_def(fn_def_id, opaque_ty_node_id, DefPathData::ImplTrait, opaque_ty_span);\n \n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the\n@@ -1866,6 +1873,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 opaque_ty_def_id,\n                 inner_node_id,\n                 DefPathData::LifetimeNs(ident.name),\n+                ident.span,\n             );\n             new_remapping.insert(outer_def_id, inner_def_id);\n "}, {"sha": "d3d8431c163c728efa42dd52a248c6f692271a84", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -519,7 +519,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             ast::MetaItemKind::List(items) => {\n                 self.print_path(&item.path, false, 0);\n                 self.popen();\n-                self.commasep(Consistent, &items, |s, i| s.print_meta_list_item(i));\n+                self.commasep(Consistent, items, |s, i| s.print_meta_list_item(i));\n                 self.pclose();\n             }\n         }\n@@ -536,7 +536,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_tt(&mut self, tt: &TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(token, _) => {\n-                let token_str = self.token_to_string_ext(&token, convert_dollar_crate);\n+                let token_str = self.token_to_string_ext(token, convert_dollar_crate);\n                 self.word(token_str);\n                 if let token::DocComment(..) = token.kind {\n                     self.hardbreak()\n@@ -998,7 +998,7 @@ impl<'a> State<'a> {\n             ast::AssocConstraintKind::Bound { bounds } => {\n                 if !bounds.is_empty() {\n                     self.word_nbsp(\":\");\n-                    self.print_type_bounds(&bounds);\n+                    self.print_type_bounds(bounds);\n                 }\n             }\n         }\n@@ -1035,7 +1035,7 @@ impl<'a> State<'a> {\n             }\n             ast::TyKind::Tup(elts) => {\n                 self.popen();\n-                self.commasep(Inconsistent, &elts, |s, ty| s.print_type(ty));\n+                self.commasep(Inconsistent, elts, |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n@@ -1254,7 +1254,7 @@ impl<'a> State<'a> {\n \n         self.popen();\n         self.commasep(Consistent, &args, |s, arg| match arg {\n-            AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n+            AsmArg::Template(template) => s.print_string(template, ast::StrStyle::Cooked),\n             AsmArg::Operand(op) => {\n                 let print_reg_or_class = |s: &mut Self, r: &InlineAsmRegOrRegClass| match r {\n                     InlineAsmRegOrRegClass::Reg(r) => s.print_symbol(*r, ast::StrStyle::Cooked),\n@@ -1424,11 +1424,11 @@ impl<'a> State<'a> {\n                     self.print_path(path, true, 0);\n                 }\n                 self.popen();\n-                self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n+                self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                 self.pclose();\n             }\n             PatKind::Or(pats) => {\n-                self.strsep(\"|\", true, Inconsistent, &pats, |s, p| s.print_pat(p));\n+                self.strsep(\"|\", true, Inconsistent, pats, |s, p| s.print_pat(p));\n             }\n             PatKind::Path(None, path) => {\n                 self.print_path(path, true, 0);\n@@ -1450,7 +1450,7 @@ impl<'a> State<'a> {\n                 }\n                 self.commasep_cmnt(\n                     Consistent,\n-                    &fields,\n+                    fields,\n                     |s, f| {\n                         s.cbox(INDENT_UNIT);\n                         if !f.is_shorthand {\n@@ -1475,7 +1475,7 @@ impl<'a> State<'a> {\n             }\n             PatKind::Tuple(elts) => {\n                 self.popen();\n-                self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n+                self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n@@ -1498,7 +1498,7 @@ impl<'a> State<'a> {\n                     self.print_pat(inner);\n                 }\n             }\n-            PatKind::Lit(e) => self.print_expr(&**e),\n+            PatKind::Lit(e) => self.print_expr(e),\n             PatKind::Range(begin, end, Spanned { node: end_kind, .. }) => {\n                 if let Some(e) = begin {\n                     self.print_expr(e);\n@@ -1514,7 +1514,7 @@ impl<'a> State<'a> {\n             }\n             PatKind::Slice(elts) => {\n                 self.word(\"[\");\n-                self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n+                self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                 self.word(\"]\");\n             }\n             PatKind::Rest => self.word(\"..\"),\n@@ -1600,7 +1600,7 @@ impl<'a> State<'a> {\n \n         self.word(\"<\");\n \n-        self.commasep(Inconsistent, &generic_params, |s, param| {\n+        self.commasep(Inconsistent, generic_params, |s, param| {\n             s.print_outer_attributes_inline(&param.attrs);\n \n             match &param.kind {"}, {"sha": "4ed16e337d297483ce5cec9d914ef69c03313a10", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -305,10 +305,10 @@ impl<'a> State<'a> {\n                 self.print_expr_tup(exprs);\n             }\n             ast::ExprKind::Call(func, args) => {\n-                self.print_expr_call(func, &args);\n+                self.print_expr_call(func, args);\n             }\n             ast::ExprKind::MethodCall(box ast::MethodCall { seg, receiver, args, .. }) => {\n-                self.print_expr_method_call(seg, &receiver, &args);\n+                self.print_expr_method_call(seg, receiver, args);\n             }\n             ast::ExprKind::Binary(op, lhs, rhs) => {\n                 self.print_expr_binary(*op, lhs, rhs);\n@@ -402,6 +402,7 @@ impl<'a> State<'a> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: _,\n+                fn_arg_span: _,\n             }) => {\n                 self.print_closure_binder(binder);\n                 self.print_movability(*movability);\n@@ -605,7 +606,7 @@ impl<'a> State<'a> {\n         match binder {\n             ast::ClosureBinder::NotPresent => {}\n             ast::ClosureBinder::For { generic_params, .. } => {\n-                self.print_formal_generic_params(&generic_params)\n+                self.print_formal_generic_params(generic_params)\n             }\n         }\n     }"}, {"sha": "e379e6470623759eabab4567b6d8de519713ba92", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn replace_regions_in_mir<'tcx>(\n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);\n \n-    dump_mir(infcx.tcx, None, \"renumber\", &0, body, |_, _| Ok(()));\n+    dump_mir(infcx.tcx, false, \"renumber\", &0, body, |_, _| Ok(()));\n \n     universal_regions\n }\n@@ -331,7 +331,7 @@ pub(super) fn dump_mir_results<'tcx>(\n         return;\n     }\n \n-    dump_mir(infcx.tcx, None, \"nll\", &0, body, |pass_where, out| {\n+    dump_mir(infcx.tcx, false, \"nll\", &0, body, |pass_where, out| {\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => {\n@@ -358,15 +358,13 @@ pub(super) fn dump_mir_results<'tcx>(\n \n     // Also dump the inference graph constraints as a graphviz file.\n     let _: io::Result<()> = try {\n-        let mut file =\n-            create_dump_file(infcx.tcx, \"regioncx.all.dot\", None, \"nll\", &0, body.source)?;\n+        let mut file = create_dump_file(infcx.tcx, \"regioncx.all.dot\", false, \"nll\", &0, body)?;\n         regioncx.dump_graphviz_raw_constraints(&mut file)?;\n     };\n \n     // Also dump the inference graph constraints as a graphviz file.\n     let _: io::Result<()> = try {\n-        let mut file =\n-            create_dump_file(infcx.tcx, \"regioncx.scc.dot\", None, \"nll\", &0, body.source)?;\n+        let mut file = create_dump_file(infcx.tcx, \"regioncx.scc.dot\", false, \"nll\", &0, body)?;\n         regioncx.dump_graphviz_scc_constraints(&mut file)?;\n     };\n }"}, {"sha": "3b406036c356e9e3023964f049184a2d1f0121f5", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -19,11 +19,6 @@ version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n \n-[[package]]\n-name = \"ar\"\n-version = \"0.8.0\"\n-source = \"git+https://github.com/bjorn3/rust-ar.git?branch=do_not_remove_cg_clif_ranlib#de9ab0e56bf3a208381d342aa5b60f9ff2891648\"\n-\n [[package]]\n name = \"arrayvec\"\n version = \"0.7.2\"\n@@ -324,7 +319,6 @@ dependencies = [\n name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar\",\n  \"cranelift-codegen\",\n  \"cranelift-frontend\",\n  \"cranelift-jit\","}, {"sha": "0fdd5de118ccb10cb4db0776c5ca9c69b19cc07f", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -18,7 +18,6 @@ target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n-ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\"\n libloading = { version = \"0.7.3\", optional = true }\n once_cell = \"1.10.0\""}, {"sha": "5a29bc18def549cd035bb0a1144b5cab54addef4", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 5, "deletions": 219, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,35 +1,15 @@\n-//! Creation of ar archives like for the lib and staticlib crate type\n-\n-use std::collections::BTreeMap;\n-use std::fs::File;\n-use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuilder, ArchiveBuilderBuilder,\n+};\n use rustc_session::Session;\n \n-use object::read::archive::ArchiveFile;\n-use object::{Object, ObjectSymbol, ReadCache};\n-\n-#[derive(Debug)]\n-enum ArchiveEntry {\n-    FromArchive { archive_index: usize, file_range: (u64, u64) },\n-    File(PathBuf),\n-}\n-\n pub(crate) struct ArArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        Box::new(ArArchiveBuilder {\n-            sess,\n-            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n-            // FIXME fix builtin ranlib on macOS\n-            no_builtin_ranlib: sess.target.is_like_osx,\n-\n-            src_archives: vec![],\n-            entries: vec![],\n-        })\n+        Box::new(ArArchiveBuilder::new(sess, get_native_object_symbols))\n     }\n \n     fn create_dll_import_lib(\n@@ -40,200 +20,6 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _tmpdir: &Path,\n         _is_direct_dependency: bool,\n     ) -> PathBuf {\n-        bug!(\"creating dll imports is not supported\");\n-    }\n-}\n-\n-pub(crate) struct ArArchiveBuilder<'a> {\n-    sess: &'a Session,\n-    use_gnu_style_archive: bool,\n-    no_builtin_ranlib: bool,\n-\n-    src_archives: Vec<File>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(Vec<u8>, ArchiveEntry)>,\n-}\n-\n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn add_file(&mut self, file: &Path) {\n-        self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n-            ArchiveEntry::File(file.to_owned()),\n-        ));\n-    }\n-\n-    fn add_archive(\n-        &mut self,\n-        archive_path: &Path,\n-        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n-    ) -> std::io::Result<()> {\n-        let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n-        let archive = ArchiveFile::parse(&read_cache).unwrap();\n-        let archive_index = self.src_archives.len();\n-\n-        for entry in archive.members() {\n-            let entry = entry.map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n-            let file_name = String::from_utf8(entry.name().to_vec())\n-                .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n-                ));\n-            }\n-        }\n-\n-        self.src_archives.push(read_cache.into_inner());\n-        Ok(())\n-    }\n-\n-    fn build(mut self: Box<Self>, output: &Path) -> bool {\n-        enum BuilderKind {\n-            Bsd(ar::Builder<File>),\n-            Gnu(ar::GnuBuilder<File>),\n-        }\n-\n-        let sess = self.sess;\n-\n-        let mut symbol_table = BTreeMap::new();\n-\n-        let mut entries = Vec::new();\n-\n-        for (mut entry_name, entry) in self.entries {\n-            // FIXME only read the symbol table of the object files to avoid having to keep all\n-            // object files in memory at once, or read them twice.\n-            let data = match entry {\n-                ArchiveEntry::FromArchive { archive_index, file_range } => {\n-                    // FIXME read symbols from symtab\n-                    let src_read_cache = &mut self.src_archives[archive_index];\n-\n-                    src_read_cache.seek(io::SeekFrom::Start(file_range.0)).unwrap();\n-                    let mut data = std::vec::from_elem(0, usize::try_from(file_range.1).unwrap());\n-                    src_read_cache.read_exact(&mut data).unwrap();\n-\n-                    data\n-                }\n-                ArchiveEntry::File(file) => std::fs::read(file).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\n-                        \"error while reading object file during archive building: {}\",\n-                        err\n-                    ));\n-                }),\n-            };\n-\n-            if !self.no_builtin_ranlib {\n-                if symbol_table.contains_key(&entry_name) {\n-                    // The ar crate can't handle creating a symbol table in case of multiple archive\n-                    // members with the same name. Work around this by prepending a number until we\n-                    // get a unique name.\n-                    for i in 1.. {\n-                        let new_name = format!(\"{}_\", i)\n-                            .into_bytes()\n-                            .into_iter()\n-                            .chain(entry_name.iter().copied())\n-                            .collect::<Vec<_>>();\n-                        if !symbol_table.contains_key(&new_name) {\n-                            entry_name = new_name;\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                match object::File::parse(&*data) {\n-                    Ok(object) => {\n-                        symbol_table.insert(\n-                            entry_name.to_vec(),\n-                            object\n-                                .symbols()\n-                                .filter_map(|symbol| {\n-                                    if symbol.is_undefined() || symbol.is_local() {\n-                                        None\n-                                    } else {\n-                                        symbol.name().map(|name| name.as_bytes().to_vec()).ok()\n-                                    }\n-                                })\n-                                .collect::<Vec<_>>(),\n-                        );\n-                    }\n-                    Err(err) => {\n-                        let err = err.to_string();\n-                        if err == \"Unknown file magic\" {\n-                            // Not an object file; skip it.\n-                        } else if object::read::archive::ArchiveFile::parse(&*data).is_ok() {\n-                            // Nested archive file; skip it.\n-                        } else {\n-                            sess.fatal(&format!(\n-                                \"error parsing `{}` during archive creation: {}\",\n-                                String::from_utf8_lossy(&entry_name),\n-                                err\n-                            ));\n-                        }\n-                    }\n-                }\n-            }\n-\n-            entries.push((entry_name, data));\n-        }\n-\n-        let mut builder = if self.use_gnu_style_archive {\n-            BuilderKind::Gnu(\n-                ar::GnuBuilder::new(\n-                    File::create(output).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\n-                            \"error opening destination during archive building: {}\",\n-                            err\n-                        ));\n-                    }),\n-                    entries.iter().map(|(name, _)| name.clone()).collect(),\n-                    ar::GnuSymbolTableFormat::Size32,\n-                    symbol_table,\n-                )\n-                .unwrap(),\n-            )\n-        } else {\n-            BuilderKind::Bsd(\n-                ar::Builder::new(\n-                    File::create(output).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\n-                            \"error opening destination during archive building: {}\",\n-                            err\n-                        ));\n-                    }),\n-                    symbol_table,\n-                )\n-                .unwrap(),\n-            )\n-        };\n-\n-        let any_members = !entries.is_empty();\n-\n-        // Add all files\n-        for (entry_name, data) in entries.into_iter() {\n-            let header = ar::Header::new(entry_name, data.len() as u64);\n-            match builder {\n-                BuilderKind::Bsd(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n-                BuilderKind::Gnu(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n-            }\n-        }\n-\n-        // Finalize archive\n-        std::mem::drop(builder);\n-\n-        if self.no_builtin_ranlib {\n-            let ranlib = crate::toolchain::get_toolchain_binary(self.sess, \"ranlib\");\n-\n-            // Run ranlib to be able to link the archive\n-            let status = std::process::Command::new(ranlib)\n-                .arg(output)\n-                .status()\n-                .expect(\"Couldn't run ranlib\");\n-\n-            if !status.success() {\n-                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n-            }\n-        }\n-\n-        any_members\n+        unimplemented!(\"creating dll imports is not yet supported\");\n     }\n }"}, {"sha": "1cb219e12e04d5a88bea03e20028a78c4eab377c", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -11,12 +11,6 @@ dependencies = [\n  \"memchr\",\n ]\n \n-[[package]]\n-name = \"ar\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"450575f58f7bee32816abbff470cbc47797397c2a81e0eaced4b98436daf52e1\"\n-\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -212,10 +206,8 @@ dependencies = [\n name = \"rustc_codegen_gcc\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n- \"target-lexicon\",\n  \"tempfile\",\n ]\n \n@@ -228,12 +220,6 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n-[[package]]\n-name = \"target-lexicon\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab0e7238dcc7b40a7be719a25365910f6807bd864f4cce6b2e6b873658e2b19d\"\n-\n [[package]]\n name = \"tempfile\"\n version = \"3.2.0\""}, {"sha": "1f3da2f799b781991000e123eceb6d9e3547db23", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -27,10 +27,6 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n # Local copy.\n #gccjit = { path = \"../gccjit.rs\" }\n \n-target-lexicon = \"0.10.0\"\n-\n-ar = \"0.8.0\"\n-\n [dev-dependencies]\n lang_tester = \"0.3.9\"\n tempfile = \"3.1.0\""}, {"sha": "11fa074f5ac79e81a9902d8b93c5ce9839727423", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 6, "deletions": 171, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,44 +1,17 @@\n-use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use crate::errors::RanlibFailure;\n-\n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuilder, ArchiveBuilderBuilder,\n+};\n use rustc_session::Session;\n \n use rustc_session::cstore::DllImport;\n \n-struct ArchiveConfig<'a> {\n-    sess: &'a Session,\n-    use_native_ar: bool,\n-    use_gnu_style_archive: bool,\n-}\n-\n-#[derive(Debug)]\n-enum ArchiveEntry {\n-    FromArchive {\n-        archive_index: usize,\n-        entry_index: usize,\n-    },\n-    File(PathBuf),\n-}\n-\n-pub struct ArArchiveBuilderBuilder;\n+pub(crate) struct ArArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        let config = ArchiveConfig {\n-            sess,\n-            use_native_ar: false,\n-            // FIXME test for linux and System V derivatives instead\n-            use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n-        };\n-\n-        Box::new(ArArchiveBuilder {\n-            config,\n-            src_archives: vec![],\n-            entries: vec![],\n-        })\n+        Box::new(ArArchiveBuilder::new(sess, get_native_object_symbols))\n     }\n \n     fn create_dll_import_lib(\n@@ -49,144 +22,6 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _tmpdir: &Path,\n         _is_direct_dependency: bool,\n     ) -> PathBuf {\n-        unimplemented!();\n-    }\n-}\n-\n-pub struct ArArchiveBuilder<'a> {\n-    config: ArchiveConfig<'a>,\n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(String, ArchiveEntry)>,\n-}\n-\n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn add_file(&mut self, file: &Path) {\n-        self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string(),\n-            ArchiveEntry::File(file.to_owned()),\n-        ));\n-    }\n-\n-    fn add_archive(\n-        &mut self,\n-        archive_path: &Path,\n-        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n-    ) -> std::io::Result<()> {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n-        let archive_index = self.src_archives.len();\n-\n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry?;\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n-                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries\n-                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n-            }\n-            i += 1;\n-        }\n-\n-        self.src_archives.push((archive_path.to_owned(), archive));\n-        Ok(())\n-    }\n-\n-    fn build(mut self: Box<Self>, output: &Path) -> bool {\n-        use std::process::Command;\n-\n-        fn add_file_using_ar(archive: &Path, file: &Path) {\n-            Command::new(\"ar\")\n-                .arg(\"r\") // add or replace file\n-                .arg(\"-c\") // silence created file message\n-                .arg(archive)\n-                .arg(&file)\n-                .status()\n-                .unwrap();\n-        }\n-\n-        enum BuilderKind<'a> {\n-            Bsd(ar::Builder<File>),\n-            Gnu(ar::GnuBuilder<File>),\n-            NativeAr(&'a Path),\n-        }\n-\n-        let mut builder = if self.config.use_native_ar {\n-            BuilderKind::NativeAr(output)\n-        } else if self.config.use_gnu_style_archive {\n-            BuilderKind::Gnu(ar::GnuBuilder::new(\n-                File::create(output).unwrap(),\n-                self.entries\n-                    .iter()\n-                    .map(|(name, _)| name.as_bytes().to_vec())\n-                    .collect(),\n-            ))\n-        } else {\n-            BuilderKind::Bsd(ar::Builder::new(File::create(output).unwrap()))\n-        };\n-\n-        let any_members = !self.entries.is_empty();\n-\n-        // Add all files\n-        for (entry_name, entry) in self.entries.into_iter() {\n-            match entry {\n-                ArchiveEntry::FromArchive {\n-                    archive_index,\n-                    entry_index,\n-                } => {\n-                    let (ref src_archive_path, ref mut src_archive) =\n-                        self.src_archives[archive_index];\n-                    let entry = src_archive.jump_to_entry(entry_index).unwrap();\n-                    let header = entry.header().clone();\n-\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::NativeAr(archive_file) => {\n-                            Command::new(\"ar\")\n-                                .arg(\"x\")\n-                                .arg(src_archive_path)\n-                                .arg(&entry_name)\n-                                .status()\n-                                .unwrap();\n-                            add_file_using_ar(archive_file, Path::new(&entry_name));\n-                            std::fs::remove_file(entry_name).unwrap();\n-                        }\n-                    }\n-                }\n-                ArchiveEntry::File(file) =>\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder\n-                                .append_file(entry_name.as_bytes(), &mut File::open(file).expect(\"file for bsd builder\"))\n-                                .unwrap()\n-                        },\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder\n-                                .append_file(entry_name.as_bytes(), &mut File::open(&file).expect(&format!(\"file {:?} for gnu builder\", file)))\n-                                .unwrap()\n-                        },\n-                        BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n-                    },\n-            }\n-        }\n-\n-        // Finalize archive\n-        std::mem::drop(builder);\n-\n-        // Run ranlib to be able to link the archive\n-        let status =\n-            std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n-\n-        if !status.success() {\n-            self.config.sess.emit_fatal(RanlibFailure::new(status.code()));\n-        }\n-\n-        any_members\n+        unimplemented!(\"creating dll imports is not yet supported\");\n     }\n }"}, {"sha": "89fed7be1315614e91331d4b2c05fb58ff320989", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -16,18 +16,6 @@ impl IntoDiagnosticArg for ExitCode {\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_gcc_ranlib_failure)]\n-pub(crate) struct RanlibFailure {\n-    exit_code: ExitCode,\n-}\n-\n-impl RanlibFailure {\n-    pub fn new(exit_code: Option<i32>) -> Self {\n-        RanlibFailure { exit_code: ExitCode(exit_code) }\n-    }\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_gcc_invalid_monomorphization_basic_integer, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n@@ -227,7 +215,7 @@ pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n #[diag(codegen_gcc_linkage_const_or_mut_type)]\n pub(crate) struct LinkageConstOrMutType {\n     #[primary_span]\n-    pub span: Span\n+    pub span: Span,\n }\n \n #[derive(Diagnostic)]\n@@ -238,5 +226,5 @@ pub(crate) struct LTONotSupported;\n #[diag(codegen_gcc_unwinding_inline_asm)]\n pub(crate) struct UnwindingInlineAsm {\n     #[primary_span]\n-    pub span: Span\n+    pub span: Span,\n }"}, {"sha": "93d6234dc884550875cf4aef0b3ce89dc2250f5d", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -11,7 +11,7 @@ bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n measureme = \"10.0.0\"\n-object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read\"] }\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc-demangle = \"0.1.21\""}, {"sha": "f3bdacf6085552109871140a10cacd1e2757d24b", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -258,13 +258,12 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n         OptimizeAttr::Speed => {}\n     }\n \n-    let inline = if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-        InlineAttr::Never\n-    } else if codegen_fn_attrs.inline == InlineAttr::None && instance.def.requires_inline(cx.tcx) {\n-        InlineAttr::Hint\n-    } else {\n-        codegen_fn_attrs.inline\n-    };\n+    let inline =\n+        if codegen_fn_attrs.inline == InlineAttr::None && instance.def.requires_inline(cx.tcx) {\n+            InlineAttr::Hint\n+        } else {\n+            codegen_fn_attrs.inline\n+        };\n     to_add.extend(inline_attr(cx, inline));\n \n     // The `uwtable` attribute according to LLVM is:"}, {"sha": "0aee1a1439b9bcd2867bb2da9681092891c257d5", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 69, "deletions": 62, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,31 +1,30 @@\n //! A helper class for dealing with static archives\n \n use std::env;\n-use std::ffi::{CStr, CString, OsString};\n-use std::fs;\n-use std::io::{self, Write};\n+use std::ffi::{c_char, c_void, CStr, CString, OsString};\n+use std::io;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::ptr;\n use std::str;\n \n-use object::read::macho::FatArch;\n-\n use crate::common;\n use crate::errors::{\n-    ArchiveBuildFailure, DlltoolFailImportLibrary, ErrorCallingDllTool, ErrorCreatingImportLibrary,\n-    ErrorWritingDEFFile, UnknownArchiveKind,\n+    DlltoolFailImportLibrary, ErrorCallingDllTool, ErrorCreatingImportLibrary, ErrorWritingDEFFile,\n };\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n-use rustc_data_structures::memmap::Mmap;\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, try_extract_macho_fat_archive, ArArchiveBuilder,\n+    ArchiveBuildFailure, ArchiveBuilder, ArchiveBuilderBuilder, UnknownArchiveKind,\n+};\n+\n use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n \n /// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n-pub struct LlvmArchiveBuilder<'a> {\n+pub(crate) struct LlvmArchiveBuilder<'a> {\n     sess: &'a Session,\n     additions: Vec<Addition>,\n }\n@@ -61,57 +60,6 @@ fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n     }\n }\n \n-fn try_filter_fat_archs(\n-    archs: object::read::Result<&[impl FatArch]>,\n-    target_arch: object::Architecture,\n-    archive_path: &Path,\n-    archive_map_data: &[u8],\n-) -> io::Result<Option<PathBuf>> {\n-    let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n-\n-    let desired = match archs.iter().filter(|a| a.architecture() == target_arch).next() {\n-        Some(a) => a,\n-        None => return Ok(None),\n-    };\n-\n-    let (mut new_f, extracted_path) = tempfile::Builder::new()\n-        .suffix(archive_path.file_name().unwrap())\n-        .tempfile()?\n-        .keep()\n-        .unwrap();\n-\n-    new_f.write_all(\n-        desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n-    )?;\n-\n-    Ok(Some(extracted_path))\n-}\n-\n-fn try_extract_macho_fat_archive(\n-    sess: &Session,\n-    archive_path: &Path,\n-) -> io::Result<Option<PathBuf>> {\n-    let archive_map = unsafe { Mmap::map(fs::File::open(&archive_path)?)? };\n-    let target_arch = match sess.target.arch.as_ref() {\n-        \"aarch64\" => object::Architecture::Aarch64,\n-        \"x86_64\" => object::Architecture::X86_64,\n-        _ => return Ok(None),\n-    };\n-\n-    match object::macho::FatHeader::parse(&*archive_map) {\n-        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n-            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n-            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n-        }\n-        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n-            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n-            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n-        }\n-        // Not a FatHeader at all, just return None.\n-        _ => Ok(None),\n-    }\n-}\n-\n impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     fn add_archive(\n         &mut self,\n@@ -160,7 +108,11 @@ pub struct LlvmArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n+        if sess.target.arch == \"wasm32\" || sess.target.arch == \"wasm64\" {\n+            Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n+        } else {\n+            Box::new(ArArchiveBuilder::new(sess, get_llvm_object_symbols))\n+        }\n     }\n \n     fn create_dll_import_lib(\n@@ -309,6 +261,61 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n     }\n }\n \n+// The object crate doesn't know how to get symbols for LLVM bitcode and COFF bigobj files.\n+// As such we need to use LLVM for them.\n+#[deny(unsafe_op_in_unsafe_fn)]\n+fn get_llvm_object_symbols(\n+    buf: &[u8],\n+    f: &mut dyn FnMut(&[u8]) -> io::Result<()>,\n+) -> io::Result<bool> {\n+    let is_bitcode = unsafe { llvm::LLVMRustIsBitcode(buf.as_ptr(), buf.len()) };\n+\n+    // COFF bigobj file, msvc LTO file or import library. See\n+    // https://github.com/llvm/llvm-project/blob/453f27bc9/llvm/lib/BinaryFormat/Magic.cpp#L38-L51\n+    let is_unsupported_windows_obj_file = buf.get(0..4) == Some(b\"\\0\\0\\xFF\\xFF\");\n+\n+    if is_bitcode || is_unsupported_windows_obj_file {\n+        let mut state = Box::new(f);\n+\n+        let err = unsafe {\n+            llvm::LLVMRustGetSymbols(\n+                buf.as_ptr(),\n+                buf.len(),\n+                &mut *state as *mut &mut _ as *mut c_void,\n+                callback,\n+                error_callback,\n+            )\n+        };\n+\n+        if err.is_null() {\n+            return Ok(true);\n+        } else {\n+            return Err(unsafe { *Box::from_raw(err as *mut io::Error) });\n+        }\n+\n+        unsafe extern \"C\" fn callback(\n+            state: *mut c_void,\n+            symbol_name: *const c_char,\n+        ) -> *mut c_void {\n+            let f = unsafe { &mut *(state as *mut &mut dyn FnMut(&[u8]) -> io::Result<()>) };\n+            match f(unsafe { CStr::from_ptr(symbol_name) }.to_bytes()) {\n+                Ok(()) => std::ptr::null_mut(),\n+                Err(err) => Box::into_raw(Box::new(err)) as *mut c_void,\n+            }\n+        }\n+\n+        unsafe extern \"C\" fn error_callback(error: *const c_char) -> *mut c_void {\n+            let error = unsafe { CStr::from_ptr(error) };\n+            Box::into_raw(Box::new(io::Error::new(\n+                io::ErrorKind::Other,\n+                format!(\"LLVM error: {}\", error.to_string_lossy()),\n+            ))) as *mut c_void\n+        }\n+    } else {\n+        get_native_object_symbols(buf, f)\n+    }\n+}\n+\n impl<'a> LlvmArchiveBuilder<'a> {\n     fn build_with_llvm(&mut self, output: &Path) -> io::Result<bool> {\n         let kind = &*self.sess.target.archive_format;"}, {"sha": "fddfbb23c67d5737a7d3031eee72f77707ca7fe9", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -72,12 +72,6 @@ pub(crate) struct LinkageConstOrMutType {\n #[diag(codegen_llvm_sanitizer_memtag_requires_mte)]\n pub(crate) struct SanitizerMemtagRequiresMte;\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_archive_build_failure)]\n-pub(crate) struct ArchiveBuildFailure {\n-    pub error: std::io::Error,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_llvm_error_writing_def_file)]\n pub(crate) struct ErrorWritingDEFFile {\n@@ -97,12 +91,6 @@ pub(crate) struct DlltoolFailImportLibrary<'a> {\n     pub stderr: Cow<'a, str>,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_unknown_archive_kind)]\n-pub(crate) struct UnknownArchiveKind<'a> {\n-    pub kind: &'a str,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_llvm_dynamic_linking_with_lto)]\n #[note]"}, {"sha": "8a9392255b861881e13a5ba12ed1e0c389a2ac14", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -983,6 +983,9 @@ pub type SelfProfileBeforePassCallback =\n     unsafe extern \"C\" fn(*mut c_void, *const c_char, *const c_char);\n pub type SelfProfileAfterPassCallback = unsafe extern \"C\" fn(*mut c_void);\n \n+pub type GetSymbolsCallback = unsafe extern \"C\" fn(*mut c_void, *const c_char) -> *mut c_void;\n+pub type GetSymbolsErrorCallback = unsafe extern \"C\" fn(*const c_char) -> *mut c_void;\n+\n extern \"C\" {\n     pub fn LLVMRustInstallFatalErrorHandler();\n     pub fn LLVMRustDisableSystemDialogsOnCrash();\n@@ -2474,4 +2477,14 @@ extern \"C\" {\n     pub fn LLVMRustGetMangledName(V: &Value, out: &RustString);\n \n     pub fn LLVMRustGetElementTypeArgIndex(CallSite: &Value) -> i32;\n+\n+    pub fn LLVMRustIsBitcode(ptr: *const u8, len: usize) -> bool;\n+\n+    pub fn LLVMRustGetSymbols(\n+        buf_ptr: *const u8,\n+        buf_len: usize,\n+        state: *mut c_void,\n+        callback: GetSymbolsCallback,\n+        error_callback: GetSymbolsErrorCallback,\n+    ) -> *mut c_void;\n }"}, {"sha": "2fa602520dcb0d72e02132a481f86fe6b0ec8f82", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -494,6 +494,11 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n         .flatten();\n     features.extend(feats);\n \n+    // FIXME: Move v8a to target definition list when earliest supported LLVM is 14.\n+    if get_version() >= (14, 0, 0) && sess.target.arch == \"aarch64\" {\n+        features.push(\"+v8a\".into());\n+    }\n+\n     if diagnostics && let Some(f) = check_tied_features(sess, &featsmap) {\n         sess.emit_err(TargetFeatureDisableOrEnable {\n             features: f,"}, {"sha": "345174fb595ab1de60c74441c44e3481730bdb7c", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n test = false\n \n [dependencies]\n+ar_archive_writer = \"0.1.1\"\n bitflags = \"1.2.1\"\n cc = \"1.0.69\"\n itertools = \"0.10.1\""}, {"sha": "58558fb8c4ba2912b53f7fcef66c10c676c4a7aa", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 229, "deletions": 2, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -6,14 +6,19 @@ use rustc_span::symbol::Symbol;\n \n use super::metadata::search_for_section;\n \n+pub use ar_archive_writer::get_native_object_symbols;\n+use ar_archive_writer::{write_archive_to_stream, ArchiveKind, NewArchiveMember};\n use object::read::archive::ArchiveFile;\n+use object::read::macho::FatArch;\n+use tempfile::Builder as TempFileBuilder;\n \n use std::error::Error;\n use std::fs::File;\n-use std::io;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n \n-use crate::errors::ExtractBundledLibsError;\n+// Re-exporting for rustc_codegen_llvm::back::archive\n+pub use crate::errors::{ArchiveBuildFailure, ExtractBundledLibsError, UnknownArchiveKind};\n \n pub trait ArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n@@ -80,3 +85,225 @@ pub trait ArchiveBuilder<'a> {\n \n     fn build(self: Box<Self>, output: &Path) -> bool;\n }\n+\n+#[must_use = \"must call build() to finish building the archive\"]\n+pub struct ArArchiveBuilder<'a> {\n+    sess: &'a Session,\n+    get_object_symbols:\n+        fn(buf: &[u8], f: &mut dyn FnMut(&[u8]) -> io::Result<()>) -> io::Result<bool>,\n+\n+    src_archives: Vec<(PathBuf, Mmap)>,\n+    // Don't use an `HashMap` here, as the order is important. `lib.rmeta` needs\n+    // to be at the end of an archive in some cases for linkers to not get confused.\n+    entries: Vec<(Vec<u8>, ArchiveEntry)>,\n+}\n+\n+#[derive(Debug)]\n+enum ArchiveEntry {\n+    FromArchive { archive_index: usize, file_range: (u64, u64) },\n+    File(PathBuf),\n+}\n+\n+impl<'a> ArArchiveBuilder<'a> {\n+    pub fn new(\n+        sess: &'a Session,\n+        get_object_symbols: fn(\n+            buf: &[u8],\n+            f: &mut dyn FnMut(&[u8]) -> io::Result<()>,\n+        ) -> io::Result<bool>,\n+    ) -> ArArchiveBuilder<'a> {\n+        ArArchiveBuilder { sess, get_object_symbols, src_archives: vec![], entries: vec![] }\n+    }\n+}\n+\n+fn try_filter_fat_archs(\n+    archs: object::read::Result<&[impl FatArch]>,\n+    target_arch: object::Architecture,\n+    archive_path: &Path,\n+    archive_map_data: &[u8],\n+) -> io::Result<Option<PathBuf>> {\n+    let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n+\n+    let desired = match archs.iter().filter(|a| a.architecture() == target_arch).next() {\n+        Some(a) => a,\n+        None => return Ok(None),\n+    };\n+\n+    let (mut new_f, extracted_path) = tempfile::Builder::new()\n+        .suffix(archive_path.file_name().unwrap())\n+        .tempfile()?\n+        .keep()\n+        .unwrap();\n+\n+    new_f.write_all(\n+        desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n+    )?;\n+\n+    Ok(Some(extracted_path))\n+}\n+\n+pub fn try_extract_macho_fat_archive(\n+    sess: &Session,\n+    archive_path: &Path,\n+) -> io::Result<Option<PathBuf>> {\n+    let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+    let target_arch = match sess.target.arch.as_ref() {\n+        \"aarch64\" => object::Architecture::Aarch64,\n+        \"x86_64\" => object::Architecture::X86_64,\n+        _ => return Ok(None),\n+    };\n+\n+    match object::macho::FatHeader::parse(&*archive_map) {\n+        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n+            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+        }\n+        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n+            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+        }\n+        // Not a FatHeader at all, just return None.\n+        _ => Ok(None),\n+    }\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n+    fn add_archive(\n+        &mut self,\n+        archive_path: &Path,\n+        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> io::Result<()> {\n+        let mut archive_path = archive_path.to_path_buf();\n+        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some(new_archive_path) =\n+                try_extract_macho_fat_archive(&self.sess, &archive_path)?\n+            {\n+                archive_path = new_archive_path\n+            }\n+        }\n+\n+        if self.src_archives.iter().any(|archive| archive.0 == archive_path) {\n+            return Ok(());\n+        }\n+\n+        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+        let archive = ArchiveFile::parse(&*archive_map)\n+            .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n+        let archive_index = self.src_archives.len();\n+\n+        for entry in archive.members() {\n+            let entry = entry.map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n+            let file_name = String::from_utf8(entry.name().to_vec())\n+                .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n+            if !skip(&file_name) {\n+                self.entries.push((\n+                    file_name.into_bytes(),\n+                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n+                ));\n+            }\n+        }\n+\n+        self.src_archives.push((archive_path.to_owned(), archive_map));\n+        Ok(())\n+    }\n+\n+    /// Adds an arbitrary file to this archive\n+    fn add_file(&mut self, file: &Path) {\n+        self.entries.push((\n+            file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n+            ArchiveEntry::File(file.to_owned()),\n+        ));\n+    }\n+\n+    /// Combine the provided files, rlibs, and native libraries into a single\n+    /// `Archive`.\n+    fn build(self: Box<Self>, output: &Path) -> bool {\n+        let sess = self.sess;\n+        match self.build_inner(output) {\n+            Ok(any_members) => any_members,\n+            Err(e) => sess.emit_fatal(ArchiveBuildFailure { error: e }),\n+        }\n+    }\n+}\n+\n+impl<'a> ArArchiveBuilder<'a> {\n+    fn build_inner(self, output: &Path) -> io::Result<bool> {\n+        let archive_kind = match &*self.sess.target.archive_format {\n+            \"gnu\" => ArchiveKind::Gnu,\n+            \"bsd\" => ArchiveKind::Bsd,\n+            \"darwin\" => ArchiveKind::Darwin,\n+            \"coff\" => ArchiveKind::Coff,\n+            kind => {\n+                self.sess.emit_fatal(UnknownArchiveKind { kind });\n+            }\n+        };\n+\n+        let mut entries = Vec::new();\n+\n+        for (entry_name, entry) in self.entries {\n+            let data =\n+                match entry {\n+                    ArchiveEntry::FromArchive { archive_index, file_range } => {\n+                        let src_archive = &self.src_archives[archive_index];\n+\n+                        let data = &src_archive.1\n+                            [file_range.0 as usize..file_range.0 as usize + file_range.1 as usize];\n+\n+                        Box::new(data) as Box<dyn AsRef<[u8]>>\n+                    }\n+                    ArchiveEntry::File(file) => unsafe {\n+                        Box::new(\n+                            Mmap::map(File::open(file).map_err(|err| {\n+                                io_error_context(\"failed to open object file\", err)\n+                            })?)\n+                            .map_err(|err| io_error_context(\"failed to map object file\", err))?,\n+                        ) as Box<dyn AsRef<[u8]>>\n+                    },\n+                };\n+\n+            entries.push(NewArchiveMember {\n+                buf: data,\n+                get_symbols: self.get_object_symbols,\n+                member_name: String::from_utf8(entry_name).unwrap(),\n+                mtime: 0,\n+                uid: 0,\n+                gid: 0,\n+                perms: 0o644,\n+            })\n+        }\n+\n+        // Write to a temporary file first before atomically renaming to the final name.\n+        // This prevents programs (including rustc) from attempting to read a partial archive.\n+        // It also enables writing an archive with the same filename as a dependency on Windows as\n+        // required by a test.\n+        let mut archive_tmpfile = TempFileBuilder::new()\n+            .suffix(\".temp-archive\")\n+            .tempfile_in(output.parent().unwrap_or_else(|| Path::new(\"\")))\n+            .map_err(|err| io_error_context(\"couldn't create a temp file\", err))?;\n+\n+        write_archive_to_stream(\n+            archive_tmpfile.as_file_mut(),\n+            &entries,\n+            true,\n+            archive_kind,\n+            true,\n+            false,\n+        )?;\n+\n+        let any_entries = !entries.is_empty();\n+        drop(entries);\n+        // Drop src_archives to unmap all input archives, which is necessary if we want to write the\n+        // output archive to the same location as an input archive on Windows.\n+        drop(self.src_archives);\n+\n+        archive_tmpfile\n+            .persist(output)\n+            .map_err(|err| io_error_context(\"failed to rename archive file\", err.error))?;\n+\n+        Ok(any_entries)\n+    }\n+}\n+\n+fn io_error_context(context: &str, err: io::Error) -> io::Error {\n+    io::Error::new(io::ErrorKind::Other, format!(\"{context}: {err}\"))\n+}"}, {"sha": "e3b6fbf1bc7f0e1bf07f39e7f6d581d1d8046427", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -534,3 +534,17 @@ pub struct ReadFileError {\n #[derive(Diagnostic)]\n #[diag(codegen_ssa_unsupported_link_self_contained)]\n pub struct UnsupportedLinkSelfContained;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_archive_build_failure)]\n+// Public for rustc_codegen_llvm::back::archive\n+pub struct ArchiveBuildFailure {\n+    pub error: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unknown_archive_kind)]\n+// Public for rustc_codegen_llvm::back::archive\n+pub struct UnknownArchiveKind<'a> {\n+    pub kind: &'a str,\n+}"}, {"sha": "fbe30154a7c8d26b23cb4af4ac5fa419e2a558ad", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -309,14 +309,14 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 // In the algorithm above, we can change\n                 // cast(relative_tag) + niche_variants.start()\n                 // into\n-                // cast(tag) + (niche_variants.start() - niche_start)\n+                // cast(tag + (niche_variants.start() - niche_start))\n                 // if either the casted type is no larger than the original\n                 // type, or if the niche values are contiguous (in either the\n                 // signed or unsigned sense).\n-                let can_incr_after_cast = cast_smaller || niches_ule || niches_sle;\n+                let can_incr = cast_smaller || niches_ule || niches_sle;\n \n                 let data_for_boundary_niche = || -> Option<(IntPredicate, u128)> {\n-                    if !can_incr_after_cast {\n+                    if !can_incr {\n                         None\n                     } else if niche_start == low_unsigned {\n                         Some((IntPredicate::IntULE, niche_end))\n@@ -353,24 +353,33 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     // The algorithm is now this:\n                     // is_niche = tag <= niche_end\n                     // discr = if is_niche {\n-                    //     cast(tag) + (niche_variants.start() - niche_start)\n+                    //     cast(tag + (niche_variants.start() - niche_start))\n                     // } else {\n                     //     untagged_variant\n                     // }\n                     // (the first line may instead be tag >= niche_start,\n                     // and may be a signed or unsigned comparison)\n+                    // The arithmetic must be done before the cast, so we can\n+                    // have the correct wrapping behavior. See issue #104519 for\n+                    // the consequences of getting this wrong.\n                     let is_niche =\n                         bx.icmp(predicate, tag, bx.cx().const_uint_big(tag_llty, constant));\n+                    let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n+                    let incr_tag = if delta == 0 {\n+                        tag\n+                    } else {\n+                        bx.add(tag, bx.cx().const_uint_big(tag_llty, delta))\n+                    };\n+\n                     let cast_tag = if cast_smaller {\n-                        bx.intcast(tag, cast_to, false)\n+                        bx.intcast(incr_tag, cast_to, false)\n                     } else if niches_ule {\n-                        bx.zext(tag, cast_to)\n+                        bx.zext(incr_tag, cast_to)\n                     } else {\n-                        bx.sext(tag, cast_to)\n+                        bx.sext(incr_tag, cast_to)\n                     };\n \n-                    let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n-                    (is_niche, cast_tag, delta)\n+                    (is_niche, cast_tag, 0)\n                 } else {\n                     // The special cases don't apply, so we'll have to go with\n                     // the general algorithm."}, {"sha": "76a1288e6d3512622ea743779239605942bf82cf", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -72,7 +72,7 @@ impl<'a, T: PartialOrd> PartialOrd for Interned<'a, T> {\n         if ptr::eq(self.0, other.0) {\n             Some(Ordering::Equal)\n         } else {\n-            let res = self.0.partial_cmp(&other.0);\n+            let res = self.0.partial_cmp(other.0);\n             debug_assert_ne!(res, Some(Ordering::Equal));\n             res\n         }\n@@ -86,7 +86,7 @@ impl<'a, T: Ord> Ord for Interned<'a, T> {\n         if ptr::eq(self.0, other.0) {\n             Ordering::Equal\n         } else {\n-            let res = self.0.cmp(&other.0);\n+            let res = self.0.cmp(other.0);\n             debug_assert_ne!(res, Ordering::Equal);\n             res\n         }"}, {"sha": "3d44e17f31d1fb81ed10f0bf3fb4f0745283a614", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -36,6 +36,12 @@ impl Deref for Mmap {\n \n     #[inline]\n     fn deref(&self) -> &[u8] {\n+        &self.0\n+    }\n+}\n+\n+impl AsRef<[u8]> for Mmap {\n+    fn as_ref(&self) -> &[u8] {\n         &*self.0\n     }\n }\n@@ -96,13 +102,13 @@ impl Deref for MmapMut {\n \n     #[inline]\n     fn deref(&self) -> &[u8] {\n-        &*self.0\n+        &self.0\n     }\n }\n \n impl DerefMut for MmapMut {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut [u8] {\n-        &mut *self.0\n+        &mut self.0\n     }\n }"}, {"sha": "980a540ccba7a5c0758f954cabd9cc5b8fc4a05a", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -899,25 +899,25 @@ unsafe impl<O, T: ?Sized> StableAddress for OwningRef<O, T> {}\n \n impl<O, T: ?Sized> AsRef<T> for OwningRef<O, T> {\n     fn as_ref(&self) -> &T {\n-        &*self\n+        self\n     }\n }\n \n impl<O, T: ?Sized> AsRef<T> for OwningRefMut<O, T> {\n     fn as_ref(&self) -> &T {\n-        &*self\n+        self\n     }\n }\n \n impl<O, T: ?Sized> AsMut<T> for OwningRefMut<O, T> {\n     fn as_mut(&mut self) -> &mut T {\n-        &mut *self\n+        self\n     }\n }\n \n impl<O, T: ?Sized> Borrow<T> for OwningRef<O, T> {\n     fn borrow(&self) -> &T {\n-        &*self\n+        self\n     }\n }\n \n@@ -1021,7 +1021,7 @@ where\n     T: PartialEq,\n {\n     fn eq(&self, other: &Self) -> bool {\n-        (&*self as &T).eq(&*other as &T)\n+        self.deref().eq(other.deref())\n     }\n }\n \n@@ -1032,7 +1032,7 @@ where\n     T: PartialOrd,\n {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        (&*self as &T).partial_cmp(&*other as &T)\n+        self.deref().partial_cmp(other.deref())\n     }\n }\n \n@@ -1041,7 +1041,7 @@ where\n     T: Ord,\n {\n     fn cmp(&self, other: &Self) -> Ordering {\n-        (&*self as &T).cmp(&*other as &T)\n+        self.deref().cmp(other.deref())\n     }\n }\n \n@@ -1050,7 +1050,7 @@ where\n     T: Hash,\n {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        (&*self as &T).hash(state);\n+        self.deref().hash(state);\n     }\n }\n \n@@ -1059,7 +1059,7 @@ where\n     T: PartialEq,\n {\n     fn eq(&self, other: &Self) -> bool {\n-        (&*self as &T).eq(&*other as &T)\n+        self.deref().eq(other.deref())\n     }\n }\n \n@@ -1070,7 +1070,7 @@ where\n     T: PartialOrd,\n {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        (&*self as &T).partial_cmp(&*other as &T)\n+        self.deref().partial_cmp(other.deref())\n     }\n }\n \n@@ -1079,7 +1079,7 @@ where\n     T: Ord,\n {\n     fn cmp(&self, other: &Self) -> Ordering {\n-        (&*self as &T).cmp(&*other as &T)\n+        self.deref().cmp(other.deref())\n     }\n }\n \n@@ -1088,7 +1088,7 @@ where\n     T: Hash,\n {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        (&*self as &T).hash(state);\n+        self.deref().hash(state);\n     }\n }\n "}, {"sha": "aa7a01eed15c9a1438dbfb133632091fc4018a02", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -192,7 +192,7 @@ impl SelfProfilerRef {\n             F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>,\n         {\n             let profiler = profiler_ref.profiler.as_ref().unwrap();\n-            f(&**profiler)\n+            f(profiler)\n         }\n \n         if self.event_filter_mask.contains(event_filter) {\n@@ -466,7 +466,7 @@ impl SelfProfilerRef {\n \n     pub fn with_profiler(&self, f: impl FnOnce(&SelfProfiler)) {\n         if let Some(profiler) = &self.profiler {\n-            f(&profiler)\n+            f(profiler)\n         }\n     }\n \n@@ -733,7 +733,7 @@ impl Drop for VerboseTimingGuard<'_> {\n         if let Some((start_time, start_rss, ref message)) = self.start_and_message {\n             let end_rss = get_resident_set_size();\n             let dur = start_time.elapsed();\n-            print_time_passes_entry(&message, dur, start_rss, end_rss);\n+            print_time_passes_entry(message, dur, start_rss, end_rss);\n         }\n     }\n }"}, {"sha": "cd392a7b678b66ee470e2b36cf8fda14aec9247b", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -366,7 +366,7 @@ impl<CTX> HashStable<CTX> for [u8] {\n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     #[inline]\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        (&self[..]).hash_stable(ctx, hasher);\n+        self[..].hash_stable(ctx, hasher);\n     }\n }\n \n@@ -405,7 +405,7 @@ where\n {\n     #[inline]\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        (&self[..]).hash_stable(ctx, hasher);\n+        self[..].hash_stable(ctx, hasher);\n     }\n }\n \n@@ -440,7 +440,7 @@ impl<CTX> HashStable<CTX> for str {\n impl<CTX> HashStable<CTX> for String {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        (&self[..]).hash_stable(hcx, hasher);\n+        self[..].hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "e4f47b22ac3584d5336ed0d42d5c030f2e82872e", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -201,7 +201,7 @@ cfg_if! {\n \n             #[inline(always)]\n             fn deref(&self) -> &T {\n-                &*self.0\n+                &self.0\n             }\n         }\n "}, {"sha": "22f87514dd8fa133fe2f9993400ecc7d18c37060", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -245,10 +245,8 @@ fn run_compiler(\n                 interface::run_compiler(config, |compiler| {\n                     let sopts = &compiler.session().opts;\n                     if sopts.describe_lints {\n-                        let mut lint_store = rustc_lint::new_lint_store(\n-                            sopts.unstable_opts.no_interleave_lints,\n-                            compiler.session().enable_internal_lints(),\n-                        );\n+                        let mut lint_store =\n+                            rustc_lint::new_lint_store(compiler.session().enable_internal_lints());\n                         let registered_lints =\n                             if let Some(register_lints) = compiler.register_lints() {\n                                 register_lints(compiler.session(), &mut lint_store);"}, {"sha": "a1b7afeb7099d5084e8f619e528a3408e794c56b", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,6 +1,3 @@\n-codegen_gcc_ranlib_failure =\n-    Ranlib exited with code {$exit_code}\n-\n codegen_gcc_linkage_const_or_mut_type =\n     must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n "}, {"sha": "e273476b60bb69d2c44ce27185cb56ea9af7653e", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -29,9 +29,6 @@ codegen_llvm_linkage_const_or_mut_type =\n codegen_llvm_sanitizer_memtag_requires_mte =\n     `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n \n-codegen_llvm_archive_build_failure =\n-    failed to build archive: {$error}\n-\n codegen_llvm_error_writing_def_file =\n     Error writing .DEF file: {$error}\n \n@@ -41,9 +38,6 @@ codegen_llvm_error_calling_dlltool =\n codegen_llvm_dlltool_fail_import_library =\n     Dlltool could not create import library: {$stdout}\\n{$stderr}\n \n-codegen_llvm_unknown_archive_kind =\n-    Don't know how to build archive of type: {$kind}\n-\n codegen_llvm_target_feature_disable_or_enable =\n     the target features {$features} must all be either enabled or disabled together\n "}, {"sha": "4d1f9c1c901fc63d7fc4d877c76379baa2634e8b", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -186,3 +186,9 @@ codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {erro\n codegen_ssa_read_file = failed to read file: {message}\n \n codegen_ssa_unsupported_link_self_contained = option `-C link-self-contained` is not supported on this target\n+\n+codegen_ssa_archive_build_failure =\n+    failed to build archive: {$error}\n+\n+codegen_ssa_unknown_archive_kind =\n+    Don't know how to build archive of type: {$kind}"}, {"sha": "d8879bf70ed39730ee41f5029b51f096b17278b2", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -39,7 +39,7 @@ impl Translate for AnnotateSnippetEmitterWriter {\n     }\n \n     fn fallback_fluent_bundle(&self) -> &FluentBundle {\n-        &**self.fallback_bundle\n+        &self.fallback_bundle\n     }\n }\n \n@@ -49,7 +49,7 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(diag, &fluent_args);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n             &mut primary_span,\n@@ -65,7 +65,7 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n             &diag.code,\n             &primary_span,\n             &children,\n-            &suggestions,\n+            suggestions,\n         );\n     }\n "}, {"sha": "06bb5edc090f48c8b6c326961982ce9730aa6957", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -292,7 +292,7 @@ impl Diagnostic {\n             let lint_index = expectation_id.get_lint_index();\n             expectation_id.set_lint_index(None);\n             let mut stable_id = unstable_to_stable\n-                .get(&expectation_id)\n+                .get(expectation_id)\n                 .expect(\"each unstable `LintExpectationId` must have a matching stable id\")\n                 .normalize();\n "}, {"sha": "db595df8ec18c8cfc2c8c5428996a4bfda4febde", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -283,7 +283,7 @@ pub trait Emitter: Translate {\n                         if self\n                             .source_map()\n                             .map(|sm| is_case_difference(\n-                                &**sm,\n+                                sm,\n                                 substitution,\n                                 sugg.substitutions[0].parts[0].span,\n                             ))\n@@ -525,7 +525,7 @@ impl Translate for EmitterWriter {\n     }\n \n     fn fallback_fluent_bundle(&self) -> &FluentBundle {\n-        &**self.fallback_bundle\n+        &self.fallback_bundle\n     }\n }\n \n@@ -538,7 +538,7 @@ impl Emitter for EmitterWriter {\n         let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(diag, &fluent_args);\n         debug!(\"emit_diagnostic: suggestions={:?}\", suggestions);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n@@ -555,7 +555,7 @@ impl Emitter for EmitterWriter {\n             &diag.code,\n             &primary_span,\n             &children,\n-            &suggestions,\n+            suggestions,\n             self.track_diagnostics.then_some(&diag.emitted_at),\n         );\n     }\n@@ -801,7 +801,7 @@ impl EmitterWriter {\n         }\n \n         let source_string = match file.get_line(line.line_index - 1) {\n-            Some(s) => normalize_whitespace(&*s),\n+            Some(s) => normalize_whitespace(&s),\n             None => return Vec::new(),\n         };\n \n@@ -1148,7 +1148,7 @@ impl EmitterWriter {\n                 (pos + 2, annotation.start_col.saturating_sub(left))\n             };\n             if let Some(ref label) = annotation.label {\n-                buffer.puts(line_offset + pos, code_offset + col, &label, style);\n+                buffer.puts(line_offset + pos, code_offset + col, label, style);\n             }\n         }\n \n@@ -1358,7 +1358,7 @@ impl EmitterWriter {\n             // only render error codes, not lint codes\n             if let Some(DiagnosticId::Error(ref code)) = *code {\n                 buffer.append(0, \"[\", Style::Level(*level));\n-                buffer.append(0, &code, Style::Level(*level));\n+                buffer.append(0, code, Style::Level(*level));\n                 buffer.append(0, \"]\", Style::Level(*level));\n                 label_width += 2 + code.len();\n             }\n@@ -1683,7 +1683,7 @@ impl EmitterWriter {\n         };\n \n         // Render the replacements for each suggestion\n-        let suggestions = suggestion.splice_lines(&**sm);\n+        let suggestions = suggestion.splice_lines(sm);\n         debug!(\"emit_suggestion_default: suggestions={:?}\", suggestions);\n \n         if suggestions.is_empty() {\n@@ -1784,7 +1784,7 @@ impl EmitterWriter {\n                     buffer.puts(\n                         row_num - 1 + line - line_start,\n                         max_line_num_len + 3,\n-                        &normalize_whitespace(&*file_lines.file.get_line(line - 1).unwrap()),\n+                        &normalize_whitespace(&file_lines.file.get_line(line - 1).unwrap()),\n                         Style::Removal,\n                     );\n                 }\n@@ -1926,7 +1926,7 @@ impl EmitterWriter {\n                             buffer.putc(\n                                 row_num,\n                                 (padding as isize + p) as usize,\n-                                if part.is_addition(&sm) { '+' } else { '~' },\n+                                if part.is_addition(sm) { '+' } else { '~' },\n                                 Style::Addition,\n                             );\n                         }\n@@ -1973,7 +1973,7 @@ impl EmitterWriter {\n             buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n         } else if notice_capitalization {\n             let msg = \"notice the capitalization difference\";\n-            buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n+            buffer.puts(row_num, max_line_num_len + 3, msg, Style::NoStyle);\n         }\n         emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         Ok(())\n@@ -2028,7 +2028,7 @@ impl EmitterWriter {\n                     for child in children {\n                         let span = child.render_span.as_ref().unwrap_or(&child.span);\n                         if let Err(err) = self.emit_message_default(\n-                            &span,\n+                            span,\n                             &child.message,\n                             args,\n                             &None,\n@@ -2113,7 +2113,7 @@ impl EmitterWriter {\n                 *row_num - 1,\n                 max_line_num_len + 3,\n                 &normalize_whitespace(\n-                    &*file_lines.file.get_line(file_lines.lines[line_pos].line_index).unwrap(),\n+                    &file_lines.file.get_line(file_lines.lines[line_pos].line_index).unwrap(),\n                 ),\n                 Style::NoStyle,\n             );"}, {"sha": "a37073d8fa32a5a653bdce4cc2280429e4cbb4b3", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -136,7 +136,7 @@ impl Translate for JsonEmitter {\n     }\n \n     fn fallback_fluent_bundle(&self) -> &FluentBundle {\n-        &**self.fallback_bundle\n+        &self.fallback_bundle\n     }\n }\n "}, {"sha": "eb0506c459afa732b0bf07918bf8adfde11659af", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -470,6 +470,7 @@ pub enum StashKey {\n     /// Maybe there was a typo where a comma was forgotten before\n     /// FRU syntax\n     MaybeFruTypo,\n+    CallAssocMethod,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n@@ -1328,7 +1329,7 @@ impl HandlerInner {\n \n             diagnostic.children.drain_filter(already_emitted_sub).for_each(|_| {});\n \n-            self.emitter.emit_diagnostic(&diagnostic);\n+            self.emitter.emit_diagnostic(diagnostic);\n             if diagnostic.is_error() {\n                 self.deduplicated_err_count += 1;\n             } else if let Warning(_) = diagnostic.level {"}, {"sha": "afd660ff1bf1fb6c13d70c6a385243e8c0294f33", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -59,21 +59,21 @@ pub trait Translate {\n         trace!(?message, ?args);\n         let (identifier, attr) = match message {\n             DiagnosticMessage::Str(msg) | DiagnosticMessage::Eager(msg) => {\n-                return Cow::Borrowed(&msg);\n+                return Cow::Borrowed(msg);\n             }\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n         };\n \n         let translate_with_bundle = |bundle: &'a FluentBundle| -> Option<(Cow<'_, str>, Vec<_>)> {\n-            let message = bundle.get_message(&identifier)?;\n+            let message = bundle.get_message(identifier)?;\n             let value = match attr {\n                 Some(attr) => message.get_attribute(attr)?.value(),\n                 None => message.value()?,\n             };\n             debug!(?message, ?value);\n \n             let mut errs = vec![];\n-            let translated = bundle.format_pattern(value, Some(&args), &mut errs);\n+            let translated = bundle.format_pattern(value, Some(args), &mut errs);\n             debug!(?translated, ?errs);\n             Some((translated, errs))\n         };"}, {"sha": "4812bdd9dd8b9c50097fab9ebaa332a65f896bc5", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -539,6 +539,9 @@ impl<'a> ExtCtxt<'a> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: span,\n+                // FIXME(SarthakSingh31): This points to the start of the declaration block and\n+                // not the span of the argument block.\n+                fn_arg_span: span,\n             })),\n         )\n     }"}, {"sha": "a7dfce3b9b8fce1ed528e61df14fc8cad1a2a699", "filename": "compiler/rustc_fs_util/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -65,7 +65,7 @@ pub enum LinkOrCopy {\n pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<LinkOrCopy> {\n     let p = p.as_ref();\n     let q = q.as_ref();\n-    match fs::remove_file(&q) {\n+    match fs::remove_file(q) {\n         Ok(()) => (),\n         Err(err) if err.kind() == io::ErrorKind::NotFound => (),\n         Err(err) => return Err(err),"}, {"sha": "1f8268cc17c539b813021c21f1f1c88fd2689bdc", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -410,7 +410,7 @@ impl<'a> Id<'a> {\n     }\n \n     pub fn as_slice(&'a self) -> &'a str {\n-        &*self.name\n+        &self.name\n     }\n }\n \n@@ -515,7 +515,7 @@ impl<'a> LabelText<'a> {\n     pub fn to_dot_string(&self) -> String {\n         match *self {\n             LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n-            EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s)),\n+            EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(s)),\n             HtmlStr(ref s) => format!(\"<{}>\", s),\n         }\n     }\n@@ -529,7 +529,7 @@ impl<'a> LabelText<'a> {\n             EscStr(s) => s,\n             LabelStr(s) => {\n                 if s.contains('\\\\') {\n-                    (&*s).escape_default().to_string().into()\n+                    s.escape_default().to_string().into()\n                 } else {\n                     s\n                 }"}, {"sha": "636e6e1b48d0ed61e8c64ca9aca4dd3442bddd77", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -943,7 +943,10 @@ pub struct Closure<'hir> {\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n     pub fn_decl: &'hir FnDecl<'hir>,\n     pub body: BodyId,\n+    /// The span of the declaration block: 'move |...| -> ...'\n     pub fn_decl_span: Span,\n+    /// The span of the argument block `|...|`\n+    pub fn_arg_span: Option<Span>,\n     pub movability: Option<Movability>,\n }\n \n@@ -2434,7 +2437,7 @@ impl<'hir> Ty<'hir> {\n     pub fn peel_refs(&self) -> &Self {\n         let mut final_ty = self;\n         while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n-            final_ty = &ty;\n+            final_ty = ty;\n         }\n         final_ty\n     }"}, {"sha": "93613ef27d404df43e5429ce36591de783b983ef", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -116,7 +116,7 @@ impl Ord for HirId {\n \n impl PartialOrd for HirId {\n     fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n-        Some(self.cmp(&other))\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "938ace2c785bbf1aa7d2bd9cfd50a5bf98146979", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -448,7 +448,7 @@ pub trait Visitor<'v>: Sized {\n \n pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n-    visitor.visit_pat(&param.pat);\n+    visitor.visit_pat(param.pat);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n@@ -470,7 +470,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n         }\n         ItemKind::Fn(ref sig, ref generics, body_id) => visitor.visit_fn(\n             FnKind::ItemFn(item.ident, generics, sig.header),\n-            &sig.decl,\n+            sig.decl,\n             body_id,\n             item.span,\n             item.hir_id(),\n@@ -544,7 +544,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n     walk_list!(visitor, visit_param, body.params);\n-    visitor.visit_expr(&body.value);\n+    visitor.visit_expr(body.value);\n }\n \n pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n@@ -580,7 +580,7 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n     visitor.visit_id(local.hir_id);\n-    visitor.visit_pat(&local.pat);\n+    visitor.visit_pat(local.pat);\n     if let Some(els) = local.els {\n         visitor.visit_block(els);\n     }\n@@ -606,7 +606,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n     visitor.visit_id(arm.hir_id);\n-    visitor.visit_pat(&arm.pat);\n+    visitor.visit_pat(arm.pat);\n     if let Some(ref g) = arm.guard {\n         match g {\n             Guard::If(ref e) => visitor.visit_expr(e),\n@@ -615,7 +615,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n             }\n         }\n     }\n-    visitor.visit_expr(&arm.body);\n+    visitor.visit_expr(arm.body);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n@@ -660,7 +660,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n pub fn walk_pat_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v PatField<'v>) {\n     visitor.visit_id(field.hir_id);\n     visitor.visit_ident(field.ident);\n-    visitor.visit_pat(&field.pat)\n+    visitor.visit_pat(field.pat)\n }\n \n pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n@@ -740,6 +740,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             body,\n             capture_clause: _,\n             fn_decl_span: _,\n+            fn_arg_span: _,\n             movability: _,\n         }) => {\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n@@ -799,26 +800,26 @@ pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>)\n pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n     visitor.visit_id(field.hir_id);\n     visitor.visit_ident(field.ident);\n-    visitor.visit_expr(&field.expr)\n+    visitor.visit_expr(field.expr)\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n     visitor.visit_id(typ.hir_id);\n \n     match typ.kind {\n         TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(mutable_type.ty),\n         TyKind::Rptr(ref lifetime, ref mutable_type) => {\n             visitor.visit_lifetime(lifetime);\n-            visitor.visit_ty(&mutable_type.ty)\n+            visitor.visit_ty(mutable_type.ty)\n         }\n         TyKind::Never => {}\n         TyKind::Tup(tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n         TyKind::BareFn(ref function_declaration) => {\n             walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n-            visitor.visit_fn_decl(&function_declaration.decl);\n+            visitor.visit_fn_decl(function_declaration.decl);\n         }\n         TyKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n@@ -951,8 +952,8 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n     let hir_id = trait_item.hir_id();\n     visitor.visit_ident(ident);\n-    visitor.visit_generics(&generics);\n-    visitor.visit_defaultness(&defaultness);\n+    visitor.visit_generics(generics);\n+    visitor.visit_defaultness(defaultness);\n     match *kind {\n         TraitItemKind::Const(ref ty, default) => {\n             visitor.visit_id(hir_id);\n@@ -961,13 +962,13 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Required(param_names)) => {\n             visitor.visit_id(hir_id);\n-            visitor.visit_fn_decl(&sig.decl);\n+            visitor.visit_fn_decl(sig.decl);\n             for &param_name in param_names {\n                 visitor.visit_ident(param_name);\n             }\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Provided(body_id)) => {\n-            visitor.visit_fn(FnKind::Method(ident, sig), &sig.decl, body_id, span, hir_id);\n+            visitor.visit_fn(FnKind::Method(ident, sig), sig.decl, body_id, span, hir_id);\n         }\n         TraitItemKind::Type(bounds, ref default) => {\n             visitor.visit_id(hir_id);\n@@ -1009,7 +1010,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         ImplItemKind::Fn(ref sig, body_id) => {\n             visitor.visit_fn(\n                 FnKind::Method(impl_item.ident, sig),\n-                &sig.decl,\n+                sig.decl,\n                 body_id,\n                 impl_item.span,\n                 impl_item.hir_id(),\n@@ -1042,7 +1043,7 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n \n pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n     visitor.visit_id(trait_ref.hir_ref_id);\n-    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n+    visitor.visit_path(trait_ref.path, trait_ref.hir_ref_id)\n }\n \n pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n@@ -1074,7 +1075,7 @@ pub fn walk_struct_def<'v, V: Visitor<'v>>(\n pub fn walk_field_def<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v FieldDef<'v>) {\n     visitor.visit_id(field.hir_id);\n     visitor.visit_ident(field.ident);\n-    visitor.visit_ty(&field.ty);\n+    visitor.visit_ty(field.ty);\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>("}, {"sha": "f64d65cc6ad7a303ac18eeca030d70b0f93c6a70", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -11,7 +11,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::{\n     self, subst, subst::SubstsRef, GenericParamDef, GenericParamDefKind, IsSuggestable, Ty, TyCtxt,\n };\n@@ -83,9 +82,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 Res::Def(DefKind::TyParam, src_def_id) => {\n                     if let Some(param_local_id) = param.def_id.as_local() {\n                         let param_name = tcx.hir().ty_param_name(param_local_id);\n-                        let infcx = tcx.infer_ctxt().build();\n-                        let param_type =\n-                            infcx.resolve_numeric_literals_with_default(tcx.type_of(param.def_id));\n+                        let param_type = tcx.type_of(param.def_id);\n                         if param_type.is_suggestable(tcx, false) {\n                             err.span_suggestion(\n                                 tcx.def_span(src_def_id),"}, {"sha": "f204d59d00556b604e432d02c77d120f5513a60f", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -347,7 +347,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert!(self_ty.is_some());\n             }\n         } else {\n-            assert!(self_ty.is_none() && parent_substs.is_empty());\n+            assert!(self_ty.is_none());\n         }\n \n         let arg_count = Self::check_generic_arg_count(\n@@ -1821,7 +1821,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n-        if let ty::Adt(adt_def, _) = qself_ty.kind() {\n+        if let ty::Adt(adt_def, adt_substs) = qself_ty.kind() {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n                     .variants()\n@@ -1923,8 +1923,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let Some(assoc_ty_did) = self.lookup_assoc_ty(assoc_ident, hir_ref_id, span, impl_) else {\n                     continue;\n                 };\n-                // FIXME(inherent_associated_types): This does not substitute parameters.\n-                let ty = tcx.type_of(assoc_ty_did);\n+                let item_substs = self.create_substs_for_associated_item(\n+                    span,\n+                    assoc_ty_did,\n+                    assoc_segment,\n+                    adt_substs,\n+                );\n+                let ty = tcx.bound_type_of(assoc_ty_did).subst(tcx, item_substs);\n                 return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n             }\n         }"}, {"sha": "82a77416a190c44c60c0ffa92c3768233509b8e9", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -173,13 +173,11 @@ fn compare_predicate_entailment<'tcx>(\n         impl_to_placeholder_substs.rebase_onto(tcx, impl_m.container_id(tcx), trait_to_impl_substs);\n     debug!(\"compare_impl_method: trait_to_placeholder_substs={:?}\", trait_to_placeholder_substs);\n \n-    let impl_m_generics = tcx.generics_of(impl_m.def_id);\n-    let trait_m_generics = tcx.generics_of(trait_m.def_id);\n     let impl_m_predicates = tcx.predicates_of(impl_m.def_id);\n     let trait_m_predicates = tcx.predicates_of(trait_m.def_id);\n \n     // Check region bounds.\n-    check_region_bounds_on_impl_item(tcx, impl_m, trait_m, &trait_m_generics, &impl_m_generics)?;\n+    check_region_bounds_on_impl_item(tcx, impl_m, trait_m, false)?;\n \n     // Create obligations for each predicate declared by the impl\n     // definition in the context of the trait's parameter\n@@ -338,6 +336,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     // First, check a few of the same thing as `compare_impl_method`, just so we don't ICE during substitutions later.\n     compare_number_of_generics(tcx, impl_m, trait_m, tcx.hir().span_if_local(impl_m.def_id), true)?;\n     compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n+    check_region_bounds_on_impl_item(tcx, impl_m, trait_m, true)?;\n \n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n@@ -722,12 +721,14 @@ fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     trait_m: &ty::AssocItem,\n-    trait_generics: &ty::Generics,\n-    impl_generics: &ty::Generics,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n-    let trait_params = trait_generics.own_counts().lifetimes;\n+    let impl_generics = tcx.generics_of(impl_m.def_id);\n     let impl_params = impl_generics.own_counts().lifetimes;\n \n+    let trait_generics = tcx.generics_of(trait_m.def_id);\n+    let trait_params = trait_generics.own_counts().lifetimes;\n+\n     debug!(\n         \"check_region_bounds_on_impl_item: \\\n             trait_generics={:?} \\\n@@ -761,12 +762,16 @@ fn check_region_bounds_on_impl_item<'tcx>(\n             None\n         };\n \n-        let reported = tcx.sess.emit_err(LifetimesOrBoundsMismatchOnTrait {\n-            span,\n-            item_kind: assoc_item_kind_str(impl_m),\n-            ident: impl_m.ident(tcx),\n-            generics_span,\n-        });\n+        let reported = tcx\n+            .sess\n+            .create_err(LifetimesOrBoundsMismatchOnTrait {\n+                span,\n+                item_kind: assoc_item_kind_str(impl_m),\n+                ident: impl_m.ident(tcx),\n+                generics_span,\n+            })\n+            .emit_unless(delay);\n+\n         return Err(reported);\n     }\n \n@@ -1504,18 +1509,10 @@ fn compare_type_predicate_entailment<'tcx>(\n     let trait_to_impl_substs =\n         impl_substs.rebase_onto(tcx, impl_ty.container_id(tcx), impl_trait_ref.substs);\n \n-    let impl_ty_generics = tcx.generics_of(impl_ty.def_id);\n-    let trait_ty_generics = tcx.generics_of(trait_ty.def_id);\n     let impl_ty_predicates = tcx.predicates_of(impl_ty.def_id);\n     let trait_ty_predicates = tcx.predicates_of(trait_ty.def_id);\n \n-    check_region_bounds_on_impl_item(\n-        tcx,\n-        impl_ty,\n-        trait_ty,\n-        &trait_ty_generics,\n-        &impl_ty_generics,\n-    )?;\n+    check_region_bounds_on_impl_item(tcx, impl_ty, trait_ty, false)?;\n \n     let impl_ty_own_bounds = impl_ty_predicates.instantiate_own(tcx, impl_substs);\n "}, {"sha": "b315ebad4686c37d4bac86575a991a744e2c27f0", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -241,17 +241,46 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n             hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::And, .. },\n-                _,\n-                ref r,\n-            )\n-            | hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::Or, .. },\n-                _,\n+                source_map::Spanned { node: hir::BinOpKind::And | hir::BinOpKind::Or, .. },\n+                ref l,\n                 ref r,\n             ) => {\n-                // For shortcircuiting operators, mark the RHS as a terminating\n-                // scope since it only executes conditionally.\n+                // expr is a short circuiting operator (|| or &&). As its\n+                // functionality can't be overridden by traits, it always\n+                // processes bool sub-expressions. bools are Copy and thus we\n+                // can drop any temporaries in evaluation (read) order\n+                // (with the exception of potentially failing let expressions).\n+                // We achieve this by enclosing the operands in a terminating\n+                // scope, both the LHS and the RHS.\n+\n+                // We optimize this a little in the presence of chains.\n+                // Chains like a && b && c get lowered to AND(AND(a, b), c).\n+                // In here, b and c are RHS, while a is the only LHS operand in\n+                // that chain. This holds true for longer chains as well: the\n+                // leading operand is always the only LHS operand that is not a\n+                // binop itself. Putting a binop like AND(a, b) into a\n+                // terminating scope is not useful, thus we only put the LHS\n+                // into a terminating scope if it is not a binop.\n+\n+                let terminate_lhs = match l.kind {\n+                    // let expressions can create temporaries that live on\n+                    hir::ExprKind::Let(_) => false,\n+                    // binops already drop their temporaries, so there is no\n+                    // need to put them into a terminating scope.\n+                    // This is purely an optimization to reduce the number of\n+                    // terminating scopes.\n+                    hir::ExprKind::Binary(\n+                        source_map::Spanned {\n+                            node: hir::BinOpKind::And | hir::BinOpKind::Or, ..\n+                        },\n+                        ..,\n+                    ) => false,\n+                    // otherwise: mark it as terminating\n+                    _ => true,\n+                };\n+                if terminate_lhs {\n+                    terminating(l.hir_id.local_id);\n+                }\n \n                 // `Let` expressions (in a let-chain) shouldn't be terminating, as their temporaries\n                 // should live beyond the immediate expression"}, {"sha": "b065ace6bf5e15f826f54eecaa60c0b918be0e7c", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1544,7 +1544,7 @@ fn check_fn_or_method<'tcx>(\n     check_where_clauses(wfcx, span, def_id);\n \n     check_return_position_impl_trait_in_trait_bounds(\n-        tcx,\n+        wfcx,\n         def_id,\n         sig.output(),\n         hir_decl.output.span(),\n@@ -1580,13 +1580,14 @@ fn check_fn_or_method<'tcx>(\n \n /// Basically `check_associated_type_bounds`, but separated for now and should be\n /// deduplicated when RPITITs get lowered into real associated items.\n-#[tracing::instrument(level = \"trace\", skip(tcx))]\n+#[tracing::instrument(level = \"trace\", skip(wfcx))]\n fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     fn_def_id: LocalDefId,\n     fn_output: Ty<'tcx>,\n     span: Span,\n ) {\n+    let tcx = wfcx.tcx();\n     if let Some(assoc_item) = tcx.opt_associated_item(fn_def_id.to_def_id())\n         && assoc_item.container == ty::AssocItemContainer::TraitContainer\n     {\n@@ -1596,22 +1597,20 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n                 && tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n                 && tcx.impl_trait_in_trait_parent(proj.item_def_id) == fn_def_id.to_def_id()\n             {\n-                // Create a new context, since we want the opaque's ParamEnv and not the parent's.\n                 let span = tcx.def_span(proj.item_def_id);\n-                enter_wf_checking_ctxt(tcx, span, proj.item_def_id.expect_local(), |wfcx| {\n-                    let bounds = wfcx.tcx().explicit_item_bounds(proj.item_def_id);\n-                    let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-                        let normalized_bound = wfcx.normalize(span, None, bound);\n-                        traits::wf::predicate_obligations(\n-                            wfcx.infcx,\n-                            wfcx.param_env,\n-                            wfcx.body_id,\n-                            normalized_bound,\n-                            bound_span,\n-                        )\n-                    });\n-                    wfcx.register_obligations(wf_obligations);\n+                let bounds = wfcx.tcx().explicit_item_bounds(proj.item_def_id);\n+                let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n+                    let bound = ty::EarlyBinder(bound).subst(tcx, proj.substs);\n+                    let normalized_bound = wfcx.normalize(span, None, bound);\n+                    traits::wf::predicate_obligations(\n+                        wfcx.infcx,\n+                        wfcx.param_env,\n+                        wfcx.body_id,\n+                        normalized_bound,\n+                        bound_span,\n+                    )\n                 });\n+                wfcx.register_obligations(wf_obligations);\n             }\n         }\n     }"}, {"sha": "5749b04783ce4ff8c7608e83771a3754471fffe4", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -56,25 +56,6 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let unused_extern_crates: FxHashMap<LocalDefId, Span> = tcx\n         .maybe_unused_extern_crates(())\n         .iter()\n-        .filter(|&&(def_id, _)| {\n-            // The `def_id` here actually was calculated during resolution (at least\n-            // at the time of this writing) and is being shipped to us via a side\n-            // channel of the tcx. There may have been extra expansion phases,\n-            // however, which ended up removing the `def_id` *after* expansion.\n-            //\n-            // As a result we need to verify that `def_id` is indeed still valid for\n-            // our AST and actually present in the HIR map. If it's not there then\n-            // there's safely nothing to warn about, and otherwise we carry on with\n-            // our execution.\n-            //\n-            // Note that if we carry through to the `extern_mod_stmt_cnum` query\n-            // below it'll cause a panic because `def_id` is actually bogus at this\n-            // point in time otherwise.\n-            if tcx.hir().find(tcx.hir().local_def_id_to_hir_id(def_id)).is_none() {\n-                return false;\n-            }\n-            true\n-        })\n         .filter(|&&(def_id, _)| {\n             tcx.extern_mod_stmt_cnum(def_id).map_or(true, |cnum| {\n                 !tcx.is_compiler_builtins(cnum)"}, {"sha": "b7084303aafb1d0b85c1c0f2c0423b30c6e519f5", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -2073,6 +2073,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n         }\n     }\n \n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+        codegen_fn_attrs.inline = InlineAttr::Never;\n+    }\n+\n     // Weak lang items have the same semantics as \"std internal\" symbols in the\n     // sense that they're preserved through all our LTO passes and only\n     // strippable by the linker."}, {"sha": "3791b2c8661a71a318da4d94848795109e40682e", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1480,6 +1480,7 @@ impl<'a> State<'a> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: _,\n+                fn_arg_span: _,\n                 movability: _,\n                 def_id: _,\n             }) => {"}, {"sha": "429cb60ba2b6161692c9153041a068ce638e69d5", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -456,10 +456,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .map(|ty| ArgKind::from_expected_ty(*ty, None))\n             .collect();\n-        let (closure_span, found_args) = match self.get_fn_like_arguments(expr_map_node) {\n-            Some((sp, args)) => (Some(sp), args),\n-            None => (None, Vec::new()),\n-        };\n+        let (closure_span, closure_arg_span, found_args) =\n+            match self.get_fn_like_arguments(expr_map_node) {\n+                Some((sp, arg_sp, args)) => (Some(sp), arg_sp, args),\n+                None => (None, None, Vec::new()),\n+            };\n         let expected_span =\n             expected_sig.cause_span.unwrap_or_else(|| self.tcx.def_span(expr_def_id));\n         self.report_arg_count_mismatch(\n@@ -468,6 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expected_args,\n             found_args,\n             true,\n+            closure_arg_span,\n         )\n         .emit();\n "}, {"sha": "4a112e80f1d98f0ec775795fe304feb3c83c8e2d", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -528,6 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.resolve_ty_and_res_fully_qualified_call(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n             Res::Err => {\n+                self.suggest_assoc_method_call(segs);\n                 let e =\n                     self.tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n                 self.set_tainted_by_errors(e);"}, {"sha": "3078e0cbeda59cd42a0b3b63ef9945165386f0fb", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1918,6 +1918,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         receiver: Option<&'tcx hir::Expr<'tcx>>,\n         args: &'tcx [hir::Expr<'tcx>],\n     ) -> bool {\n+        // Do not call `fn_sig` on non-functions.\n+        if !matches!(\n+            self.tcx.def_kind(def_id),\n+            DefKind::Fn | DefKind::AssocFn | DefKind::Variant | DefKind::Ctor(..)\n+        ) {\n+            return false;\n+        }\n+\n         let sig = self.tcx.fn_sig(def_id).skip_binder();\n         let args_referencing_param: Vec<_> = sig\n             .inputs()"}, {"sha": "1e9b57521308580fe83adfb40e844bfc38606dc9", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode};\n+use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::cell::{Cell, RefCell};\n use std::ops::Deref;\n@@ -162,6 +162,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             infcx: &self.infcx,\n             typeck_results: Some(self.typeck_results.borrow()),\n             fallback_has_occurred: self.fallback_has_occurred.get(),\n+            normalize_fn_sig: Box::new(|fn_sig| {\n+                if fn_sig.has_escaping_bound_vars() {\n+                    return fn_sig;\n+                }\n+                self.probe(|_| {\n+                    let ocx = ObligationCtxt::new_in_snapshot(self);\n+                    let normalized_fn_sig =\n+                        ocx.normalize(&ObligationCause::dummy(), self.param_env, fn_sig);\n+                    if ocx.select_all_or_error().is_empty() {\n+                        let normalized_fn_sig = self.resolve_vars_if_possible(normalized_fn_sig);\n+                        if !normalized_fn_sig.needs_infer() {\n+                            return normalized_fn_sig;\n+                        }\n+                    }\n+                    fn_sig\n+                })\n+            }),\n         }\n     }\n "}, {"sha": "1daca464b4772c2b07d4789a3c2286dd597ca18b", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n };\n use rustc_hir_analysis::astconv::AstConv;\n-use rustc_infer::infer::{self, TyCtxtInferExt};\n+use rustc_infer::infer;\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty};\n@@ -921,19 +921,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n             let bound_vars = self.tcx.late_bound_vars(fn_id);\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n-            let ty = self.normalize(expr.span, ty);\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n-                hir::IsAsync::Async => {\n-                    let infcx = self.tcx.infer_ctxt().build();\n-                    infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n-                        span_bug!(\n-                            fn_decl.output.span(),\n-                            \"failed to get output type of async function\"\n-                        )\n-                    })\n-                }\n+                hir::IsAsync::Async => self.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n+                    span_bug!(fn_decl.output.span(), \"failed to get output type of async function\")\n+                }),\n                 hir::IsAsync::NotAsync => ty,\n             };\n+            let ty = self.normalize(expr.span, ty);\n             if self.can_coerce(found, ty) {\n                 err.multipart_suggestion(\n                     \"you might have meant to return this value\","}, {"sha": "b33e7b8d68cf927251a4e85a9c57a672fcabf9b5", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,7 +1,6 @@\n use super::callee::DeferredCallResolution;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n@@ -11,9 +10,7 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefIdMap;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCtxt, TraitEngine, TraitEngineExt as _,\n-};\n+use rustc_trait_selection::traits::{self, TraitEngine, TraitEngineExt as _};\n \n use std::cell::RefCell;\n use std::ops::Deref;\n@@ -92,29 +89,7 @@ impl<'tcx> Inherited<'tcx> {\n             infcx: tcx\n                 .infer_ctxt()\n                 .ignoring_regions()\n-                .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n-                .with_normalize_fn_sig_for_diagnostic(Lrc::new(move |infcx, fn_sig| {\n-                    if fn_sig.has_escaping_bound_vars() {\n-                        return fn_sig;\n-                    }\n-                    infcx.probe(|_| {\n-                        let ocx = ObligationCtxt::new_in_snapshot(infcx);\n-                        let normalized_fn_sig = ocx.normalize(\n-                            &ObligationCause::dummy(),\n-                            // FIXME(compiler-errors): This is probably not the right param-env...\n-                            infcx.tcx.param_env(def_id),\n-                            fn_sig,\n-                        );\n-                        if ocx.select_all_or_error().is_empty() {\n-                            let normalized_fn_sig =\n-                                infcx.resolve_vars_if_possible(normalized_fn_sig);\n-                            if !normalized_fn_sig.needs_infer() {\n-                                return normalized_fn_sig;\n-                            }\n-                        }\n-                        fn_sig\n-                    })\n-                })),\n+                .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)),\n             def_id,\n             typeck_results: RefCell::new(ty::TypeckResults::new(hir_owner)),\n         }"}, {"sha": "a2ca5c3b7b7493a9d0330b772fd87e9bdbced645", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, GenericParamDefKind, Ty, TypeVisitable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // We probe again, taking all traits into account (not only those in scope).\n-            let mut candidates =\n+            let candidates =\n                 match self.lookup_probe(segment.ident, self_ty, call_expr, ProbeScope::AllTraits) {\n                     // If we find a different result the caller probably forgot to import a trait.\n                     Ok(ref new_pick) if pick.differs_from(new_pick) => {\n@@ -236,7 +236,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .collect(),\n                     _ => Vec::new(),\n                 };\n-            candidates.retain(|candidate| *candidate != self.tcx.parent(result.callee.def_id));\n \n             return Err(IllegalSizedBound(candidates, needs_mut, span));\n         }"}, {"sha": "ae299cc9d13706d1402600eef7c2a61328144f87", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -9,7 +9,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def::Namespace;\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -1876,6 +1875,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         self.tcx.erase_late_bound_regions(value)\n     }\n \n+    /// Determine if the given associated item type is relevant in the current context.\n+    fn is_relevant_kind_for_mode(&self, kind: ty::AssocKind) -> bool {\n+        match (self.mode, kind) {\n+            (Mode::MethodCall, ty::AssocKind::Fn) => true,\n+            (Mode::Path, ty::AssocKind::Const | ty::AssocKind::Fn) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Finds the method with the appropriate name (or return type, as the case may be). If\n     /// `allow_similar_names` is set, find methods with close-matching names.\n     // The length of the returned iterator is nearly always 0 or 1 and this\n@@ -1888,7 +1896,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .associated_items(def_id)\n                     .in_definition_order()\n                     .filter(|x| {\n-                        if x.kind.namespace() != Namespace::ValueNS {\n+                        if !self.is_relevant_kind_for_mode(x.kind) {\n                             return false;\n                         }\n                         match lev_distance_with_substrings(name.as_str(), x.name.as_str(), max_dist)\n@@ -1902,10 +1910,16 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             } else {\n                 self.fcx\n                     .associated_value(def_id, name)\n+                    .filter(|x| self.is_relevant_kind_for_mode(x.kind))\n                     .map_or_else(SmallVec::new, |x| SmallVec::from_buf([x]))\n             }\n         } else {\n-            self.tcx.associated_items(def_id).in_definition_order().copied().collect()\n+            self.tcx\n+                .associated_items(def_id)\n+                .in_definition_order()\n+                .filter(|x| self.is_relevant_kind_for_mode(x.kind))\n+                .copied()\n+                .collect()\n         }\n     }\n }"}, {"sha": "9ba4ddfd5cf7fd37920e965bfe97bb23a0e137f9", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -5,6 +5,7 @@ use crate::errors;\n use crate::FnCtxt;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::StashKey;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n     MultiSpan,\n@@ -13,6 +14,8 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n+use rustc_hir::PatKind::Binding;\n+use rustc_hir::PathSegment;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::{\n     type_variable::{TypeVariableOrigin, TypeVariableOriginKind},\n@@ -35,11 +38,11 @@ use rustc_trait_selection::traits::{\n     FulfillmentError, Obligation, ObligationCause, ObligationCauseCode,\n };\n \n-use std::cmp::Ordering;\n-use std::iter;\n-\n use super::probe::{AutorefOrPtrAdjustment, IsSuggestion, Mode, ProbeScope};\n use super::{CandidateSource, MethodError, NoMatchData};\n+use rustc_hir::intravisit::Visitor;\n+use std::cmp::Ordering;\n+use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn is_fn_ty(&self, ty: Ty<'tcx>, span: Span) -> bool {\n@@ -1462,6 +1465,61 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    /// For code `rect::area(...)`,\n+    /// if `rect` is a local variable and `area` is a valid assoc method for it,\n+    /// we try to suggest `rect.area()`\n+    pub(crate) fn suggest_assoc_method_call(&self, segs: &[PathSegment<'_>]) {\n+        debug!(\"suggest_assoc_method_call segs: {:?}\", segs);\n+        let [seg1, seg2] = segs else { return; };\n+        let Some(mut diag) =\n+                self.tcx.sess.diagnostic().steal_diagnostic(seg1.ident.span, StashKey::CallAssocMethod)\n+                else { return };\n+\n+        let map = self.infcx.tcx.hir();\n+        let body = map.body(rustc_hir::BodyId { hir_id: self.body_id });\n+        struct LetVisitor<'a> {\n+            result: Option<&'a hir::Expr<'a>>,\n+            ident_name: Symbol,\n+        }\n+\n+        impl<'v> Visitor<'v> for LetVisitor<'v> {\n+            fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n+                if let hir::StmtKind::Local(hir::Local { pat, init, .. }) = &ex.kind {\n+                    if let Binding(_, _, ident, ..) = pat.kind &&\n+                        ident.name == self.ident_name {\n+                        self.result = *init;\n+                    }\n+                }\n+                hir::intravisit::walk_stmt(self, ex);\n+            }\n+        }\n+\n+        let mut visitor = LetVisitor { result: None, ident_name: seg1.ident.name };\n+        visitor.visit_body(&body);\n+\n+        let parent = self.tcx.hir().get_parent_node(seg1.hir_id);\n+        if let Some(Node::Expr(call_expr)) = self.tcx.hir().find(parent) &&\n+            let Some(expr) = visitor.result {\n+            let self_ty = self.node_ty(expr.hir_id);\n+            let probe = self.lookup_probe(\n+                seg2.ident,\n+                self_ty,\n+                call_expr,\n+                ProbeScope::TraitsInScope,\n+            );\n+            if probe.is_ok() {\n+                let sm = self.infcx.tcx.sess.source_map();\n+                diag.span_suggestion_verbose(\n+                    sm.span_extend_while(seg1.ident.span.shrink_to_hi(), |c| c == ':').unwrap(),\n+                    \"you may have meant to call an instance method\",\n+                    \".\".to_string(),\n+                    Applicability::MaybeIncorrect\n+                );\n+            }\n+        }\n+        diag.emit();\n+    }\n+\n     /// Suggest calling a method on a field i.e. `a.field.bar()` instead of `a.bar()`\n     fn suggest_calling_method_on_field(\n         &self,"}, {"sha": "4429e4f43629a885543c06a5ac61426e96825760", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -77,10 +77,6 @@ impl<'tcx> InferCtxt<'tcx> {\n             err_count_on_creation: self.err_count_on_creation,\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n-            normalize_fn_sig_for_diagnostic: self\n-                .normalize_fn_sig_for_diagnostic\n-                .as_ref()\n-                .map(|f| f.clone()),\n             intercrate: self.intercrate,\n         }\n     }"}, {"sha": "662136ca18df6747485a7fc9c0bf5770ccf0cd50", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -95,6 +95,7 @@ pub mod nice_region_error;\n pub struct TypeErrCtxt<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n+    pub normalize_fn_sig: Box<dyn Fn(ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx> + 'a>,\n     pub fallback_has_occurred: bool,\n }\n \n@@ -1007,22 +1008,14 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n-    fn normalize_fn_sig_for_diagnostic(&self, sig: ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        if let Some(normalize) = &self.normalize_fn_sig_for_diagnostic {\n-            normalize(self, sig)\n-        } else {\n-            sig\n-        }\n-    }\n-\n     /// Given two `fn` signatures highlight only sub-parts that are different.\n     fn cmp_fn_sig(\n         &self,\n         sig1: &ty::PolyFnSig<'tcx>,\n         sig2: &ty::PolyFnSig<'tcx>,\n     ) -> (DiagnosticStyledString, DiagnosticStyledString) {\n-        let sig1 = &self.normalize_fn_sig_for_diagnostic(*sig1);\n-        let sig2 = &self.normalize_fn_sig_for_diagnostic(*sig2);\n+        let sig1 = &(self.normalize_fn_sig)(*sig1);\n+        let sig2 = &(self.normalize_fn_sig)(*sig2);\n \n         let get_lifetimes = |sig| {\n             use rustc_hir::def::Namespace;\n@@ -1262,7 +1255,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     let num_display_types = consts_offset - regions_len;\n                     for (i, (ta1, ta2)) in type_arguments.take(num_display_types).enumerate() {\n                         let i = i + regions_len;\n-                        if ta1 == ta2 {\n+                        if ta1 == ta2 && !self.tcx.sess.verbose() {\n                             values.0.push_normal(\"_\");\n                             values.1.push_normal(\"_\");\n                         } else {\n@@ -1278,7 +1271,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     let const_arguments = sub1.consts().zip(sub2.consts());\n                     for (i, (ca1, ca2)) in const_arguments.enumerate() {\n                         let i = i + consts_offset;\n-                        if ca1 == ca2 {\n+                        if ca1 == ca2 && !self.tcx.sess.verbose() {\n                             values.0.push_normal(\"_\");\n                             values.1.push_normal(\"_\");\n                         } else {\n@@ -1457,7 +1450,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             (ty::FnPtr(sig1), ty::FnPtr(sig2)) => self.cmp_fn_sig(sig1, sig2),\n \n             _ => {\n-                if t1 == t2 {\n+                if t1 == t2 && !self.tcx.sess.verbose() {\n                     // The two types are the same, elide and don't highlight.\n                     (DiagnosticStyledString::normal(\"_\"), DiagnosticStyledString::normal(\"_\"))\n                 } else {"}, {"sha": "2ce7cd8beba98a5e8cf4f154161e0e325df5f484", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -80,7 +80,6 @@ pub struct InferOk<'tcx, T> {\n }\n pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n \n-pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n \n@@ -334,9 +333,6 @@ pub struct InferCtxt<'tcx> {\n     /// bound.\n     universe: Cell<ty::UniverseIndex>,\n \n-    normalize_fn_sig_for_diagnostic:\n-        Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n-\n     /// During coherence we have to assume that other crates may add\n     /// additional impls which we currently don't know about.\n     ///\n@@ -573,8 +569,6 @@ pub struct InferCtxtBuilder<'tcx> {\n     considering_regions: bool,\n     /// Whether we are in coherence mode.\n     intercrate: bool,\n-    normalize_fn_sig_for_diagnostic:\n-        Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -587,7 +581,6 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             tcx: self,\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n-            normalize_fn_sig_for_diagnostic: None,\n             intercrate: false,\n         }\n     }\n@@ -615,14 +608,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n-    pub fn with_normalize_fn_sig_for_diagnostic(\n-        mut self,\n-        fun: Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>,\n-    ) -> Self {\n-        self.normalize_fn_sig_for_diagnostic = Some(fun);\n-        self\n-    }\n-\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -644,13 +629,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn build(&mut self) -> InferCtxt<'tcx> {\n-        let InferCtxtBuilder {\n-            tcx,\n-            defining_use_anchor,\n-            considering_regions,\n-            ref normalize_fn_sig_for_diagnostic,\n-            intercrate,\n-        } = *self;\n+        let InferCtxtBuilder { tcx, defining_use_anchor, considering_regions, intercrate } = *self;\n         InferCtxt {\n             tcx,\n             defining_use_anchor,\n@@ -666,9 +645,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             in_snapshot: Cell::new(false),\n             skip_leak_check: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n-            normalize_fn_sig_for_diagnostic: normalize_fn_sig_for_diagnostic\n-                .as_ref()\n-                .map(|f| f.clone()),\n             intercrate,\n         }\n     }\n@@ -709,7 +685,12 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// Creates a `TypeErrCtxt` for emitting various inference errors.\n     /// During typeck, use `FnCtxt::err_ctxt` instead.\n     pub fn err_ctxt(&self) -> TypeErrCtxt<'_, 'tcx> {\n-        TypeErrCtxt { infcx: self, typeck_results: None, fallback_has_occurred: false }\n+        TypeErrCtxt {\n+            infcx: self,\n+            typeck_results: None,\n+            fallback_has_occurred: false,\n+            normalize_fn_sig: Box::new(|fn_sig| fn_sig),\n+        }\n     }\n \n     pub fn is_in_snapshot(&self) -> bool {"}, {"sha": "6b5b5df9e2a7d441b2c4ba7c36a5030664fab679", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -207,10 +207,7 @@ pub fn register_plugins<'a>(\n         });\n     }\n \n-    let mut lint_store = rustc_lint::new_lint_store(\n-        sess.opts.unstable_opts.no_interleave_lints,\n-        sess.enable_internal_lints(),\n-    );\n+    let mut lint_store = rustc_lint::new_lint_store(sess.enable_internal_lints());\n     register_lints(sess, &mut lint_store);\n \n     let registrars ="}, {"sha": "a6205f4d3a531dd1a519d62ea281fb2ea9876495", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -666,7 +666,6 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(mir_pretty_relative_line_numbers, true);\n     untracked!(nll_facts, true);\n     untracked!(no_analysis, true);\n-    untracked!(no_interleave_lints, true);\n     untracked!(no_leak_check, true);\n     untracked!(no_parallel_llvm, true);\n     untracked!(parse_only, true);"}, {"sha": "23294dc2e1b6a952412fc16e55cbb61eef627059", "filename": "compiler/rustc_lexer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lexer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lexer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2FCargo.toml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -19,4 +19,4 @@ unicode-xid = \"0.2.0\"\n unic-emoji-char = \"0.9.0\"\n \n [dev-dependencies]\n-expect-test = \"1.0\"\n+expect-test = \"1.4.0\""}, {"sha": "215df567e0e02f8e0f2b5bcc22b57c013d61c184", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 17, "deletions": 76, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -25,8 +25,6 @@ use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-use std::slice;\n-\n macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n@@ -300,20 +298,14 @@ impl LintPass for EarlyLintPassObjects<'_> {\n     }\n }\n \n-macro_rules! expand_early_lint_pass_impl_methods {\n-    ([$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n-            for obj in self.lints.iter_mut() {\n-                obj.$name(context, $($param),*);\n-            }\n-        })*\n-    )\n-}\n-\n macro_rules! early_lint_pass_impl {\n-    ([], [$($methods:tt)*]) => (\n+    ([], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n         impl EarlyLintPass for EarlyLintPassObjects<'_> {\n-            expand_early_lint_pass_impl_methods!([$($methods)*]);\n+            $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n+                for obj in self.lints.iter_mut() {\n+                    obj.$name(context, $($param),*);\n+                }\n+            })*\n         }\n     )\n }\n@@ -371,87 +363,36 @@ impl<'a> EarlyCheckNode<'a> for (ast::NodeId, &'a [ast::Attribute], &'a [P<ast::\n     }\n }\n \n-fn early_lint_node<'a>(\n-    sess: &Session,\n-    warn_about_weird_lints: bool,\n-    lint_store: &LintStore,\n-    registered_tools: &RegisteredTools,\n-    buffered: LintBuffer,\n-    pass: impl EarlyLintPass,\n-    check_node: impl EarlyCheckNode<'a>,\n-) -> LintBuffer {\n-    let mut cx = EarlyContextAndPass {\n-        context: EarlyContext::new(\n-            sess,\n-            warn_about_weird_lints,\n-            lint_store,\n-            registered_tools,\n-            buffered,\n-        ),\n-        pass,\n-    };\n-\n-    cx.with_lint_attrs(check_node.id(), check_node.attrs(), |cx| check_node.check(cx));\n-    cx.context.buffered\n-}\n-\n pub fn check_ast_node<'a>(\n     sess: &Session,\n     pre_expansion: bool,\n     lint_store: &LintStore,\n     registered_tools: &RegisteredTools,\n     lint_buffer: Option<LintBuffer>,\n-    builtin_lints: impl EarlyLintPass,\n+    builtin_lints: impl EarlyLintPass + 'static,\n     check_node: impl EarlyCheckNode<'a>,\n ) {\n     let passes =\n         if pre_expansion { &lint_store.pre_expansion_passes } else { &lint_store.early_passes };\n     let mut passes: Vec<_> = passes.iter().map(|p| (p)()).collect();\n-    let mut buffered = lint_buffer.unwrap_or_default();\n-\n-    if sess.opts.unstable_opts.no_interleave_lints {\n-        for (i, pass) in passes.iter_mut().enumerate() {\n-            buffered =\n-                sess.prof.verbose_generic_activity_with_arg(\"run_lint\", pass.name()).run(|| {\n-                    early_lint_node(\n-                        sess,\n-                        !pre_expansion && i == 0,\n-                        lint_store,\n-                        registered_tools,\n-                        buffered,\n-                        EarlyLintPassObjects { lints: slice::from_mut(pass) },\n-                        check_node,\n-                    )\n-                });\n-        }\n-    } else {\n-        buffered = early_lint_node(\n+    passes.push(Box::new(builtin_lints));\n+\n+    let mut cx = EarlyContextAndPass {\n+        context: EarlyContext::new(\n             sess,\n             !pre_expansion,\n             lint_store,\n             registered_tools,\n-            buffered,\n-            builtin_lints,\n-            check_node,\n-        );\n-\n-        if !passes.is_empty() {\n-            buffered = early_lint_node(\n-                sess,\n-                false,\n-                lint_store,\n-                registered_tools,\n-                buffered,\n-                EarlyLintPassObjects { lints: &mut passes[..] },\n-                check_node,\n-            );\n-        }\n-    }\n+            lint_buffer.unwrap_or_default(),\n+        ),\n+        pass: EarlyLintPassObjects { lints: &mut passes[..] },\n+    };\n+    cx.with_lint_attrs(check_node.id(), check_node.attrs(), |cx| check_node.check(cx));\n \n     // All of the buffered lints should have been emitted at this point.\n     // If not, that means that we somehow buffered a lint for a node id\n     // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n-    for (id, lints) in buffered.map {\n+    for (id, lints) in cx.context.buffered.map {\n         for early_lint in lints {\n             sess.delay_span_bug(\n                 early_lint.span,"}, {"sha": "e1aedc26d1b0aee2425391e7d789c6a104083e45", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 23, "deletions": 77, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -28,7 +28,6 @@ use rustc_span::Span;\n \n use std::any::Any;\n use std::cell::Cell;\n-use std::slice;\n \n /// Extract the `LintStore` from the query context.\n /// This function exists because we've erased `LintStore` as `dyn Any` in the context.\n@@ -313,45 +312,42 @@ impl LintPass for LateLintPassObjects<'_, '_> {\n     }\n }\n \n-macro_rules! expand_late_lint_pass_impl_methods {\n-    ([$hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(fn $name(&mut self, context: &LateContext<$hir>, $($param: $arg),*) {\n-            for obj in self.lints.iter_mut() {\n-                obj.$name(context, $($param),*);\n-            }\n-        })*\n-    )\n-}\n-\n macro_rules! late_lint_pass_impl {\n-    ([], [$hir:tt], $methods:tt) => {\n+    ([], [$hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => {\n         impl<$hir> LateLintPass<$hir> for LateLintPassObjects<'_, $hir> {\n-            expand_late_lint_pass_impl_methods!([$hir], $methods);\n+            $(fn $name(&mut self, context: &LateContext<$hir>, $($param: $arg),*) {\n+                for obj in self.lints.iter_mut() {\n+                    obj.$name(context, $($param),*);\n+                }\n+            })*\n         }\n     };\n }\n \n crate::late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n-fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n+pub(super) fn late_lint_mod<'tcx, T: LateLintPass<'tcx> + 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     module_def_id: LocalDefId,\n-    pass: T,\n+    builtin_lints: T,\n ) {\n-    let effective_visibilities = &tcx.effective_visibilities(());\n-\n     let context = LateContext {\n         tcx,\n         enclosing_body: None,\n         cached_typeck_results: Cell::new(None),\n         param_env: ty::ParamEnv::empty(),\n-        effective_visibilities,\n+        effective_visibilities: &tcx.effective_visibilities(()),\n         lint_store: unerased_lint_store(tcx),\n         last_node_with_lint_attrs: tcx.hir().local_def_id_to_hir_id(module_def_id),\n         generics: None,\n         only_module: true,\n     };\n \n+    let mut passes: Vec<_> =\n+        unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)(tcx)).collect();\n+    passes.push(Box::new(builtin_lints));\n+    let pass = LateLintPassObjects { lints: &mut passes[..] };\n+\n     let mut cx = LateContextAndPass { context, pass };\n \n     let (module, _span, hir_id) = tcx.hir().get_module(module_def_id);\n@@ -365,46 +361,29 @@ fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n     }\n }\n \n-pub fn late_lint_mod<'tcx, T: LateLintPass<'tcx>>(\n-    tcx: TyCtxt<'tcx>,\n-    module_def_id: LocalDefId,\n-    builtin_lints: T,\n-) {\n-    if tcx.sess.opts.unstable_opts.no_interleave_lints {\n-        // These passes runs in late_lint_crate with -Z no_interleave_lints\n-        return;\n-    }\n-\n-    late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n-\n-    let mut passes: Vec<_> =\n-        unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)(tcx)).collect();\n-\n-    if !passes.is_empty() {\n-        late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n-    }\n-}\n-\n-fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n-    let effective_visibilities = &tcx.effective_visibilities(());\n-\n+fn late_lint_crate<'tcx, T: LateLintPass<'tcx> + 'tcx>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n     let context = LateContext {\n         tcx,\n         enclosing_body: None,\n         cached_typeck_results: Cell::new(None),\n         param_env: ty::ParamEnv::empty(),\n-        effective_visibilities,\n+        effective_visibilities: &tcx.effective_visibilities(()),\n         lint_store: unerased_lint_store(tcx),\n         last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n         generics: None,\n         only_module: false,\n     };\n \n+    let mut passes =\n+        unerased_lint_store(tcx).late_passes.iter().map(|p| (p)(tcx)).collect::<Vec<_>>();\n+    passes.push(Box::new(builtin_lints));\n+    let pass = LateLintPassObjects { lints: &mut passes[..] };\n+\n     let mut cx = LateContextAndPass { context, pass };\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(hir::CRATE_HIR_ID, |cx| {\n-        // since the root module isn't visited as an item (because it isn't an\n+        // Since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         lint_callback!(cx, check_crate,);\n         tcx.hir().walk_toplevel_module(cx);\n@@ -413,41 +392,8 @@ fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T)\n     })\n }\n \n-fn late_lint_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n-    let mut passes =\n-        unerased_lint_store(tcx).late_passes.iter().map(|p| (p)(tcx)).collect::<Vec<_>>();\n-\n-    if !tcx.sess.opts.unstable_opts.no_interleave_lints {\n-        if !passes.is_empty() {\n-            late_lint_pass_crate(tcx, LateLintPassObjects { lints: &mut passes[..] });\n-        }\n-\n-        late_lint_pass_crate(tcx, builtin_lints);\n-    } else {\n-        for pass in &mut passes {\n-            tcx.sess.prof.verbose_generic_activity_with_arg(\"run_late_lint\", pass.name()).run(\n-                || {\n-                    late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-                },\n-            );\n-        }\n-\n-        let mut passes: Vec<_> =\n-            unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)(tcx)).collect();\n-\n-        for pass in &mut passes {\n-            tcx.sess\n-                .prof\n-                .verbose_generic_activity_with_arg(\"run_late_module_lint\", pass.name())\n-                .run(|| {\n-                    late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-                });\n-        }\n-    }\n-}\n-\n /// Performs lint checking on a crate.\n-pub fn check_crate<'tcx, T: LateLintPass<'tcx>>(\n+pub fn check_crate<'tcx, T: LateLintPass<'tcx> + 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     builtin_lints: impl FnOnce() -> T + Send,\n ) {"}, {"sha": "10bae36e0fd3c3b4eb0d1c53daa1d7934236e15c", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 111, "deletions": 164, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -127,132 +127,116 @@ fn lint_mod(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     late::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n \n-macro_rules! pre_expansion_lint_passes {\n-    ($macro:path, $args:tt) => {\n-        $macro!($args, [KeywordIdents: KeywordIdents,]);\n-    };\n-}\n-\n-macro_rules! early_lint_passes {\n-    ($macro:path, $args:tt) => {\n-        $macro!(\n-            $args,\n-            [\n-                UnusedParens: UnusedParens,\n-                UnusedBraces: UnusedBraces,\n-                UnusedImportBraces: UnusedImportBraces,\n-                UnsafeCode: UnsafeCode,\n-                SpecialModuleName: SpecialModuleName,\n-                AnonymousParameters: AnonymousParameters,\n-                EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),\n-                NonCamelCaseTypes: NonCamelCaseTypes,\n-                DeprecatedAttr: DeprecatedAttr::new(),\n-                WhileTrue: WhileTrue,\n-                NonAsciiIdents: NonAsciiIdents,\n-                HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,\n-                IncompleteFeatures: IncompleteFeatures,\n-                RedundantSemicolons: RedundantSemicolons,\n-                UnusedDocComment: UnusedDocComment,\n-                UnexpectedCfgs: UnexpectedCfgs,\n-            ]\n-        );\n-    };\n-}\n-\n-macro_rules! declare_combined_early_pass {\n-    ([$name:ident], $passes:tt) => (\n-        early_lint_methods!(declare_combined_early_lint_pass, [pub $name, $passes]);\n-    )\n-}\n-\n-pre_expansion_lint_passes!(declare_combined_early_pass, [BuiltinCombinedPreExpansionLintPass]);\n-early_lint_passes!(declare_combined_early_pass, [BuiltinCombinedEarlyLintPass]);\n-\n-macro_rules! late_lint_passes {\n-    ($macro:path, $args:tt) => {\n-        $macro!(\n-            $args,\n-            [\n-                // Tracks state across modules\n-                UnnameableTestItems: UnnameableTestItems::new(),\n-                // Tracks attributes of parents\n-                MissingDoc: MissingDoc::new(),\n-                // Builds a global list of all impls of `Debug`.\n-                // FIXME: Turn the computation of types which implement Debug into a query\n-                // and change this to a module lint pass\n-                MissingDebugImplementations: MissingDebugImplementations::default(),\n-                // Keeps a global list of foreign declarations.\n-                ClashingExternDeclarations: ClashingExternDeclarations::new(),\n-            ]\n-        );\n-    };\n-}\n-\n-macro_rules! late_lint_mod_passes {\n-    ($macro:path, $args:tt) => {\n-        $macro!(\n-            $args,\n-            [\n-                ForLoopsOverFallibles: ForLoopsOverFallibles,\n-                DerefIntoDynSupertrait: DerefIntoDynSupertrait,\n-                HardwiredLints: HardwiredLints,\n-                ImproperCTypesDeclarations: ImproperCTypesDeclarations,\n-                ImproperCTypesDefinitions: ImproperCTypesDefinitions,\n-                VariantSizeDifferences: VariantSizeDifferences,\n-                BoxPointers: BoxPointers,\n-                PathStatements: PathStatements,\n-                LetUnderscore: LetUnderscore,\n-                // Depends on referenced function signatures in expressions\n-                UnusedResults: UnusedResults,\n-                NonUpperCaseGlobals: NonUpperCaseGlobals,\n-                NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n-                UnusedAllocation: UnusedAllocation,\n-                // Depends on types used in type definitions\n-                MissingCopyImplementations: MissingCopyImplementations,\n-                // Depends on referenced function signatures in expressions\n-                MutableTransmutes: MutableTransmutes,\n-                TypeAliasBounds: TypeAliasBounds,\n-                TrivialConstraints: TrivialConstraints,\n-                TypeLimits: TypeLimits::new(),\n-                NonSnakeCase: NonSnakeCase,\n-                InvalidNoMangleItems: InvalidNoMangleItems,\n-                // Depends on effective visibilities\n-                UnreachablePub: UnreachablePub,\n-                ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n-                InvalidValue: InvalidValue,\n-                DerefNullPtr: DerefNullPtr,\n-                // May Depend on constants elsewhere\n-                UnusedBrokenConst: UnusedBrokenConst,\n-                UnstableFeatures: UnstableFeatures,\n-                ArrayIntoIter: ArrayIntoIter::default(),\n-                DropTraitConstraints: DropTraitConstraints,\n-                TemporaryCStringAsPtr: TemporaryCStringAsPtr,\n-                NonPanicFmt: NonPanicFmt,\n-                NoopMethodCall: NoopMethodCall,\n-                EnumIntrinsicsNonEnums: EnumIntrinsicsNonEnums,\n-                InvalidAtomicOrdering: InvalidAtomicOrdering,\n-                NamedAsmLabels: NamedAsmLabels,\n-                OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n-            ]\n-        );\n-    };\n-}\n-\n-macro_rules! declare_combined_late_pass {\n-    ([$v:vis $name:ident], $passes:tt) => (\n-        late_lint_methods!(declare_combined_late_lint_pass, [$v $name, $passes], ['tcx]);\n-    )\n-}\n+early_lint_methods!(\n+    declare_combined_early_lint_pass,\n+    [\n+        pub BuiltinCombinedPreExpansionLintPass,\n+        [\n+            KeywordIdents: KeywordIdents,\n+        ]\n+    ]\n+);\n+\n+early_lint_methods!(\n+    declare_combined_early_lint_pass,\n+    [\n+        pub BuiltinCombinedEarlyLintPass,\n+        [\n+            UnusedParens: UnusedParens,\n+            UnusedBraces: UnusedBraces,\n+            UnusedImportBraces: UnusedImportBraces,\n+            UnsafeCode: UnsafeCode,\n+            SpecialModuleName: SpecialModuleName,\n+            AnonymousParameters: AnonymousParameters,\n+            EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),\n+            NonCamelCaseTypes: NonCamelCaseTypes,\n+            DeprecatedAttr: DeprecatedAttr::new(),\n+            WhileTrue: WhileTrue,\n+            NonAsciiIdents: NonAsciiIdents,\n+            HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,\n+            IncompleteFeatures: IncompleteFeatures,\n+            RedundantSemicolons: RedundantSemicolons,\n+            UnusedDocComment: UnusedDocComment,\n+            UnexpectedCfgs: UnexpectedCfgs,\n+        ]\n+    ]\n+);\n \n // FIXME: Make a separate lint type which do not require typeck tables\n-late_lint_passes!(declare_combined_late_pass, [pub BuiltinCombinedLateLintPass]);\n-\n-late_lint_mod_passes!(declare_combined_late_pass, [BuiltinCombinedModuleLateLintPass]);\n-\n-pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> LintStore {\n+late_lint_methods!(\n+    declare_combined_late_lint_pass,\n+    [\n+        pub BuiltinCombinedLateLintPass,\n+        [\n+            // Tracks state across modules\n+            UnnameableTestItems: UnnameableTestItems::new(),\n+            // Tracks attributes of parents\n+            MissingDoc: MissingDoc::new(),\n+            // Builds a global list of all impls of `Debug`.\n+            // FIXME: Turn the computation of types which implement Debug into a query\n+            // and change this to a module lint pass\n+            MissingDebugImplementations: MissingDebugImplementations::default(),\n+            // Keeps a global list of foreign declarations.\n+            ClashingExternDeclarations: ClashingExternDeclarations::new(),\n+        ]\n+    ],\n+    ['tcx]\n+);\n+\n+late_lint_methods!(\n+    declare_combined_late_lint_pass,\n+    [\n+        BuiltinCombinedModuleLateLintPass,\n+        [\n+            ForLoopsOverFallibles: ForLoopsOverFallibles,\n+            DerefIntoDynSupertrait: DerefIntoDynSupertrait,\n+            HardwiredLints: HardwiredLints,\n+            ImproperCTypesDeclarations: ImproperCTypesDeclarations,\n+            ImproperCTypesDefinitions: ImproperCTypesDefinitions,\n+            VariantSizeDifferences: VariantSizeDifferences,\n+            BoxPointers: BoxPointers,\n+            PathStatements: PathStatements,\n+            LetUnderscore: LetUnderscore,\n+            // Depends on referenced function signatures in expressions\n+            UnusedResults: UnusedResults,\n+            NonUpperCaseGlobals: NonUpperCaseGlobals,\n+            NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n+            UnusedAllocation: UnusedAllocation,\n+            // Depends on types used in type definitions\n+            MissingCopyImplementations: MissingCopyImplementations,\n+            // Depends on referenced function signatures in expressions\n+            MutableTransmutes: MutableTransmutes,\n+            TypeAliasBounds: TypeAliasBounds,\n+            TrivialConstraints: TrivialConstraints,\n+            TypeLimits: TypeLimits::new(),\n+            NonSnakeCase: NonSnakeCase,\n+            InvalidNoMangleItems: InvalidNoMangleItems,\n+            // Depends on effective visibilities\n+            UnreachablePub: UnreachablePub,\n+            ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n+            InvalidValue: InvalidValue,\n+            DerefNullPtr: DerefNullPtr,\n+            // May Depend on constants elsewhere\n+            UnusedBrokenConst: UnusedBrokenConst,\n+            UnstableFeatures: UnstableFeatures,\n+            ArrayIntoIter: ArrayIntoIter::default(),\n+            DropTraitConstraints: DropTraitConstraints,\n+            TemporaryCStringAsPtr: TemporaryCStringAsPtr,\n+            NonPanicFmt: NonPanicFmt,\n+            NoopMethodCall: NoopMethodCall,\n+            EnumIntrinsicsNonEnums: EnumIntrinsicsNonEnums,\n+            InvalidAtomicOrdering: InvalidAtomicOrdering,\n+            NamedAsmLabels: NamedAsmLabels,\n+            OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n+        ]\n+    ],\n+    ['tcx]\n+);\n+\n+pub fn new_lint_store(internal_lints: bool) -> LintStore {\n     let mut lint_store = LintStore::new();\n \n-    register_builtins(&mut lint_store, no_interleave_lints);\n+    register_builtins(&mut lint_store);\n     if internal_lints {\n         register_internals(&mut lint_store);\n     }\n@@ -263,54 +247,17 @@ pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> LintSt\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc_session::lint::builtin`).\n-fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n+fn register_builtins(store: &mut LintStore) {\n     macro_rules! add_lint_group {\n         ($name:expr, $($lint:ident),*) => (\n             store.register_group(false, $name, None, vec![$(LintId::of($lint)),*]);\n         )\n     }\n \n-    macro_rules! register_early_pass {\n-        ($method:ident, $ty:ident, $constructor:expr) => {\n-            store.register_lints(&$ty::get_lints());\n-            store.$method(|| Box::new($constructor));\n-        };\n-    }\n-\n-    macro_rules! register_late_pass {\n-        ($method:ident, $ty:ident, $constructor:expr) => {\n-            store.register_lints(&$ty::get_lints());\n-            store.$method(|_| Box::new($constructor));\n-        };\n-    }\n-\n-    macro_rules! register_early_passes {\n-        ($method:ident, [$($passes:ident: $constructor:expr,)*]) => (\n-            $(\n-                register_early_pass!($method, $passes, $constructor);\n-            )*\n-        )\n-    }\n-\n-    macro_rules! register_late_passes {\n-        ($method:ident, [$($passes:ident: $constructor:expr,)*]) => (\n-            $(\n-                register_late_pass!($method, $passes, $constructor);\n-            )*\n-        )\n-    }\n-\n-    if no_interleave_lints {\n-        pre_expansion_lint_passes!(register_early_passes, register_pre_expansion_pass);\n-        early_lint_passes!(register_early_passes, register_early_pass);\n-        late_lint_passes!(register_late_passes, register_late_pass);\n-        late_lint_mod_passes!(register_late_passes, register_late_mod_pass);\n-    } else {\n-        store.register_lints(&BuiltinCombinedPreExpansionLintPass::get_lints());\n-        store.register_lints(&BuiltinCombinedEarlyLintPass::get_lints());\n-        store.register_lints(&BuiltinCombinedModuleLateLintPass::get_lints());\n-        store.register_lints(&BuiltinCombinedLateLintPass::get_lints());\n-    }\n+    store.register_lints(&BuiltinCombinedPreExpansionLintPass::get_lints());\n+    store.register_lints(&BuiltinCombinedEarlyLintPass::get_lints());\n+    store.register_lints(&BuiltinCombinedModuleLateLintPass::get_lints());\n+    store.register_lints(&BuiltinCombinedLateLintPass::get_lints());\n \n     add_lint_group!(\n         \"nonstandard_style\","}, {"sha": "2f53986139e05cc55500a7b87e112913caf3d357", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,7 +1,6 @@\n use crate::context::{EarlyContext, LateContext};\n \n use rustc_ast as ast;\n-use rustc_data_structures::sync;\n use rustc_hir as hir;\n use rustc_session::lint::builtin::HardwiredLints;\n use rustc_session::lint::LintPass;\n@@ -66,16 +65,10 @@ macro_rules! late_lint_methods {\n // FIXME: eliminate the duplication with `Visitor`. But this also\n // contains a few lint-specific methods with no equivalent in `Visitor`.\n \n-macro_rules! expand_lint_pass_methods {\n-    ($context:ty, [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(#[inline(always)] fn $name(&mut self, _: $context, $(_: $arg),*) {})*\n-    )\n-}\n-\n macro_rules! declare_late_lint_pass {\n-    ([], [$hir:tt], [$($methods:tt)*]) => (\n+    ([], [$hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n         pub trait LateLintPass<$hir>: LintPass {\n-            expand_lint_pass_methods!(&LateContext<$hir>, [$($methods)*]);\n+            $(#[inline(always)] fn $name(&mut self, _: &LateContext<$hir>, $(_: $arg),*) {})*\n         }\n     )\n }\n@@ -175,16 +168,10 @@ macro_rules! early_lint_methods {\n     )\n }\n \n-macro_rules! expand_early_lint_pass_methods {\n-    ($context:ty, [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(#[inline(always)] fn $name(&mut self, _: $context, $(_: $arg),*) {})*\n-    )\n-}\n-\n macro_rules! declare_early_lint_pass {\n-    ([], [$($methods:tt)*]) => (\n+    ([], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n         pub trait EarlyLintPass: LintPass {\n-            expand_early_lint_pass_methods!(&EarlyContext<'_>, [$($methods)*]);\n+            $(#[inline(always)] fn $name(&mut self, _: &EarlyContext<'_>, $(_: $arg),*) {})*\n         }\n     )\n }\n@@ -243,5 +230,5 @@ macro_rules! declare_combined_early_lint_pass {\n }\n \n /// A lint pass boxed up as a trait object.\n-pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + 'static>;\n-pub type LateLintPassObject<'tcx> = Box<dyn LateLintPass<'tcx> + sync::Send + 'tcx>;\n+pub type EarlyLintPassObject = Box<dyn EarlyLintPass + 'static>;\n+pub type LateLintPassObject<'tcx> = Box<dyn LateLintPass<'tcx> + 'tcx>;"}, {"sha": "79f06ac146c77953267734d0d37022d3abfa9853", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -222,6 +222,7 @@ fn main() {\n         .file(\"llvm-wrapper/RustWrapper.cpp\")\n         .file(\"llvm-wrapper/ArchiveWrapper.cpp\")\n         .file(\"llvm-wrapper/CoverageMappingWrapper.cpp\")\n+        .file(\"llvm-wrapper/SymbolWrapper.cpp\")\n         .file(\"llvm-wrapper/Linker.cpp\")\n         .cpp(true)\n         .cpp_link_stdlib(None) // we handle this below"}, {"sha": "792d921c6a4f99568776f1175223fccd69f016ac", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1967,3 +1967,7 @@ extern \"C\" int32_t LLVMRustGetElementTypeArgIndex(LLVMValueRef CallSite) {\n #endif\n     return -1;\n }\n+\n+extern \"C\" bool LLVMRustIsBitcode(char *ptr, size_t len) {\n+  return identify_magic(StringRef(ptr, len)) == file_magic::bitcode;\n+}"}, {"sha": "974207e918cd6f9138190aaf13bc0d23c8fb3bf3", "filename": "compiler/rustc_llvm/llvm-wrapper/SymbolWrapper.cpp", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,96 @@\n+// Derived from code in LLVM, which is:\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+\n+// Derived from:\n+// * https://github.com/llvm/llvm-project/blob/8ef3e895ad8ab1724e2b87cabad1dacdc7a397a3/llvm/include/llvm/Object/ArchiveWriter.h\n+// * https://github.com/llvm/llvm-project/blob/8ef3e895ad8ab1724e2b87cabad1dacdc7a397a3/llvm/lib/Object/ArchiveWriter.cpp\n+\n+#include \"llvm/IR/LLVMContext.h\"\n+#include \"llvm/Object/ObjectFile.h\"\n+#include \"llvm/ADT/Optional.h\"\n+\n+using namespace llvm;\n+using namespace llvm::sys;\n+using namespace llvm::object;\n+\n+static bool isArchiveSymbol(const object::BasicSymbolRef &S) {\n+  Expected<uint32_t> SymFlagsOrErr = S.getFlags();\n+  if (!SymFlagsOrErr)\n+    // FIXME: Actually report errors helpfully.\n+    report_fatal_error(SymFlagsOrErr.takeError());\n+  if (*SymFlagsOrErr & object::SymbolRef::SF_FormatSpecific)\n+    return false;\n+  if (!(*SymFlagsOrErr & object::SymbolRef::SF_Global))\n+    return false;\n+  if (*SymFlagsOrErr & object::SymbolRef::SF_Undefined)\n+    return false;\n+  return true;\n+}\n+\n+typedef void *(*LLVMRustGetSymbolsCallback)(void *, const char *);\n+typedef void *(*LLVMRustGetSymbolsErrorCallback)(const char *);\n+\n+// Note: This is implemented in C++ instead of using the C api from Rust as IRObjectFile doesn't\n+// implement getSymbolName, only printSymbolName, which is inaccessible from the C api.\n+extern \"C\" void *LLVMRustGetSymbols(\n+  char *BufPtr, size_t BufLen, void *State, LLVMRustGetSymbolsCallback Callback,\n+  LLVMRustGetSymbolsErrorCallback ErrorCallback) {\n+  std::unique_ptr<MemoryBuffer> Buf =\n+    MemoryBuffer::getMemBuffer(StringRef(BufPtr, BufLen), StringRef(\"LLVMRustGetSymbolsObject\"),\n+                               false);\n+  SmallString<0> SymNameBuf;\n+  raw_svector_ostream SymName(SymNameBuf);\n+\n+  // In the scenario when LLVMContext is populated SymbolicFile will contain a\n+  // reference to it, thus SymbolicFile should be destroyed first.\n+  LLVMContext Context;\n+  std::unique_ptr<object::SymbolicFile> Obj;\n+\n+  const file_magic Type = identify_magic(Buf->getBuffer());\n+  if (!object::SymbolicFile::isSymbolicFile(Type, &Context)) {\n+    return 0;\n+  }\n+\n+  if (Type == file_magic::bitcode) {\n+    auto ObjOrErr = object::SymbolicFile::createSymbolicFile(\n+      Buf->getMemBufferRef(), file_magic::bitcode, &Context);\n+    if (!ObjOrErr) {\n+      Error E = ObjOrErr.takeError();\n+      SmallString<0> ErrorBuf;\n+      raw_svector_ostream Error(ErrorBuf);\n+      Error << E << '\\0';\n+      return ErrorCallback(Error.str().data());\n+    }\n+    Obj = std::move(*ObjOrErr);\n+  } else {\n+    auto ObjOrErr = object::SymbolicFile::createSymbolicFile(Buf->getMemBufferRef());\n+    if (!ObjOrErr) {\n+      Error E = ObjOrErr.takeError();\n+      SmallString<0> ErrorBuf;\n+      raw_svector_ostream Error(ErrorBuf);\n+      Error << E << '\\0';\n+      return ErrorCallback(Error.str().data());\n+    }\n+    Obj = std::move(*ObjOrErr);\n+  }\n+\n+\n+  for (const object::BasicSymbolRef &S : Obj->symbols()) {\n+    if (!isArchiveSymbol(S))\n+      continue;\n+    if (Error E = S.printName(SymName)) {\n+      SmallString<0> ErrorBuf;\n+      raw_svector_ostream Error(ErrorBuf);\n+      Error << E << '\\0';\n+      return ErrorCallback(Error.str().data());\n+    }\n+    SymName << '\\0';\n+    if (void *E = Callback(State, SymNameBuf.str().data())) {\n+      return E;\n+    }\n+    SymNameBuf.clear();\n+  }\n+  return 0;\n+}"}, {"sha": "684835d8c5c86b88e60713d8639ab1962a4eb0da", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -29,8 +29,8 @@ impl<'a> DiagnosticDerive<'a> {\n         let DiagnosticDerive { mut structure, mut builder } = self;\n \n         let implementation = builder.each_variant(&mut structure, |mut builder, variant| {\n-            let preamble = builder.preamble(&variant);\n-            let body = builder.body(&variant);\n+            let preamble = builder.preamble(variant);\n+            let body = builder.body(variant);\n \n             let diag = &builder.parent.diag;\n             let DiagnosticDeriveKind::Diagnostic { handler } = &builder.parent.kind else {\n@@ -39,7 +39,7 @@ impl<'a> DiagnosticDerive<'a> {\n             let init = match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n-                        .help(&format!(\n+                        .help(format!(\n                             \"specify the slug as the first argument to the `#[diag(...)]` \\\n                             attribute, such as `#[diag(hir_analysis_example_error)]`\",\n                         ))\n@@ -48,10 +48,10 @@ impl<'a> DiagnosticDerive<'a> {\n                 }\n                 Some(slug) if let Some( Mismatch { slug_name, crate_name, slug_prefix }) = Mismatch::check(slug) => {\n                     span_err(slug.span().unwrap(), \"diagnostic slug and crate name do not match\")\n-                        .note(&format!(\n+                        .note(format!(\n                             \"slug is `{slug_name}` but the crate name is `{crate_name}`\"\n                         ))\n-                        .help(&format!(\n+                        .help(format!(\n                             \"expected a slug starting with `{slug_prefix}_...`\"\n                         ))\n                         .emit();\n@@ -113,8 +113,8 @@ impl<'a> LintDiagnosticDerive<'a> {\n         let LintDiagnosticDerive { mut structure, mut builder } = self;\n \n         let implementation = builder.each_variant(&mut structure, |mut builder, variant| {\n-            let preamble = builder.preamble(&variant);\n-            let body = builder.body(&variant);\n+            let preamble = builder.preamble(variant);\n+            let body = builder.body(variant);\n \n             let diag = &builder.parent.diag;\n             let formatting_init = &builder.formatting_init;\n@@ -128,28 +128,28 @@ impl<'a> LintDiagnosticDerive<'a> {\n \n         let msg = builder.each_variant(&mut structure, |mut builder, variant| {\n             // Collect the slug by generating the preamble.\n-            let _ = builder.preamble(&variant);\n+            let _ = builder.preamble(variant);\n \n             match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n-                        .help(&format!(\n+                        .help(format!(\n                             \"specify the slug as the first argument to the attribute, such as \\\n                             `#[diag(compiletest_example)]`\",\n                         ))\n                         .emit();\n-                    return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    DiagnosticDeriveError::ErrorHandled.to_compile_error()\n                 }\n                 Some(slug) if let Some( Mismatch { slug_name, crate_name, slug_prefix }) = Mismatch::check(slug) => {\n                     span_err(slug.span().unwrap(), \"diagnostic slug and crate name do not match\")\n-                        .note(&format!(\n+                        .note(format!(\n                             \"slug is `{slug_name}` but the crate name is `{crate_name}`\"\n                         ))\n-                        .help(&format!(\n+                        .help(format!(\n                             \"expected a slug starting with `{slug_prefix}_...`\"\n                         ))\n                         .emit();\n-                    return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    DiagnosticDeriveError::ErrorHandled.to_compile_error()\n                 }\n                 Some(slug) => {\n                     quote! {"}, {"sha": "9f2ac5112f1cd9d3aa4b78a9cf1deeda1c0ae799", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -100,7 +100,7 @@ impl DiagnosticDeriveBuilder {\n                 _ => variant.ast().ident.span().unwrap(),\n             };\n             let builder = DiagnosticDeriveVariantBuilder {\n-                parent: &self,\n+                parent: self,\n                 span,\n                 field_map: build_field_mapping(variant),\n                 formatting_init: TokenStream::new(),\n@@ -211,7 +211,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     nested_iter.next();\n                 }\n                 Some(NestedMeta::Meta(Meta::NameValue { .. })) => {}\n-                Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| diag\n+                Some(nested_attr) => throw_invalid_nested_attr!(attr, nested_attr, |diag| diag\n                     .help(\"a diagnostic slug is required as the first argument\")),\n                 None => throw_invalid_attr!(attr, &meta, |diag| diag\n                     .help(\"a diagnostic slug is required as the first argument\")),\n@@ -227,13 +227,13 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                         ..\n                     })) => (value, path),\n                     NestedMeta::Meta(Meta::Path(_)) => {\n-                        invalid_nested_attr(attr, &nested_attr)\n+                        invalid_nested_attr(attr, nested_attr)\n                             .help(\"diagnostic slug must be the first argument\")\n                             .emit();\n                         continue;\n                     }\n                     _ => {\n-                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        invalid_nested_attr(attr, nested_attr).emit();\n                         continue;\n                     }\n                 };\n@@ -251,7 +251,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                             #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n                         });\n                     }\n-                    _ => invalid_nested_attr(attr, &nested_attr)\n+                    _ => invalid_nested_attr(attr, nested_attr)\n                         .help(\"only `code` is a valid nested attributes following the slug\")\n                         .emit(),\n                 }\n@@ -427,9 +427,9 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n             }\n             SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n-                if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                if type_matches_path(info.ty, &[\"rustc_span\", \"Span\"]) {\n                     Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n-                } else if type_is_unit(&info.ty) {\n+                } else if type_is_unit(info.ty) {\n                     Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n                     report_type_error(attr, \"`Span` or `()`\")?"}, {"sha": "446aebe4f83f59a3d95a4903227bd4fa7b9cbb92", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -409,7 +409,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 let mut code = None;\n                 for nested_attr in list.nested.iter() {\n                     let NestedMeta::Meta(ref meta) = nested_attr else {\n-                        throw_invalid_nested_attr!(attr, &nested_attr);\n+                        throw_invalid_nested_attr!(attr, nested_attr);\n                     };\n \n                     let span = meta.span().unwrap();\n@@ -427,7 +427,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                             );\n                             code.set_once((code_field, formatting_init), span);\n                         }\n-                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                        _ => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n                         }),\n                     }"}, {"sha": "da90233523ca3c83e503f45bb351207bcdcd5f74", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -80,7 +80,7 @@ fn report_error_if_not_applied_to_ty(\n     path: &[&str],\n     ty_name: &str,\n ) -> Result<(), DiagnosticDeriveError> {\n-    if !type_matches_path(&info.ty, path) {\n+    if !type_matches_path(info.ty, path) {\n         report_type_error(attr, ty_name)?;\n     }\n \n@@ -105,8 +105,8 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n ) -> Result<(), DiagnosticDeriveError> {\n-    if !type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"])\n-        && !type_matches_path(&info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n+    if !type_matches_path(info.ty, &[\"rustc_span\", \"Span\"])\n+        && !type_matches_path(info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n     {\n         report_type_error(attr, \"`Span` or `MultiSpan`\")?;\n     }\n@@ -686,7 +686,7 @@ impl SubdiagnosticKind {\n             let meta = match nested_attr {\n                 NestedMeta::Meta(ref meta) => meta,\n                 NestedMeta::Lit(_) => {\n-                    invalid_nested_attr(attr, &nested_attr).emit();\n+                    invalid_nested_attr(attr, nested_attr).emit();\n                     continue;\n                 }\n             };\n@@ -698,7 +698,7 @@ impl SubdiagnosticKind {\n             let string_value = match meta {\n                 Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => Some(value),\n \n-                Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                Meta::Path(_) => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n                     diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n                 }),\n                 _ => None,\n@@ -720,7 +720,7 @@ impl SubdiagnosticKind {\n                     | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n                 ) => {\n                     let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        invalid_nested_attr(attr, nested_attr).emit();\n                         continue;\n                     };\n \n@@ -736,7 +736,7 @@ impl SubdiagnosticKind {\n                     | SubdiagnosticKind::MultipartSuggestion { .. },\n                 ) => {\n                     let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        invalid_nested_attr(attr, nested_attr).emit();\n                         continue;\n                     };\n \n@@ -752,19 +752,19 @@ impl SubdiagnosticKind {\n \n                 // Invalid nested attribute\n                 (_, SubdiagnosticKind::Suggestion { .. }) => {\n-                    invalid_nested_attr(attr, &nested_attr)\n+                    invalid_nested_attr(attr, nested_attr)\n                         .help(\n                             \"only `style`, `code` and `applicability` are valid nested attributes\",\n                         )\n                         .emit();\n                 }\n                 (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n-                    invalid_nested_attr(attr, &nested_attr)\n+                    invalid_nested_attr(attr, nested_attr)\n                         .help(\"only `style` and `applicability` are valid nested attributes\")\n                         .emit()\n                 }\n                 _ => {\n-                    invalid_nested_attr(attr, &nested_attr).emit();\n+                    invalid_nested_attr(attr, nested_attr).emit();\n                 }\n             }\n         }"}, {"sha": "1bd8f95350879d29e86136f6c5d7c7bd1892bbb7", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1022,7 +1022,7 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => {\n                 // Ensure that the returned span has the item's SyntaxContext.\n-                fn_decl_span.find_ancestor_in_same_ctxt(*span).unwrap_or(*span)\n+                fn_decl_span.find_ancestor_inside(*span).unwrap_or(*span)\n             }\n             _ => self.span_with_body(hir_id),\n         };"}, {"sha": "a513444e1e08bd91b8f98fe9c428e1406554ffc2", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 37, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -100,13 +100,9 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n /// pass will be named after the type, and it will consist of a main\n /// loop that goes over each available MIR and applies `run_pass`.\n pub trait MirPass<'tcx> {\n-    fn name(&self) -> Cow<'_, str> {\n+    fn name(&self) -> &str {\n         let name = std::any::type_name::<Self>();\n-        if let Some(tail) = name.rfind(':') {\n-            Cow::from(&name[tail + 1..])\n-        } else {\n-            Cow::from(name)\n-        }\n+        if let Some((_, tail)) = name.rsplit_once(':') { tail } else { name }\n     }\n \n     /// Returns `true` if this pass is enabled with the current combination of compiler flags.\n@@ -182,35 +178,6 @@ impl RuntimePhase {\n     }\n }\n \n-impl Display for MirPhase {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        match self {\n-            MirPhase::Built => write!(f, \"built\"),\n-            MirPhase::Analysis(p) => write!(f, \"analysis-{}\", p),\n-            MirPhase::Runtime(p) => write!(f, \"runtime-{}\", p),\n-        }\n-    }\n-}\n-\n-impl Display for AnalysisPhase {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        match self {\n-            AnalysisPhase::Initial => write!(f, \"initial\"),\n-            AnalysisPhase::PostCleanup => write!(f, \"post_cleanup\"),\n-        }\n-    }\n-}\n-\n-impl Display for RuntimePhase {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        match self {\n-            RuntimePhase::Initial => write!(f, \"initial\"),\n-            RuntimePhase::PostCleanup => write!(f, \"post_cleanup\"),\n-            RuntimePhase::Optimized => write!(f, \"optimized\"),\n-        }\n-    }\n-}\n-\n /// Where a specific `mir::Body` comes from.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[derive(HashStable, TyEncodable, TyDecodable, TypeFoldable, TypeVisitable)]\n@@ -368,7 +335,7 @@ impl<'tcx> Body<'tcx> {\n \n         let mut body = Body {\n             phase: MirPhase::Built,\n-            pass_count: 1,\n+            pass_count: 0,\n             source,\n             basic_blocks: BasicBlocks::new(basic_blocks),\n             source_scopes,\n@@ -403,7 +370,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n         let mut body = Body {\n             phase: MirPhase::Built,\n-            pass_count: 1,\n+            pass_count: 0,\n             source: MirSource::item(CRATE_DEF_ID.to_def_id()),\n             basic_blocks: BasicBlocks::new(basic_blocks),\n             source_scopes: IndexVec::new(),"}, {"sha": "2a4ff4b8810dbc513171e07fb969e8f299e033f3", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -16,7 +16,6 @@ use rustc_middle::mir::interpret::{\n     Pointer, Provenance,\n };\n use rustc_middle::mir::visit::Visitor;\n-use rustc_middle::mir::MirSource;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_target::abi::Size;\n@@ -74,7 +73,7 @@ pub enum PassWhere {\n #[inline]\n pub fn dump_mir<'tcx, F>(\n     tcx: TyCtxt<'tcx>,\n-    pass_num: Option<&dyn Display>,\n+    pass_num: bool,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n     body: &Body<'tcx>,\n@@ -111,7 +110,7 @@ pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, def_id: DefId) ->\n \n fn dump_matched_mir_node<'tcx, F>(\n     tcx: TyCtxt<'tcx>,\n-    pass_num: Option<&dyn Display>,\n+    pass_num: bool,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n     body: &Body<'tcx>,\n@@ -120,8 +119,7 @@ fn dump_matched_mir_node<'tcx, F>(\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n     let _: io::Result<()> = try {\n-        let mut file =\n-            create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, body.source)?;\n+        let mut file = create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, body)?;\n         // see notes on #41697 above\n         let def_path =\n             ty::print::with_forced_impl_filename_line!(tcx.def_path_str(body.source.def_id()));\n@@ -143,16 +141,14 @@ fn dump_matched_mir_node<'tcx, F>(\n \n     if tcx.sess.opts.unstable_opts.dump_mir_graphviz {\n         let _: io::Result<()> = try {\n-            let mut file =\n-                create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, body.source)?;\n+            let mut file = create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, body)?;\n             write_mir_fn_graphviz(tcx, body, false, &mut file)?;\n         };\n     }\n \n     if let Some(spanview) = tcx.sess.opts.unstable_opts.dump_mir_spanview {\n         let _: io::Result<()> = try {\n-            let file_basename =\n-                dump_file_basename(tcx, pass_num, pass_name, disambiguator, body.source);\n+            let file_basename = dump_file_basename(tcx, pass_num, pass_name, disambiguator, body);\n             let mut file = create_dump_file_with_basename(tcx, &file_basename, \"html\")?;\n             if body.source.def_id().is_local() {\n                 write_mir_fn_spanview(tcx, body, spanview, &file_basename, &mut file)?;\n@@ -165,11 +161,12 @@ fn dump_matched_mir_node<'tcx, F>(\n /// where we should dump a MIR representation output files.\n fn dump_file_basename<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    pass_num: Option<&dyn Display>,\n+    pass_num: bool,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n-    source: MirSource<'tcx>,\n+    body: &Body<'tcx>,\n ) -> String {\n+    let source = body.source;\n     let promotion_id = match source.promoted {\n         Some(id) => format!(\"-{:?}\", id),\n         None => String::new(),\n@@ -178,9 +175,10 @@ fn dump_file_basename<'tcx>(\n     let pass_num = if tcx.sess.opts.unstable_opts.dump_mir_exclude_pass_number {\n         String::new()\n     } else {\n-        match pass_num {\n-            None => \".-------\".to_string(),\n-            Some(pass_num) => format!(\".{}\", pass_num),\n+        if pass_num {\n+            format!(\".{:03}-{:03}\", body.phase.phase_index(), body.pass_count)\n+        } else {\n+            \".-------\".to_string()\n         }\n     };\n \n@@ -250,14 +248,14 @@ fn create_dump_file_with_basename(\n pub fn create_dump_file<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     extension: &str,\n-    pass_num: Option<&dyn Display>,\n+    pass_num: bool,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n-    source: MirSource<'tcx>,\n+    body: &Body<'tcx>,\n ) -> io::Result<io::BufWriter<fs::File>> {\n     create_dump_file_with_basename(\n         tcx,\n-        &dump_file_basename(tcx, pass_num, pass_name, disambiguator, source),\n+        &dump_file_basename(tcx, pass_num, pass_name, disambiguator, body),\n         extension,\n     )\n }"}, {"sha": "7d2a6bda56926cbe8030d3430e35478c30540cb0", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -89,6 +89,19 @@ pub enum MirPhase {\n     Runtime(RuntimePhase),\n }\n \n+impl MirPhase {\n+    pub fn name(&self) -> &'static str {\n+        match *self {\n+            MirPhase::Built => \"built\",\n+            MirPhase::Analysis(AnalysisPhase::Initial) => \"analysis\",\n+            MirPhase::Analysis(AnalysisPhase::PostCleanup) => \"analysis-post-cleanup\",\n+            MirPhase::Runtime(RuntimePhase::Initial) => \"runtime\",\n+            MirPhase::Runtime(RuntimePhase::PostCleanup) => \"runtime-post-cleanup\",\n+            MirPhase::Runtime(RuntimePhase::Optimized) => \"runtime-optimized\",\n+        }\n+    }\n+}\n+\n /// See [`MirPhase::Analysis`].\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]"}, {"sha": "d6dea0e9f30fa06649c9de4cfb341cae9ffeaa96", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1109,6 +1109,7 @@ rustc_queries! {\n         desc { |tcx| \"looking up span for `{}`\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     /// Gets the span for the identifier of the definition."}, {"sha": "c5683a9db94737402b8c5c9242b1eba9236dd842", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1507,7 +1507,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             self.def_path(def_id).to_string_no_crate_verbose()\n         )\n     }\n+}\n \n+impl<'tcx> TyCtxtAt<'tcx> {\n     /// Create a new definition within the incr. comp. engine.\n     pub fn create_def(\n         self,\n@@ -1536,9 +1538,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         // - this write will have happened before these queries are called.\n         let def_id = self.definitions.write().create_def(parent, data);\n \n-        TyCtxtFeed { tcx: self, def_id }\n+        let feed = TyCtxtFeed { tcx: self.tcx, def_id };\n+        feed.def_span(self.span);\n+        feed\n     }\n+}\n \n+impl<'tcx> TyCtxt<'tcx> {\n     pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'tcx {\n         // Create a dependency to the red node to be sure we re-execute this when the amount of\n         // definitions change."}, {"sha": "a7fd1754960ab8d901ead70b35f3e0ba26fcf106", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -344,12 +344,10 @@ macro_rules! define_feedable {\n \n                 match cached {\n                     Ok(old) => {\n-                        assert_eq!(\n-                            value, old,\n-                            \"Trying to feed an already recorded value for query {} key={key:?}\",\n+                        bug!(\n+                            \"Trying to feed an already recorded value for query {} key={key:?}:\\nold value: {old:?}\\nnew value: {value:?}\",\n                             stringify!($name),\n                         );\n-                        return old;\n                     }\n                     Err(()) => (),\n                 }"}, {"sha": "70b98e59a8beab34f6e801b412526d6d5ac15aed", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -32,13 +32,23 @@ impl<'tcx> Value<TyCtxt<'tcx>> for ty::SymbolName<'_> {\n }\n \n impl<'tcx> Value<TyCtxt<'tcx>> for ty::Binder<'_, ty::FnSig<'_>> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, stack: &[QueryInfo]) -> Self {\n         let err = tcx.ty_error();\n-        // FIXME(compiler-errors): It would be nice if we could get the\n-        // query key, so we could at least generate a fn signature that\n-        // has the right arity.\n+\n+        let arity = if let Some(frame) = stack.get(0)\n+            && frame.query.name == \"fn_sig\"\n+            && let Some(def_id) = frame.query.def_id\n+            && let Some(node) = tcx.hir().get_if_local(def_id)\n+            && let Some(sig) = node.fn_sig()\n+        {\n+            sig.decl.inputs.len() + sig.decl.implicit_self.has_implicit_self() as usize\n+        } else {\n+            tcx.sess.abort_if_errors();\n+            unreachable!()\n+        };\n+\n         let fn_sig = ty::Binder::dummy(tcx.mk_fn_sig(\n-            [].into_iter(),\n+            std::iter::repeat(err).take(arity),\n             err,\n             false,\n             rustc_hir::Unsafety::Normal,"}, {"sha": "eb021f477573c165847eb5159def1aff24535c7c", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -57,7 +57,7 @@ pub(super) fn build_custom_mir<'tcx>(\n         is_polymorphic: false,\n         tainted_by_errors: None,\n         injection_phase: None,\n-        pass_count: 1,\n+        pass_count: 0,\n     };\n \n     body.local_decls.push(LocalDecl::new(return_ty, return_ty_span));"}, {"sha": "6ddbe69e17e75fae367d832918ccaefd9bfecfd1", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -294,14 +294,7 @@ where\n         None if tcx.sess.opts.unstable_opts.dump_mir_dataflow\n             && dump_enabled(tcx, A::NAME, def_id) =>\n         {\n-            create_dump_file(\n-                tcx,\n-                \".dot\",\n-                None,\n-                A::NAME,\n-                &pass_name.unwrap_or(\"-----\"),\n-                body.source,\n-            )?\n+            create_dump_file(tcx, \".dot\", false, A::NAME, &pass_name.unwrap_or(\"-----\"), body)?\n         }\n \n         _ => return Ok(()),"}, {"sha": "d6a298fade42e889e5b4521693a3f54bb47f2805", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -638,7 +638,7 @@ pub(super) fn dump_coverage_spanview<'tcx>(\n     let def_id = mir_source.def_id();\n \n     let span_viewables = span_viewables(tcx, mir_body, basic_coverage_blocks, &coverage_spans);\n-    let mut file = create_dump_file(tcx, \"html\", None, pass_name, &0, mir_source)\n+    let mut file = create_dump_file(tcx, \"html\", false, pass_name, &0, mir_body)\n         .expect(\"Unexpected error creating MIR spanview HTML file\");\n     let crate_name = tcx.crate_name(def_id.krate);\n     let item_name = tcx.def_path(def_id).to_filename_friendly_no_crate();\n@@ -739,7 +739,7 @@ pub(super) fn dump_coverage_graphviz<'tcx>(\n                 .join(\"\\n  \")\n         ));\n     }\n-    let mut file = create_dump_file(tcx, \"dot\", None, pass_name, &0, mir_source)\n+    let mut file = create_dump_file(tcx, \"dot\", false, pass_name, &0, mir_body)\n         .expect(\"Unexpected error creating BasicCoverageBlock graphviz DOT file\");\n     graphviz_writer\n         .write_graphviz(tcx, &mut file)"}, {"sha": "97485c4f57b12ea872de807daf68c6ca9fe7ec8a", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -787,7 +787,7 @@ fn dest_prop_mir_dump<'body, 'tcx>(\n     round: usize,\n ) {\n     let mut reachable = None;\n-    dump_mir(tcx, None, \"DestinationPropagation-dataflow\", &round, body, |pass_where, w| {\n+    dump_mir(tcx, false, \"DestinationPropagation-dataflow\", &round, body, |pass_where, w| {\n         let reachable = reachable.get_or_insert_with(|| traversal::reachable_as_bitset(body));\n \n         match pass_where {"}, {"sha": "778ae63c5a42e1c0d20c41debce93dfcaacefd39", "filename": "compiler/rustc_mir_transform/src/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdump_mir.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,6 +1,5 @@\n //! This pass just dumps MIR at a specified point.\n \n-use std::borrow::Cow;\n use std::fs::File;\n use std::io;\n \n@@ -13,8 +12,8 @@ use rustc_session::config::{OutputFilenames, OutputType};\n pub struct Marker(pub &'static str);\n \n impl<'tcx> MirPass<'tcx> for Marker {\n-    fn name(&self) -> Cow<'_, str> {\n-        Cow::Borrowed(self.0)\n+    fn name(&self) -> &str {\n+        self.0\n     }\n \n     fn run_pass(&self, _tcx: TyCtxt<'tcx>, _body: &mut Body<'tcx>) {}"}, {"sha": "8922298ecafcb3fa35dbb9cee7a818aebb2e9240", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1000,7 +1000,7 @@ fn create_generator_drop_shim<'tcx>(\n     // unrelated code from the resume part of the function\n     simplify::remove_dead_blocks(tcx, &mut body);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, &body, |_, _| Ok(()));\n+    dump_mir(tcx, false, \"generator_drop\", &0, &body, |_, _| Ok(()));\n \n     body\n }\n@@ -1171,7 +1171,7 @@ fn create_generator_resume_function<'tcx>(\n     // unrelated code from the drop part of the function\n     simplify::remove_dead_blocks(tcx, body);\n \n-    dump_mir(tcx, None, \"generator_resume\", &0, body, |_, _| Ok(()));\n+    dump_mir(tcx, false, \"generator_resume\", &0, body, |_, _| Ok(()));\n }\n \n fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n@@ -1394,14 +1394,14 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         // This is expanded to a drop ladder in `elaborate_generator_drops`.\n         let drop_clean = insert_clean_drop(body);\n \n-        dump_mir(tcx, None, \"generator_pre-elab\", &0, body, |_, _| Ok(()));\n+        dump_mir(tcx, false, \"generator_pre-elab\", &0, body, |_, _| Ok(()));\n \n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n         elaborate_generator_drops(tcx, body);\n \n-        dump_mir(tcx, None, \"generator_post-transform\", &0, body, |_, _| Ok(()));\n+        dump_mir(tcx, false, \"generator_post-transform\", &0, body, |_, _| Ok(()));\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx, &transform, gen_ty, body, drop_clean);"}, {"sha": "bf670c5c26a7753394e631bca6d73d77ccaf664d", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -363,10 +363,6 @@ impl<'tcx> Inliner<'tcx> {\n             return Err(\"C variadic\");\n         }\n \n-        if callee_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-            return Err(\"naked\");\n-        }\n-\n         if callee_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n             return Err(\"cold\");\n         }"}, {"sha": "e1b65823a5a9c86669ba43af79a11e1ccdb9464c", "filename": "compiler/rustc_mir_transform/src/pass_manager.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,5 +1,3 @@\n-use std::borrow::Cow;\n-\n use rustc_middle::mir::{self, Body, MirPhase, RuntimePhase};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n@@ -8,13 +6,9 @@ use crate::{validate, MirPass};\n \n /// Just like `MirPass`, except it cannot mutate `Body`.\n pub trait MirLint<'tcx> {\n-    fn name(&self) -> Cow<'_, str> {\n+    fn name(&self) -> &str {\n         let name = std::any::type_name::<Self>();\n-        if let Some(tail) = name.rfind(':') {\n-            Cow::from(&name[tail + 1..])\n-        } else {\n-            Cow::from(name)\n-        }\n+        if let Some((_, tail)) = name.rsplit_once(':') { tail } else { name }\n     }\n \n     fn is_enabled(&self, _sess: &Session) -> bool {\n@@ -32,7 +26,7 @@ impl<'tcx, T> MirPass<'tcx> for Lint<T>\n where\n     T: MirLint<'tcx>,\n {\n-    fn name(&self) -> Cow<'_, str> {\n+    fn name(&self) -> &str {\n         self.0.name()\n     }\n \n@@ -55,7 +49,7 @@ impl<'tcx, T> MirPass<'tcx> for WithMinOptLevel<T>\n where\n     T: MirPass<'tcx>,\n {\n-    fn name(&self) -> Cow<'_, str> {\n+    fn name(&self) -> &str {\n         self.1.name()\n     }\n \n@@ -146,10 +140,11 @@ fn run_passes_inner<'tcx>(\n         }\n \n         body.phase = new_phase;\n+        body.pass_count = 0;\n \n         dump_mir_for_phase_change(tcx, body);\n         if validate || new_phase == MirPhase::Runtime(RuntimePhase::Optimized) {\n-            validate_body(tcx, body, format!(\"after phase change to {}\", new_phase));\n+            validate_body(tcx, body, format!(\"after phase change to {}\", new_phase.name()));\n         }\n \n         body.pass_count = 1;\n@@ -166,11 +161,9 @@ pub fn dump_mir_for_pass<'tcx>(\n     pass_name: &str,\n     is_after: bool,\n ) {\n-    let phase_index = body.phase.phase_index();\n-\n     mir::dump_mir(\n         tcx,\n-        Some(&format_args!(\"{:03}-{:03}\", phase_index, body.pass_count)),\n+        true,\n         pass_name,\n         if is_after { &\"after\" } else { &\"before\" },\n         body,\n@@ -179,14 +172,6 @@ pub fn dump_mir_for_pass<'tcx>(\n }\n \n pub fn dump_mir_for_phase_change<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n-    let phase_index = body.phase.phase_index();\n-\n-    mir::dump_mir(\n-        tcx,\n-        Some(&format_args!(\"{:03}-000\", phase_index)),\n-        &format!(\"{}\", body.phase),\n-        &\"after\",\n-        body,\n-        |_, _| Ok(()),\n-    )\n+    assert_eq!(body.pass_count, 0);\n+    mir::dump_mir(tcx, true, body.phase.name(), &\"after\", body, |_, _| Ok(()))\n }"}, {"sha": "475e2ec9a1dea713881123d96bc84a941bb95272", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -35,7 +35,6 @@ use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Vis\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n use smallvec::SmallVec;\n-use std::borrow::Cow;\n use std::convert::TryInto;\n \n pub struct SimplifyCfg {\n@@ -57,8 +56,8 @@ pub fn simplify_cfg<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn name(&self) -> Cow<'_, str> {\n-        Cow::Borrowed(&self.label)\n+    fn name(&self) -> &str {\n+        &self.label\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "405ebce4d2227f7bdfac152ac51725783ac59886", "filename": "compiler/rustc_mir_transform/src/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -2,8 +2,6 @@ use crate::MirPass;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n-use std::borrow::Cow;\n-\n /// A pass that replaces a branch with a goto when its condition is known.\n pub struct SimplifyConstCondition {\n     label: String,\n@@ -16,8 +14,8 @@ impl SimplifyConstCondition {\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyConstCondition {\n-    fn name(&self) -> Cow<'_, str> {\n-        Cow::Borrowed(&self.label)\n+    fn name(&self) -> &str {\n+        &self.label\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "fe3cfde2e6383dfc024a56812bb09b726ae7ee6b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -2060,7 +2060,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let capture_clause = self.parse_capture_clause()?;\n-        let fn_decl = self.parse_fn_block_decl()?;\n+        let (fn_decl, fn_arg_span) = self.parse_fn_block_decl()?;\n         let decl_hi = self.prev_token.span;\n         let mut body = match fn_decl.output {\n             FnRetTy::Default(_) => {\n@@ -2101,6 +2101,7 @@ impl<'a> Parser<'a> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: lo.to(decl_hi),\n+                fn_arg_span,\n             })),\n         );\n \n@@ -2129,7 +2130,9 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the `|arg, arg|` header of a closure.\n-    fn parse_fn_block_decl(&mut self) -> PResult<'a, P<FnDecl>> {\n+    fn parse_fn_block_decl(&mut self) -> PResult<'a, (P<FnDecl>, Span)> {\n+        let arg_start = self.token.span.lo();\n+\n         let inputs = if self.eat(&token::OrOr) {\n             Vec::new()\n         } else {\n@@ -2145,10 +2148,11 @@ impl<'a> Parser<'a> {\n             self.expect_or()?;\n             args\n         };\n+        let arg_span = self.prev_token.span.with_lo(arg_start);\n         let output =\n             self.parse_ret_ty(AllowPlus::Yes, RecoverQPath::Yes, RecoverReturnSign::Yes)?;\n \n-        Ok(P(FnDecl { inputs, output }))\n+        Ok((P(FnDecl { inputs, output }), arg_span))\n     }\n \n     /// Parses a parameter in a closure header (e.g., `|arg, arg|`)."}, {"sha": "42197e6379749a264c325dbb332a41926754b515", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -72,14 +72,22 @@ impl<'a> Parser<'a> {\n \n         Ok(Some(if self.token.is_keyword(kw::Let) {\n             self.parse_local_mk(lo, attrs, capture_semi, force_collect)?\n-        } else if self.is_kw_followed_by_ident(kw::Mut) {\n-            self.recover_stmt_local(lo, attrs, InvalidVariableDeclarationSub::MissingLet)?\n-        } else if self.is_kw_followed_by_ident(kw::Auto) {\n+        } else if self.is_kw_followed_by_ident(kw::Mut) && self.may_recover() {\n+            self.recover_stmt_local_after_let(lo, attrs, InvalidVariableDeclarationSub::MissingLet)?\n+        } else if self.is_kw_followed_by_ident(kw::Auto) && self.may_recover() {\n             self.bump(); // `auto`\n-            self.recover_stmt_local(lo, attrs, InvalidVariableDeclarationSub::UseLetNotAuto)?\n-        } else if self.is_kw_followed_by_ident(sym::var) {\n+            self.recover_stmt_local_after_let(\n+                lo,\n+                attrs,\n+                InvalidVariableDeclarationSub::UseLetNotAuto,\n+            )?\n+        } else if self.is_kw_followed_by_ident(sym::var) && self.may_recover() {\n             self.bump(); // `var`\n-            self.recover_stmt_local(lo, attrs, InvalidVariableDeclarationSub::UseLetNotVar)?\n+            self.recover_stmt_local_after_let(\n+                lo,\n+                attrs,\n+                InvalidVariableDeclarationSub::UseLetNotVar,\n+            )?\n         } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n@@ -213,13 +221,21 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn recover_stmt_local(\n+    fn recover_stmt_local_after_let(\n         &mut self,\n         lo: Span,\n         attrs: AttrWrapper,\n         subdiagnostic: fn(Span) -> InvalidVariableDeclarationSub,\n     ) -> PResult<'a, Stmt> {\n-        let stmt = self.recover_local_after_let(lo, attrs)?;\n+        let stmt =\n+            self.collect_tokens_trailing_token(attrs, ForceCollect::Yes, |this, attrs| {\n+                let local = this.parse_local(attrs)?;\n+                // FIXME - maybe capture semicolon in recovery?\n+                Ok((\n+                    this.mk_stmt(lo.to(this.prev_token.span), StmtKind::Local(local)),\n+                    TrailingToken::None,\n+                ))\n+            })?;\n         self.sess.emit_err(InvalidVariableDeclaration { span: lo, sub: subdiagnostic(lo) });\n         Ok(stmt)\n     }\n@@ -243,17 +259,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn recover_local_after_let(&mut self, lo: Span, attrs: AttrWrapper) -> PResult<'a, Stmt> {\n-        self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n-            let local = this.parse_local(attrs)?;\n-            // FIXME - maybe capture semicolon in recovery?\n-            Ok((\n-                this.mk_stmt(lo.to(this.prev_token.span), StmtKind::Local(local)),\n-                TrailingToken::None,\n-            ))\n-        })\n-    }\n-\n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n         let lo = self.prev_token.span;"}, {"sha": "30d28ff34550375ad50f0db0af318ab8c2fba13f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -532,7 +532,8 @@ impl<K: DepKind> DepGraph<K> {\n             let mut edges = SmallVec::new();\n             K::read_deps(|task_deps| match task_deps {\n                 TaskDepsRef::Allow(deps) => edges.extend(deps.lock().reads.iter().copied()),\n-                TaskDepsRef::Ignore | TaskDepsRef::Forbid => {\n+                TaskDepsRef::Ignore => {} // During HIR lowering, we have no dependencies.\n+                TaskDepsRef::Forbid => {\n                     panic!(\"Cannot summarize when dependencies are not recorded.\")\n                 }\n             });"}, {"sha": "f6b6cf3a94c18e93f3075ae246db451067694c35", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1840,13 +1840,16 @@ impl<'a> Resolver<'a> {\n \n             (format!(\"use of undeclared type `{}`\", ident), suggestion)\n         } else {\n-            let suggestion = if ident.name == sym::alloc {\n-                Some((\n+            let mut suggestion = None;\n+            if ident.name == sym::alloc {\n+                suggestion = Some((\n                     vec![],\n                     String::from(\"add `extern crate alloc` to use the `alloc` crate\"),\n                     Applicability::MaybeIncorrect,\n                 ))\n-            } else {\n+            }\n+\n+            suggestion = suggestion.or_else(|| {\n                 self.find_similarly_named_module_or_crate(ident.name, &parent_scope.module).map(\n                     |sugg| {\n                         (\n@@ -1856,7 +1859,7 @@ impl<'a> Resolver<'a> {\n                         )\n                     },\n                 )\n-            };\n+            });\n             (format!(\"use of undeclared crate or module `{}`\", ident), suggestion)\n         }\n     }"}, {"sha": "b100a8c17cf398ba08c82d0fc8a226e93c82dd85", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -4,7 +4,10 @@ use crate::diagnostics::{import_candidates, Suggestion};\n use crate::Determinacy::{self, *};\n use crate::Namespace::*;\n use crate::{module_to_string, names_to_string, ImportSuggestion};\n-use crate::{AmbiguityKind, BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n+use crate::{\n+    AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingKey, ModuleKind, ResolutionError,\n+    Resolver, Segment,\n+};\n use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet};\n use crate::{NameBinding, NameBindingKind, PathResult};\n \n@@ -791,7 +794,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 match binding {\n                     Ok(binding) => {\n                         // Consistency checks, analogous to `finalize_macro_resolutions`.\n-                        let initial_res = source_bindings[ns].get().map(|initial_binding| {\n+                        let initial_binding = source_bindings[ns].get().map(|initial_binding| {\n                             all_ns_err = false;\n                             if let Some(target_binding) = target_bindings[ns].get() {\n                                 if target.name == kw::Underscore\n@@ -805,12 +808,20 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                     );\n                                 }\n                             }\n-                            initial_binding.res()\n+                            initial_binding\n                         });\n                         let res = binding.res();\n-                        if let Ok(initial_res) = initial_res {\n+                        if let Ok(initial_binding) = initial_binding {\n+                            let initial_res = initial_binding.res();\n                             if res != initial_res && this.ambiguity_errors.is_empty() {\n-                                span_bug!(import.span, \"inconsistent resolution for an import\");\n+                                this.ambiguity_errors.push(AmbiguityError {\n+                                    kind: AmbiguityKind::Import,\n+                                    ident,\n+                                    b1: initial_binding,\n+                                    b2: binding,\n+                                    misc1: AmbiguityErrorMisc::None,\n+                                    misc2: AmbiguityErrorMisc::None,\n+                                });\n                             }\n                         } else if res != Res::Err\n                             && this.ambiguity_errors.is_empty()"}, {"sha": "51a53f7b37cc2421db3f5cc5365b99310126738c", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -3365,13 +3365,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // Before we start looking for candidates, we have to get our hands\n             // on the type user is trying to perform invocation on; basically:\n             // we're transforming `HashMap::new` into just `HashMap`.\n-            let path = match path.split_last() {\n+            let prefix_path = match path.split_last() {\n                 Some((_, path)) if !path.is_empty() => path,\n                 _ => return Some(parent_err),\n             };\n \n             let (mut err, candidates) =\n-                this.smart_resolve_report_errors(path, path_span, PathSource::Type, None);\n+                this.smart_resolve_report_errors(prefix_path, path_span, PathSource::Type, None);\n \n             // There are two different error messages user might receive at\n             // this point:\n@@ -3415,11 +3415,23 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             if this.should_report_errs() {\n                 if candidates.is_empty() {\n-                    // When there is no suggested imports, we can just emit the error\n-                    // and suggestions immediately. Note that we bypass the usually error\n-                    // reporting routine (ie via `self.r.report_error`) because we need\n-                    // to post-process the `ResolutionError` above.\n-                    err.emit();\n+                    if path.len() == 2 && prefix_path.len() == 1 {\n+                        // Delay to check whether methond name is an associated function or not\n+                        // ```\n+                        // let foo = Foo {};\n+                        // foo::bar(); // possibly suggest to foo.bar();\n+                        //```\n+                        err.stash(\n+                            prefix_path[0].ident.span,\n+                            rustc_errors::StashKey::CallAssocMethod,\n+                        );\n+                    } else {\n+                        // When there is no suggested imports, we can just emit the error\n+                        // and suggestions immediately. Note that we bypass the usually error\n+                        // reporting routine (ie via `self.r.report_error`) because we need\n+                        // to post-process the `ResolutionError` above.\n+                        err.emit();\n+                    }\n                 } else {\n                     // If there are suggested imports, the error reporting is delayed\n                     this.r.use_injections.push(UseError {\n@@ -3428,7 +3440,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         def_id,\n                         instead: false,\n                         suggestion: None,\n-                        path: path.into(),\n+                        path: prefix_path.into(),\n                         is_call: source.is_call(),\n                     });\n                 }"}, {"sha": "8703e5754655f3c0a39792a7813da26054e0e5e4", "filename": "compiler/rustc_session/src/cgu_reuse_tracker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -121,7 +121,7 @@ impl CguReuseTracker {\n                         let at_least = if at_least { 1 } else { 0 };\n                         IncorrectCguReuseType {\n                             span: error_span.0,\n-                            cgu_user_name: &cgu_user_name,\n+                            cgu_user_name,\n                             actual_reuse,\n                             expected_reuse,\n                             at_least,"}, {"sha": "d8c4b0845d0acb67bc60114c74b98196ec25ed31", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -622,7 +622,7 @@ impl OutputFilenames {\n     /// should be placed on disk.\n     pub fn output_path(&self, flavor: OutputType) -> PathBuf {\n         let extension = flavor.extension();\n-        self.with_directory_and_extension(&self.out_directory, &extension)\n+        self.with_directory_and_extension(&self.out_directory, extension)\n     }\n \n     /// Gets the path where a compilation artifact of the given type for the\n@@ -659,7 +659,7 @@ impl OutputFilenames {\n \n         let temps_directory = self.temps_directory.as_ref().unwrap_or(&self.out_directory);\n \n-        self.with_directory_and_extension(&temps_directory, &extension)\n+        self.with_directory_and_extension(temps_directory, &extension)\n     }\n \n     pub fn with_extension(&self, extension: &str) -> PathBuf {\n@@ -1159,7 +1159,7 @@ impl CrateCheckConfig {\n                 values_target_family\n                     .extend(target.options.families.iter().map(|family| Symbol::intern(family)));\n                 values_target_arch.insert(Symbol::intern(&target.arch));\n-                values_target_endian.insert(Symbol::intern(&target.options.endian.as_str()));\n+                values_target_endian.insert(Symbol::intern(target.options.endian.as_str()));\n                 values_target_env.insert(Symbol::intern(&target.options.env));\n                 values_target_abi.insert(Symbol::intern(&target.options.abi));\n                 values_target_vendor.insert(Symbol::intern(&target.options.vendor));\n@@ -1846,7 +1846,7 @@ pub fn parse_target_triple(\n     match matches.opt_str(\"target\") {\n         Some(target) if target.ends_with(\".json\") => {\n             let path = Path::new(&target);\n-            TargetTriple::from_path(&path).unwrap_or_else(|_| {\n+            TargetTriple::from_path(path).unwrap_or_else(|_| {\n                 early_error(error_format, &format!(\"target file {path:?} does not exist\"))\n             })\n         }\n@@ -1992,7 +1992,7 @@ fn parse_native_lib_modifiers(\n ) -> (NativeLibKind, Option<bool>) {\n     let mut verbatim = None;\n     for modifier in modifiers.split(',') {\n-        let (modifier, value) = match modifier.strip_prefix(&['+', '-']) {\n+        let (modifier, value) = match modifier.strip_prefix(['+', '-']) {\n             Some(m) => (m, modifier.starts_with('+')),\n             None => early_error(\n                 error_format,\n@@ -2421,7 +2421,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut search_paths = vec![];\n     for s in &matches.opt_strs(\"L\") {\n-        search_paths.push(SearchPath::from_cli_opt(&s, error_format));\n+        search_paths.push(SearchPath::from_cli_opt(s, error_format));\n     }\n \n     let libs = parse_libs(matches, error_format);"}, {"sha": "8cb9e1a6f1ae81462eb65293fb736409083ddef2", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -317,7 +317,7 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n         LitError::InvalidIntSuffix => {\n             let suf = suffix.expect(\"suffix error with no suffix\");\n             let suf = suf.as_str();\n-            if looks_like_width_suffix(&['i', 'u'], &suf) {\n+            if looks_like_width_suffix(&['i', 'u'], suf) {\n                 // If it looks like a width, try to be helpful.\n                 sess.emit_err(InvalidIntLiteralWidth { span, width: suf[1..].into() });\n             } else if let Some(fixed) = fix_base_capitalisation(suf) {"}, {"sha": "01a9361e7867663f200ec7938cccc2da6352a5fa", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1414,8 +1414,6 @@ options! {\n         \"run all passes except codegen; no output\"),\n     no_generate_arange_section: bool = (false, parse_no_flag, [TRACKED],\n         \"omit DWARF address ranges that give faster lookups\"),\n-    no_interleave_lints: bool = (false, parse_no_flag, [UNTRACKED],\n-        \"execute lints separately; allows benchmarking individual lints\"),\n     no_leak_check: bool = (false, parse_no_flag, [UNTRACKED],\n         \"disable the 'leak check' for subtyping; unsound, but useful for tests\"),\n     no_link: bool = (false, parse_no_flag, [TRACKED],"}, {"sha": "d3c2c5113bcdec663f1b00fb9d873d316d7bccae", "filename": "compiler/rustc_span/src/analyze_source_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -247,7 +247,7 @@ fn analyze_source_file_generic(\n             // The slow path:\n             // This is either ASCII control character \"DEL\" or the beginning of\n             // a multibyte char. Just decode to `char`.\n-            let c = (&src[i..]).chars().next().unwrap();\n+            let c = src[i..].chars().next().unwrap();\n             char_len = c.len_utf8();\n \n             let pos = BytePos::from_usize(i) + output_offset;"}, {"sha": "886112769a977f78db57a95c9ddabafe985133dc", "filename": "compiler/rustc_span/src/caching_source_map_view.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -165,7 +165,7 @@ impl<'sm> CachingSourceMapView<'sm> {\n             Some(new_file_and_idx)\n         } else {\n             let file = &self.line_cache[oldest].file;\n-            if !file_contains(&file, span_data.hi) {\n+            if !file_contains(file, span_data.hi) {\n                 return None;\n             }\n "}, {"sha": "038699154c727dc72d9add71fc1e6ecc6f70b78c", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -381,7 +381,7 @@ impl HygieneData {\n     }\n \n     pub fn with<T, F: FnOnce(&mut HygieneData) -> T>(f: F) -> T {\n-        with_session_globals(|session_globals| f(&mut *session_globals.hygiene_data.borrow_mut()))\n+        with_session_globals(|session_globals| f(&mut session_globals.hygiene_data.borrow_mut()))\n     }\n \n     #[inline]"}, {"sha": "cef4c6f79cefd9d813824284f5d2886d973f0b86", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -238,7 +238,7 @@ impl RealFileName {\n     pub fn remapped_path_if_available(&self) -> &Path {\n         match self {\n             RealFileName::LocalPath(p)\n-            | RealFileName::Remapped { local_path: _, virtual_name: p } => &p,\n+            | RealFileName::Remapped { local_path: _, virtual_name: p } => p,\n         }\n     }\n "}, {"sha": "f0e91e5a6a917c3373fa399a2e496fe243ab805d", "filename": "compiler/rustc_span/src/span_encoding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -166,5 +166,5 @@ impl SpanInterner {\n // If an interner exists, return it. Otherwise, prepare a fresh one.\n #[inline]\n fn with_span_interner<T, F: FnOnce(&mut SpanInterner) -> T>(f: F) -> T {\n-    crate::with_session_globals(|session_globals| f(&mut *session_globals.span_interner.lock()))\n+    crate::with_session_globals(|session_globals| f(&mut session_globals.span_interner.lock()))\n }"}, {"sha": "9e446c96db319cc11d2221a23aad75c005f7438a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1877,7 +1877,7 @@ impl<S: Encoder> Encodable<S> for Symbol {\n impl<D: Decoder> Decodable<D> for Symbol {\n     #[inline]\n     default fn decode(d: &mut D) -> Symbol {\n-        Symbol::intern(&d.read_str())\n+        Symbol::intern(d.read_str())\n     }\n }\n "}, {"sha": "c8b6ac5ae25b2eb60152c2f3ae166471d0bb3f58", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -78,7 +78,7 @@ fn arg_scalar_pair<C>(\n where\n     C: HasDataLayout,\n {\n-    data = arg_scalar(cx, &scalar1, offset, data);\n+    data = arg_scalar(cx, scalar1, offset, data);\n     match (scalar1.primitive(), scalar2.primitive()) {\n         (abi::F32, _) => offset += Reg::f32().size,\n         (_, abi::F64) => offset += Reg::f64().size,\n@@ -90,7 +90,7 @@ where\n     if (offset.bytes() % 4) != 0 && scalar2.primitive().is_float() {\n         offset += Size::from_bytes(4 - (offset.bytes() % 4));\n     }\n-    data = arg_scalar(cx, &scalar2, offset, data);\n+    data = arg_scalar(cx, scalar2, offset, data);\n     return data;\n }\n "}, {"sha": "e72cab629ff19058cd332c33689fc851ee263cc4", "filename": "compiler/rustc_target/src/spec/aarch64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,4 +1,4 @@\n-use super::apple_base::{macos_link_env_remove, macos_llvm_target, opts, Arch};\n+use super::apple_base::{macos_llvm_target, opts, Arch};\n use crate::spec::{FramePointer, SanitizerSet, Target, TargetOptions};\n \n pub fn target() -> Target {\n@@ -10,8 +10,6 @@ pub fn target() -> Target {\n     // FIXME: The leak sanitizer currently fails the tests, see #88132.\n     base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::CFI | SanitizerSet::THREAD;\n \n-    base.link_env_remove.to_mut().extend(macos_link_env_remove());\n-\n     Target {\n         // Clang automatically chooses a more specific target based on\n         // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work"}, {"sha": "3c90a5e7e93ea74ca2ae33ac230ad3522d10f841", "filename": "compiler/rustc_target/src/spec/apple/tests.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple%2Ftests.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,6 +1,6 @@\n use crate::spec::{\n-    aarch64_apple_ios_sim, aarch64_apple_watchos_sim, x86_64_apple_ios, x86_64_apple_tvos,\n-    x86_64_apple_watchos_sim,\n+    aarch64_apple_darwin, aarch64_apple_ios_sim, aarch64_apple_watchos_sim, i686_apple_darwin,\n+    x86_64_apple_darwin, x86_64_apple_ios, x86_64_apple_tvos, x86_64_apple_watchos_sim,\n };\n \n #[test]\n@@ -18,3 +18,18 @@ fn simulator_targets_set_abi() {\n         assert_eq!(target.abi, \"sim\")\n     }\n }\n+\n+#[test]\n+fn macos_link_environment_unmodified() {\n+    let all_macos_targets = [\n+        aarch64_apple_darwin::target(),\n+        i686_apple_darwin::target(),\n+        x86_64_apple_darwin::target(),\n+    ];\n+\n+    for target in all_macos_targets {\n+        // macOS targets should only remove information for cross-compiling, but never\n+        // for the host.\n+        assert_eq!(target.link_env_remove, crate::spec::cvs![\"IPHONEOS_DEPLOYMENT_TARGET\"]);\n+    }\n+}"}, {"sha": "7f8160b5dec62d7ce4ed0b5a4ff5113cfb4da9ac", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -72,16 +72,6 @@ impl Arch {\n             Arm64_sim => \"apple-a12\",\n         }\n     }\n-\n-    fn link_env_remove(self) -> StaticCow<[StaticCow<str>]> {\n-        match self {\n-            Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | I686 | X86_64 | X86_64_sim\n-            | Arm64_sim => {\n-                cvs![\"MACOSX_DEPLOYMENT_TARGET\"]\n-            }\n-            X86_64_macabi | Arm64_macabi => cvs![\"IPHONEOS_DEPLOYMENT_TARGET\"],\n-        }\n-    }\n }\n \n fn pre_link_args(os: &'static str, arch: Arch, abi: &'static str) -> LinkArgs {\n@@ -140,7 +130,7 @@ pub fn opts(os: &'static str, arch: Arch) -> TargetOptions {\n         abi: abi.into(),\n         os: os.into(),\n         cpu: arch.target_cpu().into(),\n-        link_env_remove: arch.link_env_remove(),\n+        link_env_remove: link_env_remove(arch, os),\n         vendor: \"apple\".into(),\n         linker_flavor: LinkerFlavor::Darwin(Cc::Yes, Lld::No),\n         // macOS has -dead_strip, which doesn't rely on function_sections\n@@ -211,20 +201,38 @@ pub fn macos_llvm_target(arch: Arch) -> String {\n     format!(\"{}-apple-macosx{}.{}.0\", arch.target_name(), major, minor)\n }\n \n-pub fn macos_link_env_remove() -> Vec<StaticCow<str>> {\n-    let mut env_remove = Vec::with_capacity(2);\n-    // Remove the `SDKROOT` environment variable if it's clearly set for the wrong platform, which\n-    // may occur when we're linking a custom build script while targeting iOS for example.\n-    if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n-        if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"iPhoneSimulator.platform\") {\n-            env_remove.push(\"SDKROOT\".into())\n+fn link_env_remove(arch: Arch, os: &'static str) -> StaticCow<[StaticCow<str>]> {\n+    // Apple platforms only officially support macOS as a host for any compilation.\n+    //\n+    // If building for macOS, we go ahead and remove any erronous environment state\n+    // that's only applicable to cross-OS compilation. Always leave anything for the\n+    // host OS alone though.\n+    if os == \"macos\" {\n+        let mut env_remove = Vec::with_capacity(2);\n+        // Remove the `SDKROOT` environment variable if it's clearly set for the wrong platform, which\n+        // may occur when we're linking a custom build script while targeting iOS for example.\n+        if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n+            if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"iPhoneSimulator.platform\")\n+            {\n+                env_remove.push(\"SDKROOT\".into())\n+            }\n+        }\n+        // Additionally, `IPHONEOS_DEPLOYMENT_TARGET` must not be set when using the Xcode linker at\n+        // \"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld\",\n+        // although this is apparently ignored when using the linker at \"/usr/bin/ld\".\n+        env_remove.push(\"IPHONEOS_DEPLOYMENT_TARGET\".into());\n+        env_remove.into()\n+    } else {\n+        // Otherwise if cross-compiling for a different OS/SDK, remove any part\n+        // of the linking environment that's wrong and reversed.\n+        match arch {\n+            Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | I686 | X86_64 | X86_64_sim\n+            | Arm64_sim => {\n+                cvs![\"MACOSX_DEPLOYMENT_TARGET\"]\n+            }\n+            X86_64_macabi | Arm64_macabi => cvs![\"IPHONEOS_DEPLOYMENT_TARGET\"],\n         }\n     }\n-    // Additionally, `IPHONEOS_DEPLOYMENT_TARGET` must not be set when using the Xcode linker at\n-    // \"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld\",\n-    // although this is apparently ignored when using the linker at \"/usr/bin/ld\".\n-    env_remove.push(\"IPHONEOS_DEPLOYMENT_TARGET\".into());\n-    env_remove\n }\n \n fn ios_deployment_target() -> (u32, u32) {"}, {"sha": "ad22467ba9c8970ad4cdf13b804d648b307f6cfb", "filename": "compiler/rustc_target/src/spec/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,4 +1,4 @@\n-use super::apple_base::{macos_link_env_remove, macos_llvm_target, opts, Arch};\n+use super::apple_base::{macos_llvm_target, opts, Arch};\n use crate::spec::{Cc, FramePointer, LinkerFlavor, Lld, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n@@ -7,7 +7,6 @@ pub fn target() -> Target {\n     let mut base = opts(\"macos\", arch);\n     base.max_atomic_width = Some(64);\n     base.add_pre_link_args(LinkerFlavor::Darwin(Cc::Yes, Lld::No), &[\"-m32\"]);\n-    base.link_env_remove.to_mut().extend(macos_link_env_remove());\n     base.stack_probes = StackProbeType::X86;\n     base.frame_pointer = FramePointer::Always;\n "}, {"sha": "d05b8aa420067a9b4f8d1a66aa1650ce924f0216", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -2658,7 +2658,7 @@ impl Target {\n \n                 // Additionally look in the sysroot under `lib/rustlib/<triple>/target.json`\n                 // as a fallback.\n-                let rustlib_path = crate::target_rustlib_path(&sysroot, &target_triple);\n+                let rustlib_path = crate::target_rustlib_path(sysroot, target_triple);\n                 let p = PathBuf::from_iter([\n                     Path::new(sysroot),\n                     Path::new(&rustlib_path),"}, {"sha": "9a3e7a8050025c01cc63e69238ad78756b736213", "filename": "compiler/rustc_target/src/spec/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,4 +1,4 @@\n-use super::apple_base::{macos_link_env_remove, macos_llvm_target, opts, Arch};\n+use super::apple_base::{macos_llvm_target, opts, Arch};\n use crate::spec::{Cc, FramePointer, LinkerFlavor, Lld, SanitizerSet};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n@@ -8,7 +8,6 @@ pub fn target() -> Target {\n     base.max_atomic_width = Some(128); // core2 supports cmpxchg16b\n     base.frame_pointer = FramePointer::Always;\n     base.add_pre_link_args(LinkerFlavor::Darwin(Cc::Yes, Lld::No), &[\"-m64\"]);\n-    base.link_env_remove.to_mut().extend(macos_link_env_remove());\n     base.stack_probes = StackProbeType::X86;\n     base.supported_sanitizers =\n         SanitizerSet::ADDRESS | SanitizerSet::CFI | SanitizerSet::LEAK | SanitizerSet::THREAD;"}, {"sha": "899e30275a05296eb2de1958b29b41286f3f51d0", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -11,8 +11,8 @@ use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::util::impl_subject_and_oblig;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{\n-    self, Normalized, Obligation, ObligationCause, ObligationCtxt, PredicateObligation,\n-    PredicateObligations, SelectionContext,\n+    self, Obligation, ObligationCause, ObligationCtxt, PredicateObligation, PredicateObligations,\n+    SelectionContext,\n };\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n@@ -30,6 +30,8 @@ use std::fmt::Debug;\n use std::iter;\n use std::ops::ControlFlow;\n \n+use super::NormalizeExt;\n+\n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n #[derive(Copy, Clone, Debug)]\n@@ -128,8 +130,8 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n         predicates: tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs).predicates,\n     };\n \n-    let Normalized { value: mut header, obligations } =\n-        traits::normalize(selcx, param_env, ObligationCause::dummy(), header);\n+    let InferOk { value: mut header, obligations } =\n+        selcx.infcx.at(&ObligationCause::dummy(), param_env).normalize(header);\n \n     header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n     header"}, {"sha": "c028e89e4ea2963f093b48240a8f98ca613199d3", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -112,6 +112,24 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         self.register_infer_ok_obligations(infer_ok)\n     }\n \n+    /// Makes `expected <: actual`.\n+    pub fn eq_exp<T>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        a_is_expected: bool,\n+        a: T,\n+        b: T,\n+    ) -> Result<(), TypeError<'tcx>>\n+    where\n+        T: ToTrace<'tcx>,\n+    {\n+        self.infcx\n+            .at(cause, param_env)\n+            .eq_exp(a_is_expected, a, b)\n+            .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n+    }\n+\n     pub fn eq<T: ToTrace<'tcx>>(\n         &self,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "3379279dd15441bbe4bf61ac4b0959c7ba2d7683", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -9,7 +9,7 @@ use super::{\n };\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n+use crate::infer::{self, InferCtxt};\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::QueryNormalizeExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n@@ -71,7 +71,7 @@ pub trait InferCtxtExt<'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Option<Span>, Vec<ArgKind>)>;\n \n     /// Reports an error when the number of arguments needed by a\n     /// trait match doesn't match the number that the expression\n@@ -83,6 +83,7 @@ pub trait InferCtxtExt<'tcx> {\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n+        closure_pipe_span: Option<Span>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n \n     /// Checks if the type implements one of `Fn`, `FnMut`, or `FnOnce`\n@@ -135,15 +136,16 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Option<Span>, Vec<ArgKind>)> {\n         let sm = self.tcx.sess.source_map();\n         let hir = self.tcx.hir();\n         Some(match node {\n             Node::Expr(&hir::Expr {\n-                kind: hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }),\n+                kind: hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, fn_arg_span, .. }),\n                 ..\n             }) => (\n                 fn_decl_span,\n+                fn_arg_span,\n                 hir.body(body)\n                     .params\n                     .iter()\n@@ -174,6 +176,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                 kind: hir::TraitItemKind::Fn(ref sig, _), ..\n             }) => (\n                 sig.span,\n+                None,\n                 sig.decl\n                     .inputs\n                     .iter()\n@@ -188,7 +191,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             ),\n             Node::Ctor(ref variant_data) => {\n                 let span = variant_data.ctor_hir_id().map_or(DUMMY_SP, |id| hir.span(id));\n-                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n+                (span, None, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n         })\n@@ -204,6 +207,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n+        closure_arg_span: Option<Span>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let kind = if is_closure { \"closure\" } else { \"function\" };\n \n@@ -241,24 +245,13 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         if let Some(found_span) = found_span {\n             err.span_label(found_span, format!(\"takes {}\", found_str));\n \n-            // move |_| { ... }\n-            // ^^^^^^^^-- def_span\n-            //\n-            // move |_| { ... }\n-            // ^^^^^-- prefix\n-            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n-            // move |_| { ... }\n-            //      ^^^-- pipe_span\n-            let pipe_span =\n-                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n-\n             // Suggest to take and ignore the arguments with expected_args_length `_`s if\n             // found arguments is empty (assume the user just wants to ignore args in this case).\n             // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n             if found_args.is_empty() && is_closure {\n                 let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n                 err.span_suggestion_verbose(\n-                    pipe_span,\n+                    closure_arg_span.unwrap_or(found_span),\n                     &format!(\n                         \"consider changing the closure to take and ignore the expected argument{}\",\n                         pluralize!(expected_args.len())\n@@ -1252,20 +1245,22 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         obligation.cause.code(),\n                     )\n                 } else {\n-                    let (closure_span, found) = found_did\n+                    let (closure_span, closure_arg_span, found) = found_did\n                         .and_then(|did| {\n                             let node = self.tcx.hir().get_if_local(did)?;\n-                            let (found_span, found) = self.get_fn_like_arguments(node)?;\n-                            Some((Some(found_span), found))\n+                            let (found_span, closure_arg_span, found) =\n+                                self.get_fn_like_arguments(node)?;\n+                            Some((Some(found_span), closure_arg_span, found))\n                         })\n-                        .unwrap_or((found_span, found));\n+                        .unwrap_or((found_span, None, found));\n \n                     self.report_arg_count_mismatch(\n                         span,\n                         closure_span,\n                         expected,\n                         found,\n                         found_trait_ty.is_closure(),\n+                        closure_arg_span,\n                     )\n                 }\n             }\n@@ -1577,32 +1572,26 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n \n         self.probe(|_| {\n-            let mut err = error.err;\n-            let mut values = None;\n+            let ocx = ObligationCtxt::new_in_snapshot(self);\n \n             // try to find the mismatched types to report the error with.\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n             let bound_predicate = predicate.kind();\n-            if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n+            let (values, err) = if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n                 bound_predicate.skip_binder()\n             {\n-                let mut selcx = SelectionContext::new(self);\n                 let data = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n                     bound_predicate.rebind(data),\n                 );\n-                let mut obligations = vec![];\n-                // FIXME(normalization): Change this to use `At::normalize`\n-                let normalized_ty = super::normalize_projection_type(\n-                    &mut selcx,\n+                let normalized_ty = ocx.normalize(\n+                    &obligation.cause,\n                     obligation.param_env,\n-                    data.projection_ty,\n-                    obligation.cause.clone(),\n-                    0,\n-                    &mut obligations,\n+                    self.tcx\n+                        .mk_projection(data.projection_ty.item_def_id, data.projection_ty.substs),\n                 );\n \n                 debug!(?obligation.cause, ?obligation.param_env);\n@@ -1618,19 +1607,34 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         | ObligationCauseCode::ObjectCastObligation(..)\n                         | ObligationCauseCode::OpaqueType\n                 );\n-                if let Err(new_err) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n+                let expected_ty = data.term.ty().unwrap();\n+\n+                // constrain inference variables a bit more to nested obligations from normalize so\n+                // we can have more helpful errors.\n+                ocx.select_where_possible();\n+\n+                if let Err(new_err) = ocx.eq_exp(\n+                    &obligation.cause,\n+                    obligation.param_env,\n                     is_normalized_ty_expected,\n                     normalized_ty,\n-                    data.term,\n+                    expected_ty,\n                 ) {\n-                    values = Some((data, is_normalized_ty_expected, normalized_ty, data.term));\n-                    err = new_err;\n+                    (Some((data, is_normalized_ty_expected, normalized_ty, expected_ty)), new_err)\n+                } else {\n+                    (None, error.err)\n                 }\n-            }\n+            } else {\n+                (None, error.err)\n+            };\n \n             let msg = values\n                 .and_then(|(predicate, _, normalized_ty, expected_ty)| {\n-                    self.maybe_detailed_projection_msg(predicate, normalized_ty, expected_ty)\n+                    self.maybe_detailed_projection_msg(\n+                        predicate,\n+                        normalized_ty.into(),\n+                        expected_ty.into(),\n+                    )\n                 })\n                 .unwrap_or_else(|| format!(\"type mismatch resolving `{}`\", predicate));\n             let mut diag = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271, \"{msg}\");\n@@ -1672,11 +1676,11 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 &mut diag,\n                 &obligation.cause,\n                 secondary_span,\n-                values.map(|(_, is_normalized_ty_expected, normalized_ty, term)| {\n+                values.map(|(_, is_normalized_ty_expected, normalized_ty, expected_ty)| {\n                     infer::ValuePairs::Terms(ExpectedFound::new(\n                         is_normalized_ty_expected,\n-                        normalized_ty,\n-                        term,\n+                        normalized_ty.into(),\n+                        expected_ty.into(),\n                     ))\n                 }),\n                 err,\n@@ -1930,14 +1934,6 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             return report(normalized_impl_candidates, err);\n         }\n \n-        let normalize = |candidate| {\n-            let infcx = self.tcx.infer_ctxt().build();\n-            infcx\n-                .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-                .query_normalize(candidate)\n-                .map_or(candidate, |normalized| normalized.value)\n-        };\n-\n         // Sort impl candidates so that ordering is consistent for UI tests.\n         // because the ordering of `impl_candidates` may not be deterministic:\n         // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n@@ -1947,7 +1943,11 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let mut normalized_impl_candidates_and_similarities = impl_candidates\n             .into_iter()\n             .map(|ImplCandidate { trait_ref, similarity }| {\n-                let normalized = normalize(trait_ref);\n+                // FIXME(compiler-errors): This should be using `NormalizeExt::normalize`\n+                let normalized = self\n+                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                    .query_normalize(trait_ref)\n+                    .map_or(trait_ref, |normalized| normalized.value);\n                 (similarity, normalized)\n             })\n             .collect::<Vec<_>>();"}, {"sha": "c6818a4e57d424cb04355b43f1451bf5caecdfa3", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -56,7 +56,6 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub(crate) use self::project::{normalize, normalize_to};\n pub use self::project::{normalize_projection_type, NormalizeExt};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};"}, {"sha": "051660be9c474abb77ada510476f05f55426dc14", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -50,14 +50,18 @@ pub type ProjectionTyObligation<'tcx> = Obligation<'tcx, ty::ProjectionTy<'tcx>>\n pub(super) struct InProgress;\n \n pub trait NormalizeExt<'tcx> {\n+    /// Normalize a value using the `AssocTypeNormalizer`.\n+    ///\n+    /// This normalization should be used when the type contains inference variables or the\n+    /// projection may be fallible.\n     fn normalize<T: TypeFoldable<'tcx>>(&self, t: T) -> InferOk<'tcx, T>;\n }\n \n impl<'tcx> NormalizeExt<'tcx> for At<'_, 'tcx> {\n     fn normalize<T: TypeFoldable<'tcx>>(&self, value: T) -> InferOk<'tcx, T> {\n         let mut selcx = SelectionContext::new(self.infcx);\n         let Normalized { value, obligations } =\n-            normalize(&mut selcx, self.param_env, self.cause.clone(), value);\n+            normalize_with_depth(&mut selcx, self.param_env, self.cause.clone(), 0, value);\n         InferOk { value, obligations }\n     }\n }\n@@ -303,37 +307,6 @@ fn project_and_unify_type<'cx, 'tcx>(\n     }\n }\n \n-/// Normalizes any associated type projections in `value`, replacing\n-/// them with a fully resolved type where possible. The return value\n-/// combines the normalized result and any additional obligations that\n-/// were incurred as result.\n-pub(crate) fn normalize<'a, 'b, 'tcx, T>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    value: T,\n-) -> Normalized<'tcx, T>\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    let mut obligations = Vec::new();\n-    let value = normalize_to(selcx, param_env, cause, value, &mut obligations);\n-    Normalized { value, obligations }\n-}\n-\n-pub(crate) fn normalize_to<'a, 'b, 'tcx, T>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    value: T,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    normalize_with_depth_to(selcx, param_env, cause, 0, value, obligations)\n-}\n-\n /// As `normalize`, but with a custom depth.\n pub(crate) fn normalize_with_depth<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n@@ -2324,10 +2297,11 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         },\n     ));\n \n-    let ty = super::normalize_to(\n+    let ty = normalize_with_depth_to(\n         selcx,\n         obligation.param_env,\n         cause.clone(),\n+        obligation.recursion_depth + 1,\n         tcx.bound_trait_impl_trait_tys(impl_fn_def_id)\n             .map_bound(|tys| {\n                 tys.map_or_else(|_| tcx.ty_error(), |tys| tys[&obligation.predicate.item_def_id])"}, {"sha": "f899321fc01e1e4d1a13ea625b4185871c67fe41", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -23,6 +23,13 @@ use super::NoSolution;\n pub use rustc_middle::traits::query::NormalizationResult;\n \n pub trait QueryNormalizeExt<'tcx> {\n+    /// Normalize a value using the `QueryNormalizer`.\n+    ///\n+    /// This normalization should *only* be used when the projection does not\n+    /// have possible ambiguity or may not be well-formed.\n+    ///\n+    /// After codegen, when lifetimes do not matter, it is preferable to instead\n+    /// use [`TyCtxt::normalize_erasing_regions`], which wraps this procedure.\n     fn query_normalize<T>(&self, value: T) -> Result<Normalized<'tcx, T>, NoSolution>\n     where\n         T: TypeFoldable<'tcx>;"}, {"sha": "e4b70f0d2ffa7afbfc54dbf7fdaa252400ef1226", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -203,7 +203,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // type/region parameters.\n         let self_ty = obligation.self_ty().skip_binder();\n         match self_ty.kind() {\n-            ty::Generator(..) => {\n+            // async constructs get lowered to a special kind of generator that\n+            // should *not* `impl Generator`.\n+            ty::Generator(did, ..) if !self.tcx().generator_is_async(*did) => {\n                 debug!(?self_ty, ?obligation, \"assemble_generator_candidates\",);\n \n                 candidates.vec.push(GeneratorCandidate);\n@@ -223,6 +225,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) {\n         let self_ty = obligation.self_ty().skip_binder();\n         if let ty::Generator(did, ..) = self_ty.kind() {\n+            // async constructs get lowered to a special kind of generator that\n+            // should directly `impl Future`.\n             if self.tcx().generator_is_async(*did) {\n                 debug!(?self_ty, ?obligation, \"assemble_future_candidates\",);\n "}, {"sha": "8835f2cc1b97a7737879b252f62a2dfaf7be2d91", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -371,23 +371,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     if !candidate_set.ambiguous && no_candidates_apply {\n                         let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                        let self_ty = trait_ref.self_ty();\n-                        let (trait_desc, self_desc) = with_no_trimmed_paths!({\n-                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n-                            let self_desc = if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n+                        if !trait_ref.references_error() {\n+                            let self_ty = trait_ref.self_ty();\n+                            let (trait_desc, self_desc) = with_no_trimmed_paths!({\n+                                let trait_desc = trait_ref.print_only_trait_path().to_string();\n+                                let self_desc = if self_ty.has_concrete_skeleton() {\n+                                    Some(self_ty.to_string())\n+                                } else {\n+                                    None\n+                                };\n+                                (trait_desc, self_desc)\n+                            });\n+                            let cause = if let Conflict::Upstream = conflict {\n+                                IntercrateAmbiguityCause::UpstreamCrateUpdate {\n+                                    trait_desc,\n+                                    self_desc,\n+                                }\n                             } else {\n-                                None\n+                                IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n                             };\n-                            (trait_desc, self_desc)\n-                        });\n-                        let cause = if let Conflict::Upstream = conflict {\n-                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                        } else {\n-                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                        };\n-                        debug!(?cause, \"evaluate_stack: pushing cause\");\n-                        self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n+                            debug!(?cause, \"evaluate_stack: pushing cause\");\n+                            self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n+                        }\n                     }\n                 }\n             }"}, {"sha": "4866c53e7d521c64d5870b2e8be8553d86e24bc7", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -2699,12 +2699,18 @@ impl<T, A: Allocator> IndexMut<usize> for VecDeque<T, A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for VecDeque<T> {\n+    #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> VecDeque<T> {\n-        let iterator = iter.into_iter();\n-        let (lower, _) = iterator.size_hint();\n-        let mut deq = VecDeque::with_capacity(lower);\n-        deq.extend(iterator);\n-        deq\n+        // Since converting is O(1) now, might as well re-use that logic\n+        // (including things like the `vec::IntoIter`\u2192`Vec` specialization)\n+        // especially as that could save us some monomorphiziation work\n+        // if one uses the same iterators (like slice ones) with both.\n+        return from_iter_via_vec(iter.into_iter());\n+\n+        #[inline]\n+        fn from_iter_via_vec<U>(iter: impl Iterator<Item = U>) -> VecDeque<U> {\n+            Vec::from_iter(iter).into()\n+        }\n     }\n }\n \n@@ -2791,6 +2797,7 @@ impl<T, A: Allocator> From<Vec<T, A>> for VecDeque<T, A> {\n     /// In its current implementation, this is a very cheap\n     /// conversion. This isn't yet a guarantee though, and\n     /// shouldn't be relied on.\n+    #[inline]\n     fn from(other: Vec<T, A>) -> Self {\n         let (ptr, len, cap, alloc) = other.into_raw_parts_with_alloc();\n         Self { head: 0, len, buf: unsafe { RawVec::from_raw_parts_in(ptr, cap, alloc) } }"}, {"sha": "ba34ab6800fad4cdd9f6e8be14a63eca335aac17", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1070,7 +1070,8 @@ impl<T, A: Allocator> Vec<T, A> {\n \n     /// Converts the vector into [`Box<[T]>`][owned slice].\n     ///\n-    /// Note that this will drop any excess capacity.\n+    /// If the vector has excess capacity, its items will be moved into a\n+    /// newly-allocated buffer with exactly the right capacity.\n     ///\n     /// [owned slice]: Box\n     ///\n@@ -3223,6 +3224,14 @@ impl<T, A: Allocator> From<Vec<T, A>> for Box<[T], A> {\n     /// ```\n     /// assert_eq!(Box::from(vec![1, 2, 3]), vec![1, 2, 3].into_boxed_slice());\n     /// ```\n+    ///\n+    /// Any excess capacity is removed:\n+    /// ```\n+    /// let mut vec = Vec::with_capacity(10);\n+    /// vec.extend([1, 2, 3]);\n+    ///\n+    /// assert_eq!(Box::from(vec), vec![1, 2, 3].into_boxed_slice());\n+    /// ```\n     fn from(v: Vec<T, A>) -> Self {\n         v.into_boxed_slice()\n     }"}, {"sha": "6a339b338d990f87c410fd146eebdb29d59b9616", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1249,12 +1249,11 @@ macro_rules! nonzero_bits {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_bits)]\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::BITS, \", stringify!($Int), \"::BITS);\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_bits\", issue = \"94881\")]\n+                #[stable(feature = \"nonzero_bits\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const BITS: u32 = <$Int>::BITS;\n             }\n         )+"}, {"sha": "a704a00faaafadbbdedb51a3d1cb457dcb3992ed", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -38,10 +38,9 @@ use crate::panic::{Location, PanicInfo};\n /// site as much as possible (so that `panic!()` has as low an impact\n /// on (e.g.) the inlining of other functions as possible), by moving\n /// the actual formatting into this shared place.\n-#[cold]\n // If panic_immediate_abort, inline the abort call,\n // otherwise avoid inlining because of it is cold path.\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[track_caller]\n #[lang = \"panic_fmt\"] // needed for const-evaluated panics\n@@ -67,8 +66,7 @@ pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n \n /// Like panic_fmt, but without unwinding and track_caller to reduce the impact on codesize.\n /// Also just works on `str`, as a `fmt::Arguments` needs more space to be passed.\n-#[cold]\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[rustc_nounwind]\n pub fn panic_str_nounwind(msg: &'static str) -> ! {\n@@ -96,10 +94,9 @@ pub fn panic_str_nounwind(msg: &'static str) -> ! {\n // above.\n \n /// The underlying implementation of libcore's `panic!` macro when no formatting is used.\n-#[cold]\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[track_caller]\n #[rustc_const_unstable(feature = \"core_panic\", issue = \"none\")]\n@@ -138,8 +135,8 @@ pub const fn panic_display<T: fmt::Display>(x: &T) -> ! {\n     panic_fmt(format_args!(\"{}\", *x));\n }\n \n-#[cold]\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[track_caller]\n #[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n fn panic_bounds_check(index: usize, len: usize) -> ! {\n@@ -154,8 +151,8 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n ///\n /// This function is called directly by the codegen backend, and must not have\n /// any extra arguments (including those synthesized by track_caller).\n-#[cold]\n-#[inline(never)]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[lang = \"panic_no_unwind\"] // needed by codegen for panic in nounwind function\n #[rustc_nounwind]\n fn panic_no_unwind() -> ! {\n@@ -185,7 +182,8 @@ pub enum AssertKind {\n }\n \n /// Internal function for `assert_eq!` and `assert_ne!` macros\n-#[cold]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[track_caller]\n #[doc(hidden)]\n pub fn assert_failed<T, U>(\n@@ -202,7 +200,8 @@ where\n }\n \n /// Internal function for `assert_match!`\n-#[cold]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[track_caller]\n #[doc(hidden)]\n pub fn assert_matches_failed<T: fmt::Debug + ?Sized>(\n@@ -221,6 +220,8 @@ pub fn assert_matches_failed<T: fmt::Debug + ?Sized>(\n }\n \n /// Non-generic version of the above functions, to avoid code bloat.\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[track_caller]\n fn assert_failed_inner(\n     kind: AssertKind,"}, {"sha": "c295a0e06458d910a104c3242b711c1dc9e3081c", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -31,9 +31,8 @@ where\n     }\n }\n \n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cold]\n #[track_caller]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n const fn slice_start_index_len_fail(index: usize, len: usize) -> ! {\n@@ -48,19 +47,20 @@ const fn slice_start_index_len_fail(index: usize, len: usize) -> ! {\n }\n \n // FIXME const-hack\n+#[inline]\n #[track_caller]\n fn slice_start_index_len_fail_rt(index: usize, len: usize) -> ! {\n     panic!(\"range start index {index} out of range for slice of length {len}\");\n }\n \n+#[inline]\n #[track_caller]\n const fn slice_start_index_len_fail_ct(_: usize, _: usize) -> ! {\n     panic!(\"slice start index is out of range for slice\");\n }\n \n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cold]\n #[track_caller]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n const fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n@@ -71,19 +71,20 @@ const fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n }\n \n // FIXME const-hack\n+#[inline]\n #[track_caller]\n fn slice_end_index_len_fail_rt(index: usize, len: usize) -> ! {\n     panic!(\"range end index {index} out of range for slice of length {len}\");\n }\n \n+#[inline]\n #[track_caller]\n const fn slice_end_index_len_fail_ct(_: usize, _: usize) -> ! {\n     panic!(\"slice end index is out of range for slice\");\n }\n \n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cold]\n #[track_caller]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n const fn slice_index_order_fail(index: usize, end: usize) -> ! {\n@@ -92,27 +93,27 @@ const fn slice_index_order_fail(index: usize, end: usize) -> ! {\n }\n \n // FIXME const-hack\n+#[inline]\n #[track_caller]\n fn slice_index_order_fail_rt(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {index} but ends at {end}\");\n }\n \n+#[inline]\n #[track_caller]\n const fn slice_index_order_fail_ct(_: usize, _: usize) -> ! {\n     panic!(\"slice index start is larger than end\");\n }\n \n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cold]\n #[track_caller]\n const fn slice_start_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice from after maximum usize\");\n }\n \n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cold]\n #[track_caller]\n const fn slice_end_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice up to maximum usize\");"}, {"sha": "f357d505fe89ce2adcd50f2fdb08615651bc7fae", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -510,8 +510,9 @@ impl File {\n     /// # Errors\n     ///\n     /// This function will return an error if the file is not opened for writing.\n-    /// Also, std::io::ErrorKind::InvalidInput will be returned if the desired\n-    /// length would cause an overflow due to the implementation specifics.\n+    /// Also, [`std::io::ErrorKind::InvalidInput`](crate::io::ErrorKind::InvalidInput)\n+    /// will be returned if the desired length would cause an overflow due to\n+    /// the implementation specifics.\n     ///\n     /// # Examples\n     ///"}, {"sha": "1039835bbbdfe5430d9f5175ed28b7b4d11ef883", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -594,8 +594,8 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n // lang item for CTFE panic support\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n-#[cold]\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n #[track_caller]\n #[rustc_do_not_const_check] // hooked by const-eval\n pub const fn begin_panic<M: Any + Send>(msg: M) -> ! {"}, {"sha": "524658bce139d73794a18ca88237241a6aec1dce", "filename": "library/test/src/cli.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Ftest%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Ftest%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fcli.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -26,6 +26,10 @@ pub struct TestOpts {\n     pub test_threads: Option<usize>,\n     pub skip: Vec<String>,\n     pub time_options: Option<TestTimeOptions>,\n+    /// Stop at first failing test.\n+    /// May run a few more tests due to threading, but will\n+    /// abort as soon as possible.\n+    pub fail_fast: bool,\n     pub options: Options,\n }\n \n@@ -296,6 +300,7 @@ fn parse_opts_impl(matches: getopts::Matches) -> OptRes {\n         skip,\n         time_options,\n         options,\n+        fail_fast: false,\n     };\n \n     Ok(test_opts)"}, {"sha": "a3c39f71f08b88ef38fd3e7673a78d062a78f630", "filename": "library/test/src/console.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -293,7 +293,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n     run_tests(opts, tests, |x| on_test_event(&x, &mut st, &mut *out))?;\n     st.exec_time = start_time.map(|t| TestSuiteExecTime(t.elapsed()));\n \n-    assert!(st.current_test_count() == st.total);\n+    assert!(opts.fail_fast || st.current_test_count() == st.total);\n \n     out.write_run_finish(&st)\n }"}, {"sha": "256c9e8d141e0baa57684ec5ebdb9c74cb5fc7c0", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -384,8 +384,17 @@ where\n             let mut completed_test = rx.recv().unwrap();\n             RunningTest { join_handle }.join(&mut completed_test);\n \n+            let fail_fast = match completed_test.result {\n+                TrIgnored | TrOk | TrBench(_) => false,\n+                TrFailed | TrFailedMsg(_) | TrTimedFail => opts.fail_fast,\n+            };\n+\n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n+\n+            if fail_fast {\n+                return Ok(());\n+            }\n         }\n     } else {\n         while pending > 0 || !remaining.is_empty() {\n@@ -431,9 +440,20 @@ where\n             let running_test = running_tests.remove(&completed_test.id).unwrap();\n             running_test.join(&mut completed_test);\n \n+            let fail_fast = match completed_test.result {\n+                TrIgnored | TrOk | TrBench(_) => false,\n+                TrFailed | TrFailedMsg(_) | TrTimedFail => opts.fail_fast,\n+            };\n+\n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n             pending -= 1;\n+\n+            if fail_fast {\n+                // Prevent remaining test threads from panicking\n+                std::mem::forget(rx);\n+                return Ok(());\n+            }\n         }\n     }\n "}, {"sha": "3a0260f86cf5d081f08a4b6122a0f40c3ed77b38", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -51,6 +51,7 @@ impl TestOpts {\n             skip: vec![],\n             time_options: None,\n             options: Options::new(),\n+            fail_fast: false,\n         }\n     }\n }"}, {"sha": "efe8ae3169fc2f9e4ca678f809a3d7aaf095bec4", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -11,15 +11,6 @@ dependencies = [\n  \"memchr\",\n ]\n \n-[[package]]\n-name = \"ansi_term\"\n-version = \"0.12.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2\"\n-dependencies = [\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"autocfg\"\n version = \"1.1.0\"\n@@ -108,28 +99,28 @@ checksum = \"5827cebf4670468b8772dd191856768aedcb1b0278a04f989f7766351917b9dc\"\n \n [[package]]\n name = \"cpufeatures\"\n-version = \"0.2.2\"\n+version = \"0.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"59a6001667ab124aebae2a495118e11d30984c3a653e99d86d58971708cf5e4b\"\n+checksum = \"28d997bd5e24a5928dd43e46dc529867e207907fe0b239c3477d924f7f2ca320\"\n dependencies = [\n  \"libc\",\n ]\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.4\"\n+version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aaa7bd5fb665c6864b5f963dd9097905c54125909c7aa94c9e18507cdbe6c53\"\n+checksum = \"c2dd04ddaf88237dc3b8d8f9a3c1004b506b54b3313403944054d23c0870c521\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils\",\n ]\n \n [[package]]\n name = \"crossbeam-deque\"\n-version = \"0.8.1\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6455c0ca19f0d2fbf751b908d5c55c1f5cbc65e03c4225427254b46890bdde1e\"\n+checksum = \"715e8152b692bba2d374b53d4875445368fdf21a94751410af607a5ac677d1fc\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-epoch\",\n@@ -138,26 +129,24 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.9.8\"\n+version = \"0.9.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1145cf131a2c6ba0615079ab6a638f7e1973ac9c2634fcbeaaad6114246efe8c\"\n+checksum = \"01a9af1f4c2ef74bb8aa1f7e19706bc72d03598c8a570bb5de72243c7a9d9d5a\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n  \"crossbeam-utils\",\n- \"lazy_static\",\n  \"memoffset\",\n  \"scopeguard\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.8\"\n+version = \"0.8.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0bf124c720b7686e3c2663cf54062ab0f68a88af2fb6a030e87e30bf721fcb38\"\n+checksum = \"4fb766fa798726286dbbb842f174001dab8abc7b627a1dd86e0b7222a95d929f\"\n dependencies = [\n  \"cfg-if\",\n- \"lazy_static\",\n ]\n \n [[package]]\n@@ -379,9 +368,9 @@ checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"memoffset\"\n-version = \"0.6.5\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n+checksum = \"5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4\"\n dependencies = [\n  \"autocfg\",\n ]\n@@ -447,14 +436,14 @@ checksum = \"1df8c4ec4b0627e53bdf214615ad287367e482558cf84b109250b37464dc03ae\"\n \n [[package]]\n name = \"pretty_assertions\"\n-version = \"0.7.2\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cab0e7c02cf376875e9335e0ba1da535775beb5450d21e1dffca068818ed98b\"\n+checksum = \"a25e9bcb20aa780fd0bb16b72403a9064d6b3f22f026946029acb941a50af755\"\n dependencies = [\n- \"ansi_term\",\n  \"ctor\",\n  \"diff\",\n  \"output_vt100\",\n+ \"yansi\",\n ]\n \n [[package]]\n@@ -477,21 +466,20 @@ dependencies = [\n \n [[package]]\n name = \"rayon\"\n-version = \"1.5.3\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bd99e5772ead8baa5215278c9b15bf92087709e9c1b2d1f97cdb5a183c933a7d\"\n+checksum = \"1e060280438193c554f654141c9ea9417886713b7acd75974c85b18a69a88e0b\"\n dependencies = [\n- \"autocfg\",\n  \"crossbeam-deque\",\n  \"either\",\n  \"rayon-core\",\n ]\n \n [[package]]\n name = \"rayon-core\"\n-version = \"1.9.3\"\n+version = \"1.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"258bcdb5ac6dad48491bb2992db6b7cf74878b0384908af124823d118c99683f\"\n+checksum = \"cac410af5d00ab6884528b4ab69d1e8e146e8d471201800fa1b4524126de6ad3\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"crossbeam-deque\",\n@@ -803,3 +791,9 @@ checksum = \"c179869f34fc7c01830d3ce7ea2086bc3a07e0d35289b667d0a8bf910258926c\"\n dependencies = [\n  \"lzma-sys\",\n ]\n+\n+[[package]]\n+name = \"yansi\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"09041cd90cf85f7f8b2df60c646f853b7f535ce68f85244eb6731cf89fa498ec\""}, {"sha": "ccc7ec1fce9f010d3842e31ba6e63b6ad4720efd", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -72,7 +72,7 @@ features = [\n ]\n \n [dev-dependencies]\n-pretty_assertions = \"0.7\"\n+pretty_assertions = \"1.2\"\n \n [features]\n build-metrics = [\"sysinfo\"]"}, {"sha": "d69bced0b28db14b105fbce6c030ee9bb4c96890", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -647,10 +647,23 @@ impl Build {\n         if !update(true).status().map_or(false, |status| status.success()) {\n             self.run(&mut update(false));\n         }\n-        self.run(Command::new(\"git\").args(&[\"stash\", \"push\"]).current_dir(&absolute_path));\n+\n+        // Save any local changes, but avoid running `git stash pop` if there are none (since it will exit with an error).\n+        let has_local_modifications = !self.try_run(\n+            Command::new(\"git\")\n+                .args(&[\"diff-index\", \"--quiet\", \"HEAD\"])\n+                .current_dir(&absolute_path),\n+        );\n+        if has_local_modifications {\n+            self.run(Command::new(\"git\").args(&[\"stash\", \"push\"]).current_dir(&absolute_path));\n+        }\n+\n         self.run(Command::new(\"git\").args(&[\"reset\", \"-q\", \"--hard\"]).current_dir(&absolute_path));\n         self.run(Command::new(\"git\").args(&[\"clean\", \"-qdfx\"]).current_dir(&absolute_path));\n-        self.run(Command::new(\"git\").args(&[\"stash\", \"pop\"]).current_dir(absolute_path));\n+\n+        if has_local_modifications {\n+            self.run(Command::new(\"git\").args(&[\"stash\", \"pop\"]).current_dir(absolute_path));\n+        }\n     }\n \n     /// If any submodule has been initialized already, sync it unconditionally."}, {"sha": "75e44fe49874a7cca91f1f2590f80b9ad1893a08", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -77,7 +77,7 @@ x--expand-yaml-anchors--remove:\n     <<: *base-job\n \n   - &job-macos-xl\n-    os: macos-latest  # We don't have an XL builder for this\n+    os: macos-12-xl\n     <<: *base-job\n \n   - &job-windows-xl"}, {"sha": "0271c27b4f522142474fb7ef9e910b7684093d02", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -32,7 +32,7 @@ features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"]\n rayon = \"1.5.1\"\n \n [dev-dependencies]\n-expect-test = \"1.0\"\n+expect-test = \"1.4.0\"\n \n [features]\n jemalloc = []"}, {"sha": "2a2a9470d25c0ee4da19badf253f0207a6dcdda7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -12,7 +12,7 @@ pub(crate) mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet, IndexEntry};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -598,47 +598,105 @@ pub(crate) fn clean_generics<'tcx>(\n         })\n         .collect::<Vec<_>>();\n \n+    let mut bound_predicates = FxIndexMap::default();\n+    let mut region_predicates = FxIndexMap::default();\n+    let mut eq_predicates = ThinVec::default();\n+    for pred in gens.predicates.iter().filter_map(|x| clean_where_predicate(x, cx)) {\n+        match pred {\n+            WherePredicate::BoundPredicate { ty, bounds, bound_params } => {\n+                match bound_predicates.entry(ty) {\n+                    IndexEntry::Vacant(v) => {\n+                        v.insert((bounds, bound_params));\n+                    }\n+                    IndexEntry::Occupied(mut o) => {\n+                        // we merge both bounds.\n+                        for bound in bounds {\n+                            if !o.get().0.contains(&bound) {\n+                                o.get_mut().0.push(bound);\n+                            }\n+                        }\n+                        for bound_param in bound_params {\n+                            if !o.get().1.contains(&bound_param) {\n+                                o.get_mut().1.push(bound_param);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            WherePredicate::RegionPredicate { lifetime, bounds } => {\n+                match region_predicates.entry(lifetime) {\n+                    IndexEntry::Vacant(v) => {\n+                        v.insert(bounds);\n+                    }\n+                    IndexEntry::Occupied(mut o) => {\n+                        // we merge both bounds.\n+                        for bound in bounds {\n+                            if !o.get().contains(&bound) {\n+                                o.get_mut().push(bound);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            WherePredicate::EqPredicate { lhs, rhs, bound_params } => {\n+                eq_predicates.push(WherePredicate::EqPredicate { lhs, rhs, bound_params });\n+            }\n+        }\n+    }\n+\n     let mut params = ThinVec::with_capacity(gens.params.len());\n+    // In this loop, we gather the generic parameters (`<'a, B: 'a>`) and check if they have\n+    // bounds in the where predicates. If so, we move their bounds into the where predicates\n+    // while also preventing duplicates.\n     for p in gens.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n-        let p = clean_generic_param(cx, Some(gens), p);\n+        let mut p = clean_generic_param(cx, Some(gens), p);\n+        match &mut p.kind {\n+            GenericParamDefKind::Lifetime { ref mut outlives } => {\n+                if let Some(region_pred) = region_predicates.get_mut(&Lifetime(p.name)) {\n+                    // We merge bounds in the `where` clause.\n+                    for outlive in outlives.drain(..) {\n+                        let outlive = GenericBound::Outlives(outlive);\n+                        if !region_pred.contains(&outlive) {\n+                            region_pred.push(outlive);\n+                        }\n+                    }\n+                }\n+            }\n+            GenericParamDefKind::Type { bounds, synthetic: false, .. } => {\n+                if let Some(bound_pred) = bound_predicates.get_mut(&Type::Generic(p.name)) {\n+                    // We merge bounds in the `where` clause.\n+                    for bound in bounds.drain(..) {\n+                        if !bound_pred.0.contains(&bound) {\n+                            bound_pred.0.push(bound);\n+                        }\n+                    }\n+                }\n+            }\n+            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                // nothing to do here.\n+            }\n+        }\n         params.push(p);\n     }\n     params.extend(impl_trait_params);\n \n-    let mut generics = Generics {\n+    Generics {\n         params,\n-        where_predicates: gens\n-            .predicates\n-            .iter()\n-            .filter_map(|x| clean_where_predicate(x, cx))\n+        where_predicates: bound_predicates\n+            .into_iter()\n+            .map(|(ty, (bounds, bound_params))| WherePredicate::BoundPredicate {\n+                ty,\n+                bounds,\n+                bound_params,\n+            })\n+            .chain(\n+                region_predicates\n+                    .into_iter()\n+                    .map(|(lifetime, bounds)| WherePredicate::RegionPredicate { lifetime, bounds }),\n+            )\n+            .chain(eq_predicates.into_iter())\n             .collect(),\n-    };\n-\n-    // Some duplicates are generated for ?Sized bounds between type params and where\n-    // predicates. The point in here is to move the bounds definitions from type params\n-    // to where predicates when such cases occur.\n-    for where_pred in &mut generics.where_predicates {\n-        match *where_pred {\n-            WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds, .. } => {\n-                if bounds.is_empty() {\n-                    for param in &mut generics.params {\n-                        match param.kind {\n-                            GenericParamDefKind::Lifetime { .. } => {}\n-                            GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n-                                if &param.name == name {\n-                                    mem::swap(bounds, ty_bounds);\n-                                    break;\n-                                }\n-                            }\n-                            GenericParamDefKind::Const { .. } => {}\n-                        }\n-                    }\n-                }\n-            }\n-            _ => continue,\n-        }\n     }\n-    generics\n }\n \n fn clean_ty_generics<'tcx>("}, {"sha": "f44797fe55f179245c31eb6a9755846af7ce8749", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -908,6 +908,7 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \n .popover {\n \tposition: absolute;\n+\ttop: 100%;\n \tright: 0;\n \tz-index: 2;\n \tdisplay: block;\n@@ -1357,22 +1358,24 @@ a.test-arrow:hover {\n }\n #settings-menu, #help-button {\n \tmargin-left: 4px;\n-\toutline: none;\n+\tdisplay: flex;\n }\n \n #settings-menu > a, #help-button > a, #copy-path {\n \twidth: 33px;\n-\tline-height: 1.5;\n }\n \n #settings-menu > a, #help-button > a {\n-\tpadding: 5px;\n-\theight: 100%;\n-\tdisplay: block;\n+\tdisplay: flex;\n+\talign-items: center;\n+\tjustify-content: center;\n \tbackground-color: var(--button-background-color);\n \tborder: 1px solid var(--border-color);\n \tborder-radius: 2px;\n \tcolor: var(--settings-button-color);\n+\t/* Rare exception to specifying font sizes in rem. Since this is acting\n+\t   as an icon, it's okay to specify their sizes in pixels. */\n+\tfont-size: 20px;\n }\n \n #settings-menu > a:hover, #settings-menu > a:focus,\n@@ -1408,14 +1411,6 @@ a.test-arrow:hover {\n \tanimation: rotating 2s linear infinite;\n }\n \n-#help-button > a {\n-\ttext-align: center;\n-\t/* Rare exception to specifying font sizes in rem. Since this is acting\n-\t   as an icon, it's okay to specify their sizes in pixels. */\n-\tfont-size: 20px;\n-\tpadding-top: 2px;\n-}\n-\n kbd {\n \tdisplay: inline-block;\n \tpadding: 3px 5px;\n@@ -1590,17 +1585,11 @@ details.rustdoc-toggle[open] > summary.hideme > span {\n \tdisplay: none;\n }\n \n-details.rustdoc-toggle[open] > summary::before,\n-details.rustdoc-toggle[open] > summary.hideme::before {\n+details.rustdoc-toggle[open] > summary::before {\n \tbackground: url(\"toggle-minus-31bbd6e4c77f5c96.svg\") no-repeat top left;\n-\twidth: 16px;\n-\theight: 16px;\n-\tdisplay: inline-block;\n-\tcontent: \"\";\n }\n \n-details.rustdoc-toggle[open] > summary::after,\n-details.rustdoc-toggle[open] > summary.hideme::after {\n+details.rustdoc-toggle[open] > summary::after {\n \tcontent: \"Collapse\";\n }\n \n@@ -1658,10 +1647,6 @@ in storage.js\n \t\tcontent: \"Since \";\n \t}\n \n-\t#copy-path {\n-\t\tdisplay: none;\n-\t}\n-\n \t/* Hide the logo and item name from the sidebar. Those are displayed\n \t   in the mobile-topbar instead. */\n \t.sidebar .sidebar-logo,\n@@ -1795,8 +1780,8 @@ in storage.js\n \t\tborder-bottom: 1px solid;\n \t}\n \n-\t/* We don't display the help button on mobile devices. */\n-\t#help-button {\n+\t/* We don't display these buttons on mobile devices. */\n+\t#copy-path, #help-button {\n \t\tdisplay: none;\n \t}\n "}, {"sha": "1196f944faad2d26981b806023fe739cfaacc953", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 52, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -99,53 +99,6 @@ impl<'tcx> JsonRenderer<'tcx> {\n             })\n             .unwrap_or_default()\n     }\n-\n-    fn get_trait_items(&mut self) -> Vec<(types::Id, types::Item)> {\n-        debug!(\"Adding foreign trait items\");\n-        Rc::clone(&self.cache)\n-            .traits\n-            .iter()\n-            .filter_map(|(&id, trait_item)| {\n-                // only need to synthesize items for external traits\n-                if !id.is_local() {\n-                    for item in &trait_item.items {\n-                        trace!(\"Adding subitem to {id:?}: {:?}\", item.item_id);\n-                        self.item(item.clone()).unwrap();\n-                    }\n-                    let item_id = from_item_id(id.into(), self.tcx);\n-                    Some((\n-                        item_id.clone(),\n-                        types::Item {\n-                            id: item_id,\n-                            crate_id: id.krate.as_u32(),\n-                            name: self\n-                                .cache\n-                                .paths\n-                                .get(&id)\n-                                .unwrap_or_else(|| {\n-                                    self.cache\n-                                        .external_paths\n-                                        .get(&id)\n-                                        .expect(\"Trait should either be in local or external paths\")\n-                                })\n-                                .0\n-                                .last()\n-                                .map(|s| s.to_string()),\n-                            visibility: types::Visibility::Public,\n-                            inner: types::ItemEnum::Trait(trait_item.clone().into_tcx(self.tcx)),\n-                            span: None,\n-                            docs: Default::default(),\n-                            links: Default::default(),\n-                            attrs: Default::default(),\n-                            deprecation: Default::default(),\n-                        },\n-                    ))\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect()\n-    }\n }\n \n impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n@@ -276,11 +229,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n \n         let e = ExternalCrate { crate_num: LOCAL_CRATE };\n \n-        // FIXME(adotinthevoid): Remove this, as it's not consistent with not\n-        // inlining foreign items.\n-        let foreign_trait_items = self.get_trait_items();\n-        let mut index = (*self.index).clone().into_inner();\n-        index.extend(foreign_trait_items);\n+        let index = (*self.index).clone().into_inner();\n \n         debug!(\"Constructing Output\");\n         // This needs to be the default HashMap for compatibility with the public interface for"}, {"sha": "6d34f484754c7a6c2c60d85b3ac9c0ca1e740b5e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -781,10 +781,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n         let sess = compiler.session();\n \n         if sess.opts.describe_lints {\n-            let mut lint_store = rustc_lint::new_lint_store(\n-                sess.opts.unstable_opts.no_interleave_lints,\n-                sess.enable_internal_lints(),\n-            );\n+            let mut lint_store = rustc_lint::new_lint_store(sess.enable_internal_lints());\n             let registered_lints = if let Some(register_lints) = compiler.register_lints() {\n                 register_lints(sess, &mut lint_store);\n                 true"}, {"sha": "7ff3ccef945c2915c0b12833b0a69c70093187ea", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=faec28970f86f52ca37e0e8cec0a447ba2f1393b", "patch": "@@ -1,110 +0,0 @@\n-//! Detects links that are not linkified, e.g., in Markdown such as `Go to https://example.com/.`\n-//! Suggests wrapping the link with angle brackets: `Go to <https://example.com/>.` to linkify it.\n-use super::Pass;\n-use crate::clean::*;\n-use crate::core::DocContext;\n-use crate::html::markdown::main_body_opts;\n-use crate::visit::DocVisitor;\n-use core::ops::Range;\n-use pulldown_cmark::{Event, Parser, Tag};\n-use regex::Regex;\n-use rustc_errors::Applicability;\n-use std::mem;\n-use std::sync::LazyLock;\n-\n-pub(crate) const CHECK_BARE_URLS: Pass = Pass {\n-    name: \"check-bare-urls\",\n-    run: check_bare_urls,\n-    description: \"detects URLs that are not hyperlinks\",\n-};\n-\n-static URL_REGEX: LazyLock<Regex> = LazyLock::new(|| {\n-    Regex::new(concat!(\n-        r\"https?://\",                          // url scheme\n-        r\"([-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.)+\", // one or more subdomains\n-        r\"[a-zA-Z]{2,63}\",                     // root domain\n-        r\"\\b([-a-zA-Z0-9@:%_\\+.~#?&/=]*)\"      // optional query or url fragments\n-    ))\n-    .expect(\"failed to build regex\")\n-});\n-\n-struct BareUrlsLinter<'a, 'tcx> {\n-    cx: &'a mut DocContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> BareUrlsLinter<'a, 'tcx> {\n-    fn find_raw_urls(\n-        &self,\n-        text: &str,\n-        range: Range<usize>,\n-        f: &impl Fn(&DocContext<'_>, &str, &str, Range<usize>),\n-    ) {\n-        trace!(\"looking for raw urls in {}\", text);\n-        // For now, we only check \"full\" URLs (meaning, starting with \"http://\" or \"https://\").\n-        for match_ in URL_REGEX.find_iter(text) {\n-            let url = match_.as_str();\n-            let url_range = match_.range();\n-            f(\n-                self.cx,\n-                \"this URL is not a hyperlink\",\n-                url,\n-                Range { start: range.start + url_range.start, end: range.start + url_range.end },\n-            );\n-        }\n-    }\n-}\n-\n-pub(crate) fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    BareUrlsLinter { cx }.visit_crate(&krate);\n-    krate\n-}\n-\n-impl<'a, 'tcx> DocVisitor for BareUrlsLinter<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-        let Some(hir_id) = DocContext::as_local_hir_id(self.cx.tcx, item.item_id)\n-        else {\n-            // If non-local, no need to check anything.\n-            return;\n-        };\n-        let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n-        if !dox.is_empty() {\n-            let report_diag = |cx: &DocContext<'_>, msg: &str, url: &str, range: Range<usize>| {\n-                let sp = super::source_span_for_markdown_range(cx.tcx, &dox, &range, &item.attrs)\n-                    .unwrap_or_else(|| item.attr_span(cx.tcx));\n-                cx.tcx.struct_span_lint_hir(crate::lint::BARE_URLS, hir_id, sp, msg, |lint| {\n-                    lint.note(\"bare URLs are not automatically turned into clickable links\")\n-                        .span_suggestion(\n-                            sp,\n-                            \"use an automatic link instead\",\n-                            format!(\"<{}>\", url),\n-                            Applicability::MachineApplicable,\n-                        )\n-                });\n-            };\n-\n-            let mut p = Parser::new_ext(&dox, main_body_opts()).into_offset_iter();\n-\n-            while let Some((event, range)) = p.next() {\n-                match event {\n-                    Event::Text(s) => self.find_raw_urls(&s, range, &report_diag),\n-                    // We don't want to check the text inside code blocks or links.\n-                    Event::Start(tag @ (Tag::CodeBlock(_) | Tag::Link(..))) => {\n-                        while let Some((event, _)) = p.next() {\n-                            match event {\n-                                Event::End(end)\n-                                    if mem::discriminant(&end) == mem::discriminant(&tag) =>\n-                                {\n-                                    break;\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        self.visit_item_recur(item)\n-    }\n-}"}, {"sha": "2e651b5387419fa2441abbda60e515a66b00e4c1", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=faec28970f86f52ca37e0e8cec0a447ba2f1393b", "patch": "@@ -1,209 +0,0 @@\n-//! Validates syntax inside Rust code blocks (\\`\\`\\`rust).\n-use rustc_data_structures::sync::{Lock, Lrc};\n-use rustc_errors::{\n-    emitter::Emitter,\n-    translation::{to_fluent_args, Translate},\n-    Applicability, Diagnostic, Handler, LazyFallbackBundle,\n-};\n-use rustc_parse::parse_stream_from_source_str;\n-use rustc_session::parse::ParseSess;\n-use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n-use rustc_span::source_map::{FilePathMapping, SourceMap};\n-use rustc_span::{FileName, InnerSpan, DUMMY_SP};\n-\n-use crate::clean;\n-use crate::core::DocContext;\n-use crate::html::markdown::{self, RustCodeBlock};\n-use crate::passes::Pass;\n-use crate::visit::DocVisitor;\n-\n-pub(crate) const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n-    name: \"check-code-block-syntax\",\n-    run: check_code_block_syntax,\n-    description: \"validates syntax inside Rust code blocks\",\n-};\n-\n-pub(crate) fn check_code_block_syntax(\n-    krate: clean::Crate,\n-    cx: &mut DocContext<'_>,\n-) -> clean::Crate {\n-    SyntaxChecker { cx }.visit_crate(&krate);\n-    krate\n-}\n-\n-struct SyntaxChecker<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n-    fn check_rust_syntax(&self, item: &clean::Item, dox: &str, code_block: RustCodeBlock) {\n-        let buffer = Lrc::new(Lock::new(Buffer::default()));\n-        let fallback_bundle =\n-            rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n-        let emitter = BufferEmitter { buffer: Lrc::clone(&buffer), fallback_bundle };\n-\n-        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let handler = Handler::with_emitter(false, None, Box::new(emitter));\n-        let source = dox[code_block.code].to_owned();\n-        let sess = ParseSess::with_span_handler(handler, sm);\n-\n-        let edition = code_block.lang_string.edition.unwrap_or_else(|| self.cx.tcx.sess.edition());\n-        let expn_data = ExpnData::default(\n-            ExpnKind::AstPass(AstPass::TestHarness),\n-            DUMMY_SP,\n-            edition,\n-            None,\n-            None,\n-        );\n-        let expn_id =\n-            self.cx.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n-        let span = DUMMY_SP.fresh_expansion(expn_id);\n-\n-        let is_empty = rustc_driver::catch_fatal_errors(|| {\n-            parse_stream_from_source_str(\n-                FileName::Custom(String::from(\"doctest\")),\n-                source,\n-                &sess,\n-                Some(span),\n-            )\n-            .is_empty()\n-        })\n-        .unwrap_or(false);\n-        let buffer = buffer.borrow();\n-\n-        if !buffer.has_errors && !is_empty {\n-            // No errors in a non-empty program.\n-            return;\n-        }\n-\n-        let Some(local_id) = item.item_id.as_def_id().and_then(|x| x.as_local())\n-        else {\n-            // We don't need to check the syntax for other crates so returning\n-            // without doing anything should not be a problem.\n-            return;\n-        };\n-\n-        let hir_id = self.cx.tcx.hir().local_def_id_to_hir_id(local_id);\n-        let empty_block = code_block.lang_string == Default::default() && code_block.is_fenced;\n-        let is_ignore = code_block.lang_string.ignore != markdown::Ignore::None;\n-\n-        // The span and whether it is precise or not.\n-        let (sp, precise_span) = match super::source_span_for_markdown_range(\n-            self.cx.tcx,\n-            dox,\n-            &code_block.range,\n-            &item.attrs,\n-        ) {\n-            Some(sp) => (sp, true),\n-            None => (item.attr_span(self.cx.tcx), false),\n-        };\n-\n-        let msg = if buffer.has_errors {\n-            \"could not parse code block as Rust code\"\n-        } else {\n-            \"Rust code block is empty\"\n-        };\n-\n-        // Finally build and emit the completed diagnostic.\n-        // All points of divergence have been handled earlier so this can be\n-        // done the same way whether the span is precise or not.\n-        self.cx.tcx.struct_span_lint_hir(\n-            crate::lint::INVALID_RUST_CODEBLOCKS,\n-            hir_id,\n-            sp,\n-            msg,\n-            |lint| {\n-                let explanation = if is_ignore {\n-                    \"`ignore` code blocks require valid Rust code for syntax highlighting; \\\n-                    mark blocks that do not contain Rust code as text\"\n-                } else {\n-                    \"mark blocks that do not contain Rust code as text\"\n-                };\n-\n-                if precise_span {\n-                    if is_ignore {\n-                        // giving an accurate suggestion is hard because `ignore` might not have come first in the list.\n-                        // just give a `help` instead.\n-                        lint.span_help(\n-                            sp.from_inner(InnerSpan::new(0, 3)),\n-                            &format!(\"{}: ```text\", explanation),\n-                        );\n-                    } else if empty_block {\n-                        lint.span_suggestion(\n-                            sp.from_inner(InnerSpan::new(0, 3)).shrink_to_hi(),\n-                            explanation,\n-                            \"text\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                } else if empty_block || is_ignore {\n-                    lint.help(&format!(\"{}: ```text\", explanation));\n-                }\n-\n-                // FIXME(#67563): Provide more context for these errors by displaying the spans inline.\n-                for message in buffer.messages.iter() {\n-                    lint.note(message);\n-                }\n-\n-                lint\n-            },\n-        );\n-    }\n-}\n-\n-impl<'a, 'tcx> DocVisitor for SyntaxChecker<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &clean::Item) {\n-        if let Some(dox) = &item.attrs.collapsed_doc_value() {\n-            let sp = item.attr_span(self.cx.tcx);\n-            let extra = crate::html::markdown::ExtraInfo::new_did(\n-                self.cx.tcx,\n-                item.item_id.expect_def_id(),\n-                sp,\n-            );\n-            for code_block in markdown::rust_code_blocks(dox, &extra) {\n-                self.check_rust_syntax(item, dox, code_block);\n-            }\n-        }\n-\n-        self.visit_item_recur(item)\n-    }\n-}\n-\n-#[derive(Default)]\n-struct Buffer {\n-    messages: Vec<String>,\n-    has_errors: bool,\n-}\n-\n-struct BufferEmitter {\n-    buffer: Lrc<Lock<Buffer>>,\n-    fallback_bundle: LazyFallbackBundle,\n-}\n-\n-impl Translate for BufferEmitter {\n-    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n-        None\n-    }\n-\n-    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n-        &**self.fallback_bundle\n-    }\n-}\n-\n-impl Emitter for BufferEmitter {\n-    fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        let mut buffer = self.buffer.borrow_mut();\n-\n-        let fluent_args = to_fluent_args(diag.args());\n-        let translated_main_message = self.translate_message(&diag.message[0].0, &fluent_args);\n-\n-        buffer.messages.push(format!(\"error from rustc: {}\", translated_main_message));\n-        if diag.is_error() {\n-            buffer.has_errors = true;\n-        }\n-    }\n-\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-}"}, {"sha": "97031c4f028f45eb1bafc4cfe5d7b34c7eb7de34", "filename": "src/librustdoc/passes/lint.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,33 @@\n+//! Runs several rustdoc lints, consolidating them into a single pass for\n+//! efficiency and simplicity.\n+\n+mod bare_urls;\n+mod check_code_block_syntax;\n+mod html_tags;\n+\n+use super::Pass;\n+use crate::clean::*;\n+use crate::core::DocContext;\n+use crate::visit::DocVisitor;\n+\n+pub(crate) const RUN_LINTS: Pass =\n+    Pass { name: \"run-lints\", run: run_lints, description: \"runs some of rustdoc's lints\" };\n+\n+struct Linter<'a, 'tcx> {\n+    cx: &'a mut DocContext<'tcx>,\n+}\n+\n+pub(crate) fn run_lints(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    Linter { cx }.visit_crate(&krate);\n+    krate\n+}\n+\n+impl<'a, 'tcx> DocVisitor for Linter<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n+        bare_urls::visit_item(self.cx, item);\n+        check_code_block_syntax::visit_item(self.cx, item);\n+        html_tags::visit_item(self.cx, item);\n+\n+        self.visit_item_recur(item)\n+    }\n+}"}, {"sha": "423230cfe381e186ba00dc80f40b6aa41525fff6", "filename": "src/librustdoc/passes/lint/bare_urls.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Flint%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Flint%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fbare_urls.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,89 @@\n+//! Detects links that are not linkified, e.g., in Markdown such as `Go to https://example.com/.`\n+//! Suggests wrapping the link with angle brackets: `Go to <https://example.com/>.` to linkify it.\n+\n+use crate::clean::*;\n+use crate::core::DocContext;\n+use crate::html::markdown::main_body_opts;\n+use crate::passes::source_span_for_markdown_range;\n+use core::ops::Range;\n+use pulldown_cmark::{Event, Parser, Tag};\n+use regex::Regex;\n+use rustc_errors::Applicability;\n+use std::mem;\n+use std::sync::LazyLock;\n+\n+pub(super) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n+    let Some(hir_id) = DocContext::as_local_hir_id(cx.tcx, item.item_id)\n+        else {\n+            // If non-local, no need to check anything.\n+            return;\n+        };\n+    let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n+    if !dox.is_empty() {\n+        let report_diag = |cx: &DocContext<'_>, msg: &str, url: &str, range: Range<usize>| {\n+            let sp = source_span_for_markdown_range(cx.tcx, &dox, &range, &item.attrs)\n+                .unwrap_or_else(|| item.attr_span(cx.tcx));\n+            cx.tcx.struct_span_lint_hir(crate::lint::BARE_URLS, hir_id, sp, msg, |lint| {\n+                lint.note(\"bare URLs are not automatically turned into clickable links\")\n+                    .span_suggestion(\n+                        sp,\n+                        \"use an automatic link instead\",\n+                        format!(\"<{}>\", url),\n+                        Applicability::MachineApplicable,\n+                    )\n+            });\n+        };\n+\n+        let mut p = Parser::new_ext(&dox, main_body_opts()).into_offset_iter();\n+\n+        while let Some((event, range)) = p.next() {\n+            match event {\n+                Event::Text(s) => find_raw_urls(cx, &s, range, &report_diag),\n+                // We don't want to check the text inside code blocks or links.\n+                Event::Start(tag @ (Tag::CodeBlock(_) | Tag::Link(..))) => {\n+                    while let Some((event, _)) = p.next() {\n+                        match event {\n+                            Event::End(end)\n+                                if mem::discriminant(&end) == mem::discriminant(&tag) =>\n+                            {\n+                                break;\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}\n+\n+static URL_REGEX: LazyLock<Regex> = LazyLock::new(|| {\n+    Regex::new(concat!(\n+        r\"https?://\",                          // url scheme\n+        r\"([-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.)+\", // one or more subdomains\n+        r\"[a-zA-Z]{2,63}\",                     // root domain\n+        r\"\\b([-a-zA-Z0-9@:%_\\+.~#?&/=]*)\"      // optional query or url fragments\n+    ))\n+    .expect(\"failed to build regex\")\n+});\n+\n+fn find_raw_urls(\n+    cx: &DocContext<'_>,\n+    text: &str,\n+    range: Range<usize>,\n+    f: &impl Fn(&DocContext<'_>, &str, &str, Range<usize>),\n+) {\n+    trace!(\"looking for raw urls in {}\", text);\n+    // For now, we only check \"full\" URLs (meaning, starting with \"http://\" or \"https://\").\n+    for match_ in URL_REGEX.find_iter(text) {\n+        let url = match_.as_str();\n+        let url_range = match_.range();\n+        f(\n+            cx,\n+            \"this URL is not a hyperlink\",\n+            url,\n+            Range { start: range.start + url_range.start, end: range.start + url_range.end },\n+        );\n+    }\n+}"}, {"sha": "5aa4f238b2d149e582f79e7c613870fda2ff51de", "filename": "src/librustdoc/passes/lint/check_code_block_syntax.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,170 @@\n+//! Validates syntax inside Rust code blocks (\\`\\`\\`rust).\n+use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_errors::{\n+    emitter::Emitter,\n+    translation::{to_fluent_args, Translate},\n+    Applicability, Diagnostic, Handler, LazyFallbackBundle,\n+};\n+use rustc_parse::parse_stream_from_source_str;\n+use rustc_session::parse::ParseSess;\n+use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n+use rustc_span::source_map::{FilePathMapping, SourceMap};\n+use rustc_span::{FileName, InnerSpan, DUMMY_SP};\n+\n+use crate::clean;\n+use crate::core::DocContext;\n+use crate::html::markdown::{self, RustCodeBlock};\n+use crate::passes::source_span_for_markdown_range;\n+\n+pub(crate) fn visit_item(cx: &DocContext<'_>, item: &clean::Item) {\n+    if let Some(dox) = &item.attrs.collapsed_doc_value() {\n+        let sp = item.attr_span(cx.tcx);\n+        let extra =\n+            crate::html::markdown::ExtraInfo::new_did(cx.tcx, item.item_id.expect_def_id(), sp);\n+        for code_block in markdown::rust_code_blocks(dox, &extra) {\n+            check_rust_syntax(cx, item, dox, code_block);\n+        }\n+    }\n+}\n+\n+fn check_rust_syntax(\n+    cx: &DocContext<'_>,\n+    item: &clean::Item,\n+    dox: &str,\n+    code_block: RustCodeBlock,\n+) {\n+    let buffer = Lrc::new(Lock::new(Buffer::default()));\n+    let fallback_bundle =\n+        rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n+    let emitter = BufferEmitter { buffer: Lrc::clone(&buffer), fallback_bundle };\n+\n+    let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+    let handler = Handler::with_emitter(false, None, Box::new(emitter));\n+    let source = dox[code_block.code].to_owned();\n+    let sess = ParseSess::with_span_handler(handler, sm);\n+\n+    let edition = code_block.lang_string.edition.unwrap_or_else(|| cx.tcx.sess.edition());\n+    let expn_data =\n+        ExpnData::default(ExpnKind::AstPass(AstPass::TestHarness), DUMMY_SP, edition, None, None);\n+    let expn_id = cx.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n+    let span = DUMMY_SP.fresh_expansion(expn_id);\n+\n+    let is_empty = rustc_driver::catch_fatal_errors(|| {\n+        parse_stream_from_source_str(\n+            FileName::Custom(String::from(\"doctest\")),\n+            source,\n+            &sess,\n+            Some(span),\n+        )\n+        .is_empty()\n+    })\n+    .unwrap_or(false);\n+    let buffer = buffer.borrow();\n+\n+    if !buffer.has_errors && !is_empty {\n+        // No errors in a non-empty program.\n+        return;\n+    }\n+\n+    let Some(local_id) = item.item_id.as_def_id().and_then(|x| x.as_local())\n+        else {\n+            // We don't need to check the syntax for other crates so returning\n+            // without doing anything should not be a problem.\n+            return;\n+        };\n+\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n+    let empty_block = code_block.lang_string == Default::default() && code_block.is_fenced;\n+    let is_ignore = code_block.lang_string.ignore != markdown::Ignore::None;\n+\n+    // The span and whether it is precise or not.\n+    let (sp, precise_span) =\n+        match source_span_for_markdown_range(cx.tcx, dox, &code_block.range, &item.attrs) {\n+            Some(sp) => (sp, true),\n+            None => (item.attr_span(cx.tcx), false),\n+        };\n+\n+    let msg = if buffer.has_errors {\n+        \"could not parse code block as Rust code\"\n+    } else {\n+        \"Rust code block is empty\"\n+    };\n+\n+    // Finally build and emit the completed diagnostic.\n+    // All points of divergence have been handled earlier so this can be\n+    // done the same way whether the span is precise or not.\n+    cx.tcx.struct_span_lint_hir(crate::lint::INVALID_RUST_CODEBLOCKS, hir_id, sp, msg, |lint| {\n+        let explanation = if is_ignore {\n+            \"`ignore` code blocks require valid Rust code for syntax highlighting; \\\n+                    mark blocks that do not contain Rust code as text\"\n+        } else {\n+            \"mark blocks that do not contain Rust code as text\"\n+        };\n+\n+        if precise_span {\n+            if is_ignore {\n+                // giving an accurate suggestion is hard because `ignore` might not have come first in the list.\n+                // just give a `help` instead.\n+                lint.span_help(\n+                    sp.from_inner(InnerSpan::new(0, 3)),\n+                    &format!(\"{}: ```text\", explanation),\n+                );\n+            } else if empty_block {\n+                lint.span_suggestion(\n+                    sp.from_inner(InnerSpan::new(0, 3)).shrink_to_hi(),\n+                    explanation,\n+                    \"text\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        } else if empty_block || is_ignore {\n+            lint.help(&format!(\"{}: ```text\", explanation));\n+        }\n+\n+        // FIXME(#67563): Provide more context for these errors by displaying the spans inline.\n+        for message in buffer.messages.iter() {\n+            lint.note(message);\n+        }\n+\n+        lint\n+    });\n+}\n+\n+#[derive(Default)]\n+struct Buffer {\n+    messages: Vec<String>,\n+    has_errors: bool,\n+}\n+\n+struct BufferEmitter {\n+    buffer: Lrc<Lock<Buffer>>,\n+    fallback_bundle: LazyFallbackBundle,\n+}\n+\n+impl Translate for BufferEmitter {\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+        &**self.fallback_bundle\n+    }\n+}\n+\n+impl Emitter for BufferEmitter {\n+    fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let mut buffer = self.buffer.borrow_mut();\n+\n+        let fluent_args = to_fluent_args(diag.args());\n+        let translated_main_message = self.translate_message(&diag.message[0].0, &fluent_args);\n+\n+        buffer.messages.push(format!(\"error from rustc: {}\", translated_main_message));\n+        if diag.is_error() {\n+            buffer.has_errors = true;\n+        }\n+    }\n+\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n+}"}, {"sha": "070c0aab5868b548f33d7e47d936f00b6c3fc31f", "filename": "src/librustdoc/passes/lint/html_tags.rs", "status": "renamed", "additions": 143, "deletions": 166, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,30 +1,159 @@\n //! Detects invalid HTML (like an unclosed `<span>`) in doc comments.\n-use super::Pass;\n use crate::clean::*;\n use crate::core::DocContext;\n use crate::html::markdown::main_body_opts;\n-use crate::visit::DocVisitor;\n+use crate::passes::source_span_for_markdown_range;\n \n use pulldown_cmark::{BrokenLink, Event, LinkType, Parser, Tag};\n \n use std::iter::Peekable;\n use std::ops::Range;\n use std::str::CharIndices;\n \n-pub(crate) const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n-    name: \"check-invalid-html-tags\",\n-    run: check_invalid_html_tags,\n-    description: \"detects invalid HTML tags in doc comments\",\n-};\n+pub(crate) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n+    let tcx = cx.tcx;\n+    let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n+    // If non-local, no need to check anything.\n+    else { return };\n+    let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n+    if !dox.is_empty() {\n+        let report_diag = |msg: &str, range: &Range<usize>, is_open_tag: bool| {\n+            let sp = match source_span_for_markdown_range(tcx, &dox, range, &item.attrs) {\n+                Some(sp) => sp,\n+                None => item.attr_span(tcx),\n+            };\n+            tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, msg, |lint| {\n+                use rustc_lint_defs::Applicability;\n+                // If a tag looks like `<this>`, it might actually be a generic.\n+                // We don't try to detect stuff `<like, this>` because that's not valid HTML,\n+                // and we don't try to detect stuff `<like this>` because that's not valid Rust.\n+                let mut generics_end = range.end;\n+                if let Some(Some(mut generics_start)) = (is_open_tag\n+                    && dox[..generics_end].ends_with('>'))\n+                .then(|| extract_path_backwards(&dox, range.start))\n+                {\n+                    while generics_start != 0\n+                        && generics_end < dox.len()\n+                        && dox.as_bytes()[generics_start - 1] == b'<'\n+                        && dox.as_bytes()[generics_end] == b'>'\n+                    {\n+                        generics_end += 1;\n+                        generics_start -= 1;\n+                        if let Some(new_start) = extract_path_backwards(&dox, generics_start) {\n+                            generics_start = new_start;\n+                        }\n+                        if let Some(new_end) = extract_path_forward(&dox, generics_end) {\n+                            generics_end = new_end;\n+                        }\n+                    }\n+                    if let Some(new_end) = extract_path_forward(&dox, generics_end) {\n+                        generics_end = new_end;\n+                    }\n+                    let generics_sp = match source_span_for_markdown_range(\n+                        tcx,\n+                        &dox,\n+                        &(generics_start..generics_end),\n+                        &item.attrs,\n+                    ) {\n+                        Some(sp) => sp,\n+                        None => item.attr_span(tcx),\n+                    };\n+                    // Sometimes, we only extract part of a path. For example, consider this:\n+                    //\n+                    //     <[u32] as IntoIter<u32>>::Item\n+                    //                       ^^^^^ unclosed HTML tag `u32`\n+                    //\n+                    // We don't have any code for parsing fully-qualified trait paths.\n+                    // In theory, we could add it, but doing it correctly would require\n+                    // parsing the entire path grammar, which is problematic because of\n+                    // overlap between the path grammar and Markdown.\n+                    //\n+                    // The example above shows that ambiguity. Is `[u32]` intended to be an\n+                    // intra-doc link to the u32 primitive, or is it intended to be a slice?\n+                    //\n+                    // If the below conditional were removed, we would suggest this, which is\n+                    // not what the user probably wants.\n+                    //\n+                    //     <[u32] as `IntoIter<u32>`>::Item\n+                    //\n+                    // We know that the user actually wants to wrap the whole thing in a code\n+                    // block, but the only reason we know that is because `u32` does not, in\n+                    // fact, implement IntoIter. If the example looks like this:\n+                    //\n+                    //     <[Vec<i32>] as IntoIter<i32>::Item\n+                    //\n+                    // The ideal fix would be significantly different.\n+                    if (generics_start > 0 && dox.as_bytes()[generics_start - 1] == b'<')\n+                        || (generics_end < dox.len() && dox.as_bytes()[generics_end] == b'>')\n+                    {\n+                        return lint;\n+                    }\n+                    // multipart form is chosen here because ``Vec<i32>`` would be confusing.\n+                    lint.multipart_suggestion(\n+                        \"try marking as source code\",\n+                        vec![\n+                            (generics_sp.shrink_to_lo(), String::from(\"`\")),\n+                            (generics_sp.shrink_to_hi(), String::from(\"`\")),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n \n-struct InvalidHtmlTagsLinter<'a, 'tcx> {\n-    cx: &'a mut DocContext<'tcx>,\n-}\n+                lint\n+            });\n+        };\n+\n+        let mut tags = Vec::new();\n+        let mut is_in_comment = None;\n+        let mut in_code_block = false;\n+\n+        let link_names = item.link_names(&cx.cache);\n \n-pub(crate) fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    let mut coll = InvalidHtmlTagsLinter { cx };\n-    coll.visit_crate(&krate);\n-    krate\n+        let mut replacer = |broken_link: BrokenLink<'_>| {\n+            if let Some(link) =\n+                link_names.iter().find(|link| *link.original_text == *broken_link.reference)\n+            {\n+                Some((link.href.as_str().into(), link.new_text.as_str().into()))\n+            } else if matches!(\n+                &broken_link.link_type,\n+                LinkType::Reference | LinkType::ReferenceUnknown\n+            ) {\n+                // If the link is shaped [like][this], suppress any broken HTML in the [this] part.\n+                // The `broken_intra_doc_links` will report typos in there anyway.\n+                Some((\n+                    broken_link.reference.to_string().into(),\n+                    broken_link.reference.to_string().into(),\n+                ))\n+            } else {\n+                None\n+            }\n+        };\n+\n+        let p = Parser::new_with_broken_link_callback(&dox, main_body_opts(), Some(&mut replacer))\n+            .into_offset_iter();\n+\n+        for (event, range) in p {\n+            match event {\n+                Event::Start(Tag::CodeBlock(_)) => in_code_block = true,\n+                Event::Html(text) if !in_code_block => {\n+                    extract_tags(&mut tags, &text, range, &mut is_in_comment, &report_diag)\n+                }\n+                Event::End(Tag::CodeBlock(_)) => in_code_block = false,\n+                _ => {}\n+            }\n+        }\n+\n+        for (tag, range) in tags.iter().filter(|(t, _)| {\n+            let t = t.to_lowercase();\n+            !ALLOWED_UNCLOSED.contains(&t.as_str())\n+        }) {\n+            report_diag(&format!(\"unclosed HTML tag `{}`\", tag), range, true);\n+        }\n+\n+        if let Some(range) = is_in_comment {\n+            report_diag(\"Unclosed HTML comment\", &range, false);\n+        }\n+    }\n }\n \n const ALLOWED_UNCLOSED: &[&str] = &[\n@@ -276,155 +405,3 @@ fn extract_tags(\n         }\n     }\n }\n-\n-impl<'a, 'tcx> DocVisitor for InvalidHtmlTagsLinter<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-        let tcx = self.cx.tcx;\n-        let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n-        // If non-local, no need to check anything.\n-        else { return };\n-        let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n-        if !dox.is_empty() {\n-            let report_diag = |msg: &str, range: &Range<usize>, is_open_tag: bool| {\n-                let sp = match super::source_span_for_markdown_range(tcx, &dox, range, &item.attrs)\n-                {\n-                    Some(sp) => sp,\n-                    None => item.attr_span(tcx),\n-                };\n-                tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, msg, |lint| {\n-                    use rustc_lint_defs::Applicability;\n-                    // If a tag looks like `<this>`, it might actually be a generic.\n-                    // We don't try to detect stuff `<like, this>` because that's not valid HTML,\n-                    // and we don't try to detect stuff `<like this>` because that's not valid Rust.\n-                    let mut generics_end = range.end;\n-                    if let Some(Some(mut generics_start)) = (is_open_tag\n-                        && dox[..generics_end].ends_with('>'))\n-                    .then(|| extract_path_backwards(&dox, range.start))\n-                    {\n-                        while generics_start != 0\n-                            && generics_end < dox.len()\n-                            && dox.as_bytes()[generics_start - 1] == b'<'\n-                            && dox.as_bytes()[generics_end] == b'>'\n-                        {\n-                            generics_end += 1;\n-                            generics_start -= 1;\n-                            if let Some(new_start) = extract_path_backwards(&dox, generics_start) {\n-                                generics_start = new_start;\n-                            }\n-                            if let Some(new_end) = extract_path_forward(&dox, generics_end) {\n-                                generics_end = new_end;\n-                            }\n-                        }\n-                        if let Some(new_end) = extract_path_forward(&dox, generics_end) {\n-                            generics_end = new_end;\n-                        }\n-                        let generics_sp = match super::source_span_for_markdown_range(\n-                            tcx,\n-                            &dox,\n-                            &(generics_start..generics_end),\n-                            &item.attrs,\n-                        ) {\n-                            Some(sp) => sp,\n-                            None => item.attr_span(tcx),\n-                        };\n-                        // Sometimes, we only extract part of a path. For example, consider this:\n-                        //\n-                        //     <[u32] as IntoIter<u32>>::Item\n-                        //                       ^^^^^ unclosed HTML tag `u32`\n-                        //\n-                        // We don't have any code for parsing fully-qualified trait paths.\n-                        // In theory, we could add it, but doing it correctly would require\n-                        // parsing the entire path grammar, which is problematic because of\n-                        // overlap between the path grammar and Markdown.\n-                        //\n-                        // The example above shows that ambiguity. Is `[u32]` intended to be an\n-                        // intra-doc link to the u32 primitive, or is it intended to be a slice?\n-                        //\n-                        // If the below conditional were removed, we would suggest this, which is\n-                        // not what the user probably wants.\n-                        //\n-                        //     <[u32] as `IntoIter<u32>`>::Item\n-                        //\n-                        // We know that the user actually wants to wrap the whole thing in a code\n-                        // block, but the only reason we know that is because `u32` does not, in\n-                        // fact, implement IntoIter. If the example looks like this:\n-                        //\n-                        //     <[Vec<i32>] as IntoIter<i32>::Item\n-                        //\n-                        // The ideal fix would be significantly different.\n-                        if (generics_start > 0 && dox.as_bytes()[generics_start - 1] == b'<')\n-                            || (generics_end < dox.len() && dox.as_bytes()[generics_end] == b'>')\n-                        {\n-                            return lint;\n-                        }\n-                        // multipart form is chosen here because ``Vec<i32>`` would be confusing.\n-                        lint.multipart_suggestion(\n-                            \"try marking as source code\",\n-                            vec![\n-                                (generics_sp.shrink_to_lo(), String::from(\"`\")),\n-                                (generics_sp.shrink_to_hi(), String::from(\"`\")),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-\n-                    lint\n-                });\n-            };\n-\n-            let mut tags = Vec::new();\n-            let mut is_in_comment = None;\n-            let mut in_code_block = false;\n-\n-            let link_names = item.link_names(&self.cx.cache);\n-\n-            let mut replacer = |broken_link: BrokenLink<'_>| {\n-                if let Some(link) =\n-                    link_names.iter().find(|link| *link.original_text == *broken_link.reference)\n-                {\n-                    Some((link.href.as_str().into(), link.new_text.as_str().into()))\n-                } else if matches!(\n-                    &broken_link.link_type,\n-                    LinkType::Reference | LinkType::ReferenceUnknown\n-                ) {\n-                    // If the link is shaped [like][this], suppress any broken HTML in the [this] part.\n-                    // The `broken_intra_doc_links` will report typos in there anyway.\n-                    Some((\n-                        broken_link.reference.to_string().into(),\n-                        broken_link.reference.to_string().into(),\n-                    ))\n-                } else {\n-                    None\n-                }\n-            };\n-\n-            let p =\n-                Parser::new_with_broken_link_callback(&dox, main_body_opts(), Some(&mut replacer))\n-                    .into_offset_iter();\n-\n-            for (event, range) in p {\n-                match event {\n-                    Event::Start(Tag::CodeBlock(_)) => in_code_block = true,\n-                    Event::Html(text) if !in_code_block => {\n-                        extract_tags(&mut tags, &text, range, &mut is_in_comment, &report_diag)\n-                    }\n-                    Event::End(Tag::CodeBlock(_)) => in_code_block = false,\n-                    _ => {}\n-                }\n-            }\n-\n-            for (tag, range) in tags.iter().filter(|(t, _)| {\n-                let t = t.to_lowercase();\n-                !ALLOWED_UNCLOSED.contains(&t.as_str())\n-            }) {\n-                report_diag(&format!(\"unclosed HTML tag `{}`\", tag), range, true);\n-            }\n-\n-            if let Some(range) = is_in_comment {\n-                report_diag(\"Unclosed HTML comment\", &range, false);\n-            }\n-        }\n-\n-        self.visit_item_recur(item)\n-    }\n-}", "previous_filename": "src/librustdoc/passes/html_tags.rs"}, {"sha": "634e70ec97a0dbad224ca2595f7197d7eb7300f6", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -12,9 +12,6 @@ use crate::core::DocContext;\n mod stripper;\n pub(crate) use stripper::*;\n \n-mod bare_urls;\n-pub(crate) use self::bare_urls::CHECK_BARE_URLS;\n-\n mod strip_hidden;\n pub(crate) use self::strip_hidden::STRIP_HIDDEN;\n \n@@ -36,14 +33,11 @@ pub(crate) use self::check_doc_test_visibility::CHECK_DOC_TEST_VISIBILITY;\n mod collect_trait_impls;\n pub(crate) use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n \n-mod check_code_block_syntax;\n-pub(crate) use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n-\n mod calculate_doc_coverage;\n pub(crate) use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n \n-mod html_tags;\n-pub(crate) use self::html_tags::CHECK_INVALID_HTML_TAGS;\n+mod lint;\n+pub(crate) use self::lint::RUN_LINTS;\n \n /// A single pass over the cleaned documentation.\n ///\n@@ -82,11 +76,9 @@ pub(crate) const PASSES: &[Pass] = &[\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n     COLLECT_INTRA_DOC_LINKS,\n-    CHECK_CODE_BLOCK_SYNTAX,\n     COLLECT_TRAIT_IMPLS,\n     CALCULATE_DOC_COVERAGE,\n-    CHECK_INVALID_HTML_TAGS,\n-    CHECK_BARE_URLS,\n+    RUN_LINTS,\n ];\n \n /// The list of passes run by default.\n@@ -97,10 +89,8 @@ pub(crate) const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),\n     ConditionalPass::new(STRIP_PRIV_IMPORTS, WhenDocumentPrivate),\n     ConditionalPass::always(COLLECT_INTRA_DOC_LINKS),\n-    ConditionalPass::always(CHECK_CODE_BLOCK_SYNTAX),\n-    ConditionalPass::always(CHECK_INVALID_HTML_TAGS),\n     ConditionalPass::always(PROPAGATE_DOC_CFG),\n-    ConditionalPass::always(CHECK_BARE_URLS),\n+    ConditionalPass::always(RUN_LINTS),\n ];\n \n /// The list of default passes run when `--doc-coverage` is passed to rustdoc."}, {"sha": "1908ffb8ff3f0aad5efc6aeb10f01dba49dc65ed", "filename": "src/test/assembly/asm/aarch64-el2vmsa.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fassembly%2Fasm%2Faarch64-el2vmsa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fassembly%2Fasm%2Faarch64-el2vmsa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Faarch64-el2vmsa.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,37 @@\n+// assembly-output: emit-asm\n+// compile-flags: --target aarch64-unknown-linux-gnu\n+// needs-llvm-components: aarch64\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+// CHECK-LABEL: ttbr0_el2:\n+#[no_mangle]\n+pub fn ttbr0_el2() {\n+    // CHECK: //APP\n+    // CHECK-NEXT: msr TTBR0_EL2, x0\n+    // CHECK-NEXT: //NO_APP\n+    unsafe {\n+        asm!(\"msr ttbr0_el2, x0\");\n+    }\n+}\n+\n+// CHECK-LABEL: vttbr_el2:\n+#[no_mangle]\n+pub fn vttbr_el2() {\n+    // CHECK: //APP\n+    // CHECK-NEXT: msr VTTBR_EL2, x0\n+    // CHECK-NEXT: //NO_APP\n+    unsafe {\n+        asm!(\"msr vttbr_el2, x0\");\n+    }\n+}"}, {"sha": "6309dd420ffa4d5c8c42915fdbfd6a9e86b43924", "filename": "src/test/assembly/sparc-struct-abi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fassembly%2Fsparc-struct-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fassembly%2Fsparc-struct-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fsparc-struct-abi.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -44,12 +44,16 @@ pub unsafe extern \"C\" fn callee(arg: Franta) {\n     tst_use(arg.b);\n     tst_use(arg.c);\n     tst_use(arg.d);\n+    tail_call_avoidance_fn();\n }\n \n extern \"C\" {\n     fn opaque_callee(arg: Franta, intarg: i32);\n     fn tst_use(arg: f32);\n     fn clobber();\n+    // This exists so that post-https://reviews.llvm.org/D138741 LLVM doesn't\n+    // tail-call away some of our assertions.\n+    fn tail_call_avoidance_fn();\n }\n \n #[no_mangle]\n@@ -62,4 +66,5 @@ pub unsafe extern \"C\" fn caller() {\n     // CHECK: call opaque_callee\n     // CHECK: mov     3, %o2\n     opaque_callee(Franta { a: 1.0, b: 2.0, c: 3.0, d: 4.0 }, 3);\n+    tail_call_avoidance_fn();\n }"}, {"sha": "44f1b408d21b8f0ede3c3ceb48cec463f614e142", "filename": "src/test/codegen/enum-match.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fcodegen%2Fenum-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fcodegen%2Fenum-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-match.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -34,11 +34,8 @@ pub enum Enum1 {\n \n // CHECK: define i8 @match1{{.*}}\n // CHECK-NEXT: start:\n-// CHECK-NEXT: %1 = icmp ugt i8 %0, 1\n-// CHECK-NEXT: %2 = zext i8 %0 to i64\n-// CHECK-NEXT: %3 = add nsw i64 %2, -1\n-// CHECK-NEXT: %_2 = select i1 %1, i64 %3, i64 0\n-// CHECK-NEXT: switch i64 %_2, label {{.*}} [\n+// CHECK-NEXT: %1 = {{.*}}call i8 @llvm.usub.sat.i8(i8 %0, i8 1)\n+// CHECK-NEXT: switch i8 %1, label {{.*}} [\n #[no_mangle]\n pub fn match1(e: Enum1) -> u8 {\n     use Enum1::*;"}, {"sha": "91a6260bf2aa2f1794b3f676a1b231ab91b69848", "filename": "src/test/codegen/naked-nocoverage.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fcodegen%2Fnaked-nocoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fcodegen%2Fnaked-nocoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnaked-nocoverage.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,19 @@\n+// Checks that naked functions are not instrumented by -Cinstrument-coverage.\n+// Regression test for issue #105170.\n+//\n+// needs-asm-support\n+// needs-profiler-support\n+// compile-flags: -Cinstrument-coverage\n+#![crate_type = \"lib\"]\n+#![feature(naked_functions)]\n+use std::arch::asm;\n+\n+#[naked]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn f() {\n+    // CHECK:       define void @f()\n+    // CHECK-NEXT:  start:\n+    // CHECK-NEXT:    call void asm\n+    // CHECK-NEXT:    unreachable\n+    asm!(\"\", options(noreturn));\n+}"}, {"sha": "70fca04365378e4af715d7948589000a591399e4", "filename": "src/test/run-make/macos-deployment-target/Makefile", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frun-make%2Fmacos-deployment-target%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frun-make%2Fmacos-deployment-target%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmacos-deployment-target%2FMakefile?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,21 @@\n+# only-macos\n+#\n+# Check that a set deployment target actually makes it to the linker.\n+# This is important since its a compatibility hazard. The linker will\n+# generate load commands differently based on what minimum OS it can assume.\n+\n+include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(strip $(shell uname -m)),arm64)\n+\tGREP_PATTERN = \"minos 11.0\"\n+else\n+ \tGREP_PATTERN = \"version 10.9\"\n+endif\n+\n+OUT_FILE=$(TMPDIR)/with_deployment_target.dylib\n+all:\n+\tenv MACOSX_DEPLOYMENT_TARGET=10.9 $(RUSTC) with_deployment_target.rs -o $(OUT_FILE)\n+# XXX: The check is for either the x86_64 minimum OR the aarch64 minimum (M1 starts at macOS 11).\n+# They also use different load commands, so we let that change with each too. The aarch64 check\n+# isn't as robust as the x86 one, but testing both seems unneeded.\n+\tvtool -show-build $(OUT_FILE) | $(CGREP) -e $(GREP_PATTERN)"}, {"sha": "342fe0ecbcfcd20085014a4b62278cfe2b762cbc", "filename": "src/test/run-make/macos-deployment-target/with_deployment_target.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frun-make%2Fmacos-deployment-target%2Fwith_deployment_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frun-make%2Fmacos-deployment-target%2Fwith_deployment_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmacos-deployment-target%2Fwith_deployment_target.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,4 @@\n+#![crate_type = \"cdylib\"]\n+\n+#[allow(dead_code)]\n+fn something_and_nothing() {}"}, {"sha": "bfe85f59e8179645a1d9dd058d7b487d8df7a152", "filename": "src/test/rustdoc-json/intra-doc-links/auxiliary/enum_variant_in_trait_method.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Fintra-doc-links%2Fauxiliary%2Fenum_variant_in_trait_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Fintra-doc-links%2Fauxiliary%2Fenum_variant_in_trait_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fintra-doc-links%2Fauxiliary%2Fenum_variant_in_trait_method.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,8 @@\n+pub trait Trait {\n+    /// [`Enum::Variant`]\n+    fn method() {}\n+}\n+\n+pub enum Enum {\n+    Variant,\n+}"}, {"sha": "e29682313386806d718d89fb08bdf36a0743439e", "filename": "src/test/rustdoc-json/intra-doc-links/foreign_variant.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Fintra-doc-links%2Fforeign_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Fintra-doc-links%2Fforeign_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fintra-doc-links%2Fforeign_variant.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,13 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/105025>\n+// aux-build: enum_variant_in_trait_method.rs\n+\n+extern crate enum_variant_in_trait_method;\n+\n+pub struct Local;\n+\n+/// local impl\n+impl enum_variant_in_trait_method::Trait for Local {}\n+\n+// @!has \"$.index[*][?(@.name == 'Trait')]\"\n+// @!has \"$.index[*][?(@.name == 'method')]\"\n+// @count \"$.index[*][?(@.docs == 'local impl')].inner.items[*]\" 0"}, {"sha": "1e87966b28aea55bc09dd8bae5385726c7e2cbe8", "filename": "src/test/rustdoc-json/reexport/auxiliary/trait_with_docs.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Freexport%2Fauxiliary%2Ftrait_with_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Freexport%2Fauxiliary%2Ftrait_with_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fauxiliary%2Ftrait_with_docs.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,2 @@\n+/// The Docs\n+pub trait HasDocs {}"}, {"sha": "25a7c08d689225e9484e0f42c2255db78aaa5e3d", "filename": "src/test/rustdoc-json/reexport/synthesize_trait_with_docs.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Freexport%2Fsynthesize_trait_with_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Freexport%2Fsynthesize_trait_with_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fsynthesize_trait_with_docs.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/105022>\n+// aux-build: trait_with_docs.rs\n+\n+extern crate trait_with_docs;\n+\n+pub struct Local;\n+\n+impl trait_with_docs::HasDocs for Local {}\n+\n+// @!has \"$.index[*][?(@.name == 'HasDocs')]\""}, {"sha": "55a51f739ab236c03c9e2ba0a6eb05835fa46d96", "filename": "src/test/rustdoc-json/traits/uses_extern_trait.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Ftraits%2Fuses_extern_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-json%2Ftraits%2Fuses_extern_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ftraits%2Fuses_extern_trait.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,12 +1,5 @@\n #![no_std]\n pub fn drop_default<T: core::default::Default>(_x: T) {}\n \n-// FIXME(adotinthevoid): Theses shouldn't be here\n-// @has \"$.index[*][?(@.name=='Debug')]\"\n-\n-// Debug may have several items. All we depend on here the that `fmt` is first. See\n-// https://github.com/rust-lang/rust/pull/104525#issuecomment-1331087852 for why we\n-// can't use [*].\n-\n-// @set Debug_fmt = \"$.index[*][?(@.name=='Debug')].inner.items[0]\"\n-// @has \"$.index[*][?(@.name=='fmt')].id\" $Debug_fmt\n+// @!has \"$.index[*][?(@.name=='Debug')]\"\n+// @!has \"$.index[*][?(@.name=='Default')]\""}, {"sha": "1678352436315d74046949c81b8f3402974a7db3", "filename": "src/test/rustdoc-ui/issue-91713.stdout", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -5,11 +5,9 @@ check_doc_test_visibility - run various visibility-related lints on doctests\n   strip-priv-imports - strips all private import statements (`use`, `extern crate`) from a crate\n    propagate-doc-cfg - propagates `#[doc(cfg(...))]` to child items\n collect-intra-doc-links - resolves intra-doc links\n-check-code-block-syntax - validates syntax inside Rust code blocks\n  collect-trait-impls - retrieves trait impls for items in the crate\n calculate-doc-coverage - counts the number of items with and without documentation\n-check-invalid-html-tags - detects invalid HTML tags in doc comments\n-     check-bare-urls - detects URLs that are not hyperlinks\n+           run-lints - runs some of rustdoc's lints\n \n Default passes for rustdoc:\n  collect-trait-impls\n@@ -18,10 +16,8 @@ check_doc_test_visibility\n        strip-private  (when not --document-private-items)\n   strip-priv-imports  (when --document-private-items)\n collect-intra-doc-links\n-check-code-block-syntax\n-check-invalid-html-tags\n    propagate-doc-cfg\n-     check-bare-urls\n+           run-lints\n \n Passes run with `--show-coverage`:\n         strip-hidden  (when not --document-hidden-items)"}, {"sha": "55154803098675fdacff687709d0b8ab9c475cec", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -90,7 +90,6 @@\n     -Z                             no-analysis=val -- parse and expand the source, but run no analysis\n     -Z                              no-codegen=val -- run all passes except codegen; no output\n     -Z              no-generate-arange-section=val -- omit DWARF address ranges that give faster lookups\n-    -Z                     no-interleave-lints=val -- execute lints separately; allows benchmarking individual lints\n     -Z                           no-leak-check=val -- disable the 'leak check' for subtyping; unsound, but useful for tests\n     -Z                                 no-link=val -- compile without linking\n     -Z                        no-parallel-llvm=val -- run LLVM in non-parallel mode (while keeping codegen-units and ThinLTO)"}, {"sha": "279e3c148887e8bc4e8ea128d71dfd4a39c8c943", "filename": "src/test/rustdoc/bounds-in-multiple-parts.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fbounds-in-multiple-parts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fbounds-in-multiple-parts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fbounds-in-multiple-parts.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,20 @@\n+#![crate_name = \"foo\"]\n+\n+pub trait Eq {}\n+pub trait Eq2 {}\n+\n+// Checking that \"where predicates\" and \"generics params\" are merged.\n+// @has 'foo/trait.T.html'\n+// @has - \"//*[@id='tymethod.f']/h4\" \"fn f<'a, 'b, 'c, T>()where Self: Eq, T: Eq + 'a, 'c: 'b + 'a,\"\n+pub trait T {\n+    fn f<'a, 'b, 'c: 'a, T: Eq + 'a>()\n+        where Self: Eq, Self: Eq, T: Eq, 'c: 'b;\n+}\n+\n+// Checking that a duplicated \"where predicate\" is removed.\n+// @has 'foo/trait.T2.html'\n+// @has - \"//*[@id='tymethod.f']/h4\" \"fn f<T>()where Self: Eq + Eq2, T: Eq2 + Eq,\"\n+pub trait T2 {\n+    fn f<T: Eq>()\n+        where Self: Eq, Self: Eq2, T: Eq2;\n+}"}, {"sha": "90cbb77cb6b60a013b1b8475bfa9bdde21204227", "filename": "src/test/rustdoc/impl-parts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fimpl-parts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fimpl-parts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpl-parts.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -6,7 +6,7 @@ pub auto trait AnAutoTrait {}\n pub struct Foo<T> { field: T }\n \n // @has impl_parts/struct.Foo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n-//     \"impl<T: Clone> !AnAutoTrait for Foo<T>where T: Sync,\"\n+//     \"impl<T> !AnAutoTrait for Foo<T>where T: Sync + Clone,\"\n // @has impl_parts/trait.AnAutoTrait.html '//*[@id=\"implementors-list\"]//h3[@class=\"code-header\"]' \\\n-//     \"impl<T: Clone> !AnAutoTrait for Foo<T>where T: Sync,\"\n+//     \"impl<T> !AnAutoTrait for Foo<T>where T: Sync + Clone,\"\n impl<T: Clone> !AnAutoTrait for Foo<T> where T: Sync {}"}, {"sha": "7ed9d6729b647a67523462e6ec57a04be926a407", "filename": "src/test/rustdoc/rfc-2632-const-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -61,7 +61,7 @@ impl<T> S<T> {\n     // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/a[@class=\"trait\"]' 'Clone'\n     // @!has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where\"]' '~const'\n     // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n-    pub const fn foo<B: ~const Clone + ~const Destruct>()\n+    pub const fn foo<B, C: ~const Clone + ~const Destruct>()\n     where\n         B: ~const Clone + ~const Destruct,\n     {"}, {"sha": "f7663e4616ae6784ca44d04afe6af378232d98ea", "filename": "src/test/rustdoc/whitespace-after-where-clause.enum.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,4 +1,4 @@\n-<div class=\"item-decl\"><pre class=\"rust enum\"><code>pub enum Cow&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n+<div class=\"item-decl\"><pre class=\"rust enum\"><code>pub enum Cow&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     Borrowed(<a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a </a>B),\n     Whatever(<a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>),\n }</code></pre></div>\n\\ No newline at end of file"}, {"sha": "fa3f224e7ad0f5d21deb3fc66599eb2bd162d3d5", "filename": "src/test/rustdoc/whitespace-after-where-clause.struct.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,4 +1,4 @@\n-<div class=\"item-decl\"><pre class=\"rust struct\"><code>pub struct Struct&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n+<div class=\"item-decl\"><pre class=\"rust struct\"><code>pub struct Struct&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     pub a: <a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a </a>B,\n     pub b: <a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>,\n }</code></pre></div>\n\\ No newline at end of file"}, {"sha": "7bb177debc3a8c828e6526c0f5a0e45ba47af870", "filename": "src/test/rustdoc/whitespace-after-where-clause.union.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,3 +1,3 @@\n-<div class=\"item-decl\"><pre class=\"rust union\"><code>pub union Union&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n+<div class=\"item-decl\"><pre class=\"rust union\"><code>pub union Union&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     /* private fields */\n }</code></pre></div>\n\\ No newline at end of file"}, {"sha": "82679c9e10a100b0ec5241092ed43abc2f8ed7c4", "filename": "src/test/ui-fulldeps/lint-plugin-cmdline-load.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-load.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,11 +1,3 @@\n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> <crate attribute>:1:1\n-   |\n-LL | plugin(lint_plugin_test)\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n warning: item is named 'lintme'\n   --> $DIR/lint-plugin-cmdline-load.rs:8:1\n    |\n@@ -14,5 +6,13 @@ LL | fn lintme() { }\n    |\n    = note: `#[warn(test_lint)]` on by default\n \n+warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n+  --> <crate attribute>:1:1\n+   |\n+LL | plugin(lint_plugin_test)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n warning: 2 warnings emitted\n "}, {"sha": "5e8891bf1f1ac224eb860bf78abf98263a39f2a3", "filename": "src/test/ui-fulldeps/lint-plugin-deny-attr.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-deny-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-deny-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-deny-attr.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,11 +1,3 @@\n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/lint-plugin-deny-attr.rs:5:1\n-   |\n-LL | #![plugin(lint_plugin_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n error: item is named 'lintme'\n   --> $DIR/lint-plugin-deny-attr.rs:9:1\n    |\n@@ -18,5 +10,13 @@ note: the lint level is defined here\n LL | #![deny(test_lint)]\n    |         ^^^^^^^^^\n \n+warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n+  --> $DIR/lint-plugin-deny-attr.rs:5:1\n+   |\n+LL | #![plugin(lint_plugin_test)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "d5d6b5352145c531ac081fc9e38279117c55bc1a", "filename": "src/test/ui-fulldeps/lint-plugin-deny-cmdline.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-deny-cmdline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-deny-cmdline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-deny-cmdline.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,11 +1,3 @@\n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/lint-plugin-deny-cmdline.rs:6:1\n-   |\n-LL | #![plugin(lint_plugin_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n error: item is named 'lintme'\n   --> $DIR/lint-plugin-deny-cmdline.rs:9:1\n    |\n@@ -14,5 +6,13 @@ LL | fn lintme() { }\n    |\n    = note: requested on the command line with `-D test-lint`\n \n+warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n+  --> $DIR/lint-plugin-deny-cmdline.rs:6:1\n+   |\n+LL | #![plugin(lint_plugin_test)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "cf31b3ec1587e788d6a1c748c8ed2c55f1ce4d41", "filename": "src/test/ui-fulldeps/lint-plugin-forbid-attrs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-attrs.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -11,7 +11,6 @@ fn lintme() {} //~ ERROR item is named 'lintme'\n #[allow(test_lint)]\n //~^ ERROR allow(test_lint) incompatible\n //~| ERROR allow(test_lint) incompatible\n-//~| ERROR allow(test_lint) incompatible\n pub fn main() {\n     lintme();\n }"}, {"sha": "ae34b25cc2f808002972340723ac46c7eda961db", "filename": "src/test/ui-fulldeps/lint-plugin-forbid-attrs.stderr", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-attrs.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -7,23 +7,6 @@ LL | #![forbid(test_lint)]\n LL | #[allow(test_lint)]\n    |         ^^^^^^^^^ overruled by previous forbid\n \n-error[E0453]: allow(test_lint) incompatible with previous forbid\n-  --> $DIR/lint-plugin-forbid-attrs.rs:11:9\n-   |\n-LL | #![forbid(test_lint)]\n-   |           --------- `forbid` level set here\n-...\n-LL | #[allow(test_lint)]\n-   |         ^^^^^^^^^ overruled by previous forbid\n-\n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/lint-plugin-forbid-attrs.rs:5:1\n-   |\n-LL | #![plugin(lint_plugin_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n error: item is named 'lintme'\n   --> $DIR/lint-plugin-forbid-attrs.rs:9:1\n    |\n@@ -45,6 +28,14 @@ LL | #![forbid(test_lint)]\n LL | #[allow(test_lint)]\n    |         ^^^^^^^^^ overruled by previous forbid\n \n-error: aborting due to 4 previous errors; 1 warning emitted\n+warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n+  --> $DIR/lint-plugin-forbid-attrs.rs:5:1\n+   |\n+LL | #![plugin(lint_plugin_test)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0453`."}, {"sha": "b9d1aa85a69308694fae84a4baabb14c86518989", "filename": "src/test/ui-fulldeps/lint-plugin-forbid-cmdline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-cmdline.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -9,7 +9,7 @@ fn lintme() { } //~ ERROR item is named 'lintme'\n \n #[allow(test_lint)] //~ ERROR allow(test_lint) incompatible\n                     //~| ERROR allow(test_lint) incompatible\n-                    //~| ERROR allow(test_lint)\n+\n pub fn main() {\n     lintme();\n }"}, {"sha": "491c4d2064681e9ae467a2f5b8a8399160cc253b", "filename": "src/test/ui-fulldeps/lint-plugin-forbid-cmdline.stderr", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-cmdline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-cmdline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-forbid-cmdline.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -6,22 +6,6 @@ LL | #[allow(test_lint)]\n    |\n    = note: `forbid` lint level was set on command line\n \n-error[E0453]: allow(test_lint) incompatible with previous forbid\n-  --> $DIR/lint-plugin-forbid-cmdline.rs:10:9\n-   |\n-LL | #[allow(test_lint)]\n-   |         ^^^^^^^^^ overruled by previous forbid\n-   |\n-   = note: `forbid` lint level was set on command line\n-\n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/lint-plugin-forbid-cmdline.rs:6:1\n-   |\n-LL | #![plugin(lint_plugin_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n error: item is named 'lintme'\n   --> $DIR/lint-plugin-forbid-cmdline.rs:8:1\n    |\n@@ -38,6 +22,14 @@ LL | #[allow(test_lint)]\n    |\n    = note: `forbid` lint level was set on command line\n \n-error: aborting due to 4 previous errors; 1 warning emitted\n+warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n+  --> $DIR/lint-plugin-forbid-cmdline.rs:6:1\n+   |\n+LL | #![plugin(lint_plugin_test)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0453`."}, {"sha": "dd5d3d72ecf39baff81953fceebedeec5c48deee", "filename": "src/test/ui-fulldeps/lint-plugin.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-plugin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,11 +1,3 @@\n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/lint-plugin.rs:5:1\n-   |\n-LL | #![plugin(lint_plugin_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n warning: item is named 'lintme'\n   --> $DIR/lint-plugin.rs:8:1\n    |\n@@ -14,5 +6,13 @@ LL | fn lintme() { }\n    |\n    = note: `#[warn(test_lint)]` on by default\n \n+warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n+  --> $DIR/lint-plugin.rs:5:1\n+   |\n+LL | #![plugin(lint_plugin_test)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n warning: 2 warnings emitted\n "}, {"sha": "b060e3a3e38b4c10eaac0a881b39258628a46961", "filename": "src/test/ui-fulldeps/lint-tool-cmdline-allow.stderr", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-tool-cmdline-allow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-tool-cmdline-allow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-tool-cmdline-allow.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -6,18 +6,6 @@ warning: lint name `test_lint` is deprecated and does not have an effect anymore\n    |\n    = note: requested on the command line with `-A test_lint`\n \n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/lint-tool-cmdline-allow.rs:7:1\n-   |\n-LL | #![plugin(lint_tool_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n-warning: lint name `test_lint` is deprecated and does not have an effect anymore. Use: clippy::test_lint\n-   |\n-   = note: requested on the command line with `-A test_lint`\n-\n warning: item is named 'lintme'\n   --> $DIR/lint-tool-cmdline-allow.rs:9:1\n    |\n@@ -26,9 +14,17 @@ LL | fn lintme() {}\n    |\n    = note: `#[warn(clippy::test_lint)]` on by default\n \n+warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n+  --> $DIR/lint-tool-cmdline-allow.rs:7:1\n+   |\n+LL | #![plugin(lint_tool_test)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n warning: lint name `test_lint` is deprecated and does not have an effect anymore. Use: clippy::test_lint\n    |\n    = note: requested on the command line with `-A test_lint`\n \n-warning: 6 warnings emitted\n+warning: 5 warnings emitted\n "}, {"sha": "f92bcd213b844a272914c36cf2ceea10bb58ab0f", "filename": "src/test/ui-fulldeps/lint-tool-test.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-tool-test.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -10,12 +10,10 @@\n //~^ WARNING lint name `test_lint` is deprecated and may not have an effect in the future\n //~| WARNING lint name `test_lint` is deprecated and may not have an effect in the future\n //~| WARNING lint name `test_lint` is deprecated and may not have an effect in the future\n-//~| WARNING lint name `test_lint` is deprecated and may not have an effect in the future\n #![deny(clippy_group)]\n //~^ WARNING lint name `clippy_group` is deprecated and may not have an effect in the future\n //~| WARNING lint name `clippy_group` is deprecated and may not have an effect in the future\n //~| WARNING lint name `clippy_group` is deprecated and may not have an effect in the future\n-//~| WARNING lint name `clippy_group` is deprecated and may not have an effect in the future\n \n fn lintme() { } //~ ERROR item is named 'lintme'\n \n@@ -32,7 +30,6 @@ pub fn main() {\n //~^ WARNING lint name `test_group` is deprecated and may not have an effect in the future\n //~| WARNING lint name `test_group` is deprecated and may not have an effect in the future\n //~| WARNING lint name `test_group` is deprecated and may not have an effect in the future\n-//~| WARNING lint name `test_group` is deprecated and may not have an effect in the future\n #[deny(this_lint_does_not_exist)] //~ WARNING unknown lint: `this_lint_does_not_exist`\n fn hello() {\n     fn lintmetoo() { }"}, {"sha": "027cf8f80cff28b2c1ed539c9b1230dabde0e9c0", "filename": "src/test/ui-fulldeps/lint-tool-test.stderr", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-tool-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Flint-tool-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-tool-test.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -7,13 +7,13 @@ LL | #![cfg_attr(foo, warn(test_lint))]\n    = note: `#[warn(renamed_and_removed_lints)]` on by default\n \n warning: lint name `clippy_group` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:14:9\n+  --> $DIR/lint-tool-test.rs:13:9\n    |\n LL | #![deny(clippy_group)]\n    |         ^^^^^^^^^^^^ help: change it to: `clippy::group`\n \n warning: lint name `test_group` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:31:9\n+  --> $DIR/lint-tool-test.rs:29:9\n    |\n LL | #[allow(test_group)]\n    |         ^^^^^^^^^^ help: change it to: `clippy::test_group`\n@@ -25,89 +25,71 @@ LL | #![cfg_attr(foo, warn(test_lint))]\n    |                       ^^^^^^^^^ help: change it to: `clippy::test_lint`\n \n warning: lint name `clippy_group` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:14:9\n-   |\n-LL | #![deny(clippy_group)]\n-   |         ^^^^^^^^^^^^ help: change it to: `clippy::group`\n-\n-warning: lint name `test_group` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:31:9\n-   |\n-LL | #[allow(test_group)]\n-   |         ^^^^^^^^^^ help: change it to: `clippy::test_group`\n-\n-warning: unknown lint: `this_lint_does_not_exist`\n-  --> $DIR/lint-tool-test.rs:36:8\n-   |\n-LL | #[deny(this_lint_does_not_exist)]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(unknown_lints)]` on by default\n-\n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/lint-tool-test.rs:6:1\n-   |\n-LL | #![plugin(lint_tool_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n-warning: lint name `test_lint` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:9:23\n-   |\n-LL | #![cfg_attr(foo, warn(test_lint))]\n-   |                       ^^^^^^^^^ help: change it to: `clippy::test_lint`\n-\n-warning: lint name `clippy_group` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:14:9\n+  --> $DIR/lint-tool-test.rs:13:9\n    |\n LL | #![deny(clippy_group)]\n    |         ^^^^^^^^^^^^ help: change it to: `clippy::group`\n \n error: item is named 'lintme'\n-  --> $DIR/lint-tool-test.rs:20:1\n+  --> $DIR/lint-tool-test.rs:18:1\n    |\n LL | fn lintme() { }\n    | ^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-tool-test.rs:14:9\n+  --> $DIR/lint-tool-test.rs:13:9\n    |\n LL | #![deny(clippy_group)]\n    |         ^^^^^^^^^^^^\n    = note: `#[deny(clippy::test_lint)]` implied by `#[deny(clippy::group)]`\n \n error: item is named 'lintmetoo'\n-  --> $DIR/lint-tool-test.rs:28:5\n+  --> $DIR/lint-tool-test.rs:26:5\n    |\n LL |     fn lintmetoo() { }\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[deny(clippy::test_group)]` implied by `#[deny(clippy::group)]`\n \n warning: lint name `test_group` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:31:9\n+  --> $DIR/lint-tool-test.rs:29:9\n    |\n LL | #[allow(test_group)]\n    |         ^^^^^^^^^^ help: change it to: `clippy::test_group`\n \n+warning: unknown lint: `this_lint_does_not_exist`\n+  --> $DIR/lint-tool-test.rs:33:8\n+   |\n+LL | #[deny(this_lint_does_not_exist)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(unknown_lints)]` on by default\n+\n+warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n+  --> $DIR/lint-tool-test.rs:6:1\n+   |\n+LL | #![plugin(lint_tool_test)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n warning: lint name `test_lint` is deprecated and may not have an effect in the future.\n   --> $DIR/lint-tool-test.rs:9:23\n    |\n LL | #![cfg_attr(foo, warn(test_lint))]\n    |                       ^^^^^^^^^ help: change it to: `clippy::test_lint`\n \n warning: lint name `clippy_group` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:14:9\n+  --> $DIR/lint-tool-test.rs:13:9\n    |\n LL | #![deny(clippy_group)]\n    |         ^^^^^^^^^^^^ help: change it to: `clippy::group`\n \n warning: lint name `test_group` is deprecated and may not have an effect in the future.\n-  --> $DIR/lint-tool-test.rs:31:9\n+  --> $DIR/lint-tool-test.rs:29:9\n    |\n LL | #[allow(test_group)]\n    |         ^^^^^^^^^^ help: change it to: `clippy::test_group`\n \n-error: aborting due to 2 previous errors; 14 warnings emitted\n+error: aborting due to 2 previous errors; 11 warnings emitted\n "}, {"sha": "a93ba87470a9c045703a8d31a2d39b51884d04a5", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -126,6 +126,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                         fn_decl: decl.clone(),\n                         body: e,\n                         fn_decl_span: DUMMY_SP,\n+                        fn_arg_span: DUMMY_SP,\n                     })))\n                 });\n             }"}, {"sha": "a28b1c00113c9b6ef15336f7b5c712d22f00a06f", "filename": "src/test/ui/associated-consts/issue-47814.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-47814.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-47814.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-47814.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,14 @@\n+struct ArpIPv4<'a> {\n+    s: &'a u8\n+}\n+\n+impl<'a> ArpIPv4<'a> {\n+    const LENGTH: usize = 20;\n+\n+    pub fn to_buffer() -> [u8; Self::LENGTH] {\n+        //~^ ERROR: generic `Self` types are currently not permitted in anonymous constants\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2e4ddb81166b404ff621eb97cf57b1e532811ed5", "filename": "src/test/ui/associated-consts/issue-47814.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-47814.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-47814.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-47814.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,14 @@\n+error: generic `Self` types are currently not permitted in anonymous constants\n+  --> $DIR/issue-47814.rs:8:32\n+   |\n+LL |     pub fn to_buffer() -> [u8; Self::LENGTH] {\n+   |                                ^^^^\n+   |\n+note: not a concrete type\n+  --> $DIR/issue-47814.rs:5:10\n+   |\n+LL | impl<'a> ArpIPv4<'a> {\n+   |          ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "8952b379173080a0f6a5bb62ae42c8b91cc9a4d7", "filename": "src/test/ui/associated-inherent-types/struct-generics.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fstruct-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fstruct-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-inherent-types%2Fstruct-generics.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T> S<T> {\n+    type P = T;\n+}\n+\n+fn main() {\n+    type A = S<()>::P;\n+    let _: A = ();\n+}"}, {"sha": "37d7cfa6fb7a37aa20ebc991c91bc06812e20acd", "filename": "src/test/ui/async-await/generator-not-future.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-not-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-not-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-not-future.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,45 @@\n+// edition:2018\n+#![feature(generators, generator_trait)]\n+\n+use std::future::Future;\n+use std::ops::Generator;\n+\n+async fn async_fn() {}\n+fn returns_async_block() -> impl Future<Output = ()> {\n+    async {}\n+}\n+fn returns_generator() -> impl Generator<(), Yield = (), Return = ()> {\n+    || {\n+        let _: () = yield ();\n+    }\n+}\n+\n+fn takes_future(_f: impl Future<Output = ()>) {}\n+fn takes_generator<ResumeTy>(_g: impl Generator<ResumeTy, Yield = (), Return = ()>) {}\n+\n+fn main() {\n+    // okay:\n+    takes_future(async_fn());\n+    takes_future(returns_async_block());\n+    takes_future(async {});\n+    takes_generator(returns_generator());\n+    takes_generator(|| {\n+        let _: () = yield ();\n+    });\n+\n+    // async futures are not generators:\n+    takes_generator(async_fn());\n+    //~^ ERROR the trait bound\n+    takes_generator(returns_async_block());\n+    //~^ ERROR the trait bound\n+    takes_generator(async {});\n+    //~^ ERROR the trait bound\n+\n+    // generators are not futures:\n+    takes_future(returns_generator());\n+    //~^ ERROR is not a future\n+    takes_future(|ctx| {\n+        //~^ ERROR is not a future\n+        ctx = yield ();\n+    });\n+}"}, {"sha": "1b81b461f0aadb95fb3dc5240ff2ed961cfc35f0", "filename": "src/test/ui/async-await/generator-not-future.stderr", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-not-future.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-not-future.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-not-future.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,81 @@\n+error[E0277]: the trait bound `impl Future<Output = ()>: Generator<_>` is not satisfied\n+  --> $DIR/generator-not-future.rs:31:21\n+   |\n+LL |     takes_generator(async_fn());\n+   |     --------------- ^^^^^^^^^^ the trait `Generator<_>` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `takes_generator`\n+  --> $DIR/generator-not-future.rs:18:39\n+   |\n+LL | fn takes_generator<ResumeTy>(_g: impl Generator<ResumeTy, Yield = (), Return = ()>) {}\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `takes_generator`\n+\n+error[E0277]: the trait bound `impl Future<Output = ()>: Generator<_>` is not satisfied\n+  --> $DIR/generator-not-future.rs:33:21\n+   |\n+LL |     takes_generator(returns_async_block());\n+   |     --------------- ^^^^^^^^^^^^^^^^^^^^^ the trait `Generator<_>` is not implemented for `impl Future<Output = ()>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `takes_generator`\n+  --> $DIR/generator-not-future.rs:18:39\n+   |\n+LL | fn takes_generator<ResumeTy>(_g: impl Generator<ResumeTy, Yield = (), Return = ()>) {}\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `takes_generator`\n+\n+error[E0277]: the trait bound `[async block@$DIR/generator-not-future.rs:35:21: 35:29]: Generator<_>` is not satisfied\n+  --> $DIR/generator-not-future.rs:35:21\n+   |\n+LL |     takes_generator(async {});\n+   |     --------------- ^^^^^^^^ the trait `Generator<_>` is not implemented for `[async block@$DIR/generator-not-future.rs:35:21: 35:29]`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `takes_generator`\n+  --> $DIR/generator-not-future.rs:18:39\n+   |\n+LL | fn takes_generator<ResumeTy>(_g: impl Generator<ResumeTy, Yield = (), Return = ()>) {}\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `takes_generator`\n+\n+error[E0277]: `impl Generator<Yield = (), Return = ()>` is not a future\n+  --> $DIR/generator-not-future.rs:39:18\n+   |\n+LL |     takes_future(returns_generator());\n+   |     ------------ ^^^^^^^^^^^^^^^^^^^ `impl Generator<Yield = (), Return = ()>` is not a future\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Future` is not implemented for `impl Generator<Yield = (), Return = ()>`\n+   = note: impl Generator<Yield = (), Return = ()> must be a future or must implement `IntoFuture` to be awaited\n+note: required by a bound in `takes_future`\n+  --> $DIR/generator-not-future.rs:17:26\n+   |\n+LL | fn takes_future(_f: impl Future<Output = ()>) {}\n+   |                          ^^^^^^^^^^^^^^^^^^^ required by this bound in `takes_future`\n+\n+error[E0277]: `[generator@$DIR/generator-not-future.rs:41:18: 41:23]` is not a future\n+  --> $DIR/generator-not-future.rs:41:18\n+   |\n+LL |       takes_future(|ctx| {\n+   |  _____------------_^\n+   | |     |\n+   | |     required by a bound introduced by this call\n+LL | |\n+LL | |         ctx = yield ();\n+LL | |     });\n+   | |_____^ `[generator@$DIR/generator-not-future.rs:41:18: 41:23]` is not a future\n+   |\n+   = help: the trait `Future` is not implemented for `[generator@$DIR/generator-not-future.rs:41:18: 41:23]`\n+   = note: [generator@$DIR/generator-not-future.rs:41:18: 41:23] must be a future or must implement `IntoFuture` to be awaited\n+note: required by a bound in `takes_future`\n+  --> $DIR/generator-not-future.rs:17:26\n+   |\n+LL | fn takes_future(_f: impl Future<Output = ()>) {}\n+   |                          ^^^^^^^^^^^^^^^^^^^ required by this bound in `takes_future`\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f1f0d7e5907d3277fb4d611d58674e0c8566969a", "filename": "src/test/ui/async-await/in-trait/async-generics-and-bounds.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -4,11 +4,11 @@ error[E0311]: the parameter type `U` may not live long enough\n LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n    |                            ^^^^^^^\n    |\n-note: the parameter type `U` must be valid for the anonymous lifetime as defined here...\n+note: the parameter type `U` must be valid for the anonymous lifetime defined here...\n   --> $DIR/async-generics-and-bounds.rs:12:18\n    |\n LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n-   |                  ^\n+   |                  ^^^^^\n note: ...so that the reference type `&(T, U)` does not outlive the data it points at\n   --> $DIR/async-generics-and-bounds.rs:12:28\n    |\n@@ -21,11 +21,11 @@ error[E0311]: the parameter type `T` may not live long enough\n LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n    |                            ^^^^^^^\n    |\n-note: the parameter type `T` must be valid for the anonymous lifetime as defined here...\n+note: the parameter type `T` must be valid for the anonymous lifetime defined here...\n   --> $DIR/async-generics-and-bounds.rs:12:18\n    |\n LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n-   |                  ^\n+   |                  ^^^^^\n note: ...so that the reference type `&(T, U)` does not outlive the data it points at\n   --> $DIR/async-generics-and-bounds.rs:12:28\n    |"}, {"sha": "2f05564564cd2b383510547b3241c84cce117c43", "filename": "src/test/ui/async-await/in-trait/async-generics.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -4,11 +4,11 @@ error[E0311]: the parameter type `U` may not live long enough\n LL |     async fn foo(&self) -> &(T, U);\n    |                            ^^^^^^^\n    |\n-note: the parameter type `U` must be valid for the anonymous lifetime as defined here...\n+note: the parameter type `U` must be valid for the anonymous lifetime defined here...\n   --> $DIR/async-generics.rs:9:18\n    |\n LL |     async fn foo(&self) -> &(T, U);\n-   |                  ^\n+   |                  ^^^^^\n note: ...so that the reference type `&(T, U)` does not outlive the data it points at\n   --> $DIR/async-generics.rs:9:28\n    |\n@@ -21,11 +21,11 @@ error[E0311]: the parameter type `T` may not live long enough\n LL |     async fn foo(&self) -> &(T, U);\n    |                            ^^^^^^^\n    |\n-note: the parameter type `T` must be valid for the anonymous lifetime as defined here...\n+note: the parameter type `T` must be valid for the anonymous lifetime defined here...\n   --> $DIR/async-generics.rs:9:18\n    |\n LL |     async fn foo(&self) -> &(T, U);\n-   |                  ^\n+   |                  ^^^^^\n note: ...so that the reference type `&(T, U)` does not outlive the data it points at\n   --> $DIR/async-generics.rs:9:28\n    |"}, {"sha": "d5481d277e40a5955a74d93de96c3b0a13816480", "filename": "src/test/ui/async-await/in-trait/async-lifetimes-and-bounds.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,5 +1,4 @@\n-// check-fail\n-// known-bug: #102682\n+// check-pass\n // edition: 2021\n \n #![feature(async_fn_in_trait)]"}, {"sha": "0f02420274333badbcbc3d84b3c0fd159a8bdcd6", "filename": "src/test/ui/async-await/in-trait/async-lifetimes-and-bounds.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.stderr?ref=faec28970f86f52ca37e0e8cec0a447ba2f1393b", "patch": "@@ -1,23 +0,0 @@\n-error[E0309]: the parameter type `Self` may not live long enough\n-  --> $DIR/async-lifetimes-and-bounds.rs:11:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T) where T: Debug + Sized;\n-   |                                           ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `Self: 'a`...\n-   = note: ...so that the reference type `&'a Self` does not outlive the data it points at\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/async-lifetimes-and-bounds.rs:11:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T) where T: Debug + Sized;\n-   |                                           ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'b T` does not outlive the data it points at\n-   |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | trait MyTrait<'a, 'b, T: 'b> {\n-   |                        ++++\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "f298e45d2390b368dc7391a7b1989de9ab096f13", "filename": "src/test/ui/async-await/in-trait/async-lifetimes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,5 +1,4 @@\n-// check-fail\n-// known-bug: #102682\n+// check-pass\n // edition: 2021\n \n #![feature(async_fn_in_trait)]"}, {"sha": "9a7d294bb17669f6de727d113abcc4c78903e990", "filename": "src/test/ui/async-await/in-trait/async-lifetimes.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.stderr?ref=faec28970f86f52ca37e0e8cec0a447ba2f1393b", "patch": "@@ -1,23 +0,0 @@\n-error[E0309]: the parameter type `Self` may not live long enough\n-  --> $DIR/async-lifetimes.rs:9:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T);\n-   |                                           ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `Self: 'a`...\n-   = note: ...so that the reference type `&'a Self` does not outlive the data it points at\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/async-lifetimes.rs:9:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T);\n-   |                                           ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'b T` does not outlive the data it points at\n-   |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | trait MyTrait<'a, 'b, T: 'b> {\n-   |                        ++++\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "52bceb3cc5cd61c3fd39062d347369d885498009", "filename": "src/test/ui/async-await/in-trait/implied-bounds.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fimplied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fimplied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fimplied-bounds.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait TcpStack {\n+    type Connection<'a>: Sized where Self: 'a;\n+    fn connect<'a>(&'a self) -> Self::Connection<'a>;\n+    async fn async_connect<'a>(&'a self) -> Self::Connection<'a>;\n+}\n+\n+fn main() {}"}, {"sha": "45ede193c0fc633bd3b8a4b56b359d664e81d244", "filename": "src/test/ui/async-await/in-trait/lifetime-mismatch.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,20 @@\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+//~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+\n+trait MyTrait {\n+    async fn foo<'a>(&self);\n+    async fn bar(&self);\n+}\n+\n+impl MyTrait for i32 {\n+    async fn foo(&self) {}\n+    //~^ ERROR lifetime parameters or bounds on method `foo` do not match the trait declaration\n+\n+    async fn bar(&self) {\n+        self.foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d87adcc78b6c8bb9fbb282eb57ae3a894e6c87db", "filename": "src/test/ui/async-await/in-trait/lifetime-mismatch.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/lifetime-mismatch.rs:3:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0195]: lifetime parameters or bounds on method `foo` do not match the trait declaration\n+  --> $DIR/lifetime-mismatch.rs:12:17\n+   |\n+LL |     async fn foo<'a>(&self);\n+   |                 ---- lifetimes in impl do not match this method in trait\n+...\n+LL |     async fn foo(&self) {}\n+   |                 ^ lifetimes do not match method in trait\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0195`."}, {"sha": "70dcd5413f1ee0b2a445e4cedd3058f9326b881f", "filename": "src/test/ui/attributes/unused-item-in-attr.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,6 @@\n+#[w = { extern crate alloc; }]\n+//~^ ERROR unexpected expression: `{\n+//~| ERROR cannot find attribute `w` in this scope\n+fn f() {}\n+\n+fn main() {}"}, {"sha": "92a8f58582136a05f808b34a53f3d5d0b1d7a89d", "filename": "src/test/ui/attributes/unused-item-in-attr.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,16 @@\n+error: unexpected expression: `{\n+           extern crate alloc;\n+       }`\n+  --> $DIR/unused-item-in-attr.rs:1:7\n+   |\n+LL | #[w = { extern crate alloc; }]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot find attribute `w` in this scope\n+  --> $DIR/unused-item-in-attr.rs:1:3\n+   |\n+LL | #[w = { extern crate alloc; }]\n+   |   ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "5ce1fd54a9e62027a7f53517d8fb03fb74c14207", "filename": "src/test/ui/drop/drop_order.rs", "status": "modified", "additions": 90, "deletions": 7, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -43,7 +43,7 @@ impl DropOrderCollector {\n         }\n \n         if {\n-            if self.option_loud_drop(7).is_some() && self.option_loud_drop(6).is_some() {\n+            if self.option_loud_drop(6).is_some() && self.option_loud_drop(7).is_some() {\n                 self.loud_drop(8);\n                 true\n             } else {\n@@ -118,17 +118,85 @@ impl DropOrderCollector {\n         }\n     }\n \n+    fn and_chain(&self) {\n+        // issue-103107\n+        if self.option_loud_drop(1).is_some() // 1\n+            && self.option_loud_drop(2).is_some() // 2\n+            && self.option_loud_drop(3).is_some() // 3\n+            && self.option_loud_drop(4).is_some() // 4\n+            && self.option_loud_drop(5).is_some() // 5\n+        {\n+            self.print(6); // 6\n+        }\n+\n+        let _ = self.option_loud_drop(7).is_some() // 1\n+            && self.option_loud_drop(8).is_some() // 2\n+            && self.option_loud_drop(9).is_some(); // 3\n+        self.print(10); // 4\n+\n+        // Test associativity\n+        if self.option_loud_drop(11).is_some() // 1\n+            && (self.option_loud_drop(12).is_some() // 2\n+            && self.option_loud_drop(13).is_some() // 3\n+            && self.option_loud_drop(14).is_some()) // 4\n+            && self.option_loud_drop(15).is_some() // 5\n+        {\n+            self.print(16); // 6\n+        }\n+    }\n+\n+    fn or_chain(&self) {\n+        // issue-103107\n+        if self.option_loud_drop(1).is_none() // 1\n+            || self.option_loud_drop(2).is_none() // 2\n+            || self.option_loud_drop(3).is_none() // 3\n+            || self.option_loud_drop(4).is_none() // 4\n+            || self.option_loud_drop(5).is_some() // 5\n+        {\n+            self.print(6); // 6\n+        }\n+\n+        let _ = self.option_loud_drop(7).is_none() // 1\n+            || self.option_loud_drop(8).is_none() // 2\n+            || self.option_loud_drop(9).is_none(); // 3\n+        self.print(10); // 4\n+\n+        // Test associativity\n+        if self.option_loud_drop(11).is_none() // 1\n+            || (self.option_loud_drop(12).is_none() // 2\n+            || self.option_loud_drop(13).is_none() // 3\n+            || self.option_loud_drop(14).is_none()) // 4\n+            || self.option_loud_drop(15).is_some() // 5\n+        {\n+            self.print(16); // 6\n+        }\n+    }\n+\n+    fn mixed_and_or_chain(&self) {\n+        // issue-103107\n+        if self.option_loud_drop(1).is_none() // 1\n+            || self.option_loud_drop(2).is_none() // 2\n+            || self.option_loud_drop(3).is_some() // 3\n+            && self.option_loud_drop(4).is_some() // 4\n+            && self.option_loud_drop(5).is_none() // 5\n+            || self.option_loud_drop(6).is_none() // 6\n+            || self.option_loud_drop(7).is_some() // 7\n+        {\n+            self.print(8); // 8\n+        }\n+    }\n+\n     fn let_chain(&self) {\n         // take the \"then\" branch\n-        if self.option_loud_drop(2).is_some() // 2\n-            && self.option_loud_drop(1).is_some() // 1\n+        if self.option_loud_drop(1).is_some() // 1\n+            && self.option_loud_drop(2).is_some() // 2\n             && let Some(_d) = self.option_loud_drop(4) { // 4\n             self.print(3); // 3\n         }\n \n         // take the \"else\" branch\n-        if self.option_loud_drop(6).is_some() // 2\n-            && self.option_loud_drop(5).is_some() // 1\n+        if self.option_loud_drop(5).is_some() // 1\n+            && self.option_loud_drop(6).is_some() // 2\n             && let None = self.option_loud_drop(8) { // 4\n             unreachable!();\n         } else {\n@@ -152,8 +220,8 @@ impl DropOrderCollector {\n             }\n \n         // let exprs last\n-        if self.option_loud_drop(20).is_some() // 2\n-            && self.option_loud_drop(19).is_some() // 1\n+        if self.option_loud_drop(19).is_some() // 1\n+            && self.option_loud_drop(20).is_some() // 2\n             && let Some(_d) = self.option_loud_drop(23) // 5\n             && let Some(_e) = self.option_loud_drop(22) { // 4\n                 self.print(21); // 3\n@@ -187,6 +255,21 @@ fn main() {\n     collector.if_();\n     collector.assert_sorted();\n \n+    println!(\"-- and chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.and_chain();\n+    collector.assert_sorted();\n+\n+    println!(\"-- or chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.or_chain();\n+    collector.assert_sorted();\n+\n+    println!(\"-- mixed and/or chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.mixed_and_or_chain();\n+    collector.assert_sorted();\n+\n     println!(\"-- if let --\");\n     let collector = DropOrderCollector::default();\n     collector.if_let();"}, {"sha": "5f447595662edd74aa749b1f5c44c73eebb139b2", "filename": "src/test/ui/drop/issue-103107.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+// compile-flags: -Z validate-mir\n+\n+struct Foo<'a>(&'a mut u32);\n+\n+impl<'a> Drop for Foo<'a> {\n+    fn drop(&mut self) {\n+        *self.0 = 0;\n+    }\n+}\n+\n+fn and() {\n+    let mut foo = 0;\n+    // This used to compile also before the fix\n+    if true && *Foo(&mut foo).0 == 0 && ({ foo = 0; true}) {}\n+\n+    // This used to fail before the fix\n+    if *Foo(&mut foo).0 == 0 && ({ foo = 0; true}) {}\n+\n+    println!(\"{foo}\");\n+}\n+\n+fn or() {\n+    let mut foo = 0;\n+    // This used to compile also before the fix\n+    if false || *Foo(&mut foo).0 == 1 || ({ foo = 0; true}) {}\n+\n+    // This used to fail before the fix\n+    if *Foo(&mut foo).0 == 1 || ({ foo = 0; true}) {}\n+\n+    println!(\"{foo}\");\n+}\n+\n+fn main() {\n+    and();\n+    or();\n+}"}, {"sha": "c4630f76b3a1341bf5e8c2abe0902bc58339562c", "filename": "src/test/ui/enum-discriminant/issue-104519.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-104519.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-104519.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-104519.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,36 @@\n+// run-pass\n+#![allow(dead_code)]\n+\n+enum OpenResult {\n+    Ok(()),\n+    Err(()),\n+    TransportErr(TransportErr),\n+}\n+\n+#[repr(i32)]\n+enum TransportErr {\n+    UnknownMethod = -2,\n+}\n+\n+#[inline(never)]\n+fn some_match(result: OpenResult) -> u8 {\n+    match result {\n+        OpenResult::Ok(()) => 0,\n+        _ => 1,\n+    }\n+}\n+\n+fn main() {\n+    let result = OpenResult::Ok(());\n+    assert_eq!(some_match(result), 0);\n+\n+    let result = OpenResult::Ok(());\n+    match result {\n+        OpenResult::Ok(()) => (),\n+        _ => unreachable!(\"message a\"),\n+    }\n+    match result {\n+        OpenResult::Ok(()) => (),\n+        _ => unreachable!(\"message b\"),\n+    }\n+}"}, {"sha": "d7a8c95e8b2abf5d46b73bdd3a794c19499c5e97", "filename": "src/test/ui/fn/signature-error-reporting-under-verbose.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Ffn%2Fsignature-error-reporting-under-verbose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Ffn%2Fsignature-error-reporting-under-verbose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fsignature-error-reporting-under-verbose.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Zverbose\n+\n+fn foo(_: i32, _: i32) {}\n+\n+fn needs_ptr(_: fn(i32, u32)) {}\n+//~^ NOTE function defined here\n+//~| NOTE\n+\n+fn main() {\n+    needs_ptr(foo);\n+    //~^ ERROR mismatched types\n+    //~| NOTE expected `u32`, found `i32`\n+    //~| NOTE expected fn pointer `fn(i32, u32)`\n+    //~| NOTE arguments to this function are incorrect\n+}"}, {"sha": "6260fc8dcec528fb0b81e2f78a91341b4b3d6294", "filename": "src/test/ui/fn/signature-error-reporting-under-verbose.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Ffn%2Fsignature-error-reporting-under-verbose.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Ffn%2Fsignature-error-reporting-under-verbose.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fsignature-error-reporting-under-verbose.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/signature-error-reporting-under-verbose.rs:10:15\n+   |\n+LL |     needs_ptr(foo);\n+   |     --------- ^^^ expected `u32`, found `i32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected fn pointer `fn(i32, u32)`\n+                 found fn item `fn(i32, i32) {foo}`\n+note: function defined here\n+  --> $DIR/signature-error-reporting-under-verbose.rs:5:4\n+   |\n+LL | fn needs_ptr(_: fn(i32, u32)) {}\n+   |    ^^^^^^^^^ ---------------\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "87bac519cf304868600d7e479c64ac7240b1047a", "filename": "src/test/ui/impl-trait/in-trait/where-clause.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n+\n+trait Foo<Item> {\n+    fn foo<'a>(&'a self) -> impl Debug\n+    where\n+        Item: 'a;\n+}\n+\n+impl<Item, D: Debug + Clone> Foo<Item> for D {\n+    fn foo<'a>(&'a self) -> impl Debug\n+    where\n+        Item: 'a,\n+    {\n+        self.clone()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f7547742ddcbed9d0638bc12d694c0221b34e707", "filename": "src/test/ui/inline-const/expr-with-block-err.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block-err.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,6 @@\n+#![feature(inline_const)]\n+\n+fn main() {\n+    const { 2 } - const { 1 };\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "6f7408f4e2a6aff3027dfb2d923880b8b51758ac", "filename": "src/test/ui/inline-const/expr-with-block-err.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block-err.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/expr-with-block-err.rs:4:13\n+   |\n+LL |     const { 2 } - const { 1 };\n+   |             ^ expected `()`, found integer\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "391872476fccdfff56c333e2638ab4037dbecff3", "filename": "src/test/ui/inline-const/expr-with-block.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-with-block.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+#![feature(inline_const)]\n+fn main() {\n+    match true {\n+        true => const {}\n+        false => ()\n+    }\n+    const {}\n+    ()\n+}"}, {"sha": "aa6f74cb5d45ae0ffd98fd5d231cd79d67198f91", "filename": "src/test/ui/issues/issue-35976.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fissues%2Fissue-35976.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fissues%2Fissue-35976.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35976.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,5 +1,9 @@\n+// revisions: imported unimported\n+//[imported] check-pass\n+\n mod private {\n     pub trait Future {\n+        //[unimported]~^^ HELP perhaps add a `use` for it\n         fn wait(&self) where Self: Sized;\n     }\n \n@@ -8,13 +12,13 @@ mod private {\n     }\n }\n \n-//use private::Future;\n+#[cfg(imported)]\n+use private::Future;\n \n fn bar(arg: Box<dyn private::Future>) {\n+    // Importing the trait means that we don't autoderef `Box<dyn Future>`\n     arg.wait();\n-    //~^ ERROR the `wait` method cannot be invoked on a trait object\n+    //[unimported]~^ ERROR the `wait` method cannot be invoked on a trait object\n }\n \n-fn main() {\n-\n-}\n+fn main() {}"}, {"sha": "5d61bb8ea379992abb59771028d5f1c466bc94f8", "filename": "src/test/ui/issues/issue-35976.unimported.stderr", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fissues%2Fissue-35976.unimported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fissues%2Fissue-35976.unimported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35976.unimported.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,11 +1,16 @@\n error: the `wait` method cannot be invoked on a trait object\n-  --> $DIR/issue-35976.rs:14:9\n+  --> $DIR/issue-35976.rs:20:9\n    |\n LL |         fn wait(&self) where Self: Sized;\n    |                                    ----- this has a `Sized` requirement\n ...\n LL |     arg.wait();\n    |         ^^^^\n+   |\n+help: another candidate was found in the following trait, perhaps add a `use` for it:\n+   |\n+LL | use private::Future;\n+   |\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/issues/issue-35976.stderr"}, {"sha": "a2581658920b9e2195281c84d0955b89ac40ceff", "filename": "src/test/ui/lint/issue-97094.nointerleaved.stderr", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftest%2Fui%2Flint%2Fissue-97094.nointerleaved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftest%2Fui%2Flint%2Fissue-97094.nointerleaved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-97094.nointerleaved.stderr?ref=faec28970f86f52ca37e0e8cec0a447ba2f1393b", "patch": "@@ -1,53 +0,0 @@\n-error: unknown lint: `nonex_lint_top_level`\n-  --> $DIR/issue-97094.rs:14:26\n-   |\n-LL | #![cfg_attr(all(), allow(nonex_lint_top_level))]\n-   |                          ^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/issue-97094.rs:10:9\n-   |\n-LL | #![deny(warnings)]\n-   |         ^^^^^^^^\n-   = note: `#[deny(unknown_lints)]` implied by `#[deny(warnings)]`\n-\n-error: lint `bare_trait_object` has been renamed to `bare_trait_objects`\n-  --> $DIR/issue-97094.rs:16:26\n-   |\n-LL | #![cfg_attr(all(), allow(bare_trait_object))]\n-   |                          ^^^^^^^^^^^^^^^^^ help: use the new name: `bare_trait_objects`\n-   |\n-   = note: `#[deny(renamed_and_removed_lints)]` implied by `#[deny(warnings)]`\n-\n-error: unknown lint: `nonex_lint_mod`\n-  --> $DIR/issue-97094.rs:19:25\n-   |\n-LL | #[cfg_attr(all(), allow(nonex_lint_mod))]\n-   |                         ^^^^^^^^^^^^^^\n-\n-error: unknown lint: `nonex_lint_mod_inner`\n-  --> $DIR/issue-97094.rs:22:30\n-   |\n-LL |     #![cfg_attr(all(), allow(nonex_lint_mod_inner))]\n-   |                              ^^^^^^^^^^^^^^^^^^^^\n-\n-error: unknown lint: `nonex_lint_fn`\n-  --> $DIR/issue-97094.rs:26:25\n-   |\n-LL | #[cfg_attr(all(), allow(nonex_lint_fn))]\n-   |                         ^^^^^^^^^^^^^\n-\n-error: unknown lint: `nonex_lint_in_macro`\n-  --> $DIR/issue-97094.rs:37:29\n-   |\n-LL |     #[cfg_attr(all(), allow(nonex_lint_in_macro))]\n-   |                             ^^^^^^^^^^^^^^^^^^^\n-\n-error: unknown lint: `nonex_lint_fn`\n-  --> $DIR/issue-97094.rs:56:13\n-   |\n-LL |     #[allow(nonex_lint_fn)]\n-   |             ^^^^^^^^^^^^^\n-\n-error: aborting due to 7 previous errors\n-"}, {"sha": "22525ca11ae04cefa3abbb465c9beb527e49cc30", "filename": "src/test/ui/lint/issue-97094.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Flint%2Fissue-97094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Flint%2Fissue-97094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-97094.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,12 +1,3 @@\n-// revisions: interleaved nointerleaved\n-// [nointerleaved]compile-flags: -Z no-interleave-lints\n-\n-// This test has two revisions because the logic change\n-// needed to make this test pass had to be adjusted\n-// for no-interleave-lints. Should the debug option\n-// be removed one day, please don't remove this\n-// test entirely, just remove the revision from it.\n-\n #![deny(warnings)]\n \n // Ensure that unknown lints inside cfg-attr's are linted for"}, {"sha": "1a0a3eaf25077d407e96bf4455cd240dc6747cf2", "filename": "src/test/ui/lint/issue-97094.stderr", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Flint%2Fissue-97094.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Flint%2Fissue-97094.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-97094.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,50 +1,50 @@\n error: unknown lint: `nonex_lint_top_level`\n-  --> $DIR/issue-97094.rs:14:26\n+  --> $DIR/issue-97094.rs:5:26\n    |\n LL | #![cfg_attr(all(), allow(nonex_lint_top_level))]\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/issue-97094.rs:10:9\n+  --> $DIR/issue-97094.rs:1:9\n    |\n LL | #![deny(warnings)]\n    |         ^^^^^^^^\n    = note: `#[deny(unknown_lints)]` implied by `#[deny(warnings)]`\n \n error: lint `bare_trait_object` has been renamed to `bare_trait_objects`\n-  --> $DIR/issue-97094.rs:16:26\n+  --> $DIR/issue-97094.rs:7:26\n    |\n LL | #![cfg_attr(all(), allow(bare_trait_object))]\n    |                          ^^^^^^^^^^^^^^^^^ help: use the new name: `bare_trait_objects`\n    |\n    = note: `#[deny(renamed_and_removed_lints)]` implied by `#[deny(warnings)]`\n \n error: unknown lint: `nonex_lint_mod`\n-  --> $DIR/issue-97094.rs:19:25\n+  --> $DIR/issue-97094.rs:10:25\n    |\n LL | #[cfg_attr(all(), allow(nonex_lint_mod))]\n    |                         ^^^^^^^^^^^^^^\n \n error: unknown lint: `nonex_lint_mod_inner`\n-  --> $DIR/issue-97094.rs:22:30\n+  --> $DIR/issue-97094.rs:13:30\n    |\n LL |     #![cfg_attr(all(), allow(nonex_lint_mod_inner))]\n    |                              ^^^^^^^^^^^^^^^^^^^^\n \n error: unknown lint: `nonex_lint_fn`\n-  --> $DIR/issue-97094.rs:26:25\n+  --> $DIR/issue-97094.rs:17:25\n    |\n LL | #[cfg_attr(all(), allow(nonex_lint_fn))]\n    |                         ^^^^^^^^^^^^^\n \n error: unknown lint: `nonex_lint_in_macro`\n-  --> $DIR/issue-97094.rs:37:29\n+  --> $DIR/issue-97094.rs:28:29\n    |\n LL |     #[cfg_attr(all(), allow(nonex_lint_in_macro))]\n    |                             ^^^^^^^^^^^^^^^^^^^\n \n error: unknown lint: `nonex_lint_fn`\n-  --> $DIR/issue-97094.rs:56:13\n+  --> $DIR/issue-97094.rs:47:13\n    |\n LL |     #[allow(nonex_lint_fn)]\n    |             ^^^^^^^^^^^^^", "previous_filename": "src/test/ui/lint/issue-97094.interleaved.stderr"}, {"sha": "fa05baed7fc8e40ee5eadcef11b2a1055cea9082", "filename": "src/test/ui/macros/issue-103529.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fmacros%2Fissue-103529.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fmacros%2Fissue-103529.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-103529.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,13 @@\n+macro_rules! m {\n+    ($s:stmt) => {}\n+}\n+\n+m! { mut x }\n+//~^ ERROR expected expression, found keyword `mut`\n+//~| ERROR expected a statement\n+m! { auto x }\n+//~^ ERROR invalid variable declaration\n+m! { var x }\n+//~^ ERROR invalid variable declaration\n+\n+fn main() {}"}, {"sha": "61e322afc770986faaed5e35b5423ef67913ac25", "filename": "src/test/ui/macros/issue-103529.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fmacros%2Fissue-103529.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fmacros%2Fissue-103529.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-103529.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,39 @@\n+error: expected expression, found keyword `mut`\n+  --> $DIR/issue-103529.rs:5:6\n+   |\n+LL | m! { mut x }\n+   |      ^^^ expected expression\n+\n+error: expected a statement\n+  --> $DIR/issue-103529.rs:5:10\n+   |\n+LL |     ($s:stmt) => {}\n+   |      ------- while parsing argument for this `stmt` macro fragment\n+...\n+LL | m! { mut x }\n+   |          ^\n+\n+error: invalid variable declaration\n+  --> $DIR/issue-103529.rs:8:6\n+   |\n+LL | m! { auto x }\n+   |      ^^^^\n+   |\n+help: write `let` instead of `auto` to introduce a new variable\n+   |\n+LL | m! { let x }\n+   |      ~~~\n+\n+error: invalid variable declaration\n+  --> $DIR/issue-103529.rs:10:6\n+   |\n+LL | m! { var x }\n+   |      ^^^\n+   |\n+help: write `let` instead of `var` to introduce a new variable\n+   |\n+LL | m! { let x }\n+   |      ~~~\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "7a9b8469c9e19ebfdffa471c6b834f976e6b5c52", "filename": "src/test/ui/query-system/fn-sig-cycle-arity.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fquery-system%2Ffn-sig-cycle-arity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fquery-system%2Ffn-sig-cycle-arity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquery-system%2Ffn-sig-cycle-arity.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,8 @@\n+trait Dancer {\n+    fn dance(&self) -> _ {\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+        self.dance()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "67e0c2545515eb402f7dd479034a44a1c39146d8", "filename": "src/test/ui/query-system/fn-sig-cycle-arity.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fquery-system%2Ffn-sig-cycle-arity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fquery-system%2Ffn-sig-cycle-arity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquery-system%2Ffn-sig-cycle-arity.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,9 @@\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n+  --> $DIR/fn-sig-cycle-arity.rs:2:24\n+   |\n+LL |     fn dance(&self) -> _ {\n+   |                        ^ not allowed in type signatures\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0121`."}, {"sha": "558760c6793ab08dc34bdde3589725466ba53d91", "filename": "src/test/ui/resolve/bad-module.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fbad-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fbad-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fbad-module.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,15 +1,15 @@\n-error[E0433]: failed to resolve: use of undeclared crate or module `thing`\n-  --> $DIR/bad-module.rs:2:15\n-   |\n-LL |     let foo = thing::len(Vec::new());\n-   |               ^^^^^ use of undeclared crate or module `thing`\n-\n error[E0433]: failed to resolve: use of undeclared crate or module `foo`\n   --> $DIR/bad-module.rs:5:15\n    |\n LL |     let foo = foo::bar::baz();\n    |               ^^^ use of undeclared crate or module `foo`\n \n+error[E0433]: failed to resolve: use of undeclared crate or module `thing`\n+  --> $DIR/bad-module.rs:2:15\n+   |\n+LL |     let foo = thing::len(Vec::new());\n+   |               ^^^^^ use of undeclared crate or module `thing`\n+\n error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0433`."}, {"sha": "4d3d469447c2b9b20519bc079c1e32f6cf5ed7c2", "filename": "src/test/ui/resolve/issue-101749-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-101749-2.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,16 @@\n+struct Rectangle {\n+    width: i32,\n+    height: i32,\n+}\n+impl Rectangle {\n+    fn new(width: i32, height: i32) -> Self {\n+        Self { width, height }\n+    }\n+}\n+\n+fn main() {\n+    let rect = Rectangle::new(3, 4);\n+    // `area` is not implemented for `Rectangle`, so this should not suggest\n+    let _ = rect::area();\n+    //~^ ERROR failed to resolve: use of undeclared crate or module `rect`\n+}"}, {"sha": "370d4b14540d634c4f2b5e32f037823d126d7f10", "filename": "src/test/ui/resolve/issue-101749-2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-101749-2.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: use of undeclared crate or module `rect`\n+  --> $DIR/issue-101749-2.rs:14:13\n+   |\n+LL |     let _ = rect::area();\n+   |             ^^^^ use of undeclared crate or module `rect`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "3e5544296e462f4653e24aa8c5b88359a46bf874", "filename": "src/test/ui/resolve/issue-101749.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.fixed?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+struct Rectangle {\n+    width: i32,\n+    height: i32,\n+}\n+impl Rectangle {\n+    fn new(width: i32, height: i32) -> Self {\n+        Self { width, height }\n+    }\n+    fn area(&self) -> i32 {\n+        self.height * self.width\n+    }\n+}\n+\n+fn main() {\n+    let rect = Rectangle::new(3, 4);\n+    let _ = rect.area();\n+    //~^ ERROR failed to resolve: use of undeclared crate or module `rect`\n+}"}, {"sha": "fd67ccab6fa7522c80a0199a8bcdf9ff8f28b3af", "filename": "src/test/ui/resolve/issue-101749.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+struct Rectangle {\n+    width: i32,\n+    height: i32,\n+}\n+impl Rectangle {\n+    fn new(width: i32, height: i32) -> Self {\n+        Self { width, height }\n+    }\n+    fn area(&self) -> i32 {\n+        self.height * self.width\n+    }\n+}\n+\n+fn main() {\n+    let rect = Rectangle::new(3, 4);\n+    let _ = rect::area();\n+    //~^ ERROR failed to resolve: use of undeclared crate or module `rect`\n+}"}, {"sha": "dd29d7fc051039a477700735a19acfeb7211798f", "filename": "src/test/ui/resolve/issue-101749.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-101749.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,14 @@\n+error[E0433]: failed to resolve: use of undeclared crate or module `rect`\n+  --> $DIR/issue-101749.rs:17:13\n+   |\n+LL |     let _ = rect::area();\n+   |             ^^^^ use of undeclared crate or module `rect`\n+   |\n+help: you may have meant to call an instance method\n+   |\n+LL |     let _ = rect.area();\n+   |                 ~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "73455cf7711c6b623c5c4c316755629903698852", "filename": "src/test/ui/resolve/issue-105069.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,11 @@\n+use self::A::*;\n+use V; //~ ERROR `V` is ambiguous\n+use self::B::*;\n+enum A {\n+    V\n+}\n+enum B {\n+    V\n+}\n+\n+fn main() {}"}, {"sha": "1e6c9c6e2dc34fa9b331b60a763f55dc119dc4ed", "filename": "src/test/ui/resolve/issue-105069.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,21 @@\n+error[E0659]: `V` is ambiguous\n+  --> $DIR/issue-105069.rs:2:5\n+   |\n+LL | use V;\n+   |     ^ ambiguous name\n+   |\n+   = note: ambiguous because of multiple potential import sources\n+note: `V` could refer to the variant imported here\n+  --> $DIR/issue-105069.rs:1:5\n+   |\n+LL | use self::A::*;\n+   |     ^^^^^^^^^^\n+note: `V` could also refer to the variant imported here\n+  --> $DIR/issue-105069.rs:3:5\n+   |\n+LL | use self::B::*;\n+   |     ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "82f5a1d5b57b3a167741b4600fe18a6dc9486846", "filename": "src/test/ui/resolve/issue-24968.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-24968.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fissue-24968.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-24968.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,15 +1,3 @@\n-error[E0433]: failed to resolve: `Self` is only available in impls, traits, and type definitions\n-  --> $DIR/issue-24968.rs:21:19\n-   |\n-LL | const FOO2: u32 = Self::bar();\n-   |                   ^^^^ `Self` is only available in impls, traits, and type definitions\n-\n-error[E0433]: failed to resolve: `Self` is only available in impls, traits, and type definitions\n-  --> $DIR/issue-24968.rs:27:22\n-   |\n-LL | static FOO_S2: u32 = Self::bar();\n-   |                      ^^^^ `Self` is only available in impls, traits, and type definitions\n-\n error[E0411]: cannot find type `Self` in this scope\n   --> $DIR/issue-24968.rs:3:11\n    |\n@@ -51,6 +39,18 @@ LL | static FOO_S: Self = 0;\n    |        |\n    |        `Self` not allowed in a static item\n \n+error[E0433]: failed to resolve: `Self` is only available in impls, traits, and type definitions\n+  --> $DIR/issue-24968.rs:21:19\n+   |\n+LL | const FOO2: u32 = Self::bar();\n+   |                   ^^^^ `Self` is only available in impls, traits, and type definitions\n+\n+error[E0433]: failed to resolve: `Self` is only available in impls, traits, and type definitions\n+  --> $DIR/issue-24968.rs:27:22\n+   |\n+LL | static FOO_S2: u32 = Self::bar();\n+   |                      ^^^^ `Self` is only available in impls, traits, and type definitions\n+\n error: aborting due to 7 previous errors\n \n Some errors have detailed explanations: E0411, E0433."}, {"sha": "89b69e1409967544f917a7bb296e3843210dc5e0", "filename": "src/test/ui/resolve/typo-suggestion-mistyped-in-path.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftypo-suggestion-mistyped-in-path.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,3 +1,24 @@\n+error[E0433]: failed to resolve: could not find `Struc` in `module`\n+  --> $DIR/typo-suggestion-mistyped-in-path.rs:35:13\n+   |\n+LL |     module::Struc::foo();\n+   |             ^^^^^\n+   |             |\n+   |             could not find `Struc` in `module`\n+   |             help: a struct with a similar name exists: `Struct`\n+\n+error[E0599]: no function or associated item named `fob` found for struct `Struct` in the current scope\n+  --> $DIR/typo-suggestion-mistyped-in-path.rs:23:13\n+   |\n+LL | struct Struct;\n+   | ------------- function or associated item `fob` not found for this struct\n+...\n+LL |     Struct::fob();\n+   |             ^^^\n+   |             |\n+   |             function or associated item not found in `Struct`\n+   |             help: there is an associated function with a similar name: `foo`\n+\n error[E0433]: failed to resolve: use of undeclared type `Struc`\n   --> $DIR/typo-suggestion-mistyped-in-path.rs:27:5\n    |\n@@ -18,15 +39,6 @@ help: there is a crate or module with a similar name\n LL |     module::foo();\n    |     ~~~~~~\n \n-error[E0433]: failed to resolve: could not find `Struc` in `module`\n-  --> $DIR/typo-suggestion-mistyped-in-path.rs:35:13\n-   |\n-LL |     module::Struc::foo();\n-   |             ^^^^^\n-   |             |\n-   |             could not find `Struc` in `module`\n-   |             help: a struct with a similar name exists: `Struct`\n-\n error[E0433]: failed to resolve: use of undeclared type `Trai`\n   --> $DIR/typo-suggestion-mistyped-in-path.rs:39:5\n    |\n@@ -36,18 +48,6 @@ LL |     Trai::foo();\n    |     use of undeclared type `Trai`\n    |     help: a trait with a similar name exists: `Trait`\n \n-error[E0599]: no function or associated item named `fob` found for struct `Struct` in the current scope\n-  --> $DIR/typo-suggestion-mistyped-in-path.rs:23:13\n-   |\n-LL | struct Struct;\n-   | ------------- function or associated item `fob` not found for this struct\n-...\n-LL |     Struct::fob();\n-   |             ^^^\n-   |             |\n-   |             function or associated item not found in `Struct`\n-   |             help: there is an associated function with a similar name: `foo`\n-\n error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0433, E0599."}, {"sha": "54ad853831f368bbf1dcba37ee673abfd8cec7d4", "filename": "src/test/ui/resolve/use_suggestion.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,9 +1,3 @@\n-error[E0433]: failed to resolve: use of undeclared type `GooMap`\n-  --> $DIR/use_suggestion.rs:3:14\n-   |\n-LL |     let x2 = GooMap::new();\n-   |              ^^^^^^ use of undeclared type `GooMap`\n-\n error[E0433]: failed to resolve: use of undeclared type `HashMap`\n   --> $DIR/use_suggestion.rs:2:14\n    |\n@@ -32,6 +26,12 @@ error[E0412]: cannot find type `GooMap` in this scope\n LL |     let y2: GooMap;\n    |             ^^^^^^ not found in this scope\n \n+error[E0433]: failed to resolve: use of undeclared type `GooMap`\n+  --> $DIR/use_suggestion.rs:3:14\n+   |\n+LL |     let x2 = GooMap::new();\n+   |              ^^^^^^ use of undeclared type `GooMap`\n+\n error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0412, E0433."}, {"sha": "f46e088b85f7201a46911fa4b19092bf6d48469d", "filename": "src/test/ui/return/tail-expr-as-potential-return.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -12,7 +12,6 @@\n // edition:2018\n \n fn main() {\n-    let _ = foo(true);\n }\n \n fn foo(x: bool) -> Result<f64, i32> {\n@@ -30,3 +29,19 @@ async fn bar(x: bool) -> Result<f64, i32> {\n     }\n     Ok(42.0)\n }\n+\n+trait Identity {\n+    type Out;\n+}\n+\n+impl<T> Identity for T {\n+    type Out = T;\n+}\n+\n+async fn foo2() -> i32 {\n+    if true {\n+        1i32 //~ ERROR mismatched types\n+            //| HELP you might have meant to return this value\n+    }\n+    0\n+}"}, {"sha": "9183b4599ba6dafb238f94d2aba435476ba30887", "filename": "src/test/ui/return/tail-expr-as-potential-return.stderr", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/tail-expr-as-potential-return.rs:28:9\n+  --> $DIR/tail-expr-as-potential-return.rs:27:9\n    |\n LL | /     if x {\n LL | |         Err(42)\n@@ -16,7 +16,22 @@ LL |         return Err(42);\n    |         ++++++        +\n \n error[E0308]: mismatched types\n-  --> $DIR/tail-expr-as-potential-return.rs:20:9\n+  --> $DIR/tail-expr-as-potential-return.rs:43:9\n+   |\n+LL | /     if true {\n+LL | |         1i32\n+   | |         ^^^^ expected `()`, found `i32`\n+LL | |             //| HELP you might have meant to return this value\n+LL | |     }\n+   | |_____- expected this to be `()`\n+   |\n+help: you might have meant to return this value\n+   |\n+LL |         return 1i32;\n+   |         ++++++     +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/tail-expr-as-potential-return.rs:19:9\n    |\n LL | /     if x {\n LL | |         Err(42)\n@@ -32,6 +47,6 @@ help: you might have meant to return this value\n LL |         return Err(42);\n    |         ++++++        +\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "b604c65d75100cec2cc491e547522e23dd4a4c42", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-79450.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-79450.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-79450.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-79450.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,20 @@\n+#![feature(const_fmt_arguments_new)]\n+#![feature(const_trait_impl)]\n+\n+#[const_trait]\n+trait Tr {\n+    fn req(&self);\n+\n+    fn prov(&self) {\n+        println!(\"lul\"); //~ ERROR: cannot call non-const fn `_print` in constant functions\n+        self.req();\n+    }\n+}\n+\n+struct S;\n+\n+impl const Tr for S {\n+    fn req(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "082c0333fbfcdfd7130f72297becd8d915a607c4", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-79450.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-79450.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-79450.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-79450.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,12 @@\n+error[E0015]: cannot call non-const fn `_print` in constant functions\n+  --> $DIR/issue-79450.rs:9:9\n+   |\n+LL |         println!(\"lul\");\n+   |         ^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "4b4595dd5e6a5e70fce2e754b5532f44f50eb8a9", "filename": "src/test/ui/suggestions/assoc-const-as-fn.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,18 @@\n+unsafe fn pointer(v: usize, w: u32) {}\n+\n+pub trait UniformScalar {}\n+impl UniformScalar for u32 {}\n+\n+pub trait GlUniformScalar: UniformScalar {\n+    const FACTORY: unsafe fn(usize, Self) -> ();\n+}\n+impl GlUniformScalar for u32 {\n+    const FACTORY: unsafe fn(usize, Self) -> () = pointer;\n+}\n+\n+pub fn foo<T: UniformScalar>(value: T) {\n+    <T as GlUniformScalar>::FACTORY(1, value);\n+    //~^ ERROR the trait bound `T: GlUniformScalar` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "fa740687858275b0ba5bad5c15ff31cacaacc3cb", "filename": "src/test/ui/suggestions/assoc-const-as-fn.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the trait bound `T: GlUniformScalar` is not satisfied\n+  --> $DIR/assoc-const-as-fn.rs:14:5\n+   |\n+LL |     <T as GlUniformScalar>::FACTORY(1, value);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `GlUniformScalar` is not implemented for `T`\n+   |\n+help: consider further restricting this bound\n+   |\n+LL | pub fn foo<T: UniformScalar + GlUniformScalar>(value: T) {\n+   |                             +++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "98b88b4fb9202cc7d5ccbe50e6f81e3278dad298", "filename": "src/test/ui/suggestions/crate-or-module-typo.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fsuggestions%2Fcrate-or-module-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fsuggestions%2Fcrate-or-module-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcrate-or-module-typo.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -20,12 +20,6 @@ help: there is a crate or module with a similar name\n LL | use bar::bar;\n    |     ~~~\n \n-error[E0433]: failed to resolve: use of undeclared crate or module `bar`\n-  --> $DIR/crate-or-module-typo.rs:6:20\n-   |\n-LL |     pub fn bar() { bar::baz(); }\n-   |                    ^^^ use of undeclared crate or module `bar`\n-\n error[E0433]: failed to resolve: use of undeclared crate or module `st`\n   --> $DIR/crate-or-module-typo.rs:14:10\n    |\n@@ -37,6 +31,12 @@ help: there is a crate or module with a similar name\n LL |     bar: std::cell::Cell<bool>\n    |          ~~~\n \n+error[E0433]: failed to resolve: use of undeclared crate or module `bar`\n+  --> $DIR/crate-or-module-typo.rs:6:20\n+   |\n+LL |     pub fn bar() { bar::baz(); }\n+   |                    ^^^ use of undeclared crate or module `bar`\n+\n error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0432, E0433."}, {"sha": "0d9543e0b8fa22d61ae4280b051aabe571f7aeef", "filename": "src/test/ui/suggestions/dont-suggest-ufcs-for-const.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -2,13 +2,7 @@ error[E0599]: no method named `MAX` found for type `u32` in the current scope\n   --> $DIR/dont-suggest-ufcs-for-const.rs:2:11\n    |\n LL |     1_u32.MAX();\n-   |     ------^^^--\n-   |     |     |\n-   |     |     this is an associated function, not a method\n-   |     help: use associated function syntax instead: `u32::MAX()`\n-   |\n-   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n-   = note: the candidate is defined in an impl for the type `u32`\n+   |           ^^^ method not found in `u32`\n \n error: aborting due to previous error\n "}, {"sha": "e5d0a1aaed049f442b39a6b186fe9ccf3e54db35", "filename": "src/test/ui/trait-bounds/impl-bound-with-references-error.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-bound-with-references-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-bound-with-references-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-bound-with-references-error.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #105138.\n+// This test ensures that the compiler does not add note\n+// for implementation of trait whose inner type is erroneous.\n+\n+pub enum LabelText {\n+    Plain,\n+}\n+\n+impl<T> From<T> for LabelText\n+//~^ ERROR conflicting implementations of trait `From<LabelText>` for type `LabelText` [E0119]\n+where\n+    T: Into<Cow<'static, str>>,\n+    //~^ ERROR cannot find type `Cow` in this scope [E0412]\n+{\n+    fn from(text: T) -> Self {\n+        LabelText::Plain(text.into())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "95fd6bd504cdd1ab61109bc79a48ba1c23d20d58", "filename": "src/test/ui/trait-bounds/impl-bound-with-references-error.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-bound-with-references-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-bound-with-references-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-bound-with-references-error.stderr?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,24 @@\n+error[E0412]: cannot find type `Cow` in this scope\n+  --> $DIR/impl-bound-with-references-error.rs:12:13\n+   |\n+LL |     T: Into<Cow<'static, str>>,\n+   |             ^^^ not found in this scope\n+   |\n+help: consider importing this enum\n+   |\n+LL | use std::borrow::Cow;\n+   |\n+\n+error[E0119]: conflicting implementations of trait `From<LabelText>` for type `LabelText`\n+  --> $DIR/impl-bound-with-references-error.rs:9:1\n+   |\n+LL | impl<T> From<T> for LabelText\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: conflicting implementation in crate `core`:\n+           - impl<T> From<T> for T;\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0119, E0412.\n+For more information about an error, try `rustc --explain E0119`."}, {"sha": "f6e737b1e3386adb89333bf06a01f68a91ac5306", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1 +1 @@\n-Subproject commit e027c4b5d25af2119b1956fac42863b9b3242744\n+Subproject commit f6e737b1e3386adb89333bf06a01f68a91ac5306"}, {"sha": "91c701a5ddd2e469b9115fc02af7eab28dd5349e", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -514,6 +514,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         options: test::Options::new(),\n         time_options: None,\n         force_run_in_process: false,\n+        fail_fast: std::env::var_os(\"RUSTC_TEST_FAIL_FAST\").is_some(),\n     }\n }\n "}, {"sha": "e15f5fe3ccc968d46d295534015c3831d0ebff85", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -60,6 +60,8 @@ impl<'a> Validator<'a> {\n \n     fn check_item(&mut self, id: &'a Id) {\n         if let Some(item) = &self.krate.index.get(id) {\n+            item.links.values().for_each(|id| self.add_any_id(id));\n+\n             match &item.inner {\n                 ItemEnum::Import(x) => self.check_import(x),\n                 ItemEnum::Union(x) => self.check_union(x),\n@@ -376,6 +378,10 @@ impl<'a> Validator<'a> {\n         }\n     }\n \n+    fn add_any_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, |_| true, \"any kind of item\");\n+    }\n+\n     fn add_field_id(&mut self, id: &'a Id) {\n         self.add_id_checked(id, Kind::is_struct_field, \"StructField\");\n     }\n@@ -446,3 +452,6 @@ fn set_remove<T: Hash + Eq + Clone>(set: &mut HashSet<T>) -> Option<T> {\n         None\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "c4aeee9c53b760162af70925c189148d2fed723c", "filename": "src/tools/jsondoclint/src/validator/tests.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -0,0 +1,50 @@\n+use std::collections::HashMap;\n+\n+use rustdoc_json_types::{Crate, Item, Visibility};\n+\n+use super::*;\n+\n+#[track_caller]\n+fn check(krate: &Crate, errs: &[Error]) {\n+    let mut validator = Validator::new(krate);\n+    validator.check_crate();\n+\n+    assert_eq!(errs, &validator.errs[..]);\n+}\n+\n+fn id(s: &str) -> Id {\n+    Id(s.to_owned())\n+}\n+\n+#[test]\n+fn errors_on_missing_links() {\n+    let k = Crate {\n+        root: id(\"0\"),\n+        crate_version: None,\n+        includes_private: false,\n+        index: HashMap::from_iter([(\n+            id(\"0\"),\n+            Item {\n+                name: Some(\"root\".to_owned()),\n+                id: id(\"\"),\n+                crate_id: 0,\n+                span: None,\n+                visibility: Visibility::Public,\n+                docs: None,\n+                links: HashMap::from_iter([(\"Not Found\".to_owned(), id(\"1\"))]),\n+                attrs: vec![],\n+                deprecation: None,\n+                inner: ItemEnum::Module(Module {\n+                    is_crate: true,\n+                    items: vec![],\n+                    is_stripped: false,\n+                }),\n+            },\n+        )]),\n+        paths: HashMap::new(),\n+        external_crates: HashMap::new(),\n+        format_version: rustdoc_json_types::FORMAT_VERSION,\n+    };\n+\n+    check(&k, &[Error { kind: ErrorKind::NotFound, id: id(\"1\") }]);\n+}"}, {"sha": "8dd18ae98e6d62304a55fc6417ac2f021fbd4fef", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -1 +1 @@\n-cef44f53034eac46be3a0e3eec7b2b3d4ef5140b\n+203c8765ea33c65d888febe0e8219c4bb11b0d89"}, {"sha": "244d4427c562359c695f7095ab936cdd3ba3be21", "filename": "src/tools/rustfmt/src/closures.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -335,6 +335,7 @@ pub(crate) fn rewrite_last_closure(\n             ref fn_decl,\n             ref body,\n             fn_decl_span: _,\n+            fn_arg_span: _,\n         } = **closure;\n         let body = match body.kind {\n             ast::ExprKind::Block(ref block, _)"}, {"sha": "ff7a219d9bd8518d43cfacf60bb285127b59212c", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b63c1619498f1a17fd482f4bb87815d8fdc48/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=552b63c1619498f1a17fd482f4bb87815d8fdc48", "patch": "@@ -31,23 +31,25 @@ const LICENSES: &[&str] = &[\n /// tooling. It is _crucial_ that no exception crates be dependencies\n /// of the Rust runtime (std/test).\n const EXCEPTIONS: &[(&str, &str)] = &[\n-    (\"mdbook\", \"MPL-2.0\"),            // mdbook\n-    (\"openssl\", \"Apache-2.0\"),        // cargo, mdbook\n-    (\"colored\", \"MPL-2.0\"),           // rustfmt\n-    (\"ryu\", \"Apache-2.0 OR BSL-1.0\"), // cargo/... (because of serde)\n-    (\"bytesize\", \"Apache-2.0\"),       // cargo\n-    (\"im-rc\", \"MPL-2.0+\"),            // cargo\n-    (\"sized-chunks\", \"MPL-2.0+\"),     // cargo via im-rc\n-    (\"bitmaps\", \"MPL-2.0+\"),          // cargo via im-rc\n-    (\"instant\", \"BSD-3-Clause\"),      // rustc_driver/tracing-subscriber/parking_lot\n-    (\"snap\", \"BSD-3-Clause\"),         // rustc\n+    (\"ar_archive_writer\", \"Apache-2.0 WITH LLVM-exception\"), // rustc\n+    (\"mdbook\", \"MPL-2.0\"),                                   // mdbook\n+    (\"openssl\", \"Apache-2.0\"),                               // cargo, mdbook\n+    (\"colored\", \"MPL-2.0\"),                                  // rustfmt\n+    (\"ryu\", \"Apache-2.0 OR BSL-1.0\"),                        // cargo/... (because of serde)\n+    (\"bytesize\", \"Apache-2.0\"),                              // cargo\n+    (\"im-rc\", \"MPL-2.0+\"),                                   // cargo\n+    (\"sized-chunks\", \"MPL-2.0+\"),                            // cargo via im-rc\n+    (\"bitmaps\", \"MPL-2.0+\"),                                 // cargo via im-rc\n+    (\"instant\", \"BSD-3-Clause\"), // rustc_driver/tracing-subscriber/parking_lot\n+    (\"snap\", \"BSD-3-Clause\"),    // rustc\n     (\"fluent-langneg\", \"Apache-2.0\"), // rustc (fluent translations)\n-    (\"self_cell\", \"Apache-2.0\"),      // rustc (fluent translations)\n+    (\"self_cell\", \"Apache-2.0\"), // rustc (fluent translations)\n     // FIXME: this dependency violates the documentation comment above:\n     (\"fortanix-sgx-abi\", \"MPL-2.0\"), // libstd but only for `sgx` target\n     (\"dunce\", \"CC0-1.0\"),            // cargo (dev dependency)\n     (\"similar\", \"Apache-2.0\"),       // cargo (dev dependency)\n     (\"normalize-line-endings\", \"Apache-2.0\"), // cargo (dev dependency)\n+    (\"dissimilar\", \"Apache-2.0\"),    // rustdoc, rustc_lexer (few tests) via expect-test, (dev deps)\n ];\n \n const EXCEPTIONS_CRANELIFT: &[(&str, &str)] = &[\n@@ -86,6 +88,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"aho-corasick\",\n     \"annotate-snippets\",\n     \"ansi_term\",\n+    \"ar_archive_writer\",\n     \"arrayvec\",\n     \"atty\",\n     \"autocfg\",\n@@ -110,9 +113,9 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"cstr\",\n     \"datafrog\",\n     \"derive_more\",\n-    \"difference\",\n     \"digest\",\n     \"displaydoc\",\n+    \"dissimilar\",\n     \"dlmalloc\",\n     \"either\",\n     \"ena\",\n@@ -276,7 +279,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n     \"ahash\",\n     \"anyhow\",\n-    \"ar\",\n     \"arrayvec\",\n     \"autocfg\",\n     \"bumpalo\","}]}