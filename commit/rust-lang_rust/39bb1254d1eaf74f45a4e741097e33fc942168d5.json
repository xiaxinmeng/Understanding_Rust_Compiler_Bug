{"sha": "39bb1254d1eaf74f45a4e741097e33fc942168d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YmIxMjU0ZDFlYWY3NGY0NWE0ZTc0MTA5N2UzM2ZjOTQyMTY4ZDU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-19T03:02:37Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-19T03:02:37Z"}, "message": "Fix write_value of ByVal into a ByRef.\n\nPreviously, you could perform the following, if you assume we could make\n`Cell<i32>` into a primitive. (Alternately, you could achieve this with\nunsafe code):\n\n    x = Cell::new(12);\n    y = &x;\n\n    // Miri locals array:\n    //   x = ByRef(alloc123);\n    //   y = ByVal(Ptr(alloc123));\n    //\n    // Miri allocations:\n    //   alloc123: [12, 0, 0, 0]\n\n    x.set(42);\n\n    // Miri locals array:\n    //   x = ByVal(I32(42));\n    //   y = ByVal(Ptr(alloc123));\n    //\n    // Miri allocations:\n    //   alloc123: [12, 0, 0, 0]\n\nNotice how `y` still refers to the allocation that used to represent\n`x`. But now `x` was changed to `42` and `y` is still looking at memory\ncontaining `12`.\n\nNow, instead, we keep `x` as a `ByRef` and write the `42` constant into\nit.\n\nUnit test to follow in the next commit.", "tree": {"sha": "b69f66d1896aa28d70314002c6d77352082bab39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b69f66d1896aa28d70314002c6d77352082bab39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39bb1254d1eaf74f45a4e741097e33fc942168d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39bb1254d1eaf74f45a4e741097e33fc942168d5", "html_url": "https://github.com/rust-lang/rust/commit/39bb1254d1eaf74f45a4e741097e33fc942168d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39bb1254d1eaf74f45a4e741097e33fc942168d5/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5c0a24bb05381bb94051d4da8e9ebf66d6a4025", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c0a24bb05381bb94051d4da8e9ebf66d6a4025", "html_url": "https://github.com/rust-lang/rust/commit/f5c0a24bb05381bb94051d4da8e9ebf66d6a4025"}], "stats": {"total": 47, "additions": 34, "deletions": 13}, "files": [{"sha": "fccc90aa89ad3b18625d14460e912b1cfd6f0816", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/39bb1254d1eaf74f45a4e741097e33fc942168d5/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39bb1254d1eaf74f45a4e741097e33fc942168d5/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=39bb1254d1eaf74f45a4e741097e33fc942168d5", "patch": "@@ -1156,29 +1156,50 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn write_value(\n         &mut self,\n-        value: Value,\n+        src_val: Value,\n         dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         match dest {\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.write_value_to_ptr(value, ptr, dest_ty)?;\n+                self.write_value_to_ptr(src_val, ptr, dest_ty)?;\n             }\n+\n+            // The cases here can be a bit subtle. Read carefully!\n             Lvalue::Local { frame, local } => {\n-                if let Value::ByRef(src_ptr) = value {\n-                    let dest_val = self.stack[frame].get_local(local);\n-                    let dest_ptr = if let Some(Value::ByRef(ptr)) = dest_val {\n-                        ptr\n-                    } else {\n-                        let ptr = self.alloc_ptr(dest_ty)?;\n-                        self.stack[frame].set_local(local, Value::ByRef(ptr));\n-                        ptr\n-                    };\n+                let dest_val = self.stack[frame].get_local(local);\n+\n+                if let Some(Value::ByRef(dest_ptr)) = dest_val {\n+                    // If the local value is already `ByRef` (that is, backed by an `Allocation`),\n+                    // then we must write the new value into this allocation, because there may be\n+                    // other pointers into the allocation. These other pointers are logically\n+                    // pointers into the local variable, and must be able to observe the change.\n+                    //\n+                    // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n+                    // knew for certain that there were no outstanding pointers to this local.\n+                    self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n+\n+                } else if let Value::ByRef(src_ptr) = src_val {\n+                    // If the local value is not `ByRef`, then we know there are no pointers to it\n+                    // and we can simply overwrite the `Value` in the locals array directly.\n+                    //\n+                    // In this specific case, where the source value is `ByRef`, we must duplicate\n+                    // the allocation, because this is a by-value operation. It would be incorrect\n+                    // if they referred to the same allocation, since then a change to one would\n+                    // implicitly change the other.\n+                    //\n+                    // TODO(solson): It would be valid to attempt reading a primitive value out of\n+                    // the source and writing that into the destination without making an\n+                    // allocation. This would be a pure optimization.\n+                    let dest_ptr = self.alloc_ptr(dest_ty)?;\n                     self.copy(src_ptr, dest_ptr, dest_ty)?;\n+                    self.stack[frame].set_local(local, Value::ByRef(dest_ptr));\n+\n                 } else {\n-                    // FIXME(solson): Is it safe to free the existing local here?\n-                    self.stack[frame].set_local(local, value);\n+                    // Finally, we have the simple case where neither source nor destination are\n+                    // `ByRef`. We may simply copy the source value over the the destintion local.\n+                    self.stack[frame].set_local(local, src_val);\n                 }\n             }\n         }"}]}