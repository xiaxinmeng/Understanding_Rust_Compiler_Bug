{"sha": "8c5402efdda733d163895d1edb9bcf7f401dd33b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNTQwMmVmZGRhNzMzZDE2Mzg5NWQxZWRiOWJjZjdmNDAxZGQzM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-30T21:23:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-30T21:23:19Z"}, "message": "Auto merge of #72794 - RalfJung:rollup-gzs4nl4, r=RalfJung\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #72543 (Account for missing lifetime in opaque and trait object return types)\n - #72625 (Improve inline asm error diagnostics)\n - #72637 (expand `env!` with def-site context)\n - #72650 (Sort sidebar elements)\n - #72657 (Allow types (with lifetimes/generics) in impl_lint_pass)\n - #72666 (Add -Z profile-emit=<path> for Gcov gcda output.)\n - #72668 (Fix missing parentheses Fn notation error)\n - #72669 (rustc_session: Cleanup session creation)\n - #72728 (Make bootstrap aware of relative libdir in stage0 compiler)\n - #72757 (rustc_lexer: Optimize shebang detection slightly)\n - #72772 (miri validation: clarify valid values of 'char')\n - #72773 (Fix is_char_boundary documentation)\n - #72777 (rustdoc: remove calls to `local_def_id_from_node_id`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1abfcbf012a45c7595c129995fcede2b092c408c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1abfcbf012a45c7595c129995fcede2b092c408c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c5402efdda733d163895d1edb9bcf7f401dd33b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c5402efdda733d163895d1edb9bcf7f401dd33b", "html_url": "https://github.com/rust-lang/rust/commit/8c5402efdda733d163895d1edb9bcf7f401dd33b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c5402efdda733d163895d1edb9bcf7f401dd33b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74e80468347471779be6060d8d7d6d04e98e467f", "url": "https://api.github.com/repos/rust-lang/rust/commits/74e80468347471779be6060d8d7d6d04e98e467f", "html_url": "https://github.com/rust-lang/rust/commit/74e80468347471779be6060d8d7d6d04e98e467f"}, {"sha": "581eafcdf767ebc064f1711b7225388cfbc46b98", "url": "https://api.github.com/repos/rust-lang/rust/commits/581eafcdf767ebc064f1711b7225388cfbc46b98", "html_url": "https://github.com/rust-lang/rust/commit/581eafcdf767ebc064f1711b7225388cfbc46b98"}], "stats": {"total": 2317, "additions": 1467, "deletions": 850}, "files": [{"sha": "c8a85eae252ff0c9e0d72dcbaf0447454d7f226a", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -648,6 +648,7 @@ impl<'a> Builder<'a> {\n     pub fn sysroot_libdir_relative(&self, compiler: Compiler) -> &Path {\n         match self.config.libdir_relative() {\n             Some(relative_libdir) if compiler.stage >= 1 => relative_libdir,\n+            _ if compiler.stage == 0 => &self.build.initial_libdir,\n             _ => Path::new(\"lib\"),\n         }\n     }"}, {"sha": "c46c68e4d56824d9224868fb105c985a7e12c386", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -243,6 +243,7 @@ pub struct Build {\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n     initial_lld: PathBuf,\n+    initial_libdir: PathBuf,\n \n     // Runtime state filled in later on\n     // C/C++ compilers and archiver for all targets\n@@ -344,18 +345,39 @@ impl Build {\n         // we always try to use git for LLVM builds\n         let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n \n-        let initial_sysroot = config.initial_rustc.parent().unwrap().parent().unwrap();\n-        let initial_lld = initial_sysroot\n-            .join(\"lib\")\n-            .join(\"rustlib\")\n-            .join(config.build)\n-            .join(\"bin\")\n-            .join(\"rust-lld\");\n+        let initial_target_libdir_str = if config.dry_run {\n+            \"/dummy/lib/path/to/lib/\".to_string()\n+        } else {\n+            output(\n+                Command::new(&config.initial_rustc)\n+                    .arg(\"--target\")\n+                    .arg(config.build)\n+                    .arg(\"--print\")\n+                    .arg(\"target-libdir\"),\n+            )\n+        };\n+        let initial_target_dir = Path::new(&initial_target_libdir_str).parent().unwrap();\n+        let initial_lld = initial_target_dir.join(\"bin\").join(\"rust-lld\");\n+\n+        let initial_sysroot = if config.dry_run {\n+            \"/dummy\".to_string()\n+        } else {\n+            output(Command::new(&config.initial_rustc).arg(\"--print\").arg(\"sysroot\"))\n+        };\n+        let initial_libdir = initial_target_dir\n+            .parent()\n+            .unwrap()\n+            .parent()\n+            .unwrap()\n+            .strip_prefix(initial_sysroot.trim())\n+            .unwrap()\n+            .to_path_buf();\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             initial_lld,\n+            initial_libdir,\n             local_rebuild: config.local_rebuild,\n             fail_fast: config.cmd.fail_fast(),\n             doc_tests: config.cmd.doc_tests(),"}, {"sha": "316c2cd55aceaf60527b454354f737ee5ce0fc88", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2270,12 +2270,11 @@ impl str {\n         self.len() == 0\n     }\n \n-    /// Checks that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n+    /// Checks that `index`-th byte is the first byte in a UTF-8 code point\n+    /// sequence or the end of the string.\n     ///\n     /// The start and end of the string (when `index == self.len()`) are\n-    /// considered to be\n-    /// boundaries.\n+    /// considered to be boundaries.\n     ///\n     /// Returns `false` if `index` is greater than `self.len()`.\n     ///"}, {"sha": "23bf7b35419db9767d20d7340bd20320dc124ca1", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -191,6 +191,11 @@ pub struct Parser<'a> {\n     append_newline: bool,\n     /// Whether this formatting string is a literal or it comes from a macro.\n     is_literal: bool,\n+    /// Start position of the current line.\n+    cur_line_start: usize,\n+    /// Start and end byte offset of every line of the format string. Excludes\n+    /// newline characters and leading whitespace.\n+    pub line_spans: Vec<InnerSpan>,\n }\n \n impl<'a> Iterator for Parser<'a> {\n@@ -235,10 +240,15 @@ impl<'a> Iterator for Parser<'a> {\n                         None\n                     }\n                 }\n-                '\\n' => Some(String(self.string(pos))),\n                 _ => Some(String(self.string(pos))),\n             }\n         } else {\n+            if self.is_literal && self.cur_line_start != self.input.len() {\n+                let start = self.to_span_index(self.cur_line_start);\n+                let end = self.to_span_index(self.input.len());\n+                self.line_spans.push(start.to(end));\n+                self.cur_line_start = self.input.len();\n+            }\n             None\n         }\n     }\n@@ -266,6 +276,8 @@ impl<'a> Parser<'a> {\n             last_opening_brace: None,\n             append_newline,\n             is_literal,\n+            cur_line_start: 0,\n+            line_spans: vec![],\n         }\n     }\n \n@@ -433,7 +445,17 @@ impl<'a> Parser<'a> {\n                 '{' | '}' => {\n                     return &self.input[start..pos];\n                 }\n+                '\\n' if self.is_literal => {\n+                    let start = self.to_span_index(self.cur_line_start);\n+                    let end = self.to_span_index(pos);\n+                    self.line_spans.push(start.to(end));\n+                    self.cur_line_start = pos + 1;\n+                    self.cur.next();\n+                }\n                 _ => {\n+                    if self.is_literal && pos == self.cur_line_start && c.is_whitespace() {\n+                        self.cur_line_start = pos + c.len_utf8();\n+                    }\n                     self.cur.next();\n                 }\n             }"}, {"sha": "efcf95ec706b811b668971d22e60f9377bc1407c", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1252,7 +1252,7 @@ pub enum ExprKind {\n     Ret(Option<P<Expr>>),\n \n     /// Output of the `asm!()` macro.\n-    InlineAsm(InlineAsm),\n+    InlineAsm(P<InlineAsm>),\n     /// Output of the `llvm_asm!()` macro.\n     LlvmInlineAsm(P<LlvmInlineAsm>),\n \n@@ -1971,6 +1971,7 @@ pub struct InlineAsm {\n     pub template: Vec<InlineAsmTemplatePiece>,\n     pub operands: Vec<(InlineAsmOperand, Span)>,\n     pub options: InlineAsmOptions,\n+    pub line_spans: Vec<Span>,\n }\n \n /// Inline assembly dialect."}, {"sha": "c9037da377ebb3d32f41b5d2ed5751647c0cf7a7", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1267,7 +1267,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let operands = self.arena.alloc_from_iter(operands);\n         let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n-        let hir_asm = hir::InlineAsm { template, operands, options: asm.options };\n+        let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);\n+        let hir_asm = hir::InlineAsm { template, operands, options: asm.options, line_spans };\n         hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n     }\n "}, {"sha": "19fae63557289bf33bea35f0a9e9c7ca381242a5", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -513,10 +513,16 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         }\n     }\n \n-    let inline_asm = ast::InlineAsm { template, operands, options: args.options };\n+    let line_spans = if parser.line_spans.is_empty() {\n+        vec![template_sp]\n+    } else {\n+        parser.line_spans.iter().map(|span| template_span.from_inner(*span)).collect()\n+    };\n+\n+    let inline_asm = ast::InlineAsm { template, operands, options: args.options, line_spans };\n     P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        kind: ast::ExprKind::InlineAsm(inline_asm),\n+        kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n         span: sp,\n         attrs: ast::AttrVec::new(),\n         tokens: None,"}, {"sha": "d769ebb1f5520d621ef27b299eccee1217607d49", "filename": "src/librustc_builtin_macros/env.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_builtin_macros%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_builtin_macros%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fenv.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -77,6 +77,7 @@ pub fn expand_env<'cx>(\n         return DummyResult::any(sp);\n     }\n \n+    let sp = cx.with_def_site_ctxt(sp);\n     let e = match env::var(&*var.as_str()) {\n         Err(_) => {\n             cx.span_err(sp, &msg.as_str());"}, {"sha": "9d4a30f23a20934286ffa491a4710f098da2de78", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::TyAndLayout;\n-use rustc_span::Span;\n+use rustc_span::{Pos, Span};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n \n@@ -97,7 +97,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             ia.volatile,\n             ia.alignstack,\n             ia.dialect,\n-            span,\n+            &[span],\n         );\n         if r.is_none() {\n             return false;\n@@ -119,7 +119,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         template: &[InlineAsmTemplatePiece],\n         operands: &[InlineAsmOperandRef<'tcx, Self>],\n         options: InlineAsmOptions,\n-        span: Span,\n+        line_spans: &[Span],\n     ) {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n \n@@ -287,9 +287,9 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             volatile,\n             alignstack,\n             dialect,\n-            span,\n+            line_spans,\n         )\n-        .unwrap_or_else(|| span_bug!(span, \"LLVM asm constraint validation failed\"));\n+        .unwrap_or_else(|| span_bug!(line_spans[0], \"LLVM asm constraint validation failed\"));\n \n         if options.contains(InlineAsmOptions::PURE) {\n             if options.contains(InlineAsmOptions::NOMEM) {\n@@ -341,7 +341,7 @@ fn inline_asm_call(\n     volatile: bool,\n     alignstack: bool,\n     dia: LlvmAsmDialect,\n-    span: Span,\n+    line_spans: &[Span],\n ) -> Option<&'ll Value> {\n     let volatile = if volatile { llvm::True } else { llvm::False };\n     let alignstack = if alignstack { llvm::True } else { llvm::False };\n@@ -382,8 +382,24 @@ fn inline_asm_call(\n                 key.len() as c_uint,\n             );\n \n-            let val: &'ll Value = bx.const_i32(span.ctxt().outer_expn().as_u32() as i32);\n-            llvm::LLVMSetMetadata(call, kind, llvm::LLVMMDNodeInContext(bx.llcx, &val, 1));\n+            // srcloc contains one integer for each line of assembly code.\n+            // Unfortunately this isn't enough to encode a full span so instead\n+            // we just encode the start position of each line.\n+            // FIXME: Figure out a way to pass the entire line spans.\n+            let mut srcloc = vec![];\n+            if dia == LlvmAsmDialect::Intel && line_spans.len() > 1 {\n+                // LLVM inserts an extra line to add the \".intel_syntax\", so add\n+                // a dummy srcloc entry for it.\n+                //\n+                // Don't do this if we only have 1 line span since that may be\n+                // due to the asm template string coming from a macro. LLVM will\n+                // default to the first srcloc for lines that don't have an\n+                // associated srcloc.\n+                srcloc.push(bx.const_i32(0));\n+            }\n+            srcloc.extend(line_spans.iter().map(|span| bx.const_i32(span.lo().to_u32() as i32)));\n+            let md = llvm::LLVMMDNodeInContext(bx.llcx, srcloc.as_ptr(), srcloc.len() as u32);\n+            llvm::LLVMSetMetadata(call, kind, md);\n \n             Some(call)\n         } else {"}, {"sha": "02a9294930d2b12bb7ee652f63c7120ba6275d75", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -23,6 +23,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, Lto, OutputType, Passes, Sanitizer, SwitchWithOptPath};\n use rustc_session::Session;\n+use rustc_span::InnerSpan;\n use rustc_target::spec::{CodeModel, RelocModel};\n \n use libc::{c_char, c_int, c_uint, c_void, size_t};\n@@ -238,12 +239,19 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n     }\n }\n \n-unsafe extern \"C\" fn report_inline_asm(\n+fn report_inline_asm(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n-    msg: &str,\n-    cookie: c_uint,\n+    msg: String,\n+    mut cookie: c_uint,\n+    source: Option<(String, Vec<InnerSpan>)>,\n ) {\n-    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_owned());\n+    // In LTO build we may get srcloc values from other crates which are invalid\n+    // since they use a different source map. To be safe we just suppress these\n+    // in LTO builds.\n+    if matches!(cgcx.lto, Lto::Fat | Lto::Thin) {\n+        cookie = 0;\n+    }\n+    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg, source);\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void, cookie: c_uint) {\n@@ -252,10 +260,37 @@ unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void\n     }\n     let (cgcx, _) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n \n-    let msg = llvm::build_string(|s| llvm::LLVMRustWriteSMDiagnosticToString(diag, s))\n-        .expect(\"non-UTF8 SMDiagnostic\");\n+    // Recover the post-substitution assembly code from LLVM for better\n+    // diagnostics.\n+    let mut have_source = false;\n+    let mut buffer = String::new();\n+    let mut loc = 0;\n+    let mut ranges = [0; 8];\n+    let mut num_ranges = ranges.len() / 2;\n+    let msg = llvm::build_string(|msg| {\n+        buffer = llvm::build_string(|buffer| {\n+            have_source = llvm::LLVMRustUnpackSMDiagnostic(\n+                diag,\n+                msg,\n+                buffer,\n+                &mut loc,\n+                ranges.as_mut_ptr(),\n+                &mut num_ranges,\n+            );\n+        })\n+        .expect(\"non-UTF8 inline asm\");\n+    })\n+    .expect(\"non-UTF8 SMDiagnostic\");\n+\n+    let source = have_source.then(|| {\n+        let mut spans = vec![InnerSpan::new(loc as usize, loc as usize)];\n+        for i in 0..num_ranges {\n+            spans.push(InnerSpan::new(ranges[i * 2] as usize, ranges[i * 2 + 1] as usize));\n+        }\n+        (buffer, spans)\n+    });\n \n-    report_inline_asm(cgcx, &msg, cookie);\n+    report_inline_asm(cgcx, msg, cookie, source);\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void) {\n@@ -266,7 +301,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n-            report_inline_asm(cgcx, &llvm::twine_to_string(inline.message), inline.cookie);\n+            report_inline_asm(cgcx, llvm::twine_to_string(inline.message), inline.cookie, None);\n         }\n \n         llvm::diagnostic::Optimization(opt) => {"}, {"sha": "333eb805221ff0fda5ec6b462fde4dd76a60c0b2", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -959,16 +959,16 @@ pub fn compile_unit_metadata(\n         if tcx.sess.opts.debugging_opts.profile {\n             let cu_desc_metadata =\n                 llvm::LLVMRustMetadataAsValue(debug_context.llcontext, unit_metadata);\n+            let default_gcda_path = &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\");\n+            let gcda_path =\n+                tcx.sess.opts.debugging_opts.profile_emit.as_ref().unwrap_or(default_gcda_path);\n \n             let gcov_cu_info = [\n                 path_to_mdstring(\n                     debug_context.llcontext,\n                     &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcno\"),\n                 ),\n-                path_to_mdstring(\n-                    debug_context.llcontext,\n-                    &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\"),\n-                ),\n+                path_to_mdstring(debug_context.llcontext, &gcda_path),\n                 cu_desc_metadata,\n             ];\n             let gcov_metadata = llvm::LLVMMDNodeInContext("}, {"sha": "759c2bf1b85f4f5cb4efcc048e8703652a1277d6", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2070,7 +2070,14 @@ extern \"C\" {\n     );\n \n     #[allow(improper_ctypes)]\n-    pub fn LLVMRustWriteSMDiagnosticToString(d: &SMDiagnostic, s: &RustString);\n+    pub fn LLVMRustUnpackSMDiagnostic(\n+        d: &SMDiagnostic,\n+        message_out: &RustString,\n+        buffer_out: &RustString,\n+        loc_out: &mut c_uint,\n+        ranges_out: *mut c_uint,\n+        num_ranges: &mut usize,\n+    ) -> bool;\n \n     pub fn LLVMRustWriteArchive(\n         Dst: *const c_char,"}, {"sha": "cb5c95c11fad823d9e9cdc7ce0206499e357a40c", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -31,9 +31,9 @@ use rustc_session::cgu_reuse_tracker::CguReuseTracker;\n use rustc_session::config::{self, CrateType, Lto, OutputFilenames, OutputType};\n use rustc_session::config::{Passes, Sanitizer, SwitchWithOptPath};\n use rustc_session::Session;\n-use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n \n use std::any::Any;\n@@ -1551,7 +1551,7 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n \n enum SharedEmitterMessage {\n     Diagnostic(Diagnostic),\n-    InlineAsmError(u32, String),\n+    InlineAsmError(u32, String, Option<(String, Vec<InnerSpan>)>),\n     AbortIfErrors,\n     Fatal(String),\n }\n@@ -1572,8 +1572,13 @@ impl SharedEmitter {\n         (SharedEmitter { sender }, SharedEmitterMain { receiver })\n     }\n \n-    pub fn inline_asm_error(&self, cookie: u32, msg: String) {\n-        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg)));\n+    pub fn inline_asm_error(\n+        &self,\n+        cookie: u32,\n+        msg: String,\n+        source: Option<(String, Vec<InnerSpan>)>,\n+    ) {\n+        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg, source)));\n     }\n \n     pub fn fatal(&self, msg: &str) {\n@@ -1626,8 +1631,30 @@ impl SharedEmitterMain {\n                     }\n                     handler.emit_diagnostic(&d);\n                 }\n-                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    sess.span_err(ExpnId::from_u32(cookie).expn_data().call_site, &msg)\n+                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg, source)) => {\n+                    let msg = msg.strip_prefix(\"error: \").unwrap_or(&msg);\n+\n+                    // If the cookie is 0 then we don't have span information.\n+                    let mut err = if cookie == 0 {\n+                        sess.struct_err(&msg)\n+                    } else {\n+                        let pos = BytePos::from_u32(cookie);\n+                        let span = Span::with_root_ctxt(pos, pos);\n+                        sess.struct_span_err(span, &msg)\n+                    };\n+\n+                    // Point to the generated assembly if it is available.\n+                    if let Some((buffer, spans)) = source {\n+                        let source = sess\n+                            .source_map()\n+                            .new_source_file(FileName::inline_asm_source_code(&buffer), buffer);\n+                        let source_span = Span::with_root_ctxt(source.start_pos, source.end_pos);\n+                        let spans: Vec<_> =\n+                            spans.iter().map(|sp| source_span.from_inner(*sp)).collect();\n+                        err.span_note(spans, \"instantiated into assembly here\");\n+                    }\n+\n+                    err.emit();\n                 }\n                 Ok(SharedEmitterMessage::AbortIfErrors) => {\n                     sess.abort_if_errors();"}, {"sha": "6c18e753d790b7a2af7f2f90304484c266cf7148", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -831,6 +831,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         template: &[ast::InlineAsmTemplatePiece],\n         operands: &[mir::InlineAsmOperand<'tcx>],\n         options: ast::InlineAsmOptions,\n+        line_spans: &[Span],\n         destination: Option<mir::BasicBlock>,\n     ) {\n         let span = terminator.source_info.span;\n@@ -930,7 +931,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             })\n             .collect();\n \n-        bx.codegen_inline_asm(template, &operands, options, span);\n+        bx.codegen_inline_asm(template, &operands, options, line_spans);\n \n         if let Some(target) = destination {\n             helper.funclet_br(self, &mut bx, target);\n@@ -1033,14 +1034,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bug!(\"borrowck false edges in codegen\")\n             }\n \n-            mir::TerminatorKind::InlineAsm { template, ref operands, options, destination } => {\n+            mir::TerminatorKind::InlineAsm {\n+                template,\n+                ref operands,\n+                options,\n+                line_spans,\n+                destination,\n+            } => {\n                 self.codegen_asm_terminator(\n                     helper,\n                     bx,\n                     terminator,\n                     template,\n                     operands,\n                     options,\n+                    line_spans,\n                     destination,\n                 );\n             }"}, {"sha": "b6b57744f95b61ca02f829c7573645ec75cffb78", "filename": "src/librustc_codegen_ssa/traits/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -52,7 +52,7 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n         template: &[InlineAsmTemplatePiece],\n         operands: &[InlineAsmOperandRef<'tcx, Self>],\n         options: InlineAsmOptions,\n-        span: Span,\n+        line_spans: &[Span],\n     );\n }\n "}, {"sha": "0194dc9f90bb8dec48bd7ed0ba4c84fa6c09d356", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2106,6 +2106,7 @@ pub struct InlineAsm<'hir> {\n     pub template: &'hir [InlineAsmTemplatePiece],\n     pub operands: &'hir [InlineAsmOperand<'hir>],\n     pub options: InlineAsmOptions,\n+    pub line_spans: &'hir [Span],\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]"}, {"sha": "a59a91e3005aacda59f9429c41b5f6e9e483124b", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 124, "deletions": 46, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -60,7 +60,7 @@ use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::Node;\n+use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{\n     self,\n@@ -1682,49 +1682,92 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) -> DiagnosticBuilder<'a> {\n+        let hir = &self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n-        let type_param_span = match (self.in_progress_tables, bound_kind) {\n-            (Some(ref table), GenericKind::Param(ref param)) => {\n-                let table_owner = table.borrow().hir_owner;\n-                table_owner.and_then(|table_owner| {\n-                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n-                    // Account for the case where `param` corresponds to `Self`,\n-                    // which doesn't have the expected type argument.\n-                    if !(generics.has_self && param.index == 0) {\n-                        let type_param = generics.type_param(param, self.tcx);\n-                        let hir = &self.tcx.hir();\n-                        type_param.def_id.as_local().map(|def_id| {\n-                            // Get the `hir::Param` to verify whether it already has any bounds.\n-                            // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n-                            // instead we suggest `T: 'a + 'b` in that case.\n-                            let id = hir.as_local_hir_id(def_id);\n-                            let mut has_bounds = false;\n-                            if let Node::GenericParam(param) = hir.get(id) {\n-                                has_bounds = !param.bounds.is_empty();\n-                            }\n-                            let sp = hir.span(id);\n-                            // `sp` only covers `T`, change it so that it covers\n-                            // `T:` when appropriate\n-                            let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n-                            let sp = if has_bounds && !is_impl_trait {\n-                                sp.to(self\n-                                    .tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .next_point(self.tcx.sess.source_map().next_point(sp)))\n-                            } else {\n-                                sp\n-                            };\n-                            (sp, has_bounds, is_impl_trait)\n-                        })\n+        let generics =\n+            self.in_progress_tables.and_then(|table| table.borrow().hir_owner).map(|table_owner| {\n+                let hir_id = hir.as_local_hir_id(table_owner);\n+                let parent_id = hir.get_parent_item(hir_id);\n+                (\n+                    // Parent item could be a `mod`, so we check the HIR before calling:\n+                    if let Some(Node::Item(Item {\n+                        kind: ItemKind::Trait(..) | ItemKind::Impl { .. },\n+                        ..\n+                    })) = hir.find(parent_id)\n+                    {\n+                        Some(self.tcx.generics_of(hir.local_def_id(parent_id).to_def_id()))\n                     } else {\n                         None\n-                    }\n-                })\n+                    },\n+                    self.tcx.generics_of(table_owner.to_def_id()),\n+                )\n+            });\n+        let type_param_span = match (generics, bound_kind) {\n+            (Some((_, ref generics)), GenericKind::Param(ref param)) => {\n+                // Account for the case where `param` corresponds to `Self`,\n+                // which doesn't have the expected type argument.\n+                if !(generics.has_self && param.index == 0) {\n+                    let type_param = generics.type_param(param, self.tcx);\n+                    type_param.def_id.as_local().map(|def_id| {\n+                        // Get the `hir::Param` to verify whether it already has any bounds.\n+                        // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n+                        // instead we suggest `T: 'a + 'b` in that case.\n+                        let id = hir.as_local_hir_id(def_id);\n+                        let mut has_bounds = false;\n+                        if let Node::GenericParam(param) = hir.get(id) {\n+                            has_bounds = !param.bounds.is_empty();\n+                        }\n+                        let sp = hir.span(id);\n+                        // `sp` only covers `T`, change it so that it covers\n+                        // `T:` when appropriate\n+                        let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n+                        let sp = if has_bounds && !is_impl_trait {\n+                            sp.to(self\n+                                .tcx\n+                                .sess\n+                                .source_map()\n+                                .next_point(self.tcx.sess.source_map().next_point(sp)))\n+                        } else {\n+                            sp\n+                        };\n+                        (sp, has_bounds, is_impl_trait)\n+                    })\n+                } else {\n+                    None\n+                }\n             }\n             _ => None,\n         };\n+        let new_lt = generics\n+            .as_ref()\n+            .and_then(|(parent_g, g)| {\n+                let possible: Vec<_> = (b'a'..=b'z').map(|c| format!(\"'{}\", c as char)).collect();\n+                let mut lts_names = g\n+                    .params\n+                    .iter()\n+                    .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n+                    .map(|p| p.name.as_str())\n+                    .collect::<Vec<_>>();\n+                if let Some(g) = parent_g {\n+                    lts_names.extend(\n+                        g.params\n+                            .iter()\n+                            .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n+                            .map(|p| p.name.as_str()),\n+                    );\n+                }\n+                let lts = lts_names.iter().map(|s| -> &str { &*s }).collect::<Vec<_>>();\n+                possible.into_iter().find(|candidate| !lts.contains(&candidate.as_str()))\n+            })\n+            .unwrap_or(\"'lt\".to_string());\n+        let add_lt_sugg = generics\n+            .as_ref()\n+            .and_then(|(_, g)| g.params.first())\n+            .and_then(|param| param.def_id.as_local())\n+            .map(|def_id| {\n+                (hir.span(hir.as_local_hir_id(def_id)).shrink_to_lo(), format!(\"{}, \", new_lt))\n+            });\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n@@ -1781,6 +1824,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        let new_binding_suggestion =\n+            |err: &mut DiagnosticBuilder<'tcx>,\n+             type_param_span: Option<(Span, bool, bool)>,\n+             bound_kind: GenericKind<'tcx>| {\n+                let msg = \"consider introducing an explicit lifetime bound\";\n+                if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n+                    let suggestion = if is_impl_trait {\n+                        (sp.shrink_to_hi(), format!(\" + {}\", new_lt))\n+                    } else {\n+                        let tail = if has_lifetimes { \" +\" } else { \"\" };\n+                        (sp, format!(\"{}: {}{}\", bound_kind, new_lt, tail))\n+                    };\n+                    let mut sugg =\n+                        vec![suggestion, (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n+                    if let Some(lt) = add_lt_sugg {\n+                        sugg.push(lt);\n+                        sugg.rotate_right(1);\n+                    }\n+                    // `MaybeIncorrect` due to issue #41966.\n+                    err.multipart_suggestion(msg, sugg, Applicability::MaybeIncorrect);\n+                }\n+            };\n+\n         let mut err = match *sub {\n             ty::ReEarlyBound(ty::EarlyBoundRegion { name, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: ty::BrNamed(_, name), .. }) => {\n@@ -1822,17 +1888,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"{} may not live long enough\",\n                     labeled_user_string\n                 );\n-                err.help(&format!(\n-                    \"consider adding an explicit lifetime bound for `{}`\",\n-                    bound_kind\n-                ));\n                 note_and_explain_region(\n                     self.tcx,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\",\n                 );\n+                if let Some(infer::RelateParamBound(_, t)) = origin {\n+                    let t = self.resolve_vars_if_possible(&t);\n+                    match t.kind {\n+                        // We've got:\n+                        // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+                        // suggest:\n+                        // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+                        ty::Closure(_, _substs) | ty::Opaque(_, _substs) => {\n+                            new_binding_suggestion(&mut err, type_param_span, bound_kind);\n+                        }\n+                        _ => {\n+                            binding_suggestion(&mut err, type_param_span, bound_kind, new_lt);\n+                        }\n+                    }\n+                }\n                 err\n             }\n         };\n@@ -1861,14 +1938,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"...\",\n         );\n \n+        debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n+        debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n+        debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n+        debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n+        debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n+\n         if let (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) =\n             (&sup_origin, &sub_origin)\n         {\n-            debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n-            debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n-            debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n-            debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n-            debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n             debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n             debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n             debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);"}, {"sha": "7ab18e54f7ea2342210629fa6af0286ccbf5f140", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -121,16 +121,14 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             (Some(ret_span), _) => (\n                 ty_sub.span,\n                 ret_span,\n-                \"this parameter and the return type are declared \\\n-                 with different lifetimes...\"\n+                \"this parameter and the return type are declared with different lifetimes...\"\n                     .to_owned(),\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),\n             (_, Some(ret_span)) => (\n                 ty_sup.span,\n                 ret_span,\n-                \"this parameter and the return type are declared \\\n-                 with different lifetimes...\"\n+                \"this parameter and the return type are declared with different lifetimes...\"\n                     .to_owned(),\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),"}, {"sha": "cc8f1816bc3f4a10ac6fccef165ce0fc55937a70", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -55,9 +55,9 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n                 diag.emit();\n                 ErrorReported\n             })\n+            .or_else(|| self.try_report_impl_not_conforming_to_trait())\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_static_impl_trait())\n-            .or_else(|| self.try_report_impl_not_conforming_to_trait())\n     }\n \n     pub fn regions(&self) -> Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)> {"}, {"sha": "acaf47469927625fb8da0cb7bb7346c4487d5022", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -21,8 +21,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n-        // with the named one.//scope_def_id\n-        let (named, anon, anon_param_info, region_info) = if self.is_named_region(sub)\n+        // with the named one.\n+        let (named, anon, anon_param_info, region_info) = if sub.has_name()\n             && self.tcx().is_suitable_region(sup).is_some()\n             && self.find_param_with_region(sup, sub).is_some()\n         {\n@@ -32,7 +32,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 self.find_param_with_region(sup, sub).unwrap(),\n                 self.tcx().is_suitable_region(sup).unwrap(),\n             )\n-        } else if self.is_named_region(sup)\n+        } else if sup.has_name()\n             && self.tcx().is_suitable_region(sub).is_some()\n             && self.find_param_with_region(sub, sup).is_some()\n         {\n@@ -74,15 +74,21 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n \n         if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n-            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some()\n-                || self.is_self_anon(is_first, scope_def_id)\n-            {\n+            let is_self_anon = self.is_self_anon(is_first, scope_def_id);\n+            if is_self_anon {\n                 return None;\n             }\n+\n             if let FnRetTy::Return(ty) = &fndecl.output {\n-                if let (TyKind::Def(_, _), ty::ReStatic) = (&ty.kind, sub) {\n-                    // This is an impl Trait return that evaluates de need of 'static.\n-                    // We handle this case better in `static_impl_trait`.\n+                let mut v = ty::TraitObjectVisitor(vec![]);\n+                rustc_hir::intravisit::walk_ty(&mut v, ty);\n+\n+                debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n+                if sub == &ty::ReStatic && (matches!(ty.kind, TyKind::Def(_, _)) || v.0.len() == 1)\n+                {\n+                    debug!(\"try_report_named_anon_conflict: impl Trait + 'static\");\n+                    // This is an `impl Trait` or `dyn Trait` return that evaluates de need of\n+                    // `'static`. We handle this case better in `static_impl_trait`.\n                     return None;\n                 }\n             }\n@@ -114,17 +120,4 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         Some(diag)\n     }\n-\n-    // This method returns whether the given Region is Named\n-    pub(super) fn is_named_region(&self, region: ty::Region<'tcx>) -> bool {\n-        match *region {\n-            ty::ReStatic => true,\n-            ty::ReFree(ref free_region) => match free_region.bound_region {\n-                ty::BrNamed(..) => true,\n-                _ => false,\n-            },\n-            ty::ReEarlyBound(ebr) => ebr.has_name(),\n-            _ => false,\n-        }\n-    }\n }"}, {"sha": "f4c86ddae604e2b0297484bb6ee3b53a4505ddea", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,7 +4,7 @@ use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use rustc_errors::{Applicability, ErrorReported};\n-use rustc_middle::ty::{BoundRegion, FreeRegion, RegionKind};\n+use rustc_middle::ty::RegionKind;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n@@ -20,48 +20,59 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ) = error.clone()\n             {\n                 let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                let return_ty = self.tcx().return_type_impl_trait(anon_reg_sup.def_id);\n-                if sub_r == &RegionKind::ReStatic && return_ty.is_some() {\n+                let (fn_return_span, is_dyn) =\n+                    self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n+                if sub_r == &RegionKind::ReStatic {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n                     let mut err =\n                         self.tcx().sess.struct_span_err(sp, \"cannot infer an appropriate lifetime\");\n-                    err.span_label(\n-                        return_sp,\n-                        \"this return type evaluates to the `'static` lifetime...\",\n-                    );\n-                    err.span_label(sup_origin.span(), \"...but this borrow...\");\n+                    let param_info = self.find_param_with_region(sup_r, sub_r)?;\n+                    err.span_label(param_info.param_ty_span, \"data with this lifetime...\");\n \n-                    let (lifetime, lt_sp_opt) = msg_span_from_free_region(self.tcx(), sup_r);\n-                    if let Some(lifetime_sp) = lt_sp_opt {\n-                        err.span_note(lifetime_sp, &format!(\"...can't outlive {}\", lifetime));\n-                    }\n-\n-                    let lifetime_name = match sup_r {\n-                        RegionKind::ReFree(FreeRegion {\n-                            bound_region: BoundRegion::BrNamed(_, ref name),\n-                            ..\n-                        }) => name.to_string(),\n-                        _ => \"'_\".to_owned(),\n-                    };\n-                    let fn_return_span = return_ty.unwrap().1;\n-                    if let Ok(snippet) =\n-                        self.tcx().sess.source_map().span_to_snippet(fn_return_span)\n+                    // We try to make the output have fewer overlapping spans if possible.\n+                    if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n+                        && sup_origin.span() != return_sp\n                     {\n-                        // only apply this suggestion onto functions with\n-                        // explicit non-desugar'able return.\n-                        if fn_return_span.desugaring_kind().is_none() {\n-                            err.span_suggestion(\n-                                fn_return_span,\n-                                &format!(\n-                                    \"you can add a bound to the return type to make it last \\\n-                                 less than `'static` and match {}\",\n-                                    lifetime,\n-                                ),\n-                                format!(\"{} + {}\", snippet, lifetime_name),\n-                                Applicability::Unspecified,\n-                            );\n+                        // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+\n+                        // Customize the spans and labels depending on their relative order so\n+                        // that split sentences flow correctly.\n+                        if sup_origin.span().shrink_to_hi() <= return_sp.shrink_to_lo() {\n+                            err.span_label(sup_origin.span(), \"...is captured here...\");\n+                            err.span_label(return_sp, \"...and required to be `'static` by this\");\n+                        } else {\n+                            err.span_label(return_sp, \"...is required to be `'static` by this...\");\n+                            err.span_label(sup_origin.span(), \"...and is captured here\");\n                         }\n+                    } else {\n+                        err.span_label(\n+                            return_sp,\n+                            \"...is captured and required to be `'static` here\",\n+                        );\n+                    }\n+\n+                    let (lifetime, _) = msg_span_from_free_region(self.tcx(), sup_r);\n+\n+                    let lifetime_name =\n+                        if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n+                    // only apply this suggestion onto functions with\n+                    // explicit non-desugar'able return.\n+                    if fn_return_span.desugaring_kind().is_none() {\n+                        let msg = format!(\n+                            \"to permit non-static references in {} `{} Trait` value, you can add \\\n+                             an explicit bound for {}\",\n+                            if is_dyn { \"a\" } else { \"an\" },\n+                            if is_dyn { \"dyn\" } else { \"impl\" },\n+                            lifetime,\n+                        );\n+                        // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+                        err.span_suggestion_verbose(\n+                            fn_return_span.shrink_to_hi(),\n+                            &msg,\n+                            format!(\" + {}\", lifetime_name),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n                     err.emit();\n                     return Some(ErrorReported);"}, {"sha": "9ac27030adeeac0a1e1f11ea6ff5c53e612095c7", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -10,10 +10,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         origin: &SubregionOrigin<'tcx>,\n     ) {\n+        let mut label_or_note = |span, msg| {\n+            let sub_count = err.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = err.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = err.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                err.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                err.note(msg);\n+            } else {\n+                err.span_note(span, msg);\n+            }\n+        };\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n-                    err.span_note(\n+                    label_or_note(\n                         trace.cause.span,\n                         &format!(\"...so that the {}\", trace.cause.as_requirement_str()),\n                     );\n@@ -24,27 +36,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // handling of region checking when type errors are present is\n                     // *terrible*.\n \n-                    err.span_note(\n+                    label_or_note(\n                         trace.cause.span,\n                         &format!(\"...so that {}\", trace.cause.as_requirement_str()),\n                     );\n                 }\n             }\n             infer::Reborrow(span) => {\n-                err.span_note(span, \"...so that reference does not outlive borrowed content\");\n+                label_or_note(span, \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                err.span_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n+                label_or_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n             }\n             infer::RelateObjectBound(span) => {\n-                err.span_note(span, \"...so that it can be closed over into an object\");\n+                label_or_note(span, \"...so that it can be closed over into an object\");\n             }\n             infer::CallReturn(span) => {\n-                err.span_note(span, \"...so that return value is valid for the call\");\n+                label_or_note(span, \"...so that return value is valid for the call\");\n             }\n             infer::DataBorrowed(ty, span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n                         \"...so that the type `{}` is not borrowed for too long\",\n@@ -53,36 +65,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n-                        \"...so that the reference type `{}` does not outlive the \\\n-                                        data it points at\",\n+                        \"...so that the reference type `{}` does not outlive the data it points at\",\n                         self.ty_to_string(ty)\n                     ),\n                 );\n             }\n             infer::RelateParamBound(span, t) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n-                        \"...so that the type `{}` will meet its required \\\n-                                        lifetime bounds\",\n+                        \"...so that the type `{}` will meet its required lifetime bounds\",\n                         self.ty_to_string(t)\n                     ),\n                 );\n             }\n             infer::RelateRegionParamBound(span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     \"...so that the declared lifetime parameter bounds are satisfied\",\n                 );\n             }\n             infer::CompareImplMethodObligation { span, .. } => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n-                    \"...so that the definition in impl matches the definition from the \\\n-                               trait\",\n+                    \"...so that the definition in impl matches the definition from the trait\",\n                 );\n             }\n         }\n@@ -113,8 +122,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0312,\n-                    \"lifetime of reference outlives lifetime of \\\n-                                                borrowed content...\"\n+                    \"lifetime of reference outlives lifetime of borrowed content...\"\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n@@ -138,8 +146,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0313,\n-                    \"lifetime of borrowed pointer outlives lifetime \\\n-                                                of captured variable `{}`...\",\n+                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n                     var_name\n                 );\n                 note_and_explain_region(\n@@ -163,8 +170,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0476,\n-                    \"lifetime of the source pointer does not outlive \\\n-                                                lifetime bound of the object type\"\n+                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n+                     object type\"\n                 );\n                 note_and_explain_region(self.tcx, &mut err, \"object type is valid for \", sub, \"\");\n                 note_and_explain_region(\n@@ -181,8 +188,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0477,\n-                    \"the type `{}` does not fulfill the required \\\n-                                                lifetime\",\n+                    \"the type `{}` does not fulfill the required lifetime\",\n                     self.ty_to_string(ty)\n                 );\n                 match *sub {\n@@ -217,8 +223,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0482,\n-                    \"lifetime of return value does not outlive the \\\n-                                                function call\"\n+                    \"lifetime of return value does not outlive the function call\"\n                 );\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "f127a239eea2ce8b76aee12bba292bcfde57aed4", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -18,7 +18,7 @@ use rustc_session::lint;\n use rustc_session::parse::{CrateConfig, ParseSess};\n use rustc_session::{DiagnosticOutput, Session};\n use rustc_span::edition;\n-use rustc_span::source_map::{FileLoader, FileName, SourceMap};\n+use rustc_span::source_map::{FileLoader, FileName};\n use std::path::PathBuf;\n use std::result;\n use std::sync::{Arc, Mutex};\n@@ -31,7 +31,6 @@ pub type Result<T> = result::Result<T, ErrorReported>;\n pub struct Compiler {\n     pub(crate) sess: Lrc<Session>,\n     codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n-    source_map: Lrc<SourceMap>,\n     pub(crate) input: Input,\n     pub(crate) input_path: Option<PathBuf>,\n     pub(crate) output_dir: Option<PathBuf>,\n@@ -49,9 +48,6 @@ impl Compiler {\n     pub fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n         &self.codegen_backend\n     }\n-    pub fn source_map(&self) -> &Lrc<SourceMap> {\n-        &self.source_map\n-    }\n     pub fn input(&self) -> &Input {\n         &self.input\n     }\n@@ -168,7 +164,7 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n     f: impl FnOnce(&Compiler) -> R,\n ) -> R {\n     let registry = &config.registry;\n-    let (sess, codegen_backend, source_map) = util::create_session(\n+    let (sess, codegen_backend) = util::create_session(\n         config.opts,\n         config.crate_cfg,\n         config.diagnostic_output,\n@@ -181,7 +177,6 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n     let compiler = Compiler {\n         sess,\n         codegen_backend,\n-        source_map,\n         input: config.input,\n         input_path: config.input_path,\n         output_dir: config.output_dir,"}, {"sha": "18cbea858d47a5c6be64571571fb327feb552df5", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -7,11 +7,10 @@ use rustc_session::config::{build_configuration, build_session_options, to_crate\n use rustc_session::config::{rustc_optgroups, ErrorOutputType, ExternLocation, Options, Passes};\n use rustc_session::config::{CFGuard, ExternEntry, LinkerPluginLto, LtoCli, SwitchWithOptPath};\n use rustc_session::config::{Externs, OutputType, OutputTypes, Sanitizer, SymbolManglingVersion};\n-use rustc_session::getopts;\n use rustc_session::lint::Level;\n use rustc_session::search_paths::SearchPath;\n use rustc_session::utils::NativeLibKind;\n-use rustc_session::{build_session, Session};\n+use rustc_session::{build_session, getopts, DiagnosticOutput, Session};\n use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::symbol::sym;\n use rustc_span::SourceFileHashAlgorithm;\n@@ -32,7 +31,14 @@ fn build_session_options_and_crate_config(matches: getopts::Matches) -> (Options\n fn mk_session(matches: getopts::Matches) -> (Session, CfgSpecs) {\n     let registry = registry::Registry::new(&[]);\n     let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-    let sess = build_session(sessopts, None, registry);\n+    let sess = build_session(\n+        sessopts,\n+        None,\n+        registry,\n+        DiagnosticOutput::Default,\n+        Default::default(),\n+        None,\n+    );\n     (sess, cfg)\n }\n \n@@ -557,6 +563,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(plt, Some(true));\n     tracked!(print_fuel, Some(\"abc\".to_string()));\n     tracked!(profile, true);\n+    tracked!(profile_emit, Some(PathBuf::from(\"abc\")));\n     tracked!(relro_level, Some(RelroLevel::Full));\n     tracked!(report_delayed_bugs, true);\n     tracked!(run_dsymutil, false);"}, {"sha": "924908e57248760986a543c1a84660ec39774c77", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -23,7 +23,7 @@ use rustc_session::parse::CrateConfig;\n use rustc_session::CrateDisambiguator;\n use rustc_session::{early_error, filesearch, output, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n-use rustc_span::source_map::{FileLoader, SourceMap};\n+use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n use smallvec::SmallVec;\n use std::env;\n@@ -65,8 +65,8 @@ pub fn create_session(\n     input_path: Option<PathBuf>,\n     lint_caps: FxHashMap<lint::LintId, lint::Level>,\n     descriptions: Registry,\n-) -> (Lrc<Session>, Lrc<Box<dyn CodegenBackend>>, Lrc<SourceMap>) {\n-    let (mut sess, source_map) = session::build_session_with_source_map(\n+) -> (Lrc<Session>, Lrc<Box<dyn CodegenBackend>>) {\n+    let mut sess = session::build_session(\n         sopts,\n         input_path,\n         descriptions,\n@@ -81,7 +81,7 @@ pub fn create_session(\n     add_configuration(&mut cfg, &mut sess, &*codegen_backend);\n     sess.parse_sess.config = cfg;\n \n-    (Lrc::new(sess), Lrc::new(codegen_backend), source_map)\n+    (Lrc::new(sess), Lrc::new(codegen_backend))\n }\n \n const STACK_SIZE: usize = 8 * 1024 * 1024;"}, {"sha": "c2139d07f378a5640327bca97903c04b7da0b8a0", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -238,26 +238,25 @@ pub enum Base {\n /// `rustc` allows files to have a shebang, e.g. \"#!/usr/bin/rustrun\",\n /// but shebang isn't a part of rust syntax.\n pub fn strip_shebang(input: &str) -> Option<usize> {\n-    let first_line = input.lines().next()?;\n-    // A shebang is intentionally loosely defined as `#! [non whitespace]` on the first line.\n-    let could_be_shebang =\n-        first_line.starts_with(\"#!\") && first_line[2..].contains(|c| !is_whitespace(c));\n-    if !could_be_shebang {\n-        return None;\n-    }\n-    let non_whitespace_tokens = tokenize(input).map(|tok| tok.kind).filter(|tok|\n-        !matches!(tok, TokenKind::LineComment | TokenKind::BlockComment { .. } | TokenKind::Whitespace)\n-    );\n-    let prefix = [TokenKind::Pound, TokenKind::Not, TokenKind::OpenBracket];\n-    let starts_with_attribute = non_whitespace_tokens.take(3).eq(prefix.iter().copied());\n-    if starts_with_attribute {\n-        // If the file starts with #![ then it's definitely not a shebang -- it couldn't be\n-        // a rust program since a Rust program can't start with `[`\n-        None\n-    } else {\n-        // It's a #!... and there isn't a `[` in sight, must be a shebang\n-        Some(first_line.len())\n+    // Shebang must start with `#!` literally, without any preceding whitespace.\n+    if input.starts_with(\"#!\") {\n+        let input_tail = &input[2..];\n+        // Shebang must have something non-whitespace after `#!` on the first line.\n+        let first_line_tail = input_tail.lines().next()?;\n+        if first_line_tail.contains(|c| !is_whitespace(c)) {\n+            // Ok, this is a shebang but if the next non-whitespace token is `[` or maybe\n+            // a doc comment (due to `TokenKind::(Line,Block)Comment` ambiguity at lexer level),\n+            // then it may be valid Rust code, so consider it Rust code.\n+            let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).filter(|tok|\n+                !matches!(tok, TokenKind::Whitespace | TokenKind::LineComment | TokenKind::BlockComment { .. })\n+            ).next();\n+            if next_non_whitespace_token != Some(TokenKind::OpenBracket) {\n+                // No other choice than to consider this a shebang.\n+                return Some(2 + first_line_tail.len());\n+            }\n+        }\n     }\n+    None\n }\n \n /// Parses the first token from the provided input string."}, {"sha": "d5212ec5c3081fcacc7e51433293998c3440e698", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -82,6 +82,8 @@ macro_rules! arena_types {\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n             [decode] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n \n+            // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n+            [decode] span: rustc_span::Span,\n         ], $tcx);\n     )\n }"}, {"sha": "b54b09918abe1b59144922de4f449fcdf60e681e", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1194,6 +1194,10 @@ pub enum TerminatorKind<'tcx> {\n         /// Miscellaneous options for the inline assembly.\n         options: InlineAsmOptions,\n \n+        /// Source spans for each line of the inline assembly code. These are\n+        /// used to map assembler errors back to the line in the source code.\n+        line_spans: &'tcx [Span],\n+\n         /// Destination block after the inline assembly returns, unless it is\n         /// diverging (InlineAsmOptions::NORETURN).\n         destination: Option<BasicBlock>,\n@@ -1596,7 +1600,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             }\n             FalseEdges { .. } => write!(fmt, \"falseEdges\"),\n             FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n-            InlineAsm { template, ref operands, options, destination: _ } => {\n+            InlineAsm { template, ref operands, options, .. } => {\n                 write!(fmt, \"asm!(\\\"{}\\\"\", InlineAsmTemplatePiece::to_string(template))?;\n                 for op in operands {\n                     write!(fmt, \", \")?;"}, {"sha": "b0207b469fa64e61b50ae957346d12ac4abeadf1", "filename": "src/librustc_middle/mir/type_foldable.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -78,9 +78,13 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 FalseEdges { real_target, imaginary_target }\n             }\n             FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n-            InlineAsm { template, ref operands, options, destination } => {\n-                InlineAsm { template, operands: operands.fold_with(folder), options, destination }\n-            }\n+            InlineAsm { template, ref operands, options, line_spans, destination } => InlineAsm {\n+                template,\n+                operands: operands.fold_with(folder),\n+                options,\n+                line_spans,\n+                destination,\n+            },\n         };\n         Terminator { source_info: self.source_info, kind }\n     }"}, {"sha": "035e6e55a975d0dc4b49c9957c3cc83b3b9f938a", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -535,6 +535,7 @@ macro_rules! make_mir_visitor {\n                         template: _,\n                         operands,\n                         options: _,\n+                        line_spans: _,\n                         destination: _,\n                     } => {\n                         for op in operands {"}, {"sha": "c9d240a5da91ebb1ebaefb74dbae131e84e1671e", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 74, "deletions": 27, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1,38 +1,27 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::DepGraph;\n-use crate::dep_graph::{self, DepConstructor};\n+use crate::dep_graph::{self, DepConstructor, DepGraph};\n use crate::hir::exports::Export;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::LintDiagnosticBuilder;\n-use crate::lint::{struct_lint_level, LintSource};\n+use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintSource};\n use crate::middle;\n-use crate::middle::cstore::CrateStoreDyn;\n-use crate::middle::cstore::EncodedMetadata;\n+use crate::middle::cstore::{CrateStoreDyn, EncodedMetadata};\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::interpret::{Allocation, ConstValue, Scalar};\n-use crate::mir::{interpret, Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n+use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n-use crate::ty::query;\n use crate::ty::steal::Steal;\n-use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n-use crate::ty::subst::{GenericArgKind, UserSubsts};\n-use crate::ty::CanonicalPolyFnSig;\n-use crate::ty::GenericParamDefKind;\n-use crate::ty::RegionKind;\n-use crate::ty::ReprOptions;\n+use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n-use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n-use crate::ty::{AdtDef, AdtKind, Const, Region};\n-use crate::ty::{BindingMode, BoundVar};\n-use crate::ty::{ConstVid, FloatVar, FloatVid, IntVar, IntVid, TyVar, TyVid};\n-use crate::ty::{ExistentialPredicate, Predicate, PredicateKind};\n-use crate::ty::{InferConst, ParamConst};\n-use crate::ty::{InferTy, ParamTy, PolyFnSig, ProjectionTy};\n-use crate::ty::{List, TyKind, TyS};\n+use crate::ty::{\n+    self, query, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n+    DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n+    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, ProjectionTy,\n+    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n+};\n use rustc_ast::ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n@@ -48,10 +37,8 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n-use rustc_hir::lang_items;\n-use rustc_hir::lang_items::PanicLocationLangItem;\n-use rustc_hir::{HirId, Node, TraitCandidate};\n-use rustc_hir::{ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet};\n+use rustc_hir::lang_items::{self, PanicLocationLangItem};\n+use rustc_hir::{HirId, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet, Node, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n@@ -1396,6 +1383,66 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n+    pub fn return_type_impl_or_dyn_trait(&self, scope_def_id: DefId) -> Option<(Span, bool)> {\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n+        let hir_output = match self.hir().get(hir_id) {\n+            Node::Item(hir::Item {\n+                kind:\n+                    ItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        ..,\n+                    ),\n+                ..\n+            })\n+            | Node::ImplItem(hir::ImplItem {\n+                kind:\n+                    hir::ImplItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        _,\n+                    ),\n+                ..\n+            })\n+            | Node::TraitItem(hir::TraitItem {\n+                kind:\n+                    hir::TraitItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        _,\n+                    ),\n+                ..\n+            }) => ty,\n+            _ => return None,\n+        };\n+\n+        let ret_ty = self.type_of(scope_def_id);\n+        match ret_ty.kind {\n+            ty::FnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(*self);\n+                let output = self.erase_late_bound_regions(&sig.output());\n+                if output.is_impl_trait() {\n+                    let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n+                    Some((fn_decl.output.span(), false))\n+                } else {\n+                    let mut v = TraitObjectVisitor(vec![]);\n+                    rustc_hir::intravisit::walk_ty(&mut v, hir_output);\n+                    if v.0.len() == 1 {\n+                        return Some((v.0[0], true));\n+                    }\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());"}, {"sha": "1403efb745b156bec69771e54a047d2beb50ee5b", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -249,3 +249,22 @@ pub fn suggest_constraining_type_param(\n         true\n     }\n }\n+\n+pub struct TraitObjectVisitor(pub Vec<rustc_span::Span>);\n+impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor {\n+    type Map = rustc_hir::intravisit::ErasedMap<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+        if let hir::TyKind::TraitObject(\n+            _,\n+            hir::Lifetime { name: hir::LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+        ) = ty.kind\n+        {\n+            self.0.push(ty.span);\n+        }\n+    }\n+}"}, {"sha": "0b59e29b66c748a55a45133c6fd651cb381002c1", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -183,7 +183,13 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     }\n                 }\n             }\n-            TerminatorKind::InlineAsm { template: _, ref operands, options: _, destination: _ } => {\n+            TerminatorKind::InlineAsm {\n+                template: _,\n+                ref operands,\n+                options: _,\n+                line_spans: _,\n+                destination: _,\n+            } => {\n                 for op in operands {\n                     match *op {\n                         InlineAsmOperand::In { reg: _, ref value }"}, {"sha": "268fbfcf3952541c95c7fbb5f91c3ee46ed51f6a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -722,7 +722,13 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n             }\n \n-            TerminatorKind::InlineAsm { template: _, ref operands, options: _, destination: _ } => {\n+            TerminatorKind::InlineAsm {\n+                template: _,\n+                ref operands,\n+                options: _,\n+                line_spans: _,\n+                destination: _,\n+            } => {\n                 for op in operands {\n                     match *op {\n                         InlineAsmOperand::In { reg: _, ref value }"}, {"sha": "9e2a28853e151ceb51c98e904b9cc0942c602653", "filename": "src/librustc_mir/dataflow/framework/direction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -482,7 +482,7 @@ impl Direction for Forward {\n                 }\n             }\n \n-            InlineAsm { template: _, operands: _, options: _, destination } => {\n+            InlineAsm { template: _, operands: _, options: _, line_spans: _, destination } => {\n                 if let Some(target) = destination {\n                     propagate(target, exit_state);\n                 }"}, {"sha": "e35d853c92815611184b6c6bbb20c7d9a92478cd", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -411,7 +411,13 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                     self.gather_init(destination.as_ref(), InitKind::NonPanicPathOnly);\n                 }\n             }\n-            TerminatorKind::InlineAsm { template: _, ref operands, options: _, destination: _ } => {\n+            TerminatorKind::InlineAsm {\n+                template: _,\n+                ref operands,\n+                options: _,\n+                line_spans: _,\n+                destination: _\n+            } => {\n                 for op in operands {\n                     match *op {\n                         InlineAsmOperand::In { reg: _, ref value }"}, {"sha": "d5f4a63baaa83fc6b572aa9c010e57ce7eca3587", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -485,7 +485,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 try_validation!(\n                     value.to_char(),\n                     self.path,\n-                    err_ub!(InvalidChar(..)) => { \"{}\", value } expected { \"a valid unicode codepoint\" },\n+                    err_ub!(InvalidChar(..)) => { \"{}\", value } expected { \"a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\" },\n                 );\n                 Ok(true)\n             }"}, {"sha": "e7733deee4dd35da08c0b941c735934c9fe58794", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n                 block.unit()\n             }\n-            ExprKind::InlineAsm { template, operands, options } => {\n+            ExprKind::InlineAsm { template, operands, options, line_spans } => {\n                 use crate::hair;\n                 use rustc_middle::mir;\n                 let operands = operands\n@@ -368,6 +368,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         template,\n                         operands,\n                         options,\n+                        line_spans,\n                         destination: if options.contains(InlineAsmOptions::NORETURN) {\n                             None\n                         } else {"}, {"sha": "969bb4f72597e8dabf21fc7b2857aa691a592e22", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -513,6 +513,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 })\n                 .collect(),\n             options: asm.options,\n+            line_spans: asm.line_spans,\n         },\n \n         hir::ExprKind::LlvmInlineAsm(ref asm) => ExprKind::LlvmInlineAsm {"}, {"sha": "0a1c68e83a94c57e40f11738072e33c204df2685", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -283,6 +283,7 @@ crate enum ExprKind<'tcx> {\n         template: &'tcx [InlineAsmTemplatePiece],\n         operands: Vec<InlineAsmOperand<'tcx>>,\n         options: InlineAsmOptions,\n+        line_spans: &'tcx [Span],\n     },\n     LlvmInlineAsm {\n         asm: &'tcx hir::LlvmInlineAsmInner,"}, {"sha": "8a66fac1e3634e3b9f317a36f5497dc2edd0592d", "filename": "src/librustc_session/lint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_session%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_session%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -347,14 +347,14 @@ pub trait LintPass {\n     fn name(&self) -> &'static str;\n }\n \n-/// Implements `LintPass for $name` with the given list of `Lint` statics.\n+/// Implements `LintPass for $ty` with the given list of `Lint` statics.\n #[macro_export]\n macro_rules! impl_lint_pass {\n-    ($name:ident => [$($lint:expr),* $(,)?]) => {\n-        impl $crate::lint::LintPass for $name {\n-            fn name(&self) -> &'static str { stringify!($name) }\n+    ($ty:ty => [$($lint:expr),* $(,)?]) => {\n+        impl $crate::lint::LintPass for $ty {\n+            fn name(&self) -> &'static str { stringify!($ty) }\n         }\n-        impl $name {\n+        impl $ty {\n             pub fn get_lints() -> $crate::lint::LintArray { $crate::lint_array!($($lint),*) }\n         }\n     };"}, {"sha": "a38e7f063d79ae88daa355432f9d89c72c8381a4", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -955,6 +955,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"print layout information for each type encountered (default: no)\"),\n     profile: bool = (false, parse_bool, [TRACKED],\n         \"insert profiling code (default: no)\"),\n+    profile_emit: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n+        \"file path to emit profiling data at runtime when using 'profile' \\\n+        (default based on relative source path)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"enable queries of the dependency graph for regression testing (default: no)\"),\n     query_stats: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "233761dbed7dee6166b5d4fc05b75d016ceebfdd", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -174,6 +174,10 @@ impl ParseSess {\n         &self.source_map\n     }\n \n+    pub fn clone_source_map(&self) -> Lrc<SourceMap> {\n+        self.source_map.clone()\n+    }\n+\n     pub fn buffer_lint(\n         &self,\n         lint: &'static Lint,"}, {"sha": "048033846a13841fbe240cf722a17112595681fe", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 15, "deletions": 40, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -21,7 +21,7 @@ use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_span::edition::Edition;\n-use rustc_span::source_map::{self, FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n+use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n use rustc_span::{SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n@@ -523,7 +523,7 @@ impl Session {\n     }\n \n     #[inline]\n-    pub fn source_map(&self) -> &source_map::SourceMap {\n+    pub fn source_map(&self) -> &SourceMap {\n         self.parse_sess.source_map()\n     }\n     pub fn verbose(&self) -> bool {\n@@ -1026,26 +1026,10 @@ impl Session {\n     }\n }\n \n-pub fn build_session(\n-    sopts: config::Options,\n-    local_crate_source_file: Option<PathBuf>,\n-    registry: rustc_errors::registry::Registry,\n-) -> Session {\n-    build_session_with_source_map(\n-        sopts,\n-        local_crate_source_file,\n-        registry,\n-        DiagnosticOutput::Default,\n-        Default::default(),\n-        None,\n-    )\n-    .0\n-}\n-\n fn default_emitter(\n     sopts: &config::Options,\n     registry: rustc_errors::registry::Registry,\n-    source_map: &Lrc<source_map::SourceMap>,\n+    source_map: Lrc<SourceMap>,\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Box<dyn Emitter + sync::Send> {\n     let macro_backtrace = sopts.debugging_opts.macro_backtrace;\n@@ -1054,25 +1038,22 @@ fn default_emitter(\n             let (short, color_config) = kind.unzip();\n \n             if let HumanReadableErrorType::AnnotateSnippet(_) = kind {\n-                let emitter = AnnotateSnippetEmitterWriter::new(\n-                    Some(source_map.clone()),\n-                    short,\n-                    macro_backtrace,\n-                );\n+                let emitter =\n+                    AnnotateSnippetEmitterWriter::new(Some(source_map), short, macro_backtrace);\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n             } else {\n                 let emitter = match dst {\n                     None => EmitterWriter::stderr(\n                         color_config,\n-                        Some(source_map.clone()),\n+                        Some(source_map),\n                         short,\n                         sopts.debugging_opts.teach,\n                         sopts.debugging_opts.terminal_width,\n                         macro_backtrace,\n                     ),\n                     Some(dst) => EmitterWriter::new(\n                         dst,\n-                        Some(source_map.clone()),\n+                        Some(source_map),\n                         short,\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n@@ -1084,20 +1065,14 @@ fn default_emitter(\n             }\n         }\n         (config::ErrorOutputType::Json { pretty, json_rendered }, None) => Box::new(\n-            JsonEmitter::stderr(\n-                Some(registry),\n-                source_map.clone(),\n-                pretty,\n-                json_rendered,\n-                macro_backtrace,\n-            )\n-            .ui_testing(sopts.debugging_opts.ui_testing),\n+            JsonEmitter::stderr(Some(registry), source_map, pretty, json_rendered, macro_backtrace)\n+                .ui_testing(sopts.debugging_opts.ui_testing),\n         ),\n         (config::ErrorOutputType::Json { pretty, json_rendered }, Some(dst)) => Box::new(\n             JsonEmitter::new(\n                 dst,\n                 Some(registry),\n-                source_map.clone(),\n+                source_map,\n                 pretty,\n                 json_rendered,\n                 macro_backtrace,\n@@ -1112,14 +1087,14 @@ pub enum DiagnosticOutput {\n     Raw(Box<dyn Write + Send>),\n }\n \n-pub fn build_session_with_source_map(\n+pub fn build_session(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     registry: rustc_errors::registry::Registry,\n     diagnostics_output: DiagnosticOutput,\n     driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n     file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n-) -> (Session, Lrc<SourceMap>) {\n+) -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n     // later via the source code.\n@@ -1157,7 +1132,7 @@ pub fn build_session_with_source_map(\n         sopts.file_path_mapping(),\n         hash_kind,\n     ));\n-    let emitter = default_emitter(&sopts, registry, &source_map, write_dest);\n+    let emitter = default_emitter(&sopts, registry, source_map.clone(), write_dest);\n \n     let span_diagnostic = rustc_errors::Handler::with_emitter_and_flags(\n         emitter,\n@@ -1185,7 +1160,7 @@ pub fn build_session_with_source_map(\n         None\n     };\n \n-    let parse_sess = ParseSess::with_span_handler(span_diagnostic, source_map.clone());\n+    let parse_sess = ParseSess::with_span_handler(span_diagnostic, source_map);\n     let sysroot = match &sopts.maybe_sysroot {\n         Some(sysroot) => sysroot.clone(),\n         None => filesearch::get_or_default_sysroot(),\n@@ -1308,7 +1283,7 @@ pub fn build_session_with_source_map(\n \n     validate_commandline_args_with_session_available(&sess);\n \n-    (sess, source_map)\n+    sess\n }\n \n // If it is useful to have a Session available already for validating a"}, {"sha": "616876d4b02a81b66177f41140c2e46576f812c0", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -101,6 +101,8 @@ pub enum FileName {\n     /// Custom sources for explicit parser calls from plugins and drivers.\n     Custom(String),\n     DocTest(PathBuf, isize),\n+    /// Post-substitution inline assembly from LLVM\n+    InlineAsm(u64),\n }\n \n impl std::fmt::Display for FileName {\n@@ -116,6 +118,7 @@ impl std::fmt::Display for FileName {\n             CliCrateAttr(_) => write!(fmt, \"<crate attribute>\"),\n             Custom(ref s) => write!(fmt, \"<{}>\", s),\n             DocTest(ref path, _) => write!(fmt, \"{}\", path.display()),\n+            InlineAsm(_) => write!(fmt, \"<inline asm>\"),\n         }\n     }\n }\n@@ -139,7 +142,8 @@ impl FileName {\n             | CliCrateAttr(_)\n             | Custom(_)\n             | QuoteExpansion(_)\n-            | DocTest(_, _) => false,\n+            | DocTest(_, _)\n+            | InlineAsm(_) => false,\n         }\n     }\n \n@@ -182,6 +186,12 @@ impl FileName {\n     pub fn doc_test_source_code(path: PathBuf, line: isize) -> FileName {\n         FileName::DocTest(path, line)\n     }\n+\n+    pub fn inline_asm_source_code(src: &str) -> FileName {\n+        let mut hasher = StableHasher::new();\n+        src.hash(&mut hasher);\n+        FileName::InlineAsm(hasher.finish())\n+    }\n }\n \n /// Spans represent a region of code, used for error reporting. Positions in spans"}, {"sha": "ab9db159038af09b5187dbe897006a5ef8d660a0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1151,9 +1151,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .as_ref()\n                             .and_then(|args| args.args.get(0))\n                             .and_then(|arg| match arg {\n-                                hir::GenericArg::Type(ty) => {\n-                                    sess.source_map().span_to_snippet(ty.span).ok()\n+                                hir::GenericArg::Type(ty) => match ty.kind {\n+                                    hir::TyKind::Tup(t) => t\n+                                        .iter()\n+                                        .map(|e| sess.source_map().span_to_snippet(e.span))\n+                                        .collect::<Result<Vec<_>, _>>()\n+                                        .map(|a| a.join(\", \")),\n+                                    _ => sess.source_map().span_to_snippet(ty.span),\n                                 }\n+                                .map(|s| format!(\"({})\", s))\n+                                .ok(),\n                                 _ => None,\n                             })\n                             .unwrap_or_else(|| \"()\".to_string()),"}, {"sha": "08e04f719e9ba692d86b263c129e6b8844a6aba5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::Mutability;\n use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::ty;\n@@ -454,11 +454,7 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n                         name: None,\n                         attrs: clean::Attributes::default(),\n                         source: clean::Span::empty(),\n-                        def_id: cx\n-                            .tcx\n-                            .hir()\n-                            .local_def_id_from_node_id(ast::CRATE_NODE_ID)\n-                            .to_def_id(),\n+                        def_id: DefId::local(CRATE_DEF_INDEX),\n                         visibility: clean::Public,\n                         stability: None,\n                         deprecation: None,"}, {"sha": "371df7444b004e8e188480e72e48763b7679780a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1549,11 +1549,11 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 let ty = cx.tcx.lift(self).expect(\"FnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n-                let local_def_id = cx.tcx.hir().local_def_id_from_node_id(ast::CRATE_NODE_ID);\n+                let def_id = DefId::local(CRATE_DEF_INDEX);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n                     generic_params: Vec::new(),\n-                    decl: (local_def_id.to_def_id(), sig).clean(cx),\n+                    decl: (def_id, sig).clean(cx),\n                     abi: sig.abi(),\n                 })\n             }\n@@ -2255,7 +2255,7 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_node_id(ast::CRATE_NODE_ID).to_def_id(),\n+            def_id: DefId::local(CRATE_DEF_INDEX),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,"}, {"sha": "5b364ed95cf59f26b5c2e607b14b8a202954478c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4067,9 +4067,9 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_none())\n                 .flat_map(move |i| get_methods(i.inner_impl(), false, used_links_bor, false))\n                 .collect::<Vec<_>>();\n-            // We want links' order to be reproducible so we don't use unstable sort.\n-            ret.sort();\n             if !ret.is_empty() {\n+                // We want links' order to be reproducible so we don't use unstable sort.\n+                ret.sort();\n                 out.push_str(&format!(\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#implementations\\\">Methods</a>\\\n                      <div class=\\\"sidebar-links\\\">{}</div>\",\n@@ -4240,7 +4240,7 @@ fn is_negative_impl(i: &clean::Impl) -> bool {\n fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n     let mut sidebar = String::new();\n \n-    let types = t\n+    let mut types = t\n         .items\n         .iter()\n         .filter_map(|m| match m.name {\n@@ -4249,8 +4249,8 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n             }\n             _ => None,\n         })\n-        .collect::<String>();\n-    let consts = t\n+        .collect::<Vec<_>>();\n+    let mut consts = t\n         .items\n         .iter()\n         .filter_map(|m| match m.name {\n@@ -4259,7 +4259,7 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n             }\n             _ => None,\n         })\n-        .collect::<String>();\n+        .collect::<Vec<_>>();\n     let mut required = t\n         .items\n         .iter()\n@@ -4282,32 +4282,34 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n         .collect::<Vec<String>>();\n \n     if !types.is_empty() {\n+        types.sort();\n         sidebar.push_str(&format!(\n             \"<a class=\\\"sidebar-title\\\" href=\\\"#associated-types\\\">\\\n-                                   Associated Types</a><div class=\\\"sidebar-links\\\">{}</div>\",\n-            types\n+                Associated Types</a><div class=\\\"sidebar-links\\\">{}</div>\",\n+            types.join(\"\")\n         ));\n     }\n     if !consts.is_empty() {\n+        consts.sort();\n         sidebar.push_str(&format!(\n             \"<a class=\\\"sidebar-title\\\" href=\\\"#associated-const\\\">\\\n-                                   Associated Constants</a><div class=\\\"sidebar-links\\\">{}</div>\",\n-            consts\n+                Associated Constants</a><div class=\\\"sidebar-links\\\">{}</div>\",\n+            consts.join(\"\")\n         ));\n     }\n     if !required.is_empty() {\n         required.sort();\n         sidebar.push_str(&format!(\n             \"<a class=\\\"sidebar-title\\\" href=\\\"#required-methods\\\">\\\n-                                   Required Methods</a><div class=\\\"sidebar-links\\\">{}</div>\",\n+                Required Methods</a><div class=\\\"sidebar-links\\\">{}</div>\",\n             required.join(\"\")\n         ));\n     }\n     if !provided.is_empty() {\n         provided.sort();\n         sidebar.push_str(&format!(\n             \"<a class=\\\"sidebar-title\\\" href=\\\"#provided-methods\\\">\\\n-                                   Provided Methods</a><div class=\\\"sidebar-links\\\">{}</div>\",\n+                Provided Methods</a><div class=\\\"sidebar-links\\\">{}</div>\",\n             provided.join(\"\")\n         ));\n     }\n@@ -4325,8 +4327,8 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n             res.sort();\n             sidebar.push_str(&format!(\n                 \"<a class=\\\"sidebar-title\\\" href=\\\"#foreign-impls\\\">\\\n-                                       Implementations on Foreign Types</a><div \\\n-                                       class=\\\"sidebar-links\\\">{}</div>\",\n+                    Implementations on Foreign Types</a><div \\\n+                    class=\\\"sidebar-links\\\">{}</div>\",\n                 res.into_iter()\n                     .map(|(name, id)| format!(\"<a href=\\\"#{}\\\">{}</a>\", id, Escape(&name)))\n                     .collect::<Vec<_>>()\n@@ -4339,7 +4341,7 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n     if t.auto {\n         sidebar.push_str(\n             \"<a class=\\\"sidebar-title\\\" \\\n-                          href=\\\"#synthetic-implementors\\\">Auto Implementors</a>\",\n+                href=\\\"#synthetic-implementors\\\">Auto Implementors</a>\",\n         );\n     }\n \n@@ -4365,18 +4367,18 @@ fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item) {\n }\n \n fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n-    fields\n+    let mut fields = fields\n         .iter()\n         .filter(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false })\n         .filter_map(|f| match f.name {\n-            Some(ref name) => Some(format!(\n-                \"<a href=\\\"#structfield.{name}\\\">\\\n-                                              {name}</a>\",\n-                name = name\n-            )),\n+            Some(ref name) => {\n+                Some(format!(\"<a href=\\\"#structfield.{name}\\\">{name}</a>\", name = name))\n+            }\n             _ => None,\n         })\n-        .collect()\n+        .collect::<Vec<_>>();\n+    fields.sort();\n+    fields.join(\"\")\n }\n \n fn sidebar_union(buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n@@ -4386,7 +4388,7 @@ fn sidebar_union(buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n     if !fields.is_empty() {\n         sidebar.push_str(&format!(\n             \"<a class=\\\"sidebar-title\\\" href=\\\"#fields\\\">Fields</a>\\\n-                                   <div class=\\\"sidebar-links\\\">{}</div>\",\n+             <div class=\\\"sidebar-links\\\">{}</div>\",\n             fields\n         ));\n     }\n@@ -4401,23 +4403,20 @@ fn sidebar_union(buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n fn sidebar_enum(buf: &mut Buffer, it: &clean::Item, e: &clean::Enum) {\n     let mut sidebar = String::new();\n \n-    let variants = e\n+    let mut variants = e\n         .variants\n         .iter()\n         .filter_map(|v| match v.name {\n-            Some(ref name) => Some(format!(\n-                \"<a href=\\\"#variant.{name}\\\">{name}\\\n-                                                                 </a>\",\n-                name = name\n-            )),\n+            Some(ref name) => Some(format!(\"<a href=\\\"#variant.{name}\\\">{name}</a>\", name = name)),\n             _ => None,\n         })\n-        .collect::<String>();\n+        .collect::<Vec<_>>();\n     if !variants.is_empty() {\n+        variants.sort_unstable();\n         sidebar.push_str(&format!(\n             \"<a class=\\\"sidebar-title\\\" href=\\\"#variants\\\">Variants</a>\\\n-                                   <div class=\\\"sidebar-links\\\">{}</div>\",\n-            variants\n+             <div class=\\\"sidebar-links\\\">{}</div>\",\n+            variants.join(\"\"),\n         ));\n     }\n "}, {"sha": "85ba4cbdc7e1b42904d5be5851c7ecb5a983452d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -114,7 +114,7 @@ pub fn run(options: Options) -> Result<(), String> {\n                 options,\n                 false,\n                 opts,\n-                Some(compiler.source_map().clone()),\n+                Some(compiler.session().parse_sess.clone_source_map()),\n                 None,\n                 enable_per_target_ignores,\n             );"}, {"sha": "6fac2662506a175484910acfac87e7f858158671", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1216,10 +1216,33 @@ extern \"C\" void LLVMRustSetInlineAsmDiagnosticHandler(\n   unwrap(C)->setInlineAsmDiagnosticHandler(H, CX);\n }\n \n-extern \"C\" void LLVMRustWriteSMDiagnosticToString(LLVMSMDiagnosticRef D,\n-                                                  RustStringRef Str) {\n-  RawRustStringOstream OS(Str);\n-  unwrap(D)->print(\"\", OS);\n+extern \"C\" bool LLVMRustUnpackSMDiagnostic(LLVMSMDiagnosticRef DRef,\n+                                           RustStringRef MessageOut,\n+                                           RustStringRef BufferOut,\n+                                           unsigned* LocOut,\n+                                           unsigned* RangesOut,\n+                                           size_t* NumRanges) {\n+  SMDiagnostic& D = *unwrap(DRef);\n+  RawRustStringOstream MessageOS(MessageOut);\n+  MessageOS << D.getMessage();\n+\n+  if (D.getLoc() == SMLoc())\n+    return false;\n+\n+  const SourceMgr &LSM = *D.getSourceMgr();\n+  const MemoryBuffer *LBuf = LSM.getMemoryBuffer(LSM.FindBufferContainingLoc(D.getLoc()));\n+  LLVMRustStringWriteImpl(BufferOut, LBuf->getBufferStart(), LBuf->getBufferSize());\n+\n+  *LocOut = D.getLoc().getPointer() - LBuf->getBufferStart();\n+\n+  *NumRanges = std::min(*NumRanges, D.getRanges().size());\n+  size_t LineStart = *LocOut - (size_t)D.getColumnNo();\n+  for (size_t i = 0; i < *NumRanges; i++) {\n+    RangesOut[i * 2] = LineStart + D.getRanges()[i].first;\n+    RangesOut[i * 2 + 1] = LineStart + D.getRanges()[i].second;\n+  }\n+\n+  return true;\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildCleanupPad(LLVMBuilderRef B,"}, {"sha": "04d382b475ed298111d1e614f045a0589706140f", "filename": "src/test/run-make-fulldeps/profile/Makefile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Frun-make-fulldeps%2Fprofile%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Frun-make-fulldeps%2Fprofile%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fprofile%2FMakefile?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -7,3 +7,6 @@ all:\n \t$(call RUN,test) || exit 1\n \t[ -e \"$(TMPDIR)/test.gcno\" ] || (echo \"No .gcno file\"; exit 1)\n \t[ -e \"$(TMPDIR)/test.gcda\" ] || (echo \"No .gcda file\"; exit 1)\n+\t$(RUSTC) -g -Z profile -Z profile-emit=$(TMPDIR)/abc/abc.gcda test.rs\n+\t$(call RUN,test) || exit 1\n+\t[ -e \"$(TMPDIR)/abc/abc.gcda\" ] || (echo \"gcda file not emitted to defined path\"; exit 1)"}, {"sha": "b3c2a542792f0efa85ee9a4df8035f37bcaaa01c", "filename": "src/test/ui-fulldeps/lint-pass-macros.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui-fulldeps%2Flint-pass-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui-fulldeps%2Flint-pass-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-pass-macros.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,26 @@\n+// compile-flags: -Z unstable-options\n+// check-pass\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc_session;\n+\n+use rustc_session::lint::{LintArray, LintPass};\n+use rustc_session::{declare_lint, declare_lint_pass, impl_lint_pass};\n+\n+declare_lint! {\n+    pub TEST_LINT,\n+    Allow,\n+    \"test\"\n+}\n+\n+struct Foo;\n+\n+struct Bar<'a>(&'a u32);\n+\n+impl_lint_pass!(Foo => [TEST_LINT]);\n+impl_lint_pass!(Bar<'_> => [TEST_LINT]);\n+\n+declare_lint_pass!(Baz => [TEST_LINT]);\n+\n+fn main() {}"}, {"sha": "7af6f620a9858cc1dce9ad963f2c508e8d4ba0ae", "filename": "src/test/ui/asm/srcloc.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,41 @@\n+// no-system-llvm\n+// only-x86_64\n+// build-fail\n+\n+#![feature(asm)]\n+\n+// Checks that inline asm errors are mapped to the correct line in the source code.\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"invalid_instruction\");\n+        //~^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\"\n+            invalid_instruction\n+        \");\n+        //~^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(r#\"\n+            invalid_instruction\n+        \"#);\n+        //~^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\"\n+            mov eax, eax\n+            invalid_instruction\n+            mov eax, eax\n+        \");\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(r#\"\n+            mov eax, eax\n+            invalid_instruction\n+            mov eax, eax\n+        \"#);\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(concat!(\"invalid\", \"_\", \"instruction\"));\n+        //~^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+    }\n+}"}, {"sha": "57a4fbb974228943ec078ca114fd2ac74c04c4de", "filename": "src/test/ui/asm/srcloc.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,74 @@\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:11:15\n+   |\n+LL |         asm!(\"invalid_instruction\");\n+   |               ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:15:13\n+   |\n+LL |             invalid_instruction\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:13\n+   |\n+LL |             invalid_instruction\n+   |             ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:20:13\n+   |\n+LL |             invalid_instruction\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:13\n+   |\n+LL |             invalid_instruction\n+   |             ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:26:13\n+   |\n+LL |             invalid_instruction\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:13\n+   |\n+LL |             invalid_instruction\n+   |             ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:33:13\n+   |\n+LL |             invalid_instruction\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:13\n+   |\n+LL |             invalid_instruction\n+   |             ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:38:14\n+   |\n+LL |         asm!(concat!(\"invalid\", \"_\", \"instruction\"));\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "af8fc2cd2ab459d8bc4b3eda43227db55de77e5c", "filename": "src/test/ui/async-await/issues/issue-62097.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,15 +2,12 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/issue-62097.rs:12:31\n    |\n LL |     pub async fn run_dummy_fn(&self) {\n-   |                               ^^^^^ ...but this borrow...\n+   |                               ^^^^^\n+   |                               |\n+   |                               data with this lifetime...\n+   |                               ...is captured here...\n LL |         foo(|| self.bar()).await;\n-   |         --- this return type evaluates to the `'static` lifetime...\n-   |\n-note: ...can't outlive the lifetime `'_` as defined on the method body at 12:31\n-  --> $DIR/issue-62097.rs:12:31\n-   |\n-LL |     pub async fn run_dummy_fn(&self) {\n-   |                               ^\n+   |         --- ...and required to be `'static` by this\n \n error: aborting due to previous error\n "}, {"sha": "2dac4a22ae7136983347e6a7efe0e4fa44805900", "filename": "src/test/ui/builtin-superkinds/builtin-superkinds-self-type.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,15 +2,9 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/builtin-superkinds-self-type.rs:10:16\n    |\n LL | impl <T: Sync> Foo for T { }\n-   |       --       ^^^\n+   |       --       ^^^ ...so that the type `T` will meet its required lifetime bounds\n    |       |\n    |       help: consider adding an explicit lifetime bound...: `T: 'static +`\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/builtin-superkinds-self-type.rs:10:16\n-   |\n-LL | impl <T: Sync> Foo for T { }\n-   |                ^^^\n \n error: aborting due to previous error\n "}, {"sha": "e49fd3e0b970bd4ed7d2b5a92a57c3b0ceb44bf2", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -82,7 +82,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:87:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0xffffffff at .<enum-variant(Some)>.0.1, but expected a valid unicode codepoint\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0xffffffff at .<enum-variant(Some)>.0.1, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "56415fd1f0dd0ef4cd262f0f1d440cdd3557b5ad", "filename": "src/test/ui/extenv/extenv-not-defined-custom.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fextenv%2Fextenv-not-defined-custom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fextenv%2Fextenv-not-defined-custom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextenv%2Fextenv-not-defined-custom.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -3,6 +3,8 @@ error: my error message\n    |\n LL | fn main() { env!(\"__HOPEFULLY_NOT_DEFINED__\", \"my error message\"); }\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "1a9332c4f1c9fd6e880457cc13ba18e2788cb960", "filename": "src/test/ui/extenv/extenv-not-defined-default.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fextenv%2Fextenv-not-defined-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fextenv%2Fextenv-not-defined-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextenv%2Fextenv-not-defined-default.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -3,6 +3,8 @@ error: environment variable `__HOPEFULLY_NOT_DEFINED__` not defined\n    |\n LL |     env!(\"__HOPEFULLY_NOT_DEFINED__\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "b62f06e33e531ccbf230c6f21d8c12d5e20e6791", "filename": "src/test/ui/extenv/issue-55897.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -3,6 +3,8 @@ error: environment variable `NON_EXISTENT` not defined\n    |\n LL |     include!(concat!(env!(\"NON_EXISTENT\"), \"/data.rs\"));\n    |                      ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: suffixes on a string literal are invalid\n   --> $DIR/issue-55897.rs:16:22"}, {"sha": "2beeba8184a7dfb0b3a7891fa222f6c2819c0ef2", "filename": "src/test/ui/feature-gates/feature-gate-infer_static_outlives_requirements.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,13 +4,7 @@ error[E0310]: the parameter type `U` may not live long enough\n LL | struct Foo<U> {\n    |            - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     bar: Bar<U>\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `U` will meet its required lifetime bounds\n-  --> $DIR/feature-gate-infer_static_outlives_requirements.rs:5:5\n-   |\n-LL |     bar: Bar<U>\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `U` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "e06977ebbe3df6dbf13b4ee1344f80c6f44fd116", "filename": "src/test/ui/generic-associated-types/impl_bounds.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,11 +5,7 @@ LL |     type A<'a> where Self: 'static = (&'a ());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n-note: ...so that the type `Fooy<T>` will meet its required lifetime bounds\n-  --> $DIR/impl_bounds.rs:15:5\n-   |\n-LL |     type A<'a> where Self: 'static = (&'a ());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...so that the type `Fooy<T>` will meet its required lifetime bounds\n \n error[E0478]: lifetime bound not satisfied\n   --> $DIR/impl_bounds.rs:17:5"}, {"sha": "d7dae6a08a7b94b9d17514e79198245d1ee7fa17", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 19, "deletions": 37, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,55 +2,43 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |                       ---------   ^ ...but this borrow...\n-   |                       |\n-   |                       this return type evaluates to the `'static` lifetime...\n+   |              ----     ---------   ^ ...and is captured here\n+   |              |        |\n+   |              |        ...is required to be `'static` by this...\n+   |              data with this lifetime...\n    |\n-note: ...can't outlive the anonymous lifetime #1 defined on the function body at 3:1\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:1\n-   |\n-LL | fn elided(x: &i32) -> impl Copy { x }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the function body at 3:1\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 3:1\n    |\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n-   |                       ^^^^^^^^^^^^^^\n+   |                                 ^^^^\n \n error: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |                                ---------   ^ ...but this borrow...\n-   |                                |\n-   |                                this return type evaluates to the `'static` lifetime...\n+   |                    -------     ---------   ^ ...and is captured here\n+   |                    |           |\n+   |                    |           ...is required to be `'static` by this...\n+   |                    data with this lifetime...\n    |\n-note: ...can't outlive the lifetime `'a` as defined on the function body at 6:13\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:13\n-   |\n-LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             ^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the function body at 6:13\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 6:13\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n-   |                                ^^^^^^^^^^^^^^\n+   |                                          ^^^^\n \n error: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:12:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                                  --------------------------------   ^ ...but this borrow...\n-   |                                  |\n-   |                                  this return type evaluates to the `'static` lifetime...\n-   |\n-note: ...can't outlive the lifetime `'a` as defined on the function body at 12:15\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:15\n+   |                      -------     --------------------------------   ^ ...and is captured here\n+   |                      |           |\n+   |                      |           ...is required to be `'static` by this...\n+   |                      data with this lifetime...\n    |\n-LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |               ^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the function body at 12:15\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 12:15\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static + 'a { x }\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                                   ^^^^\n \n error[E0623]: lifetime mismatch\n   --> $DIR/must_outlive_least_region_or_bound.rs:17:61\n@@ -65,15 +53,9 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                 --                ^^^^^^^^^^^^^^^^^^^^\n+   |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |                                 |\n    |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n-   |\n-LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                                   ^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "1c3a5979ee55bc74c7038c31c2fcd532996f7e77", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,43 +2,35 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/static-return-lifetime-infered.rs:7:16\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                                   ----------------------- this return type evaluates to the `'static` lifetime...\n+   |                         -----     ----------------------- ...is required to be `'static` by this...\n+   |                         |\n+   |                         data with this lifetime...\n LL |         self.x.iter().map(|a| a.0)\n    |         ------ ^^^^\n    |         |\n-   |         ...but this borrow...\n+   |         ...and is captured here\n    |\n-note: ...can't outlive the anonymous lifetime #1 defined on the method body at 6:5\n-  --> $DIR/static-return-lifetime-infered.rs:6:5\n-   |\n-LL | /     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-LL | |         self.x.iter().map(|a| a.0)\n-LL | |     }\n-   | |_____^\n-help: you can add a bound to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the method body at 6:5\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the method body at 6:5\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                           ^^^^\n \n error: cannot infer an appropriate lifetime\n   --> $DIR/static-return-lifetime-infered.rs:11:16\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                                     ----------------------- this return type evaluates to the `'static` lifetime...\n+   |                        --------     ----------------------- ...is required to be `'static` by this...\n+   |                        |\n+   |                        data with this lifetime...\n LL |         self.x.iter().map(|a| a.0)\n    |         ------ ^^^^\n    |         |\n-   |         ...but this borrow...\n-   |\n-note: ...can't outlive the lifetime `'a` as defined on the method body at 10:20\n-  --> $DIR/static-return-lifetime-infered.rs:10:20\n+   |         ...and is captured here\n    |\n-LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    ^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the method body at 10:20\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the method body at 10:20\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                             ^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "40e50b9922f8d2e9f6269cc113ab756df0ec3cc1", "filename": "src/test/ui/impl-trait/type_parameters_captured.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,15 +2,9 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/type_parameters_captured.rs:7:20\n    |\n LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |        -           ^^^^^^^^^^^^^^^^^^\n+   |        -           ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |        |\n    |        help: consider adding an explicit lifetime bound...: `T: 'static`\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/type_parameters_captured.rs:7:20\n-   |\n-LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |                    ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "7f4f5b22eb302cb77a3d187fd9241ea6b3441edb", "filename": "src/test/ui/issues/issue-16922.nll.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-16922.rs:4:5\n+   |\n+LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n+   |                       - let's call the lifetime of this reference `'1`\n+LL |     Box::new(value) as Box<dyn Any>\n+   |     ^^^^^^^^^^^^^^^ cast requires that `'1` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "827163ef83cf7cf4c7f3fff461b0d28fce7d2333", "filename": "src/test/ui/issues/issue-16922.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,7 +2,7 @@ use std::any::Any;\n \n fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n     Box::new(value) as Box<dyn Any>\n-    //~^ ERROR explicit lifetime required in the type of `value` [E0621]\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "02d33aae023ff27f5c31f28e7b6edfd267523943", "filename": "src/test/ui/issues/issue-16922.stderr", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1,11 +1,18 @@\n-error[E0621]: explicit lifetime required in the type of `value`\n-  --> $DIR/issue-16922.rs:4:5\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/issue-16922.rs:4:14\n    |\n LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n-   |                       -- help: add explicit lifetime `'static` to the type of `value`: `&'static T`\n+   |                       -- data with this lifetime...\n LL |     Box::new(value) as Box<dyn Any>\n-   |     ^^^^^^^^^^^^^^^ lifetime `'static` required\n+   |     ---------^^^^^-\n+   |     |        |\n+   |     |        ...and is captured here\n+   |     ...is required to be `'static` by this...\n+   |\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 3:1\n+   |\n+LL | fn foo<T: Any>(value: &T) -> Box<dyn Any + '_> {\n+   |                                          ^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0621`."}, {"sha": "a6500b9bb4c24668f81999db2fb1cb78845c2b48", "filename": "src/test/ui/issues/issue-23458.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fissues%2Fissue-23458.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fissues%2Fissue-23458.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23458.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,16 +2,19 @@ error: invalid operand in inline asm: 'int $3'\n   --> $DIR/issue-23458.rs:8:9\n    |\n LL |         llvm_asm!(\"int $3\");\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-\n-error: <inline asm>:1:2: error: too few operands for instruction\n-        int \n-        ^\n+   |         ^\n \n+error: too few operands for instruction\n   --> $DIR/issue-23458.rs:8:9\n    |\n LL |         llvm_asm!(\"int $3\");\n-   |         ^^^^^^^^^^^^^^^^^^^^\n+   |         ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:1:2\n+   |\n+LL |     int \n+   |     ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d682478db0eeff8b302d2e0f9e54e44ffb3f3193", "filename": "src/test/ui/lifetimes/lifetime-doesnt-live-long-enough.stderr", "status": "modified", "additions": 7, "deletions": 39, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,27 +4,15 @@ error[E0310]: the parameter type `T` may not live long enough\n LL | struct Foo<T> {\n    |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     foo: &'static T\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'static T` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:19:5\n-   |\n-LL |     foo: &'static T\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:24:19\n    |\n LL | trait X<K>: Sized {\n    |         - help: consider adding an explicit lifetime bound...: `K: 'a`\n LL |     fn foo<'a, L: X<&'a Nested<K>>>();\n-   |                   ^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:24:19\n-   |\n-LL |     fn foo<'a, L: X<&'a Nested<K>>>();\n-   |                   ^^^^^^^^^^^^^^^^\n+   |                   ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n \n error[E0309]: the parameter type `Self` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:28:19\n@@ -33,51 +21,31 @@ LL |     fn bar<'a, L: X<&'a Nested<Self>>>();\n    |                   ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `Self: 'a`...\n-note: ...so that the reference type `&'a Nested<Self>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:28:19\n-   |\n-LL |     fn bar<'a, L: X<&'a Nested<Self>>>();\n-   |                   ^^^^^^^^^^^^^^^^^^^\n+   = note: ...so that the reference type `&'a Nested<Self>` does not outlive the data it points at\n \n error[E0309]: the parameter type `L` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:32:22\n    |\n LL |     fn baz<'a, L, M: X<&'a Nested<L>>>() {\n-   |                -     ^^^^^^^^^^^^^^^^\n+   |                -     ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n    |                |\n    |                help: consider adding an explicit lifetime bound...: `L: 'a`\n-   |\n-note: ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:32:22\n-   |\n-LL |     fn baz<'a, L, M: X<&'a Nested<L>>>() {\n-   |                      ^^^^^^^^^^^^^^^^\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:41:33\n    |\n LL | impl<K> Nested<K> {\n    |      - help: consider adding an explicit lifetime bound...: `K: 'a`\n LL |     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n-   |                                 ^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:41:33\n-   |\n-LL |     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n-   |                                 ^^^^^^^^^^^^^^^^\n+   |                                 ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n \n error[E0309]: the parameter type `M` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:44:36\n    |\n LL |     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n    |                                    ^^^^^^^^^^^^^^^^  -- help: consider adding an explicit lifetime bound...: `M: 'a +`\n-   |\n-note: ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:44:36\n-   |\n-LL |     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n-   |                                    ^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n \n error: aborting due to 6 previous errors\n "}, {"sha": "96c019b760e95ae47507e05d6bc60887e880f7f0", "filename": "src/test/ui/llvm-asm/issue-69092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-69092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-69092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-69092.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -6,5 +6,5 @@\n \n fn main() {\n     unsafe { llvm_asm!(\".ascii \\\"Xen\\0\\\"\"); }\n-    //~^ ERROR: <inline asm>:1:9: error: expected string in '.ascii' directive\n+    //~^ ERROR: expected string in '.ascii' directive\n }"}, {"sha": "2ca86cf7c1b999284f94c5af008d0804ee97cb12", "filename": "src/test/ui/llvm-asm/issue-69092.stderr", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-69092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-69092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-69092.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1,11 +1,14 @@\n-error: <inline asm>:1:9: error: expected string in '.ascii' directive\n-        .ascii \"Xen\n-               ^\n-\n+error: expected string in '.ascii' directive\n   --> $DIR/issue-69092.rs:8:14\n    |\n LL |     unsafe { llvm_asm!(\".ascii \\\"Xen\\0\\\"\"); }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:1:9\n+   |\n+LL |     .ascii \"Xen\n+   |            ^\n \n error: aborting due to previous error\n "}, {"sha": "42954ebcdc1cd4df6e4cdf7f70804773b13ecfca", "filename": "src/test/ui/macros/macros-nonfatal-errors.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -47,6 +47,8 @@ error: environment variable `RUST_HOPEFULLY_THIS_DOESNT_EXIST` not defined\n    |\n LL |     env!(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: format argument must be a string literal\n   --> $DIR/macros-nonfatal-errors.rs:23:13"}, {"sha": "eba00c5a9454e613a5d7cb9cf0ead5d1b6b36d35", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-bound.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,11 +5,7 @@ LL |     bar::<T::Output>()\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as MyTrait<'a>>::Output: 'a`...\n-note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n-  --> $DIR/projection-where-clause-env-wrong-bound.rs:15:5\n-   |\n-LL |     bar::<T::Output>()\n-   |     ^^^^^^^^^^^^^^^^\n+   = note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "34b83859a6bd2e346a996f628c8ceb066db44bee", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,11 +5,7 @@ LL |     bar::<<T as MyTrait<'a>>::Output>()\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as MyTrait<'a>>::Output: 'a`...\n-note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n-  --> $DIR/projection-where-clause-env-wrong-lifetime.rs:14:5\n-   |\n-LL |     bar::<<T as MyTrait<'a>>::Output>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "9563c0dff3644468961cfb59f8fc15e96cee8db6", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1,11 +1,11 @@\n-error[E0621]: explicit lifetime required in the type of `ss`\n+error: lifetime may not live long enough\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n-   |             --------------- help: add explicit lifetime `'static` to the type of `ss`: `&mut SomeStruct<'static>`\n+   |         -- has type `&mut SomeStruct<'1>`\n ...\n LL |     ss.r\n-   |     ^^^^ lifetime `'static` required\n+   |     ^^^^ returning this value requires that `'1` must outlive `'static`\n \n error[E0507]: cannot move out of `ss.r` which is behind a mutable reference\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5"}, {"sha": "708ab1cf38297d2d3778de18bf1039063c09453c", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -15,7 +15,7 @@ fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR explicit lifetime required in the type of `ss` [E0621]\n+    ss.r //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn store(ss: &mut SomeStruct, b: Box<dyn SomeTrait>) {"}, {"sha": "70a9bf22b8db372779e8bd2efbee667875c49af6", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1,11 +1,16 @@\n-error[E0621]: explicit lifetime required in the type of `ss`\n+error: cannot infer an appropriate lifetime\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n-   |             --------------- help: add explicit lifetime `'static` to the type of `ss`: `&mut SomeStruct<'static>`\n+   |             --------------- data with this lifetime...\n ...\n LL |     ss.r\n-   |     ^^^^ lifetime `'static` required\n+   |     ^^^^ ...is captured and required to be `'static` here\n+   |\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #2 defined on the function body at 14:1\n+   |\n+LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait + '_> {\n+   |                                                   ^^^^\n \n error[E0621]: explicit lifetime required in the type of `ss`\n   --> $DIR/object-lifetime-default-from-box-error.rs:31:12"}, {"sha": "7dbb9eebc757127599eb861fdba58f14ac0f3ed0", "filename": "src/test/ui/parser/shebang/shebang-doc-comment.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,6 @@\n+#!///bin/bash\n+[allow(unused_variables)]\n+//~^^ ERROR expected `[`, found doc comment\n+\n+// Doc comment is misinterpreted as a whitespace (regular comment) during shebang detection.\n+// Even if it wasn't, it would still result in an error, just a different one."}, {"sha": "f524f556837fbc1e30f412adec6dc9fb8810c2a3", "filename": "src/test/ui/parser/shebang/shebang-doc-comment.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,8 @@\n+error: expected `[`, found doc comment `///bin/bash`\n+  --> $DIR/shebang-doc-comment.rs:1:3\n+   |\n+LL | #!///bin/bash\n+   |   ^^^^^^^^^^^ expected `[`\n+\n+error: aborting due to previous error\n+"}, {"sha": "bf02ba8eb9199d2a4c090f200239d3f11436e8ca", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.nll.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -14,17 +14,17 @@ LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ lifetime `'static` required\n \n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:21:5\n+error: lifetime may not live long enough\n+  --> $DIR/region-object-lifetime-in-coercion.rs:20:5\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         - let's call the lifetime of this reference `'1`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^ lifetime `'static` required\n+   |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/region-object-lifetime-in-coercion.rs:26:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:24:5\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      -- -- lifetime `'b` defined here"}, {"sha": "d56eaf77b6646fe2163dd211eb0d5bb31da2d34a", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -11,20 +11,17 @@ fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n }\n \n fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-    Box::new(v)\n-        //~^ ERROR explicit lifetime required in the type of `v` [E0621]\n+    Box::new(v) //~ ERROR explicit lifetime required in the type of `v` [E0621]\n }\n \n fn c(v: &[u8]) -> Box<dyn Foo> {\n     // same as previous case due to RFC 599\n \n-    Box::new(v)\n-        //~^ ERROR explicit lifetime required in the type of `v` [E0621]\n+    Box::new(v) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n-    Box::new(v)\n-        //~^ ERROR cannot infer an appropriate lifetime due to conflicting\n+    Box::new(v) //~ ERROR cannot infer an appropriate lifetime due to conflicting\n }\n \n fn e<'a:'b,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {"}, {"sha": "1462af44cb15a6702f085410026d272bbe4600d2", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.stderr", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -14,40 +14,48 @@ LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ lifetime `'static` required\n \n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:21:5\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/region-object-lifetime-in-coercion.rs:20:14\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         ----- data with this lifetime...\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^ lifetime `'static` required\n+   |     ---------^-\n+   |     |        |\n+   |     |        ...and is captured here\n+   |     ...is required to be `'static` by this...\n+   |\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 17:1\n+   |\n+LL | fn c(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                               ^^^^\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/region-object-lifetime-in-coercion.rs:26:14\n+  --> $DIR/region-object-lifetime-in-coercion.rs:24:14\n    |\n LL |     Box::new(v)\n    |              ^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 25:6...\n-  --> $DIR/region-object-lifetime-in-coercion.rs:25:6\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 23:6...\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:6\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      ^^\n note: ...so that the expression is assignable\n-  --> $DIR/region-object-lifetime-in-coercion.rs:26:14\n+  --> $DIR/region-object-lifetime-in-coercion.rs:24:14\n    |\n LL |     Box::new(v)\n    |              ^\n    = note: expected `&[u8]`\n               found `&'a [u8]`\n-note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 25:9...\n-  --> $DIR/region-object-lifetime-in-coercion.rs:25:9\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 23:9...\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:9\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |         ^^\n note: ...so that the expression is assignable\n-  --> $DIR/region-object-lifetime-in-coercion.rs:26:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:24:5\n    |\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^"}, {"sha": "9303e0f8e66432a19d6ba148670cd2be3e65f2b7", "filename": "src/test/ui/regions/regions-close-associated-type-into-object.stderr", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-close-associated-type-into-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-close-associated-type-into-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-associated-type-into-object.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,11 +5,7 @@ LL |     Box::new(item)\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iter>::Item: 'static`...\n-note: ...so that the type `<T as Iter>::Item` will meet its required lifetime bounds\n-  --> $DIR/regions-close-associated-type-into-object.rs:15:5\n-   |\n-LL |     Box::new(item)\n-   |     ^^^^^^^^^^^^^^\n+   = note: ...so that the type `<T as Iter>::Item` will meet its required lifetime bounds\n \n error[E0310]: the associated type `<T as Iter>::Item` may not live long enough\n   --> $DIR/regions-close-associated-type-into-object.rs:22:5\n@@ -18,11 +14,7 @@ LL |     Box::new(item)\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iter>::Item: 'static`...\n-note: ...so that the type `std::boxed::Box<<T as Iter>::Item>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-associated-type-into-object.rs:22:5\n-   |\n-LL |     Box::new(item)\n-   |     ^^^^^^^^^^^^^^\n+   = note: ...so that the type `std::boxed::Box<<T as Iter>::Item>` will meet its required lifetime bounds\n \n error[E0309]: the associated type `<T as Iter>::Item` may not live long enough\n   --> $DIR/regions-close-associated-type-into-object.rs:28:5\n@@ -31,11 +23,7 @@ LL |     Box::new(item)\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iter>::Item: 'a`...\n-note: ...so that the type `<T as Iter>::Item` will meet its required lifetime bounds\n-  --> $DIR/regions-close-associated-type-into-object.rs:28:5\n-   |\n-LL |     Box::new(item)\n-   |     ^^^^^^^^^^^^^^\n+   = note: ...so that the type `<T as Iter>::Item` will meet its required lifetime bounds\n \n error[E0309]: the associated type `<T as Iter>::Item` may not live long enough\n   --> $DIR/regions-close-associated-type-into-object.rs:35:5\n@@ -44,11 +32,7 @@ LL |     Box::new(item)\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iter>::Item: 'a`...\n-note: ...so that the type `std::boxed::Box<<T as Iter>::Item>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-associated-type-into-object.rs:35:5\n-   |\n-LL |     Box::new(item)\n-   |     ^^^^^^^^^^^^^^\n+   = note: ...so that the type `std::boxed::Box<<T as Iter>::Item>` will meet its required lifetime bounds\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e5a80cbd54758c0fd22f4a2eabcec80c1567ea04", "filename": "src/test/ui/regions/regions-close-object-into-object-5.stderr", "status": "modified", "additions": 6, "deletions": 42, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,13 +5,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |     ^^^^^^^^^^\n-   |\n-note: ...so that the type `B<'_, T>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-object-into-object-5.rs:17:5\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |     ^^^^^^^^^^\n+   |     ^^^^^^^^^^ ...so that the type `B<'_, T>` will meet its required lifetime bounds\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:9\n@@ -20,13 +14,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |         ^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-close-object-into-object-5.rs:17:9\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |         ^\n+   |         ^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:9\n@@ -35,13 +23,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |         ^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-close-object-into-object-5.rs:17:9\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |         ^^^^^^\n+   |         ^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n@@ -50,13 +32,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |           ^^^\n-   |\n-note: ...so that the reference type `&dyn A<T>` does not outlive the data it points at\n-  --> $DIR/regions-close-object-into-object-5.rs:17:11\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |           ^^^\n+   |           ^^^ ...so that the reference type `&dyn A<T>` does not outlive the data it points at\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n@@ -65,13 +41,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |           ^^^\n-   |\n-note: ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n-  --> $DIR/regions-close-object-into-object-5.rs:17:11\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |           ^^^\n+   |           ^^^ ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n@@ -80,13 +50,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |           ^^^\n-   |\n-note: ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n-  --> $DIR/regions-close-object-into-object-5.rs:17:11\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |           ^^^\n+   |           ^^^ ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n \n error: aborting due to 6 previous errors\n "}, {"sha": "50274b066df60039130b9ba55bd0272b0de0f885", "filename": "src/test/ui/regions/regions-close-over-type-parameter-1.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,27 +4,15 @@ error[E0310]: the parameter type `A` may not live long enough\n LL | fn make_object1<A: SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n    |                 -- help: consider adding an explicit lifetime bound...: `A: 'static +`\n LL |     box v as Box<dyn SomeTrait + 'static>\n-   |     ^^^^^\n-   |\n-note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-close-over-type-parameter-1.rs:12:5\n-   |\n-LL |     box v as Box<dyn SomeTrait + 'static>\n-   |     ^^^^^\n+   |     ^^^^^ ...so that the type `A` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-close-over-type-parameter-1.rs:21:5\n    |\n LL | fn make_object3<'a, 'b, A: SomeTrait + 'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n    |                         -- help: consider adding an explicit lifetime bound...: `A: 'b +`\n LL |     box v as Box<dyn SomeTrait + 'b>\n-   |     ^^^^^\n-   |\n-note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-close-over-type-parameter-1.rs:21:5\n-   |\n-LL |     box v as Box<dyn SomeTrait + 'b>\n-   |     ^^^^^\n+   |     ^^^^^ ...so that the type `A` will meet its required lifetime bounds\n \n error: aborting due to 2 previous errors\n "}, {"sha": "705d21078ecd76032b69eeb80727dba0f32d75b2", "filename": "src/test/ui/regions/regions-close-param-into-object.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,13 +5,7 @@ LL | fn p1<T>(v: T) -> Box<dyn X + 'static>\n    |       - help: consider adding an explicit lifetime bound...: `T: 'static`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-close-param-into-object.rs:6:5\n-   |\n-LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:12:5\n@@ -20,13 +14,7 @@ LL | fn p2<T>(v: Box<T>) -> Box<dyn X + 'static>\n    |       - help: consider adding an explicit lifetime bound...: `T: 'static`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `std::boxed::Box<T>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-param-into-object.rs:12:5\n-   |\n-LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `std::boxed::Box<T>` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:18:5\n@@ -35,13 +23,7 @@ LL | fn p3<'a,T>(v: T) -> Box<dyn X + 'a>\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-close-param-into-object.rs:18:5\n-   |\n-LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:24:5\n@@ -50,13 +32,7 @@ LL | fn p4<'a,T>(v: Box<T>) -> Box<dyn X + 'a>\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `std::boxed::Box<T>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-param-into-object.rs:24:5\n-   |\n-LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `std::boxed::Box<T>` will meet its required lifetime bounds\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e32a36f72cd14b003a9207d88fe5ee514c2a91e1", "filename": "src/test/ui/regions/regions-enum-not-wf.stderr", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,13 +4,7 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | enum Ref1<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref1Variant1(RequireOutlives<'a, T>)\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:18:18\n-   |\n-LL |     Ref1Variant1(RequireOutlives<'a, T>)\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:23:25\n@@ -19,13 +13,7 @@ LL | enum Ref2<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref2Variant1,\n LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:23:25\n-   |\n-LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:35:1\n@@ -37,30 +25,15 @@ LL |   enum RefDouble<'a, 'b, T> {\n LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n LL | |\n LL | | }\n-   | |_^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:35:1\n-   |\n-LL | / enum RefDouble<'a, 'b, T> {\n-LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-LL | |\n-LL | | }\n-   | |_^\n+   | |_^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:36:23\n    |\n LL | enum RefDouble<'a, 'b, T> {\n    |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:36:23\n-   |\n-LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ea59ea11a143c6dd70126b373f9637a370340550", "filename": "src/test/ui/regions/regions-implied-bounds-projection-gap-1.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,13 +5,7 @@ LL | fn func<'x, T:Trait1<'x>>(t: &'x T::Foo)\n    |             -- help: consider adding an explicit lifetime bound...: `T: 'x +`\n LL | {\n LL |     wf::<&'x T>();\n-   |          ^^^^^\n-   |\n-note: ...so that the reference type `&'x T` does not outlive the data it points at\n-  --> $DIR/regions-implied-bounds-projection-gap-1.rs:16:10\n-   |\n-LL |     wf::<&'x T>();\n-   |          ^^^^^\n+   |          ^^^^^ ...so that the reference type `&'x T` does not outlive the data it points at\n \n error: aborting due to previous error\n "}, {"sha": "4ca5ac291d5bef33a6d08e6b3b7edf8638bc378d", "filename": "src/test/ui/regions/regions-infer-bound-from-trait-self.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait-self.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,11 +5,7 @@ LL |         check_bound(x, self)\n    |         ^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `Self: 'a`...\n-note: ...so that the type `Self` will meet its required lifetime bounds\n-  --> $DIR/regions-infer-bound-from-trait-self.rs:46:9\n-   |\n-LL |         check_bound(x, self)\n-   |         ^^^^^^^^^^^\n+   = note: ...so that the type `Self` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "196ee8ca7c0b59a43d2afab6939ede59a1664593", "filename": "src/test/ui/regions/regions-infer-bound-from-trait.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,27 +4,15 @@ error[E0309]: the parameter type `A` may not live long enough\n LL | fn bar1<'a,A>(x: Inv<'a>, a: A) {\n    |            - help: consider adding an explicit lifetime bound...: `A: 'a`\n LL |     check_bound(x, a)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-infer-bound-from-trait.rs:33:5\n-   |\n-LL |     check_bound(x, a)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-infer-bound-from-trait.rs:37:5\n    |\n LL | fn bar2<'a,'b,A:Is<'b>>(x: Inv<'a>, y: Inv<'b>, a: A) {\n    |               -- help: consider adding an explicit lifetime bound...: `A: 'a +`\n LL |     check_bound(x, a)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-infer-bound-from-trait.rs:37:5\n-   |\n-LL |     check_bound(x, a)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2bb51731583a6ffded7c220c0c825f69638b1999", "filename": "src/test/ui/rfc-2093-infer-outlives/dont-infer-static.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,13 +4,7 @@ error[E0310]: the parameter type `U` may not live long enough\n LL | struct Foo<U> {\n    |            - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     bar: Bar<U>\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `U` will meet its required lifetime bounds\n-  --> $DIR/dont-infer-static.rs:8:5\n-   |\n-LL |     bar: Bar<U>\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `U` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "e32a36f72cd14b003a9207d88fe5ee514c2a91e1", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-enum-not-wf.stderr", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,13 +4,7 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | enum Ref1<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref1Variant1(RequireOutlives<'a, T>)\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:18:18\n-   |\n-LL |     Ref1Variant1(RequireOutlives<'a, T>)\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:23:25\n@@ -19,13 +13,7 @@ LL | enum Ref2<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref2Variant1,\n LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:23:25\n-   |\n-LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:35:1\n@@ -37,30 +25,15 @@ LL |   enum RefDouble<'a, 'b, T> {\n LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n LL | |\n LL | | }\n-   | |_^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:35:1\n-   |\n-LL | / enum RefDouble<'a, 'b, T> {\n-LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-LL | |\n-LL | | }\n-   | |_^\n+   | |_^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:36:23\n    |\n LL | enum RefDouble<'a, 'b, T> {\n    |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:36:23\n-   |\n-LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error: aborting due to 4 previous errors\n "}, {"sha": "44812a51778a74d133e47992181a87213bac3e31", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-struct-not-wf.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,27 +4,15 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | impl<'a, T> Trait<'a, T> for usize {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a T;\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a T` does not outlive the data it points at\n-  --> $DIR/regions-struct-not-wf.rs:13:5\n-   |\n-LL |     type Out = &'a T;\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-struct-not-wf.rs:21:5\n    |\n LL | impl<'a, T> Trait<'a, T> for u32 {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = RefOk<'a, T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-struct-not-wf.rs:21:5\n-   |\n-LL |     type Out = RefOk<'a, T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0491]: in type `&'a &'b T`, reference has a longer lifetime than the data it references\n   --> $DIR/regions-struct-not-wf.rs:25:5"}, {"sha": "1aeabce5e8aaf267fa616f22b6d3ff8bf93f7d68", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,15 +2,10 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:16\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                ^^^^                 ---------- this return type evaluates to the `'static` lifetime...\n-   |                |\n-   |                ...but this borrow...\n-   |\n-note: ...can't outlive the lifetime `'_` as defined on the method body at 8:26\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:26\n-   |\n-LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          ^\n+   |                ^^^^  ----------     ---------- ...and required to be `'static` by this\n+   |                |     |\n+   |                |     data with this lifetime...\n+   |                ...is captured here...\n \n error: aborting due to previous error\n "}, {"sha": "04c475be787b89af4af76ca7f5cb93c83e167882", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -2,19 +2,15 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                               ----------   ^^^^ ...but this borrow...\n-   |                               |\n-   |                               this return type evaluates to the `'static` lifetime...\n+   |                ----------     ----------   ^^^^ ...and is captured here\n+   |                |              |\n+   |                |              ...is required to be `'static` by this...\n+   |                data with this lifetime...\n    |\n-note: ...can't outlive the anonymous lifetime #1 defined on the method body at 6:5\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:5\n-   |\n-LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the method body at 6:5\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the method body at 6:5\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n-   |                               ^^^^^^^^^^^^^^^\n+   |                                          ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "cf940f4e9267a965e81e4224ee8f0d3d01b60ee4", "filename": "src/test/ui/suggestions/fn-trait-notation.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.fixed?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+fn e0658<F, G, H>(f: F, g: G, h: H) -> i32\n+where\n+    F: Fn(i32) -> i32, //~ ERROR E0658\n+    G: Fn(i32, i32) -> (i32, i32), //~ ERROR E0658\n+    H: Fn(i32) -> i32, //~ ERROR E0658\n+{\n+    f(3);\n+    g(3, 4);\n+    h(3)\n+}\n+\n+fn main() {\n+    e0658(\n+        |a| a,\n+        |a, b| (b, a),\n+        |a| a,\n+    );\n+}"}, {"sha": "f0bb03315d987a5e2d941a5e9e5f4127684bd9b5", "filename": "src/test/ui/suggestions/fn-trait-notation.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+fn e0658<F, G, H>(f: F, g: G, h: H) -> i32\n+where\n+    F: Fn<i32, Output = i32>, //~ ERROR E0658\n+    G: Fn<(i32, i32, ), Output = (i32, i32)>, //~ ERROR E0658\n+    H: Fn<(i32,), Output = i32>, //~ ERROR E0658\n+{\n+    f(3);\n+    g(3, 4);\n+    h(3)\n+}\n+\n+fn main() {\n+    e0658(\n+        |a| a,\n+        |a, b| (b, a),\n+        |a| a,\n+    );\n+}"}, {"sha": "3e3b54174401794aeea4d5269d9353a8c4ccab3d", "filename": "src/test/ui/suggestions/fn-trait-notation.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-trait-notation.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,30 @@\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n+  --> $DIR/fn-trait-notation.rs:4:8\n+   |\n+LL |     F: Fn<i32, Output = i32>,\n+   |        ^^^^^^^^^^^^^^^^^^^^^ help: use parenthetical notation instead: `Fn(i32) -> i32`\n+   |\n+   = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n+  --> $DIR/fn-trait-notation.rs:5:8\n+   |\n+LL |     G: Fn<(i32, i32, ), Output = (i32, i32)>,\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use parenthetical notation instead: `Fn(i32, i32) -> (i32, i32)`\n+   |\n+   = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n+  --> $DIR/fn-trait-notation.rs:6:8\n+   |\n+LL |     H: Fn<(i32,), Output = i32>,\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^ help: use parenthetical notation instead: `Fn(i32) -> i32`\n+   |\n+   = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "2072b00f7b2cb3f3512cba02809c1166e7dcf4de", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.nll.stderr", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,115 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/missing-lifetimes-in-signature.rs:37:11\n+   |\n+LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |        -  ^^ undeclared lifetime\n+   |        |\n+   |        help: consider introducing lifetime `'a` here: `'a,`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:15:37\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                          -          ^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |                          |\n+   |                          let's call the lifetime of this reference `'1`\n+   |\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 25:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:1\n+   |\n+LL | / fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 47:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:1\n+   |\n+LL | / fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:58\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                                          ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the method body at 59:5...\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:5\n+   |\n+LL | /     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+LL | |\n+LL | |         move || {\n+LL | |             *dest = g.get();\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:68:45\n+   |\n+LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 68:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:68:1\n+   |\n+LL | / fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0621]: explicit lifetime required in the type of `dest`\n+  --> $DIR/missing-lifetimes-in-signature.rs:73:5\n+   |\n+LL |   fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                    ------ help: add explicit lifetime `'a` to the type of `dest`: `&'a mut T`\n+...\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^ lifetime `'a` required\n+\n+error[E0309]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:79:44\n+   |\n+LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+   |                                            ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `G: 'a`...\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0261, E0309, E0621.\n+For more information about an error, try `rustc --explain E0261`."}, {"sha": "d3853445dfdfebb01518eb66ac063a0872c38fcb", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,110 @@\n+pub trait Get<T> {\n+    fn get(self) -> T;\n+}\n+\n+struct Foo {\n+    x: usize,\n+}\n+\n+impl Get<usize> for Foo {\n+    fn get(self) -> usize {\n+        self.x\n+    }\n+}\n+\n+fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+where\n+    G: Get<T>\n+{\n+    move || { //~ ERROR cannot infer an appropriate lifetime\n+        *dest = g.get();\n+    }\n+}\n+\n+// After applying suggestion for `foo`:\n+fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+\n+// After applying suggestion for `bar`:\n+fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ //~ ERROR undeclared lifetime\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// After applying suggestion for `baz`:\n+fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// Same as above, but show that we pay attention to lifetime names from parent item\n+impl<'a> Foo {\n+    fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+        //~^ ERROR the parameter type `G` may not live long enough\n+        move || {\n+            *dest = g.get();\n+        }\n+    }\n+}\n+\n+// After applying suggestion for `qux`:\n+fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+//~^ ERROR explicit lifetime required in the type of `dest`\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// Potential incorrect attempt:\n+fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+\n+// We need to tie the lifetime of `G` with the lifetime of `&mut T` and the returned closure:\n+fn ok<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// This also works. The `'_` isn't necessary but it's where we arrive to following the suggestions:\n+fn ok2<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + '_ + 'a\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5cf170d566ca94acb9767161c8e4609de7d1526b", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -0,0 +1,126 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/missing-lifetimes-in-signature.rs:37:11\n+   |\n+LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |        -  ^^ undeclared lifetime\n+   |        |\n+   |        help: consider introducing lifetime `'a` here: `'a,`\n+\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/missing-lifetimes-in-signature.rs:19:5\n+   |\n+LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                            ------     ------------- ...is required to be `'static` by this...\n+   |                            |\n+   |                            data with this lifetime...\n+...\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^ ...and is captured here\n+   |\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 15:1\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                                   ^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 25:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:1\n+   |\n+LL | / fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:30:5: 32:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL | fn bar<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |        ^^^^^                                                   ^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 47:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:1\n+   |\n+LL | / fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:52:5: 54:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL | fn qux<'b, 'a, G: 'b + 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'b\n+   |        ^^^     ^^^^^^^                                                  ^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:58\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                                          ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the method body at 59:5...\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:5\n+   |\n+LL | /     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+LL | |\n+LL | |         move || {\n+LL | |             *dest = g.get();\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:61:9: 63:10 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:58\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                                          ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL |     fn qux<'c, 'b, G: 'c + Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'c {\n+   |            ^^^     ^^^^^^^                                                           ^^^^\n+\n+error[E0621]: explicit lifetime required in the type of `dest`\n+  --> $DIR/missing-lifetimes-in-signature.rs:68:45\n+   |\n+LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                  ------     ^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'a` required\n+   |                                  |\n+   |                                  help: add explicit lifetime `'a` to the type of `dest`: `&'a mut T`\n+\n+error[E0309]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:79:44\n+   |\n+LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+   |            -                               ^^^^^^^^^^^^^^^^^^ ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:84:5: 86:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+   |            |\n+   |            help: consider adding an explicit lifetime bound...: `G: 'a`\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors have detailed explanations: E0261, E0309, E0621.\n+For more information about an error, try `rustc --explain E0261`."}, {"sha": "643dac25724972168904f14bebbcc95168c4e2ff", "filename": "src/test/ui/suggestions/suggest-impl-trait-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,13 +5,7 @@ LL | fn foo(d: impl Debug) {\n    |           ---------- help: consider adding an explicit lifetime bound...: `impl Debug + 'static`\n LL |\n LL |     bar(d);\n-   |     ^^^\n-   |\n-note: ...so that the type `impl Debug` will meet its required lifetime bounds\n-  --> $DIR/suggest-impl-trait-lifetime.rs:7:5\n-   |\n-LL |     bar(d);\n-   |     ^^^\n+   |     ^^^ ...so that the type `impl Debug` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "e2540e424cb19ac9d0990673e6ac6c0f6f56615d", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -22,16 +22,10 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/generic_type_does_not_live_long_enough.rs:9:1\n    |\n LL | type WrongGeneric<T> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n ...\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n    |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:1\n-   |\n-LL | type WrongGeneric<T> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3577dd59289e5ca7c3a42750cb845fcf3c4b162d", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.stderr", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -1,31 +1,16 @@\n-error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements\n+error: cannot infer an appropriate lifetime\n   --> $DIR/dyn-trait-underscore.rs:8:20\n    |\n+LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n+   |                ---- data with this lifetime...\n+LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter())\n-   |                    ^^^^\n+   |     ---------------^^^^--- ...is captured and required to be `'static` here\n    |\n-note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the function body at 6:1...\n-  --> $DIR/dyn-trait-underscore.rs:6:1\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 6:1\n    |\n-LL | / fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n-LL | |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n-LL | |     Box::new(items.iter())\n-LL | | }\n-   | |_^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/dyn-trait-underscore.rs:8:14\n-   |\n-LL |     Box::new(items.iter())\n-   |              ^^^^^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the expression is assignable\n-  --> $DIR/dyn-trait-underscore.rs:8:5\n-   |\n-LL |     Box::new(items.iter())\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected `std::boxed::Box<(dyn std::iter::Iterator<Item = &T> + 'static)>`\n-              found `std::boxed::Box<dyn std::iter::Iterator<Item = &T>>`\n+LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T> + '_> {\n+   |                                                   ^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "f3b32ad3f7e85d27399c8e9a574d4aad8789606a", "filename": "src/test/ui/wf/wf-impl-associated-type-region.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,13 +4,7 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | impl<'a, T> Foo<'a> for T {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Bar = &'a T;\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a T` does not outlive the data it points at\n-  --> $DIR/wf-impl-associated-type-region.rs:10:5\n-   |\n-LL |     type Bar = &'a T;\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n \n error: aborting due to previous error\n "}, {"sha": "a79c446247794ad59a1fdbc56bfd1922059da488", "filename": "src/test/ui/wf/wf-in-fn-type-static.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,13 +5,7 @@ LL | struct Foo<T> {\n    |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // needs T: 'static\n LL |     x: fn() -> &'static T\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'static T` does not outlive the data it points at\n-  --> $DIR/wf-in-fn-type-static.rs:13:5\n-   |\n-LL |     x: fn() -> &'static T\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/wf-in-fn-type-static.rs:18:5\n@@ -20,13 +14,7 @@ LL | struct Bar<T> {\n    |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // needs T: Copy\n LL |     x: fn(&'static T)\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'static T` does not outlive the data it points at\n-  --> $DIR/wf-in-fn-type-static.rs:18:5\n-   |\n-LL |     x: fn(&'static T)\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c0057f3c82977fd990fc09b3251108ec65239106", "filename": "src/test/ui/wf/wf-in-obj-type-static.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,13 +5,7 @@ LL | struct Foo<T> {\n    |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // needs T: 'static\n LL |     x: dyn Object<&'static T>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'static T` does not outlive the data it points at\n-  --> $DIR/wf-in-obj-type-static.rs:14:5\n-   |\n-LL |     x: dyn Object<&'static T>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n \n error: aborting due to previous error\n "}, {"sha": "4c25ab9593958ddf8d26de9dc9da0e548ebc6d21", "filename": "src/test/ui/wf/wf-outlives-ty-in-fn-or-trait.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -4,27 +4,15 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | impl<'a, T> Trait<'a, T> for usize {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a fn(T);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a fn(T)` does not outlive the data it points at\n-  --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:9:5\n-   |\n-LL |     type Out = &'a fn(T);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'a fn(T)` does not outlive the data it points at\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:19:5\n    |\n LL | impl<'a, T> Trait<'a, T> for u32 {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a dyn Baz<T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a (dyn Baz<T> + 'a)` does not outlive the data it points at\n-  --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:19:5\n-   |\n-LL |     type Out = &'a dyn Baz<T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'a (dyn Baz<T> + 'a)` does not outlive the data it points at\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ae681ba6c9bb5c573fd8f7e3fe555cdd07370e3b", "filename": "src/test/ui/wf/wf-trait-associated-type-region.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5402efdda733d163895d1edb9bcf7f401dd33b/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-region.stderr?ref=8c5402efdda733d163895d1edb9bcf7f401dd33b", "patch": "@@ -5,11 +5,7 @@ LL |     type Type2 = &'a Self::Type1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<Self as SomeTrait<'a>>::Type1: 'a`...\n-note: ...so that the reference type `&'a <Self as SomeTrait<'a>>::Type1` does not outlive the data it points at\n-  --> $DIR/wf-trait-associated-type-region.rs:9:5\n-   |\n-LL |     type Type2 = &'a Self::Type1;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...so that the reference type `&'a <Self as SomeTrait<'a>>::Type1` does not outlive the data it points at\n \n error: aborting due to previous error\n "}]}