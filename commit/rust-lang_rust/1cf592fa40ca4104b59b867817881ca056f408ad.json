{"sha": "1cf592fa40ca4104b59b867817881ca056f408ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZjU5MmZhNDBjYTQxMDRiNTliODY3ODE3ODgxY2EwNTZmNDA4YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-22T02:17:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-22T02:17:24Z"}, "message": "Auto merge of #36551 - eddyb:meta-games, r=nikomatsakis\n\nRefactor away RBML from rustc_metadata.\n\nRBML and `ty{en,de}code` have had their long-overdue purge. Summary of changes:\n* Metadata is now a tree encoded in post-order and with relative backward references pointing to children nodes. With auto-deriving and type safety, this makes maintenance and adding new information to metadata painless and bug-free by default. It's also more compact and cache-friendly (cache misses should be proportional to the depth of the node being accessed, not the number of siblings as in EBML/RBML).\n* Metadata sizes have been reduced, for `libcore` it went down 16% (`8.38MB` -> `7.05MB`) and for `libstd` 14% (`3.53MB` -> `3.03MB`), while encoding more or less the same information\n* Specialization is used in the bundled `libserialize` (crates.io `rustc_serialize` remains unaffected) to customize the encoding (and more importantly, decoding) of various types, most notably those interned in the `TyCtxt`. Some of this abuses a soundness hole pending a fix (cc @aturon), but when that fix arrives, we'll move to macros 1.1 `#[derive]` and custom `TyCtxt`-aware serialization traits.\n* Enumerating children of modules from other crates is now orthogonal to describing those items via `Def` - this is a step towards bridging crate-local HIR and cross-crate metadata\n* `CrateNum` has been moved to `rustc` and both it and `NodeId` are now newtypes instead of `u32` aliases, for specializing their decoding. This is `[syntax-breaking]` (cc @Manishearth ).\n\ncc @rust-lang/compiler", "tree": {"sha": "19a912a724e96de8d4bf50a02407ef592d21459e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19a912a724e96de8d4bf50a02407ef592d21459e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cf592fa40ca4104b59b867817881ca056f408ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf592fa40ca4104b59b867817881ca056f408ad", "html_url": "https://github.com/rust-lang/rust/commit/1cf592fa40ca4104b59b867817881ca056f408ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cf592fa40ca4104b59b867817881ca056f408ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "html_url": "https://github.com/rust-lang/rust/commit/4f9812a59ab7247f0f52b01ca89b0793a2d289c3"}, {"sha": "4ac30013c3402d9349f83888a9d0903f0a68746e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac30013c3402d9349f83888a9d0903f0a68746e", "html_url": "https://github.com/rust-lang/rust/commit/4ac30013c3402d9349f83888a9d0903f0a68746e"}], "stats": {"total": 16880, "additions": 4646, "deletions": 12234}, "files": [{"sha": "86bb3a8ca0ccc8b09ec4bf277ed59b0513732516", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -61,7 +61,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n                 rustc_const_eval rustc_const_math rustc_incremental rustc_macro\n HOST_CRATES := syntax syntax_ext proc_macro syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n-\t\tflate arena graphviz rbml log serialize\n+\t\tflate arena graphviz log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n \n DEPS_core :=\n@@ -96,7 +96,6 @@ DEPS_getopts := std\n DEPS_graphviz := std\n DEPS_log := std\n DEPS_num := std\n-DEPS_rbml := std log serialize\n DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n@@ -110,7 +109,7 @@ DEPS_rustc_const_math := std syntax log serialize\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n \t\t\t     rustc_back graphviz syntax_pos\n \n-DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml \\\n+DEPS_rustc := syntax fmt_macros flate arena serialize getopts \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n \t      rustc_const_math syntax_pos rustc_errors\n DEPS_rustc_back := std syntax flate log libc\n@@ -126,7 +125,7 @@ DEPS_rustc_errors := log libc serialize syntax_pos\n DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_macro := std syntax\n-DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rbml rustc_const_math \\\n+DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rustc_const_math \\\n \t\t\trustc_macro syntax_ext\n DEPS_rustc_passes := syntax syntax_pos rustc core rustc_const_eval rustc_errors\n DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags\n@@ -137,7 +136,7 @@ DEPS_rustc_privacy := rustc log syntax syntax_pos\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n                     rustc_const_math rustc_const_eval rustc_incremental rustc_errors syntax_pos\n-DEPS_rustc_incremental := rbml rustc syntax_pos serialize rustc_data_structures\n+DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n DEPS_rustc_typeck := rustc syntax syntax_pos rustc_platform_intrinsics rustc_const_math \\\n                      rustc_const_eval rustc_errors"}, {"sha": "fc1f4b5561a78c7742bc13e830c62a1bf0caaf9f", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -27,7 +27,7 @@ TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system libc \\\n \t\t\t\t  panic_abort,$(TARGET_CRATES)) \\\n \t\t\tcollectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES) arena flate fmt_macros getopts graphviz \\\n-                log rand rbml serialize syntax term test\n+                log rand serialize syntax term test\n TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve \\\n \t\t   \t\trustc_trans rustc_lint,\\\n                      $(HOST_CRATES))"}, {"sha": "ab89ac2b7a1eb6a1c5f66cccd696d9ca3a863c1d", "filename": "src/librbml/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrbml%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrbml%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2FCargo.toml?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,13 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rbml\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rbml\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-log = { path = \"../liblog\" }\n-serialize = { path = \"../libserialize\" }"}, {"sha": "5a8a52f7dfc6e15d9b5bc215395f620ae75e1747", "filename": "src/librbml/lib.rs", "status": "removed", "additions": 0, "deletions": 1609, "changes": 1609, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,1609 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Really Bad Markup Language (rbml) is an internal serialization format of rustc.\n-//! This is not intended to be used by users.\n-//!\n-//! Originally based on the Extensible Binary Markup Language\n-//! (ebml; http://www.matroska.org/technical/specs/rfc/index.html),\n-//! it is now a separate format tuned for the rust object metadata.\n-//!\n-//! # Encoding\n-//!\n-//! RBML document consists of the tag, length and data.\n-//! The encoded data can contain multiple RBML documents concatenated.\n-//!\n-//! **Tags** are a hint for the following data.\n-//! Tags are a number from 0x000 to 0xfff, where 0xf0 through 0xff is reserved.\n-//! Tags less than 0xf0 are encoded in one literal byte.\n-//! Tags greater than 0xff are encoded in two big-endian bytes,\n-//! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n-//!\n-//! **Lengths** encode the length of the following data.\n-//! It is a variable-length unsigned isize, and one of the following forms:\n-//!\n-//! - `80` through `fe` for lengths up to 0x7e;\n-//! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n-//! - `20 40 00` through `3f ff ff` for lengths up to 0x1fffff;\n-//! - `10 20 00 00` through `1f ff ff ff` for lengths up to 0xfffffff.\n-//!\n-//! The \"overlong\" form is allowed so that the length can be encoded\n-//! without the prior knowledge of the encoded data.\n-//! For example, the length 0 can be represented either by `80`, `40 00`,\n-//! `20 00 00` or `10 00 00 00`.\n-//! The encoder tries to minimize the length if possible.\n-//! Also, some predefined tags listed below are so commonly used that\n-//! their lengths are omitted (\"implicit length\").\n-//!\n-//! **Data** can be either binary bytes or zero or more nested RBML documents.\n-//! Nested documents cannot overflow, and should be entirely contained\n-//! within a parent document.\n-//!\n-//! # Predefined Tags\n-//!\n-//! Most RBML tags are defined by the application.\n-//! (For the rust object metadata, see also `rustc::metadata::common`.)\n-//! RBML itself does define a set of predefined tags however,\n-//! intended for the auto-serialization implementation.\n-//!\n-//! Predefined tags with an implicit length:\n-//!\n-//! - `U8`  (`00`): 1-byte unsigned integer.\n-//! - `U16` (`01`): 2-byte big endian unsigned integer.\n-//! - `U32` (`02`): 4-byte big endian unsigned integer.\n-//! - `U64` (`03`): 8-byte big endian unsigned integer.\n-//!   Any of `U*` tags can be used to encode primitive unsigned integer types,\n-//!   as long as it is no greater than the actual size.\n-//!   For example, `u8` can only be represented via the `U8` tag.\n-//!\n-//! - `I8`  (`04`): 1-byte signed integer.\n-//! - `I16` (`05`): 2-byte big endian signed integer.\n-//! - `I32` (`06`): 4-byte big endian signed integer.\n-//! - `I64` (`07`): 8-byte big endian signed integer.\n-//!   Similar to `U*` tags. Always uses two's complement encoding.\n-//!\n-//! - `Bool` (`08`): 1-byte boolean value, `00` for false and `01` for true.\n-//!\n-//! - `Char` (`09`): 4-byte big endian Unicode scalar value.\n-//!   Surrogate pairs or out-of-bound values are invalid.\n-//!\n-//! - `F32` (`0a`): 4-byte big endian unsigned integer representing\n-//!   IEEE 754 binary32 floating-point format.\n-//! - `F64` (`0b`): 8-byte big endian unsigned integer representing\n-//!   IEEE 754 binary64 floating-point format.\n-//!\n-//! - `Sub8`  (`0c`): 1-byte unsigned integer for supplementary information.\n-//! - `Sub32` (`0d`): 4-byte unsigned integer for supplementary information.\n-//!   Those two tags normally occur as the first subdocument of certain tags,\n-//!   namely `Enum`, `Vec` and `Map`, to provide a variant or size information.\n-//!   They can be used interchangeably.\n-//!\n-//! Predefined tags with an explicit length:\n-//!\n-//! - `Str` (`10`): A UTF-8-encoded string.\n-//!\n-//! - `Enum` (`11`): An enum.\n-//!   The first subdocument should be `Sub*` tags with a variant ID.\n-//!   Subsequent subdocuments, if any, encode variant arguments.\n-//!\n-//! - `Vec` (`12`): A vector (sequence).\n-//! - `VecElt` (`13`): A vector element.\n-//!   The first subdocument should be `Sub*` tags with the number of elements.\n-//!   Subsequent subdocuments should be `VecElt` tag per each element.\n-//!\n-//! - `Map` (`14`): A map (associated array).\n-//! - `MapKey` (`15`): A key part of the map entry.\n-//! - `MapVal` (`16`): A value part of the map entry.\n-//!   The first subdocument should be `Sub*` tags with the number of entries.\n-//!   Subsequent subdocuments should be an alternating sequence of\n-//!   `MapKey` and `MapVal` tags per each entry.\n-//!\n-//! - `Opaque` (`17`): An opaque, custom-format tag.\n-//!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n-//!   Rustc typically uses this to encode type information.\n-//!\n-//! First 0x20 tags are reserved by RBML; custom tags start at 0x20.\n-\n-#![crate_name = \"rbml\"]\n-#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n-\n-#![feature(rustc_private)]\n-#![feature(staged_api)]\n-#![feature(question_mark)]\n-\n-#![cfg_attr(test, feature(test))]\n-\n-extern crate serialize;\n-\n-#[cfg(test)]\n-extern crate serialize as rustc_serialize; // Used by RustcEncodable\n-\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(test)]\n-extern crate test;\n-\n-pub mod opaque;\n-pub mod leb128;\n-\n-pub use self::EbmlEncoderTag::*;\n-pub use self::Error::*;\n-\n-use std::str;\n-use std::fmt;\n-\n-/// Common data structures\n-#[derive(Clone, Copy)]\n-pub struct Doc<'a> {\n-    pub data: &'a [u8],\n-    pub start: usize,\n-    pub end: usize,\n-}\n-\n-impl<'doc> Doc<'doc> {\n-    pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n-        Doc {\n-            data: data,\n-            start: 0,\n-            end: data.len(),\n-        }\n-    }\n-\n-    pub fn get(&self, tag: usize) -> Doc<'doc> {\n-        reader::get_doc(*self, tag)\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.start == self.end\n-    }\n-\n-    pub fn as_str(&self) -> &'doc str {\n-        str::from_utf8(&self.data[self.start..self.end]).unwrap()\n-    }\n-\n-    pub fn to_string(&self) -> String {\n-        self.as_str().to_string()\n-    }\n-}\n-\n-pub struct TaggedDoc<'a> {\n-    tag: usize,\n-    pub doc: Doc<'a>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EbmlEncoderTag {\n-    // tags 00..1f are reserved for auto-serialization.\n-    // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n-    EsU8 = 0x00, // + 1 byte\n-    EsU16 = 0x01, // + 2 bytes\n-    EsU32 = 0x02, // + 4 bytes\n-    EsU64 = 0x03, // + 8 bytes\n-    EsI8 = 0x04, // + 1 byte\n-    EsI16 = 0x05, // + 2 bytes\n-    EsI32 = 0x06, // + 4 bytes\n-    EsI64 = 0x07, // + 8 bytes\n-    EsBool = 0x08, // + 1 byte\n-    EsChar = 0x09, // + 4 bytes\n-    EsF32 = 0x0a, // + 4 bytes\n-    EsF64 = 0x0b, // + 8 bytes\n-    EsSub8 = 0x0c, // + 1 byte\n-    EsSub32 = 0x0d, // + 4 bytes\n-    // 0x0e and 0x0f are reserved\n-    EsStr = 0x10,\n-    EsEnum = 0x11, // encodes the variant id as the first EsSub*\n-    EsVec = 0x12, // encodes the # of elements as the first EsSub*\n-    EsVecElt = 0x13,\n-    EsMap = 0x14, // encodes the # of pairs as the first EsSub*\n-    EsMapKey = 0x15,\n-    EsMapVal = 0x16,\n-    EsOpaque = 0x17,\n-}\n-\n-const NUM_TAGS: usize = 0x1000;\n-const NUM_IMPLICIT_TAGS: usize = 0x0e;\n-\n-#[cfg_attr(rustfmt, rustfmt_skip)]\n-static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n-    1, 2, 4, 8, // EsU*\n-    1, 2, 4, 8, // ESI*\n-    1, // EsBool\n-    4, // EsChar\n-    4, 8, // EsF*\n-    1, 4, // EsSub*\n-];\n-\n-#[derive(Debug)]\n-pub enum Error {\n-    IntTooBig(usize),\n-    InvalidTag(usize),\n-    Expected(String),\n-    IoError(std::io::Error),\n-    ApplicationError(String),\n-}\n-\n-impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME: this should be a more useful display form\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-// --------------------------------------\n-\n-pub mod reader {\n-    use std::char;\n-\n-    use std::isize;\n-    use std::mem::transmute;\n-\n-    use serialize;\n-\n-    use super::opaque;\n-    use super::{ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n-                EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32,\n-                EsChar, EsStr, EsMapVal, EsOpaque, EbmlEncoderTag, Doc, TaggedDoc, Error,\n-                IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN};\n-\n-    pub type DecodeResult<T> = Result<T, Error>;\n-    // rbml reading\n-\n-    macro_rules! try_or {\n-        ($e:expr, $r:expr) => (\n-            match $e {\n-                Ok(e) => e,\n-                Err(e) => {\n-                    debug!(\"ignored error: {:?}\", e);\n-                    return $r\n-                }\n-            }\n-        )\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct Res {\n-        pub val: usize,\n-        pub next: usize,\n-    }\n-\n-    pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        let v = data[start] as usize;\n-        if v < 0xf0 {\n-            Ok(Res {\n-                val: v,\n-                next: start + 1,\n-            })\n-        } else if v > 0xf0 {\n-            Ok(Res {\n-                val: ((v & 0xf) << 8) | data[start + 1] as usize,\n-                next: start + 2,\n-            })\n-        } else {\n-            // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n-            Err(InvalidTag(v))\n-        }\n-    }\n-\n-    #[inline(never)]\n-    fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        let a = data[start];\n-        if a & 0x80 != 0 {\n-            return Ok(Res {\n-                val: (a & 0x7f) as usize,\n-                next: start + 1,\n-            });\n-        }\n-        if a & 0x40 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x3f) as usize) << 8 | (data[start + 1] as usize),\n-                next: start + 2,\n-            });\n-        }\n-        if a & 0x20 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x1f) as usize) << 16 | (data[start + 1] as usize) << 8 |\n-                     (data[start + 2] as usize),\n-                next: start + 3,\n-            });\n-        }\n-        if a & 0x10 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x0f) as usize) << 24 | (data[start + 1] as usize) << 16 |\n-                     (data[start + 2] as usize) << 8 |\n-                     (data[start + 3] as usize),\n-                next: start + 4,\n-            });\n-        }\n-        Err(IntTooBig(a as usize))\n-    }\n-\n-    pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        if data.len() - start < 4 {\n-            return vuint_at_slow(data, start);\n-        }\n-\n-        // Lookup table for parsing EBML Element IDs as per\n-        // http://ebml.sourceforge.net/specs/ The Element IDs are parsed by\n-        // reading a big endian u32 positioned at data[start].  Using the four\n-        // most significant bits of the u32 we lookup in the table below how\n-        // the element ID should be derived from it.\n-        //\n-        // The table stores tuples (shift, mask) where shift is the number the\n-        // u32 should be right shifted with and mask is the value the right\n-        // shifted value should be masked with.  If for example the most\n-        // significant bit is set this means it's a class A ID and the u32\n-        // should be right shifted with 24 and masked with 0x7f. Therefore we\n-        // store (24, 0x7f) at index 0x8 - 0xF (four bit numbers where the most\n-        // significant bit is set).\n-        //\n-        // By storing the number of shifts and masks in a table instead of\n-        // checking in order if the most significant bit is set, the second\n-        // most significant bit is set etc. we can replace up to three\n-        // \"and+branch\" with a single table lookup which gives us a measured\n-        // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(usize, u32); 16] = [(0, 0x0),\n-                                                       (0, 0x0fffffff),\n-                                                       (8, 0x1fffff),\n-                                                       (8, 0x1fffff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f)];\n-\n-        unsafe {\n-            let ptr = data.as_ptr().offset(start as isize) as *const u32;\n-            let val = u32::from_be(*ptr);\n-\n-            let i = (val >> 28) as usize;\n-            let (shift, mask) = SHIFT_MASK_TABLE[i];\n-            Ok(Res {\n-                val: ((val >> shift) & mask) as usize,\n-                next: start + ((32 - shift) >> 3),\n-            })\n-        }\n-    }\n-\n-    pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n-        if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n-            Ok(Res {\n-                val: TAG_IMPLICIT_LEN[tag.val] as usize,\n-                next: tag.next,\n-            })\n-        } else {\n-            vuint_at(data, tag.next)\n-        }\n-    }\n-\n-    pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n-        let elt_tag = tag_at(data, start)?;\n-        let elt_size = tag_len_at(data, elt_tag)?;\n-        let end = elt_size.next + elt_size.val;\n-        Ok(TaggedDoc {\n-            tag: elt_tag.val,\n-            doc: Doc {\n-                data: data,\n-                start: elt_size.next,\n-                end: end,\n-            },\n-        })\n-    }\n-\n-    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = try_or!(tag_at(d.data, pos), None);\n-            let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tg {\n-                return Some(Doc {\n-                    data: d.data,\n-                    start: elt_size.next,\n-                    end: pos,\n-                });\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n-        match maybe_get_doc(d, tg) {\n-            Some(d) => d,\n-            None => {\n-                error!(\"failed to find block with tag {:?}\", tg);\n-                panic!();\n-            }\n-        }\n-    }\n-\n-    pub fn docs<'a>(d: Doc<'a>) -> DocsIterator<'a> {\n-        DocsIterator { d: d }\n-    }\n-\n-    pub struct DocsIterator<'a> {\n-        d: Doc<'a>,\n-    }\n-\n-    impl<'a> Iterator for DocsIterator<'a> {\n-        type Item = (usize, Doc<'a>);\n-\n-        fn next(&mut self) -> Option<(usize, Doc<'a>)> {\n-            if self.d.start >= self.d.end {\n-                return None;\n-            }\n-\n-            let elt_tag = try_or!(tag_at(self.d.data, self.d.start), {\n-                self.d.start = self.d.end;\n-                None\n-            });\n-            let elt_size = try_or!(tag_len_at(self.d.data, elt_tag), {\n-                self.d.start = self.d.end;\n-                None\n-            });\n-\n-            let end = elt_size.next + elt_size.val;\n-            let doc = Doc {\n-                data: self.d.data,\n-                start: elt_size.next,\n-                end: end,\n-            };\n-\n-            self.d.start = end;\n-            return Some((elt_tag.val, doc));\n-        }\n-    }\n-\n-    pub fn tagged_docs<'a>(d: Doc<'a>, tag: usize) -> TaggedDocsIterator<'a> {\n-        TaggedDocsIterator {\n-            iter: docs(d),\n-            tag: tag,\n-        }\n-    }\n-\n-    pub struct TaggedDocsIterator<'a> {\n-        iter: DocsIterator<'a>,\n-        tag: usize,\n-    }\n-\n-    impl<'a> Iterator for TaggedDocsIterator<'a> {\n-        type Item = Doc<'a>;\n-\n-        fn next(&mut self) -> Option<Doc<'a>> {\n-            while let Some((tag, doc)) = self.iter.next() {\n-                if tag == self.tag {\n-                    return Some(doc);\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    pub fn with_doc_data<T, F>(d: Doc, f: F) -> T\n-        where F: FnOnce(&[u8]) -> T\n-    {\n-        f(&d.data[d.start..d.end])\n-    }\n-\n-    pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert_eq!(d.end, d.start + 1);\n-        d.data[d.start]\n-    }\n-\n-    pub fn doc_as_u64(d: Doc) -> u64 {\n-        if d.end >= 8 {\n-            // For performance, we read 8 big-endian bytes,\n-            // and mask off the junk if there is any. This\n-            // obviously won't work on the first 8 bytes\n-            // of a file - we will fall of the start\n-            // of the page and segfault.\n-\n-            let mut b = [0; 8];\n-            b.copy_from_slice(&d.data[d.end - 8..d.end]);\n-            let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n-            let len = d.end - d.start;\n-            if len < 8 {\n-                data & ((1 << (len * 8)) - 1)\n-            } else {\n-                data\n-            }\n-        } else {\n-            let mut result = 0;\n-            for b in &d.data[d.start..d.end] {\n-                result = (result << 8) + (*b as u64);\n-            }\n-            result\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn doc_as_u16(d: Doc) -> u16 {\n-        doc_as_u64(d) as u16\n-    }\n-    #[inline]\n-    pub fn doc_as_u32(d: Doc) -> u32 {\n-        doc_as_u64(d) as u32\n-    }\n-\n-    #[inline]\n-    pub fn doc_as_i8(d: Doc) -> i8 {\n-        doc_as_u8(d) as i8\n-    }\n-    #[inline]\n-    pub fn doc_as_i16(d: Doc) -> i16 {\n-        doc_as_u16(d) as i16\n-    }\n-    #[inline]\n-    pub fn doc_as_i32(d: Doc) -> i32 {\n-        doc_as_u32(d) as i32\n-    }\n-    #[inline]\n-    pub fn doc_as_i64(d: Doc) -> i64 {\n-        doc_as_u64(d) as i64\n-    }\n-\n-    pub struct Decoder<'a> {\n-        parent: Doc<'a>,\n-        pos: usize,\n-    }\n-\n-    impl<'doc> Decoder<'doc> {\n-        pub fn new(d: Doc<'doc>) -> Decoder<'doc> {\n-            Decoder {\n-                parent: d,\n-                pos: d.start,\n-            }\n-        }\n-\n-        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n-            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n-            }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n-                   self.parent.start,\n-                   self.parent.end,\n-                   self.pos,\n-                   r_tag,\n-                   r_doc.start,\n-                   r_doc.end);\n-            if r_tag != (exp_tag as usize) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                                            exp_tag,\n-                                            r_tag)));\n-            }\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            Ok(r_doc)\n-        }\n-\n-        fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            let d = self.next_doc(exp_tag)?;\n-            let old_parent = self.parent;\n-            let old_pos = self.pos;\n-            self.parent = d;\n-            self.pos = d.start;\n-            let r = f(self)?;\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(r)\n-        }\n-\n-        fn _next_sub(&mut self) -> DecodeResult<usize> {\n-            // empty vector/map optimization\n-            if self.parent.is_empty() {\n-                return Ok(0);\n-            }\n-\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            let r = if r_tag == (EsSub8 as usize) {\n-                doc_as_u8(r_doc) as usize\n-            } else if r_tag == (EsSub32 as usize) {\n-                doc_as_u32(r_doc) as usize\n-            } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but found \\\n-                                             tag {:?}\",\n-                                            EsSub8,\n-                                            EsSub32,\n-                                            r_tag)));\n-            };\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            debug!(\"_next_sub result={:?}\", r);\n-            Ok(r)\n-        }\n-\n-        // variable-length unsigned integer with different tags.\n-        // `first_tag` should be a tag for u8 or i8.\n-        // `last_tag` should be the largest allowed integer tag with the matching signedness.\n-        // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n-        fn _next_int(&mut self,\n-                     first_tag: EbmlEncoderTag,\n-                     last_tag: EbmlEncoderTag)\n-                     -> DecodeResult<u64> {\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n-            }\n-\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n-                match r_tag - first_tag as usize {\n-                    0 => doc_as_u8(r_doc) as u64,\n-                    1 => doc_as_u16(r_doc) as u64,\n-                    2 => doc_as_u32(r_doc) as u64,\n-                    3 => doc_as_u64(r_doc),\n-                    _ => unreachable!(),\n-                }\n-            } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n-                                             found tag {:?}\",\n-                                            first_tag,\n-                                            last_tag,\n-                                            r_tag)));\n-            };\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n-            Ok(r)\n-        }\n-\n-        pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n-            where F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>\n-        {\n-            let doc = self.next_doc(EsOpaque)?;\n-\n-            let result = {\n-                let mut opaque_decoder = opaque::Decoder::new(doc.data, doc.start);\n-                op(&mut opaque_decoder, doc)?\n-            };\n-\n-            Ok(result)\n-        }\n-\n-        pub fn position(&self) -> usize {\n-            self.pos\n-        }\n-\n-        pub fn advance(&mut self, bytes: usize) {\n-            self.pos += bytes;\n-        }\n-    }\n-\n-    impl<'doc> serialize::Decoder for Decoder<'doc> {\n-        type Error = Error;\n-        fn read_nil(&mut self) -> DecodeResult<()> {\n-            Ok(())\n-        }\n-\n-        fn read_u64(&mut self) -> DecodeResult<u64> {\n-            self._next_int(EsU8, EsU64)\n-        }\n-        fn read_u32(&mut self) -> DecodeResult<u32> {\n-            Ok(self._next_int(EsU8, EsU32)? as u32)\n-        }\n-        fn read_u16(&mut self) -> DecodeResult<u16> {\n-            Ok(self._next_int(EsU8, EsU16)? as u16)\n-        }\n-        fn read_u8(&mut self) -> DecodeResult<u8> {\n-            Ok(doc_as_u8(self.next_doc(EsU8)?))\n-        }\n-        fn read_usize(&mut self) -> DecodeResult<usize> {\n-            let v = self._next_int(EsU8, EsU64)?;\n-            if v > (::std::usize::MAX as u64) {\n-                Err(IntTooBig(v as usize))\n-            } else {\n-                Ok(v as usize)\n-            }\n-        }\n-\n-        fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(self._next_int(EsI8, EsI64)? as i64)\n-        }\n-        fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(self._next_int(EsI8, EsI32)? as i32)\n-        }\n-        fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(self._next_int(EsI8, EsI16)? as i16)\n-        }\n-        fn read_i8(&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n-        }\n-        fn read_isize(&mut self) -> DecodeResult<isize> {\n-            let v = self._next_int(EsI8, EsI64)? as i64;\n-            if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n-                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                Err(IntTooBig(v as usize))\n-            } else {\n-                Ok(v as isize)\n-            }\n-        }\n-\n-        fn read_bool(&mut self) -> DecodeResult<bool> {\n-            Ok(doc_as_u8(self.next_doc(EsBool)?) != 0)\n-        }\n-\n-        fn read_f64(&mut self) -> DecodeResult<f64> {\n-            let bits = doc_as_u64(self.next_doc(EsF64)?);\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_f32(&mut self) -> DecodeResult<f32> {\n-            let bits = doc_as_u32(self.next_doc(EsF32)?);\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_char(&mut self) -> DecodeResult<char> {\n-            Ok(char::from_u32(doc_as_u32(self.next_doc(EsChar)?)).unwrap())\n-        }\n-        fn read_str(&mut self) -> DecodeResult<String> {\n-            Ok(self.next_doc(EsStr)?.to_string())\n-        }\n-\n-        // Compound types:\n-        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum({})\", name);\n-\n-            let doc = self.next_doc(EsEnum)?;\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self)?;\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_variant()\");\n-            let idx = self._next_sub()?;\n-            debug!(\"  idx={}\", idx);\n-\n-            f(self, idx)\n-        }\n-\n-        fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_variant_arg(idx={})\", idx);\n-            f(self)\n-        }\n-\n-        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_struct_variant()\");\n-            let idx = self._next_sub()?;\n-            debug!(\"  idx={}\", idx);\n-\n-            f(self, idx)\n-        }\n-\n-        fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                                name: &str,\n-                                                idx: usize,\n-                                                f: F)\n-                                                -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_struct(name={})\", name);\n-            f(self)\n-        }\n-\n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple()\");\n-            self.read_seq(move |d, len| {\n-                if len == tuple_len {\n-                    f(d)\n-                } else {\n-                    Err(Expected(format!(\"Expected tuple of length `{}`, found tuple of length \\\n-                                          `{}`\",\n-                                         tuple_len,\n-                                         len)))\n-                }\n-            })\n-        }\n-\n-        fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_arg(idx={})\", idx);\n-            self.read_seq_elt(idx, f)\n-        }\n-\n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_struct(name={})\", name);\n-            self.read_tuple(len, f)\n-        }\n-\n-        fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n-            self.read_tuple_arg(idx, f)\n-        }\n-\n-        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>\n-        {\n-            debug!(\"read_option()\");\n-            self.read_enum(\"Option\", move |this| {\n-                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                    match idx {\n-                        0 => f(this, false),\n-                        1 => f(this, true),\n-                        _ => Err(Expected(format!(\"Expected None or Some\"))),\n-                    }\n-                })\n-            })\n-        }\n-\n-        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_seq()\");\n-            self.push_doc(EsVec, move |d| {\n-                let len = d._next_sub()?;\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_seq_elt(idx={})\", idx);\n-            self.push_doc(EsVecElt, f)\n-        }\n-\n-        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map()\");\n-            self.push_doc(EsMap, move |d| {\n-                let len = d._next_sub()?;\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map_elt_key(idx={})\", idx);\n-            self.push_doc(EsMapKey, f)\n-        }\n-\n-        fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map_elt_val(idx={})\", idx);\n-            self.push_doc(EsMapVal, f)\n-        }\n-\n-        fn error(&mut self, err: &str) -> Error {\n-            ApplicationError(err.to_string())\n-        }\n-    }\n-}\n-\n-pub mod writer {\n-    use std::mem;\n-    use std::io::prelude::*;\n-    use std::io::{self, SeekFrom, Cursor};\n-\n-    use super::opaque;\n-    use super::{EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey, EsU64, EsU32, EsU16,\n-                EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-                EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS};\n-\n-    use serialize;\n-\n-\n-    pub type EncodeResult = io::Result<()>;\n-\n-    // rbml writing\n-    pub struct Encoder<'a> {\n-        pub writer: &'a mut Cursor<Vec<u8>>,\n-        size_positions: Vec<u64>,\n-        relax_limit: u64, // do not move encoded bytes before this position\n-    }\n-\n-    fn write_tag<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0xf0 {\n-            w.write_all(&[n as u8])\n-        } else if 0x100 <= n && n < NUM_TAGS {\n-            w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::Other, &format!(\"invalid tag: {}\", n)[..]))\n-        }\n-    }\n-\n-    fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n-        match size {\n-            1 => w.write_all(&[0x80 | (n as u8)]),\n-            2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n-            3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8, n as u8]),\n-            4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8, (n >> 8) as u8, n as u8]),\n-            _ => Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..])),\n-        }\n-    }\n-\n-    pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0x7f {\n-            return write_sized_vuint(w, n, 1);\n-        }\n-        if n < 0x4000 {\n-            return write_sized_vuint(w, n, 2);\n-        }\n-        if n < 0x200000 {\n-            return write_sized_vuint(w, n, 3);\n-        }\n-        if n < 0x10000000 {\n-            return write_sized_vuint(w, n, 4);\n-        }\n-        Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n-    }\n-\n-    impl<'a> Encoder<'a> {\n-        pub fn new(w: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n-            Encoder {\n-                writer: w,\n-                size_positions: vec![],\n-                relax_limit: 0,\n-            }\n-        }\n-\n-        pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n-            debug!(\"Start tag {:?}\", tag_id);\n-            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-\n-            // Write the enum ID:\n-            write_tag(self.writer, tag_id)?;\n-\n-            // Write a placeholder four-byte size.\n-            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-            self.size_positions.push(cur_pos);\n-            let zeroes: &[u8] = &[0, 0, 0, 0];\n-            self.writer.write_all(zeroes)\n-        }\n-\n-        pub fn end_tag(&mut self) -> EncodeResult {\n-            let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-            self.writer.seek(SeekFrom::Start(last_size_pos))?;\n-            let size = (cur_pos - last_size_pos - 4) as usize;\n-\n-            // relax the size encoding for small tags (bigger tags are costly to move).\n-            // we should never try to move the stable positions, however.\n-            const RELAX_MAX_SIZE: usize = 0x100;\n-            if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n-                // we can't alter the buffer in place, so have a temporary buffer\n-                let mut buf = [0u8; RELAX_MAX_SIZE];\n-                {\n-                    let last_size_pos = last_size_pos as usize;\n-                    let data = &self.writer.get_ref()[last_size_pos + 4..cur_pos as usize];\n-                    buf[..size].copy_from_slice(data);\n-                }\n-\n-                // overwrite the size and data and continue\n-                write_vuint(self.writer, size)?;\n-                self.writer.write_all(&buf[..size])?;\n-            } else {\n-                // overwrite the size with an overlong encoding and skip past the data\n-                write_sized_vuint(self.writer, size, 4)?;\n-                self.writer.seek(SeekFrom::Start(cur_pos))?;\n-            }\n-\n-            debug!(\"End tag (size = {:?})\", size);\n-            Ok(())\n-        }\n-\n-        pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult\n-            where F: FnOnce() -> EncodeResult\n-        {\n-            self.start_tag(tag_id)?;\n-            blk()?;\n-            self.end_tag()\n-        }\n-\n-        pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-            write_tag(self.writer, tag_id)?;\n-            write_vuint(self.writer, b.len())?;\n-            self.writer.write_all(b)\n-        }\n-\n-        pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            // tagged integers are emitted in big-endian, with no\n-            // leading zeros.\n-            let leading_zero_bytes = v.leading_zeros() / 8;\n-            self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, &[v])\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-            self.wr_tagged_u32(tag_id, v as u32)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-            self.wr_tagged_u16(tag_id, v as u16)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, &[v as u8])\n-        }\n-\n-        pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, v.as_bytes())\n-        }\n-\n-        // for auto-serialization\n-        fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            write_tag(self.writer, tag_id)?;\n-            self.writer.write_all(b)\n-        }\n-\n-        fn wr_tagged_raw_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_bytes(tag_id, &[v])\n-        }\n-\n-        fn wr_tagged_raw_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-            self.wr_tagged_raw_u64(tag_id, v as u64)\n-        }\n-\n-        fn wr_tagged_raw_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-            self.wr_tagged_raw_u32(tag_id, v as u32)\n-        }\n-\n-        fn wr_tagged_raw_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-            self.wr_tagged_raw_u16(tag_id, v as u16)\n-        }\n-\n-        fn wr_tagged_raw_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n-        }\n-\n-        pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n-            debug!(\"Write {:?} bytes\", b.len());\n-            self.writer.write_all(b)\n-        }\n-\n-        pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n-            debug!(\"Write str: {:?}\", s);\n-            self.writer.write_all(s.as_bytes())\n-        }\n-\n-        /// Returns the current position while marking it stable, i.e.\n-        /// generated bytes so far wouldn't be affected by relaxation.\n-        pub fn mark_stable_position(&mut self) -> u64 {\n-            let pos = self.writer.seek(SeekFrom::Current(0)).unwrap();\n-            if self.relax_limit < pos {\n-                self.relax_limit = pos;\n-            }\n-            pos\n-        }\n-    }\n-\n-    impl<'a> Encoder<'a> {\n-        // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n-            if v as u8 as usize == v {\n-                self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n-            } else if v as u32 as usize == v {\n-                self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n-            } else {\n-                Err(io::Error::new(io::ErrorKind::Other,\n-                                   &format!(\"length or variant id too big: {}\", v)[..]))\n-            }\n-        }\n-\n-        pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n-        {\n-            self.start_tag(EsOpaque as usize)?;\n-\n-            {\n-                let mut opaque_encoder = opaque::Encoder::new(self.writer);\n-                f(&mut opaque_encoder)?;\n-            }\n-\n-            self.mark_stable_position();\n-            self.end_tag()\n-        }\n-    }\n-\n-    impl<'a> serialize::Encoder for Encoder<'a> {\n-        type Error = io::Error;\n-\n-        fn emit_nil(&mut self) -> EncodeResult {\n-            Ok(())\n-        }\n-\n-        fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-            self.emit_u64(v as u64)\n-        }\n-        fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            if v as u32 as u64 == v {\n-                self.emit_u32(v as u32)\n-            } else {\n-                self.wr_tagged_raw_u64(EsU64 as usize, v)\n-            }\n-        }\n-        fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            if v as u16 as u32 == v {\n-                self.emit_u16(v as u16)\n-            } else {\n-                self.wr_tagged_raw_u32(EsU32 as usize, v)\n-            }\n-        }\n-        fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            if v as u8 as u16 == v {\n-                self.emit_u8(v as u8)\n-            } else {\n-                self.wr_tagged_raw_u16(EsU16 as usize, v)\n-            }\n-        }\n-        fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsU8 as usize, v)\n-        }\n-\n-        fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-            self.emit_i64(v as i64)\n-        }\n-        fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            if v as i32 as i64 == v {\n-                self.emit_i32(v as i32)\n-            } else {\n-                self.wr_tagged_raw_i64(EsI64 as usize, v)\n-            }\n-        }\n-        fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            if v as i16 as i32 == v {\n-                self.emit_i16(v as i16)\n-            } else {\n-                self.wr_tagged_raw_i32(EsI32 as usize, v)\n-            }\n-        }\n-        fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            if v as i8 as i16 == v {\n-                self.emit_i8(v as i8)\n-            } else {\n-                self.wr_tagged_raw_i16(EsI16 as usize, v)\n-            }\n-        }\n-        fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_i8(EsI8 as usize, v)\n-        }\n-\n-        fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsBool as usize, v as u8)\n-        }\n-\n-        fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u64(EsF64 as usize, bits)\n-        }\n-        fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u32(EsF32 as usize, bits)\n-        }\n-        fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_raw_u32(EsChar as usize, v as u32)\n-        }\n-\n-        fn emit_str(&mut self, v: &str) -> EncodeResult {\n-            self.wr_tagged_str(EsStr as usize, v)\n-        }\n-\n-        fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.start_tag(EsEnum as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self._emit_tagged_sub(v_id)?;\n-            f(self)\n-        }\n-\n-        fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_enum_struct_variant<F>(&mut self,\n-                                       v_name: &str,\n-                                       v_id: usize,\n-                                       cnt: usize,\n-                                       f: F)\n-                                       -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum_variant(v_name, v_id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum(\"Option\", f)\n-        }\n-        fn emit_option_none(&mut self) -> EncodeResult {\n-            self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-        }\n-        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.emit_enum_variant(\"Some\", 1, 1, f)\n-        }\n-\n-        fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            if len == 0 {\n-                // empty vector optimization\n-                return self.wr_tagged_bytes(EsVec as usize, &[]);\n-            }\n-\n-            self.start_tag(EsVec as usize)?;\n-            self._emit_tagged_sub(len)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.start_tag(EsVecElt as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            if len == 0 {\n-                // empty map optimization\n-                return self.wr_tagged_bytes(EsMap as usize, &[]);\n-            }\n-\n-            self.start_tag(EsMap as usize)?;\n-            self._emit_tagged_sub(len)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.start_tag(EsMapKey as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.start_tag(EsMapVal as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Testing\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{Doc, reader, writer};\n-\n-    use serialize::{Encodable, Decodable};\n-\n-    use std::io::Cursor;\n-\n-    #[test]\n-    fn test_vuint_at() {\n-        let data = &[\n-            0x80,\n-            0xff,\n-            0x40, 0x00,\n-            0x7f, 0xff,\n-            0x20, 0x00, 0x00,\n-            0x3f, 0xff, 0xff,\n-            0x10, 0x00, 0x00, 0x00,\n-            0x1f, 0xff, 0xff, 0xff\n-        ];\n-\n-        let mut res: reader::Res;\n-\n-        // Class A\n-        res = reader::vuint_at(data, 0).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 1);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 7) - 1);\n-        assert_eq!(res.next, 2);\n-\n-        // Class B\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 4);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 14) - 1);\n-        assert_eq!(res.next, 6);\n-\n-        // Class C\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 9);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 21) - 1);\n-        assert_eq!(res.next, 12);\n-\n-        // Class D\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 16);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 28) - 1);\n-        assert_eq!(res.next, 20);\n-    }\n-\n-    #[test]\n-    fn test_option_int() {\n-        fn test_v(v: Option<isize>) {\n-            debug!(\"v == {:?}\", v);\n-            let mut wr = Cursor::new(Vec::new());\n-            {\n-                let mut rbml_w = writer::Encoder::new(&mut wr);\n-                let _ = v.encode(&mut rbml_w);\n-            }\n-            let rbml_doc = Doc::new(wr.get_ref());\n-            let mut deser = reader::Decoder::new(rbml_doc);\n-            let v1 = Decodable::decode(&mut deser).unwrap();\n-            debug!(\"v1 == {:?}\", v1);\n-            assert_eq!(v, v1);\n-        }\n-\n-        test_v(Some(22));\n-        test_v(None);\n-        test_v(Some(3));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    #![allow(non_snake_case)]\n-    use test::Bencher;\n-    use super::reader;\n-\n-    #[bench]\n-    pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        let data = (0..4 * 100)\n-                       .map(|i| {\n-                           match i % 2 {\n-                               0 => 0x80,\n-                               _ => i as u8,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        let data = (0..4 * 100 + 1)\n-                       .map(|i| {\n-                           match i % 2 {\n-                               1 => 0x80,\n-                               _ => i as u8,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        let data = (0..4 * 100)\n-                       .map(|i| {\n-                           match i % 4 {\n-                               0 => 0x10,\n-                               3 => i as u8,\n-                               _ => 0,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        let data = (0..4 * 100 + 1)\n-                       .map(|i| {\n-                           match i % 4 {\n-                               1 => 0x10,\n-                               0 => i as u8,\n-                               _ => 0,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-}"}, {"sha": "578ef68b00386f3be294d68748acafc59128460f", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -14,7 +14,6 @@ flate = { path = \"../libflate\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n log = { path = \"../liblog\" }\n-rbml = { path = \"../librbml\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "269f0ebb813ca091f6028b60395552790492ab8c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -103,18 +103,13 @@ pub enum DepNode<D: Clone + Debug> {\n     // table in the tcx (or elsewhere) maps to one of these\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n-    // predicates for an item wind up in `ItemSignature`). Other\n-    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n-    // might be mergable are kept distinct because the sets of def-ids\n-    // to which they apply are disjoint, and hence we might as well\n-    // have distinct labels for easier debugging.\n+    // predicates for an item wind up in `ItemSignature`).\n     ImplOrTraitItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n     SizedConstraint(D),\n-    TraitItemDefIds(D),\n+    ImplOrTraitItemDefIds(D),\n     InherentImpls(D),\n-    ImplItems(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -162,9 +157,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             ImplOrTraitItems,\n             ItemSignature,\n             FieldTy,\n-            TraitItemDefIds,\n+            ImplOrTraitItemDefIds,\n             InherentImpls,\n-            ImplItems,\n             TraitImpls,\n             ReprHints,\n         }\n@@ -231,9 +225,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            TraitItemDefIds(ref d) => op(d).map(TraitItemDefIds),\n+            ImplOrTraitItemDefIds(ref d) => op(d).map(ImplOrTraitItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n-            ImplItems(ref d) => op(d).map(ImplItems),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "dec8ea8a29c3918afc091d940d70a57b8106a88e", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -16,23 +16,20 @@ use hir;\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n     Fn(DefId),\n-    SelfTy(Option<DefId> /* trait */, Option<ast::NodeId> /* impl */),\n+    SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     Mod(DefId),\n-    ForeignMod(DefId),\n     Static(DefId, bool /* is_mutbl */),\n     Const(DefId),\n     AssociatedConst(DefId),\n-    Local(DefId, // def id of variable\n-             ast::NodeId), // node id of variable\n-    Variant(DefId /* enum */, DefId /* variant */),\n+    Local(DefId),\n+    Variant(DefId),\n     Enum(DefId),\n     TyAlias(DefId),\n-    AssociatedTy(DefId /* trait */, DefId),\n+    AssociatedTy(DefId),\n     Trait(DefId),\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n     Upvar(DefId,        // def id of closed over local\n-             ast::NodeId,  // node id of closed over local\n              usize,        // index in the freevars list of the closure\n              ast::NodeId), // expr node that creates the closure\n \n@@ -94,37 +91,20 @@ pub type DefMap = NodeMap<PathResolution>;\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Export {\n     pub name: ast::Name,    // The name of the target.\n     pub def_id: DefId, // The definition of the target.\n }\n \n impl Def {\n-    pub fn var_id(&self) -> ast::NodeId {\n-        match *self {\n-            Def::Local(_, id) |\n-            Def::Upvar(_, id, ..) => {\n-                id\n-            }\n-\n-            Def::Fn(..) | Def::Mod(..) | Def::ForeignMod(..) | Def::Static(..) |\n-            Def::Variant(..) | Def::Enum(..) | Def::TyAlias(..) | Def::AssociatedTy(..) |\n-            Def::TyParam(..) | Def::Struct(..) | Def::Union(..) | Def::Trait(..) |\n-            Def::Method(..) | Def::Const(..) | Def::AssociatedConst(..) |\n-            Def::PrimTy(..) | Def::Label(..) | Def::SelfTy(..) | Def::Err => {\n-                bug!(\"attempted .var_id() on invalid {:?}\", self)\n-            }\n-        }\n-    }\n-\n     pub fn def_id(&self) -> DefId {\n         match *self {\n-            Def::Fn(id) | Def::Mod(id) | Def::ForeignMod(id) | Def::Static(id, _) |\n-            Def::Variant(_, id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(_, id) |\n+            Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n+            Def::Variant(id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(id) |\n             Def::TyParam(id) | Def::Struct(id) | Def::Union(id) | Def::Trait(id) |\n             Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n-            Def::Local(id, _) | Def::Upvar(id, ..) => {\n+            Def::Local(id) | Def::Upvar(id, ..) => {\n                 id\n             }\n \n@@ -141,7 +121,6 @@ impl Def {\n         match *self {\n             Def::Fn(..) => \"function\",\n             Def::Mod(..) => \"module\",\n-            Def::ForeignMod(..) => \"foreign module\",\n             Def::Static(..) => \"static\",\n             Def::Variant(..) => \"variant\",\n             Def::Enum(..) => \"enum\","}, {"sha": "399243551d6518b14f7af6807e8d0b3edbf54e94", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,12 +8,69 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::LOCAL_CRATE;\n use ty;\n-use syntax::ast::CrateNum;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+use serialize::{self, Encoder, Decoder};\n+\n use std::fmt;\n use std::u32;\n \n+#[derive(Clone, Copy, Eq, Ord, PartialOrd, PartialEq, Hash, Debug)]\n+pub struct CrateNum(u32);\n+\n+impl Idx for CrateNum {\n+    fn new(value: usize) -> Self {\n+        assert!(value < (u32::MAX) as usize);\n+        CrateNum(value as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// Item definitions in the currently-compiled crate would have the CrateNum\n+/// LOCAL_CRATE in their DefId.\n+pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n+\n+impl CrateNum {\n+    pub fn new(x: usize) -> CrateNum {\n+        assert!(x < (u32::MAX as usize));\n+        CrateNum(x as u32)\n+    }\n+\n+    pub fn from_u32(x: u32) -> CrateNum {\n+        CrateNum(x)\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl fmt::Display for CrateNum {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl serialize::UseSpecializedEncodable for CrateNum {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u32(self.0)\n+    }\n+}\n+\n+impl serialize::UseSpecializedDecodable for CrateNum {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<CrateNum, D::Error> {\n+        d.read_u32().map(CrateNum)\n+    }\n+}\n+\n /// A DefIndex is an index into the hir-map for a crate, identifying a\n /// particular definition. It should really be considered an interned\n /// shorthand for a particular DefPath.\n@@ -46,8 +103,7 @@ pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n-#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n-           RustcDecodable, Hash, Copy)]\n+#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub index: DefIndex,"}, {"sha": "57b5599bd1d7ffd59065f0d20c3077cbc0437f2b", "filename": "src/librustc/hir/fold.rs", "status": "removed", "additions": 0, "deletions": 1131, "changes": 1131, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,1131 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A Folder represents an HIR->HIR fold; it accepts a HIR piece,\n-//! and returns a piece of the same type.\n-\n-use hir::*;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_};\n-use syntax::ast::{NestedMetaItem, NestedMetaItemKind, MetaItem, MetaItemKind};\n-use hir;\n-use syntax_pos::Span;\n-use syntax::codemap::{respan, Spanned};\n-use syntax::ptr::P;\n-use syntax::parse::token::keywords;\n-use syntax::util::move_map::MoveMap;\n-\n-pub trait Folder : Sized {\n-    // Any additions to this trait should happen in form\n-    // of a call to a public `noop_*` function that only calls\n-    // out to the folder again, not other `noop_*` functions.\n-    //\n-    // This is a necessary API workaround to the problem of not\n-    // being able to call out to the super default method\n-    // in an overridden default method.\n-\n-    fn fold_crate(&mut self, c: Crate) -> Crate {\n-        noop_fold_crate(c, self)\n-    }\n-\n-    fn fold_meta_items(&mut self, meta_items: HirVec<P<MetaItem>>) -> HirVec<P<MetaItem>> {\n-        noop_fold_meta_items(meta_items, self)\n-    }\n-\n-    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n-        noop_fold_meta_list_item(list_item, self)\n-    }\n-\n-    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n-        noop_fold_meta_item(meta_item, self)\n-    }\n-\n-    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> {\n-        noop_fold_view_path(view_path, self)\n-    }\n-\n-    fn fold_foreign_item(&mut self, ni: ForeignItem) -> ForeignItem {\n-        noop_fold_foreign_item(ni, self)\n-    }\n-\n-    fn fold_item(&mut self, i: Item) -> Item {\n-        noop_fold_item(i, self)\n-    }\n-\n-    fn fold_item_id(&mut self, i: ItemId) -> ItemId {\n-        noop_fold_item_id(i, self)\n-    }\n-\n-    fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n-        noop_fold_struct_field(sf, self)\n-    }\n-\n-    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n-        noop_fold_item_underscore(i, self)\n-    }\n-\n-    fn fold_trait_item(&mut self, i: TraitItem) -> TraitItem {\n-        noop_fold_trait_item(i, self)\n-    }\n-\n-    fn fold_impl_item(&mut self, i: ImplItem) -> ImplItem {\n-        noop_fold_impl_item(i, self)\n-    }\n-\n-    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n-        noop_fold_fn_decl(d, self)\n-    }\n-\n-    fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n-        noop_fold_block(b, self)\n-    }\n-\n-    fn fold_stmt(&mut self, s: Stmt) -> Stmt {\n-        noop_fold_stmt(s, self)\n-    }\n-\n-    fn fold_arm(&mut self, a: Arm) -> Arm {\n-        noop_fold_arm(a, self)\n-    }\n-\n-    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n-        noop_fold_pat(p, self)\n-    }\n-\n-    fn fold_decl(&mut self, d: P<Decl>) -> P<Decl> {\n-        noop_fold_decl(d, self)\n-    }\n-\n-    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n-        e.map(|e| noop_fold_expr(e, self))\n-    }\n-\n-    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n-        noop_fold_ty(t, self)\n-    }\n-\n-    fn fold_ty_binding(&mut self, t: TypeBinding) -> TypeBinding {\n-        noop_fold_ty_binding(t, self)\n-    }\n-\n-    fn fold_mod(&mut self, m: Mod) -> Mod {\n-        noop_fold_mod(m, self)\n-    }\n-\n-    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod {\n-        noop_fold_foreign_mod(nm, self)\n-    }\n-\n-    fn fold_variant(&mut self, v: Variant) -> Variant {\n-        noop_fold_variant(v, self)\n-    }\n-\n-    fn fold_name(&mut self, n: Name) -> Name {\n-        noop_fold_name(n, self)\n-    }\n-\n-    fn fold_usize(&mut self, i: usize) -> usize {\n-        noop_fold_usize(i, self)\n-    }\n-\n-    fn fold_path(&mut self, p: Path) -> Path {\n-        noop_fold_path(p, self)\n-    }\n-\n-    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n-        noop_fold_path_parameters(p, self)\n-    }\n-\n-    fn fold_angle_bracketed_parameter_data(&mut self,\n-                                           p: AngleBracketedParameterData)\n-                                           -> AngleBracketedParameterData {\n-        noop_fold_angle_bracketed_parameter_data(p, self)\n-    }\n-\n-    fn fold_parenthesized_parameter_data(&mut self,\n-                                         p: ParenthesizedParameterData)\n-                                         -> ParenthesizedParameterData {\n-        noop_fold_parenthesized_parameter_data(p, self)\n-    }\n-\n-    fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n-        noop_fold_local(l, self)\n-    }\n-\n-    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n-        noop_fold_lifetime(l, self)\n-    }\n-\n-    fn fold_lifetime_def(&mut self, l: LifetimeDef) -> LifetimeDef {\n-        noop_fold_lifetime_def(l, self)\n-    }\n-\n-    fn fold_attribute(&mut self, at: Attribute) -> Option<Attribute> {\n-        noop_fold_attribute(at, self)\n-    }\n-\n-    fn fold_arg(&mut self, a: Arg) -> Arg {\n-        noop_fold_arg(a, self)\n-    }\n-\n-    fn fold_generics(&mut self, generics: Generics) -> Generics {\n-        noop_fold_generics(generics, self)\n-    }\n-\n-    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef {\n-        noop_fold_trait_ref(p, self)\n-    }\n-\n-    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef {\n-        noop_fold_poly_trait_ref(p, self)\n-    }\n-\n-    fn fold_variant_data(&mut self, vdata: VariantData) -> VariantData {\n-        noop_fold_variant_data(vdata, self)\n-    }\n-\n-    fn fold_lifetimes(&mut self, lts: HirVec<Lifetime>) -> HirVec<Lifetime> {\n-        noop_fold_lifetimes(lts, self)\n-    }\n-\n-    fn fold_lifetime_defs(&mut self, lts: HirVec<LifetimeDef>) -> HirVec<LifetimeDef> {\n-        noop_fold_lifetime_defs(lts, self)\n-    }\n-\n-    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n-        noop_fold_ty_param(tp, self)\n-    }\n-\n-    fn fold_ty_params(&mut self, tps: HirVec<TyParam>) -> HirVec<TyParam> {\n-        noop_fold_ty_params(tps, self)\n-    }\n-\n-    fn fold_opt_lifetime(&mut self, o_lt: Option<Lifetime>) -> Option<Lifetime> {\n-        noop_fold_opt_lifetime(o_lt, self)\n-    }\n-\n-    fn fold_opt_bounds(&mut self,\n-                       b: Option<TyParamBounds>)\n-                       -> Option<TyParamBounds> {\n-        noop_fold_opt_bounds(b, self)\n-    }\n-\n-    fn fold_bounds(&mut self, b: TyParamBounds) -> TyParamBounds {\n-        noop_fold_bounds(b, self)\n-    }\n-\n-    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound {\n-        noop_fold_ty_param_bound(tpb, self)\n-    }\n-\n-    fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n-        noop_fold_mt(mt, self)\n-    }\n-\n-    fn fold_field(&mut self, field: Field) -> Field {\n-        noop_fold_field(field, self)\n-    }\n-\n-    fn fold_where_clause(&mut self, where_clause: WhereClause) -> WhereClause {\n-        noop_fold_where_clause(where_clause, self)\n-    }\n-\n-    fn fold_where_predicate(&mut self, where_predicate: WherePredicate) -> WherePredicate {\n-        noop_fold_where_predicate(where_predicate, self)\n-    }\n-\n-    /// called for the `id` on each declaration\n-    fn new_id(&mut self, i: NodeId) -> NodeId {\n-        i\n-    }\n-\n-    /// called for ids that are references (e.g., ItemDef)\n-    fn map_id(&mut self, i: NodeId) -> NodeId {\n-        i\n-    }\n-\n-    fn new_span(&mut self, sp: Span) -> Span {\n-        sp\n-    }\n-}\n-\n-pub fn noop_fold_meta_items<T: Folder>(meta_items: HirVec<P<MetaItem>>,\n-                                       fld: &mut T)\n-                                       -> HirVec<P<MetaItem>> {\n-    meta_items.move_map(|x| fld.fold_meta_item(x))\n-}\n-\n-pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n-    view_path.map(|Spanned { node, span }| {\n-        Spanned {\n-            node: match node {\n-                ViewPathSimple(name, path) => {\n-                    ViewPathSimple(name, fld.fold_path(path))\n-                }\n-                ViewPathGlob(path) => {\n-                    ViewPathGlob(fld.fold_path(path))\n-                }\n-                ViewPathList(path, path_list_idents) => {\n-                    ViewPathList(fld.fold_path(path),\n-                                 path_list_idents.move_map(|path_list_ident| {\n-                                     Spanned {\n-                                         node: PathListItem_ {\n-                                             id: fld.new_id(path_list_ident.node.id),\n-                                             name: path_list_ident.node.name,\n-                                             rename: path_list_ident.node.rename,\n-                                         },\n-                                         span: fld.new_span(path_list_ident.span),\n-                                     }\n-                                 }))\n-                }\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn fold_attrs<T, F>(attrs: T, fld: &mut F) -> T\n-    where T: Into<Vec<Attribute>> + From<Vec<Attribute>>,\n-          F: Folder,\n-{\n-    attrs.into().move_flat_map(|x| fld.fold_attribute(x)).into()\n-}\n-\n-pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n-    Arm {\n-        attrs: fold_attrs(attrs, fld),\n-        pats: pats.move_map(|x| fld.fold_pat(x)),\n-        guard: guard.map(|x| fld.fold_expr(x)),\n-        body: fld.fold_expr(body),\n-    }\n-}\n-\n-pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> P<Decl> {\n-    d.map(|Spanned { node, span }| {\n-        match node {\n-            DeclLocal(l) => Spanned {\n-                node: DeclLocal(fld.fold_local(l)),\n-                span: fld.new_span(span),\n-            },\n-            DeclItem(it) => Spanned {\n-                node: DeclItem(fld.fold_item_id(it)),\n-                span: fld.new_span(span),\n-            },\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n-    TypeBinding {\n-        id: fld.new_id(b.id),\n-        name: b.name,\n-        ty: fld.fold_ty(b.ty),\n-        span: fld.new_span(b.span),\n-    }\n-}\n-\n-pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n-    t.map(|Ty { id, node, span }| {\n-        Ty {\n-            id: fld.new_id(id),\n-            node: match node {\n-                TyInfer => node,\n-                TyVec(ty) => TyVec(fld.fold_ty(ty)),\n-                TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n-                TyRptr(region, mt) => {\n-                    TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n-                }\n-                TyBareFn(f) => {\n-                    TyBareFn(f.map(|BareFnTy { lifetimes, unsafety, abi, decl }| {\n-                        BareFnTy {\n-                            lifetimes: fld.fold_lifetime_defs(lifetimes),\n-                            unsafety: unsafety,\n-                            abi: abi,\n-                            decl: fld.fold_fn_decl(decl),\n-                        }\n-                    }))\n-                }\n-                TyNever => node,\n-                TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n-                TyPath(qself, path) => {\n-                    let qself = qself.map(|QSelf { ty, position }| {\n-                        QSelf {\n-                            ty: fld.fold_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    TyPath(qself, fld.fold_path(path))\n-                }\n-                TyObjectSum(ty, bounds) => {\n-                    TyObjectSum(fld.fold_ty(ty), fld.fold_bounds(bounds))\n-                }\n-                TyFixedLengthVec(ty, e) => {\n-                    TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n-                }\n-                TyTypeof(expr) => {\n-                    TyTypeof(fld.fold_expr(expr))\n-                }\n-                TyPolyTraitRef(bounds) => {\n-                    TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-                }\n-                TyImplTrait(bounds) => {\n-                    TyImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-                }\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod { abi, items }: ForeignMod,\n-                                        fld: &mut T)\n-                                        -> ForeignMod {\n-    ForeignMod {\n-        abi: abi,\n-        items: items.move_map(|x| fld.fold_foreign_item(x)),\n-    }\n-}\n-\n-pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n-    Spanned {\n-        node: Variant_ {\n-            name: v.node.name,\n-            attrs: fold_attrs(v.node.attrs, fld),\n-            data: fld.fold_variant_data(v.node.data),\n-            disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),\n-        },\n-        span: fld.new_span(v.span),\n-    }\n-}\n-\n-pub fn noop_fold_name<T: Folder>(n: Name, _: &mut T) -> Name {\n-    n\n-}\n-\n-pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n-    i\n-}\n-\n-pub fn noop_fold_path<T: Folder>(Path { global, segments, span }: Path, fld: &mut T) -> Path {\n-    Path {\n-        global: global,\n-        segments: segments.move_map(|PathSegment { name, parameters }| {\n-            PathSegment {\n-                name: fld.fold_name(name),\n-                parameters: fld.fold_path_parameters(parameters),\n-            }\n-        }),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters,\n-                                            fld: &mut T)\n-                                            -> PathParameters {\n-    match path_parameters {\n-        AngleBracketedParameters(data) =>\n-            AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n-        ParenthesizedParameters(data) =>\n-            ParenthesizedParameters(fld.fold_parenthesized_parameter_data(data)),\n-    }\n-}\n-\n-pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n-                                                           fld: &mut T)\n-                                                           -> AngleBracketedParameterData {\n-    let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n-    AngleBracketedParameterData {\n-        lifetimes: fld.fold_lifetimes(lifetimes),\n-        types: types.move_map(|ty| fld.fold_ty(ty)),\n-        bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n-    }\n-}\n-\n-pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n-                                                         fld: &mut T)\n-                                                         -> ParenthesizedParameterData {\n-    let ParenthesizedParameterData { inputs, output, span } = data;\n-    ParenthesizedParameterData {\n-        inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-        output: output.map(|ty| fld.fold_ty(ty)),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local { id, pat, ty, init, span, attrs }| {\n-        Local {\n-            id: fld.new_id(id),\n-            ty: ty.map(|t| fld.fold_ty(t)),\n-            pat: fld.fold_pat(pat),\n-            init: init.map(|e| fld.fold_expr(e)),\n-            span: fld.new_span(span),\n-            attrs: fold_attrs(attrs, fld),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n-    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n-    Some(Spanned {\n-        node: Attribute_ {\n-            id: id,\n-            style: style,\n-            value: fld.fold_meta_item(value),\n-            is_sugared_doc: is_sugared_doc,\n-        },\n-        span: fld.new_span(span),\n-    })\n-}\n-\n-pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n-    -> NestedMetaItem {\n-    Spanned {\n-        node: match li.node {\n-            NestedMetaItemKind::MetaItem(mi) =>  {\n-                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n-            },\n-            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n-        },\n-        span: fld.new_span(li.span)\n-    }\n-}\n-\n-pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n-    mi.map(|Spanned { node, span }| {\n-        Spanned {\n-            node: match node {\n-                MetaItemKind::Word(id) => MetaItemKind::Word(id),\n-                MetaItemKind::List(id, mis) => {\n-                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n-                }\n-                MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s),\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_arg<T: Folder>(Arg { id, pat, ty }: Arg, fld: &mut T) -> Arg {\n-    Arg {\n-        id: fld.new_id(id),\n-        pat: fld.fold_pat(pat),\n-        ty: fld.fold_ty(ty),\n-    }\n-}\n-\n-pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n-    decl.map(|FnDecl { inputs, output, variadic }| {\n-        FnDecl {\n-            inputs: inputs.move_map(|x| fld.fold_arg(x)),\n-            output: match output {\n-                Return(ty) => Return(fld.fold_ty(ty)),\n-                DefaultReturn(span) => DefaultReturn(span),\n-            },\n-            variadic: variadic,\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T) -> TyParamBound\n-    where T: Folder\n-{\n-    match tpb {\n-        TraitTyParamBound(ty, modifier) => TraitTyParamBound(fld.fold_poly_trait_ref(ty), modifier),\n-        RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-    }\n-}\n-\n-pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {id, name, bounds, default, span} = tp;\n-    TyParam {\n-        id: fld.new_id(id),\n-        name: name,\n-        bounds: fld.fold_bounds(bounds),\n-        default: default.map(|x| fld.fold_ty(x)),\n-        span: span,\n-    }\n-}\n-\n-pub fn noop_fold_ty_params<T: Folder>(tps: HirVec<TyParam>,\n-                                      fld: &mut T)\n-                                      -> HirVec<TyParam> {\n-    tps.move_map(|tp| fld.fold_ty_param(tp))\n-}\n-\n-pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n-    Lifetime {\n-        id: fld.new_id(l.id),\n-        name: l.name,\n-        span: fld.new_span(l.span),\n-    }\n-}\n-\n-pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T) -> LifetimeDef {\n-    LifetimeDef {\n-        lifetime: fld.fold_lifetime(l.lifetime),\n-        bounds: fld.fold_lifetimes(l.bounds),\n-    }\n-}\n-\n-pub fn noop_fold_lifetimes<T: Folder>(lts: HirVec<Lifetime>, fld: &mut T) -> HirVec<Lifetime> {\n-    lts.move_map(|l| fld.fold_lifetime(l))\n-}\n-\n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: HirVec<LifetimeDef>,\n-                                          fld: &mut T)\n-                                          -> HirVec<LifetimeDef> {\n-    lts.move_map(|l| fld.fold_lifetime_def(l))\n-}\n-\n-pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T) -> Option<Lifetime> {\n-    o_lt.map(|lt| fld.fold_lifetime(lt))\n-}\n-\n-pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause, span}: Generics,\n-                                     fld: &mut T)\n-                                     -> Generics {\n-    Generics {\n-        ty_params: fld.fold_ty_params(ty_params),\n-        lifetimes: fld.fold_lifetime_defs(lifetimes),\n-        where_clause: fld.fold_where_clause(where_clause),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_where_clause<T: Folder>(WhereClause { id, predicates }: WhereClause,\n-                                         fld: &mut T)\n-                                         -> WhereClause {\n-    WhereClause {\n-        id: fld.new_id(id),\n-        predicates: predicates.move_map(|predicate| fld.fold_where_predicate(predicate)),\n-    }\n-}\n-\n-pub fn noop_fold_where_predicate<T: Folder>(pred: WherePredicate, fld: &mut T) -> WherePredicate {\n-    match pred {\n-        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{bound_lifetimes,\n-                                                                     bounded_ty,\n-                                                                     bounds,\n-                                                                     span}) => {\n-            hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n-                bounded_ty: fld.fold_ty(bounded_ty),\n-                bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n-                span: fld.new_span(span),\n-            })\n-        }\n-        hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{lifetime,\n-                                                                       bounds,\n-                                                                       span}) => {\n-            hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span: fld.new_span(span),\n-                lifetime: fld.fold_lifetime(lifetime),\n-                bounds: bounds.move_map(|bound| fld.fold_lifetime(bound)),\n-            })\n-        }\n-        hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{id,\n-                                                               path,\n-                                                               ty,\n-                                                               span}) => {\n-            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                id: fld.new_id(id),\n-                path: fld.fold_path(path),\n-                ty: fld.fold_ty(ty),\n-                span: fld.new_span(span),\n-            })\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_variant_data<T: Folder>(vdata: VariantData, fld: &mut T) -> VariantData {\n-    match vdata {\n-        VariantData::Struct(fields, id) => {\n-            VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)),\n-                                fld.new_id(id))\n-        }\n-        VariantData::Tuple(fields, id) => {\n-            VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)),\n-                               fld.new_id(id))\n-        }\n-        VariantData::Unit(id) => VariantData::Unit(fld.new_id(id)),\n-    }\n-}\n-\n-pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n-    let id = fld.new_id(p.ref_id);\n-    let TraitRef {\n-        path,\n-        ref_id: _,\n-    } = p;\n-    hir::TraitRef {\n-        path: fld.fold_path(path),\n-        ref_id: id,\n-    }\n-}\n-\n-pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n-    hir::PolyTraitRef {\n-        bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n-        trait_ref: fld.fold_trait_ref(p.trait_ref),\n-        span: fld.new_span(p.span),\n-    }\n-}\n-\n-pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField {\n-    StructField {\n-        span: fld.new_span(f.span),\n-        id: fld.new_id(f.id),\n-        name: f.name,\n-        vis: f.vis,\n-        ty: fld.fold_ty(f.ty),\n-        attrs: fold_attrs(f.attrs, fld),\n-    }\n-}\n-\n-pub fn noop_fold_field<T: Folder>(Field { name, expr, span }: Field, folder: &mut T) -> Field {\n-    Field {\n-        name: respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-        expr: folder.fold_expr(expr),\n-        span: folder.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_mt<T: Folder>(MutTy { ty, mutbl }: MutTy, folder: &mut T) -> MutTy {\n-    MutTy {\n-        ty: folder.fold_ty(ty),\n-        mutbl: mutbl,\n-    }\n-}\n-\n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>,\n-                                       folder: &mut T)\n-                                       -> Option<TyParamBounds> {\n-    b.map(|bounds| folder.fold_bounds(bounds))\n-}\n-\n-fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T) -> TyParamBounds {\n-    bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n-}\n-\n-pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block { id, stmts, expr, rules, span }| {\n-        Block {\n-            id: folder.new_id(id),\n-            stmts: stmts.move_map(|s| folder.fold_stmt(s)),\n-            expr: expr.map(|x| folder.fold_expr(x)),\n-            rules: rules,\n-            span: folder.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n-    match i {\n-        ItemExternCrate(string) => ItemExternCrate(string),\n-        ItemUse(view_path) => {\n-            ItemUse(folder.fold_view_path(view_path))\n-        }\n-        ItemStatic(t, m, e) => {\n-            ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n-        }\n-        ItemConst(t, e) => {\n-            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n-        }\n-        ItemFn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemFn(folder.fold_fn_decl(decl),\n-                   unsafety,\n-                   constness,\n-                   abi,\n-                   folder.fold_generics(generics),\n-                   folder.fold_block(body))\n-        }\n-        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n-        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemTy(t, generics) => {\n-            ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n-        }\n-        ItemEnum(enum_definition, generics) => {\n-            ItemEnum(hir::EnumDef {\n-                         variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n-                     },\n-                     folder.fold_generics(generics))\n-        }\n-        ItemStruct(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemStruct(struct_def, folder.fold_generics(generics))\n-        }\n-        ItemUnion(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemUnion(struct_def, folder.fold_generics(generics))\n-        }\n-        ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n-        }\n-        ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items\n-                .move_map(|item| folder.fold_impl_item(item));\n-            let ifce = match ifce {\n-                None => None,\n-                Some(ref trait_ref) => {\n-                    Some(folder.fold_trait_ref((*trait_ref).clone()))\n-                }\n-            };\n-            ItemImpl(unsafety,\n-                     polarity,\n-                     folder.fold_generics(generics),\n-                     ifce,\n-                     folder.fold_ty(ty),\n-                     new_impl_items)\n-        }\n-        ItemTrait(unsafety, generics, bounds, items) => {\n-            let bounds = folder.fold_bounds(bounds);\n-            let items = items.move_map(|item| folder.fold_trait_item(item));\n-            ItemTrait(unsafety, folder.fold_generics(generics), bounds, items)\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_trait_item<T: Folder>(i: TraitItem,\n-                                       folder: &mut T)\n-                                       -> TraitItem {\n-    TraitItem {\n-        id: folder.new_id(i.id),\n-        name: folder.fold_name(i.name),\n-        attrs: fold_attrs(i.attrs, folder),\n-        node: match i.node {\n-            ConstTraitItem(ty, default) => {\n-                ConstTraitItem(folder.fold_ty(ty), default.map(|x| folder.fold_expr(x)))\n-            }\n-            MethodTraitItem(sig, body) => {\n-                MethodTraitItem(noop_fold_method_sig(sig, folder),\n-                                body.map(|x| folder.fold_block(x)))\n-            }\n-            TypeTraitItem(bounds, default) => {\n-                TypeTraitItem(folder.fold_bounds(bounds),\n-                              default.map(|x| folder.fold_ty(x)))\n-            }\n-        },\n-        span: folder.new_span(i.span),\n-    }\n-}\n-\n-pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T) -> ImplItem {\n-    ImplItem {\n-        id: folder.new_id(i.id),\n-        name: folder.fold_name(i.name),\n-        attrs: fold_attrs(i.attrs, folder),\n-        vis: i.vis,\n-        defaultness: i.defaultness,\n-        node: match i.node {\n-            ImplItemKind::Const(ty, expr) => {\n-                ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n-            }\n-            ImplItemKind::Method(sig, body) => {\n-                ImplItemKind::Method(noop_fold_method_sig(sig, folder), folder.fold_block(body))\n-            }\n-            ImplItemKind::Type(ty) => ImplItemKind::Type(folder.fold_ty(ty)),\n-        },\n-        span: folder.new_span(i.span),\n-    }\n-}\n-\n-pub fn noop_fold_mod<T: Folder>(Mod { inner, item_ids }: Mod, folder: &mut T) -> Mod {\n-    Mod {\n-        inner: folder.new_span(inner),\n-        item_ids: item_ids.move_map(|x| folder.fold_item_id(x)),\n-    }\n-}\n-\n-pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n-                                          exported_macros, items }: Crate,\n-                                  folder: &mut T)\n-                                  -> Crate {\n-    let config = folder.fold_meta_items(config);\n-\n-    let crate_mod = folder.fold_item(hir::Item {\n-        name: keywords::Invalid.name(),\n-        attrs: attrs,\n-        id: DUMMY_NODE_ID,\n-        vis: hir::Public,\n-        span: span,\n-        node: hir::ItemMod(module),\n-    });\n-\n-    let (module, attrs, span) = match crate_mod {\n-        hir::Item { attrs, span, node, .. } => {\n-            match node {\n-                hir::ItemMod(m) => (m, attrs, span),\n-                _ => panic!(\"fold converted a module to not a module\"),\n-            }\n-        }\n-    };\n-\n-    let items = items.into_iter()\n-                     .map(|(id, item)| (id, folder.fold_item(item)))\n-                     .collect();\n-\n-    Crate {\n-        module: module,\n-        attrs: attrs,\n-        config: config,\n-        span: span,\n-        exported_macros: exported_macros,\n-        items: items,\n-    }\n-}\n-\n-pub fn noop_fold_item_id<T: Folder>(i: ItemId, folder: &mut T) -> ItemId {\n-    let id = folder.map_id(i.id);\n-    ItemId { id: id }\n-}\n-\n-// fold one item into one item\n-pub fn noop_fold_item<T: Folder>(item: Item, folder: &mut T) -> Item {\n-    let Item { id, name, attrs, node, vis, span } = item;\n-    let id = folder.new_id(id);\n-    let node = folder.fold_item_underscore(node);\n-\n-    Item {\n-        id: id,\n-        name: folder.fold_name(name),\n-        attrs: fold_attrs(attrs, folder),\n-        node: node,\n-        vis: vis,\n-        span: folder.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n-    ForeignItem {\n-        id: folder.new_id(ni.id),\n-        name: folder.fold_name(ni.name),\n-        attrs: fold_attrs(ni.attrs, folder),\n-        node: match ni.node {\n-            ForeignItemFn(fdec, generics) => {\n-                ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n-            }\n-            ForeignItemStatic(t, m) => {\n-                ForeignItemStatic(folder.fold_ty(t), m)\n-            }\n-        },\n-        vis: ni.vis,\n-        span: folder.new_span(ni.span),\n-    }\n-}\n-\n-pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n-    MethodSig {\n-        generics: folder.fold_generics(sig.generics),\n-        abi: sig.abi,\n-        unsafety: sig.unsafety,\n-        constness: sig.constness,\n-        decl: folder.fold_fn_decl(sig.decl),\n-    }\n-}\n-\n-pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n-    p.map(|Pat { id, node, span }| {\n-        Pat {\n-            id: folder.new_id(id),\n-            node: match node {\n-                PatKind::Wild => PatKind::Wild,\n-                PatKind::Binding(binding_mode, pth1, sub) => {\n-                    PatKind::Binding(binding_mode,\n-                             Spanned {\n-                                 span: folder.new_span(pth1.span),\n-                                 node: folder.fold_name(pth1.node),\n-                             },\n-                             sub.map(|x| folder.fold_pat(x)))\n-                }\n-                PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-                PatKind::TupleStruct(pth, pats, ddpos) => {\n-                    PatKind::TupleStruct(folder.fold_path(pth),\n-                            pats.move_map(|x| folder.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Path(opt_qself, pth) => {\n-                    let opt_qself = opt_qself.map(|qself| {\n-                        QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n-                    });\n-                    PatKind::Path(opt_qself, folder.fold_path(pth))\n-                }\n-                PatKind::Struct(pth, fields, etc) => {\n-                    let pth = folder.fold_path(pth);\n-                    let fs = fields.move_map(|f| {\n-                        Spanned {\n-                            span: folder.new_span(f.span),\n-                            node: hir::FieldPat {\n-                                name: f.node.name,\n-                                pat: folder.fold_pat(f.node.pat),\n-                                is_shorthand: f.node.is_shorthand,\n-                            },\n-                        }\n-                    });\n-                    PatKind::Struct(pth, fs, etc)\n-                }\n-                PatKind::Tuple(elts, ddpos) => {\n-                    PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n-                PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n-                PatKind::Range(e1, e2) => {\n-                    PatKind::Range(folder.fold_expr(e1), folder.fold_expr(e2))\n-                }\n-                PatKind::Vec(before, slice, after) => {\n-                    PatKind::Vec(before.move_map(|x| folder.fold_pat(x)),\n-                           slice.map(|x| folder.fold_pat(x)),\n-                           after.move_map(|x| folder.fold_pat(x)))\n-                }\n-            },\n-            span: folder.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &mut T) -> Expr {\n-    Expr {\n-        id: folder.new_id(id),\n-        node: match node {\n-            ExprBox(e) => {\n-                ExprBox(folder.fold_expr(e))\n-            }\n-            ExprVec(exprs) => {\n-                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprRepeat(expr, count) => {\n-                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n-            }\n-            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n-            ExprCall(f, args) => {\n-                ExprCall(folder.fold_expr(f), args.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprMethodCall(name, tps, args) => {\n-                ExprMethodCall(respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-                               tps.move_map(|x| folder.fold_ty(x)),\n-                               args.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprBinary(binop, lhs, rhs) => {\n-                ExprBinary(binop, folder.fold_expr(lhs), folder.fold_expr(rhs))\n-            }\n-            ExprUnary(binop, ohs) => {\n-                ExprUnary(binop, folder.fold_expr(ohs))\n-            }\n-            ExprLit(l) => ExprLit(l),\n-            ExprCast(expr, ty) => {\n-                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprType(expr, ty) => {\n-                ExprType(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-            ExprIf(cond, tr, fl) => {\n-                ExprIf(folder.fold_expr(cond),\n-                       folder.fold_block(tr),\n-                       fl.map(|x| folder.fold_expr(x)))\n-            }\n-            ExprWhile(cond, body, opt_name) => {\n-                ExprWhile(folder.fold_expr(cond),\n-                          folder.fold_block(body),\n-                          opt_name.map(|label| {\n-                              respan(folder.new_span(label.span), folder.fold_name(label.node))\n-                          }))\n-            }\n-            ExprLoop(body, opt_name) => {\n-                ExprLoop(folder.fold_block(body),\n-                         opt_name.map(|label| {\n-                             respan(folder.new_span(label.span), folder.fold_name(label.node))\n-                         }))\n-            }\n-            ExprMatch(expr, arms, source) => {\n-                ExprMatch(folder.fold_expr(expr),\n-                          arms.move_map(|x| folder.fold_arm(x)),\n-                          source)\n-            }\n-            ExprClosure(capture_clause, decl, body, fn_decl_span) => {\n-                ExprClosure(capture_clause,\n-                            folder.fold_fn_decl(decl),\n-                            folder.fold_block(body),\n-                            folder.new_span(fn_decl_span))\n-            }\n-            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n-            ExprAssign(el, er) => {\n-                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprAssignOp(op, el, er) => {\n-                ExprAssignOp(op, folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprField(el, name) => {\n-                ExprField(folder.fold_expr(el),\n-                          respan(folder.new_span(name.span), folder.fold_name(name.node)))\n-            }\n-            ExprTupField(el, index) => {\n-                ExprTupField(folder.fold_expr(el),\n-                             respan(folder.new_span(index.span), folder.fold_usize(index.node)))\n-            }\n-            ExprIndex(el, er) => {\n-                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprPath(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n-                    QSelf {\n-                        ty: folder.fold_ty(ty),\n-                        position: position,\n-                    }\n-                });\n-                ExprPath(qself, folder.fold_path(path))\n-            }\n-            ExprBreak(opt_name) => ExprBreak(opt_name.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_name(label.node))\n-            })),\n-            ExprAgain(opt_name) => ExprAgain(opt_name.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_name(label.node))\n-            })),\n-            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n-            ExprInlineAsm(asm, outputs, inputs) => {\n-                ExprInlineAsm(asm,\n-                              outputs.move_map(|x| folder.fold_expr(x)),\n-                              inputs.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprStruct(path, fields, maybe_expr) => {\n-                ExprStruct(folder.fold_path(path),\n-                           fields.move_map(|x| folder.fold_field(x)),\n-                           maybe_expr.map(|x| folder.fold_expr(x)))\n-            }\n-        },\n-        span: folder.new_span(span),\n-        attrs: fold_attrs(attrs, folder),\n-    }\n-}\n-\n-pub fn noop_fold_stmt<T: Folder>(stmt: Stmt, folder: &mut T) -> Stmt {\n-    let span = folder.new_span(stmt.span);\n-    match stmt.node {\n-        StmtDecl(d, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtDecl(folder.fold_decl(d), id),\n-                span: span\n-            }\n-        }\n-        StmtExpr(e, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtExpr(folder.fold_expr(e), id),\n-                span: span,\n-            }\n-        }\n-        StmtSemi(e, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtSemi(folder.fold_expr(e), id),\n-                span: span,\n-            }\n-        }\n-    }\n-}"}, {"sha": "726e4e53e231c1fc5c592ac4e80b9be80f7c3524", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -881,8 +881,8 @@ pub struct IdRange {\n impl IdRange {\n     pub fn max() -> IdRange {\n         IdRange {\n-            min: u32::MAX,\n-            max: u32::MIN,\n+            min: NodeId::from_u32(u32::MAX),\n+            max: NodeId::from_u32(u32::MIN),\n         }\n     }\n \n@@ -896,7 +896,7 @@ impl IdRange {\n \n     pub fn add(&mut self, id: NodeId) {\n         self.min = cmp::min(self.min, id);\n-        self.max = cmp::max(self.max, id + 1);\n+        self.max = cmp::max(self.max, NodeId::from_u32(id.as_u32() + 1));\n     }\n \n }"}, {"sha": "37b5eac3cceebcec77d9191b99cb08a14b5d01f6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -61,7 +61,7 @@ use syntax_pos::Span;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n-    sess: Option<&'a Session>,\n+    sess: &'a Session,\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n@@ -81,21 +81,7 @@ pub trait Resolver {\n \n     // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     // This should only return `None` during testing.\n-    fn definitions(&mut self) -> Option<&mut Definitions>;\n-}\n-\n-pub struct DummyResolver;\n-impl Resolver for DummyResolver {\n-    fn resolve_generated_global_path(&mut self, _path: &hir::Path, _is_value: bool) -> Def {\n-        Def::Err\n-    }\n-    fn get_resolution(&mut self, _id: NodeId) -> Option<PathResolution> {\n-        None\n-    }\n-    fn record_resolution(&mut self, _id: NodeId, _def: Def) {}\n-    fn definitions(&mut self) -> Option<&mut Definitions> {\n-        None\n-    }\n+    fn definitions(&mut self) -> &mut Definitions;\n }\n \n pub fn lower_crate(sess: &Session,\n@@ -115,22 +101,13 @@ pub fn lower_crate(sess: &Session,\n         } else {\n             Some(\"std\")\n         },\n-        sess: Some(sess),\n+        sess: sess,\n         parent_def: None,\n         resolver: resolver,\n     }.lower_crate(krate)\n }\n \n impl<'a> LoweringContext<'a> {\n-    pub fn testing_context(resolver: &'a mut Resolver) -> Self {\n-        LoweringContext {\n-            crate_root: None,\n-            sess: None,\n-            parent_def: None,\n-            resolver: resolver,\n-        }\n-    }\n-\n     fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             items: BTreeMap<NodeId, hir::Item>,\n@@ -161,12 +138,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn next_id(&self) -> NodeId {\n-        self.sess.map(Session::next_node_id).unwrap_or(0)\n+        self.sess.next_node_id()\n     }\n \n     fn diagnostic(&self) -> &errors::Handler {\n-        self.sess.map(Session::diagnostic)\n-                 .unwrap_or_else(|| panic!(\"this lowerer cannot emit diagnostics\"))\n+        self.sess.diagnostic()\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> Name {\n@@ -177,9 +153,9 @@ impl<'a> LoweringContext<'a> {\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n         let old_def = self.parent_def;\n-        self.parent_def = match self.resolver.definitions() {\n-            Some(defs) => Some(defs.opt_def_index(parent_id).unwrap()),\n-            None => old_def,\n+        self.parent_def = {\n+            let defs = self.resolver.definitions();\n+            Some(defs.opt_def_index(parent_id).unwrap())\n         };\n \n         let result = f(self);\n@@ -1719,9 +1695,10 @@ impl<'a> LoweringContext<'a> {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n         let expr = self.expr(span, expr_path, ThinVec::new());\n \n-        let def = self.resolver.definitions().map(|defs| {\n-            Def::Local(defs.local_def_id(binding), binding)\n-        }).unwrap_or(Def::Err);\n+        let def = {\n+            let defs = self.resolver.definitions();\n+            Def::Local(defs.local_def_id(binding))\n+        };\n         self.resolver.record_resolution(expr.id, def);\n \n         expr\n@@ -1869,11 +1846,12 @@ impl<'a> LoweringContext<'a> {\n         let pat = self.pat(span, pat_ident);\n \n         let parent_def = self.parent_def;\n-        let def = self.resolver.definitions().map(|defs| {\n+        let def = {\n+            let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());\n             let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n-            Def::Local(DefId::local(def_index), pat.id)\n-        }).unwrap_or(Def::Err);\n+            Def::Local(DefId::local(def_index))\n+        };\n         self.resolver.record_resolution(pat.id, def);\n \n         pat"}, {"sha": "3d9031a136e280cdbd0b5b0ac88178655f121825", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -27,6 +27,10 @@ pub struct NodeCollector<'ast> {\n     pub map: Vec<MapEntry<'ast>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n+    /// If true, completely ignore nested items. We set this when loading\n+    /// HIR from metadata, since in that case we only want the HIR for\n+    /// one specific item (and not the ones nested inside of it).\n+    pub ignore_nested_items: bool\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -35,6 +39,7 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n+            ignore_nested_items: false\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n \n@@ -52,6 +57,7 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: map,\n             parent_node: parent_node,\n+            ignore_nested_items: true\n         };\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n@@ -63,10 +69,10 @@ impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n-        if id as usize >= len {\n-            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n+        if id.as_usize() >= len {\n+            self.map.extend(repeat(NotPresent).take(id.as_usize() - len + 1));\n         }\n-        self.map[id as usize] = entry;\n+        self.map[id.as_usize()] = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n@@ -88,7 +94,9 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// their outer items.\n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.visit_item(self.krate.item(item.id))\n+        if !self.ignore_nested_items {\n+            self.visit_item(self.krate.item(item.id))\n+        }\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {"}, {"sha": "ea1f8aac7a55ab036a3d065529468c118e017188", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -285,15 +285,6 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n \n // We walk the HIR rather than the AST when reading items from metadata.\n impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n-    /// Because we want to track parent items and so forth, enable\n-    /// deep walking so that we walk nested items in the context of\n-    /// their outer items.\n-    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n-        debug!(\"visit_nested_item: {:?}\", item_id);\n-        let item = self.hir_crate.unwrap().item(item_id.id);\n-        self.visit_item(item)\n-    }\n-\n     fn visit_item(&mut self, i: &'ast hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "f404f60cc9cefa766afeb4ec3f814f6ed68bddef", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map::def_collector::DefCollector;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::fmt::Write;\n use std::hash::{Hash, Hasher, SipHasher};\n use syntax::{ast, visit};\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{self, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n@@ -70,15 +69,15 @@ pub struct DefPath {\n     pub data: Vec<DisambiguatedDefPathData>,\n \n     /// what krate root is this path relative to?\n-    pub krate: ast::CrateNum,\n+    pub krate: CrateNum,\n }\n \n impl DefPath {\n     pub fn is_local(&self) -> bool {\n         self.krate == LOCAL_CRATE\n     }\n \n-    pub fn make<FN>(start_krate: ast::CrateNum,\n+    pub fn make<FN>(start_krate: CrateNum,\n                     start_index: DefIndex,\n                     mut get_key: FN) -> DefPath\n         where FN: FnMut(DefIndex) -> DefKey\n@@ -116,11 +115,7 @@ impl DefPath {\n     pub fn to_string(&self, tcx: TyCtxt) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n-        if self.krate == LOCAL_CRATE {\n-            s.push_str(&tcx.crate_name(self.krate));\n-        } else {\n-            s.push_str(&tcx.sess.cstore.original_crate_name(self.krate));\n-        }\n+        s.push_str(&tcx.original_crate_name(self.krate));\n         s.push_str(\"/\");\n         s.push_str(&tcx.crate_disambiguator(self.krate));\n \n@@ -142,7 +137,7 @@ impl DefPath {\n     }\n \n     pub fn deterministic_hash_to<H: Hasher>(&self, tcx: TyCtxt, state: &mut H) {\n-        tcx.crate_name(self.krate).hash(state);\n+        tcx.original_crate_name(self.krate).hash(state);\n         tcx.crate_disambiguator(self.krate).hash(state);\n         self.data.hash(state);\n     }\n@@ -327,6 +322,30 @@ impl Definitions {\n }\n \n impl DefPathData {\n+    pub fn get_opt_name(&self) -> Option<ast::Name> {\n+        use self::DefPathData::*;\n+        match *self {\n+            TypeNs(ref name) |\n+            ValueNs(ref name) |\n+            Module(ref name) |\n+            MacroDef(ref name) |\n+            TypeParam(ref name) |\n+            LifetimeDef(ref name) |\n+            EnumVariant(ref name) |\n+            Binding(ref name) |\n+            Field(ref name) => Some(token::intern(name)),\n+\n+            Impl |\n+            CrateRoot |\n+            InlinedRoot(_) |\n+            Misc |\n+            ClosureExpr |\n+            StructCtor |\n+            Initializer |\n+            ImplTrait => None\n+        }\n+    }\n+\n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n         match *self {"}, {"sha": "b351bd427acbc26de10d8a477d7b10473b09ac9a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 28, "deletions": 100, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -22,17 +22,15 @@ use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n+use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n-use hir::fold::Folder;\n use hir::print as pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n-use std::cmp;\n use std::io;\n use std::mem;\n \n@@ -240,7 +238,7 @@ impl<'ast> Map<'ast> {\n         let mut id = id0;\n         if !self.is_inlined_node_id(id) {\n             loop {\n-                match map[id as usize] {\n+                match map[id.as_usize()] {\n                     EntryItem(_, item) => {\n                         let def_id = self.local_def_id(item.id);\n                         // NB                          ^~~~~~~\n@@ -295,7 +293,7 @@ impl<'ast> Map<'ast> {\n             // reading from an inlined def-id is really a read out of\n             // the metadata from which we loaded the item.\n             loop {\n-                match map[id as usize] {\n+                match map[id.as_usize()] {\n                     EntryItem(p, _) |\n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n@@ -373,7 +371,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id as usize).cloned()\n+        self.map.borrow().get(id.as_usize()).cloned()\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -456,8 +454,8 @@ impl<'ast> Map<'ast> {\n         let mut id = start_id;\n         loop {\n             let parent_node = self.get_parent_node(id);\n-            if parent_node == 0 {\n-                return Ok(0);\n+            if parent_node == CRATE_NODE_ID {\n+                return Ok(CRATE_NODE_ID);\n             }\n             if parent_node == id {\n                 return Err(id);\n@@ -582,22 +580,24 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> &'ast VariantData {\n+    pub fn expect_variant_data(&self, id: NodeId) -> &'ast VariantData {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) => struct_def,\n-                    _ => bug!(\"struct ID bound to non-struct\")\n+                    ItemStruct(ref struct_def, _) |\n+                    ItemUnion(ref struct_def, _) => struct_def,\n+                    _ => {\n+                        bug!(\"struct ID bound to non-struct {}\",\n+                             self.node_to_string(id));\n+                    }\n                 }\n             }\n-            Some(NodeVariant(variant)) => {\n-                if variant.node.data.is_struct() {\n-                    &variant.node.data\n-                } else {\n-                    bug!(\"struct ID bound to enum variant that isn't struct-like\")\n-                }\n+            Some(NodeStructCtor(data)) => data,\n+            Some(NodeVariant(variant)) => &variant.node.data,\n+            _ => {\n+                bug!(\"expected struct or variant, found {}\",\n+                     self.node_to_string(id));\n             }\n-            _ => bug!(\"expected struct, found {}\", self.node_to_string(id)),\n         }\n     }\n \n@@ -680,7 +680,7 @@ impl<'ast> Map<'ast> {\n             map: self,\n             item_name: parts.last().unwrap(),\n             in_which: &parts[..parts.len() - 1],\n-            idx: 0,\n+            idx: CRATE_NODE_ID,\n         }\n     }\n \n@@ -801,10 +801,10 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n-            if idx as usize >= self.map.entry_count() {\n+            if idx.as_usize() >= self.map.entry_count() {\n                 return None;\n             }\n-            self.idx += 1;\n+            self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx) {\n                 Some(EntryItem(_, n))       => n.name(),\n                 Some(EntryForeignItem(_, n))=> n.name(),\n@@ -832,57 +832,6 @@ impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n-pub trait FoldOps {\n-    fn new_id(&self, id: NodeId) -> NodeId {\n-        id\n-    }\n-    fn new_def_id(&self, def_id: DefId) -> DefId {\n-        def_id\n-    }\n-    fn new_span(&self, span: Span) -> Span {\n-        span\n-    }\n-}\n-\n-/// A Folder that updates IDs and Span's according to fold_ops.\n-pub struct IdAndSpanUpdater<F> {\n-    fold_ops: F,\n-    min_id_assigned: NodeId,\n-    max_id_assigned: NodeId,\n-}\n-\n-impl<F: FoldOps> IdAndSpanUpdater<F> {\n-    pub fn new(fold_ops: F) -> IdAndSpanUpdater<F> {\n-        IdAndSpanUpdater {\n-            fold_ops: fold_ops,\n-            min_id_assigned: ::std::u32::MAX,\n-            max_id_assigned: ::std::u32::MIN,\n-        }\n-    }\n-\n-    pub fn id_range(&self) -> intravisit::IdRange {\n-        intravisit::IdRange {\n-            min: self.min_id_assigned,\n-            max: self.max_id_assigned + 1,\n-        }\n-    }\n-}\n-\n-impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n-    fn new_id(&mut self, id: NodeId) -> NodeId {\n-        let id = self.fold_ops.new_id(id);\n-\n-        self.min_id_assigned = cmp::min(self.min_id_assigned, id);\n-        self.max_id_assigned = cmp::max(self.max_id_assigned, id);\n-\n-        id\n-    }\n-\n-    fn new_span(&mut self, span: Span) -> Span {\n-        self.fold_ops.new_span(span)\n-    }\n-}\n-\n pub fn map_crate<'ast>(forest: &'ast mut Forest,\n                        definitions: Definitions)\n                        -> Map<'ast> {\n@@ -906,7 +855,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    let local_node_id_watermark = map.len() as NodeId;\n+    let local_node_id_watermark = NodeId::new(map.len());\n     let local_def_id_watermark = definitions.len();\n \n     Map {\n@@ -921,36 +870,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.\n-pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n-                                          parent_def_path: DefPath,\n-                                          parent_def_id: DefId,\n-                                          ii: InlinedItem,\n-                                          fold_ops: F)\n-                                          -> &'ast InlinedItem {\n+pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n+                              parent_def_path: DefPath,\n+                              parent_def_id: DefId,\n+                              ii: InlinedItem,\n+                              ii_parent_id: NodeId)\n+                              -> &'ast InlinedItem {\n     let _ignore = map.forest.dep_graph.in_ignore();\n \n-    let mut fld = IdAndSpanUpdater::new(fold_ops);\n-    let ii = match ii {\n-        II::Item(d, i) => II::Item(fld.fold_ops.new_def_id(d),\n-                                   i.map(|i| fld.fold_item(i))),\n-        II::TraitItem(d, ti) => {\n-            II::TraitItem(fld.fold_ops.new_def_id(d),\n-                          ti.map(|ti| fld.fold_trait_item(ti)))\n-        }\n-        II::ImplItem(d, ii) => {\n-            II::ImplItem(fld.fold_ops.new_def_id(d),\n-                         ii.map(|ii| fld.fold_impl_item(ii)))\n-        }\n-    };\n-\n     let ii = map.forest.inlined_items.alloc(ii);\n-    let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-\n-    // Assert that the ii_parent_id is the last NodeId in our reserved range\n-    assert!(ii_parent_id == fld.max_id_assigned);\n-    // Assert that we did not violate the invariant that all inlined HIR items\n-    // have NodeIds greater than or equal to `local_node_id_watermark`\n-    assert!(fld.min_id_assigned >= map.local_node_id_watermark);\n \n     let defs = &mut *map.definitions.borrow_mut();\n     let mut def_collector = DefCollector::extend(ii_parent_id,"}, {"sha": "0cfdbae1a50b0a53d7bd1f9e1392620dc45eb391", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -67,7 +67,6 @@ macro_rules! hir_vec {\n pub mod check_attr;\n pub mod def;\n pub mod def_id;\n-pub mod fold;\n pub mod intravisit;\n pub mod lowering;\n pub mod map;"}, {"sha": "dec41fdfc3b50c35a4693339c61948d6488a3407", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -174,7 +174,7 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n             PatKind::Path(..) |\n             PatKind::Struct(..) => {\n                 match dm.get(&p.id) {\n-                    Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {\n+                    Some(&PathResolution { base_def: Def::Variant(id), .. }) => {\n                         variants.push(id);\n                     }\n                     _ => ()"}, {"sha": "289f7d6c7380088ba4a8bb6f25d346a864f4f284", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -63,9 +63,8 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let requested_node: Option<ast::NodeId> = env::var(\"RUST_REGION_GRAPH_NODE\")\n-                                                  .ok()\n-                                                  .and_then(|s| s.parse().ok());\n+    let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n+        .ok().and_then(|s| s.parse().map(ast::NodeId::new).ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;"}, {"sha": "c34286f0195bfb61005beb5bdc676537932ae928", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -50,7 +50,6 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate rbml;\n extern crate rustc_llvm as llvm;\n extern crate rustc_back;\n extern crate rustc_data_structures;"}, {"sha": "e57e116cea7407e2a48b9fe87cf334e6ed226a7d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 79, "deletions": 304, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -23,19 +23,18 @@\n // probably get a better home if someone can find one.\n \n use hir::def::{self, Def};\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n use hir::map::definitions::DefKey;\n use hir::svh::Svh;\n use middle::lang_items;\n-use ty::{self, Ty, TyCtxt, VariantKind};\n+use ty::{self, Ty, TyCtxt};\n use mir::repr::Mir;\n use mir::mir_map::MirMap;\n use session::Session;\n use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n-use util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n-use std::rc::Rc;\n+use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n@@ -47,7 +46,6 @@ use rustc_back::target::Target;\n use hir;\n use hir::intravisit::Visitor;\n \n-pub use self::DefLike::{DlDef, DlField, DlImpl};\n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n \n // lonely orphan structs and enums looking for a better home\n@@ -64,30 +62,20 @@ pub struct LinkMeta {\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone)]\n+#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub enum NativeLibraryKind {\n-        NativeStatic,    // native static library (.a archive)\n-        NativeFramework, // OSX-specific\n-        NativeUnknown,   // default way to specify a dynamic library\n-    }\n-}\n-\n-// Something that a name can resolve to.\n-#[derive(Copy, Clone, Debug)]\n-pub enum DefLike {\n-    DlDef(Def),\n-    DlImpl(DefId),\n-    DlField\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum NativeLibraryKind {\n+    NativeStatic,    // native static library (.a archive)\n+    NativeFramework, // OSX-specific\n+    NativeUnknown,   // default way to specify a dynamic library\n }\n \n /// The data we save and restore about an inlined item or method.  This is not\n@@ -101,24 +89,13 @@ pub enum InlinedItem {\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n     Item(DefId, &'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n     ImplItem(DefId, &'a hir::ImplItem)\n }\n \n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n-pub const LOCAL_CRATE: ast::CrateNum = 0;\n-\n-#[derive(Copy, Clone)]\n-pub struct ChildItem {\n-    pub def: DefLike,\n-    pub name: ast::Name,\n-    pub vis: ty::Visibility,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct ExternCrate {\n     /// def_id of an `extern crate` in the current crate that caused\n@@ -144,47 +121,39 @@ pub struct ExternCrate {\n /// can be accessed.\n pub trait CrateStore<'tcx> {\n     // item info\n+    fn describe_def(&self, def: DefId) -> Option<Def>;\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>;\n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance>;\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n-    fn item_name(&self, def: DefId) -> ast::Name;\n-    fn opt_item_name(&self, def: DefId) -> Option<ast::Name>;\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>;\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx>;\n+                         -> ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n-    fn method_arg_names(&self, did: DefId) -> Vec<String>;\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>>;\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId>;\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>;\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n@@ -195,53 +164,46 @@ pub trait CrateStore<'tcx> {\n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n-    fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n-    fn is_typedef(&self, did: DefId) -> bool;\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                    -> Vec<(ast::CrateNum, LinkagePreference)>;\n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>;\n-    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>;\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_compiler_builtins(&self, cnum: ast::CrateNum) -> bool;\n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy;\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>;\n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                    -> Vec<(CrateNum, LinkagePreference)>;\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n+    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool;\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool;\n+    fn is_allocator(&self, cnum: CrateNum) -> bool;\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool;\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy;\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString;\n     /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> InternedString;\n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>;\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>;\n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>;\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool;\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh;\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>;\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex>;\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n+    fn variant_kind(&self, def_id: DefId) -> Option<ty::VariantKind>;\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n-    fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n+    fn item_children(&self, did: DefId) -> Vec<def::Export>;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -255,27 +217,21 @@ pub trait CrateStore<'tcx> {\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<ast::CrateNum>;\n+    fn crates(&self) -> Vec<CrateNum>;\n     fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)>;\n     fn used_link_args(&self) -> Vec<String>;\n \n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8>;\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>;\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8>;\n+                           mir_map: &MirMap<'tcx>) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -324,59 +280,51 @@ pub struct DummyCrateStore;\n #[allow(unused_variables)]\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n+    fn describe_def(&self, def: DefId) -> Option<Def> { bug!(\"describe_def\") }\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind  { bug!(\"closure_kind\") }\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind { bug!(\"closure_kind\") }\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance> { bug!(\"item_variances\") }\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n-    fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n-    fn opt_item_name(&self, def: DefId) -> Option<ast::Name> { bug!(\"opt_item_name\") }\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx> { bug!(\"item_generics\") }\n+                         -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }\n-    fn method_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"method_arg_names\") }\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex> {\n         None\n     }\n \n     // impl info\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n-        { bug!(\"impl_items\") }\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>\n+        { bug!(\"impl_or_trait_items\") }\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { bug!(\"impl_polarity\") }\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n         { bug!(\"custom_coerce_unsized_kind\") }\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n@@ -387,64 +335,53 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n-    fn is_impl(&self, did: DefId) -> bool { bug!(\"is_impl\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n         { bug!(\"is_extern_item\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n-    fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                    -> Vec<(ast::CrateNum, LinkagePreference)>\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                    -> Vec<(CrateNum, LinkagePreference)>\n         { bug!(\"dylib_dependency_formats\") }\n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n         { bug!(\"lang_items\") }\n-    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>\n+    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n         { bug!(\"missing_lang_items\") }\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_staged_api\") }\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_allocator\") }\n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n-    fn is_compiler_builtins(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy {\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool { bug!(\"is_staged_api\") }\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n+    fn is_allocator(&self, cnum: CrateNum) -> bool { bug!(\"is_allocator\") }\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n         bug!(\"panic_strategy\")\n     }\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n-        { bug!(\"crate_attrs\") }\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString {\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString { bug!(\"crate_name\") }\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString {\n         bug!(\"original_crate_name\")\n     }\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh { bug!(\"crate_hash\") }\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum)\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n+    fn crate_disambiguator(&self, cnum: CrateNum)\n                            -> InternedString { bug!(\"crate_disambiguator\") }\n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n-        { bug!(\"crate_struct_field_attrs\") }\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n         { bug!(\"native_libraries\") }\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_no_builtins\") }\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n         bug!(\"relative_def_path\")\n     }\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { bug!(\"variant_kind\") }\n+    fn variant_kind(&self, def_id: DefId) -> Option<ty::VariantKind> { bug!(\"variant_kind\") }\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n         { bug!(\"struct_ctor_def_id\") }\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n-        { bug!(\"tuple_struct_definition_if_ctor\") }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n-    fn item_children(&self, did: DefId) -> Vec<ChildItem> { bug!(\"item_children\") }\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n-        { bug!(\"crate_top_level_items\") }\n+    fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -466,187 +403,25 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<ast::CrateNum> { vec![] }\n+    fn crates(&self) -> Vec<CrateNum> { vec![] }\n     fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)> { vec![] }\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8> {\n-        bug!(\"encode_type\")\n-    }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n         { vec![] }\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8> { vec![] }\n+                           mir_map: &MirMap<'tcx>) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n pub trait MacroLoader {\n      fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n }\n-\n-/// Metadata encoding and decoding can make use of thread-local encoding and\n-/// decoding contexts. These allow implementers of serialize::Encodable and\n-/// Decodable to access information and datastructures that would otherwise not\n-/// be available to them. For example, we can automatically translate def-id and\n-/// span information during decoding because the decoding context knows which\n-/// crate the data is decoded from. Or it allows to make ty::Ty decodable\n-/// because the context has access to the TyCtxt that is needed for creating\n-/// ty::Ty instances.\n-///\n-/// Note, however, that this only works for RBML-based encoding and decoding at\n-/// the moment.\n-pub mod tls {\n-    use rbml::opaque::Encoder as OpaqueEncoder;\n-    use rbml::opaque::Decoder as OpaqueDecoder;\n-    use serialize;\n-    use std::cell::Cell;\n-    use std::mem;\n-    use ty::{self, Ty, TyCtxt};\n-    use ty::subst::Substs;\n-    use hir::def_id::DefId;\n-\n-    pub trait EncodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: Ty<'tcx>);\n-        fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>);\n-    }\n-\n-    /// Marker type used for the TLS slot.\n-    /// The type context cannot be used directly because the TLS\n-    /// in libstd doesn't allow types generic over lifetimes.\n-    struct TlsPayload;\n-\n-    thread_local! {\n-        static TLS_ENCODING: Cell<Option<*const TlsPayload>> = Cell::new(None)\n-    }\n-\n-    /// Execute f after pushing the given EncodingContext onto the TLS stack.\n-    pub fn enter_encoding_context<'tcx, F, R>(ecx: &EncodingContext<'tcx>,\n-                                              encoder: &mut OpaqueEncoder,\n-                                              f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R\n-    {\n-        let tls_payload = (ecx as *const _, encoder as *mut _);\n-        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_ENCODING.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some(tls_ptr));\n-            let ret = f(ecx, encoder);\n-            tls.set(prev);\n-            return ret\n-        })\n-    }\n-\n-    /// Execute f with access to the thread-local encoding context and\n-    /// rbml encoder. This function will panic if the encoder passed in and the\n-    /// context encoder are not the same.\n-    ///\n-    /// Note that this method is 'practically' safe due to its checking that the\n-    /// encoder passed in is the same as the one in TLS, but it would still be\n-    /// possible to construct cases where the EncodingContext is exchanged\n-    /// while the same encoder is used, thus working with a wrong context.\n-    pub fn with_encoding_context<'tcx, E, F, R>(encoder: &mut E, f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R,\n-              E: serialize::Encoder\n-    {\n-        unsafe {\n-            unsafe_with_encoding_context(|ecx, tls_encoder| {\n-                assert!(encoder as *mut _ as usize == tls_encoder as *mut _ as usize);\n-\n-                let ecx: &EncodingContext<'tcx> = mem::transmute(ecx);\n-\n-                f(ecx, tls_encoder)\n-            })\n-        }\n-    }\n-\n-    /// Execute f with access to the thread-local encoding context and\n-    /// rbml encoder.\n-    pub unsafe fn unsafe_with_encoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&EncodingContext, &mut OpaqueEncoder) -> R\n-    {\n-        TLS_ENCODING.with(|tls| {\n-            let tls = tls.get().unwrap();\n-            let tls_payload = tls as *mut (&EncodingContext, &mut OpaqueEncoder);\n-            f((*tls_payload).0, (*tls_payload).1)\n-        })\n-    }\n-\n-    pub trait DecodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n-        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx>;\n-        fn translate_def_id(&self, def_id: DefId) -> DefId;\n-    }\n-\n-    thread_local! {\n-        static TLS_DECODING: Cell<Option<*const TlsPayload>> = Cell::new(None)\n-    }\n-\n-    /// Execute f after pushing the given DecodingContext onto the TLS stack.\n-    pub fn enter_decoding_context<'tcx, F, R>(dcx: &DecodingContext<'tcx>,\n-                                              decoder: &mut OpaqueDecoder,\n-                                              f: F) -> R\n-        where F: FnOnce(&DecodingContext<'tcx>, &mut OpaqueDecoder) -> R\n-    {\n-        let tls_payload = (dcx as *const _, decoder as *mut _);\n-        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_DECODING.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some(tls_ptr));\n-            let ret = f(dcx, decoder);\n-            tls.set(prev);\n-            return ret\n-        })\n-    }\n-\n-    /// Execute f with access to the thread-local decoding context and\n-    /// rbml decoder. This function will panic if the decoder passed in and the\n-    /// context decoder are not the same.\n-    ///\n-    /// Note that this method is 'practically' safe due to its checking that the\n-    /// decoder passed in is the same as the one in TLS, but it would still be\n-    /// possible to construct cases where the DecodingContext is exchanged\n-    /// while the same decoder is used, thus working with a wrong context.\n-    pub fn with_decoding_context<'decoder, 'tcx, D, F, R>(d: &'decoder mut D, f: F) -> R\n-        where D: serialize::Decoder,\n-              F: FnOnce(&DecodingContext<'tcx>,\n-                        &mut OpaqueDecoder) -> R,\n-              'tcx: 'decoder\n-    {\n-        unsafe {\n-            unsafe_with_decoding_context(|dcx, decoder| {\n-                assert!((d as *mut _ as usize) == (decoder as *mut _ as usize));\n-\n-                let dcx: &DecodingContext<'tcx> = mem::transmute(dcx);\n-\n-                f(dcx, decoder)\n-            })\n-        }\n-    }\n-\n-    /// Execute f with access to the thread-local decoding context and\n-    /// rbml decoder.\n-    pub unsafe fn unsafe_with_decoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&DecodingContext, &mut OpaqueDecoder) -> R\n-    {\n-        TLS_DECODING.with(|tls| {\n-            let tls = tls.get().unwrap();\n-            let tls_payload = tls as *mut (&DecodingContext, &mut OpaqueDecoder);\n-            f((*tls_payload).0, (*tls_payload).1)\n-        })\n-    }\n-}"}, {"sha": "7f3a58808c225edbf261871171935d1d2a88fcc7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -112,10 +112,10 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeName(_) => 0,\n+            pprust::NodeName(_) => ast::CRATE_NODE_ID,\n             pprust::NodeExpr(expr) => expr.id,\n             pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) | pprust::NodeSubItem(_) => 0,\n+            pprust::NodeItem(_) | pprust::NodeSubItem(_) => ast::CRATE_NODE_ID,\n             pprust::NodePat(pat) => pat.id\n         };\n "}, {"sha": "30a0c6a9dc93963fd4e2f0473f73038791fb6892", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -108,8 +108,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ if self.ignore_non_const_paths => (),\n             Def::PrimTy(_) => (),\n             Def::SelfTy(..) => (),\n-            Def::Variant(enum_id, variant_id) => {\n-                self.check_def_id(enum_id);\n+            Def::Variant(variant_id) => {\n+                if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n+                    self.check_def_id(enum_id);\n+                }\n                 if !self.ignore_variant_stack.contains(&variant_id) {\n                     self.check_def_id(variant_id);\n                 }\n@@ -470,13 +472,12 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_items = self.tcx.impl_items.borrow();\n+        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n         if let Some(impl_list) =\n                 self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n             for impl_did in impl_list.iter() {\n-                for item_did in impl_items.get(impl_did).unwrap().iter() {\n-                    if let Some(item_node_id) =\n-                            self.tcx.map.as_local_node_id(item_did.def_id()) {\n+                for &item_did in &impl_items[impl_did][..] {\n+                    if let Some(item_node_id) = self.tcx.map.as_local_node_id(item_did) {\n                         if self.live_symbols.contains(&item_node_id) {\n                             return true;\n                         }"}, {"sha": "c6908e11ed20950902468383b5437c203ff89769", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -61,7 +61,7 @@\n //! Additionally, the algorithm is geared towards finding *any* solution rather\n //! than finding a number of solutions (there are normally quite a few).\n \n-use syntax::ast;\n+use hir::def_id::CrateNum;\n \n use session;\n use session::config::{self, PanicStrategy};\n@@ -169,9 +169,9 @@ fn calculate_type(sess: &session::Session,\n     }\n \n     // Collect what we've got so far in the return vector.\n-    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        match formats.get(&cnum) {\n+        match formats.get(&CrateNum::new(cnum)) {\n             Some(&RequireDynamic) => Linkage::Dynamic,\n             Some(&RequireStatic) => Linkage::IncludedFromDylib,\n             None => Linkage::NotLinked,\n@@ -191,7 +191,7 @@ fn calculate_type(sess: &session::Session,\n             assert!(src.rlib.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n-            ret[cnum as usize - 1] = Linkage::Static;\n+            ret[cnum.as_usize() - 1] = Linkage::Static;\n         }\n     }\n \n@@ -213,7 +213,7 @@ fn calculate_type(sess: &session::Session,\n     // For situations like this, we perform one last pass over the dependencies,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n-        let cnum = (cnum + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(cnum + 1);\n         let src = sess.cstore.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n@@ -237,9 +237,9 @@ fn calculate_type(sess: &session::Session,\n }\n \n fn add_library(sess: &session::Session,\n-               cnum: ast::CrateNum,\n+               cnum: CrateNum,\n                link: LinkagePreference,\n-               m: &mut FnvHashMap<ast::CrateNum, LinkagePreference>) {\n+               m: &mut FnvHashMap<CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n@@ -269,9 +269,9 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n-    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.is_explicitly_linked(cnum) {\n+        if sess.cstore.is_explicitly_linked(CrateNum::new(cnum)) {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -298,11 +298,11 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n // a required dependency) in one of the session's field. If this field is not\n // set then this compilation doesn't actually need the dependency and we can\n // also skip this step entirely.\n-fn activate_injected_dep(injected: Option<ast::CrateNum>,\n+fn activate_injected_dep(injected: Option<CrateNum>,\n                          list: &mut DependencyList,\n-                         replaces_injected: &Fn(ast::CrateNum) -> bool) {\n+                         replaces_injected: &Fn(CrateNum) -> bool) {\n     for (i, slot) in list.iter().enumerate() {\n-        let cnum = (i + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(i + 1);\n         if !replaces_injected(cnum) {\n             continue\n         }\n@@ -311,7 +311,7 @@ fn activate_injected_dep(injected: Option<ast::CrateNum>,\n         }\n     }\n     if let Some(injected) = injected {\n-        let idx = injected as usize - 1;\n+        let idx = injected.as_usize() - 1;\n         assert_eq!(list[idx], Linkage::NotLinked);\n         list[idx] = Linkage::Static;\n     }\n@@ -329,7 +329,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n         if let Linkage::NotLinked = *linkage {\n             continue\n         }\n-        let cnum = (i + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(i + 1);\n         if sess.cstore.is_allocator(cnum) {\n             if let Some(prev) = allocator {\n                 let prev_name = sess.cstore.crate_name(prev);\n@@ -380,7 +380,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n             if desired_strategy == PanicStrategy::Abort {\n                 continue\n             }\n-            let cnum = (i + 1) as ast::CrateNum;\n+            let cnum = CrateNum::new(i + 1);\n             let found_strategy = sess.cstore.panic_strategy(cnum);\n             if desired_strategy == found_strategy {\n                 continue"}, {"sha": "5b5c3da8f05b2eae0334c60879f5a8d7e0f2933d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -1003,7 +1003,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             match tcx.expect_def_or_none(pat.id) {\n-                Some(Def::Variant(enum_did, variant_did)) => {\n+                Some(Def::Variant(variant_did)) => {\n+                    let enum_did = tcx.parent_def_id(variant_did).unwrap();\n                     let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n                         cmt_pat\n                     } else {\n@@ -1029,7 +1030,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let id_var = freevar.def.var_id();\n+                let def_id = freevar.def.def_id();\n+                let id_var = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n                 let upvar_capture = self.mc.infcx.upvar_capture(upvar_id).unwrap();\n@@ -1061,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = upvar_def.var_id();\n+        let var_id = self.tcx().map.as_local_node_id(upvar_def.def_id()).unwrap();\n         let var_ty = self.mc.infcx.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "078cce9c49ff4410121b4893e48f31f0eb308fa3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -43,7 +43,7 @@ macro_rules! language_item_table {\n \n \n enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+    #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n     pub enum LangItem {\n         $($variant,)*\n     }"}, {"sha": "db9dd82d492d3193650fd464a0248bd63991511a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -465,7 +465,8 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         let mut call_caps = Vec::new();\n         ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n-                if let Def::Local(_, rv) = fv.def {\n+                if let Def::Local(def_id) = fv.def {\n+                    let rv = ir.tcx.map.as_local_node_id(def_id).unwrap();\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n                                                 var_nid: rv});\n@@ -1270,7 +1271,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match self.ir.tcx.expect_def(expr.id) {\n-          Def::Local(_, nid) => {\n+          Def::Local(def_id) => {\n+            let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n@@ -1529,11 +1531,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                if let Def::Local(_, nid) = self.ir.tcx.expect_def(expr.id) {\n+                if let Def::Local(def_id) = self.ir.tcx.expect_def(expr.id) {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n                     // as being used.\n+                    let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, expr.id, ln, var);"}, {"sha": "340a5ac8f87b73a03f6a06adb8360006ece44cfd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -529,7 +529,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n \n-          Def::Mod(_) | Def::ForeignMod(_) |\n+          Def::Mod(_) |\n           Def::Trait(_) | Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(_) |\n           Def::TyParam(..) |\n           Def::Label(_) | Def::SelfTy(..) |\n@@ -549,7 +549,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n               }))\n           }\n \n-          Def::Upvar(_, var_id, _, fn_node_id) => {\n+          Def::Upvar(def_id, _, fn_node_id) => {\n+              let var_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n               let ty = self.node_ty(fn_node_id)?;\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {\n@@ -585,7 +586,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n               }\n           }\n \n-          Def::Local(_, vid) => {\n+          Def::Local(def_id) => {\n+            let vid = self.tcx().map.as_local_node_id(def_id).unwrap();\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n@@ -1075,18 +1077,23 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // alone) because PatKind::Struct can also refer to variants.\n         let cmt = match self.tcx().expect_def_or_none(pat.id) {\n             Some(Def::Err) => return Err(()),\n-            Some(Def::Variant(enum_did, variant_did))\n+            Some(Def::Variant(variant_did)) => {\n                 // univariant enums do not need downcasts\n-                if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n+                let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n+                if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n+                } else {\n+                    cmt\n                 }\n+            }\n             _ => cmt\n         };\n \n         match pat.node {\n           PatKind::TupleStruct(_, ref subpats, ddpos) => {\n             let expected_len = match self.tcx().expect_def(pat.id) {\n-                Def::Variant(enum_def, def_id) => {\n+                Def::Variant(def_id) => {\n+                    let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n                     self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n                 Def::Struct(..) => {"}, {"sha": "33110c61e8f8b1f0cf95c30f319c600f599a545d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -20,7 +20,6 @@ use dep_graph::DepNode;\n use hir::map as ast_map;\n use session::Session;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n-use middle::cstore::InlinedItem;\n use ty;\n \n use std::cell::RefCell;\n@@ -1256,19 +1255,3 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n     }\n     return maps;\n }\n-\n-pub fn resolve_inlined_item(sess: &Session,\n-                            region_maps: &RegionMaps,\n-                            item: &InlinedItem) {\n-    let mut visitor = RegionResolutionVisitor {\n-        sess: sess,\n-        region_maps: region_maps,\n-        cx: Context {\n-            root_id: None,\n-            parent: ROOT_CODE_EXTENT,\n-            var_parent: ROOT_CODE_EXTENT\n-        },\n-        terminating_scopes: NodeSet()\n-    };\n-    item.visit(&mut visitor);\n-}"}, {"sha": "2c768db47f11a94661c000b9c99ae6167443fc3b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -17,9 +17,8 @@ use dep_graph::DepNode;\n use hir::map as hir_map;\n use session::Session;\n use lint;\n-use middle::cstore::LOCAL_CRATE;\n use hir::def::Def;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n use ty::{self, TyCtxt, AdtKind};\n use middle::privacy::AccessLevels;\n use syntax::parse::token::InternedString;\n@@ -103,7 +102,7 @@ pub struct Index<'tcx> {\n     depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FnvHashMap<ast::CrateNum, bool>\n+    staged_api: FnvHashMap<CrateNum, bool>\n }\n \n // A private tree-walker for producing an Index.\n@@ -696,10 +695,9 @@ fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n \n fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n     match tcx.trait_item_of_item(id) {\n-        Some(ty::MethodTraitItemId(trait_method_id))\n-            if trait_method_id != id => {\n-                is_staged_api(tcx, trait_method_id)\n-            }\n+        Some(trait_method_id) if trait_method_id != id => {\n+            is_staged_api(tcx, trait_method_id)\n+        }\n         _ => {\n             *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n                 || tcx.sess.cstore.is_staged_api(id.krate))"}, {"sha": "6ad6251d584a9739e8309325600aeaa030c9649c", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -1154,7 +1154,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, lv) in freevars.iter().zip(lvs) {\n-                                    let var_name = tcx.local_var_name_str(freevar.def.var_id());\n+                                    let def_id = freevar.def.def_id();\n+                                    let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                                    let var_name = tcx.local_var_name_str(var_id);\n                                     struct_fmt.field(&var_name, lv);\n                                 }\n                             });"}, {"sha": "8dd5d4d45f7a40e263319849fdd5f9c80de235f4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -493,7 +493,7 @@ impl Passes {\n     }\n }\n \n-#[derive(Clone, PartialEq, Hash)]\n+#[derive(Clone, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub enum PanicStrategy {\n     Unwind,\n     Abort,"}, {"sha": "268dbd70bb5bb2f8cd1bdde4a9c4e8bbd4efbbd2", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepGraph;\n-use hir::def_id::DefIndex;\n+use hir::def_id::{CrateNum, DefIndex};\n use hir::svh::Svh;\n use lint;\n use middle::cstore::CrateStore;\n@@ -93,8 +93,8 @@ pub struct Session {\n     /// The metadata::creader module may inject an allocator/panic_runtime\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n-    pub injected_allocator: Cell<Option<ast::CrateNum>>,\n-    pub injected_panic_runtime: Cell<Option<ast::CrateNum>>,\n+    pub injected_allocator: Cell<Option<CrateNum>>,\n+    pub injected_panic_runtime: Cell<Option<CrateNum>>,\n \n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n@@ -266,11 +266,13 @@ impl Session {\n         }\n         lints.insert(id, vec!((lint_id, sp, msg)));\n     }\n-    pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n+    pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n         let id = self.next_node_id.get();\n \n-        match id.checked_add(count) {\n-            Some(next) => self.next_node_id.set(next),\n+        match id.as_usize().checked_add(count) {\n+            Some(next) => {\n+                self.next_node_id.set(ast::NodeId::new(next));\n+            }\n             None => bug!(\"Input too large, ran out of node ids!\")\n         }\n \n@@ -545,7 +547,7 @@ pub fn build_session_(sopts: config::Options,\n         crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n-        next_node_id: Cell::new(1),\n+        next_node_id: Cell::new(NodeId::new(1)),\n         injected_allocator: Cell::new(None),\n         injected_panic_runtime: Cell::new(None),\n         imported_macro_spans: RefCell::new(HashMap::new()),"}, {"sha": "68c88249ec0c36b29c3d061069f116dd438b6a53", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -12,8 +12,7 @@\n \n use super::{SelectionContext, Obligation, ObligationCause};\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use infer::{InferCtxt, TypeOrigin};\n use syntax_pos::DUMMY_SP;"}, {"sha": "7ba10d9c0a58e1140d35de18d2148993014a5191", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -40,7 +40,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n-pub use self::specialize::{SpecializesCache};\n+pub use self::specialize::{SpecializesCache, find_method};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n@@ -527,6 +527,88 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     Ok(resolved_value)\n }\n \n+/// Normalizes the predicates and checks whether they hold.  If this\n+/// returns false, then either normalize encountered an error or one\n+/// of the predicates did not hold. Used when creating vtables to\n+/// check for unsatisfiable methods.\n+pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               predicates: Vec<ty::Predicate<'tcx>>)\n+                                               -> bool\n+{\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\",\n+           predicates);\n+\n+    tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let cause = ObligationCause::dummy();\n+        let Normalized { value: predicates, obligations } =\n+            normalize(&mut selcx, cause.clone(), &predicates);\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+        for predicate in predicates {\n+            let obligation = Obligation::new(cause.clone(), predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+\n+        fulfill_cx.select_all_or_error(&infcx).is_ok()\n+    })\n+}\n+\n+/// Given a trait `trait_ref`, iterates the vtable entries\n+/// that come from `trait_ref`, including its supertraits.\n+#[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+pub fn get_vtable_methods<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>)\n+    -> impl Iterator<Item=Option<(DefId, &'tcx Substs<'tcx>)>> + 'a\n+{\n+    debug!(\"get_vtable_methods({:?})\", trait_ref);\n+\n+    supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+        tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n+\n+        let trait_item_def_ids = tcx.impl_or_trait_items(trait_ref.def_id());\n+        let trait_methods = (0..trait_item_def_ids.len()).filter_map(move |i| {\n+            match tcx.impl_or_trait_item(trait_item_def_ids[i]) {\n+                ty::MethodTraitItem(m) => Some(m),\n+                _ => None\n+            }\n+        });\n+\n+        // Now list each method's DefId and Substs (for within its trait).\n+        // If the method can never be called from this object, produce None.\n+        trait_methods.map(move |trait_method| {\n+            debug!(\"get_vtable_methods: trait_method={:?}\", trait_method);\n+\n+            // Some methods cannot be called on an object; skip those.\n+            if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n+                debug!(\"get_vtable_methods: not vtable safe\");\n+                return None;\n+            }\n+\n+            // the method may have some early-bound lifetimes, add\n+            // regions for those\n+            let substs = Substs::for_item(tcx, trait_method.def_id,\n+                                            |_, _| tcx.mk_region(ty::ReErased),\n+                                            |def, _| trait_ref.substs().type_for_def(def));\n+\n+            // It's possible that the method relies on where clauses that\n+            // do not hold for this particular set of type parameters.\n+            // Note that this method could then never be called, so we\n+            // do not want to try and trans it, in that case (see #23435).\n+            let predicates = trait_method.predicates.instantiate_own(tcx, substs);\n+            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+                debug!(\"get_vtable_methods: predicates do not hold\");\n+                return None;\n+            }\n+\n+            Some((trait_method.def_id, substs))\n+        })\n+    })\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)\n@@ -571,7 +653,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n \n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: 0, code: MiscObligation }\n+        ObligationCause { span: DUMMY_SP, body_id: ast::CRATE_NODE_ID, code: MiscObligation }\n     }\n }\n "}, {"sha": "9d7131dc96cc5c31bedf67f55e5e4548288b4b01", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -814,7 +814,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         if let ImplCandidate(def_id) = candidate {\n-            if self.tcx().trait_impl_polarity(def_id) == Some(hir::ImplPolarity::Negative) {\n+            if self.tcx().trait_impl_polarity(def_id) == hir::ImplPolarity::Negative {\n                 return Err(Unimplemented)\n             }\n         }"}, {"sha": "e37425901c8c8f2dd74ae0d89cc9ce127692f9e3", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -26,9 +26,11 @@ use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause, Normalized};\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n \n+use syntax::ast;\n+\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n@@ -103,6 +105,41 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     source_substs.rebase_onto(infcx.tcx, source_impl, target_substs)\n }\n \n+/// Given a selected impl described by `impl_data`, returns the\n+/// definition and substitions for the method with the name `name`,\n+/// and trait method substitutions `substs`, in that impl, a less\n+/// specialized impl, or the trait default, whichever applies.\n+pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             name: ast::Name,\n+                             substs: &'tcx Substs<'tcx>,\n+                             impl_data: &super::VtableImplData<'tcx, ()>)\n+                             -> (DefId, &'tcx Substs<'tcx>)\n+{\n+    assert!(!substs.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    match trait_def.ancestors(impl_data.impl_def_id).fn_defs(tcx, name).next() {\n+        Some(node_item) => {\n+            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+                let substs = translate_substs(&infcx, impl_data.impl_def_id,\n+                                              substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"find_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n+            });\n+            (node_item.item.def_id, substs)\n+        }\n+        None => {\n+            bug!(\"method {:?} not found in {:?}\", name, impl_data.impl_def_id)\n+        }\n+    }\n+}\n+\n /// Is impl1 a specialization of impl2?\n ///\n /// Specialization is determined by the sets of types to which the impls apply;"}, {"sha": "1374719ef49c4875bd7eafe97a4fdd348a414a35", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 47, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell;\n use std::rc::Rc;\n \n use super::{OverlapError, specializes};\n@@ -287,21 +286,10 @@ impl<'a, 'gcx, 'tcx> Node {\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n     pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeItems<'a, 'gcx> {\n-        match *self {\n-            Node::Impl(impl_def_id) => {\n-                NodeItems::Impl {\n-                    tcx: tcx.global_tcx(),\n-                    items: cell::Ref::map(tcx.impl_items.borrow(),\n-                                          |impl_items| &impl_items[&impl_def_id]),\n-                    idx: 0,\n-                }\n-            }\n-            Node::Trait(trait_def_id) => {\n-                NodeItems::Trait {\n-                    items: tcx.trait_items(trait_def_id).clone(),\n-                    idx: 0,\n-                }\n-            }\n+        NodeItems {\n+            tcx: tcx.global_tcx(),\n+            items: tcx.impl_or_trait_items(self.def_id()),\n+            idx: 0,\n         }\n     }\n \n@@ -314,42 +302,23 @@ impl<'a, 'gcx, 'tcx> Node {\n }\n \n /// An iterator over the items defined within a trait or impl.\n-pub enum NodeItems<'a, 'tcx: 'a> {\n-    Impl {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        items: cell::Ref<'a, Vec<ty::ImplOrTraitItemId>>,\n-        idx: usize,\n-    },\n-    Trait {\n-        items: Rc<Vec<ImplOrTraitItem<'tcx>>>,\n-        idx: usize,\n-    },\n+pub struct NodeItems<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    items: Rc<Vec<DefId>>,\n+    idx: usize\n }\n \n impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n     type Item = ImplOrTraitItem<'tcx>;\n     fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n-        match *self {\n-            NodeItems::Impl { tcx, ref items, ref mut idx } => {\n-                let items_table = tcx.impl_or_trait_items.borrow();\n-                if *idx < items.len() {\n-                    let item_def_id = items[*idx].def_id();\n-                    let item = items_table[&item_def_id].clone();\n-                    *idx += 1;\n-                    Some(item)\n-                } else {\n-                    None\n-                }\n-            }\n-            NodeItems::Trait { ref items, ref mut idx } => {\n-                if *idx < items.len() {\n-                    let item = items[*idx].clone();\n-                    *idx += 1;\n-                    Some(item)\n-                } else {\n-                    None\n-                }\n-            }\n+        if self.idx < self.items.len() {\n+            let item_def_id = self.items[self.idx];\n+            let items_table = self.tcx.impl_or_trait_items.borrow();\n+            let item = items_table[&item_def_id].clone();\n+            self.idx += 1;\n+            Some(item)\n+        } else {\n+            None\n         }\n     }\n }"}, {"sha": "cfe370343ae490093682f58b15a0cc3469972184", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::Span;\n \n use hir;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum AutoAdjustment<'tcx> {\n     AdjustNeverToAny(Ty<'tcx>), // go from ! to any type\n     AdjustReifyFnPointer,       // go from a fn-item type to a fn-pointer type\n@@ -90,7 +90,7 @@ pub enum AutoAdjustment<'tcx> {\n ///     unsize: Some(Box<[i32]>),\n /// }\n /// ```\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct AutoDerefRef<'tcx> {\n     /// Step 1. Apply a number of dereferences, producing an lvalue.\n     pub autoderefs: usize,\n@@ -122,7 +122,7 @@ impl<'tcx> AutoDerefRef<'tcx> {\n }\n \n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoRef<'tcx> {\n     /// Convert from T to &T.\n     AutoPtr(&'tcx ty::Region, hir::Mutability),"}, {"sha": "d5e5f4402bb854d8d38884c94a928be0f92df168", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 90, "deletions": 62, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -13,10 +13,9 @@\n use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n use middle;\n-use middle::cstore::LOCAL_CRATE;\n use hir::TraitMap;\n use hir::def::DefMap;\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as ast_map;\n use hir::map::{DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n use middle::free_region::FreeRegionMap;\n@@ -26,7 +25,7 @@ use middle::stability;\n use ty::subst::Substs;\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n-use ty::{TyS, TypeVariants};\n+use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n@@ -93,7 +92,7 @@ pub struct CtxtInterners<'tcx> {\n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n     type_: RefCell<FnvHashSet<Interned<'tcx, TyS<'tcx>>>>,\n-    type_list: RefCell<FnvHashSet<Interned<'tcx, [Ty<'tcx>]>>>,\n+    type_list: RefCell<FnvHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FnvHashSet<Interned<'tcx, Substs<'tcx>>>>,\n     bare_fn: RefCell<FnvHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n     region: RefCell<FnvHashSet<Interned<'tcx, Region>>>,\n@@ -331,8 +330,8 @@ pub struct GlobalCtxt<'tcx> {\n     /// Maps from a trait item to the trait item \"descriptor\"\n     pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n \n-    /// Maps from a trait def-id to a list of the def-ids of its trait items\n-    pub trait_item_def_ids: RefCell<DepTrackingMap<maps::TraitItemDefIds<'tcx>>>,\n+    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+    pub impl_or_trait_item_def_ids: RefCell<DepTrackingMap<maps::ImplOrTraitItemDefIds<'tcx>>>,\n \n     /// A cache for the trait_items() routine; note that the routine\n     /// itself pushes the `TraitItems` dependency node.\n@@ -393,12 +392,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Methods in these implementations don't need to be exported.\n     pub inherent_impls: RefCell<DepTrackingMap<maps::InherentImpls<'tcx>>>,\n \n-    /// Maps a DefId of an impl to a list of its items.\n-    /// Note that this contains all of the impls that we know about,\n-    /// including ones in other crates. It's not clear that this is the best\n-    /// way to do it.\n-    pub impl_items: RefCell<DepTrackingMap<maps::ImplItems<'tcx>>>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -512,15 +505,23 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: ast::CrateNum) -> token::InternedString {\n+    pub fn crate_name(self, cnum: CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(self, cnum: ast::CrateNum) -> token::InternedString {\n+    pub fn original_crate_name(self, cnum: CrateNum) -> token::InternedString {\n+        if cnum == LOCAL_CRATE {\n+            self.crate_name.clone()\n+        } else {\n+            self.sess.cstore.original_crate_name(cnum)\n+        }\n+    }\n+\n+    pub fn crate_disambiguator(self, cnum: CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.sess.local_crate_disambiguator()\n         } else {\n@@ -533,7 +534,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// relative to `krate`.\n     ///\n     /// Returns `None` if there is no `DefIndex` with that key.\n-    pub fn def_index_for_def_key(self, krate: ast::CrateNum, key: DefKey)\n+    pub fn def_index_for_def_key(self, krate: CrateNum, key: DefKey)\n                                  -> Option<DefIndex> {\n         if krate == LOCAL_CRATE {\n             self.map.def_index_for_def_key(key)\n@@ -735,13 +736,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n             impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            impl_or_trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n             used_trait_imports: RefCell::new(NodeSet()),\n@@ -848,10 +848,11 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a [Ty<'a>] {\n-    type Lifted = &'tcx [Ty<'tcx>];\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx [Ty<'tcx>]> {\n-        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(*self) {\n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n+    type Lifted = &'tcx Slice<Ty<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<&'tcx Slice<Ty<'tcx>>> {\n+        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(&self[..]) {\n             if *self as *const _ == list as *const _ {\n                 return Some(list);\n             }\n@@ -1068,9 +1069,24 @@ impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for Interned<'tcx, TyS<'tcx>>\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, [Ty<'tcx>]> {\n+// NB: An Interned<Slice<T>> compares and hashes as its elements.\n+impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, Slice<T>> {\n+    fn eq(&self, other: &Interned<'tcx, Slice<T>>) -> bool {\n+        self.0[..] == other.0[..]\n+    }\n+}\n+\n+impl<'tcx, T: Eq> Eq for Interned<'tcx, Slice<T>> {}\n+\n+impl<'tcx, T: Hash> Hash for Interned<'tcx, Slice<T>> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.0[..].hash(s)\n+    }\n+}\n+\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n-        self.0\n+        &self.0[..]\n     }\n }\n \n@@ -1092,32 +1108,23 @@ impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n     }\n }\n \n-macro_rules! items { ($($item:item)+) => ($($item)+) }\n-macro_rules! impl_interners {\n-    ($lt_tcx:tt, $($name:ident: $method:ident($alloc:ty, $needs_infer:expr)-> $ty:ty),+) => {\n-        items!($(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n-\n-        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n-            fn hash<H: Hasher>(&self, s: &mut H) {\n-                self.0.hash(s)\n-            }\n-        }\n-\n+macro_rules! intern_method {\n+    ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n+                                            $alloc_to_key:expr,\n+                                            $alloc_to_ret:expr,\n+                                            $needs_infer:expr) -> $ty:ty) => {\n         impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n-                if let Some(i) = self.interners.$name.borrow().get::<$ty>(&v) {\n-                    return i.0;\n-                }\n-                if !self.is_global() {\n-                    if let Some(i) = self.global_interners.$name.borrow().get::<$ty>(&v) {\n+                {\n+                    let key = ($alloc_to_key)(&v);\n+                    if let Some(i) = self.interners.$name.borrow().get(key) {\n                         return i.0;\n                     }\n+                    if !self.is_global() {\n+                        if let Some(i) = self.global_interners.$name.borrow().get(key) {\n+                            return i.0;\n+                        }\n+                    }\n                 }\n \n                 // HACK(eddyb) Depend on flags being accurate to\n@@ -1128,7 +1135,7 @@ macro_rules! impl_interners {\n                         let v = unsafe {\n                             mem::transmute(v)\n                         };\n-                        let i = self.global_interners.arenas.$name.alloc(v);\n+                        let i = ($alloc_to_ret)(self.global_interners.arenas.$name.alloc(v));\n                         self.global_interners.$name.borrow_mut().insert(Interned(i));\n                         return i;\n                     }\n@@ -1142,34 +1149,59 @@ macro_rules! impl_interners {\n                     }\n                 }\n \n-                let i = self.interners.arenas.$name.alloc(v);\n+                let i = ($alloc_to_ret)(self.interners.arenas.$name.alloc(v));\n                 self.interners.$name.borrow_mut().insert(Interned(i));\n                 i\n             }\n-        })+);\n+        }\n+    }\n+}\n+\n+macro_rules! direct_interners {\n+    ($lt_tcx:tt, $($name:ident: $method:ident($needs_infer:expr) -> $ty:ty),+) => {\n+        $(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n+\n+        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n+            fn hash<H: Hasher>(&self, s: &mut H) {\n+                self.0.hash(s)\n+            }\n+        }\n+\n+        intern_method!($lt_tcx, $name: $method($ty, |x| x, |x| x, $needs_infer) -> $ty);)+\n     }\n }\n \n fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n     x.has_type_flags(ty::TypeFlags::KEEP_IN_LOCAL_TCX)\n }\n \n-impl_interners!('tcx,\n-    type_list: mk_type_list(Vec<Ty<'tcx>>, keep_local) -> [Ty<'tcx>],\n-    substs: mk_substs(Substs<'tcx>, |substs: &Substs| {\n+direct_interners!('tcx,\n+    substs: mk_substs(|substs: &Substs| {\n         substs.params().iter().any(keep_local)\n     }) -> Substs<'tcx>,\n-    bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n+    bare_fn: mk_bare_fn(|fty: &BareFnTy| {\n         keep_local(&fty.sig)\n     }) -> BareFnTy<'tcx>,\n-    region: mk_region(Region, |r| {\n+    region: mk_region(|r| {\n         match r {\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n     }) -> Region\n );\n \n+intern_method!('tcx,\n+    type_list: mk_type_list(Vec<Ty<'tcx>>, Deref::deref, |xs: &[Ty]| -> &Slice<Ty> {\n+        unsafe { mem::transmute(xs) }\n+    }, keep_local) -> Slice<Ty<'tcx>>\n+);\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n@@ -1370,23 +1402,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n         self.trait_items_cache.memoize(trait_did, || {\n-            let def_ids = self.trait_item_def_ids(trait_did);\n+            let def_ids = self.impl_or_trait_items(trait_did);\n             Rc::new(def_ids.iter()\n-                           .map(|d| self.impl_or_trait_item(d.def_id()))\n+                           .map(|&def_id| self.impl_or_trait_item(def_id))\n                            .collect())\n         })\n     }\n \n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         self.repr_hint_cache.memoize(did, || {\n-            Rc::new(if did.is_local() {\n-                self.get_attrs(did).iter().flat_map(|meta| {\n-                    attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n-                }).collect()\n-            } else {\n-                self.sess.cstore.repr_attrs(did)\n-            })\n+            Rc::new(self.get_attrs(did).iter().flat_map(|meta| {\n+                attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n+            }).collect())\n         })\n     }\n }"}, {"sha": "fdf5185eb69e2f205e3aa3d0aabe5daaa5d7e422", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use hir::map::DefPathData;\n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::parse::token;\n@@ -67,7 +66,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the \"path\" to a particular crate. This can proceed in\n     /// various ways, depending on the `root_mode` of the `buffer`.\n     /// (See `RootMode` enum for more details.)\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: ast::CrateNum)\n+    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum)\n         where T: ItemPathBuffer\n     {\n         match *buffer.root_mode() {\n@@ -102,11 +101,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             RootMode::Absolute => {\n                 // In absolute mode, just write the crate name\n                 // unconditionally.\n-                if cnum == LOCAL_CRATE {\n-                    buffer.push(&self.crate_name(cnum));\n-                } else {\n-                    buffer.push(&self.sess.cstore.original_crate_name(cnum));\n-                }\n+                buffer.push(&self.original_crate_name(cnum));\n             }\n         }\n     }\n@@ -139,7 +134,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            cur_path.push(self.sess.cstore.opt_item_name(cur_def).unwrap_or_else(||\n+            cur_path.push(self.sess.cstore.def_key(cur_def)\n+                              .disambiguated_data.data.get_opt_name().unwrap_or_else(||\n                 token::intern(\"<unnamed>\")));\n             match visible_parent_map.get(&cur_def) {\n                 Some(&def) => cur_def = def,\n@@ -304,7 +300,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the def-id of `def_id`'s parent in the def tree. If\n     /// this returns `None`, then `def_id` represents a crate root or\n     /// inlined root.\n-    fn parent_def_id(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn parent_def_id(self, def_id: DefId) -> Option<DefId> {\n         let key = self.def_key(def_id);\n         key.parent.map(|index| DefId { krate: def_id.krate, index: index })\n     }"}, {"sha": "5e7a2bc0266cfa06672b54e04e3a0ec74f38d6c4", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -367,7 +367,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: TyCtxt, hint: attr::ReprAttr, min: i64, max: i64)\n+    pub fn repr_discr(tcx: TyCtxt, ty: Ty, hint: attr::ReprAttr, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -377,11 +377,12 @@ impl Integer {\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n         let at_least = match hint {\n-            attr::ReprInt(span, ity) => {\n+            attr::ReprInt(ity) => {\n                 let discr = Integer::from_attr(&tcx.data_layout, ity);\n                 let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n                 if discr < fit {\n-                    span_bug!(span, \"representation hint insufficient for discriminant range\")\n+                    bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                          discriminant range of enum `{}\", ty)\n                 }\n                 return (discr, ity.is_signed());\n             }\n@@ -397,10 +398,10 @@ impl Integer {\n             }\n             attr::ReprAny => I8,\n             attr::ReprPacked => {\n-                bug!(\"Integer::repr_discr: found #[repr(packed)] on an enum\");\n+                bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n             }\n             attr::ReprSimd => {\n-                bug!(\"Integer::repr_discr: found #[repr(simd)] on an enum\");\n+                bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n             }\n         };\n \n@@ -962,7 +963,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, hint, min, max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -1052,7 +1053,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, hint, 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, hint, 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);"}, {"sha": "3a552a8b437d3aba15ba54929a17f4a48e95c05d", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -34,13 +34,12 @@ dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitItemId>> }\n+dep_map_ty! { ImplOrTraitItemDefIds: ImplOrTraitItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n-dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }"}, {"sha": "9eb87fa2ed43c93b6714433eeab7eea030de18b0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 107, "deletions": 212, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::ImplOrTraitItemId::*;\n pub use self::Variance::*;\n pub use self::DtorKind::*;\n pub use self::ImplOrTraitItemContainer::*;\n@@ -21,9 +20,8 @@ pub use self::fold::TypeFoldable;\n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n-use middle::cstore::{self, LOCAL_CRATE};\n use hir::def::{Def, PathResolution, ExportMap};\n-use hir::def_id::DefId;\n+use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use traits;\n@@ -34,23 +32,23 @@ use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n use util::nodemap::FnvHashMap;\n \n-use serialize::{Encodable, Encoder, Decodable, Decoder};\n+use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::hash::{Hash, Hasher};\n use std::iter;\n+use std::ops::Deref;\n use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n-use syntax::ast::{self, CrateNum, Name, NodeId};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{self, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc_const_math::ConstInt;\n \n use hir;\n-use hir::{ItemImpl, ItemTrait, PatKind};\n use hir::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n@@ -191,23 +189,11 @@ pub enum ImplOrTraitItem<'tcx> {\n }\n \n impl<'tcx> ImplOrTraitItem<'tcx> {\n-    fn id(&self) -> ImplOrTraitItemId {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => {\n-                ConstTraitItemId(associated_const.def_id)\n-            }\n-            MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n-            TypeTraitItem(ref associated_type) => {\n-                TypeTraitItemId(associated_type.def_id)\n-            }\n-        }\n-    }\n-\n     pub fn def(&self) -> Def {\n         match *self {\n             ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n             MethodTraitItem(ref method) => Def::Method(method.def_id),\n-            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.container.id(), ty.def_id),\n+            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.def_id),\n         }\n     }\n \n@@ -251,24 +237,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub enum ImplOrTraitItemId {\n-    ConstTraitItemId(DefId),\n-    MethodTraitItemId(DefId),\n-    TypeTraitItemId(DefId),\n-}\n-\n-impl ImplOrTraitItemId {\n-    pub fn def_id(&self) -> DefId {\n-        match *self {\n-            ConstTraitItemId(def_id) => def_id,\n-            MethodTraitItemId(def_id) => def_id,\n-            TypeTraitItemId(def_id) => def_id,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Copy)]\n+#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n@@ -346,34 +315,12 @@ pub struct Method<'tcx> {\n     pub explicit_self: ExplicitSelfCategory<'tcx>,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n+    pub has_body: bool,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n \n impl<'tcx> Method<'tcx> {\n-    pub fn new(name: Name,\n-               generics: &'tcx ty::Generics<'tcx>,\n-               predicates: GenericPredicates<'tcx>,\n-               fty: &'tcx BareFnTy<'tcx>,\n-               explicit_self: ExplicitSelfCategory<'tcx>,\n-               vis: Visibility,\n-               defaultness: hir::Defaultness,\n-               def_id: DefId,\n-               container: ImplOrTraitItemContainer)\n-               -> Method<'tcx> {\n-        Method {\n-            name: name,\n-            generics: generics,\n-            predicates: predicates,\n-            fty: fty,\n-            explicit_self: explicit_self,\n-            vis: vis,\n-            defaultness: defaultness,\n-            def_id: def_id,\n-            container: container,\n-        }\n-    }\n-\n     pub fn container_id(&self) -> DefId {\n         match self.container {\n             TraitContainer(id) => id,\n@@ -425,7 +372,7 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n     pub def_id: DefId,\n@@ -567,23 +514,47 @@ impl<'tcx> Hash for TyS<'tcx> {\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-impl<'tcx> Encodable for Ty<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n-            ecx.encode_ty(rbml_w, *self);\n-            Ok(())\n-        })\n+impl<'tcx> serialize::UseSpecializedEncodable for Ty<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n+\n+/// A wrapper for slices with the additioanl invariant\n+/// that the slice is interned and no other slice with\n+/// the same contents can exist in the same context.\n+/// This means we can use pointer + length for both\n+/// equality comparisons and hashing.\n+#[derive(Debug, RustcEncodable)]\n+pub struct Slice<T>([T]);\n+\n+impl<T> PartialEq for Slice<T> {\n+    #[inline]\n+    fn eq(&self, other: &Slice<T>) -> bool {\n+        (&self.0 as *const [T]) == (&other.0 as *const [T])\n     }\n }\n+impl<T> Eq for Slice<T> {}\n \n-impl<'tcx> Decodable for Ty<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Ty<'tcx>, D::Error> {\n-        cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            Ok(dcx.decode_ty(rbml_r))\n-        })\n+impl<T> Hash for Slice<T> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self.as_ptr(), self.len()).hash(s)\n     }\n }\n \n+impl<T> Deref for Slice<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        &self.0\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a Slice<T> {\n+    type Item = &'a T;\n+    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self[..].iter()\n+    }\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<Ty<'tcx>> {}\n \n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n@@ -642,7 +613,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy)]\n+#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -653,7 +624,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n+#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -684,7 +655,7 @@ pub enum IntVarValue {\n /// from `T:'a` annotations appearing in the type definition.  If\n /// this is `None`, then the default is inherited from the\n /// surrounding context. See RFC #599 for details.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum ObjectLifetimeDefault<'tcx> {\n     /// Require an explicit annotation. Occurs when multiple\n     /// `T:'a` constraints are found.\n@@ -697,7 +668,7 @@ pub enum ObjectLifetimeDefault<'tcx> {\n     Specific(&'tcx Region),\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n@@ -707,7 +678,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct RegionParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n@@ -735,7 +706,7 @@ impl<'tcx> RegionParameterDef<'tcx> {\n \n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to hir::Generics.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Generics<'tcx> {\n     pub parent: Option<DefId>,\n     pub parent_regions: u32,\n@@ -766,6 +737,9 @@ pub struct GenericPredicates<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n+impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n+\n impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n@@ -802,7 +776,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -926,7 +900,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n@@ -983,11 +957,11 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct EquatePredicate<'tcx>(pub Ty<'tcx>, pub Ty<'tcx>); // `0 == 1`\n pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<&'tcx ty::Region,\n@@ -1006,7 +980,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, &'tcx\n /// equality between arbitrary types. Processing an instance of Form\n /// #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -1496,23 +1470,13 @@ impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx> Encodable for AdtDef<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<'tcx> serialize::UseSpecializedEncodable for AdtDef<'tcx> {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.did.encode(s)\n     }\n }\n \n-impl<'tcx> Decodable for AdtDef<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<AdtDef<'tcx>, D::Error> {\n-        let def_id: DefId = Decodable::decode(d)?;\n-\n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n-            let def_id = dcx.translate_def_id(def_id);\n-            Ok(dcx.tcx().lookup_adt_def(def_id))\n-        })\n-    }\n-}\n-\n+impl<'tcx> serialize::UseSpecializedDecodable for AdtDef<'tcx> {}\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n@@ -1705,7 +1669,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n-            Def::Variant(_, vid) => self.variant_with_id(vid),\n+            Def::Variant(vid) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n@@ -1965,7 +1929,7 @@ impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n \n /// Records the substitutions used to translate the polytype for an\n /// item into the monotype of an item reference.\n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct ItemSubsts<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n@@ -2222,7 +2186,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n+                    hir::PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },\n@@ -2285,84 +2249,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            if let ItemTrait(.., ref ms) = self.map.expect_item(id).node {\n-                ms.iter().filter_map(|ti| {\n-                    if let hir::MethodTraitItem(_, Some(_)) = ti.node {\n-                        match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n-                            MethodTraitItem(m) => Some(m),\n-                            _ => {\n-                                bug!(\"provided_trait_methods(): \\\n-                                      non-method item found from \\\n-                                      looking up provided method?!\")\n-                            }\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                }).collect()\n-            } else {\n-                bug!(\"provided_trait_methods: `{:?}` is not a trait\", id)\n+        self.impl_or_trait_items(id).iter().filter_map(|&def_id| {\n+            match self.impl_or_trait_item(def_id) {\n+                MethodTraitItem(ref m) if m.has_body => Some(m.clone()),\n+                _ => None\n             }\n-        } else {\n-            self.sess.cstore.provided_trait_methods(self.global_tcx(), id)\n-        }\n+        }).collect()\n     }\n \n-    pub fn associated_consts(self, id: DefId) -> Vec<Rc<AssociatedConst<'gcx>>> {\n+    pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.expect_item(id).node {\n-                ItemTrait(.., ref tis) => {\n-                    tis.iter().filter_map(|ti| {\n-                        if let hir::ConstTraitItem(..) = ti.node {\n-                            match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n-                                ConstTraitItem(ac) => Some(ac),\n-                                _ => {\n-                                    bug!(\"associated_consts(): \\\n-                                          non-const item found from \\\n-                                          looking up a constant?!\")\n-                                }\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    }).collect()\n-                }\n-                ItemImpl(.., ref iis) => {\n-                    iis.iter().filter_map(|ii| {\n-                        if let hir::ImplItemKind::Const(..) = ii.node {\n-                            match self.impl_or_trait_item(self.map.local_def_id(ii.id)) {\n-                                ConstTraitItem(ac) => Some(ac),\n-                                _ => {\n-                                    bug!(\"associated_consts(): \\\n-                                          non-const item found from \\\n-                                          looking up a constant?!\")\n-                                }\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    }).collect()\n-                }\n-                _ => {\n-                    bug!(\"associated_consts: `{:?}` is not a trait or impl\", id)\n-                }\n-            }\n-        } else {\n-            self.sess.cstore.associated_consts(self.global_tcx(), id)\n-        }\n-    }\n-\n-    pub fn trait_impl_polarity(self, id: DefId) -> Option<hir::ImplPolarity> {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            match self.map.find(id) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    match item.node {\n-                        hir::ItemImpl(_, polarity, ..) => Some(polarity),\n-                        _ => None\n-                    }\n-                }\n-                _ => None\n+                hir::ItemImpl(_, polarity, ..) => polarity,\n+                ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n             }\n         } else {\n             self.sess.cstore.impl_polarity(id)\n@@ -2395,10 +2294,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                    .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n-    pub fn trait_item_def_ids(self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n+    pub fn impl_or_trait_items(self, id: DefId) -> Rc<Vec<DefId>> {\n         lookup_locally_or_in_crate_store(\n-            \"trait_item_def_ids\", id, &self.trait_item_def_ids,\n-            || Rc::new(self.sess.cstore.trait_item_def_ids(id)))\n+            \"impl_or_trait_items\", id, &self.impl_or_trait_item_def_ids,\n+            || Rc::new(self.sess.cstore.impl_or_trait_items(id)))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n@@ -2409,20 +2308,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n-    /// Returns whether this DefId refers to an impl\n-    pub fn is_impl(self, id: DefId) -> bool {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            if let Some(ast_map::NodeItem(\n-                &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id) {\n-                true\n-            } else {\n-                false\n-            }\n-        } else {\n-            self.sess.cstore.is_impl(id)\n-        }\n-    }\n-\n     /// Returns a path resolution for node id if it exists, panics otherwise.\n     pub fn expect_resolution(self, id: NodeId) -> PathResolution {\n         *self.def_map.borrow().get(&id).expect(\"no def-map entry for node id\")\n@@ -2443,7 +2328,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n         match def {\n-            Def::Variant(enum_did, did) => {\n+            Def::Variant(did) => {\n+                let enum_did = self.parent_def_id(did).unwrap();\n                 self.lookup_adt_def(enum_did).variant_with_id(did)\n             }\n             Def::Struct(did) | Def::Union(did) => {\n@@ -2504,8 +2390,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n+        } else if id.index == CRATE_DEF_INDEX {\n+            token::intern(&self.sess.cstore.original_crate_name(id.krate))\n         } else {\n-            self.sess.cstore.item_name(id)\n+            let def_key = self.sess.cstore.def_key(id);\n+            // The name of a StructCtor is that of its struct parent.\n+            if let ast_map::DefPathData::StructCtor = def_key.disambiguated_data.data {\n+                self.item_name(DefId {\n+                    krate: id.krate,\n+                    index: def_key.parent.unwrap()\n+                })\n+            } else {\n+                def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n+                    bug!(\"item_name: no name for {:?}\", self.def_path(id));\n+                })\n+            }\n         }\n     }\n \n@@ -2572,7 +2471,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn lookup_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"generics\", did, &self.generics,\n-            || self.sess.cstore.item_generics(self.global_tcx(), did))\n+            || self.alloc_generics(self.sess.cstore.item_generics(self.global_tcx(), did)))\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n@@ -2685,10 +2584,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n                primitive_def_id);\n \n-        let impl_items = self.sess.cstore.impl_items(primitive_def_id);\n+        let impl_items = self.sess.cstore.impl_or_trait_items(primitive_def_id);\n \n         // Store the implementation info.\n-        self.impl_items.borrow_mut().insert(primitive_def_id, impl_items);\n+        self.impl_or_trait_item_def_ids.borrow_mut().insert(primitive_def_id, Rc::new(impl_items));\n         self.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n     }\n \n@@ -2714,8 +2613,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n         for &impl_def_id in &inherent_impls {\n             // Store the implementation info.\n-            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n-            self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n+            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n+            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n@@ -2744,28 +2643,24 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.record_trait_has_default_impl(trait_id);\n         }\n \n-        for impl_def_id in self.sess.cstore.implementations_of_trait(trait_id) {\n-            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n+        for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n+            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n             // Record the trait->implementation mapping.\n-            if let Some(parent) = self.sess.cstore.impl_parent(impl_def_id) {\n-                def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-            } else {\n-                def.record_remote_impl(self, impl_def_id, trait_ref, trait_id);\n-            }\n+            let parent = self.sess.cstore.impl_parent(impl_def_id).unwrap_or(trait_id);\n+            def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n \n             // For any methods that use a default implementation, add them to\n             // the map. This is a bit unfortunate.\n-            for impl_item_def_id in &impl_items {\n-                let method_def_id = impl_item_def_id.def_id();\n+            for &impl_item_def_id in &impl_items {\n                 // load impl items eagerly for convenience\n                 // FIXME: we may want to load these lazily\n-                self.impl_or_trait_item(method_def_id);\n+                self.impl_or_trait_item(impl_item_def_id);\n             }\n \n             // Store the implementation info.\n-            self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n+            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n@@ -2854,19 +2749,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// is already that of the original trait method, then the return value is\n     /// the same).\n     /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n+    pub fn trait_item_of_item(self, def_id: DefId) -> Option<DefId> {\n         let impl_or_trait_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(m) => m.clone(),\n             None => return None,\n         };\n         match impl_or_trait_item.container() {\n-            TraitContainer(_) => Some(impl_or_trait_item.id()),\n+            TraitContainer(_) => Some(impl_or_trait_item.def_id()),\n             ImplContainer(def_id) => {\n                 self.trait_id_of_impl(def_id).and_then(|trait_did| {\n                     let name = impl_or_trait_item.name();\n                     self.trait_items(trait_did).iter()\n                         .find(|item| item.name() == name)\n-                        .map(|item| item.id())\n+                        .map(|item| item.def_id())\n                 })\n             }\n         }\n@@ -2998,7 +2893,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n /// The category of explicit self.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n+#[derive(Clone, Copy, Eq, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ExplicitSelfCategory<'tcx> {\n     Static,\n     ByValue,"}, {"sha": "5a87ea1473d982fbda294e9dc4f5e13566aa2faf", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -14,7 +14,6 @@ use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ptr::P;\n \n use hir;\n \n@@ -437,16 +436,6 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitObject {\n@@ -464,7 +453,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx [Ty<'tcx>] {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<Ty<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let tys = self.iter().map(|t| t.fold_with(folder)).collect();\n         folder.tcx().mk_type_list(tys)"}, {"sha": "302cab0446cd3178e6048f342d1b02e9ab83e14f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -10,29 +10,28 @@\n \n //! This module contains TypeVariants and its major components\n \n-use middle::cstore;\n use hir::def_id::DefId;\n use middle::region;\n use ty::subst::Substs;\n-use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TyS, TypeFoldable};\n+use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TypeFoldable};\n+use ty::{Slice, TyS};\n use util::common::ErrorReported;\n \n use collections::enum_set::{self, EnumSet, CLike};\n use std::fmt;\n-use std::mem;\n use std::ops;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::parse::token::{keywords, InternedString};\n \n-use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use serialize;\n \n use hir;\n \n use self::InferTy::*;\n use self::TypeVariants::*;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: hir::Mutability,\n@@ -88,7 +87,7 @@ pub enum Issue32330 {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum TypeVariants<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     TyBool,\n@@ -156,7 +155,7 @@ pub enum TypeVariants<'tcx> {\n     TyNever,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(&'tcx [Ty<'tcx>]),\n+    TyTuple(&'tcx Slice<Ty<'tcx>>),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n@@ -253,7 +252,7 @@ pub enum TypeVariants<'tcx> {\n /// closure C wind up influencing the decisions we ought to make for\n /// closure C (which would then require fixed point iteration to\n /// handle). Plus it fixes an ICE. :P\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function.\n     /// These are separated out because trans wants to pass them around\n@@ -263,28 +262,10 @@ pub struct ClosureSubsts<'tcx> {\n     /// The types of the upvars. The list parallels the freevars and\n     /// `upvar_borrows` lists. These are kept distinct so that we can\n     /// easily index into them.\n-    pub upvar_tys: &'tcx [Ty<'tcx>]\n+    pub upvar_tys: &'tcx Slice<Ty<'tcx>>\n }\n \n-impl<'tcx> Encodable for ClosureSubsts<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (self.func_substs, self.upvar_tys).encode(s)\n-    }\n-}\n-\n-impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<ClosureSubsts<'tcx>, D::Error> {\n-        let (func_substs, upvar_tys) = Decodable::decode(d)?;\n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n-            Ok(ClosureSubsts {\n-                func_substs: func_substs,\n-                upvar_tys: dcx.tcx().mk_type_list(upvar_tys)\n-            })\n-        })\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitObject<'tcx> {\n     pub principal: PolyExistentialTraitRef<'tcx>,\n     pub region_bound: &'tcx ty::Region,\n@@ -307,7 +288,7 @@ pub struct TraitObject<'tcx> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n /// U>` or higher-ranked object types.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -347,7 +328,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n ///\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -383,7 +364,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n@@ -431,7 +412,7 @@ impl fmt::Debug for TypeFlags {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ProjectionTy<'tcx> {\n     /// The trait reference `T as Trait<..>`.\n     pub trait_ref: ty::TraitRef<'tcx>,\n@@ -440,14 +421,16 @@ pub struct ProjectionTy<'tcx> {\n     pub item_name: Name,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct BareFnTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx BareFnTy<'tcx> {}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n@@ -460,7 +443,7 @@ pub struct ClosureTy<'tcx> {\n /// - `inputs` is the list of arguments and their modes.\n /// - `output` is the return type.\n /// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,\n     pub output: Ty<'tcx>,\n@@ -484,7 +467,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ParamTy {\n     pub idx: u32,\n     pub name: Name,\n@@ -663,32 +646,25 @@ pub enum Region {\n     ReErased,\n }\n \n-impl<'tcx> Decodable for &'tcx Region {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Region, D::Error> {\n-        let r = Decodable::decode(d)?;\n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n-            Ok(dcx.tcx().mk_region(r))\n-        })\n-    }\n-}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Region {}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n     pub index: u32,\n     pub name: Name,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TyVid {\n     pub index: u32,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct IntVid {\n     pub index: u32\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FloatVid {\n     pub index: u32\n }\n@@ -703,7 +679,7 @@ pub struct SkolemizedRegionVid {\n     pub index: u32\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n@@ -718,7 +694,7 @@ pub enum InferTy {\n }\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExistentialProjection<'tcx> {\n     pub trait_ref: ExistentialTraitRef<'tcx>,\n     pub item_name: Name,\n@@ -763,7 +739,7 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n impl<'a, 'gcx, 'tcx> BuiltinBounds {\n@@ -806,20 +782,25 @@ impl<'a> IntoIterator for &'a BuiltinBounds {\n \n #[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n            Debug, Copy)]\n-#[repr(usize)]\n pub enum BuiltinBound {\n-    Send,\n-    Sized,\n-    Copy,\n-    Sync,\n+    Send = 0,\n+    Sized = 1,\n+    Copy = 2,\n+    Sync = 3,\n }\n \n impl CLike for BuiltinBound {\n     fn to_usize(&self) -> usize {\n         *self as usize\n     }\n     fn from_usize(v: usize) -> BuiltinBound {\n-        unsafe { mem::transmute(v) }\n+        match v {\n+            0 => BuiltinBound::Send,\n+            1 => BuiltinBound::Sized,\n+            2 => BuiltinBound::Copy,\n+            3 => BuiltinBound::Sync,\n+            _ => bug!(\"{} is not a valid BuiltinBound\", v)\n+        }\n     }\n }\n "}, {"sha": "6911d2174260db022fdf256a407e0ecd2412fcbb", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -10,12 +10,11 @@\n \n // Type substitutions.\n \n-use middle::cstore;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n-use serialize::{Encodable, Encoder, Decodable, Decoder};\n+use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n \n use core::nonzero::NonZero;\n@@ -129,8 +128,40 @@ impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> Encodable for Kind<'tcx> {\n+    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        e.emit_enum(\"Kind\", |e| {\n+            if let Some(ty) = self.as_type() {\n+                e.emit_enum_variant(\"Ty\", TYPE_TAG, 1, |e| {\n+                    e.emit_enum_variant_arg(0, |e| ty.encode(e))\n+                })\n+            } else if let Some(r) = self.as_region() {\n+                e.emit_enum_variant(\"Region\", REGION_TAG, 1, |e| {\n+                    e.emit_enum_variant_arg(0, |e| r.encode(e))\n+                })\n+            } else {\n+                bug!()\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx> Decodable for Kind<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Kind<'tcx>, D::Error> {\n+        d.read_enum(\"Kind\", |d| {\n+            d.read_enum_variant(&[\"Ty\", \"Region\"], |d, tag| {\n+                match tag {\n+                    TYPE_TAG => Ty::decode(d).map(Kind::from),\n+                    REGION_TAG => <&ty::Region>::decode(d).map(Kind::from),\n+                    _ => Err(d.error(\"invalid Kind tag\"))\n+                }\n+            })\n+        })\n+    }\n+}\n+\n /// A substitution mapping type/region parameters to new values.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct Substs<'tcx> {\n     params: Vec<Kind<'tcx>>\n }\n@@ -298,25 +329,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Encodable for &'tcx Substs<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n-            ecx.encode_substs(rbml_w, self);\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error> {\n-        let substs = cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            dcx.decode_substs(rbml_r)\n-        });\n-\n-        Ok(substs)\n-    }\n-}\n-\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`"}, {"sha": "3ff2ed76e571e3a8b308657186d9a069331e57cf", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -15,7 +15,6 @@ use ty;\n use ty::fast_reject;\n use ty::{Ty, TyCtxt, TraitRef};\n use std::cell::{Cell, RefCell};\n-use syntax::ast::Name;\n use hir;\n use util::nodemap::FnvHashMap;\n \n@@ -38,10 +37,6 @@ pub struct TraitDef<'tcx> {\n \n     pub trait_ref: ty::TraitRef<'tcx>,\n \n-    /// A list of the associated types defined in this trait. Useful\n-    /// for resolving `X::Foo` type markers.\n-    pub associated_type_names: Vec<Name>,\n-\n     // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n     // simplified version of their `Self` type: impls with a simplifiable `Self`\n     // are stored in `nonblanket_impls` keyed by it, while all other impls are\n@@ -82,15 +77,13 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n                paren_sugar: bool,\n                generics: &'tcx ty::Generics<'tcx>,\n                trait_ref: ty::TraitRef<'tcx>,\n-               associated_type_names: Vec<Name>,\n                def_path_hash: u64)\n                -> TraitDef<'tcx> {\n         TraitDef {\n             paren_sugar: paren_sugar,\n             unsafety: unsafety,\n             generics: generics,\n             trait_ref: trait_ref,\n-            associated_type_names: associated_type_names,\n             nonblanket_impls: RefCell::new(FnvHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),"}, {"sha": "d834a7d485a389fb5ad7b44d52f0ee3512aa22fe", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -240,7 +240,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn enum_repr_type(self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n         match opt_hint {\n             // Feed in the given type\n-            Some(&attr::ReprInt(_, int_t)) => int_t,\n+            Some(&attr::ReprInt(int_t)) => int_t,\n             // ... but provide sensible default if none provided\n             //\n             // NB. Historically `fn enum_variants` generate i64 here, while\n@@ -352,12 +352,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n-        let mut hasher = TypeIdHasher {\n-            tcx: self,\n-            state: SipHasher::new()\n-        };\n+        let mut hasher = TypeIdHasher::new(self, SipHasher::new());\n         hasher.visit_ty(ty);\n-        hasher.state.finish()\n+        hasher.finish()\n     }\n \n     /// Returns true if this ADT is a dtorck type.\n@@ -391,16 +388,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: SipHasher\n+    state: H\n }\n \n-impl<'a, 'gcx, 'tcx> TypeIdHasher<'a, 'gcx, 'tcx> {\n-    fn hash<T: Hash>(&mut self, x: T) {\n+impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n+        TypeIdHasher {\n+            tcx: tcx,\n+            state: state\n+        }\n+    }\n+\n+    pub fn hash<T: Hash>(&mut self, x: T) {\n         x.hash(&mut self.state);\n     }\n \n+    pub fn finish(self) -> u64 {\n+        self.state.finish()\n+    }\n+\n     fn hash_discriminant_u8<T>(&mut self, x: &T) {\n         let v = unsafe {\n             intrinsics::discriminant_value(x)\n@@ -419,7 +427,7 @@ impl<'a, 'gcx, 'tcx> TypeIdHasher<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         // Distinguish between the Ty variants uniformly.\n         self.hash_discriminant_u8(&ty.sty);\n@@ -428,17 +436,18 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n             TyInt(i) => self.hash(i),\n             TyUint(u) => self.hash(u),\n             TyFloat(f) => self.hash(f),\n-            TyAdt(d, _) => self.def_id(d.did),\n             TyArray(_, n) => self.hash(n),\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n             TyAnon(def_id, _) |\n             TyFnDef(def_id, ..) => self.def_id(def_id),\n+            TyAdt(d, _) => self.def_id(d.did),\n             TyFnPtr(f) => {\n                 self.hash(f.unsafety);\n                 self.hash(f.abi);\n                 self.hash(f.sig.variadic());\n+                self.hash(f.sig.inputs().skip_binder().len());\n             }\n             TyTrait(ref data) => {\n                 self.def_id(data.principal.def_id());\n@@ -460,32 +469,34 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n             TyChar |\n             TyStr |\n             TyBox(_) |\n-            TySlice(_) |\n-            TyError => {}\n-            TyInfer(_) => bug!()\n+            TySlice(_) => {}\n+\n+            TyError |\n+            TyInfer(_) => bug!(\"TypeIdHasher: unexpected type {}\", ty)\n         }\n \n         ty.super_visit_with(self)\n     }\n \n     fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         match *r {\n-            ty::ReStatic | ty::ReErased => {\n+            ty::ReErased => {\n                 self.hash::<u32>(0);\n             }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 assert!(db.depth > 0);\n                 self.hash::<u32>(db.depth);\n                 self.hash(i);\n             }\n+            ty::ReStatic |\n             ty::ReEmpty |\n             ty::ReEarlyBound(..) |\n             ty::ReLateBound(..) |\n             ty::ReFree(..) |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) => {\n-                bug!(\"unexpected region found when hashing a type\")\n+                bug!(\"TypeIdHasher: unexpected region {:?}\", r)\n             }\n         }\n         false"}, {"sha": "1df0cf2d5cdf6b299f5af6c6506644747d432aaa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -920,7 +920,8 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(substs.upvar_tys) {\n-                            let node_id = freevar.def.var_id();\n+                            let def_id = freevar.def.def_id();\n+                            let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n                             write!(f,\n                                         \"{}{}:{}\",\n                                         sep,"}, {"sha": "f7ae47d2e5e56efac5e5707f4cc1c47ef43b2d2e", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -46,7 +46,6 @@ extern crate serialize;\n #[macro_use] extern crate log;\n \n pub mod tempdir;\n-pub mod rpath;\n pub mod sha2;\n pub mod target;\n pub mod slice;"}, {"sha": "eb74936d8c905380625a63e630a06f6a24934631", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 73, "deletions": 69, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -26,8 +26,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::hir::pat_util::*;\n use rustc::traits::Reveal;\n-use rustc::ty::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty, TyCtxt};\n use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n@@ -40,11 +39,10 @@ use rustc_back::slice;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n use syntax::codemap::Spanned;\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n+use syntax::util::move_map::MoveMap;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n@@ -111,7 +109,7 @@ impl<'a, 'tcx> FromIterator<Vec<(&'a Pat, Option<Ty<'tcx>>)>> for Matrix<'a, 'tc\n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub param_env: ParameterEnvironment<'tcx>,\n+    pub param_env: ty::ParameterEnvironment<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -182,7 +180,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 }\n             }\n \n-            let mut static_inliner = StaticInliner::new(cx.tcx, None);\n+            let mut static_inliner = StaticInliner::new(cx.tcx);\n             let inlined_arms = arms.iter().map(|arm| {\n                 (arm.pats.iter().map(|pat| {\n                     static_inliner.fold_pat((*pat).clone())\n@@ -249,7 +247,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                 if edef.is_enum() {\n                     if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n                         if edef.variants.iter().any(|variant| {\n-                            variant.name == name.node && variant.kind == VariantKind::Unit\n+                            variant.name == name.node && variant.kind == ty::VariantKind::Unit\n                         }) {\n                             let ty_path = cx.tcx.item_path_str(edef.did);\n                             let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n@@ -460,94 +458,100 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n         _ => bug!()\n     };\n     P(hir::Expr {\n-        id: 0,\n+        id: DUMMY_NODE_ID,\n         node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP,\n         attrs: ast::ThinVec::new(),\n     })\n }\n \n-pub struct StaticInliner<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub failed: bool,\n-    pub renaming_map: Option<&'a mut FnvHashMap<(NodeId, Span), NodeId>>,\n+struct StaticInliner<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    failed: bool\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                   renaming_map: Option<&'b mut FnvHashMap<(NodeId, Span), NodeId>>)\n-                   -> StaticInliner<'b, 'tcx> {\n+    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>) -> StaticInliner<'b, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n-            failed: false,\n-            renaming_map: renaming_map\n+            failed: false\n         }\n     }\n }\n \n-struct RenamingRecorder<'map> {\n-    substituted_node_id: NodeId,\n-    origin_span: Span,\n-    renaming_map: &'map mut FnvHashMap<(NodeId, Span), NodeId>\n-}\n-\n-impl<'v, 'map> Visitor<'v> for RenamingRecorder<'map> {\n-    fn visit_id(&mut self, node_id: NodeId) {\n-        let key = (node_id, self.origin_span);\n-        self.renaming_map.insert(key, self.substituted_node_id);\n-    }\n-}\n-\n-impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n+impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n-        return match pat.node {\n+        match pat.node {\n             PatKind::Path(..) => {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::AssociatedConst(did) | Def::Const(did) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n-                                Ok(new_pat) => {\n-                                    if let Some(ref mut map) = self.renaming_map {\n-                                        // Record any renamings we do here\n-                                        record_renamings(const_expr, &pat, map);\n-                                    }\n-                                    new_pat\n-                                }\n+                                Ok(new_pat) => return new_pat,\n                                 Err(def_id) => {\n                                     self.failed = true;\n                                     self.tcx.sess.span_err(\n                                         pat.span,\n                                         &format!(\"constants of the type `{}` \\\n                                                   cannot be used in patterns\",\n                                                  self.tcx.item_path_str(def_id)));\n-                                    pat\n                                 }\n                             }\n                         } else {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n                                 \"statics cannot be referenced in patterns\");\n-                            pat\n                         }\n                     }\n-                    _ => noop_fold_pat(pat, self)\n+                    _ => {}\n                 }\n             }\n-            _ => noop_fold_pat(pat, self)\n-        };\n+            _ => {}\n+        }\n \n-        fn record_renamings(const_expr: &hir::Expr,\n-                            substituted_pat: &hir::Pat,\n-                            renaming_map: &mut FnvHashMap<(NodeId, Span), NodeId>) {\n-            let mut renaming_recorder = RenamingRecorder {\n-                substituted_node_id: substituted_pat.id,\n-                origin_span: substituted_pat.span,\n-                renaming_map: renaming_map,\n+        pat.map(|Pat { id, node, span }| {\n+            let node = match node {\n+                PatKind::Binding(binding_mode, pth1, sub) => {\n+                    PatKind::Binding(binding_mode, pth1, sub.map(|x| self.fold_pat(x)))\n+                }\n+                PatKind::TupleStruct(pth, pats, ddpos) => {\n+                    PatKind::TupleStruct(pth, pats.move_map(|x| self.fold_pat(x)), ddpos)\n+                }\n+                PatKind::Struct(pth, fields, etc) => {\n+                    let fs = fields.move_map(|f| {\n+                        Spanned {\n+                            span: f.span,\n+                            node: hir::FieldPat {\n+                                name: f.node.name,\n+                                pat: self.fold_pat(f.node.pat),\n+                                is_shorthand: f.node.is_shorthand,\n+                            },\n+                        }\n+                    });\n+                    PatKind::Struct(pth, fs, etc)\n+                }\n+                PatKind::Tuple(elts, ddpos) => {\n+                    PatKind::Tuple(elts.move_map(|x| self.fold_pat(x)), ddpos)\n+                }\n+                PatKind::Box(inner) => PatKind::Box(self.fold_pat(inner)),\n+                PatKind::Ref(inner, mutbl) => PatKind::Ref(self.fold_pat(inner), mutbl),\n+                PatKind::Vec(before, slice, after) => {\n+                    PatKind::Vec(before.move_map(|x| self.fold_pat(x)),\n+                                 slice.map(|x| self.fold_pat(x)),\n+                                 after.move_map(|x| self.fold_pat(x)))\n+                }\n+                PatKind::Wild |\n+                PatKind::Lit(_) |\n+                PatKind::Range(..) |\n+                PatKind::Path(..) => node\n             };\n-\n-            renaming_recorder.visit_expr(const_expr);\n-        }\n+            Pat {\n+                id: id,\n+                node: node,\n+                span: span\n+            }\n+        })\n     }\n }\n \n@@ -574,7 +578,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n         ty::TyAdt(adt, _) => {\n             let v = ctor.variant_for_adt(adt);\n             match v.kind {\n-                VariantKind::Struct => {\n+                ty::VariantKind::Struct => {\n                     let field_pats: hir::HirVec<_> = v.fields.iter()\n                         .zip(pats)\n                         .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n@@ -589,10 +593,10 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     let has_more_fields = field_pats.len() < pats_len;\n                     PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n                 }\n-                VariantKind::Tuple => {\n+                ty::VariantKind::Tuple => {\n                     PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n                 }\n-                VariantKind::Unit => {\n+                ty::VariantKind::Unit => {\n                     PatKind::Path(None, def_to_path(cx.tcx, v.did))\n                 }\n             }\n@@ -625,7 +629,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     };\n \n     P(hir::Pat {\n-        id: 0,\n+        id: DUMMY_NODE_ID,\n         node: pat,\n         span: DUMMY_SP\n     })\n@@ -634,7 +638,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n impl Constructor {\n     fn variant_for_adt<'tcx, 'container, 'a>(&self,\n                                              adt: &'a ty::AdtDefData<'tcx, 'container>)\n-                                             -> &'a VariantDefData<'tcx, 'container> {\n+                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n         match self {\n             &Variant(vid) => adt.variant_with_id(vid),\n             _ => adt.struct_variant()\n@@ -797,7 +801,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n-                Def::Variant(_, id) => vec![Variant(id)],\n+                Def::Variant(id) => vec![Variant(id)],\n                 Def::Struct(..) | Def::Union(..) |\n                 Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n@@ -873,7 +877,7 @@ fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n     let pat_ty = cx.tcx.pat_ty(pat);\n     (pat, Some(match pat.node {\n         PatKind::Binding(hir::BindByRef(..), ..) => {\n-            pat_ty.builtin_deref(false, NoPreference).unwrap().ty\n+            pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n         }\n         _ => pat_ty\n     }))\n@@ -909,7 +913,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n                 def => span_bug!(pat_span, \"specialize: unexpected \\\n                                           definition {:?}\", def),\n@@ -921,7 +925,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => {\n                     match ddpos {\n                         Some(ddpos) => {\n@@ -1047,7 +1051,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n     intravisit::walk_local(cx, loc);\n \n-    let pat = StaticInliner::new(cx.tcx, None).fold_pat(loc.pat.clone());\n+    let pat = StaticInliner::new(cx.tcx).fold_pat(loc.pat.clone());\n     check_irrefutable(cx, &pat, false);\n \n     // Check legality of move bindings and `@` patterns.\n@@ -1063,7 +1067,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             fn_id: NodeId) {\n     match kind {\n         FnKind::Closure(_) => {}\n-        _ => cx.param_env = ParameterEnvironment::for_item(cx.tcx, fn_id),\n+        _ => cx.param_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_id),\n     }\n \n     intravisit::walk_fn(cx, kind, decl, body, sp, fn_id);\n@@ -1182,17 +1186,17 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n               _: NodeId,\n               span: Span,\n               _: cmt,\n-              _: &'tcx Region,\n-              kind: BorrowKind,\n+              _: &'tcx ty::Region,\n+              kind:ty:: BorrowKind,\n               _: LoanCause) {\n         match kind {\n-            MutBorrow => {\n+            ty::MutBorrow => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0301,\n                           \"cannot mutably borrow in a pattern guard\")\n                     .span_label(span, &format!(\"borrowed mutably in pattern guard\"))\n                     .emit();\n             }\n-            ImmBorrow | UniqueImmBorrow => {}\n+            ty::ImmBorrow | ty::UniqueImmBorrow => {}\n         }\n     }\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}"}, {"sha": "dce3882004c6740ebbbe5d9ee0f9967f4c5a4439", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -57,7 +57,6 @@ macro_rules! math {\n }\n \n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  enum_def: DefId,\n                                   variant_def: DefId)\n                                   -> Option<&'tcx Expr> {\n     fn variant_expr<'a>(variants: &'a [hir::Variant], id: ast::NodeId)\n@@ -70,8 +69,8 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         None\n     }\n \n-    if let Some(enum_node_id) = tcx.map.as_local_node_id(enum_def) {\n-        let variant_node_id = tcx.map.as_local_node_id(variant_def).unwrap();\n+    if let Some(variant_node_id) = tcx.map.as_local_node_id(variant_def) {\n+        let enum_node_id = tcx.map.get_parent(variant_node_id);\n         match tcx.map.find(enum_node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n@@ -289,7 +288,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             let path = match def {\n                 Def::Struct(def_id) => def_to_path(tcx, def_id),\n-                Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n+                Def::Variant(variant_did) => def_to_path(tcx, variant_did),\n                 Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n                     id: expr.id,\n                     node: PatKind::Lit(P(expr.clone())),\n@@ -808,8 +807,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Variant(enum_def, variant_def) => {\n-                  if let Some(const_expr) = lookup_variant_by_id(tcx, enum_def, variant_def) {\n+              Def::Variant(variant_def) => {\n+                  if let Some(const_expr) = lookup_variant_by_id(tcx, variant_def) {\n                       match eval_const_expr_partial(tcx, const_expr, ty_hint, None) {\n                           Ok(val) => val,\n                           Err(err) => {\n@@ -824,7 +823,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Def::Struct(..) => {\n                   ConstVal::Struct(e.id)\n               }\n-              Def::Local(_, id) => {\n+              Def::Local(def_id) => {\n+                  let id = tcx.map.as_local_node_id(def_id).unwrap();\n                   debug!(\"Def::Local({:?}): {:?}\", id, fn_args);\n                   if let Some(val) = fn_args.and_then(|args| args.get(&id)) {\n                       val.clone()\n@@ -1079,8 +1079,14 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n-                match tcx.associated_consts(impl_data.impl_def_id)\n-                        .iter().find(|ic| ic.name == ti.name) {\n+                let ac = tcx.impl_or_trait_items(impl_data.impl_def_id)\n+                    .iter().filter_map(|&def_id| {\n+                        match tcx.impl_or_trait_item(def_id) {\n+                            ty::ConstTraitItem(ic) => Some(ic),\n+                            _ => None\n+                        }\n+                    }).find(|ic| ic.name == ti.name);\n+                match ac {\n                     Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                     None => match ti.node {\n                         hir::ConstTraitItem(ref ty, Some(ref expr)) => {"}, {"sha": "215287f84399c1d9e079c8ac09bc6326e5d99ed1", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -539,6 +539,7 @@ impl FromStr for UserIdentifiedItem {\n     type Err = ();\n     fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n         Ok(s.parse()\n+            .map(ast::NodeId::new)\n             .map(ItemViaNode)\n             .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n     }"}, {"sha": "f6772b8771844526844b125f35a575bc00d17633", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -166,16 +166,17 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn create_simple_region_hierarchy(&self) {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n+\n+        let node = ast::NodeId::from_u32;\n         let dscope = self.infcx\n                          .tcx\n                          .region_maps\n-                         .intern_code_extent(CodeExtentData::DestructionScope(1),\n+                         .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n                                              region::ROOT_CODE_EXTENT);\n         self.create_region_hierarchy(&RH {\n-                                         id: 1,\n-                                         sub: &[RH { id: 10, sub: &[] }, RH { id: 11, sub: &[] }],\n-                                     },\n-                                     dscope);\n+            id: node(1),\n+            sub: &[RH { id: node(10), sub: &[] }, RH { id: node(11), sub: &[] }],\n+        }, dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -315,8 +316,8 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n-    pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        let r = ty::ReScope(self.tcx().region_maps.node_extent(id));\n+    pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n+        let r = ty::ReScope(self.tcx().region_maps.node_extent(ast::NodeId::from_u32(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n@@ -327,8 +328,8 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         }))\n     }\n \n-    pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n-        let r = self.re_free(nid, id);\n+    pub fn t_rptr_free(&self, nid: u32, id: u32) -> Ty<'tcx> {\n+        let r = self.re_free(ast::NodeId::from_u32(nid), id);\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n "}, {"sha": "e3ee7527545042211481ecf9d36f6e228c23f0bc", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -10,10 +10,9 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n-rbml = { path = \"../librbml\" }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n serialize = { path = \"../libserialize\" }\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "9950f470a82c486fe78cf642af52d74db257509d", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -602,7 +602,6 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             // def-id is the same, so it suffices to hash the def-id\n             Def::Fn(..) |\n             Def::Mod(..) |\n-            Def::ForeignMod(..) |\n             Def::Static(..) |\n             Def::Variant(..) |\n             Def::Enum(..) |"}, {"sha": "42b5657e212b02be11d3c9938372368c286e5f97", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -27,7 +27,6 @@\n #![feature(core_intrinsics)]\n \n extern crate graphviz;\n-extern crate rbml;\n #[macro_use] extern crate rustc;\n extern crate rustc_data_structures;\n extern crate serialize as rustc_serialize;"}, {"sha": "cca364f442d599001b61cceb7fab3ffbc72cd54d", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -15,13 +15,11 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map::DefPath;\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::cstore::LOCAL_CRATE;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::nodemap::DefIdMap;\n use std::fmt::{self, Debug};\n use std::iter::once;\n-use syntax::ast;\n \n /// Index into the DefIdDirectory\n #[derive(Copy, Clone, Debug, PartialOrd, Ord, Hash, PartialEq, Eq,\n@@ -43,7 +41,7 @@ pub struct DefIdDirectory {\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct CrateInfo {\n-    krate: ast::CrateNum,\n+    krate: CrateNum,\n     name: String,\n     disambiguator: String,\n }\n@@ -53,7 +51,7 @@ impl DefIdDirectory {\n         DefIdDirectory { paths: vec![], krates: krates }\n     }\n \n-    fn max_current_crate(&self, tcx: TyCtxt) -> ast::CrateNum {\n+    fn max_current_crate(&self, tcx: TyCtxt) -> CrateNum {\n         tcx.sess.cstore.crates()\n                        .into_iter()\n                        .max()\n@@ -72,16 +70,16 @@ impl DefIdDirectory {\n \n     pub fn krate_still_valid(&self,\n                              tcx: TyCtxt,\n-                             max_current_crate: ast::CrateNum,\n-                             krate: ast::CrateNum) -> bool {\n+                             max_current_crate: CrateNum,\n+                             krate: CrateNum) -> bool {\n         // Check that the crate-number still matches. For now, if it\n         // doesn't, just return None. We could do better, such as\n         // finding the new number.\n \n         if krate > max_current_crate {\n             false\n         } else {\n-            let old_info = &self.krates[krate as usize];\n+            let old_info = &self.krates[krate.as_usize()];\n             assert_eq!(old_info.krate, krate);\n             let old_name: &str = &old_info.name;\n             let old_disambiguator: &str = &old_info.disambiguator;\n@@ -101,7 +99,7 @@ impl DefIdDirectory {\n                                 } else {\n                                     debug!(\"crate {} changed from {:?} to {:?}/{:?}\",\n                                            path.krate,\n-                                           self.krates[path.krate as usize],\n+                                           self.krates[path.krate.as_usize()],\n                                            tcx.crate_name(path.krate),\n                                            tcx.crate_disambiguator(path.krate));\n                                     None"}, {"sha": "c9cfaf4f6613fd6a59490b8d571477bbbe05e7ec", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -114,8 +114,8 @@\n //! unsupported file system and emit a warning in that case. This is not yet\n //! implemented.\n \n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n@@ -129,7 +129,6 @@ use std::mem;\n use std::path::{Path, PathBuf};\n use std::time::{UNIX_EPOCH, SystemTime, Duration};\n use std::__rand::{thread_rng, Rng};\n-use syntax::ast;\n \n const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n@@ -580,7 +579,7 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n     Ok(UNIX_EPOCH + duration)\n }\n \n-fn crate_path_tcx(tcx: TyCtxt, cnum: ast::CrateNum) -> PathBuf {\n+fn crate_path_tcx(tcx: TyCtxt, cnum: CrateNum) -> PathBuf {\n     crate_path(tcx.sess, &tcx.crate_name(cnum), &tcx.crate_disambiguator(cnum))\n }\n \n@@ -592,7 +591,7 @@ fn crate_path_tcx(tcx: TyCtxt, cnum: ast::CrateNum) -> PathBuf {\n /// crate's (name, disambiguator) pair. The metadata hashes are only valid for\n /// the exact version of the binary we are reading from now (i.e. the hashes\n /// are part of the dependency graph of a specific compilation session).\n-pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: ast::CrateNum) -> Option<PathBuf> {\n+pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf> {\n     let crate_directory = crate_path_tcx(tcx, cnum);\n \n     if !crate_directory.exists() {"}, {"sha": "5a4716e45f6e1f9ae6af39fe04ac38394bae6cc0", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rbml::Error;\n-use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::svh::Svh;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n+use rustc_serialize::opaque::Decoder;\n use std::io::{ErrorKind, Read};\n use std::fs::File;\n-use syntax::ast;\n \n use IncrementalHashesMap;\n use super::data::*;\n@@ -29,7 +27,7 @@ pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n     item_metadata_hashes: FnvHashMap<DefId, u64>,\n-    crate_hashes: FnvHashMap<ast::CrateNum, Svh>,\n+    crate_hashes: FnvHashMap<CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n@@ -121,7 +119,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    fn load_data(&mut self, cnum: ast::CrateNum) {\n+    fn load_data(&mut self, cnum: CrateNum) {\n         debug!(\"load_data(cnum={})\", cnum);\n \n         let svh = self.tcx.sess.cstore.crate_hash(cnum);\n@@ -187,9 +185,9 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n     }\n \n     fn load_from_data(&mut self,\n-                      cnum: ast::CrateNum,\n+                      cnum: CrateNum,\n                       data: &[u8],\n-                      expected_svh: Svh) -> Result<(), Error> {\n+                      expected_svh: Svh) -> Result<(), String> {\n         debug!(\"load_from_data(cnum={})\", cnum);\n \n         // Load up the hashes for the def-ids from this crate."}, {"sha": "b051e6c5ab73a1f759d061c1b6049b43f2216895", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -10,14 +10,13 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use rbml::Error;\n-use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashSet;\n use rustc_serialize::Decodable as RustcDecodable;\n+use rustc_serialize::opaque::Decoder;\n use std::io::Read;\n use std::fs::{self, File};\n use std::path::{Path};\n@@ -121,7 +120,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   incremental_hashes_map: &IncrementalHashesMap,\n                                   dep_graph_data: &[u8],\n                                   work_products_data: &[u8])\n-                                  -> Result<(), Error>\n+                                  -> Result<(), String>\n {\n     // Decode the list of work_products\n     let mut work_product_decoder = Decoder::new(work_products_data, 0);"}, {"sha": "5b45874840f5676fec5c559e4dd5b86badc00def", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_serialize::Encodable as RustcEncodable;\n+use rustc_serialize::opaque::Encoder;\n use std::hash::{Hash, Hasher, SipHasher};\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};"}, {"sha": "1209ced8dd3d75ffd0d4fc45c67363267194ebd3", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -92,7 +92,7 @@ pub struct TypeLimits {\n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n         TypeLimits {\n-            negated_expr_id: !0,\n+            negated_expr_id: ast::DUMMY_NODE_ID,\n         }\n     }\n }"}, {"sha": "680d55955bb96a928beb606c0986ea0a91155767", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -11,10 +11,8 @@ crate-type = [\"dylib\"]\n [dependencies]\n flate = { path = \"../libflate\" }\n log = { path = \"../liblog\" }\n-rbml = { path = \"../librbml\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "c9dbedacbc1a5a3a85cb40e72960aa4422d8ee93", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 101, "deletions": 1319, "changes": 1420, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,1369 +8,151 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-// FIXME: remove this after snapshot, and Results are handled\n-#![allow(unused_must_use)]\n-\n use rustc::hir::map as ast_map;\n-use rustc::session::Session;\n \n-use rustc::hir;\n-use rustc::hir::fold;\n-use rustc::hir::fold::Folder;\n use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange};\n \n-use common as c;\n-use cstore;\n-use decoder;\n-use encoder as e;\n-use tydecode;\n-use tyencode;\n+use cstore::CrateMetadata;\n+use encoder::EncodeContext;\n+use schema::*;\n \n-use middle::cstore::{InlinedItem, InlinedItemRef};\n-use rustc::ty::adjustment;\n-use rustc::ty::cast;\n-use middle::const_qualif::ConstQualif;\n+use rustc::middle::cstore::{InlinedItem, InlinedItemRef};\n+use rustc::middle::const_qualif::ConstQualif;\n use rustc::hir::def::{self, Def};\n use rustc::hir::def_id::DefId;\n-use middle::region;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty};\n \n use syntax::ast;\n-use syntax::ptr::P;\n-use syntax_pos;\n-\n-use std::cell::Cell;\n-use std::io::SeekFrom;\n-use std::io::prelude::*;\n-use std::fmt::Debug;\n-\n-use rbml::reader;\n-use rbml::writer::Encoder;\n-use rbml;\n-use rustc_serialize as serialize;\n-use rustc_serialize::{Decodable, Decoder, DecoderHelpers};\n-use rustc_serialize::{Encodable, EncoderHelpers};\n-\n-#[cfg(test)] use std::io::Cursor;\n-#[cfg(test)] use syntax::parse;\n-#[cfg(test)] use rustc::hir::print as pprust;\n-#[cfg(test)] use rustc::hir::lowering::{LoweringContext, DummyResolver};\n-\n-struct DecodeContext<'a, 'b, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cdata: &'b cstore::CrateMetadata,\n-    from_id_range: IdRange,\n-    to_id_range: IdRange,\n-    // Cache the last used filemap for translating spans as an optimization.\n-    last_filemap_index: Cell<usize>,\n-}\n-\n-trait tr {\n-    fn tr(&self, dcx: &DecodeContext) -> Self;\n-}\n-\n-// ______________________________________________________________________\n-// Top-level methods.\n-\n-pub fn encode_inlined_item(ecx: &e::EncodeContext,\n-                           rbml_w: &mut Encoder,\n-                           ii: InlinedItemRef) {\n-    let id = match ii {\n-        InlinedItemRef::Item(_, i) => i.id,\n-        InlinedItemRef::TraitItem(_, ti) => ti.id,\n-        InlinedItemRef::ImplItem(_, ii) => ii.id,\n-    };\n-    debug!(\"> Encoding inlined item: {} ({:?})\",\n-           ecx.tcx.node_path_str(id),\n-           rbml_w.writer.seek(SeekFrom::Current(0)));\n-\n-    // Folding could be avoided with a smarter encoder.\n-    let (ii, expected_id_range) = simplify_ast(ii);\n-    let id_range = inlined_item_id_range(&ii);\n-    assert_eq!(expected_id_range, id_range);\n-\n-    rbml_w.start_tag(c::tag_ast as usize);\n-    id_range.encode(rbml_w);\n-    encode_ast(rbml_w, &ii);\n-    encode_side_tables_for_ii(ecx, rbml_w, &ii);\n-    rbml_w.end_tag();\n-\n-    debug!(\"< Encoded inlined fn: {} ({:?})\",\n-           ecx.tcx.node_path_str(id),\n-           rbml_w.writer.seek(SeekFrom::Current(0)));\n-}\n-\n-impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n-    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n-        if id == ast::DUMMY_NODE_ID {\n-            // Used by ast_map to map the NodeInlinedParent.\n-            self.tcx.sess.next_node_id()\n-        } else {\n-            self.tr_id(id)\n-        }\n-    }\n-    fn new_def_id(&self, def_id: DefId) -> DefId {\n-        self.tr_def_id(def_id)\n-    }\n-    fn new_span(&self, span: syntax_pos::Span) -> syntax_pos::Span {\n-        self.tr_span(span)\n-    }\n-}\n-\n-/// Decodes an item from its AST in the cdata's metadata and adds it to the\n-/// ast-map.\n-pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     parent_def_path: ast_map::DefPath,\n-                                     parent_did: DefId,\n-                                     ast_doc: rbml::Doc,\n-                                     orig_did: DefId)\n-                                     -> &'tcx InlinedItem {\n-    debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n-    let mut ast_dsr = reader::Decoder::new(ast_doc);\n-    let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n-    let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n-    let dcx = &DecodeContext {\n-        cdata: cdata,\n-        tcx: tcx,\n-        from_id_range: from_id_range,\n-        to_id_range: to_id_range,\n-        last_filemap_index: Cell::new(0)\n-    };\n-    let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n-                                       parent_def_path,\n-                                       parent_did,\n-                                       decode_ast(ast_doc),\n-                                       dcx);\n-    let name = match *ii {\n-        InlinedItem::Item(_, ref i) => i.name,\n-        InlinedItem::TraitItem(_, ref ti) => ti.name,\n-        InlinedItem::ImplItem(_, ref ii) => ii.name\n-    };\n-    debug!(\"Fn named: {}\", name);\n-    debug!(\"< Decoded inlined fn: {}::{}\",\n-            tcx.item_path_str(parent_did),\n-            name);\n-    region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n-    decode_side_tables(dcx, ast_doc);\n-    copy_item_types(dcx, ii, orig_did);\n-    if let InlinedItem::Item(_, ref i) = *ii {\n-        debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-               ::rustc::hir::print::item_to_string(&i));\n-    }\n-\n-    ii\n-}\n-\n-// ______________________________________________________________________\n-// Enumerating the IDs which appear in an AST\n-\n-fn reserve_id_range(sess: &Session,\n-                    from_id_range: IdRange) -> IdRange {\n-    // Handle the case of an empty range:\n-    if from_id_range.empty() { return from_id_range; }\n-    let cnt = from_id_range.max - from_id_range.min;\n-    let to_id_min = sess.reserve_node_ids(cnt);\n-    let to_id_max = to_id_min + cnt;\n-    IdRange { min: to_id_min, max: to_id_max }\n-}\n-\n-impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n-    /// Translates an internal id, meaning a node id that is known to refer to some part of the\n-    /// item currently being inlined, such as a local variable or argument.  All naked node-ids\n-    /// that appear in types have this property, since if something might refer to an external item\n-    /// we would use a def-id to allow for the possibility that the item resides in another crate.\n-    pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n-        // from_id_range should be non-empty\n-        assert!(!self.from_id_range.empty());\n-        // Make sure that translating the NodeId will actually yield a\n-        // meaningful result\n-        assert!(self.from_id_range.contains(id));\n-\n-        // Use wrapping arithmetic because otherwise it introduces control flow.\n-        // Maybe we should just have the control flow? -- aatch\n-        (id.wrapping_sub(self.from_id_range.min).wrapping_add(self.to_id_range.min))\n-    }\n-\n-    /// Translates an EXTERNAL def-id, converting the crate number from the one used in the encoded\n-    /// data to the current crate numbers..  By external, I mean that it be translated to a\n-    /// reference to the item in its original crate, as opposed to being translated to a reference\n-    /// to the inlined version of the item.  This is typically, but not always, what you want,\n-    /// because most def-ids refer to external things like types or other fns that may or may not\n-    /// be inlined.  Note that even when the inlined function is referencing itself recursively, we\n-    /// would want `tr_def_id` for that reference--- conceptually the function calls the original,\n-    /// non-inlined version, and trans deals with linking that recursive call to the inlined copy.\n-    pub fn tr_def_id(&self, did: DefId) -> DefId {\n-        decoder::translate_def_id(self.cdata, did)\n-    }\n-\n-    /// Translates a `Span` from an extern crate to the corresponding `Span`\n-    /// within the local crate's codemap.\n-    pub fn tr_span(&self, span: syntax_pos::Span) -> syntax_pos::Span {\n-        decoder::translate_span(self.cdata,\n-                                self.tcx.sess.codemap(),\n-                                &self.last_filemap_index,\n-                                span)\n-    }\n-}\n-\n-impl tr for DefId {\n-    fn tr(&self, dcx: &DecodeContext) -> DefId {\n-        dcx.tr_def_id(*self)\n-    }\n-}\n-\n-impl tr for Option<DefId> {\n-    fn tr(&self, dcx: &DecodeContext) -> Option<DefId> {\n-        self.map(|d| dcx.tr_def_id(d))\n-    }\n-}\n-\n-impl tr for syntax_pos::Span {\n-    fn tr(&self, dcx: &DecodeContext) -> syntax_pos::Span {\n-        dcx.tr_span(*self)\n-    }\n-}\n-\n-trait def_id_encoder_helpers {\n-    fn emit_def_id(&mut self, did: DefId);\n-}\n-\n-impl<S:serialize::Encoder> def_id_encoder_helpers for S\n-    where <S as serialize::Encoder>::Error: Debug\n-{\n-    fn emit_def_id(&mut self, did: DefId) {\n-        did.encode(self).unwrap()\n-    }\n-}\n-\n-trait def_id_decoder_helpers {\n-    fn read_def_id(&mut self, dcx: &DecodeContext) -> DefId;\n-    fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::CrateMetadata) -> DefId;\n-}\n-\n-impl<D:serialize::Decoder> def_id_decoder_helpers for D\n-    where <D as serialize::Decoder>::Error: Debug\n-{\n-    fn read_def_id(&mut self, dcx: &DecodeContext) -> DefId {\n-        let did: DefId = Decodable::decode(self).unwrap();\n-        did.tr(dcx)\n-    }\n-\n-    fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::CrateMetadata)\n-                         -> DefId {\n-        let did: DefId = Decodable::decode(self).unwrap();\n-        decoder::translate_def_id(cdata, did)\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding the AST itself\n-//\n-// When decoding, we have to renumber the AST so that the node ids that\n-// appear within are disjoint from the node ids in our existing ASTs.\n-// We also have to adjust the spans: for now we just insert a dummy span,\n-// but eventually we should add entries to the local codemap as required.\n-\n-fn encode_ast(rbml_w: &mut Encoder, item: &InlinedItem) {\n-    rbml_w.start_tag(c::tag_tree as usize);\n-    rbml_w.emit_opaque(|this| item.encode(this));\n-    rbml_w.end_tag();\n-}\n-\n-struct NestedItemsDropper {\n-    id_range: IdRange\n-}\n-\n-impl Folder for NestedItemsDropper {\n-\n-    // The unit tests below run on HIR with NodeIds not properly assigned. That\n-    // causes an integer overflow. So we just don't track the id_range when\n-    // building the unit tests.\n-    #[cfg(not(test))]\n-    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n-        // Record the range of NodeIds we are visiting, so we can do a sanity\n-        // check later\n-        self.id_range.add(id);\n-        id\n-    }\n-\n-    fn fold_block(&mut self, blk: P<hir::Block>) -> P<hir::Block> {\n-        blk.and_then(|hir::Block {id, stmts, expr, rules, span, ..}| {\n-            let stmts_sans_items = stmts.into_iter().filter_map(|stmt| {\n-                let use_stmt = match stmt.node {\n-                    hir::StmtExpr(..) | hir::StmtSemi(..) => true,\n-                    hir::StmtDecl(ref decl, _) => {\n-                        match decl.node {\n-                            hir::DeclLocal(_) => true,\n-                            hir::DeclItem(_) => false,\n-                        }\n-                    }\n-                };\n-                if use_stmt {\n-                    Some(stmt)\n-                } else {\n-                    None\n-                }\n-            }).collect();\n-            let blk_sans_items = P(hir::Block {\n-                stmts: stmts_sans_items,\n-                expr: expr,\n-                id: id,\n-                rules: rules,\n-                span: span,\n-            });\n-            fold::noop_fold_block(blk_sans_items, self)\n-        })\n-    }\n-}\n-\n-// Produces a simplified copy of the AST which does not include things\n-// that we do not need to or do not want to export.  For example, we\n-// do not include any nested items: if these nested items are to be\n-// inlined, their AST will be exported separately (this only makes\n-// sense because, in Rust, nested items are independent except for\n-// their visibility).\n-//\n-// As it happens, trans relies on the fact that we do not export\n-// nested items, as otherwise it would get confused when translating\n-// inlined items.\n-fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n-    let mut fld = NestedItemsDropper {\n-        id_range: IdRange::max()\n-    };\n-\n-    let ii = match ii {\n-        // HACK we're not dropping items.\n-        InlinedItemRef::Item(d, i) => {\n-            InlinedItem::Item(d, P(fold::noop_fold_item(i.clone(), &mut fld)))\n-        }\n-        InlinedItemRef::TraitItem(d, ti) => {\n-            InlinedItem::TraitItem(d, P(fold::noop_fold_trait_item(ti.clone(), &mut fld)))\n-        }\n-        InlinedItemRef::ImplItem(d, ii) => {\n-            InlinedItem::ImplItem(d, P(fold::noop_fold_impl_item(ii.clone(), &mut fld)))\n-        }\n-    };\n-\n-    (ii, fld.id_range)\n-}\n-\n-fn decode_ast(item_doc: rbml::Doc) -> InlinedItem {\n-    let chi_doc = item_doc.get(c::tag_tree as usize);\n-    let mut rbml_r = reader::Decoder::new(chi_doc);\n-    rbml_r.read_opaque(|decoder, _| Decodable::decode(decoder)).unwrap()\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of ast::def\n-\n-fn decode_def(dcx: &DecodeContext, dsr: &mut reader::Decoder) -> Def {\n-    let def: Def = Decodable::decode(dsr).unwrap();\n-    def.tr(dcx)\n-}\n-\n-impl tr for Def {\n-    fn tr(&self, dcx: &DecodeContext) -> Def {\n-        match *self {\n-          Def::Fn(did) => Def::Fn(did.tr(dcx)),\n-          Def::Method(did) => Def::Method(did.tr(dcx)),\n-          Def::SelfTy(opt_did, impl_id) => {\n-              // Since the impl_id will never lie within the reserved range of\n-              // imported NodeIds, it does not make sense to translate it.\n-              // The result would not make any sense within the importing crate.\n-              // We also don't allow for impl items to be inlined (just their\n-              // members), so even if we had a DefId here, we wouldn't be able\n-              // to do much with it.\n-              // So, we set the id to DUMMY_NODE_ID. That way we make it\n-              // explicit that this is no usable NodeId.\n-              Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n-                          impl_id.map(|_| ast::DUMMY_NODE_ID))\n-          }\n-          Def::Mod(did) => { Def::Mod(did.tr(dcx)) }\n-          Def::ForeignMod(did) => { Def::ForeignMod(did.tr(dcx)) }\n-          Def::Static(did, m) => { Def::Static(did.tr(dcx), m) }\n-          Def::Const(did) => { Def::Const(did.tr(dcx)) }\n-          Def::AssociatedConst(did) => Def::AssociatedConst(did.tr(dcx)),\n-          Def::Local(_, nid) => {\n-              let nid = dcx.tr_id(nid);\n-              let did = dcx.tcx.map.local_def_id(nid);\n-              Def::Local(did, nid)\n-          }\n-          Def::Variant(e_did, v_did) => Def::Variant(e_did.tr(dcx), v_did.tr(dcx)),\n-          Def::Trait(did) => Def::Trait(did.tr(dcx)),\n-          Def::Enum(did) => Def::Enum(did.tr(dcx)),\n-          Def::TyAlias(did) => Def::TyAlias(did.tr(dcx)),\n-          Def::AssociatedTy(trait_did, did) =>\n-              Def::AssociatedTy(trait_did.tr(dcx), did.tr(dcx)),\n-          Def::PrimTy(p) => Def::PrimTy(p),\n-          Def::TyParam(did) => Def::TyParam(did.tr(dcx)),\n-          Def::Upvar(_, nid1, index, nid2) => {\n-              let nid1 = dcx.tr_id(nid1);\n-              let nid2 = dcx.tr_id(nid2);\n-              let did1 = dcx.tcx.map.local_def_id(nid1);\n-              Def::Upvar(did1, nid1, index, nid2)\n-          }\n-          Def::Struct(did) => Def::Struct(did.tr(dcx)),\n-          Def::Union(did) => Def::Union(did.tr(dcx)),\n-          Def::Label(nid) => Def::Label(dcx.tr_id(nid)),\n-          Def::Err => Def::Err,\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of freevar information\n-\n-fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &hir::Freevar) {\n-    (*fv).encode(rbml_w).unwrap();\n-}\n-\n-trait rbml_decoder_helper {\n-    fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> hir::Freevar;\n-    fn read_capture_mode(&mut self) -> hir::CaptureClause;\n-}\n-\n-impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n-    fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> hir::Freevar {\n-        let fv: hir::Freevar = Decodable::decode(self).unwrap();\n-        fv.tr(dcx)\n-    }\n-\n-    fn read_capture_mode(&mut self) -> hir::CaptureClause {\n-        let cm: hir::CaptureClause = Decodable::decode(self).unwrap();\n-        cm\n-    }\n-}\n-\n-impl tr for hir::Freevar {\n-    fn tr(&self, dcx: &DecodeContext) -> hir::Freevar {\n-        hir::Freevar {\n-            def: self.def.tr(dcx),\n-            span: self.span.tr(dcx),\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of MethodCallee\n-\n-trait read_method_callee_helper<'tcx> {\n-    fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                  -> (u32, ty::MethodCallee<'tcx>);\n-}\n-\n-fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n-                                  rbml_w: &mut Encoder,\n-                                  autoderef: u32,\n-                                  method: &ty::MethodCallee<'tcx>) {\n-    use rustc_serialize::Encoder;\n-\n-    rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n-        rbml_w.emit_struct_field(\"autoderef\", 0, |rbml_w| {\n-            autoderef.encode(rbml_w)\n-        });\n-        rbml_w.emit_struct_field(\"def_id\", 1, |rbml_w| {\n-            Ok(rbml_w.emit_def_id(method.def_id))\n-        });\n-        rbml_w.emit_struct_field(\"ty\", 2, |rbml_w| {\n-            Ok(rbml_w.emit_ty(ecx, method.ty))\n-        });\n-        rbml_w.emit_struct_field(\"substs\", 3, |rbml_w| {\n-            Ok(rbml_w.emit_substs(ecx, &method.substs))\n-        })\n-    }).unwrap();\n-}\n-\n-impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n-    fn read_method_callee<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                  -> (u32, ty::MethodCallee<'tcx>) {\n-\n-        self.read_struct(\"MethodCallee\", 4, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0,\n-                                                   Decodable::decode).unwrap();\n-            Ok((autoderef, ty::MethodCallee {\n-                def_id: this.read_struct_field(\"def_id\", 1, |this| {\n-                    Ok(this.read_def_id(dcx))\n-                }).unwrap(),\n-                ty: this.read_struct_field(\"ty\", 2, |this| {\n-                    Ok(this.read_ty(dcx))\n-                }).unwrap(),\n-                substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(this.read_substs(dcx))\n-                }).unwrap()\n-            }))\n-        }).unwrap()\n-    }\n-}\n-\n-pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n-    kind.encode(ebml_w).unwrap();\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding the side tables\n-\n-trait rbml_writer_helpers<'tcx> {\n-    fn emit_region(&mut self, ecx: &e::EncodeContext, r: &'tcx ty::Region);\n-    fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n-    fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                       substs: &Substs<'tcx>);\n-    fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture);\n-    fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                                adj: &adjustment::AutoAdjustment<'tcx>);\n-    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                        autoref: &adjustment::AutoRef<'tcx>);\n-    fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                               auto_deref_ref: &adjustment::AutoDerefRef<'tcx>);\n-}\n-\n-impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n-    fn emit_region(&mut self, ecx: &e::EncodeContext, r: &'tcx ty::Region) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_region(&mut this.cursor,\n-                                                        &ecx.ty_str_ctxt(),\n-                                                        r)));\n-    }\n-\n-    fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_ty(&mut this.cursor,\n-                                                    &ecx.ty_str_ctxt(),\n-                                                    ty)));\n-    }\n-\n-    fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_enum(\"UpvarCapture\", |this| {\n-            match *capture {\n-                ty::UpvarCapture::ByValue => {\n-                    this.emit_enum_variant(\"ByValue\", 1, 0, |_| Ok(()))\n-                }\n-                ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind, region }) => {\n-                    this.emit_enum_variant(\"ByRef\", 2, 0, |this| {\n-                        this.emit_enum_variant_arg(0,\n-                            |this| kind.encode(this));\n-                        this.emit_enum_variant_arg(1,\n-                            |this| Ok(this.emit_region(ecx, region)))\n-                    })\n-                }\n-            }\n-        }).unwrap()\n-    }\n-\n-    fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                       substs: &Substs<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_substs(&mut this.cursor,\n-                                                        &ecx.ty_str_ctxt(),\n-                                                        substs)));\n-    }\n-\n-    fn emit_auto_adjustment<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                                adj: &adjustment::AutoAdjustment<'tcx>) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_enum(\"AutoAdjustment\", |this| {\n-            match *adj {\n-                adjustment::AdjustReifyFnPointer => {\n-                    this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 0, |_| Ok(()))\n-                }\n-\n-                adjustment::AdjustUnsafeFnPointer => {\n-                    this.emit_enum_variant(\"AdjustUnsafeFnPointer\", 2, 0, |_| {\n-                        Ok(())\n-                    })\n-                }\n-\n-                adjustment::AdjustMutToConstPointer => {\n-                    this.emit_enum_variant(\"AdjustMutToConstPointer\", 3, 0, |_| {\n-                        Ok(())\n-                    })\n-                }\n-\n-                adjustment::AdjustDerefRef(ref auto_deref_ref) => {\n-                    this.emit_enum_variant(\"AdjustDerefRef\", 4, 2, |this| {\n-                        this.emit_enum_variant_arg(0,\n-                            |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n-                    })\n-                }\n \n-                adjustment::AdjustNeverToAny(ref ty) => {\n-                    this.emit_enum_variant(\"AdjustNeverToAny\", 5, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_ty(ecx, ty)))\n-                    })\n-                }\n-            }\n-        });\n-    }\n-\n-    fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                        autoref: &adjustment::AutoRef<'tcx>) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_enum(\"AutoRef\", |this| {\n-            match autoref {\n-                &adjustment::AutoPtr(r, m) => {\n-                    this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n-                        this.emit_enum_variant_arg(0,\n-                            |this| Ok(this.emit_region(ecx, r)));\n-                        this.emit_enum_variant_arg(1, |this| m.encode(this))\n-                    })\n-                }\n-                &adjustment::AutoUnsafe(m) => {\n-                    this.emit_enum_variant(\"AutoUnsafe\", 1, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| m.encode(this))\n-                    })\n-                }\n-            }\n-        });\n-    }\n-\n-    fn emit_auto_deref_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                               auto_deref_ref: &adjustment::AutoDerefRef<'tcx>) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_struct(\"AutoDerefRef\", 2, |this| {\n-            this.emit_struct_field(\"autoderefs\", 0, |this| auto_deref_ref.autoderefs.encode(this));\n+use rustc_serialize::Encodable;\n \n-            this.emit_struct_field(\"autoref\", 1, |this| {\n-                this.emit_option(|this| {\n-                    match auto_deref_ref.autoref {\n-                        None => this.emit_option_none(),\n-                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a))),\n-                    }\n-                })\n-            });\n-\n-            this.emit_struct_field(\"unsize\", 2, |this| {\n-                this.emit_option(|this| {\n-                    match auto_deref_ref.unsize {\n-                        None => this.emit_option_none(),\n-                        Some(target) => this.emit_option_some(|this| {\n-                            Ok(this.emit_ty(ecx, target))\n-                        })\n-                    }\n-                })\n-            })\n-        });\n-    }\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Ast<'tcx> {\n+    id_range: IdRange,\n+    item: Lazy<InlinedItem>,\n+    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>\n }\n \n-trait write_tag_and_id {\n-    fn tag<F>(&mut self, tag_id: c::astencode_tag, f: F) where F: FnOnce(&mut Self);\n-    fn id(&mut self, id: ast::NodeId);\n+#[derive(RustcEncodable, RustcDecodable)]\n+enum TableEntry<'tcx> {\n+    Def(Def),\n+    NodeType(Ty<'tcx>),\n+    ItemSubsts(ty::ItemSubsts<'tcx>),\n+    Adjustment(ty::adjustment::AutoAdjustment<'tcx>),\n+    ConstQualif(ConstQualif)\n }\n \n-impl<'a> write_tag_and_id for Encoder<'a> {\n-    fn tag<F>(&mut self,\n-              tag_id: c::astencode_tag,\n-              f: F) where\n-        F: FnOnce(&mut Encoder<'a>),\n-    {\n-        self.start_tag(tag_id as usize);\n-        f(self);\n-        self.end_tag();\n-    }\n-\n-    fn id(&mut self, id: ast::NodeId) {\n-        id.encode(self).unwrap();\n-    }\n-}\n-\n-struct SideTableEncodingIdVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n-    ecx: &'a e::EncodeContext<'c, 'tcx>,\n-    rbml_w: &'a mut Encoder<'b>,\n-}\n-\n-impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for\n-        SideTableEncodingIdVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_id(&mut self, id: ast::NodeId) {\n-        encode_side_tables_for_id(self.ecx, self.rbml_w, id)\n-    }\n-}\n-\n-fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n-                             rbml_w: &mut Encoder,\n-                             ii: &InlinedItem) {\n-    rbml_w.start_tag(c::tag_table as usize);\n-    ii.visit(&mut SideTableEncodingIdVisitor {\n-        ecx: ecx,\n-        rbml_w: rbml_w\n-    });\n-    rbml_w.end_tag();\n-}\n-\n-fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n-                             rbml_w: &mut Encoder,\n-                             id: ast::NodeId) {\n-    let tcx = ecx.tcx;\n-\n-    debug!(\"Encoding side tables for id {}\", id);\n-\n-    if let Some(def) = tcx.expect_def_or_none(id) {\n-        rbml_w.tag(c::tag_table_def, |rbml_w| {\n-            rbml_w.id(id);\n-            def.encode(rbml_w).unwrap();\n-        })\n-    }\n-\n-    if let Some(ty) = tcx.node_types().get(&id) {\n-        rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_ty(ecx, *ty);\n-        })\n-    }\n-\n-    if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n-        rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_substs(ecx, &item_substs.substs);\n-        })\n-    }\n-\n-    if let Some(fv) = tcx.freevars.borrow().get(&id) {\n-        rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_from_vec(fv, |rbml_w, fv_entry| {\n-                Ok(encode_freevar_entry(rbml_w, fv_entry))\n-            });\n-        });\n-\n-        for freevar in fv {\n-            rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n-                rbml_w.id(id);\n-\n-                let var_id = freevar.def.var_id();\n-                let upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: id\n-                };\n-                let upvar_capture = tcx.tables\n-                                       .borrow()\n-                                       .upvar_capture_map\n-                                       .get(&upvar_id)\n-                                       .unwrap()\n-                                       .clone();\n-                var_id.encode(rbml_w);\n-                rbml_w.emit_upvar_capture(ecx, &upvar_capture);\n-            })\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+    pub fn encode_inlined_item(&mut self, ii: InlinedItemRef) -> Lazy<Ast<'tcx>> {\n+        let mut id_visitor = IdRangeComputingVisitor::new();\n+        match ii {\n+            InlinedItemRef::Item(_, i) => id_visitor.visit_item(i),\n+            InlinedItemRef::TraitItem(_, ti) => id_visitor.visit_trait_item(ti),\n+            InlinedItemRef::ImplItem(_, ii) => id_visitor.visit_impl_item(ii)\n         }\n-    }\n \n-    let method_call = ty::MethodCall::expr(id);\n-    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n-        rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n-            rbml_w.id(id);\n-            encode_method_callee(ecx, rbml_w, method_call.autoderef, method)\n-        })\n-    }\n-\n-    if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n-        match *adjustment {\n-            adjustment::AdjustDerefRef(ref adj) => {\n-                for autoderef in 0..adj.autoderefs {\n-                    let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n-                    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n-                        rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n-                            rbml_w.id(id);\n-                            encode_method_callee(ecx, rbml_w,\n-                                                 method_call.autoderef, method)\n-                        })\n-                    }\n-                }\n+        let ii_pos = self.position();\n+        ii.encode(self).unwrap();\n+\n+        let tables_pos = self.position();\n+        let tables_count = {\n+            let mut visitor = SideTableEncodingIdVisitor {\n+                ecx: self,\n+                count: 0\n+            };\n+            match ii {\n+                InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n+                InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n+                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n             }\n-            _ => {}\n-        }\n-\n-        rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_auto_adjustment(ecx, adjustment);\n-        })\n-    }\n-\n-    if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {\n-        rbml_w.tag(c::tag_table_cast_kinds, |rbml_w| {\n-            rbml_w.id(id);\n-            encode_cast_kind(rbml_w, *cast_kind)\n-        })\n-    }\n+            visitor.count\n+        };\n \n-    if let Some(qualif) = tcx.const_qualif_map.borrow().get(&id) {\n-        rbml_w.tag(c::tag_table_const_qualif, |rbml_w| {\n-            rbml_w.id(id);\n-            qualif.encode(rbml_w).unwrap()\n+        self.lazy(&Ast {\n+            id_range: id_visitor.result(),\n+            item: Lazy::with_position(ii_pos),\n+            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count)\n         })\n     }\n }\n \n-trait doc_decoder_helpers: Sized {\n-    fn as_int(&self) -> isize;\n-    fn opt_child(&self, tag: c::astencode_tag) -> Option<Self>;\n+struct SideTableEncodingIdVisitor<'a, 'b:'a, 'tcx:'b> {\n+    ecx: &'a mut EncodeContext<'b, 'tcx>,\n+    count: usize\n }\n \n-impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n-    fn as_int(&self) -> isize { reader::doc_as_u64(*self) as isize }\n-    fn opt_child(&self, tag: c::astencode_tag) -> Option<rbml::Doc<'a>> {\n-        reader::maybe_get_doc(*self, tag as usize)\n-    }\n-}\n-\n-trait rbml_decoder_decoder_helpers<'tcx> {\n-    fn read_ty_encoded<'a, 'b, F, R>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>,\n-                                     f: F) -> R\n-        where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x, 'tcx>) -> R;\n-\n-    fn read_region<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> &'tcx ty::Region;\n-    fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n-    fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n-    fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                              -> ty::TraitRef<'tcx>;\n-    fn read_poly_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                   -> ty::PolyTraitRef<'tcx>;\n-    fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                              -> ty::Predicate<'tcx>;\n-    fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                           -> &'tcx Substs<'tcx>;\n-    fn read_upvar_capture<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                  -> ty::UpvarCapture<'tcx>;\n-    fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                    -> adjustment::AutoAdjustment<'tcx>;\n-    fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                 -> cast::CastKind;\n-    fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                   -> adjustment::AutoDerefRef<'tcx>;\n-    fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                            -> adjustment::AutoRef<'tcx>;\n-\n-    // Versions of the type reading functions that don't need the full\n-    // DecodeContext.\n-    fn read_ty_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         cdata: &cstore::CrateMetadata) -> Ty<'tcx>;\n-    fn read_tys_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>>;\n-    fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             cdata: &cstore::CrateMetadata)\n-                             -> &'tcx Substs<'tcx>;\n-}\n-\n-impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n-    fn read_ty_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                         cdata: &cstore::CrateMetadata)\n-                         -> Ty<'tcx> {\n-        self.read_opaque(|_, doc| {\n-            Ok(\n-                tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                                              &mut |id| decoder::translate_def_id(cdata, id))\n-                    .parse_ty())\n-        }).unwrap()\n-    }\n-\n-    fn read_tys_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                          cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>> {\n-        self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n-            .unwrap()\n-            .into_iter()\n-            .collect()\n-    }\n-\n-    fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                             cdata: &cstore::CrateMetadata)\n-                             -> &'tcx Substs<'tcx>\n-    {\n-        self.read_opaque(|_, doc| {\n-            Ok(\n-                tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                                              &mut |id| decoder::translate_def_id(cdata, id))\n-                    .parse_substs())\n-        }).unwrap()\n-    }\n-\n-    fn read_ty_encoded<'b, 'c, F, R>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>, op: F) -> R\n-        where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x,'tcx>) -> R\n-    {\n-        return self.read_opaque(|_, doc| {\n-            debug!(\"read_ty_encoded({})\", type_string(doc));\n-            Ok(op(\n-                &mut tydecode::TyDecoder::with_doc(\n-                    dcx.tcx, dcx.cdata.cnum, doc,\n-                    &mut |d| convert_def_id(dcx, d))))\n-        }).unwrap();\n+impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n+    fn visit_id(&mut self, id: ast::NodeId) {\n+        debug!(\"Encoding side tables for id {}\", id);\n \n-        fn type_string(doc: rbml::Doc) -> String {\n-            let mut str = String::new();\n-            for i in doc.start..doc.end {\n-                str.push(doc.data[i] as char);\n+        let tcx = self.ecx.tcx;\n+        let mut encode = |entry: Option<TableEntry>| {\n+            if let Some(entry) = entry {\n+                (id, entry).encode(self.ecx).unwrap();\n+                self.count += 1;\n             }\n-            str\n-        }\n-    }\n-    fn read_region<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> &'tcx ty::Region {\n-        // Note: regions types embed local node ids.  In principle, we\n-        // should translate these node ids into the new decode\n-        // context.  However, we do not bother, because region types\n-        // are not used during trans. This also applies to read_ty.\n-        return self.read_ty_encoded(dcx, |decoder| decoder.parse_region());\n-    }\n-    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n-        return self.read_ty_encoded(dcx, |decoder| decoder.parse_ty());\n-    }\n+        };\n \n-    fn read_tys<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                        -> Vec<Ty<'tcx>> {\n-        self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().into_iter().collect()\n-    }\n-\n-    fn read_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                              -> ty::TraitRef<'tcx> {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_trait_ref())\n-    }\n-\n-    fn read_poly_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                   -> ty::PolyTraitRef<'tcx> {\n-        ty::Binder(self.read_ty_encoded(dcx, |decoder| decoder.parse_trait_ref()))\n-    }\n-\n-    fn read_predicate<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                              -> ty::Predicate<'tcx>\n-    {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_predicate())\n-    }\n-\n-    fn read_substs<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                           -> &'tcx Substs<'tcx> {\n-        self.read_opaque(|_, doc| {\n-            Ok(tydecode::TyDecoder::with_doc(dcx.tcx, dcx.cdata.cnum, doc,\n-                                             &mut |d| convert_def_id(dcx, d))\n-               .parse_substs())\n-        }).unwrap()\n-    }\n-    fn read_upvar_capture<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                  -> ty::UpvarCapture<'tcx> {\n-        self.read_enum(\"UpvarCapture\", |this| {\n-            let variants = [\"ByValue\", \"ByRef\"];\n-            this.read_enum_variant(&variants, |this, i| {\n-                Ok(match i {\n-                    1 => ty::UpvarCapture::ByValue,\n-                    2 => ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                        kind: this.read_enum_variant_arg(0,\n-                                  |this| Decodable::decode(this)).unwrap(),\n-                        region: this.read_enum_variant_arg(1,\n-                                    |this| Ok(this.read_region(dcx))).unwrap()\n-                    }),\n-                    _ => bug!(\"bad enum variant for ty::UpvarCapture\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-    fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                    -> adjustment::AutoAdjustment<'tcx> {\n-        self.read_enum(\"AutoAdjustment\", |this| {\n-            let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\",\n-                            \"AdjustMutToConstPointer\", \"AdjustDerefRef\",\n-                            \"AdjustNeverToAny\"];\n-            this.read_enum_variant(&variants, |this, i| {\n-                Ok(match i {\n-                    1 => adjustment::AdjustReifyFnPointer,\n-                    2 => adjustment::AdjustUnsafeFnPointer,\n-                    3 => adjustment::AdjustMutToConstPointer,\n-                    4 => {\n-                        let auto_deref_ref: adjustment::AutoDerefRef =\n-                            this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n-\n-                        adjustment::AdjustDerefRef(auto_deref_ref)\n-                    }\n-                    5 => {\n-                        let ty: Ty<'tcx> = this.read_enum_variant_arg(0, |this| {\n-                            Ok(this.read_ty(dcx))\n-                        }).unwrap();\n-\n-                        adjustment::AdjustNeverToAny(ty)\n-                    }\n-                    _ => bug!(\"bad enum variant for adjustment::AutoAdjustment\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-\n-    fn read_auto_deref_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                   -> adjustment::AutoDerefRef<'tcx> {\n-        self.read_struct(\"AutoDerefRef\", 2, |this| {\n-            Ok(adjustment::AutoDerefRef {\n-                autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n-                    Decodable::decode(this)\n-                }).unwrap(),\n-                autoref: this.read_struct_field(\"autoref\", 1, |this| {\n-                    this.read_option(|this, b| {\n-                        if b {\n-                            Ok(Some(this.read_autoref(dcx)))\n-                        } else {\n-                            Ok(None)\n-                        }\n-                    })\n-                }).unwrap(),\n-                unsize: this.read_struct_field(\"unsize\", 2, |this| {\n-                    this.read_option(|this, b| {\n-                        if b {\n-                            Ok(Some(this.read_ty(dcx)))\n-                        } else {\n-                            Ok(None)\n-                        }\n-                    })\n-                }).unwrap(),\n-            })\n-        }).unwrap()\n-    }\n-\n-    fn read_autoref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                            -> adjustment::AutoRef<'tcx> {\n-        self.read_enum(\"AutoRef\", |this| {\n-            let variants = [\"AutoPtr\", \"AutoUnsafe\"];\n-            this.read_enum_variant(&variants, |this, i| {\n-                Ok(match i {\n-                    0 => {\n-                        let r: &'tcx ty::Region =\n-                            this.read_enum_variant_arg(0, |this| {\n-                                Ok(this.read_region(dcx))\n-                            }).unwrap();\n-                        let m: hir::Mutability =\n-                            this.read_enum_variant_arg(1, |this| {\n-                                Decodable::decode(this)\n-                            }).unwrap();\n-\n-                        adjustment::AutoPtr(r, m)\n-                    }\n-                    1 => {\n-                        let m: hir::Mutability =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-\n-                        adjustment::AutoUnsafe(m)\n-                    }\n-                    _ => bug!(\"bad enum variant for adjustment::AutoRef\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-\n-    fn read_cast_kind<'b, 'c>(&mut self, _dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                              -> cast::CastKind\n-    {\n-        Decodable::decode(self).unwrap()\n+        encode(tcx.expect_def_or_none(id).map(TableEntry::Def));\n+        encode(tcx.node_types().get(&id).cloned().map(TableEntry::NodeType));\n+        encode(tcx.tables.borrow().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n+        encode(tcx.tables.borrow().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n+        encode(tcx.const_qualif_map.borrow().get(&id).cloned().map(TableEntry::ConstQualif));\n     }\n }\n \n-// Converts a def-id that appears in a type.  The correct\n-// translation will depend on what kind of def-id this is.\n-// This is a subtle point: type definitions are not\n-// inlined into the current crate, so if the def-id names\n-// a nominal type or type alias, then it should be\n-// translated to refer to the source crate.\n-//\n-// However, *type parameters* are cloned along with the function\n-// they are attached to.  So we should translate those def-ids\n-// to refer to the new, cloned copy of the type parameter.\n-// We only see references to free type parameters in the body of\n-// an inlined function. In such cases, we need the def-id to\n-// be a local id so that the TypeContents code is able to lookup\n-// the relevant info in the ty_param_defs table.\n-//\n-// *Region parameters*, unfortunately, are another kettle of fish.\n-// In such cases, def_id's can appear in types to distinguish\n-// shadowed bound regions and so forth. It doesn't actually\n-// matter so much what we do to these, since regions are erased\n-// at trans time, but it's good to keep them consistent just in\n-// case. We translate them with `tr_def_id()` which will map\n-// the crate numbers back to the original source crate.\n-//\n-// Scopes will end up as being totally bogus. This can actually\n-// be fixed though.\n-//\n-// Unboxed closures are cloned along with the function being\n-// inlined, and all side tables use interned node IDs, so we\n-// translate their def IDs accordingly.\n-//\n-// It'd be really nice to refactor the type repr to not include\n-// def-ids so that all these distinctions were unnecessary.\n-fn convert_def_id(dcx: &DecodeContext,\n-                  did: DefId)\n-                  -> DefId {\n-    let r = dcx.tr_def_id(did);\n-    debug!(\"convert_def_id(did={:?})={:?}\", did, r);\n-    return r;\n-}\n-\n-fn decode_side_tables(dcx: &DecodeContext,\n-                      ast_doc: rbml::Doc) {\n-    let tbl_doc = ast_doc.get(c::tag_table as usize);\n-    for (tag, entry_doc) in reader::docs(tbl_doc) {\n-        let mut entry_dsr = reader::Decoder::new(entry_doc);\n-        let id0: ast::NodeId = Decodable::decode(&mut entry_dsr).unwrap();\n-        let id = dcx.tr_id(id0);\n-\n-        debug!(\">> Side table document with tag 0x{:x} \\\n-                found for id {} (orig {})\",\n-               tag, id, id0);\n-        let tag = tag as u32;\n-        let decoded_tag: Option<c::astencode_tag> = c::astencode_tag::from_u32(tag);\n-        match decoded_tag {\n-            None => {\n-                bug!(\"unknown tag found in side tables: {:x}\", tag);\n-            }\n-            Some(value) => {\n-                let val_dsr = &mut entry_dsr;\n-\n-                match value {\n-                    c::tag_table_def => {\n-                        let def = decode_def(dcx, val_dsr);\n-                        dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n-                    }\n-                    c::tag_table_node_type => {\n-                        let ty = val_dsr.read_ty(dcx);\n-                        debug!(\"inserting ty for node {}: {:?}\",\n-                               id,  ty);\n-                        dcx.tcx.node_type_insert(id, ty);\n-                    }\n-                    c::tag_table_item_subst => {\n-                        let item_substs = ty::ItemSubsts {\n-                            substs: val_dsr.read_substs(dcx)\n-                        };\n-                        dcx.tcx.tables.borrow_mut().item_substs.insert(\n-                            id, item_substs);\n-                    }\n-                    c::tag_table_freevars => {\n-                        let fv_info = val_dsr.read_to_vec(|val_dsr| {\n-                            Ok(val_dsr.read_freevar_entry(dcx))\n-                        }).unwrap().into_iter().collect();\n-                        dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n-                    }\n-                    c::tag_table_upvar_capture_map => {\n-                        let var_id: ast::NodeId = Decodable::decode(val_dsr).unwrap();\n-                        let upvar_id = ty::UpvarId {\n-                            var_id: dcx.tr_id(var_id),\n-                            closure_expr_id: id\n-                        };\n-                        let ub = val_dsr.read_upvar_capture(dcx);\n-                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n-                    }\n-                    c::tag_table_method_map => {\n-                        let (autoderef, method) = val_dsr.read_method_callee(dcx);\n-                        let method_call = ty::MethodCall {\n-                            expr_id: id,\n-                            autoderef: autoderef\n-                        };\n-                        dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n-                    }\n-                    c::tag_table_adjustments => {\n-                        let adj =\n-                            val_dsr.read_auto_adjustment(dcx);\n-                        dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n-                    }\n-                    c::tag_table_cast_kinds => {\n-                        let cast_kind =\n-                            val_dsr.read_cast_kind(dcx);\n-                        dcx.tcx.cast_kinds.borrow_mut().insert(id, cast_kind);\n-                    }\n-                    c::tag_table_const_qualif => {\n-                        let qualif: ConstQualif = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n-                    }\n-                    _ => {\n-                        bug!(\"unknown tag found in side tables: {:x}\", tag);\n-                    }\n-                }\n-            }\n-        }\n+/// Decodes an item from its AST in the cdata's metadata and adds it to the\n+/// ast-map.\n+pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n+                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     parent_def_path: ast_map::DefPath,\n+                                     parent_did: DefId,\n+                                     ast: Ast<'tcx>,\n+                                     orig_did: DefId)\n+                                     -> &'tcx InlinedItem {\n+    debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n \n-        debug!(\">< Side table doc loaded\");\n-    }\n-}\n+    let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n+    let start = tcx.sess.reserve_node_ids(cnt);\n+    let id_ranges = [ast.id_range, IdRange {\n+        min: start,\n+        max: ast::NodeId::new(start.as_usize() + cnt)\n+    }];\n \n-// copy the tcache entries from the original item to the new\n-// inlined item\n-fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n-    fn copy_item_type(dcx: &DecodeContext,\n-                      inlined_id: ast::NodeId,\n-                      remote_did: DefId) {\n-        let inlined_did = dcx.tcx.map.local_def_id(inlined_id);\n-        dcx.tcx.register_item_type(inlined_did,\n-                                   dcx.tcx.lookup_item_type(remote_did));\n+    let ii = ast.item.decode((cdata, tcx, id_ranges));\n+    let ii = ast_map::map_decoded_item(&tcx.map,\n+                                       parent_def_path,\n+                                       parent_did,\n+                                       ii,\n+                                       tcx.sess.next_node_id());\n \n-    }\n-    // copy the entry for the item itself\n     let item_node_id = match ii {\n         &InlinedItem::Item(_, ref i) => i.id,\n         &InlinedItem::TraitItem(_, ref ti) => ti.id,\n         &InlinedItem::ImplItem(_, ref ii) => ii.id\n     };\n-    copy_item_type(dcx, item_node_id, orig_did);\n+    let inlined_did = tcx.map.local_def_id(item_node_id);\n+    tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));\n \n-    // copy the entries of inner items\n-    if let &InlinedItem::Item(_, ref item) = ii {\n-        match item.node {\n-            hir::ItemEnum(ref def, _) => {\n-                let orig_def = dcx.tcx.lookup_adt_def(orig_did);\n-                for (i_variant, orig_variant) in\n-                    def.variants.iter().zip(orig_def.variants.iter())\n-                {\n-                    debug!(\"astencode: copying variant {:?} => {:?}\",\n-                           orig_variant.did, i_variant.node.data.id());\n-                    copy_item_type(dcx, i_variant.node.data.id(), orig_variant.did);\n-                }\n+    for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n+        match entry {\n+            TableEntry::Def(def) => {\n+                tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n             }\n-            hir::ItemStruct(ref def, _) => {\n-                if !def.is_struct() {\n-                    let ctor_did = dcx.tcx.lookup_adt_def(orig_did)\n-                        .struct_variant().did;\n-                    debug!(\"astencode: copying ctor {:?} => {:?}\", ctor_did,\n-                           def.id());\n-                    copy_item_type(dcx, def.id(), ctor_did);\n-                }\n+            TableEntry::NodeType(ty) => {\n+                tcx.node_type_insert(id, ty);\n             }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-fn inlined_item_id_range(ii: &InlinedItem) -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor::new();\n-    ii.visit(&mut visitor);\n-    visitor.result()\n-}\n-\n-// ______________________________________________________________________\n-// Testing of astencode_gen\n-\n-#[cfg(test)]\n-fn encode_item_ast(rbml_w: &mut Encoder, item: &hir::Item) {\n-    rbml_w.start_tag(c::tag_tree as usize);\n-    (*item).encode(rbml_w);\n-    rbml_w.end_tag();\n-}\n-\n-#[cfg(test)]\n-fn decode_item_ast(item_doc: rbml::Doc) -> hir::Item {\n-    let chi_doc = item_doc.get(c::tag_tree as usize);\n-    let mut d = reader::Decoder::new(chi_doc);\n-    Decodable::decode(&mut d).unwrap()\n-}\n-\n-#[cfg(test)]\n-trait FakeExtCtxt {\n-    fn call_site(&self) -> syntax_pos::Span;\n-    fn cfg(&self) -> ast::CrateConfig;\n-    fn ident_of(&self, st: &str) -> ast::Ident;\n-    fn name_of(&self, st: &str) -> ast::Name;\n-    fn parse_sess(&self) -> &parse::ParseSess;\n-}\n-\n-#[cfg(test)]\n-impl FakeExtCtxt for parse::ParseSess {\n-    fn call_site(&self) -> syntax_pos::Span {\n-        syntax_pos::Span {\n-            lo: syntax_pos::BytePos(0),\n-            hi: syntax_pos::BytePos(0),\n-            expn_id: syntax_pos::NO_EXPANSION,\n-        }\n-    }\n-    fn cfg(&self) -> ast::CrateConfig { Vec::new() }\n-    fn ident_of(&self, st: &str) -> ast::Ident {\n-        parse::token::str_to_ident(st)\n-    }\n-    fn name_of(&self, st: &str) -> ast::Name {\n-        parse::token::intern(st)\n-    }\n-    fn parse_sess(&self) -> &parse::ParseSess { self }\n-}\n-\n-#[cfg(test)]\n-fn mk_ctxt() -> parse::ParseSess {\n-    parse::ParseSess::new()\n-}\n-\n-#[cfg(test)]\n-fn with_testing_context<T, F: FnOnce(&mut LoweringContext) -> T>(f: F) -> T {\n-    let mut resolver = DummyResolver;\n-    let mut lcx = LoweringContext::testing_context(&mut resolver);\n-    f(&mut lcx)\n-}\n-\n-#[cfg(test)]\n-fn roundtrip(in_item: hir::Item) {\n-    let mut wr = Cursor::new(Vec::new());\n-    encode_item_ast(&mut Encoder::new(&mut wr), &in_item);\n-    let rbml_doc = rbml::Doc::new(wr.get_ref());\n-    let out_item = decode_item_ast(rbml_doc);\n-\n-    assert!(in_item == out_item);\n-}\n-\n-#[test]\n-fn test_basic() {\n-    let cx = mk_ctxt();\n-    with_testing_context(|lcx| {\n-        roundtrip(lcx.lower_item(&quote_item!(&cx,\n-            fn foo() {}\n-        ).unwrap()));\n-    });\n-}\n-\n-#[test]\n-fn test_smalltalk() {\n-    let cx = mk_ctxt();\n-    with_testing_context(|lcx| {\n-        roundtrip(lcx.lower_item(&quote_item!(&cx,\n-            fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n-        ).unwrap()));\n-    });\n-}\n-\n-#[test]\n-fn test_more() {\n-    let cx = mk_ctxt();\n-    with_testing_context(|lcx| {\n-        roundtrip(lcx.lower_item(&quote_item!(&cx,\n-            fn foo(x: usize, y: usize) -> usize {\n-                let z = x + y;\n-                return z;\n+            TableEntry::ItemSubsts(item_substs) => {\n+                tcx.tables.borrow_mut().item_substs.insert(id, item_substs);\n             }\n-        ).unwrap()));\n-    });\n-}\n-\n-#[test]\n-fn test_simplification() {\n-    use middle::cstore::LOCAL_CRATE;\n-    use rustc::hir::def_id::CRATE_DEF_INDEX;\n-\n-    let cx = mk_ctxt();\n-    let item = quote_item!(&cx,\n-        fn new_int_alist<B>() -> alist<isize, B> {\n-            fn eq_int(a: isize, b: isize) -> bool { a == b }\n-            return alist {eq_fn: eq_int, data: Vec::new()};\n-        }\n-    ).unwrap();\n-    let cx = mk_ctxt();\n-    with_testing_context(|lcx| {\n-        let hir_item = lcx.lower_item(&item);\n-        let def_id = DefId { krate: LOCAL_CRATE, index: CRATE_DEF_INDEX }; // dummy\n-        let item_in = InlinedItemRef::Item(def_id, &hir_item);\n-        let (item_out, _) = simplify_ast(item_in);\n-        let item_exp = InlinedItem::Item(def_id, P(lcx.lower_item(&quote_item!(&cx,\n-            fn new_int_alist<B>() -> alist<isize, B> {\n-                return alist {eq_fn: eq_int, data: Vec::new()};\n+            TableEntry::Adjustment(adj) => {\n+                tcx.tables.borrow_mut().adjustments.insert(id, adj);\n             }\n-        ).unwrap())));\n-        match (item_out, item_exp) {\n-            (InlinedItem::Item(_, item_out), InlinedItem::Item(_, item_exp)) => {\n-                 assert!(pprust::item_to_string(&item_out) ==\n-                         pprust::item_to_string(&item_exp));\n+            TableEntry::ConstQualif(qualif) => {\n+                tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n             }\n-            _ => bug!()\n         }\n-    });\n+    }\n+\n+    ii\n }"}, {"sha": "29b9cc0d1d923a6b0eb6af5816e71ba3b7823344", "filename": "src/librustc_metadata/common.rs", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,241 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_camel_case_types, non_upper_case_globals)]\n-\n-pub use self::astencode_tag::*;\n-\n-// RBML enum definitions and utils shared by the encoder and decoder\n-//\n-// 0x00..0x1f: reserved for RBML generic type tags\n-// 0x20..0xef: free for use, preferred for frequent tags\n-// 0xf0..0xff: internally used by RBML to encode 0x100..0xfff in two bytes\n-// 0x100..0xfff: free for use, preferred for infrequent tags\n-\n-pub const tag_items: usize = 0x100; // top-level only\n-\n-pub const tag_paths_data_name: usize = 0x20;\n-\n-pub const tag_def_id: usize = 0x21;\n-\n-pub const tag_items_data: usize = 0x22;\n-\n-pub const tag_items_data_item: usize = 0x23;\n-\n-pub const tag_items_data_item_family: usize = 0x24;\n-\n-pub const tag_items_data_item_type: usize = 0x25;\n-\n-// GAP 0x26\n-\n-pub const tag_items_data_item_variant: usize = 0x27;\n-\n-pub const tag_items_data_parent_item: usize = 0x28;\n-\n-pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n-\n-pub const tag_items_closure_kind: usize = 0x2a;\n-pub const tag_items_closure_ty: usize = 0x2b;\n-pub const tag_def_key: usize = 0x2c;\n-\n-// GAP 0x2d 0x34\n-\n-pub const tag_index: usize = 0x110; // top-level only\n-pub const tag_xref_index: usize = 0x111; // top-level only\n-pub const tag_xref_data: usize = 0x112; // top-level only\n-pub const tag_attributes: usize = 0x101; // top-level only\n-\n-// The list of crates that this crate depends on\n-pub const tag_crate_deps: usize = 0x102; // top-level only\n-\n-// A single crate dependency\n-pub const tag_crate_dep: usize = 0x35;\n-\n-pub const tag_crate_hash: usize = 0x103; // top-level only\n-pub const tag_crate_crate_name: usize = 0x104; // top-level only\n-pub const tag_crate_disambiguator: usize = 0x113; // top-level only\n-\n-pub const tag_crate_dep_crate_name: usize = 0x36;\n-pub const tag_crate_dep_hash: usize = 0x37;\n-pub const tag_crate_dep_explicitly_linked: usize = 0x38; // top-level only\n-\n-pub const tag_item_trait_item: usize = 0x3a;\n-\n-pub const tag_item_trait_ref: usize = 0x3b;\n-\n-// discriminator value for variants\n-pub const tag_disr_val: usize = 0x3c;\n-\n-// GAP 0x3d, 0x3e, 0x3f, 0x40\n-\n-pub const tag_item_field: usize = 0x41;\n-// GAP 0x42\n-pub const tag_item_variances: usize = 0x43;\n-/*\n-  trait items contain tag_item_trait_item elements,\n-  impl items contain tag_item_impl_item elements, and classes\n-  have both. That's because some code treats classes like traits,\n-  and other code treats them like impls. Because classes can contain\n-  both, tag_item_trait_item and tag_item_impl_item have to be two\n-  different tags.\n- */\n-pub const tag_item_impl_item: usize = 0x44;\n-pub const tag_item_trait_method_explicit_self: usize = 0x45;\n-\n-\n-// Reexports are found within module tags. Each reexport contains def_ids\n-// and names.\n-pub const tag_items_data_item_reexport: usize = 0x46;\n-pub const tag_items_data_item_reexport_def_id: usize = 0x47;\n-pub const tag_items_data_item_reexport_name: usize = 0x48;\n-\n-// used to encode crate_ctxt side tables\n-enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq)]\n-    #[repr(usize)]\n-    pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n-        tag_ast = 0x50,\n-\n-        tag_tree = 0x51,\n-\n-        tag_mir = 0x52,\n-\n-        tag_table = 0x53,\n-        // GAP 0x54, 0x55\n-        tag_table_def = 0x56,\n-        tag_table_node_type = 0x57,\n-        tag_table_item_subst = 0x58,\n-        tag_table_freevars = 0x59,\n-        // GAP 0x5a, 0x5b, 0x5c, 0x5d, 0x5e\n-        tag_table_method_map = 0x5f,\n-        // GAP 0x60\n-        tag_table_adjustments = 0x61,\n-        // GAP 0x62, 0x63, 0x64, 0x65\n-        tag_table_upvar_capture_map = 0x66,\n-        // GAP 0x67, 0x68\n-        tag_table_const_qualif = 0x69,\n-        tag_table_cast_kinds = 0x6a,\n-    }\n-}\n-\n-pub const tag_item_trait_item_sort: usize = 0x70;\n-\n-pub const tag_crate_triple: usize = 0x105; // top-level only\n-\n-pub const tag_dylib_dependency_formats: usize = 0x106; // top-level only\n-\n-// Language items are a top-level directory (for speed). Hierarchy:\n-//\n-// tag_lang_items\n-// - tag_lang_items_item\n-//   - tag_lang_items_item_id: u32\n-//   - tag_lang_items_item_index: u32\n-\n-pub const tag_lang_items: usize = 0x107; // top-level only\n-pub const tag_lang_items_item: usize = 0x73;\n-pub const tag_lang_items_item_id: usize = 0x74;\n-pub const tag_lang_items_item_index: usize = 0x75;\n-pub const tag_lang_items_missing: usize = 0x76;\n-\n-pub const tag_item_unnamed_field: usize = 0x77;\n-pub const tag_items_data_item_visibility: usize = 0x78;\n-pub const tag_items_data_item_inherent_impl: usize = 0x79;\n-// GAP 0x7a\n-pub const tag_mod_child: usize = 0x7b;\n-// GAP 0x7c\n-\n-// GAP 0x108\n-pub const tag_impls: usize = 0x109; // top-level only\n-pub const tag_impls_trait: usize = 0x7d;\n-pub const tag_impls_trait_impl: usize = 0x7e;\n-\n-// GAP 0x7f, 0x80, 0x81\n-\n-pub const tag_native_libraries: usize = 0x10a; // top-level only\n-pub const tag_native_libraries_lib: usize = 0x82;\n-pub const tag_native_libraries_name: usize = 0x83;\n-pub const tag_native_libraries_kind: usize = 0x84;\n-\n-pub const tag_plugin_registrar_fn: usize = 0x10b; // top-level only\n-\n-pub const tag_method_argument_names: usize = 0x85;\n-pub const tag_method_argument_name: usize = 0x86;\n-\n-pub const tag_reachable_ids: usize = 0x10c; // top-level only\n-pub const tag_reachable_id: usize = 0x87;\n-\n-pub const tag_items_data_item_stability: usize = 0x88;\n-\n-pub const tag_items_data_item_repr: usize = 0x89;\n-\n-pub const tag_struct_fields: usize = 0x10d; // top-level only\n-pub const tag_struct_field: usize = 0x8a;\n-\n-pub const tag_items_data_item_struct_ctor: usize = 0x8b;\n-pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n-// GAP 0x8d\n-pub const tag_items_data_region: usize = 0x8e;\n-\n-pub const tag_item_generics: usize = 0x8f;\n-// GAP 0x90, 0x91, 0x92, 0x93, 0x94\n-\n-pub const tag_item_predicates: usize = 0x95;\n-// GAP 0x96\n-\n-pub const tag_predicate: usize = 0x97;\n-// GAP 0x98, 0x99\n-\n-pub const tag_unsafety: usize = 0x9a;\n-\n-pub const tag_associated_type_names: usize = 0x9b;\n-pub const tag_associated_type_name: usize = 0x9c;\n-\n-pub const tag_polarity: usize = 0x9d;\n-\n-pub const tag_macro_defs: usize = 0x10e; // top-level only\n-pub const tag_macro_def: usize = 0x9e;\n-pub const tag_macro_def_body: usize = 0x9f;\n-pub const tag_macro_def_span_lo: usize = 0xa8;\n-pub const tag_macro_def_span_hi: usize = 0xa9;\n-\n-pub const tag_paren_sugar: usize = 0xa0;\n-\n-pub const tag_codemap: usize = 0xa1;\n-pub const tag_codemap_filemap: usize = 0xa2;\n-\n-pub const tag_item_super_predicates: usize = 0xa3;\n-\n-pub const tag_defaulted_trait: usize = 0xa4;\n-\n-pub const tag_impl_coerce_unsized_kind: usize = 0xa5;\n-\n-pub const tag_items_data_item_constness: usize = 0xa6;\n-\n-pub const tag_items_data_item_deprecation: usize = 0xa7;\n-\n-pub const tag_items_data_item_defaultness: usize = 0xa8;\n-\n-pub const tag_items_data_parent_impl: usize = 0xa9;\n-\n-pub const tag_rustc_version: usize = 0x10f;\n-pub fn rustc_version() -> String {\n-    format!(\n-        \"rustc {}\",\n-        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n-    )\n-}\n-\n-pub const tag_panic_strategy: usize = 0x114;\n-\n-pub const tag_macro_derive_registrar: usize = 0x115;\n-\n-// NB: increment this if you change the format of metadata such that\n-// rustc_version can't be found.\n-pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2];"}, {"sha": "95be77c24f46eb952e4c6732fd99dda696f554e0", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 70, "deletions": 218, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n //! Validates all used crates and extern libraries and loads their metadata\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n-use decoder;\n use loader::{self, CratePaths};\n+use schema::CrateRoot;\n \n-use rustc::hir::def_id::DefIndex;\n+use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::session::{config, Session};\n@@ -27,18 +25,18 @@ use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc::hir::map as hir_map;\n \n use std::cell::{RefCell, Cell};\n+use std::ops::Deref;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::fs;\n \n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap;\n use syntax::parse;\n use syntax::attr;\n use syntax::parse::token::InternedString;\n use syntax::visit;\n-use syntax_pos::{self, Span, mk_sp, Pos};\n+use syntax_pos::{self, Span, mk_sp};\n use log;\n \n struct LocalCrateReader<'a> {\n@@ -52,7 +50,7 @@ struct LocalCrateReader<'a> {\n pub struct CrateReader<'a> {\n     sess: &'a Session,\n     cstore: &'a CStore,\n-    next_crate_num: ast::CrateNum,\n+    next_crate_num: CrateNum,\n     foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n     local_crate_name: String,\n     local_crate_config: ast::CrateConfig,\n@@ -85,7 +83,7 @@ fn should_link(i: &ast::Item) -> bool {\n }\n \n #[derive(Debug)]\n-struct CrateInfo {\n+struct ExternCrateInfo {\n     ident: String,\n     name: String,\n     id: ast::NodeId,\n@@ -142,17 +140,19 @@ enum PMDSource {\n     Owned(loader::Library),\n }\n \n-impl PMDSource {\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+impl Deref for PMDSource {\n+    type Target = MetadataBlob;\n+\n+    fn deref(&self) -> &MetadataBlob {\n         match *self {\n-            PMDSource::Registered(ref cmd) => cmd.data(),\n-            PMDSource::Owned(ref lib) => lib.metadata.as_slice(),\n+            PMDSource::Registered(ref cmd) => &cmd.blob,\n+            PMDSource::Owned(ref lib) => &lib.metadata\n         }\n     }\n }\n \n enum LoadResult {\n-    Previous(ast::CrateNum),\n+    Previous(CrateNum),\n     Loaded(loader::Library),\n }\n \n@@ -183,7 +183,7 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n+    fn extract_crate_info(&self, i: &ast::Item) -> Option<ExternCrateInfo> {\n         match i.node {\n             ast::ItemKind::ExternCrate(ref path_opt) => {\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n@@ -196,7 +196,7 @@ impl<'a> CrateReader<'a> {\n                     }\n                     None => i.ident.to_string(),\n                 };\n-                Some(CrateInfo {\n+                Some(ExternCrateInfo {\n                     ident: i.ident.to_string(),\n                     name: name,\n                     id: i.id,\n@@ -208,7 +208,7 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n-                      -> Option<ast::CrateNum> {\n+                      -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n             if data.name != name { return }\n@@ -258,32 +258,28 @@ impl<'a> CrateReader<'a> {\n \n     fn verify_no_symbol_conflicts(&self,\n                                   span: Span,\n-                                  metadata: &MetadataBlob) {\n-        let disambiguator = decoder::get_crate_disambiguator(metadata.as_slice());\n-        let crate_name = decoder::get_crate_name(metadata.as_slice());\n-\n+                                  root: &CrateRoot) {\n         // Check for (potential) conflicts with the local crate\n-        if self.local_crate_name == crate_name &&\n-           self.sess.local_crate_disambiguator() == disambiguator {\n+        if self.local_crate_name == root.name &&\n+           self.sess.local_crate_disambiguator() == &root.disambiguator[..] {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n                          compiled with the same `-C metadata` arguments. This \\\n                          will result in symbol conflicts between the two.\",\n-                        crate_name)\n+                        root.name)\n         }\n \n-        let svh = decoder::get_crate_hash(metadata.as_slice());\n         // Check for conflicts with any crate loaded so far\n         self.cstore.iter_crate_data(|_, other| {\n-            if other.name() == crate_name && // same crate-name\n-               other.disambiguator() == disambiguator &&  // same crate-disambiguator\n-               other.hash() != svh { // but different SVH\n+            if other.name() == root.name && // same crate-name\n+               other.disambiguator() == root.disambiguator &&  // same crate-disambiguator\n+               other.hash() != root.hash { // but different SVH\n                 span_fatal!(self.sess, span, E0523,\n                         \"found two different crates with name `{}` that are \\\n                          not distinguished by differing `-C metadata`. This \\\n                          will result in symbol conflicts between the two.\",\n-                        crate_name)\n+                        root.name)\n             }\n         });\n     }\n@@ -295,14 +291,15 @@ impl<'a> CrateReader<'a> {\n                       span: Span,\n                       lib: loader::Library,\n                       explicitly_linked: bool)\n-                      -> (ast::CrateNum, Rc<cstore::CrateMetadata>,\n+                      -> (CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n         info!(\"register crate `extern crate {} as {}`\", name, ident);\n-        self.verify_no_symbol_conflicts(span, &lib.metadata);\n+        let crate_root = lib.metadata.get_root();\n+        self.verify_no_symbol_conflicts(span, &crate_root);\n \n         // Claim this crate number and cache it\n         let cnum = self.next_crate_num;\n-        self.next_crate_num += 1;\n+        self.next_crate_num = CrateNum::from_u32(cnum.as_u32() + 1);\n \n         // Stash paths for top-most crate locally if necessary.\n         let crate_paths = if root.is_none() {\n@@ -319,28 +316,25 @@ impl<'a> CrateReader<'a> {\n \n         let loader::Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), cnum, span);\n-        let staged_api = self.is_staged_api(metadata.as_slice());\n+        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span);\n+\n+        if crate_root.macro_derive_registrar.is_some() {\n+            self.sess.span_err(span, \"crates of the `rustc-macro` crate type \\\n+                                      cannot be linked at runtime\");\n+        }\n \n         let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n-            index: decoder::load_index(metadata.as_slice()),\n-            xref_index: decoder::load_xrefs(metadata.as_slice()),\n-            key_map: decoder::load_key_map(metadata.as_slice()),\n-            data: metadata,\n+            key_map: metadata.load_key_map(crate_root.index),\n+            root: crate_root,\n+            blob: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n-            staged_api: staged_api,\n             explicitly_linked: Cell::new(explicitly_linked),\n         });\n \n-        if decoder::get_derive_registrar_fn(cmeta.data.as_slice()).is_some() {\n-            self.sess.span_err(span, \"crates of the `rustc-macro` crate type \\\n-                                      cannot be linked at runtime\");\n-        }\n-\n         let source = cstore::CrateSource {\n             dylib: dylib,\n             rlib: rlib,\n@@ -352,16 +346,6 @@ impl<'a> CrateReader<'a> {\n         (cnum, cmeta, source)\n     }\n \n-    fn is_staged_api(&self, data: &[u8]) -> bool {\n-        let attrs = decoder::get_crate_attributes(data);\n-        for attr in &attrs {\n-            if attr.name() == \"stable\" || attr.name() == \"unstable\" {\n-                return true\n-            }\n-        }\n-        false\n-    }\n-\n     fn resolve_crate(&mut self,\n                      root: &Option<CratePaths>,\n                      ident: &str,\n@@ -370,7 +354,7 @@ impl<'a> CrateReader<'a> {\n                      span: Span,\n                      kind: PathKind,\n                      explicitly_linked: bool)\n-                     -> (ast::CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n+                     -> (CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n         let result = match self.existing_match(name, hash, kind) {\n             Some(cnum) => LoadResult::Previous(cnum),\n@@ -428,13 +412,11 @@ impl<'a> CrateReader<'a> {\n         // Note that we only do this for target triple crates, though, as we\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n+        let root = library.metadata.get_root();\n         if loader.triple == self.sess.opts.target_triple {\n-            let meta_hash = decoder::get_crate_hash(library.metadata.as_slice());\n-            let meta_name = decoder::get_crate_name(library.metadata.as_slice())\n-                                    .to_string();\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n-                if data.name() == meta_name && meta_hash == data.hash() {\n+                if data.name() == root.name && root.hash == data.hash() {\n                     assert!(loader.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n@@ -447,9 +429,9 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn update_extern_crate(&mut self,\n-                           cnum: ast::CrateNum,\n+                           cnum: CrateNum,\n                            mut extern_crate: ExternCrate,\n-                           visited: &mut FnvHashSet<(ast::CrateNum, bool)>)\n+                           visited: &mut FnvHashSet<(CrateNum, bool)>)\n     {\n         if !visited.insert((cnum, extern_crate.direct)) { return }\n \n@@ -481,33 +463,37 @@ impl<'a> CrateReader<'a> {\n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n-                          cdata: &[u8],\n-                          krate: ast::CrateNum,\n+                          crate_root: &CrateRoot,\n+                          metadata: &MetadataBlob,\n+                          krate: CrateNum,\n                           span: Span)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n-        let map: FnvHashMap<_, _> = decoder::get_crate_deps(cdata).iter().map(|dep| {\n+        let deps = crate_root.crate_deps.decode(metadata);\n+        let map: FnvHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, ..) = self.resolve_crate(root,\n-                                                        &dep.name,\n-                                                        &dep.name,\n+                                                        &dep.name.as_str(),\n+                                                        &dep.name.as_str(),\n                                                         Some(&dep.hash),\n                                                         span,\n                                                         PathKind::Dependency,\n                                                         dep.explicitly_linked);\n-            (dep.cnum, local_cnum)\n+            (CrateNum::new(crate_num + 1), local_cnum)\n         }).collect();\n \n-        let max_cnum = map.values().cloned().max().unwrap_or(0);\n+        let max_cnum = map.values().cloned().max().map(|cnum| cnum.as_u32()).unwrap_or(0);\n \n         // we map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        (0..max_cnum+1).map(|cnum| map.get(&cnum).cloned().unwrap_or(krate)).collect()\n+        (0..max_cnum+1).map(|cnum| {\n+            map.get(&CrateNum::from_u32(cnum)).cloned().unwrap_or(krate)\n+        }).collect()\n     }\n \n-    fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n+    fn read_extension_crate(&mut self, span: Span, info: &ExternCrateInfo) -> ExtensionCrate {\n         info!(\"read extension crate {} `extern crate {} as {}` linked={}\",\n               info.id, info.name, info.ident, info.should_link);\n         let target_triple = &self.sess.opts.target_triple[..];\n@@ -580,21 +566,21 @@ impl<'a> CrateReader<'a> {\n         let ci = self.extract_crate_info(item).unwrap();\n         let ekrate = self.read_extension_crate(item.span, &ci);\n \n+        let root = ekrate.metadata.get_root();\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut ret = Macros {\n             macro_rules: Vec::new(),\n             custom_derive_registrar: None,\n-            svh: decoder::get_crate_hash(ekrate.metadata.as_slice()),\n+            svh: root.hash,\n             dylib: None,\n         };\n-        decoder::each_exported_macro(ekrate.metadata.as_slice(),\n-                                     |name, attrs, span, body| {\n+        for def in root.macro_defs.decode(&*ekrate.metadata) {\n             // NB: Don't use parse::parse_tts_from_source_str because it parses with\n             // quote_depth > 0.\n             let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n                                                           self.local_crate_config.clone(),\n                                                           source_name.clone(),\n-                                                          body);\n+                                                          def.body);\n             let lo = p.span.lo;\n             let body = match p.parse_all_token_trees() {\n                 Ok(body) => body,\n@@ -607,13 +593,13 @@ impl<'a> CrateReader<'a> {\n             let local_span = mk_sp(lo, p.last_span.hi);\n \n             // Mark the attrs as used\n-            for attr in &attrs {\n+            for attr in &def.attrs {\n                 attr::mark_used(attr);\n             }\n \n             ret.macro_rules.push(ast::MacroDef {\n-                ident: ast::Ident::with_empty_ctxt(name),\n-                attrs: attrs,\n+                ident: ast::Ident::with_empty_ctxt(def.name),\n+                attrs: def.attrs,\n                 id: ast::DUMMY_NODE_ID,\n                 span: local_span,\n                 imported_from: Some(item.ident),\n@@ -625,11 +611,10 @@ impl<'a> CrateReader<'a> {\n                 body: body,\n             });\n             self.sess.imported_macro_spans.borrow_mut()\n-                .insert(local_span, (name.as_str().to_string(), span));\n-            true\n-        });\n+                .insert(local_span, (def.name.as_str().to_string(), def.span));\n+        }\n \n-        match decoder::get_derive_registrar_fn(ekrate.metadata.as_slice()) {\n+        match root.macro_derive_registrar {\n             Some(id) => ret.custom_derive_registrar = Some(id),\n \n             // If this crate is not a rustc-macro crate then we might be able to\n@@ -666,7 +651,7 @@ impl<'a> CrateReader<'a> {\n     /// SVH and DefIndex of the registrar function.\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n                                  -> Option<(PathBuf, Svh, DefIndex)> {\n-        let ekrate = self.read_extension_crate(span, &CrateInfo {\n+        let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n              name: name.to_string(),\n              ident: name.to_string(),\n              id: ast::DUMMY_NODE_ID,\n@@ -683,13 +668,10 @@ impl<'a> CrateReader<'a> {\n             span_fatal!(self.sess, span, E0456, \"{}\", &message[..]);\n         }\n \n-        let svh = decoder::get_crate_hash(ekrate.metadata.as_slice());\n-        let registrar =\n-            decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice());\n-\n-        match (ekrate.dylib.as_ref(), registrar) {\n+        let root = ekrate.metadata.get_root();\n+        match (ekrate.dylib.as_ref(), root.plugin_registrar_fn) {\n             (Some(dylib), Some(reg)) => {\n-                Some((dylib.to_path_buf(), svh, reg))\n+                Some((dylib.to_path_buf(), root.hash, reg))\n             }\n             (None, Some(_)) => {\n                 span_err!(self.sess, span, E0457,\n@@ -875,7 +857,7 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn inject_dependency_if(&self,\n-                            krate: ast::CrateNum,\n+                            krate: CrateNum,\n                             what: &str,\n                             needs_dep: &Fn(&cstore::CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n@@ -1101,133 +1083,3 @@ pub fn read_local_crates(sess: & Session,\n                          dep_graph: &DepGraph) {\n     LocalCrateReader::new(sess, cstore, defs, krate, local_crate_name).read_crates(dep_graph)\n }\n-\n-/// Imports the codemap from an external crate into the codemap of the crate\n-/// currently being compiled (the \"local crate\").\n-///\n-/// The import algorithm works analogous to how AST items are inlined from an\n-/// external crate's metadata:\n-/// For every FileMap in the external codemap an 'inline' copy is created in the\n-/// local codemap. The correspondence relation between external and local\n-/// FileMaps is recorded in the `ImportedFileMap` objects returned from this\n-/// function. When an item from an external crate is later inlined into this\n-/// crate, this correspondence information is used to translate the span\n-/// information of the inlined item so that it refers the correct positions in\n-/// the local codemap (see `astencode::DecodeContext::tr_span()`).\n-///\n-/// The import algorithm in the function below will reuse FileMaps already\n-/// existing in the local codemap. For example, even if the FileMap of some\n-/// source file of libstd gets imported many times, there will only ever be\n-/// one FileMap object for the corresponding file in the local codemap.\n-///\n-/// Note that imported FileMaps do not actually contain the source code of the\n-/// file they represent, just information about length, line breaks, and\n-/// multibyte characters. This information is enough to generate valid debuginfo\n-/// for items inlined from other crates.\n-pub fn import_codemap(local_codemap: &codemap::CodeMap,\n-                      metadata: &MetadataBlob)\n-                      -> Vec<cstore::ImportedFileMap> {\n-    let external_codemap = decoder::get_imported_filemaps(metadata.as_slice());\n-\n-    let imported_filemaps = external_codemap.into_iter().map(|filemap_to_import| {\n-        // Try to find an existing FileMap that can be reused for the filemap to\n-        // be imported. A FileMap is reusable if it is exactly the same, just\n-        // positioned at a different offset within the codemap.\n-        let reusable_filemap = {\n-            local_codemap.files\n-                         .borrow()\n-                         .iter()\n-                         .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n-                         .map(|rc| rc.clone())\n-        };\n-\n-        match reusable_filemap {\n-            Some(fm) => {\n-                cstore::ImportedFileMap {\n-                    original_start_pos: filemap_to_import.start_pos,\n-                    original_end_pos: filemap_to_import.end_pos,\n-                    translated_filemap: fm\n-                }\n-            }\n-            None => {\n-                // We can't reuse an existing FileMap, so allocate a new one\n-                // containing the information we need.\n-                let syntax_pos::FileMap {\n-                    name,\n-                    abs_path,\n-                    start_pos,\n-                    end_pos,\n-                    lines,\n-                    multibyte_chars,\n-                    ..\n-                } = filemap_to_import;\n-\n-                let source_length = (end_pos - start_pos).to_usize();\n-\n-                // Translate line-start positions and multibyte character\n-                // position into frame of reference local to file.\n-                // `CodeMap::new_imported_filemap()` will then translate those\n-                // coordinates to their new global frame of reference when the\n-                // offset of the FileMap is known.\n-                let mut lines = lines.into_inner();\n-                for pos in &mut lines {\n-                    *pos = *pos - start_pos;\n-                }\n-                let mut multibyte_chars = multibyte_chars.into_inner();\n-                for mbc in &mut multibyte_chars {\n-                    mbc.pos = mbc.pos - start_pos;\n-                }\n-\n-                let local_version = local_codemap.new_imported_filemap(name,\n-                                                                       abs_path,\n-                                                                       source_length,\n-                                                                       lines,\n-                                                                       multibyte_chars);\n-                cstore::ImportedFileMap {\n-                    original_start_pos: start_pos,\n-                    original_end_pos: end_pos,\n-                    translated_filemap: local_version\n-                }\n-            }\n-        }\n-    }).collect();\n-\n-    return imported_filemaps;\n-\n-    fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap,\n-                                 fm2: &syntax_pos::FileMap)\n-                                 -> bool {\n-        if fm1.name != fm2.name {\n-            return false;\n-        }\n-\n-        let lines1 = fm1.lines.borrow();\n-        let lines2 = fm2.lines.borrow();\n-\n-        if lines1.len() != lines2.len() {\n-            return false;\n-        }\n-\n-        for (&line1, &line2) in lines1.iter().zip(lines2.iter()) {\n-            if (line1 - fm1.start_pos) != (line2 - fm2.start_pos) {\n-                return false;\n-            }\n-        }\n-\n-        let multibytes1 = fm1.multibyte_chars.borrow();\n-        let multibytes2 = fm2.multibyte_chars.borrow();\n-\n-        if multibytes1.len() != multibytes2.len() {\n-            return false;\n-        }\n-\n-        for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n-            if (mb1.bytes != mb2.bytes) ||\n-               ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n-                return false;\n-            }\n-        }\n-\n-        true\n-    }\n-}"}, {"sha": "1f25136ffe1acc679c7870dc66be5362b2f3ff5c", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 119, "deletions": 300, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -9,28 +9,25 @@\n // except according to those terms.\n \n use cstore;\n-use common;\n-use decoder;\n use encoder;\n use loader;\n+use schema;\n \n-use middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate, DefLike};\n-use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n-use rustc::hir::def;\n-use middle::lang_items;\n-use rustc::ty::{self, Ty, TyCtxt, VariantKind};\n-use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, ExternCrate};\n+use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n+use rustc::hir::def::{self, Def};\n+use rustc::middle::lang_items;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::DefKey;\n use rustc::mir::repr::Mir;\n use rustc::mir::mir_map::MirMap;\n-use rustc::util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n+use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc::session::config::PanicStrategy;\n \n-use std::cell::RefCell;\n-use std::rc::Rc;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n@@ -40,385 +37,284 @@ use rustc_back::target::Target;\n use rustc::hir;\n \n impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n+    fn describe_def(&self, def: DefId) -> Option<Def> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).get_def(def.index)\n+    }\n+\n     fn stability(&self, def: DefId) -> Option<attr::Stability> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_stability(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_stability(def.index)\n     }\n \n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_deprecation(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_deprecation(def.index)\n     }\n \n     fn visibility(&self, def: DefId) -> ty::Visibility {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_visibility(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind\n     {\n         assert!(!def_id.is_local());\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::closure_kind(&cdata, def_id.index)\n+        self.get_crate_data(def_id.krate).closure_kind(def_id.index)\n     }\n \n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n         assert!(!def_id.is_local());\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::closure_ty(&cdata, def_id.index, tcx)\n+        self.get_crate_data(def_id.krate).closure_ty(def_id.index, tcx)\n     }\n \n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_item_variances(&cdata, def.index)\n-    }\n-\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_repr_attrs(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_item_variances(def.index)\n     }\n \n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_type(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_type(def.index, tcx)\n     }\n \n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_predicates(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_predicates(def.index, tcx)\n     }\n \n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_super_predicates(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_super_predicates(def.index, tcx)\n     }\n \n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx>\n+                         -> ty::Generics<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_generics(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_generics(def.index, tcx)\n     }\n \n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_item_attrs(&cdata, def_id.index)\n+        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n     }\n \n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_trait_def(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_trait_def(def.index, tcx)\n     }\n \n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_adt_def(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_adt_def(def.index, tcx)\n     }\n \n-    fn method_arg_names(&self, did: DefId) -> Vec<String>\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>\n     {\n         self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::get_method_arg_names(&cdata, did.index)\n-    }\n-\n-    fn item_name(&self, def: DefId) -> ast::Name {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_item_name(&cdata, def.index)\n-    }\n-\n-    fn opt_item_name(&self, def: DefId) -> Option<ast::Name> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_name(&cdata, def.index)\n+        self.get_crate_data(did.krate).get_fn_arg_names(did.index)\n     }\n \n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let mut result = vec![];\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::each_inherent_implementation_for_type(&cdata, def_id.index,\n-                                                       |iid| result.push(iid));\n-        result\n+        self.get_crate_data(def_id.krate).get_inherent_implementations_for_type(def_id.index)\n     }\n \n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n+        if let Some(def_id) = filter {\n+            self.dep_graph.read(DepNode::MetaData(def_id));\n+        }\n         let mut result = vec![];\n         self.iter_crate_data(|_, cdata| {\n-            decoder::each_implementation_for_trait(cdata, def_id, &mut |iid| {\n-                result.push(iid)\n-            })\n+            cdata.get_implementations_for_trait(filter, &mut result)\n         });\n         result\n     }\n \n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_provided_trait_methods(&cdata, def.index, tcx)\n-    }\n-\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_trait_item_def_ids(&cdata, def.index)\n-    }\n-\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(impl_def_id));\n-        let cdata = self.get_crate_data(impl_def_id.krate);\n-        decoder::get_impl_items(&cdata, impl_def_id.index)\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId> {\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n+        let mut result = vec![];\n+        self.get_crate_data(def_id.krate)\n+            .each_child_of_item(def_id.index, |child| result.push(child.def_id));\n+        result\n     }\n \n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_polarity(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_impl_polarity(def.index)\n     }\n \n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_trait(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_impl_trait(def.index, tcx)\n     }\n \n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_custom_coerce_unsized_kind(&cdata, def.index)\n-    }\n-\n-    // FIXME: killme\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_associated_consts(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_custom_coerce_unsized_kind(def.index)\n     }\n \n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(impl_def));\n-        let cdata = self.get_crate_data(impl_def.krate);\n-        decoder::get_parent_impl(&*cdata, impl_def.index)\n+        self.get_crate_data(impl_def.krate).get_parent_impl(impl_def.index)\n     }\n \n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_trait_of_item(&cdata, def_id.index)\n+        self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_or_trait_item(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_impl_or_trait_item(def.index, tcx)\n     }\n \n     fn is_const_fn(&self, did: DefId) -> bool\n     {\n         self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_const_fn(&cdata, did.index)\n+        self.get_crate_data(did.krate).is_const_fn(did.index)\n     }\n \n     fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool\n     {\n         self.dep_graph.read(DepNode::MetaData(trait_def_id));\n-        let cdata = self.get_crate_data(trait_def_id.krate);\n-        decoder::is_defaulted_trait(&cdata, trait_def_id.index)\n-    }\n-\n-    fn is_impl(&self, did: DefId) -> bool\n-    {\n-        self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_impl(&cdata, did.index)\n+        self.get_crate_data(trait_def_id.krate).is_defaulted_trait(trait_def_id.index)\n     }\n \n     fn is_default_impl(&self, impl_did: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(impl_did));\n-        let cdata = self.get_crate_data(impl_did.krate);\n-        decoder::is_default_impl(&cdata, impl_did.index)\n+        self.get_crate_data(impl_did.krate).is_default_impl(impl_did.index)\n     }\n \n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_extern_item(&cdata, did.index, tcx)\n+        self.get_crate_data(did.krate).is_extern_item(did.index, tcx)\n     }\n \n     fn is_foreign_item(&self, did: DefId) -> bool {\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_foreign_item(&cdata, did.index)\n+        self.get_crate_data(did.krate).is_foreign_item(did.index)\n     }\n \n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool\n     {\n         self.do_is_statically_included_foreign_item(id)\n     }\n \n-    fn is_typedef(&self, did: DefId) -> bool {\n-        self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_typedef(&cdata, did.index)\n-    }\n-\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                -> Vec<(ast::CrateNum, LinkagePreference)>\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                -> Vec<(CrateNum, LinkagePreference)>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_dylib_dependency_formats(&cdata)\n+        self.get_crate_data(cnum).get_dylib_dependency_formats()\n     }\n \n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n     {\n-        let mut result = vec![];\n-        let crate_data = self.get_crate_data(cnum);\n-        decoder::each_lang_item(&crate_data, |did, lid| {\n-            result.push((did, lid)); true\n-        });\n-        result\n+        self.get_crate_data(cnum).get_lang_items()\n     }\n \n-    fn missing_lang_items(&self, cnum: ast::CrateNum)\n+    fn missing_lang_items(&self, cnum: CrateNum)\n                           -> Vec<lang_items::LangItem>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_missing_lang_items(&cdata)\n+        self.get_crate_data(cnum).get_missing_lang_items()\n     }\n \n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool\n     {\n-        self.get_crate_data(cnum).staged_api\n+        self.get_crate_data(cnum).is_staged_api()\n     }\n \n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).explicitly_linked.get()\n     }\n \n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool\n+    fn is_allocator(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).is_allocator()\n     }\n \n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).is_panic_runtime()\n     }\n \n-    fn is_compiler_builtins(&self, cnum: ast::CrateNum) -> bool {\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool {\n         self.get_crate_data(cnum).is_compiler_builtins()\n     }\n \n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy {\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n         self.get_crate_data(cnum).panic_strategy()\n     }\n \n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n-    {\n-        decoder::get_crate_attributes(self.get_crate_data(cnum).data())\n-    }\n-\n-    fn crate_name(&self, cnum: ast::CrateNum) -> token::InternedString\n+    fn crate_name(&self, cnum: CrateNum) -> token::InternedString\n     {\n         token::intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n     }\n \n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> token::InternedString\n+    fn original_crate_name(&self, cnum: CrateNum) -> token::InternedString\n     {\n         token::intern_and_get_ident(&self.get_crate_data(cnum).name())\n     }\n \n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>\n     {\n         self.get_crate_data(cnum).extern_crate.get()\n     }\n \n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_crate_hash(cdata.data())\n+        self.get_crate_hash(cnum)\n     }\n \n-    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> token::InternedString\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> token::InternedString\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        token::intern_and_get_ident(decoder::get_crate_disambiguator(cdata.data()))\n+        token::intern_and_get_ident(&self.get_crate_data(cnum).disambiguator())\n     }\n \n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n     {\n-        decoder::get_struct_field_attrs(&self.get_crate_data(cnum))\n-    }\n-\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n-    {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_plugin_registrar_fn(cdata.data()).map(|index| DefId {\n+        self.get_crate_data(cnum).root.plugin_registrar_fn.map(|index| DefId {\n             krate: cnum,\n             index: index\n         })\n     }\n \n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_native_libraries(&cdata)\n+        self.get_crate_data(cnum).get_native_libraries()\n     }\n \n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_reachable_ids(&cdata)\n+        self.get_crate_data(cnum).get_reachable_ids()\n     }\n \n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool {\n-        attr::contains_name(&self.crate_attrs(cnum), \"no_builtins\")\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool {\n+        self.get_crate_data(cnum).is_no_builtins()\n     }\n \n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex> {\n         let cdata = self.get_crate_data(cnum);\n@@ -435,66 +331,41 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         // canonical name for an item.\n         //\n         // self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::def_key(&cdata, def.index)\n+        self.get_crate_data(def.krate).def_key(def.index)\n     }\n \n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n         // See `Note` above in `def_key()` for why this read is\n         // commented out:\n         //\n         // self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::def_path(&cdata, def.index)\n+        self.get_crate_data(def.krate).def_path(def.index)\n     }\n \n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> {\n+    fn variant_kind(&self, def_id: DefId) -> Option<ty::VariantKind>\n+    {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_variant_kind(&cdata, def_id.index)\n+        self.get_crate_data(def_id.krate).get_variant_kind(def_id.index)\n     }\n \n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n     {\n         self.dep_graph.read(DepNode::MetaData(struct_def_id));\n-        let cdata = self.get_crate_data(struct_def_id.krate);\n-        decoder::get_struct_ctor_def_id(&cdata, struct_def_id.index)\n-    }\n-\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::get_tuple_struct_definition_if_ctor(&cdata, did.index)\n+        self.get_crate_data(struct_def_id.krate).get_struct_ctor_def_id(struct_def_id.index)\n     }\n \n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_struct_field_names(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n-    fn item_children(&self, def_id: DefId) -> Vec<ChildItem>\n+    fn item_children(&self, def_id: DefId) -> Vec<def::Export>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n-        let crate_data = self.get_crate_data(def_id.krate);\n-        let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data, |def, name, vis| {\n-            result.push(ChildItem { def: def, name: name, vis: vis });\n-        });\n-        result\n-    }\n-\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n-    {\n-        let mut result = vec![];\n-        let crate_data = self.get_crate_data(cnum);\n-        let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_top_level_item_of_crate(&crate_data, get_crate_data, |def, name, vis| {\n-            result.push(ChildItem { def: def, name: name, vis: vis });\n-        });\n+        self.get_crate_data(def_id.krate)\n+            .each_child_of_item(def_id.index, |child| result.push(child));\n         result\n     }\n \n@@ -523,8 +394,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n         debug!(\"maybe_get_item_ast({}): inlining item\", tcx.item_path_str(def_id));\n \n-        let cdata = self.get_crate_data(def_id.krate);\n-        let inlined = decoder::maybe_get_item_ast(&cdata, tcx, def_id.index);\n+        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_ast(tcx, def_id.index);\n \n         let cache_inlined_item = |original_def_id, inlined_item_id, inlined_root_node_id| {\n             let cache_entry = cstore::CachedInlinedItem {\n@@ -557,45 +427,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         };\n \n         match inlined {\n-            decoder::FoundAst::NotFound => {\n+            None => {\n                 self.inlined_item_cache\n                     .borrow_mut()\n                     .insert(def_id, None);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::Item(d, ref item)) => {\n+            Some(&InlinedItem::Item(d, ref item)) => {\n                 assert_eq!(d, def_id);\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(def_id, item.id, inlined_root_node_id);\n             }\n-            decoder::FoundAst::FoundParent(parent_did, item) => {\n-                let inlined_root_node_id = find_inlined_item_root(item.id);\n-                cache_inlined_item(parent_did, item.id, inlined_root_node_id);\n-\n-                match item.node {\n-                    hir::ItemEnum(ref ast_def, _) => {\n-                        let ast_vs = &ast_def.variants;\n-                        let ty_vs = &tcx.lookup_adt_def(parent_did).variants;\n-                        assert_eq!(ast_vs.len(), ty_vs.len());\n-                        for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n-                            cache_inlined_item(ty_v.did,\n-                                               ast_v.node.data.id(),\n-                                               inlined_root_node_id);\n-                        }\n-                    }\n-                    hir::ItemStruct(ref struct_def, _) => {\n-                        if struct_def.is_struct() {\n-                            bug!(\"instantiate_inline: called on a non-tuple struct\")\n-                        } else {\n-                            cache_inlined_item(def_id,\n-                                               struct_def.id(),\n-                                               inlined_root_node_id);\n-                        }\n-                    }\n-                    _ => bug!(\"instantiate_inline: item has a \\\n-                               non-enum, non-struct parent\")\n-                }\n-            }\n-            decoder::FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n+            Some(&InlinedItem::TraitItem(_, ref trait_item)) => {\n                 let inlined_root_node_id = find_inlined_item_root(trait_item.id);\n                 cache_inlined_item(def_id, trait_item.id, inlined_root_node_id);\n \n@@ -608,7 +450,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 tcx.impl_or_trait_items.borrow_mut()\n                    .insert(trait_item_def_id, ty_trait_item);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::ImplItem(_, ref impl_item)) => {\n+            Some(&InlinedItem::ImplItem(_, ref impl_item)) => {\n                 let inlined_root_node_id = find_inlined_item_root(impl_item.id);\n                 cache_inlined_item(def_id, impl_item.id, inlined_root_node_id);\n             }\n@@ -640,17 +482,15 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_mir(&cdata, tcx, def.index)\n+        self.get_crate_data(def.krate).maybe_get_item_mir(tcx, def.index)\n     }\n \n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::is_item_mir_available(&cdata, def.index)\n+        self.get_crate_data(def.krate).is_item_mir_available(def.index)\n     }\n \n-    fn crates(&self) -> Vec<ast::CrateNum>\n+    fn crates(&self) -> Vec<CrateNum>\n     {\n         let mut result = vec![];\n         self.iter_crate_data(|cnum, _| result.push(cnum));\n@@ -676,26 +516,18 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         loader::meta_section_name(target)\n     }\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8>\n-    {\n-        encoder::encoded_ty(tcx, ty, def_id_to_string)\n-    }\n \n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n     {\n         self.do_get_used_crates(prefer)\n     }\n \n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource\n     {\n         self.opt_used_crate_source(cnum).unwrap()\n     }\n \n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n     {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n@@ -704,26 +536,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8>\n-    {\n-        let ecx = encoder::EncodeContext {\n-            diag: tcx.sess.diagnostic(),\n-            tcx: tcx,\n-            reexports: reexports,\n-            link_meta: link_meta,\n-            cstore: self,\n-            reachable: reachable,\n-            mir_map: mir_map,\n-            type_abbrevs: RefCell::new(FnvHashMap()),\n-        };\n-        encoder::encode_metadata(ecx, krate)\n-\n+                           mir_map: &MirMap<'tcx>) -> Vec<u8>\n+    {\n+        encoder::encode_metadata(tcx, self, reexports, link_meta, reachable, mir_map)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]\n     {\n-        common::metadata_encoding_version\n+        schema::METADATA_HEADER\n     }\n \n     /// Returns a map from a sufficiently visible external item (i.e. an external item that is\n@@ -733,10 +553,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let mut visible_parent_map = self.visible_parent_map.borrow_mut();\n         if !visible_parent_map.is_empty() { return visible_parent_map; }\n \n-        use rustc::middle::cstore::ChildItem;\n         use std::collections::vec_deque::VecDeque;\n         use std::collections::hash_map::Entry;\n-        for cnum in 1 .. self.next_crate_num() {\n+        for cnum in (1 .. self.next_crate_num().as_usize()).map(CrateNum::new) {\n             let cdata = self.get_crate_data(cnum);\n \n             match cdata.extern_crate.get() {\n@@ -746,11 +565,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             }\n \n             let mut bfs_queue = &mut VecDeque::new();\n-            let mut add_child = |bfs_queue: &mut VecDeque<_>, child: ChildItem, parent: DefId| {\n-                let child = match child.def {\n-                    DefLike::DlDef(def) if child.vis == ty::Visibility::Public => def.def_id(),\n-                    _ => return,\n-                };\n+            let mut add_child = |bfs_queue: &mut VecDeque<_>, child: def::Export, parent: DefId| {\n+                let child = child.def_id;\n+\n+                if self.visibility(child) != ty::Visibility::Public {\n+                    return;\n+                }\n \n                 match visible_parent_map.entry(child) {\n                     Entry::Occupied(mut entry) => {\n@@ -767,10 +587,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 }\n             };\n \n-            let croot = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-            for child in self.crate_top_level_items(cnum) {\n-                add_child(bfs_queue, child, croot);\n-            }\n+            bfs_queue.push_back(DefId {\n+                krate: cnum,\n+                index: CRATE_DEF_INDEX\n+            });\n             while let Some(def) = bfs_queue.pop_front() {\n                 for child in self.item_children(def) {\n                     add_child(bfs_queue, child, def);\n@@ -781,4 +601,3 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         visible_parent_map\n     }\n }\n-"}, {"sha": "0a1ff70a0497e518992afb0b8507f63aab173d32", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 48, "deletions": 92, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,54 +8,46 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-pub use self::MetadataBlob::*;\n-\n-use common;\n-use creader;\n-use decoder;\n-use index;\n use loader;\n+use schema;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap, FnvHashSet};\n \n-use std::cell::{RefCell, Ref, Cell};\n+use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::codemap;\n use syntax_pos;\n \n-pub use middle::cstore::{NativeLibraryKind, LinkagePreference};\n-pub use middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n-pub use middle::cstore::{CrateSource, LinkMeta};\n+pub use rustc::middle::cstore::{NativeLibraryKind, LinkagePreference};\n+pub use rustc::middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n+pub use rustc::middle::cstore::{CrateSource, LinkMeta};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type CrateNumMap = IndexVec<ast::CrateNum, ast::CrateNum>;\n+pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub enum MetadataBlob {\n-    MetadataVec(Bytes),\n-    MetadataArchive(loader::ArchiveMetadata),\n+    Inflated(Bytes),\n+    Archive(loader::ArchiveMetadata),\n }\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n-/// See creader::import_codemap() for more information.\n+/// See `imported_filemaps()` for more information.\n pub struct ImportedFileMap {\n     /// This FileMap's byte-offset within the codemap of its original crate\n     pub original_start_pos: syntax_pos::BytePos,\n@@ -73,14 +65,12 @@ pub struct CrateMetadata {\n     /// (e.g., by the allocator)\n     pub extern_crate: Cell<Option<ExternCrate>>,\n \n-    pub data: MetadataBlob,\n+    pub blob: MetadataBlob,\n     pub cnum_map: RefCell<CrateNumMap>,\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n-    pub staged_api: bool,\n \n-    pub index: index::Index,\n-    pub xref_index: index::DenseIndex,\n+    pub root: schema::CrateRoot,\n \n     /// For each public item in this crate, we encode a key.  When the\n     /// crate is loaded, we read all the keys and put them in this\n@@ -105,9 +95,9 @@ pub struct CachedInlinedItem {\n \n pub struct CStore {\n     pub dep_graph: DepGraph,\n-    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<CrateMetadata>>>,\n+    metas: RefCell<FnvHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n-    extern_mod_crate_map: RefCell<NodeMap<ast::CrateNum>>,\n+    extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n@@ -135,25 +125,24 @@ impl CStore {\n         }\n     }\n \n-    pub fn next_crate_num(&self) -> ast::CrateNum {\n-        self.metas.borrow().len() as ast::CrateNum + 1\n+    pub fn next_crate_num(&self) -> CrateNum {\n+        CrateNum::new(self.metas.borrow().len() + 1)\n     }\n \n-    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<CrateMetadata> {\n+    pub fn get_crate_data(&self, cnum: CrateNum) -> Rc<CrateMetadata> {\n         self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n-    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_crate_hash(cdata.data())\n+    pub fn get_crate_hash(&self, cnum: CrateNum) -> Svh {\n+        self.get_crate_data(cnum).hash()\n     }\n \n-    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<CrateMetadata>) {\n+    pub fn set_crate_data(&self, cnum: CrateNum, data: Rc<CrateMetadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n     pub fn iter_crate_data<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &Rc<CrateMetadata>),\n+        I: FnMut(CrateNum, &Rc<CrateMetadata>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, v);\n@@ -162,7 +151,7 @@ impl CStore {\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n     pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &CrateMetadata, Option<CrateSource>),\n+        I: FnMut(CrateNum, &CrateMetadata, Option<CrateSource>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.opt_used_crate_source(k);\n@@ -178,7 +167,7 @@ impl CStore {\n         }\n     }\n \n-    pub fn opt_used_crate_source(&self, cnum: ast::CrateNum)\n+    pub fn opt_used_crate_source(&self, cnum: CrateNum)\n                                  -> Option<CrateSource> {\n         self.used_crate_sources.borrow_mut()\n             .iter().find(|source| source.cnum == cnum).cloned()\n@@ -193,7 +182,7 @@ impl CStore {\n         self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n-    pub fn crate_dependencies_in_rpo(&self, krate: ast::CrateNum) -> Vec<ast::CrateNum>\n+    pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum>\n     {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);\n@@ -202,8 +191,8 @@ impl CStore {\n     }\n \n     pub fn push_dependencies_in_postorder(&self,\n-                                          ordering: &mut Vec<ast::CrateNum>,\n-                                          krate: ast::CrateNum)\n+                                          ordering: &mut Vec<CrateNum>,\n+                                          krate: CrateNum)\n     {\n         if ordering.contains(&krate) { return }\n \n@@ -227,7 +216,7 @@ impl CStore {\n     // topological sort of all crates putting the leaves at the right-most\n     // positions.\n     pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n-                              -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n+                              -> Vec<(CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n@@ -272,7 +261,7 @@ impl CStore {\n \n     pub fn add_extern_mod_stmt_cnum(&self,\n                                     emod_id: ast::NodeId,\n-                                    cnum: ast::CrateNum) {\n+                                    cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n@@ -284,7 +273,7 @@ impl CStore {\n         self.statically_included_foreign_items.borrow().contains(&id)\n     }\n \n-    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>\n+    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n     {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n@@ -299,80 +288,47 @@ impl CStore {\n }\n \n impl CrateMetadata {\n-    pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n-    pub fn name(&self) -> &str { decoder::get_crate_name(self.data()) }\n-    pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n-    pub fn disambiguator(&self) -> &str {\n-        decoder::get_crate_disambiguator(self.data())\n-    }\n-    pub fn imported_filemaps<'a>(&'a self, codemap: &codemap::CodeMap)\n-                                 -> Ref<'a, Vec<ImportedFileMap>> {\n-        let filemaps = self.codemap_import_info.borrow();\n-        if filemaps.is_empty() {\n-            drop(filemaps);\n-            let filemaps = creader::import_codemap(codemap, &self.data);\n-\n-            // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n-            *self.codemap_import_info.borrow_mut() = filemaps;\n-            self.codemap_import_info.borrow()\n-        } else {\n-            filemaps\n-        }\n+    pub fn name(&self) -> &str { &self.root.name }\n+    pub fn hash(&self) -> Svh { self.root.hash }\n+    pub fn disambiguator(&self) -> &str { &self.root.disambiguator }\n+\n+    pub fn is_staged_api(&self) -> bool {\n+        self.get_item_attrs(CRATE_DEF_INDEX).iter().any(|attr| {\n+            attr.name() == \"stable\" || attr.name() == \"unstable\"\n+        })\n     }\n \n     pub fn is_allocator(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"allocator\")\n     }\n \n     pub fn needs_allocator(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n     pub fn is_panic_runtime(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n     pub fn needs_panic_runtime(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n \n     pub fn is_compiler_builtins(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"compiler_builtins\")\n     }\n \n-    pub fn panic_strategy(&self) -> PanicStrategy {\n-        decoder::get_panic_strategy(self.data())\n+    pub fn is_no_builtins(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+        attr::contains_name(&attrs, \"no_builtins\")\n     }\n-}\n \n-impl MetadataBlob {\n-    pub fn as_slice_raw<'a>(&'a self) -> &'a [u8] {\n-        match *self {\n-            MetadataVec(ref vec) => &vec[..],\n-            MetadataArchive(ref ar) => ar.as_slice(),\n-        }\n-    }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n-        let slice = self.as_slice_raw();\n-        let len_offset = 4 + common::metadata_encoding_version.len();\n-        if slice.len() < len_offset+4 {\n-            &[] // corrupt metadata\n-        } else {\n-            let len = (((slice[len_offset+0] as u32) << 24) |\n-                       ((slice[len_offset+1] as u32) << 16) |\n-                       ((slice[len_offset+2] as u32) << 8) |\n-                       ((slice[len_offset+3] as u32) << 0)) as usize;\n-            if len <= slice.len() - 4 - len_offset {\n-                &slice[len_offset + 4..len_offset + len + 4]\n-            } else {\n-                &[] // corrupt or old metadata\n-            }\n-        }\n+    pub fn panic_strategy(&self) -> PanicStrategy {\n+        self.root.panic_strategy.clone()\n     }\n }"}, {"sha": "3e4a2542b270bc9f7b7bd3c22e56142b2f2dac21", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 903, "deletions": 1408, "changes": 2311, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -10,1637 +10,1132 @@\n \n // Decoding metadata from a single crate's metadata\n \n-#![allow(non_camel_case_types)]\n-\n-use self::Family::*;\n-\n use astencode::decode_inlined_item;\n-use cstore::{self, CrateMetadata};\n-use common::*;\n-use def_key;\n-use encoder::def_to_u64;\n-use index;\n-use tls_context;\n-use tydecode::TyDecoder;\n-\n-use rustc::hir::def_id::CRATE_DEF_INDEX;\n-use rustc::hir::svh::Svh;\n+use cstore::{self, CrateMetadata, MetadataBlob, NativeLibraryKind};\n+use index::Index;\n+use schema::*;\n+\n use rustc::hir::map as hir_map;\n-use rustc::hir::map::DefKey;\n+use rustc::hir::map::{DefKey, DefPathData};\n use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n-use rustc::session::config::PanicStrategy;\n+use rustc::hir::intravisit::IdRange;\n \n-use middle::cstore::{InlinedItem, LinkagePreference};\n-use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::{DefId, DefIndex};\n-use middle::lang_items;\n-use rustc::ty::{ImplContainer, TraitContainer};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, VariantKind};\n+use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n+use rustc::hir::def::{self, Def};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use rustc::middle::lang_items;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n \n use rustc_const_math::ConstInt;\n \n-use rustc::mir;\n-use rustc::mir::visit::MutVisitor;\n-use rustc::mir::repr::Location;\n+use rustc::mir::repr::Mir;\n \n-use std::cell::Cell;\n+use std::cell::Ref;\n use std::io;\n+use std::mem;\n use std::rc::Rc;\n use std::str;\n+use std::u32;\n \n-use rbml::reader;\n-use rbml;\n-use rustc_serialize::Decodable;\n+use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n-use syntax::parse::token;\n-use syntax::ast;\n+use syntax::ast::{self, NodeId};\n use syntax::codemap;\n-use syntax::print::pprust;\n-use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n+use syntax_pos::{self, Span, BytePos, Pos};\n \n-pub type Cmd<'a> = &'a CrateMetadata;\n+pub struct DecodeContext<'a, 'tcx: 'a> {\n+    opaque: opaque::Decoder<'a>,\n+    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    cdata: Option<&'a CrateMetadata>,\n+    from_id_range: IdRange,\n+    to_id_range: IdRange,\n \n-impl CrateMetadata {\n-    fn get_item(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n-        self.index.lookup_item(self.data(), item_id).map(|pos| {\n-            reader::doc_at(self.data(), pos as usize).unwrap().doc\n-        })\n-    }\n+    // Cache the last used filemap for translating spans as an optimization.\n+    last_filemap_index: usize,\n \n-    fn lookup_item(&self, item_id: DefIndex) -> rbml::Doc {\n-        match self.get_item(item_id) {\n-            None => bug!(\"lookup_item: id not found: {:?} in crate {:?} with number {}\",\n-                         item_id,\n-                         self.name,\n-                         self.cnum),\n-            Some(d) => d\n-        }\n-    }\n+    lazy_state: LazyState\n }\n \n-pub fn load_index(data: &[u8]) -> index::Index {\n-    let index = reader::get_doc(rbml::Doc::new(data), tag_index);\n-    index::Index::from_rbml(index)\n-}\n+/// Abstract over the various ways one can create metadata decoders.\n+pub trait Metadata<'a, 'tcx>: Copy {\n+    fn raw_bytes(self) -> &'a [u8];\n+    fn cdata(self) -> Option<&'a CrateMetadata> { None }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n \n-pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n-    let doc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(doc, tag_rustc_version).map(|s| s.to_string())\n+    fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n+        let id_range = IdRange {\n+            min: NodeId::from_u32(u32::MIN),\n+            max: NodeId::from_u32(u32::MAX)\n+        };\n+        DecodeContext {\n+            opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n+            cdata: self.cdata(),\n+            tcx: self.tcx(),\n+            from_id_range: id_range,\n+            to_id_range: id_range,\n+            last_filemap_index: 0,\n+            lazy_state: LazyState::NoNode\n+        }\n+    }\n }\n \n-pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n-    let index = reader::get_doc(rbml::Doc::new(data), tag_xref_index);\n-    index::DenseIndex::from_buf(index.data, index.start, index.end)\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n+    fn raw_bytes(self) -> &'a [u8] {\n+        match *self {\n+            MetadataBlob::Inflated(ref vec) => &vec[..],\n+            MetadataBlob::Archive(ref ar) => ar.as_slice(),\n+        }\n+    }\n }\n \n-// Go through each item in the metadata and create a map from that\n-// item's def-key to the item's DefIndex.\n-pub fn load_key_map(data: &[u8]) -> FnvHashMap<DefKey, DefIndex> {\n-    let root_doc = rbml::Doc::new(data);\n-    let items_doc = reader::get_doc(root_doc, tag_items);\n-    let items_data_doc = reader::get_doc(items_doc, tag_items_data);\n-    reader::docs(items_data_doc)\n-        .filter(|&(tag, _)| tag == tag_items_data_item)\n-        .map(|(_, item_doc)| {\n-            // load def-key from item\n-            let key = item_def_key(item_doc);\n-\n-            // load def-index from item; we only encode the full def-id,\n-            // so just pull out the index\n-            let def_id_doc = reader::get_doc(item_doc, tag_def_id);\n-            let def_id = untranslated_def_id(def_id_doc);\n-            assert!(def_id.is_local()); // local to the crate we are decoding, that is\n-\n-            (key, def_id.index)\n-        })\n-        .collect()\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n+    fn raw_bytes(self) -> &'a [u8] { self.blob.raw_bytes() }\n+    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self) }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq)]\n-enum Family {\n-    ImmStatic,             // c\n-    MutStatic,             // b\n-    Fn,                    // f\n-    StaticMethod,          // F\n-    Method,                // h\n-    Type,                  // y\n-    Mod,                   // m\n-    ForeignMod,            // n\n-    Enum,                  // t\n-    Variant(VariantKind),  // V, v, w\n-    Impl,                  // i\n-    DefaultImpl,           // d\n-    Trait,                 // I\n-    Struct(VariantKind),   // S, s, u\n-    Union,                 // U\n-    PublicField,           // g\n-    InheritedField,        // N\n-    Constant,              // C\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>) {\n+    fn raw_bytes(self) -> &'a [u8] { self.0.raw_bytes() }\n+    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self.0) }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { Some(self.1) }\n }\n \n-fn item_family(item: rbml::Doc) -> Family {\n-    let fam = reader::get_doc(item, tag_items_data_item_family);\n-    match reader::doc_as_u8(fam) as char {\n-      'C' => Constant,\n-      'c' => ImmStatic,\n-      'b' => MutStatic,\n-      'f' => Fn,\n-      'F' => StaticMethod,\n-      'h' => Method,\n-      'y' => Type,\n-      'm' => Mod,\n-      'n' => ForeignMod,\n-      't' => Enum,\n-      'V' => Variant(VariantKind::Struct),\n-      'v' => Variant(VariantKind::Tuple),\n-      'w' => Variant(VariantKind::Unit),\n-      'i' => Impl,\n-      'd' => DefaultImpl,\n-      'I' => Trait,\n-      'S' => Struct(VariantKind::Struct),\n-      's' => Struct(VariantKind::Tuple),\n-      'u' => Struct(VariantKind::Unit),\n-      'U' => Union,\n-      'g' => PublicField,\n-      'N' => InheritedField,\n-       c => bug!(\"unexpected family char: {}\", c)\n+// HACK(eddyb) Only used by astencode to customize the from/to IdRange's.\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>, [IdRange; 2]) {\n+    fn raw_bytes(self) -> &'a [u8] { self.0.raw_bytes() }\n+    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self.0) }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { Some(self.1) }\n+\n+    fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n+        let mut dcx = (self.0, self.1).decoder(pos);\n+        dcx.from_id_range = self.2[0];\n+        dcx.to_id_range = self.2[1];\n+        dcx\n     }\n }\n \n-fn item_visibility(item: rbml::Doc) -> ty::Visibility {\n-    match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n-        None => ty::Visibility::Public,\n-        Some(visibility_doc) => {\n-            match reader::doc_as_u8(visibility_doc) as char {\n-                'y' => ty::Visibility::Public,\n-                'i' => ty::Visibility::PrivateExternal,\n-                _ => bug!(\"unknown visibility character\")\n-            }\n-        }\n+impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n+    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n+        let mut dcx = meta.decoder(self.position);\n+        dcx.lazy_state = LazyState::NodeStart(self.position);\n+        T::decode(&mut dcx).unwrap()\n     }\n }\n \n-fn fn_constness(item: rbml::Doc) -> hir::Constness {\n-    match reader::maybe_get_doc(item, tag_items_data_item_constness) {\n-        None => hir::Constness::NotConst,\n-        Some(constness_doc) => {\n-            match reader::doc_as_u8(constness_doc) as char {\n-                'c' => hir::Constness::Const,\n-                'n' => hir::Constness::NotConst,\n-                _ => bug!(\"unknown constness character\")\n-            }\n-        }\n+impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n+    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> impl Iterator<Item=T> + 'a {\n+        let mut dcx = meta.decoder(self.position);\n+        dcx.lazy_state = LazyState::NodeStart(self.position);\n+        (0..self.len).map(move |_| {\n+            T::decode(&mut dcx).unwrap()\n+        })\n     }\n }\n \n-fn item_defaultness(item: rbml::Doc) -> hir::Defaultness {\n-    match reader::maybe_get_doc(item, tag_items_data_item_defaultness) {\n-        None => hir::Defaultness::Default, // should occur only for default impls on traits\n-        Some(defaultness_doc) => {\n-            match reader::doc_as_u8(defaultness_doc) as char {\n-                'd' => hir::Defaultness::Default,\n-                'f' => hir::Defaultness::Final,\n-                _ => bug!(\"unknown defaultness character\")\n-            }\n-        }\n+impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n-}\n \n-fn item_sort(item: rbml::Doc) -> Option<char> {\n-    reader::tagged_docs(item, tag_item_trait_item_sort).nth(0).map(|doc| {\n-        doc.as_str().as_bytes()[0] as char\n-    })\n-}\n+    pub fn cdata(&self) -> &'a CrateMetadata {\n+        self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n+    }\n \n-fn untranslated_def_id(d: rbml::Doc) -> DefId {\n-    let id = reader::doc_as_u64(d);\n-    let index = DefIndex::new((id & 0xFFFF_FFFF) as usize);\n-    DefId { krate: (id >> 32) as u32, index: index }\n-}\n+    fn with_position<F: FnOnce(&mut Self) -> R, R>(&mut self, pos: usize, f: F) -> R {\n+        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n+        let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n+        let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);\n+        let r = f(self);\n+        self.opaque = old_opaque;\n+        self.lazy_state = old_state;\n+        r\n+    }\n \n-fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n-    let def_id = untranslated_def_id(d);\n-    translate_def_id(cdata, def_id)\n+    fn read_lazy_distance(&mut self, min_size: usize)\n+                          -> Result<usize, <Self as Decoder>::Error> {\n+        let distance = self.read_usize()?;\n+        let position = match self.lazy_state {\n+            LazyState::NoNode => {\n+                bug!(\"read_lazy_distance: outside of a metadata node\")\n+            }\n+            LazyState::NodeStart(start) => {\n+                assert!(distance + min_size <= start);\n+                start - distance - min_size\n+            }\n+            LazyState::Previous(last_min_end) => {\n+                last_min_end + distance\n+            }\n+        };\n+        self.lazy_state = LazyState::Previous(position + min_size);\n+        Ok(position)\n+    }\n }\n \n-fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<DefId> {\n-    reader::tagged_docs(d, tag_items_data_parent_item).nth(0).map(|did| {\n-        translated_def_id(cdata, did)\n-    })\n+macro_rules! decoder_methods {\n+    ($($name:ident -> $ty:ty;)*) => {\n+        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n+            self.opaque.$name()\n+        })*\n+    }\n }\n \n-fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> DefId {\n-    translated_def_id(cdata, reader::get_doc(d, tag_items_data_parent_item))\n-}\n+impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n+    type Error = <opaque::Decoder<'doc> as Decoder>::Error;\n \n-fn item_def_id(d: rbml::Doc, cdata: Cmd) -> DefId {\n-    translated_def_id(cdata, reader::get_doc(d, tag_def_id))\n-}\n+    decoder_methods! {\n+        read_nil -> ();\n \n-fn reexports<'a>(d: rbml::Doc<'a>) -> reader::TaggedDocsIterator<'a> {\n-    reader::tagged_docs(d, tag_items_data_item_reexport)\n-}\n+        read_u64 -> u64;\n+        read_u32 -> u32;\n+        read_u16 -> u16;\n+        read_u8 -> u8;\n+        read_usize -> usize;\n \n-fn variant_disr_val(d: rbml::Doc) -> u64 {\n-    let val_doc = reader::get_doc(d, tag_disr_val);\n-    reader::with_doc_data(val_doc, |data| {\n-        str::from_utf8(data).unwrap().parse().unwrap()\n-    })\n-}\n+        read_i64 -> i64;\n+        read_i32 -> i32;\n+        read_i16 -> i16;\n+        read_i8 -> i8;\n+        read_isize -> isize;\n \n-fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n-    let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                        &mut |did| translate_def_id(cdata, did))\n-        .parse_ty()\n-}\n+        read_bool -> bool;\n+        read_f64 -> f64;\n+        read_f32 -> f32;\n+        read_char -> char;\n+        read_str -> String;\n+    }\n \n-fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n-                            -> Option<Ty<'tcx>> {\n-    reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n-        TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                            &mut |did| translate_def_id(cdata, did))\n-            .parse_ty()\n-    })\n+    fn error(&mut self, err: &str) -> Self::Error {\n+        self.opaque.error(err)\n+    }\n }\n \n-fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n-                           -> ty::TraitRef<'tcx> {\n-    TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                        &mut |did| translate_def_id(cdata, did))\n-        .parse_trait_ref()\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n+        Ok(Lazy::with_position(self.read_lazy_distance(Lazy::<T>::min_size())?))\n+    }\n }\n \n-fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n-                            -> ty::TraitRef<'tcx> {\n-    let tp = reader::get_doc(doc, tag_item_trait_ref);\n-    doc_trait_ref(tp, tcx, cdata)\n+impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<LazySeq<T>, Self::Error> {\n+        let len = self.read_usize()?;\n+        let position = if len == 0 {\n+            0\n+        } else {\n+            self.read_lazy_distance(LazySeq::<T>::min_size(len))?\n+        };\n+        Ok(LazySeq::with_position_and_length(position, len))\n+    }\n }\n \n-fn item_name(item: rbml::Doc) -> ast::Name {\n-    maybe_item_name(item).expect(\"no item in item_name\")\n-}\n+impl<'a, 'tcx> SpecializedDecoder<NodeId> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n+        let id = u32::decode(self)?;\n \n-fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n-    reader::maybe_get_doc(item, tag_paths_data_name).map(|name| {\n-        let string = name.as_str();\n-        token::intern(string)\n-    })\n-}\n+        // from_id_range should be non-empty\n+        assert!(!self.from_id_range.empty());\n+        // Make sure that translating the NodeId will actually yield a\n+        // meaningful result\n+        if !self.from_id_range.contains(NodeId::from_u32(id)) {\n+            bug!(\"NodeId::decode: {} out of DecodeContext range ({:?} -> {:?})\",\n+                 id, self.from_id_range, self.to_id_range);\n+        }\n \n-fn family_to_variant_kind<'tcx>(family: Family) -> Option<ty::VariantKind> {\n-    match family {\n-        Struct(VariantKind::Struct) | Variant(VariantKind::Struct) | Union =>\n-            Some(ty::VariantKind::Struct),\n-        Struct(VariantKind::Tuple) | Variant(VariantKind::Tuple) =>\n-            Some(ty::VariantKind::Tuple),\n-        Struct(VariantKind::Unit) | Variant(VariantKind::Unit) =>\n-            Some(ty::VariantKind::Unit),\n-        _ => None,\n+        // Use wrapping arithmetic because otherwise it introduces control flow.\n+        // Maybe we should just have the control flow? -- aatch\n+        Ok(NodeId::from_u32(id.wrapping_sub(self.from_id_range.min.as_u32())\n+                              .wrapping_add(self.to_id_range.min.as_u32())))\n     }\n }\n \n-fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: DefId) -> DefLike {\n-    let fam = item_family(item);\n-    match fam {\n-        Constant  => {\n-            // Check whether we have an associated const item.\n-            match item_sort(item) {\n-                Some('C') | Some('c') => {\n-                    DlDef(Def::AssociatedConst(did))\n-                }\n-                _ => {\n-                    // Regular const item.\n-                    DlDef(Def::Const(did))\n-                }\n-            }\n-        }\n-        ImmStatic => DlDef(Def::Static(did, false)),\n-        MutStatic => DlDef(Def::Static(did, true)),\n-        Struct(..) => DlDef(Def::Struct(did)),\n-        Union => DlDef(Def::Union(did)),\n-        Fn        => DlDef(Def::Fn(did)),\n-        Method | StaticMethod => {\n-            DlDef(Def::Method(did))\n-        }\n-        Type => {\n-            if item_sort(item) == Some('t') {\n-                let trait_did = item_require_parent_item(cdata, item);\n-                DlDef(Def::AssociatedTy(trait_did, did))\n-            } else {\n-                DlDef(Def::TyAlias(did))\n-            }\n-        }\n-        Mod => DlDef(Def::Mod(did)),\n-        ForeignMod => DlDef(Def::ForeignMod(did)),\n-        Variant(..) => {\n-            let enum_did = item_require_parent_item(cdata, item);\n-            DlDef(Def::Variant(enum_did, did))\n+impl<'a, 'tcx> SpecializedDecoder<CrateNum> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n+        let cnum = CrateNum::from_u32(u32::decode(self)?);\n+        if cnum == LOCAL_CRATE {\n+            Ok(self.cdata().cnum)\n+        } else {\n+            Ok(self.cdata().cnum_map.borrow()[cnum])\n         }\n-        Trait => DlDef(Def::Trait(did)),\n-        Enum => DlDef(Def::Enum(did)),\n-        Impl | DefaultImpl => DlImpl(did),\n-        PublicField | InheritedField => DlField,\n     }\n }\n \n-fn parse_unsafety(item_doc: rbml::Doc) -> hir::Unsafety {\n-    let unsafety_doc = reader::get_doc(item_doc, tag_unsafety);\n-    if reader::doc_as_u8(unsafety_doc) != 0 {\n-        hir::Unsafety::Unsafe\n-    } else {\n-        hir::Unsafety::Normal\n-    }\n-}\n+impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n+        let lo = BytePos::decode(self)?;\n+        let hi = BytePos::decode(self)?;\n \n-fn parse_paren_sugar(item_doc: rbml::Doc) -> bool {\n-    let paren_sugar_doc = reader::get_doc(item_doc, tag_paren_sugar);\n-    reader::doc_as_u8(paren_sugar_doc) != 0\n-}\n+        let tcx = if let Some(tcx) = self.tcx {\n+            tcx\n+        } else {\n+            return Ok(syntax_pos::mk_sp(lo, hi));\n+        };\n \n-fn parse_polarity(item_doc: rbml::Doc) -> hir::ImplPolarity {\n-    let polarity_doc = reader::get_doc(item_doc, tag_polarity);\n-    if reader::doc_as_u8(polarity_doc) != 0 {\n-        hir::ImplPolarity::Negative\n-    } else {\n-        hir::ImplPolarity::Positive\n-    }\n-}\n+        let (lo, hi) = if lo > hi {\n+            // Currently macro expansion sometimes produces invalid Span values\n+            // where lo > hi. In order not to crash the compiler when trying to\n+            // translate these values, let's transform them into something we\n+            // can handle (and which will produce useful debug locations at\n+            // least some of the time).\n+            // This workaround is only necessary as long as macro expansion is\n+            // not fixed. FIXME(#23480)\n+            (lo, lo)\n+        } else {\n+            (lo, hi)\n+        };\n \n-fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n-    let names_doc = reader::get_doc(item_doc, tag_associated_type_names);\n-    reader::tagged_docs(names_doc, tag_associated_type_name)\n-        .map(|name_doc| token::intern(name_doc.as_str()))\n-        .collect()\n-}\n+        let imported_filemaps = self.cdata().imported_filemaps(&tcx.sess.codemap());\n+        let filemap = {\n+            // Optimize for the case that most spans within a translated item\n+            // originate from the same filemap.\n+            let last_filemap = &imported_filemaps[self.last_filemap_index];\n+\n+            if lo >= last_filemap.original_start_pos &&\n+            lo <= last_filemap.original_end_pos &&\n+            hi >= last_filemap.original_start_pos &&\n+            hi <= last_filemap.original_end_pos {\n+                last_filemap\n+            } else {\n+                let mut a = 0;\n+                let mut b = imported_filemaps.len();\n \n-pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n-                               item_id: DefIndex,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(item_id);\n-    let generics = doc_generics(item_doc, tcx, cdata);\n-    let unsafety = parse_unsafety(item_doc);\n-    let associated_type_names = parse_associated_type_names(item_doc);\n-    let paren_sugar = parse_paren_sugar(item_doc);\n-    let def_path = def_path(cdata, item_id).unwrap();\n-\n-    ty::TraitDef::new(unsafety,\n-                      paren_sugar,\n-                      generics,\n-                      item_trait_ref(item_doc, tcx, cdata),\n-                      associated_type_names,\n-                      def_path.deterministic_hash(tcx))\n-}\n+                while b - a > 1 {\n+                    let m = (a + b) / 2;\n+                    if imported_filemaps[m].original_start_pos > lo {\n+                        b = m;\n+                    } else {\n+                        a = m;\n+                    }\n+                }\n \n-pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n-                             item_id: DefIndex,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                             -> ty::AdtDefMaster<'tcx>\n-{\n-    fn expect_variant_kind(family: Family) -> ty::VariantKind {\n-        match family_to_variant_kind(family) {\n-            Some(kind) => kind,\n-            _ => bug!(\"unexpected family: {:?}\", family),\n-        }\n-    }\n-    fn get_enum_variants<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n-        reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n-            let did = translated_def_id(cdata, p);\n-            let item = cdata.lookup_item(did.index);\n-            let disr = variant_disr_val(item);\n-            ty::VariantDefData {\n-                did: did,\n-                name: item_name(item),\n-                fields: get_variant_fields(cdata, item),\n-                disr_val: ConstInt::Infer(disr),\n-                kind: expect_variant_kind(item_family(item)),\n+                self.last_filemap_index = a;\n+                &imported_filemaps[a]\n             }\n-        }).collect()\n-    }\n-    fn get_variant_fields<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n-        let mut index = 0;\n-        reader::tagged_docs(doc, tag_item_field).map(|f| {\n-            let ff = item_family(f);\n-            match ff {\n-                PublicField | InheritedField => {},\n-                _ => bug!(\"expected field, found {:?}\", ff)\n-            };\n-            ty::FieldDefData::new(item_def_id(f, cdata),\n-                                  item_name(f),\n-                                  struct_field_family_to_visibility(ff))\n-        }).chain(reader::tagged_docs(doc, tag_item_unnamed_field).map(|f| {\n-            let ff = item_family(f);\n-            let name = token::with_ident_interner(|interner| interner.intern(index.to_string()));\n-            index += 1;\n-            ty::FieldDefData::new(item_def_id(f, cdata), name,\n-                                  struct_field_family_to_visibility(ff))\n-        })).collect()\n-    }\n-    fn get_struct_variant<'tcx>(cdata: Cmd,\n-                                doc: rbml::Doc,\n-                                did: DefId) -> ty::VariantDefData<'tcx, 'tcx> {\n-        ty::VariantDefData {\n-            did: did,\n-            name: item_name(doc),\n-            fields: get_variant_fields(cdata, doc),\n-            disr_val: ConstInt::Infer(0),\n-            kind: expect_variant_kind(item_family(doc)),\n-        }\n+        };\n+\n+        let lo = (lo - filemap.original_start_pos) +\n+                  filemap.translated_filemap.start_pos;\n+        let hi = (hi - filemap.original_start_pos) +\n+                  filemap.translated_filemap.start_pos;\n+\n+        Ok(syntax_pos::mk_sp(lo, hi))\n     }\n+}\n \n-    let doc = cdata.lookup_item(item_id);\n-    let did = DefId { krate: cdata.cnum, index: item_id };\n-    let mut ctor_did = None;\n-    let (kind, variants) = match item_family(doc) {\n-        Enum => {\n-            (AdtKind::Enum, get_enum_variants(cdata, doc))\n-        }\n-        Struct(..) => {\n-            // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n-            ctor_did = reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n-                translated_def_id(cdata, ctor_doc)\n-            });\n-            (AdtKind::Struct, vec![get_struct_variant(cdata, doc, ctor_did.unwrap_or(did))])\n-        }\n-        Union => {\n-            (AdtKind::Union, vec![get_struct_variant(cdata, doc, did)])\n-        }\n-        _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\", item_family(doc), did)\n-    };\n-\n-    let adt = tcx.intern_adt_def(did, kind, variants);\n-    if let Some(ctor_did) = ctor_did {\n-        // Make adt definition available through constructor id as well.\n-        tcx.insert_adt_def(ctor_did, adt);\n-    }\n-\n-    // this needs to be done *after* the variant is interned,\n-    // to support recursive structures\n-    for variant in &adt.variants {\n-        if variant.kind == ty::VariantKind::Tuple && adt.is_enum() {\n-            // tuple-like enum variant fields aren't real items - get the types\n-            // from the ctor.\n-            debug!(\"evaluating the ctor-type of {:?}\",\n-                   variant.name);\n-            let ctor_ty = get_type(cdata, variant.did.index, tcx);\n-            debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n-                   variant.name,\n-                   ctor_ty);\n-            let field_tys = match ctor_ty.sty {\n-                ty::TyFnDef(.., &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-                    ref inputs, ..\n-                }), ..}) => {\n-                    // tuple-struct constructors don't have escaping regions\n-                    assert!(!inputs.has_escaping_regions());\n-                    inputs\n-                },\n-                _ => bug!(\"tuple-variant ctor is not an ADT\")\n+// FIXME(#36588) These impls are horribly unsound as they allow\n+// the caller to pick any lifetime for 'tcx, including 'static,\n+// by using the unspecialized proxies to them.\n+\n+impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n+        let tcx = self.tcx();\n+\n+        // Handle shorthands first, if we have an usize > 0x80.\n+        if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n+            let pos = self.read_usize()?;\n+            assert!(pos >= SHORTHAND_OFFSET);\n+            let key = ty::CReaderCacheKey {\n+                cnum: self.cdata().cnum,\n+                pos: pos - SHORTHAND_OFFSET\n             };\n-            for (field, &ty) in variant.fields.iter().zip(field_tys.iter()) {\n-                field.fulfill_ty(ty);\n+            if let Some(ty) = tcx.rcache.borrow().get(&key).cloned() {\n+                return Ok(ty);\n             }\n+\n+            let ty = self.with_position(key.pos, Ty::decode)?;\n+            tcx.rcache.borrow_mut().insert(key, ty);\n+            Ok(ty)\n         } else {\n-            for field in &variant.fields {\n-                debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n-                let ty = get_type(cdata, field.did.index, tcx);\n-                field.fulfill_ty(ty);\n-                debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n-                       variant.name, field.name, ty);\n-            }\n+            Ok(tcx.mk_ty(ty::TypeVariants::decode(self)?))\n         }\n     }\n-\n-    adt\n }\n \n-pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n-                                item_id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                -> ty::GenericPredicates<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(item_id);\n-    doc_predicates(item_doc, tcx, cdata, tag_item_predicates)\n-}\n \n-pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n-                                      item_id: DefIndex,\n-                                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                      -> ty::GenericPredicates<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(item_id);\n-    doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n-}\n+impl<'a, 'tcx> SpecializedDecoder<ty::GenericPredicates<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ty::GenericPredicates<'tcx>, Self::Error> {\n+        Ok(ty::GenericPredicates {\n+            parent: Decodable::decode(self)?,\n+            predicates: (0..self.read_usize()?).map(|_| {\n+                // Handle shorthands first, if we have an usize > 0x80.\n+                if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n+                    let pos = self.read_usize()?;\n+                    assert!(pos >= SHORTHAND_OFFSET);\n+                    let pos = pos - SHORTHAND_OFFSET;\n \n-pub fn get_generics<'a, 'tcx>(cdata: Cmd,\n-                              item_id: DefIndex,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                              -> &'tcx ty::Generics<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(item_id);\n-    doc_generics(item_doc, tcx, cdata)\n+                    self.with_position(pos, ty::Predicate::decode)\n+                } else {\n+                    ty::Predicate::decode(self)\n+                }\n+            }).collect::<Result<Vec<_>, _>>()?\n+        })\n+    }\n }\n \n-pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> Ty<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(id);\n-    doc_type(item_doc, tcx, cdata)\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n+        Ok(self.tcx().mk_substs(Decodable::decode(self)?))\n+    }\n }\n \n-pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n-    let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, tag_items_data_item_stability).map(|doc| {\n-        let mut decoder = reader::Decoder::new(doc);\n-        Decodable::decode(&mut decoder).unwrap()\n-    })\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Region> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Region, Self::Error> {\n+        Ok(self.tcx().mk_region(Decodable::decode(self)?))\n+    }\n }\n \n-pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n-    let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, tag_items_data_item_deprecation).map(|doc| {\n-        let mut decoder = reader::Decoder::new(doc);\n-        Decodable::decode(&mut decoder).unwrap()\n-    })\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n+        Ok(self.tcx().mk_type_list(Decodable::decode(self)?))\n+    }\n }\n \n-pub fn get_visibility(cdata: Cmd, id: DefIndex) -> ty::Visibility {\n-    item_visibility(cdata.lookup_item(id))\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::BareFnTy<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::BareFnTy<'tcx>, Self::Error> {\n+        Ok(self.tcx().mk_bare_fn(Decodable::decode(self)?))\n+    }\n }\n \n-pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n-    let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, tag_items_data_parent_impl).map(|doc| {\n-        translated_def_id(cdata, doc)\n-    })\n+impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ty::AdtDef<'tcx>, Self::Error> {\n+        let def_id = DefId::decode(self)?;\n+        Ok(self.tcx().lookup_adt_def(def_id))\n+    }\n }\n \n-pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n-    let item = cdata.lookup_item(id);\n-    match reader::maybe_get_doc(item, tag_items_data_item_repr).map(|doc| {\n-        let mut decoder = reader::Decoder::new(doc);\n-        Decodable::decode(&mut decoder).unwrap()\n-    }) {\n-        Some(attrs) => attrs,\n-        None => Vec::new(),\n+impl<'a, 'tcx> MetadataBlob {\n+    pub fn is_compatible(&self) -> bool {\n+        self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n-}\n \n-pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n-                               id: DefIndex)\n-                               -> Option<hir::ImplPolarity>\n-{\n-    let item_doc = cdata.lookup_item(id);\n-    let fam = item_family(item_doc);\n-    match fam {\n-        Family::Impl => {\n-            Some(parse_polarity(item_doc))\n-        }\n-        _ => None\n+    pub fn get_root(&self) -> CrateRoot {\n+        let slice = self.raw_bytes();\n+        let offset = METADATA_HEADER.len();\n+        let pos = (((slice[offset + 0] as u32) << 24) |\n+                   ((slice[offset + 1] as u32) << 16) |\n+                   ((slice[offset + 2] as u32) << 8) |\n+                   ((slice[offset + 3] as u32) << 0)) as usize;\n+        Lazy::with_position(pos).decode(self)\n     }\n-}\n \n-pub fn get_custom_coerce_unsized_kind<'tcx>(\n-    cdata: Cmd,\n-    id: DefIndex)\n-    -> Option<ty::adjustment::CustomCoerceUnsized>\n-{\n-    let item_doc = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n-        let mut decoder = reader::Decoder::new(kind_doc);\n-        Decodable::decode(&mut decoder).unwrap()\n-    })\n-}\n+    /// Go through each item in the metadata and create a map from that\n+    /// item's def-key to the item's DefIndex.\n+    pub fn load_key_map(&self, index: LazySeq<Index>) -> FnvHashMap<DefKey, DefIndex> {\n+        index.iter_enumerated(self.raw_bytes()).map(|(index, item)| {\n+            (item.decode(self).def_key.decode(self), index)\n+        }).collect()\n+    }\n \n-pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n-                                id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                -> Option<ty::TraitRef<'tcx>>\n-{\n-    let item_doc = cdata.lookup_item(id);\n-    let fam = item_family(item_doc);\n-    match fam {\n-        Family::Impl | Family::DefaultImpl => {\n-            reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-                doc_trait_ref(tp, tcx, cdata)\n-            })\n+    pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n+        write!(out, \"=External Dependencies=\\n\")?;\n+        let root = self.get_root();\n+        for (i, dep) in root.crate_deps.decode(self).enumerate() {\n+            write!(out, \"{} {}-{}\\n\", i + 1, dep.name, dep.hash)?;\n         }\n-        _ => None\n+        write!(out, \"\\n\")?;\n+        Ok(())\n     }\n }\n \n-/// Iterates over the language items in the given crate.\n-pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n-    F: FnMut(DefIndex, usize) -> bool,\n-{\n-    let root = rbml::Doc::new(cdata.data());\n-    let lang_items = reader::get_doc(root, tag_lang_items);\n-    reader::tagged_docs(lang_items, tag_lang_items_item).all(|item_doc| {\n-        let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n-        let id = reader::doc_as_u32(id_doc) as usize;\n-        let index_doc = reader::get_doc(item_doc, tag_lang_items_item_index);\n-        let index = DefIndex::from_u32(reader::doc_as_u32(index_doc));\n-\n-        f(index, id)\n-    })\n+impl<'tcx> EntryKind<'tcx> {\n+    fn to_def(&self, did: DefId) -> Option<Def> {\n+        Some(match *self {\n+            EntryKind::Const  => Def::Const(did),\n+            EntryKind::AssociatedConst(_) => Def::AssociatedConst(did),\n+            EntryKind::ImmStatic |\n+            EntryKind::ForeignImmStatic => Def::Static(did, false),\n+            EntryKind::MutStatic |\n+            EntryKind::ForeignMutStatic => Def::Static(did, true),\n+            EntryKind::Struct(_) => Def::Struct(did),\n+            EntryKind::Union(_) => Def::Union(did),\n+            EntryKind::Fn(_) |\n+            EntryKind::ForeignFn(_) => Def::Fn(did),\n+            EntryKind::Method(_) => Def::Method(did),\n+            EntryKind::Type => Def::TyAlias(did),\n+            EntryKind::AssociatedType(_) => Def::AssociatedTy(did),\n+            EntryKind::Mod(_) => Def::Mod(did),\n+            EntryKind::Variant(_) => Def::Variant(did),\n+            EntryKind::Trait(_) => Def::Trait(did),\n+            EntryKind::Enum => Def::Enum(did),\n+\n+            EntryKind::ForeignMod |\n+            EntryKind::Impl(_) |\n+            EntryKind::DefaultImpl(_) |\n+            EntryKind::Field |\n+            EntryKind::Closure (_) => {\n+                return None\n+            }\n+        })\n+    }\n }\n \n-fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n-                                     item_doc: rbml::Doc,\n-                                     mut get_crate_data: G,\n-                                     mut callback: F) where\n-    F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n-{\n-    // Iterate over all children.\n-    for child_info_doc in reader::tagged_docs(item_doc, tag_mod_child) {\n-        let child_def_id = translated_def_id(cdata, child_info_doc);\n-\n-        // This item may be in yet another crate if it was the child of a\n-        // reexport.\n-        let crate_data = if child_def_id.krate == cdata.cnum {\n-            None\n-        } else {\n-            Some(get_crate_data(child_def_id.krate))\n-        };\n-        let crate_data = match crate_data {\n-            Some(ref cdata) => &**cdata,\n-            None => cdata\n-        };\n+impl<'a, 'tcx> CrateMetadata {\n+    fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n+        self.root.index.lookup(self.blob.raw_bytes(), item_id)\n+    }\n \n-        // Get the item.\n-        if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n-            // Hand off the item to the callback.\n-            let child_name = item_name(child_item_doc);\n-            let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n-            let visibility = item_visibility(child_item_doc);\n-            callback(def_like, child_name, visibility);\n+    fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n+        match self.maybe_entry(item_id) {\n+            None => bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n+                         item_id,\n+                         self.name,\n+                         self.cnum),\n+            Some(d) => d.decode(self)\n         }\n     }\n \n-    for reexport_doc in reexports(item_doc) {\n-        let def_id_doc = reader::get_doc(reexport_doc,\n-                                         tag_items_data_item_reexport_def_id);\n-        let child_def_id = translated_def_id(cdata, def_id_doc);\n-\n-        let name_doc = reader::get_doc(reexport_doc,\n-                                       tag_items_data_item_reexport_name);\n-        let name = name_doc.as_str();\n-\n-        // This reexport may be in yet another crate.\n-        let crate_data = if child_def_id.krate == cdata.cnum {\n-            None\n-        } else {\n-            Some(get_crate_data(child_def_id.krate))\n-        };\n-        let crate_data = match crate_data {\n-            Some(ref cdata) => &**cdata,\n-            None => cdata\n-        };\n-\n-        // Get the item.\n-        if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n-            // Hand off the item to the callback.\n-            let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n-            // These items have a public visibility because they're part of\n-            // a public re-export.\n-            callback(def_like, token::intern(name), ty::Visibility::Public);\n+    fn local_def_id(&self, index: DefIndex) -> DefId {\n+        DefId {\n+            krate: self.cnum,\n+            index: index\n         }\n     }\n-}\n \n-/// Iterates over each child of the given item.\n-pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex, get_crate_data: G, callback: F)\n-    where F: FnMut(DefLike, ast::Name, ty::Visibility),\n-          G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n-{\n-    // Find the item.\n-    let item_doc = match cdata.get_item(id) {\n-        None => return,\n-        Some(item_doc) => item_doc,\n-    };\n-\n-    each_child_of_item_or_crate(cdata, item_doc, get_crate_data, callback)\n-}\n-\n-/// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate<F, G>(cdata: Cmd, get_crate_data: G, callback: F)\n-    where F: FnMut(DefLike, ast::Name, ty::Visibility),\n-          G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n-{\n-    each_child_of_item(cdata, CRATE_DEF_INDEX, get_crate_data, callback)\n-}\n-\n-pub fn get_item_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n-    item_name(cdata.lookup_item(id))\n-}\n-\n-pub fn maybe_get_item_name(cdata: Cmd, id: DefIndex) -> Option<ast::Name> {\n-    maybe_item_name(cdata.lookup_item(id))\n-}\n-\n-pub enum FoundAst<'ast> {\n-    Found(&'ast InlinedItem),\n-    FoundParent(DefId, &'ast hir::Item),\n-    NotFound,\n-}\n-\n-pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n-                                    -> FoundAst<'tcx> {\n-    debug!(\"Looking up item: {:?}\", id);\n-    let item_doc = cdata.lookup_item(id);\n-    let item_did = item_def_id(item_doc, cdata);\n-    let parent_def_id = DefId {\n-        krate: cdata.cnum,\n-        index: def_key(cdata, id).parent.unwrap()\n-    };\n-    let mut parent_def_path = def_path(cdata, id).unwrap();\n-    parent_def_path.data.pop();\n-    if let Some(ast_doc) = reader::maybe_get_doc(item_doc, tag_ast as usize) {\n-        let ii = decode_inlined_item(cdata,\n-                                     tcx,\n-                                     parent_def_path,\n-                                     parent_def_id,\n-                                     ast_doc,\n-                                     item_did);\n-        return FoundAst::Found(ii);\n-    } else if let Some(parent_did) = item_parent_item(cdata, item_doc) {\n-        // Remove the last element from the paths, since we are now\n-        // trying to inline the parent.\n-        let grandparent_def_id = DefId {\n-            krate: cdata.cnum,\n-            index: def_key(cdata, parent_def_id.index).parent.unwrap()\n-        };\n-        let mut grandparent_def_path = parent_def_path;\n-        grandparent_def_path.data.pop();\n-        let parent_doc = cdata.lookup_item(parent_did.index);\n-        if let Some(ast_doc) = reader::maybe_get_doc(parent_doc, tag_ast as usize) {\n-            let ii = decode_inlined_item(cdata,\n-                                         tcx,\n-                                         grandparent_def_path,\n-                                         grandparent_def_id,\n-                                         ast_doc,\n-                                         parent_did);\n-            if let &InlinedItem::Item(_, ref i) = ii {\n-                return FoundAst::FoundParent(parent_did, i);\n-            }\n-        }\n+    fn item_name(&self, item: &Entry<'tcx>) -> ast::Name {\n+        item.def_key.decode(self).disambiguated_data.data.get_opt_name()\n+            .expect(\"no name in item_name\")\n     }\n-    FoundAst::NotFound\n-}\n \n-pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n-    if let Some(item_doc) = cdata.get_item(id) {\n-        return reader::maybe_get_doc(item_doc, tag_mir as usize).is_some();\n+    pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n+        self.entry(index).kind.to_def(self.local_def_id(index))\n     }\n \n-    false\n-}\n+    pub fn get_trait_def(&self,\n+                         item_id: DefIndex,\n+                         tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx> {\n+        let data = match self.entry(item_id).kind {\n+            EntryKind::Trait(data) => data.decode(self),\n+            _ => bug!()\n+        };\n \n-pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n-                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    id: DefIndex)\n-                                    -> Option<mir::repr::Mir<'tcx>> {\n-    let item_doc = cdata.lookup_item(id);\n+        ty::TraitDef::new(data.unsafety, data.paren_sugar,\n+                          tcx.lookup_generics(self.local_def_id(item_id)),\n+                          data.trait_ref.decode((self, tcx)),\n+                          self.def_path(item_id).unwrap().deterministic_hash(tcx))\n+    }\n \n-    return reader::maybe_get_doc(item_doc, tag_mir as usize).map(|mir_doc| {\n-        let dcx = tls_context::DecodingContext {\n-            crate_metadata: cdata,\n-            tcx: tcx,\n+    fn get_variant(&self, item: &Entry<'tcx>, index: DefIndex)\n+                   -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n+        let data = match item.kind {\n+            EntryKind::Variant(data) |\n+            EntryKind::Struct(data) |\n+            EntryKind::Union(data) => data.decode(self),\n+            _ => bug!()\n         };\n-        let mut decoder = reader::Decoder::new(mir_doc);\n \n-        let mut mir = decoder.read_opaque(|opaque_decoder, _| {\n-            tls::enter_decoding_context(&dcx, opaque_decoder, |_, opaque_decoder| {\n-                Decodable::decode(opaque_decoder)\n-            })\n-        }).unwrap();\n-\n-        assert!(decoder.position() == mir_doc.end);\n+        let fields = item.children.decode(self).map(|index| {\n+            let f = self.entry(index);\n+            ty::FieldDefData::new(self.local_def_id(index),\n+                                  self.item_name(&f),\n+                                  f.visibility)\n+        }).collect();\n+\n+        (ty::VariantDefData {\n+            did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n+            name: self.item_name(item),\n+            fields: fields,\n+            disr_val: ConstInt::Infer(data.disr),\n+            kind: data.kind,\n+        }, data.struct_ctor)\n+    }\n \n-        let mut def_id_and_span_translator = MirDefIdAndSpanTranslator {\n-            crate_metadata: cdata,\n-            codemap: tcx.sess.codemap(),\n-            last_filemap_index_hint: Cell::new(0),\n+    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                       -> ty::AdtDefMaster<'tcx> {\n+        let item = self.entry(item_id);\n+        let did = self.local_def_id(item_id);\n+        let mut ctor_index = None;\n+        let variants = if let EntryKind::Enum = item.kind {\n+            item.children.decode(self).map(|index| {\n+                let (variant, struct_ctor) = self.get_variant(&self.entry(index), index);\n+                assert_eq!(struct_ctor, None);\n+                variant\n+            }).collect()\n+        } else{\n+            let (variant, struct_ctor) = self.get_variant(&item, item_id);\n+            ctor_index = struct_ctor;\n+            vec![variant]\n+        };\n+        let kind = match item.kind {\n+            EntryKind::Enum => ty::AdtKind::Enum,\n+            EntryKind::Struct(_) => ty::AdtKind::Struct,\n+            EntryKind::Union(_) => ty::AdtKind::Union,\n+            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did)\n         };\n \n-        def_id_and_span_translator.visit_mir(&mut mir);\n-        for promoted in &mut mir.promoted {\n-            def_id_and_span_translator.visit_mir(promoted);\n+        let adt = tcx.intern_adt_def(did, kind, variants);\n+        if let Some(ctor_index) = ctor_index {\n+            // Make adt definition available through constructor id as well.\n+            tcx.insert_adt_def(self.local_def_id(ctor_index), adt);\n         }\n \n-        mir\n-    });\n+        // this needs to be done *after* the variant is interned,\n+        // to support recursive structures\n+        for variant in &adt.variants {\n+            for field in &variant.fields {\n+                debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n+                let ty = self.get_type(field.did.index, tcx);\n+                field.fulfill_ty(ty);\n+                debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n+                       variant.name, field.name, ty);\n+            }\n+        }\n \n-    struct MirDefIdAndSpanTranslator<'cdata, 'codemap> {\n-        crate_metadata: Cmd<'cdata>,\n-        codemap: &'codemap codemap::CodeMap,\n-        last_filemap_index_hint: Cell<usize>\n+        adt\n     }\n \n-    impl<'v, 'cdata, 'codemap> mir::visit::MutVisitor<'v>\n-        for MirDefIdAndSpanTranslator<'cdata, 'codemap>\n-    {\n-        fn visit_def_id(&mut self, def_id: &mut DefId, _: Location) {\n-            *def_id = translate_def_id(self.crate_metadata, *def_id);\n-        }\n-\n-        fn visit_span(&mut self, span: &mut Span) {\n-            *span = translate_span(self.crate_metadata,\n-                                   self.codemap,\n-                                   &self.last_filemap_index_hint,\n-                                   *span);\n-        }\n+    pub fn get_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> ty::GenericPredicates<'tcx> {\n+        self.entry(item_id).predicates.unwrap().decode((self, tcx))\n     }\n-}\n \n-fn get_explicit_self<'a, 'tcx>(item: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                               -> ty::ExplicitSelfCategory<'tcx> {\n-    fn get_mutability(ch: u8) -> hir::Mutability {\n-        match ch as char {\n-            'i' => hir::MutImmutable,\n-            'm' => hir::MutMutable,\n-            _ => bug!(\"unknown mutability character: `{}`\", ch as char),\n+    pub fn get_super_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                -> ty::GenericPredicates<'tcx> {\n+        match self.entry(item_id).kind {\n+            EntryKind::Trait(data) => {\n+                data.decode(self).super_predicates.decode((self, tcx))\n+            }\n+            _ => bug!()\n         }\n     }\n \n-    let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n-    let string = explicit_self_doc.as_str();\n+    pub fn get_generics(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                        -> ty::Generics<'tcx> {\n+        self.entry(item_id).generics.unwrap().decode((self, tcx))\n+    }\n \n-    let explicit_self_kind = string.as_bytes()[0];\n-    match explicit_self_kind as char {\n-        's' => ty::ExplicitSelfCategory::Static,\n-        'v' => ty::ExplicitSelfCategory::ByValue,\n-        '~' => ty::ExplicitSelfCategory::ByBox,\n-        // FIXME(#4846) expl. region\n-        '&' => {\n-            ty::ExplicitSelfCategory::ByReference(\n-                tcx.mk_region(ty::ReEmpty),\n-                get_mutability(string.as_bytes()[1]))\n-        }\n-        _ => bug!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n+    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        self.entry(id).ty.unwrap().decode((self, tcx))\n     }\n-}\n \n-/// Returns the def IDs of all the items in the given implementation.\n-pub fn get_impl_items(cdata: Cmd, impl_id: DefIndex)\n-                      -> Vec<ty::ImplOrTraitItemId> {\n-    reader::tagged_docs(cdata.lookup_item(impl_id), tag_item_impl_item).map(|doc| {\n-        let def_id = item_def_id(doc, cdata);\n-        match item_sort(doc) {\n-            Some('C') | Some('c') => ty::ConstTraitItemId(def_id),\n-            Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n-            Some('t') => ty::TypeTraitItemId(def_id),\n-            _ => bug!(\"unknown impl item sort\"),\n-        }\n-    }).collect()\n-}\n+    pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+        self.entry(id).stability.map(|stab| stab.decode(self))\n+    }\n \n-pub fn get_trait_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n-    let doc = cdata.lookup_item(id);\n-    item_name(doc)\n-}\n+    pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+        self.entry(id).deprecation.map(|depr| depr.decode(self))\n+    }\n \n-pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                        -> Option<ty::ImplOrTraitItem<'tcx>> {\n-    let item_doc = cdata.lookup_item(id);\n-\n-    let def_id = item_def_id(item_doc, cdata);\n-\n-    let container_id = if let Some(id) = item_parent_item(cdata, item_doc) {\n-        id\n-    } else {\n-        return None;\n-    };\n-    let container_doc = cdata.lookup_item(container_id.index);\n-    let container = match item_family(container_doc) {\n-        Trait => TraitContainer(container_id),\n-        _ => ImplContainer(container_id),\n-    };\n-\n-    let name = item_name(item_doc);\n-    let vis = item_visibility(item_doc);\n-    let defaultness = item_defaultness(item_doc);\n-\n-    Some(match item_sort(item_doc) {\n-        sort @ Some('C') | sort @ Some('c') => {\n-            let ty = doc_type(item_doc, tcx, cdata);\n-            ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n-                name: name,\n-                ty: ty,\n-                vis: vis,\n-                defaultness: defaultness,\n-                def_id: def_id,\n-                container: container,\n-                has_value: sort == Some('C')\n-            }))\n-        }\n-        Some('r') | Some('p') => {\n-            let generics = doc_generics(item_doc, tcx, cdata);\n-            let predicates = doc_predicates(item_doc, tcx, cdata, tag_item_predicates);\n-            let ity = tcx.lookup_item_type(def_id).ty;\n-            let fty = match ity.sty {\n-                ty::TyFnDef(.., fty) => fty,\n-                _ => bug!(\n-                    \"the type {:?} of the method {:?} is not a function?\",\n-                    ity, name)\n-            };\n-            let explicit_self = get_explicit_self(item_doc, tcx);\n-\n-            ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n-                                                        generics,\n-                                                        predicates,\n-                                                        fty,\n-                                                        explicit_self,\n-                                                        vis,\n-                                                        defaultness,\n-                                                        def_id,\n-                                                        container)))\n-        }\n-        Some('t') => {\n-            let ty = maybe_doc_type(item_doc, tcx, cdata);\n-            ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n-                name: name,\n-                ty: ty,\n-                vis: vis,\n-                defaultness: defaultness,\n-                def_id: def_id,\n-                container: container,\n-            }))\n-        }\n-        _ => return None\n-    })\n-}\n+    pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+        self.entry(id).visibility\n+    }\n \n-pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n-                              -> Vec<ty::ImplOrTraitItemId> {\n-    let item = cdata.lookup_item(id);\n-    reader::tagged_docs(item, tag_item_trait_item).map(|mth| {\n-        let def_id = item_def_id(mth, cdata);\n-        match item_sort(mth) {\n-            Some('C') | Some('c') => ty::ConstTraitItemId(def_id),\n-            Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n-            Some('t') => ty::TypeTraitItemId(def_id),\n-            _ => bug!(\"unknown trait item sort\"),\n+    fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n+        match self.entry(id).kind {\n+            EntryKind::Impl(data) => data.decode(self),\n+            _ => bug!()\n         }\n-    }).collect()\n-}\n+    }\n \n-pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> Vec<ty::Variance> {\n-    let item_doc = cdata.lookup_item(id);\n-    let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n-    let mut decoder = reader::Decoder::new(variance_doc);\n-    Decodable::decode(&mut decoder).unwrap()\n-}\n+    pub fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+        self.get_impl_data(id).parent_impl\n+    }\n \n-pub fn get_provided_trait_methods<'a, 'tcx>(cdata: Cmd,\n-                                            id: DefIndex,\n-                                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                            -> Vec<Rc<ty::Method<'tcx>>> {\n-    let item = cdata.lookup_item(id);\n+    pub fn get_impl_polarity(&self, id: DefIndex) -> hir::ImplPolarity {\n+        self.get_impl_data(id).polarity\n+    }\n \n-    reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n-        let did = item_def_id(mth_id, cdata);\n-        let mth = cdata.lookup_item(did.index);\n+    pub fn get_custom_coerce_unsized_kind(&self, id: DefIndex)\n+                                          -> Option<ty::adjustment::CustomCoerceUnsized> {\n+        self.get_impl_data(id).coerce_unsized_kind\n+    }\n \n-        if item_sort(mth) == Some('p') {\n-            let trait_item = get_impl_or_trait_item(cdata, did.index, tcx);\n-            if let Some(ty::MethodTraitItem(ref method)) = trait_item {\n-                Some((*method).clone())\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    }).collect()\n-}\n+    pub fn get_impl_trait(&self,\n+                          id: DefIndex,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> Option<ty::TraitRef<'tcx>> {\n+        self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n+    }\n \n-pub fn get_associated_consts<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                       -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n-    let item = cdata.lookup_item(id);\n+    /// Iterates over the language items in the given crate.\n+    pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n+        self.root.lang_items.decode(self).collect()\n+    }\n \n-    [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n-        reader::tagged_docs(item, tag).filter_map(|ac_id| {\n-            let did = item_def_id(ac_id, cdata);\n-            let ac_doc = cdata.lookup_item(did.index);\n+    /// Iterates over each child of the given item.\n+    pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F)\n+        where F: FnMut(def::Export)\n+    {\n+        // Find the item.\n+        let item = match self.maybe_entry(id) {\n+            None => return,\n+            Some(item) => item.decode(self),\n+        };\n \n-            match item_sort(ac_doc) {\n-                Some('C') | Some('c') => {\n-                    let trait_item = get_impl_or_trait_item(cdata, did.index, tcx);\n-                    if let Some(ty::ConstTraitItem(ref ac)) = trait_item {\n-                        Some((*ac).clone())\n-                    } else {\n-                        None\n+        // Iterate over all children.\n+        for child_index in item.children.decode(self) {\n+            // Get the item.\n+            if let Some(child) = self.maybe_entry(child_index) {\n+                let child = child.decode(self);\n+                // Hand off the item to the callback.\n+                match child.kind {\n+                    // FIXME(eddyb) Don't encode these in children.\n+                    EntryKind::ForeignMod => {\n+                        for child_index in child.children.decode(self) {\n+                            callback(def::Export {\n+                                def_id: self.local_def_id(child_index),\n+                                name: self.item_name(&self.entry(child_index))\n+                            });\n+                        }\n+                        continue;\n                     }\n+                    EntryKind::Impl(_) | EntryKind::DefaultImpl(_) => continue,\n+\n+                    _ => {}\n+                }\n+\n+                let def_key = child.def_key.decode(self);\n+                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                    callback(def::Export {\n+                        def_id: self.local_def_id(child_index),\n+                        name: name\n+                    });\n                 }\n-                _ => None\n             }\n-        })\n-    }).collect()\n-}\n+        }\n \n-pub fn get_variant_kind(cdata: Cmd, node_id: DefIndex) -> Option<VariantKind>\n-{\n-    let item = cdata.lookup_item(node_id);\n-    family_to_variant_kind(item_family(item))\n-}\n+        if let EntryKind::Mod(data) = item.kind {\n+            for exp in data.decode(self).reexports.decode(self) {\n+                callback(exp);\n+            }\n+        }\n+    }\n \n-pub fn get_struct_ctor_def_id(cdata: Cmd, node_id: DefIndex) -> Option<DefId>\n-{\n-    let item = cdata.lookup_item(node_id);\n-    reader::maybe_get_doc(item, tag_items_data_item_struct_ctor).\n-        map(|ctor_doc| translated_def_id(cdata, ctor_doc))\n-}\n+    pub fn maybe_get_item_ast(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+                              -> Option<&'tcx InlinedItem> {\n+        debug!(\"Looking up item: {:?}\", id);\n+        let item_doc = self.entry(id);\n+        let item_did = self.local_def_id(id);\n+        let parent_def_id = self.local_def_id(self.def_key(id).parent.unwrap());\n+        let mut parent_def_path = self.def_path(id).unwrap();\n+        parent_def_path.data.pop();\n+        item_doc.ast.map(|ast| {\n+            let ast = ast.decode(self);\n+            decode_inlined_item(self, tcx, parent_def_path, parent_def_id, ast, item_did)\n+        })\n+    }\n \n-/// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n-/// the actual type definition, otherwise, return None\n-pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n-                                           node_id: DefIndex)\n-    -> Option<DefId>\n-{\n-    let item = cdata.lookup_item(node_id);\n-    reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor).next().map(|_| {\n-        item_require_parent_item(cdata, item)\n-    })\n-}\n+    pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+        self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n+    }\n \n-pub fn get_item_attrs(cdata: Cmd,\n-                      orig_node_id: DefIndex)\n-                      -> Vec<ast::Attribute> {\n-    // The attributes for a tuple struct are attached to the definition, not the ctor;\n-    // we assume that someone passing in a tuple struct ctor is actually wanting to\n-    // look at the definition\n-    let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n-    let node_id = node_id.map(|x| x.index).unwrap_or(orig_node_id);\n-    let item = cdata.lookup_item(node_id);\n-    get_attributes(item)\n-}\n+    pub fn maybe_get_item_mir(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+                              -> Option<Mir<'tcx>> {\n+        self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n+    }\n \n-pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<DefId, Vec<ast::Attribute>> {\n-    let data = rbml::Doc::new(cdata.data());\n-    let fields = reader::get_doc(data, tag_struct_fields);\n-    reader::tagged_docs(fields, tag_struct_field).map(|field| {\n-        let def_id = translated_def_id(cdata, reader::get_doc(field, tag_def_id));\n-        let attrs = get_attributes(field);\n-        (def_id, attrs)\n-    }).collect()\n-}\n+    pub fn get_impl_or_trait_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                  -> Option<ty::ImplOrTraitItem<'tcx>> {\n+        let item = self.entry(id);\n+        let parent_and_name = || {\n+            let def_key = item.def_key.decode(self);\n+            (self.local_def_id(def_key.parent.unwrap()),\n+             def_key.disambiguated_data.data.get_opt_name().unwrap())\n+        };\n \n-fn struct_field_family_to_visibility(family: Family) -> ty::Visibility {\n-    match family {\n-        PublicField => ty::Visibility::Public,\n-        InheritedField => ty::Visibility::PrivateExternal,\n-        _ => bug!()\n+        Some(match item.kind {\n+            EntryKind::AssociatedConst(container) => {\n+                let (parent, name) = parent_and_name();\n+                ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n+                    name: name,\n+                    ty: item.ty.unwrap().decode((self, tcx)),\n+                    vis: item.visibility,\n+                    defaultness: container.defaultness(),\n+                    def_id: self.local_def_id(id),\n+                    container: container.with_def_id(parent),\n+                    has_value: container.has_body(),\n+                }))\n+            }\n+            EntryKind::Method(data) => {\n+                let (parent, name) = parent_and_name();\n+                let ity = item.ty.unwrap().decode((self, tcx));\n+                let fty = match ity.sty {\n+                    ty::TyFnDef(.., fty) => fty,\n+                    _ => bug!(\n+                        \"the type {:?} of the method {:?} is not a function?\",\n+                        ity, name)\n+                };\n+\n+                let data = data.decode(self);\n+                ty::MethodTraitItem(Rc::new(ty::Method {\n+                    name: name,\n+                    generics: tcx.lookup_generics(self.local_def_id(id)),\n+                    predicates: item.predicates.unwrap().decode((self, tcx)),\n+                    fty: fty,\n+                    explicit_self: data.explicit_self.decode((self, tcx)),\n+                    vis: item.visibility,\n+                    defaultness: data.container.defaultness(),\n+                    has_body: data.container.has_body(),\n+                    def_id: self.local_def_id(id),\n+                    container: data.container.with_def_id(parent),\n+                }))\n+            }\n+            EntryKind::AssociatedType(container) => {\n+                let (parent, name) = parent_and_name();\n+                ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n+                    name: name,\n+                    ty: item.ty.map(|ty| ty.decode((self, tcx))),\n+                    vis: item.visibility,\n+                    defaultness: container.defaultness(),\n+                    def_id: self.local_def_id(id),\n+                    container: container.with_def_id(parent),\n+                }))\n+            }\n+            _ => return None\n+        })\n     }\n-}\n-\n-pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n-    let item = cdata.lookup_item(id);\n-    let mut index = 0;\n-    reader::tagged_docs(item, tag_item_field).map(|an_item| {\n-        item_name(an_item)\n-    }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|_| {\n-        let name = token::with_ident_interner(|interner| interner.intern(index.to_string()));\n-        index += 1;\n-        name\n-    })).collect()\n-}\n \n-fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n-    reader::maybe_get_doc(md, tag_attributes).map_or(vec![], |attrs_doc| {\n-        let mut decoder = reader::Decoder::new(attrs_doc);\n-        let mut attrs: Vec<ast::Attribute> = decoder.read_opaque(|opaque_decoder, _| {\n-            Decodable::decode(opaque_decoder)\n-        }).unwrap();\n+    pub fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n+        self.entry(id).variances.decode(self).collect()\n+    }\n \n-        // Need new unique IDs: old thread-local IDs won't map to new threads.\n-        for attr in attrs.iter_mut() {\n-            attr.node.id = attr::mk_attr_id();\n+    pub fn get_variant_kind(&self, node_id: DefIndex) -> Option<ty::VariantKind> {\n+        match self.entry(node_id).kind {\n+            EntryKind::Struct(data) |\n+            EntryKind::Union(data) |\n+            EntryKind::Variant(data) => Some(data.decode(self).kind),\n+            _ => None\n         }\n-\n-        attrs\n-    })\n-}\n-\n-fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n-                         out: &mut io::Write) -> io::Result<()> {\n-    write!(out, \"=Crate Attributes ({})=\\n\", *hash)?;\n-\n-    let r = get_attributes(md);\n-    for attr in &r {\n-        write!(out, \"{}\\n\", pprust::attribute_to_string(attr))?;\n     }\n \n-    write!(out, \"\\n\\n\")\n-}\n-\n-pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n-    get_attributes(rbml::Doc::new(data))\n-}\n-\n-#[derive(Clone)]\n-pub struct CrateDep {\n-    pub cnum: ast::CrateNum,\n-    pub name: String,\n-    pub hash: Svh,\n-    pub explicitly_linked: bool,\n-}\n-\n-pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n-    let cratedoc = rbml::Doc::new(data);\n-    let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n-\n-    fn docstr(doc: rbml::Doc, tag_: usize) -> String {\n-        let d = reader::get_doc(doc, tag_);\n-        d.as_str().to_string()\n-    }\n-\n-    reader::tagged_docs(depsdoc, tag_crate_dep).enumerate().map(|(crate_num, depdoc)| {\n-        let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(reader::doc_as_u64(reader::get_doc(depdoc, tag_crate_dep_hash)));\n-        let doc = reader::get_doc(depdoc, tag_crate_dep_explicitly_linked);\n-        let explicitly_linked = reader::doc_as_u8(doc) != 0;\n-        CrateDep {\n-            cnum: crate_num as u32 + 1,\n-            name: name,\n-            hash: hash,\n-            explicitly_linked: explicitly_linked,\n+    pub fn get_struct_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+        match self.entry(node_id).kind {\n+            EntryKind::Struct(data) => {\n+                data.decode(self).struct_ctor.map(|index| self.local_def_id(index))\n+            }\n+            _ => None\n         }\n-    }).collect()\n-}\n-\n-fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n-    write!(out, \"=External Dependencies=\\n\")?;\n-    for dep in &get_crate_deps(data) {\n-        write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash)?;\n     }\n-    write!(out, \"\\n\")?;\n-    Ok(())\n-}\n-\n-pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n-    let cratedoc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n-        Svh::new(reader::doc_as_u64(doc))\n-    })\n-}\n-\n-pub fn get_crate_hash(data: &[u8]) -> Svh {\n-    let cratedoc = rbml::Doc::new(data);\n-    let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    Svh::new(reader::doc_as_u64(hashdoc))\n-}\n \n-pub fn maybe_get_crate_name(data: &[u8]) -> Option<&str> {\n-    let cratedoc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(cratedoc, tag_crate_crate_name).map(|doc| {\n-        doc.as_str()\n-    })\n-}\n-\n-pub fn get_crate_disambiguator<'a>(data: &'a [u8]) -> &'a str {\n-    let crate_doc = rbml::Doc::new(data);\n-    let disambiguator_doc = reader::get_doc(crate_doc, tag_crate_disambiguator);\n-    let slice: &'a str = disambiguator_doc.as_str();\n-    slice\n-}\n-\n-pub fn get_crate_triple(data: &[u8]) -> Option<String> {\n-    let cratedoc = rbml::Doc::new(data);\n-    let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n-    triple_doc.map(|s| s.as_str().to_string())\n-}\n-\n-pub fn get_crate_name(data: &[u8]) -> &str {\n-    maybe_get_crate_name(data).expect(\"no crate name in crate\")\n-}\n-\n-pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()> {\n-    let hash = get_crate_hash(bytes);\n-    let md = rbml::Doc::new(bytes);\n-    list_crate_attributes(md, &hash, out)?;\n-    list_crate_deps(bytes, out)\n-}\n-\n-// Translates a def_id from an external crate to a def_id for the current\n-// compilation environment. We use this when trying to load types from\n-// external crates - if those types further refer to types in other crates\n-// then we must translate the crate number from that encoded in the external\n-// crate to the correct local crate number.\n-pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n-    if did.is_local() {\n-        return DefId { krate: cdata.cnum, index: did.index };\n+    pub fn get_item_attrs(&self, node_id: DefIndex) -> Vec<ast::Attribute> {\n+        // The attributes for a tuple struct are attached to the definition, not the ctor;\n+        // we assume that someone passing in a tuple struct ctor is actually wanting to\n+        // look at the definition\n+        let mut item = self.entry(node_id);\n+        let def_key = item.def_key.decode(self);\n+        if def_key.disambiguated_data.data == DefPathData::StructCtor {\n+            item = self.entry(def_key.parent.unwrap());\n+        }\n+        self.get_attributes(&item)\n     }\n \n-    DefId {\n-        krate: cdata.cnum_map.borrow()[did.krate],\n-        index: did.index\n+    pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+        self.entry(id).children.decode(self).map(|index| {\n+            self.item_name(&self.entry(index))\n+        }).collect()\n     }\n-}\n \n-// Translate a DefId from the current compilation environment to a DefId\n-// for an external crate.\n-fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n-    for (local, &global) in cdata.cnum_map.borrow().iter_enumerated() {\n-        if global == did.krate {\n-            return Some(DefId { krate: local, index: did.index });\n-        }\n+    fn get_attributes(&self, item: &Entry<'tcx>) -> Vec<ast::Attribute> {\n+        item.attributes.decode(self).map(|mut attr| {\n+            // Need new unique IDs: old thread-local IDs won't map to new threads.\n+            attr.node.id = attr::mk_attr_id();\n+            attr\n+        }).collect()\n     }\n \n-    None\n-}\n-\n-/// Translates a `Span` from an extern crate to the corresponding `Span`\n-/// within the local crate's codemap.\n-pub fn translate_span(cdata: Cmd,\n-                      codemap: &codemap::CodeMap,\n-                      last_filemap_index_hint: &Cell<usize>,\n-                      span: syntax_pos::Span)\n-                      -> syntax_pos::Span {\n-    let span = if span.lo > span.hi {\n-        // Currently macro expansion sometimes produces invalid Span values\n-        // where lo > hi. In order not to crash the compiler when trying to\n-        // translate these values, let's transform them into something we\n-        // can handle (and which will produce useful debug locations at\n-        // least some of the time).\n-        // This workaround is only necessary as long as macro expansion is\n-        // not fixed. FIXME(#23480)\n-        syntax_pos::mk_sp(span.lo, span.lo)\n-    } else {\n-        span\n-    };\n-\n-    let imported_filemaps = cdata.imported_filemaps(&codemap);\n-    let filemap = {\n-        // Optimize for the case that most spans within a translated item\n-        // originate from the same filemap.\n-        let last_filemap_index = last_filemap_index_hint.get();\n-        let last_filemap = &imported_filemaps[last_filemap_index];\n-\n-        if span.lo >= last_filemap.original_start_pos &&\n-           span.lo <= last_filemap.original_end_pos &&\n-           span.hi >= last_filemap.original_start_pos &&\n-           span.hi <= last_filemap.original_end_pos {\n-            last_filemap\n-        } else {\n-            let mut a = 0;\n-            let mut b = imported_filemaps.len();\n-\n-            while b - a > 1 {\n-                let m = (a + b) / 2;\n-                if imported_filemaps[m].original_start_pos > span.lo {\n-                    b = m;\n-                } else {\n-                    a = m;\n-                }\n+    // Translate a DefId from the current compilation environment to a DefId\n+    // for an external crate.\n+    fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n+        for (local, &global) in self.cnum_map.borrow().iter_enumerated() {\n+            if global == did.krate {\n+                return Some(DefId { krate: local, index: did.index });\n             }\n-\n-            last_filemap_index_hint.set(a);\n-            &imported_filemaps[a]\n         }\n-    };\n-\n-    let lo = (span.lo - filemap.original_start_pos) +\n-              filemap.translated_filemap.start_pos;\n-    let hi = (span.hi - filemap.original_start_pos) +\n-              filemap.translated_filemap.start_pos;\n \n-    syntax_pos::mk_sp(lo, hi)\n-}\n+        None\n+    }\n \n-pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n-                                                id: DefIndex,\n-                                                mut callback: F)\n-    where F: FnMut(DefId),\n-{\n-    let item_doc = cdata.lookup_item(id);\n-    for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl) {\n-        if reader::maybe_get_doc(impl_doc, tag_item_trait_ref).is_none() {\n-            callback(item_def_id(impl_doc, cdata));\n-        }\n+    pub fn get_inherent_implementations_for_type(&self, id: DefIndex) -> Vec<DefId> {\n+        self.entry(id).inherent_impls.decode(self).map(|index| {\n+            self.local_def_id(index)\n+        }).collect()\n     }\n-}\n \n-pub fn each_implementation_for_trait<F>(cdata: Cmd,\n-                                        def_id: DefId,\n-                                        mut callback: F) where\n-    F: FnMut(DefId),\n-{\n-    // Do a reverse lookup beforehand to avoid touching the crate_num\n-    // hash map in the loop below.\n-    if let Some(crate_local_did) = reverse_translate_def_id(cdata, def_id) {\n-        let def_id_u64 = def_to_u64(crate_local_did);\n-\n-        let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n-        for trait_doc in reader::tagged_docs(impls_doc, tag_impls_trait) {\n-            let trait_def_id = reader::get_doc(trait_doc, tag_def_id);\n-            if reader::doc_as_u64(trait_def_id) != def_id_u64 {\n+    pub fn get_implementations_for_trait(&self, filter: Option<DefId>, result: &mut Vec<DefId>) {\n+        // Do a reverse lookup beforehand to avoid touching the crate_num\n+        // hash map in the loop below.\n+        let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n+            Some(Some(def_id)) => Some((def_id.krate.as_u32(), def_id.index)),\n+            Some(None) => return,\n+            None => None\n+        };\n+\n+        // FIXME(eddyb) Make this O(1) instead of O(n).\n+        for trait_impls in self.root.impls.decode(self) {\n+            if filter.is_some() && filter != Some(trait_impls.trait_id) {\n                 continue;\n             }\n-            for impl_doc in reader::tagged_docs(trait_doc, tag_impls_trait_impl) {\n-                callback(translated_def_id(cdata, impl_doc));\n+\n+            result.extend(trait_impls.impls.decode(self).map(|index| {\n+                self.local_def_id(index)\n+            }));\n+\n+            if filter.is_some() {\n+                break;\n             }\n         }\n     }\n-}\n \n-pub fn get_trait_of_item(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n-    let item_doc = cdata.lookup_item(id);\n-    let parent_item_id = match item_parent_item(cdata, item_doc) {\n-        None => return None,\n-        Some(item_id) => item_id,\n-    };\n-    let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n-    match item_family(parent_item_doc) {\n-        Trait => Some(item_def_id(parent_item_doc, cdata)),\n-        _ => None\n+    pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+        self.entry(id).def_key.decode(self).parent.and_then(|parent_index| {\n+            match self.entry(parent_index).kind {\n+                EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n+                _ => None\n+            }\n+        })\n     }\n-}\n \n \n-pub fn get_native_libraries(cdata: Cmd)\n-                            -> Vec<(cstore::NativeLibraryKind, String)> {\n-    let libraries = reader::get_doc(rbml::Doc::new(cdata.data()),\n-                                    tag_native_libraries);\n-    reader::tagged_docs(libraries, tag_native_libraries_lib).map(|lib_doc| {\n-        let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n-        let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n-        let kind: cstore::NativeLibraryKind =\n-            cstore::NativeLibraryKind::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n-        let name = name_doc.as_str().to_string();\n-        (kind, name)\n-    }).collect()\n-}\n+    pub fn get_native_libraries(&self) -> Vec<(NativeLibraryKind, String)> {\n+        self.root.native_libraries.decode(self).collect()\n+    }\n \n-pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n-    reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n-        .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n-}\n+    pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n+        self.root.dylib_dependency_formats.decode(self).enumerate().flat_map(|(i, link)| {\n+            let cnum = CrateNum::new(i + 1);\n+            link.map(|link| (self.cnum_map.borrow()[cnum], link))\n+        }).collect()\n+    }\n \n-pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n-    F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n-{\n-    let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n-    for macro_doc in reader::tagged_docs(macros, tag_macro_def) {\n-        let name = item_name(macro_doc);\n-        let attrs = get_attributes(macro_doc);\n-        let span = get_macro_span(macro_doc);\n-        let body = reader::get_doc(macro_doc, tag_macro_def_body);\n-        if !f(name, attrs, span, body.as_str().to_string()) {\n-            break;\n-        }\n+    pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n+        self.root.lang_items_missing.decode(self).collect()\n     }\n-}\n \n-pub fn get_derive_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n-    reader::maybe_get_doc(rbml::Doc::new(data), tag_macro_derive_registrar)\n-        .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n-}\n+    pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+        let arg_names = match self.entry(id).kind {\n+            EntryKind::Fn(data) |\n+            EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n+            EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n+            _ => LazySeq::empty()\n+        };\n+        arg_names.decode(self).collect()\n+    }\n \n-pub fn get_macro_span(doc: rbml::Doc) -> Span {\n-    let lo_doc = reader::get_doc(doc, tag_macro_def_span_lo);\n-    let lo = BytePos(reader::doc_as_u32(lo_doc));\n-    let hi_doc = reader::get_doc(doc, tag_macro_def_span_hi);\n-    let hi = BytePos(reader::doc_as_u32(hi_doc));\n-    return Span { lo: lo, hi: hi, expn_id: NO_EXPANSION };\n-}\n+    pub fn get_reachable_ids(&self) -> Vec<DefId> {\n+        self.root.reachable_ids.decode(self).map(|index| self.local_def_id(index)).collect()\n+    }\n \n-pub fn get_dylib_dependency_formats(cdata: Cmd)\n-    -> Vec<(ast::CrateNum, LinkagePreference)>\n-{\n-    let formats = reader::get_doc(rbml::Doc::new(cdata.data()),\n-                                  tag_dylib_dependency_formats);\n-    let mut result = Vec::new();\n-\n-    debug!(\"found dylib deps: {}\", formats.as_str());\n-    for spec in formats.as_str().split(',') {\n-        if spec.is_empty() { continue }\n-        let mut split = spec.split(':');\n-        let cnum = split.next().unwrap();\n-        let link = split.next().unwrap();\n-        let cnum: ast::CrateNum = cnum.parse().unwrap();\n-        let cnum = cdata.cnum_map.borrow()[cnum];\n-        result.push((cnum, if link == \"d\" {\n-            LinkagePreference::RequireDynamic\n-        } else {\n-            LinkagePreference::RequireStatic\n-        }));\n+    pub fn is_const_fn(&self, id: DefIndex) -> bool {\n+        let constness = match self.entry(id).kind {\n+            EntryKind::Method(data) => data.decode(self).fn_data.constness,\n+            EntryKind::Fn(data) => data.decode(self).constness,\n+            _ => hir::Constness::NotConst\n+        };\n+        constness == hir::Constness::Const\n     }\n-    return result;\n-}\n \n-pub fn get_missing_lang_items(cdata: Cmd)\n-    -> Vec<lang_items::LangItem>\n-{\n-    let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_lang_items);\n-    reader::tagged_docs(items, tag_lang_items_missing).map(|missing_docs| {\n-        lang_items::LangItem::from_u32(reader::doc_as_u32(missing_docs)).unwrap()\n-    }).collect()\n-}\n+    pub fn is_extern_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        let item = match self.maybe_entry(id) {\n+            Some(item) => item.decode(self),\n+            None => return false,\n+        };\n+        let applicable = match item.kind {\n+            EntryKind::ImmStatic |\n+            EntryKind::MutStatic |\n+            EntryKind::ForeignImmStatic |\n+            EntryKind::ForeignMutStatic => true,\n+\n+            EntryKind::Fn(_) | EntryKind::ForeignFn(_) => {\n+                self.get_generics(id, tcx).types.is_empty()\n+            }\n \n-pub fn get_method_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n-    let method_doc = cdata.lookup_item(id);\n-    match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n-        Some(args_doc) => {\n-            reader::tagged_docs(args_doc, tag_method_argument_name).map(|name_doc| {\n-                name_doc.as_str().to_string()\n-            }).collect()\n-        },\n-        None => vec![],\n-    }\n-}\n+            _ => false,\n+        };\n \n-pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n-    let items = reader::get_doc(rbml::Doc::new(cdata.data()),\n-                                tag_reachable_ids);\n-    reader::tagged_docs(items, tag_reachable_id).map(|doc| {\n-        DefId {\n-            krate: cdata.cnum,\n-            index: DefIndex::from_u32(reader::doc_as_u32(doc)),\n+        if applicable {\n+            attr::contains_extern_indicator(tcx.sess.diagnostic(),\n+                                            &self.get_attributes(&item))\n+        } else {\n+            false\n         }\n-    }).collect()\n-}\n-\n-pub fn is_typedef(cdata: Cmd, id: DefIndex) -> bool {\n-    let item_doc = cdata.lookup_item(id);\n-    match item_family(item_doc) {\n-        Type => true,\n-        _ => false,\n     }\n-}\n \n-pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n-    let item_doc = cdata.lookup_item(id);\n-    match fn_constness(item_doc) {\n-        hir::Constness::Const => true,\n-        hir::Constness::NotConst => false,\n+    pub fn is_foreign_item(&self, id: DefIndex) -> bool {\n+        match self.entry(id).kind {\n+            EntryKind::ForeignImmStatic |\n+            EntryKind::ForeignMutStatic |\n+            EntryKind::ForeignFn(_) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n-                                id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                -> bool {\n-    let item_doc = match cdata.get_item(id) {\n-        Some(doc) => doc,\n-        None => return false,\n-    };\n-    let applicable = match item_family(item_doc) {\n-        ImmStatic | MutStatic => true,\n-        Fn => get_generics(cdata, id, tcx).types.is_empty(),\n-        _ => false,\n-    };\n-\n-    if applicable {\n-        attr::contains_extern_indicator(tcx.sess.diagnostic(),\n-                                        &get_attributes(item_doc))\n-    } else {\n-        false\n+    pub fn is_defaulted_trait(&self, trait_id: DefIndex) -> bool {\n+        match self.entry(trait_id).kind {\n+            EntryKind::Trait(data) => data.decode(self).has_default_impl,\n+            _ => bug!()\n+        }\n     }\n-}\n \n-pub fn is_foreign_item(cdata: Cmd, id: DefIndex) -> bool {\n-    let item_doc = cdata.lookup_item(id);\n-    let parent_item_id = match item_parent_item(cdata, item_doc) {\n-        None => return false,\n-        Some(item_id) => item_id,\n-    };\n-    let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n-    item_family(parent_item_doc) == ForeignMod\n-}\n+    pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n+        match self.entry(impl_id).kind  {\n+            EntryKind::DefaultImpl(_) => true,\n+            _ => false\n+        }\n+    }\n \n-pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n-    let item_doc = cdata.lookup_item(id);\n-    match item_family(item_doc) {\n-        Impl => true,\n-        _ => false,\n+    pub fn closure_kind(&self, closure_id: DefIndex) -> ty::ClosureKind {\n+        match self.entry(closure_id).kind {\n+            EntryKind::Closure(data) => data.decode(self).kind,\n+            _ => bug!()\n+        }\n     }\n-}\n \n-fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          cdata: Cmd)\n-                          -> &'tcx ty::Generics<'tcx>\n-{\n-    let doc = reader::get_doc(base_doc, tag_item_generics);\n-    TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                        &mut |did| translate_def_id(cdata, did))\n-        .parse_generics()\n-}\n+    pub fn closure_ty(&self, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                      -> ty::ClosureTy<'tcx> {\n+        match self.entry(closure_id).kind {\n+            EntryKind::Closure(data) => data.decode(self).ty.decode((self, tcx)),\n+            _ => bug!()\n+        }\n+    }\n \n-fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n-                           doc: rbml::Doc,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                           -> ty::Predicate<'tcx>\n-{\n-    let predicate_pos = cdata.xref_index.lookup(\n-        cdata.data(), reader::doc_as_u32(doc)).unwrap() as usize;\n-    TyDecoder::new(\n-        cdata.data(), cdata.cnum, predicate_pos, tcx,\n-        &mut |did| translate_def_id(cdata, did)\n-    ).parse_predicate()\n-}\n+    pub fn def_key(&self, id: DefIndex) -> hir_map::DefKey {\n+        debug!(\"def_key: id={:?}\", id);\n+        self.entry(id).def_key.decode(self)\n+    }\n \n-fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            cdata: Cmd,\n-                            tag: usize)\n-                            -> ty::GenericPredicates<'tcx>\n-{\n-    let doc = reader::get_doc(base_doc, tag);\n-\n-    ty::GenericPredicates {\n-        parent: item_parent_item(cdata, doc),\n-        predicates: reader::tagged_docs(doc, tag_predicate).map(|predicate_doc| {\n-            doc_predicate(cdata, predicate_doc, tcx)\n-        }).collect()\n+    // Returns the path leading to the thing with this `id`. Note that\n+    // some def-ids don't wind up in the metadata, so `def_path` sometimes\n+    // returns `None`\n+    pub fn def_path(&self, id: DefIndex) -> Option<hir_map::DefPath> {\n+        debug!(\"def_path(id={:?})\", id);\n+        if self.maybe_entry(id).is_some() {\n+            Some(hir_map::DefPath::make(self.cnum, id, |parent| self.def_key(parent)))\n+        } else {\n+            None\n+        }\n     }\n-}\n \n-pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {\n-    let trait_doc = cdata.lookup_item(trait_id);\n-    assert!(item_family(trait_doc) == Family::Trait);\n-    let defaulted_doc = reader::get_doc(trait_doc, tag_defaulted_trait);\n-    reader::doc_as_u8(defaulted_doc) != 0\n-}\n+    /// Imports the codemap from an external crate into the codemap of the crate\n+    /// currently being compiled (the \"local crate\").\n+    ///\n+    /// The import algorithm works analogous to how AST items are inlined from an\n+    /// external crate's metadata:\n+    /// For every FileMap in the external codemap an 'inline' copy is created in the\n+    /// local codemap. The correspondence relation between external and local\n+    /// FileMaps is recorded in the `ImportedFileMap` objects returned from this\n+    /// function. When an item from an external crate is later inlined into this\n+    /// crate, this correspondence information is used to translate the span\n+    /// information of the inlined item so that it refers the correct positions in\n+    /// the local codemap (see `<decoder::DecodeContext as SpecializedDecoder<Span>>`).\n+    ///\n+    /// The import algorithm in the function below will reuse FileMaps already\n+    /// existing in the local codemap. For example, even if the FileMap of some\n+    /// source file of libstd gets imported many times, there will only ever be\n+    /// one FileMap object for the corresponding file in the local codemap.\n+    ///\n+    /// Note that imported FileMaps do not actually contain the source code of the\n+    /// file they represent, just information about length, line breaks, and\n+    /// multibyte characters. This information is enough to generate valid debuginfo\n+    /// for items inlined from other crates.\n+    pub fn imported_filemaps(&'a self, local_codemap: &codemap::CodeMap)\n+                             -> Ref<'a, Vec<cstore::ImportedFileMap>> {\n+        {\n+            let filemaps = self.codemap_import_info.borrow();\n+            if !filemaps.is_empty() {\n+                return filemaps;\n+            }\n+        }\n \n-pub fn is_default_impl(cdata: Cmd, impl_id: DefIndex) -> bool {\n-    let impl_doc = cdata.lookup_item(impl_id);\n-    item_family(impl_doc) == Family::DefaultImpl\n-}\n+        let external_codemap = self.root.codemap.decode(self);\n+\n+        let imported_filemaps = external_codemap.map(|filemap_to_import| {\n+            // Try to find an existing FileMap that can be reused for the filemap to\n+            // be imported. A FileMap is reusable if it is exactly the same, just\n+            // positioned at a different offset within the codemap.\n+            let reusable_filemap = {\n+                local_codemap.files\n+                             .borrow()\n+                             .iter()\n+                             .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n+                             .map(|rc| rc.clone())\n+            };\n \n-pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<syntax_pos::FileMap> {\n-    let crate_doc = rbml::Doc::new(metadata);\n-    let cm_doc = reader::get_doc(crate_doc, tag_codemap);\n+            match reusable_filemap {\n+                Some(fm) => {\n+                    cstore::ImportedFileMap {\n+                        original_start_pos: filemap_to_import.start_pos,\n+                        original_end_pos: filemap_to_import.end_pos,\n+                        translated_filemap: fm\n+                    }\n+                }\n+                None => {\n+                    // We can't reuse an existing FileMap, so allocate a new one\n+                    // containing the information we need.\n+                    let syntax_pos::FileMap {\n+                        name,\n+                        abs_path,\n+                        start_pos,\n+                        end_pos,\n+                        lines,\n+                        multibyte_chars,\n+                        ..\n+                    } = filemap_to_import;\n+\n+                    let source_length = (end_pos - start_pos).to_usize();\n+\n+                    // Translate line-start positions and multibyte character\n+                    // position into frame of reference local to file.\n+                    // `CodeMap::new_imported_filemap()` will then translate those\n+                    // coordinates to their new global frame of reference when the\n+                    // offset of the FileMap is known.\n+                    let mut lines = lines.into_inner();\n+                    for pos in &mut lines {\n+                        *pos = *pos - start_pos;\n+                    }\n+                    let mut multibyte_chars = multibyte_chars.into_inner();\n+                    for mbc in &mut multibyte_chars {\n+                        mbc.pos = mbc.pos - start_pos;\n+                    }\n \n-    reader::tagged_docs(cm_doc, tag_codemap_filemap).map(|filemap_doc| {\n-        let mut decoder = reader::Decoder::new(filemap_doc);\n-        decoder.read_opaque(|opaque_decoder, _| {\n-            Decodable::decode(opaque_decoder)\n-        }).unwrap()\n-    }).collect()\n-}\n+                    let local_version = local_codemap.new_imported_filemap(name,\n+                                                                           abs_path,\n+                                                                           source_length,\n+                                                                           lines,\n+                                                                           multibyte_chars);\n+                    cstore::ImportedFileMap {\n+                        original_start_pos: start_pos,\n+                        original_end_pos: end_pos,\n+                        translated_filemap: local_version\n+                    }\n+                }\n+            }\n+        }).collect();\n \n-pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n-    let closure_doc = cdata.lookup_item(closure_id);\n-    let closure_kind_doc = reader::get_doc(closure_doc, tag_items_closure_kind);\n-    let mut decoder = reader::Decoder::new(closure_kind_doc);\n-    ty::ClosureKind::decode(&mut decoder).unwrap()\n+        // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n+        *self.codemap_import_info.borrow_mut() = imported_filemaps;\n+        self.codemap_import_info.borrow()\n+    }\n }\n \n-pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                            -> ty::ClosureTy<'tcx> {\n-    let closure_doc = cdata.lookup_item(closure_id);\n-    let closure_ty_doc = reader::get_doc(closure_doc, tag_items_closure_ty);\n-    TyDecoder::with_doc(tcx, cdata.cnum, closure_ty_doc, &mut |did| translate_def_id(cdata, did))\n-        .parse_closure_ty()\n-}\n+fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap, fm2: &syntax_pos::FileMap) -> bool {\n+    if fm1.name != fm2.name {\n+        return false;\n+    }\n \n-pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n-    debug!(\"def_key: id={:?}\", id);\n-    let item_doc = cdata.lookup_item(id);\n-    item_def_key(item_doc)\n-}\n+    let lines1 = fm1.lines.borrow();\n+    let lines2 = fm2.lines.borrow();\n \n-fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n-    match reader::maybe_get_doc(item_doc, tag_def_key) {\n-        Some(def_key_doc) => {\n-            let mut decoder = reader::Decoder::new(def_key_doc);\n-            let simple_key = def_key::DefKey::decode(&mut decoder).unwrap();\n-            let name = reader::maybe_get_doc(item_doc, tag_paths_data_name).map(|name| {\n-                token::intern(name.as_str()).as_str()\n-            });\n-            def_key::recover_def_key(simple_key, name)\n-        }\n-        None => {\n-            bug!(\"failed to find block with tag {:?} for item with family {:?}\",\n-                   tag_def_key,\n-                   item_family(item_doc))\n+    if lines1.len() != lines2.len() {\n+        return false;\n+    }\n+\n+    for (&line1, &line2) in lines1.iter().zip(lines2.iter()) {\n+        if (line1 - fm1.start_pos) != (line2 - fm2.start_pos) {\n+            return false;\n         }\n     }\n-}\n \n-// Returns the path leading to the thing with this `id`. Note that\n-// some def-ids don't wind up in the metadata, so `def_path` sometimes\n-// returns `None`\n-pub fn def_path(cdata: Cmd, id: DefIndex) -> Option<hir_map::DefPath> {\n-    debug!(\"def_path(id={:?})\", id);\n-    if cdata.get_item(id).is_some() {\n-        Some(hir_map::DefPath::make(cdata.cnum, id, |parent| def_key(cdata, parent)))\n-    } else {\n-        None\n+    let multibytes1 = fm1.multibyte_chars.borrow();\n+    let multibytes2 = fm2.multibyte_chars.borrow();\n+\n+    if multibytes1.len() != multibytes2.len() {\n+        return false;\n     }\n-}\n \n-pub fn get_panic_strategy(data: &[u8]) -> PanicStrategy {\n-    let crate_doc = rbml::Doc::new(data);\n-    let strat_doc = reader::get_doc(crate_doc, tag_panic_strategy);\n-    match reader::doc_as_u8(strat_doc) {\n-        b'U' => PanicStrategy::Unwind,\n-        b'A' => PanicStrategy::Abort,\n-        b => panic!(\"unknown panic strategy in metadata: {}\", b),\n+    for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n+        if (mb1.bytes != mb2.bytes) ||\n+            ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n+            return false;\n+        }\n     }\n+\n+    true\n }"}, {"sha": "285ca2e4d4d4de2367259410dd9f09a3e291e73c", "filename": "src/librustc_metadata/def_key.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Fdef_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Fdef_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdef_key.rs?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,110 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::DefIndex;\n-use rustc::hir::map as hir_map;\n-use syntax::parse::token::InternedString;\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct DefKey {\n-    pub parent: Option<DefIndex>,\n-    pub disambiguated_data: DisambiguatedDefPathData,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct DisambiguatedDefPathData {\n-    pub data: DefPathData,\n-    pub disambiguator: u32,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub enum DefPathData {\n-    CrateRoot,\n-    Misc,\n-    Impl,\n-    TypeNs,\n-    ValueNs,\n-    Module,\n-    MacroDef,\n-    ClosureExpr,\n-    TypeParam,\n-    LifetimeDef,\n-    EnumVariant,\n-    Field,\n-    StructCtor,\n-    Initializer,\n-    Binding,\n-    ImplTrait,\n-}\n-\n-pub fn simplify_def_key(key: hir_map::DefKey) -> DefKey {\n-    let data = DisambiguatedDefPathData {\n-        data: simplify_def_path_data(key.disambiguated_data.data),\n-        disambiguator: key.disambiguated_data.disambiguator,\n-    };\n-    DefKey {\n-        parent: key.parent,\n-        disambiguated_data: data,\n-    }\n-}\n-\n-fn simplify_def_path_data(data: hir_map::DefPathData) -> DefPathData {\n-    match data {\n-        hir_map::DefPathData::CrateRoot => DefPathData::CrateRoot,\n-        hir_map::DefPathData::InlinedRoot(_) => bug!(\"unexpected DefPathData\"),\n-        hir_map::DefPathData::Misc => DefPathData::Misc,\n-        hir_map::DefPathData::Impl => DefPathData::Impl,\n-        hir_map::DefPathData::TypeNs(_) => DefPathData::TypeNs,\n-        hir_map::DefPathData::ValueNs(_) => DefPathData::ValueNs,\n-        hir_map::DefPathData::Module(_) => DefPathData::Module,\n-        hir_map::DefPathData::MacroDef(_) => DefPathData::MacroDef,\n-        hir_map::DefPathData::ClosureExpr => DefPathData::ClosureExpr,\n-        hir_map::DefPathData::TypeParam(_) => DefPathData::TypeParam,\n-        hir_map::DefPathData::LifetimeDef(_) => DefPathData::LifetimeDef,\n-        hir_map::DefPathData::EnumVariant(_) => DefPathData::EnumVariant,\n-        hir_map::DefPathData::Field(_) => DefPathData::Field,\n-        hir_map::DefPathData::StructCtor => DefPathData::StructCtor,\n-        hir_map::DefPathData::Initializer => DefPathData::Initializer,\n-        hir_map::DefPathData::Binding(_) => DefPathData::Binding,\n-        hir_map::DefPathData::ImplTrait => DefPathData::ImplTrait,\n-    }\n-}\n-\n-pub fn recover_def_key(key: DefKey, name: Option<InternedString>) -> hir_map::DefKey {\n-    let data = hir_map::DisambiguatedDefPathData {\n-        data: recover_def_path_data(key.disambiguated_data.data, name),\n-        disambiguator: key.disambiguated_data.disambiguator,\n-    };\n-    hir_map::DefKey {\n-        parent: key.parent,\n-        disambiguated_data: data,\n-    }\n-}\n-\n-fn recover_def_path_data(data: DefPathData, name: Option<InternedString>) -> hir_map::DefPathData {\n-    match data {\n-        DefPathData::CrateRoot => hir_map::DefPathData::CrateRoot,\n-        DefPathData::Misc => hir_map::DefPathData::Misc,\n-        DefPathData::Impl => hir_map::DefPathData::Impl,\n-        DefPathData::TypeNs => hir_map::DefPathData::TypeNs(name.unwrap()),\n-        DefPathData::ValueNs => hir_map::DefPathData::ValueNs(name.unwrap()),\n-        DefPathData::Module => hir_map::DefPathData::Module(name.unwrap()),\n-        DefPathData::MacroDef => hir_map::DefPathData::MacroDef(name.unwrap()),\n-        DefPathData::ClosureExpr => hir_map::DefPathData::ClosureExpr,\n-        DefPathData::TypeParam => hir_map::DefPathData::TypeParam(name.unwrap()),\n-        DefPathData::LifetimeDef => hir_map::DefPathData::LifetimeDef(name.unwrap()),\n-        DefPathData::EnumVariant => hir_map::DefPathData::EnumVariant(name.unwrap()),\n-        DefPathData::Field => hir_map::DefPathData::Field(name.unwrap()),\n-        DefPathData::StructCtor => hir_map::DefPathData::StructCtor,\n-        DefPathData::Initializer => hir_map::DefPathData::Initializer,\n-        DefPathData::Binding => hir_map::DefPathData::Binding(name.unwrap()),\n-        DefPathData::ImplTrait => hir_map::DefPathData::ImplTrait,\n-    }\n-}"}, {"sha": "0f067270b80f5cb84c67bac8fc0ae956736ea6fd", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1073, "deletions": 1612, "changes": 2685, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad"}, {"sha": "ef83251f51e8d18ed725b411528bc3b5f0516493", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 48, "deletions": 91, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,138 +8,95 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use schema::*;\n+\n use rustc::hir::def_id::{DefId, DefIndex};\n-use rbml;\n use std::io::{Cursor, Write};\n use std::slice;\n use std::u32;\n \n-/// As part of the metadata, we generate an index that stores, for\n-/// each DefIndex, the position of the corresponding RBML document (if\n-/// any).  This is just a big `[u32]` slice, where an entry of\n-/// `u32::MAX` indicates that there is no RBML document. This little\n-/// struct just stores the offsets within the metadata of the start\n-/// and end of this slice. These are actually part of an RBML\n-/// document, but for looking things up in the metadata, we just\n-/// discard the RBML positioning and jump directly to the data.\n-pub struct Index {\n-    data_start: usize,\n-    data_end: usize,\n-}\n-\n-impl Index {\n-    /// Given the RBML doc representing the index, save the offests\n-    /// for later.\n-    pub fn from_rbml(index: rbml::Doc) -> Index {\n-        Index { data_start: index.start, data_end: index.end }\n-    }\n-\n-    /// Given the metadata, extract out the offset of a particular\n-    /// DefIndex (if any).\n-    #[inline(never)]\n-    pub fn lookup_item(&self, bytes: &[u8], def_index: DefIndex) -> Option<u32> {\n-        let words = bytes_to_words(&bytes[self.data_start..self.data_end]);\n-        let index = def_index.as_usize();\n-\n-        debug!(\"lookup_item: index={:?} words.len={:?}\",\n-               index, words.len());\n-\n-        let position = u32::from_be(words[index]);\n-        if position == u32::MAX {\n-            debug!(\"lookup_item: position=u32::MAX\");\n-            None\n-        } else {\n-            debug!(\"lookup_item: position={:?}\", position);\n-            Some(position)\n-        }\n-    }\n-}\n-\n /// While we are generating the metadata, we also track the position\n /// of each DefIndex. It is not required that all definitions appear\n /// in the metadata, nor that they are serialized in order, and\n /// therefore we first allocate the vector here and fill it with\n /// `u32::MAX`. Whenever an index is visited, we fill in the\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n-pub struct IndexData {\n+pub struct Index {\n     positions: Vec<u32>,\n }\n \n-impl IndexData {\n-    pub fn new(max_index: usize) -> IndexData {\n-        IndexData {\n+impl Index {\n+    pub fn new(max_index: usize) -> Index {\n+        Index {\n             positions: vec![u32::MAX; max_index]\n         }\n     }\n \n-    pub fn record(&mut self, def_id: DefId, position: u64) {\n+    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry>) {\n         assert!(def_id.is_local());\n-        self.record_index(def_id.index, position);\n+        self.record_index(def_id.index, entry);\n     }\n \n-    pub fn record_index(&mut self, item: DefIndex, position: u64) {\n+    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry>) {\n         let item = item.as_usize();\n \n-        assert!(position < (u32::MAX as u64));\n-        let position = position as u32;\n+        assert!(entry.position < (u32::MAX as usize));\n+        let position = entry.position as u32;\n \n         assert!(self.positions[item] == u32::MAX,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n                 item, self.positions[item], position);\n \n-        self.positions[item] = position;\n+        self.positions[item] = position.to_le();\n     }\n \n-    pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) {\n-        for &position in &self.positions {\n-            write_be_u32(buf, position);\n-        }\n+    pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) -> LazySeq<Index> {\n+        let pos = buf.position();\n+        buf.write_all(words_to_bytes(&self.positions)).unwrap();\n+        LazySeq::with_position_and_length(pos as usize, self.positions.len())\n     }\n }\n \n-/// A dense index with integer keys. Different API from IndexData (should\n-/// these be merged?)\n-pub struct DenseIndex {\n-    start: usize,\n-    end: usize\n-}\n+impl<'tcx> LazySeq<Index> {\n+    /// Given the metadata, extract out the offset of a particular\n+    /// DefIndex (if any).\n+    #[inline(never)]\n+    pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n+        let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n+        let index = def_index.as_usize();\n \n-impl DenseIndex {\n-    pub fn lookup(&self, buf: &[u8], ix: u32) -> Option<u32> {\n-        let data = bytes_to_words(&buf[self.start..self.end]);\n-        data.get(ix as usize).map(|d| u32::from_be(*d))\n-    }\n-    pub fn from_buf(buf: &[u8], start: usize, end: usize) -> Self {\n-        assert!((end-start)%4 == 0 && start <= end && end <= buf.len());\n-        DenseIndex {\n-            start: start,\n-            end: end\n+        debug!(\"Index::lookup: index={:?} words.len={:?}\",\n+               index, words.len());\n+\n+        let position = u32::from_le(words[index]);\n+        if position == u32::MAX {\n+            debug!(\"Index::lookup: position=u32::MAX\");\n+            None\n+        } else {\n+            debug!(\"Index::lookup: position={:?}\", position);\n+            Some(Lazy::with_position(position as usize))\n         }\n     }\n-}\n-\n-pub fn write_dense_index(entries: Vec<u32>, buf: &mut Cursor<Vec<u8>>) {\n-    let elen = entries.len();\n-    assert!(elen < u32::MAX as usize);\n \n-    for entry in entries {\n-        write_be_u32(buf, entry);\n+    pub fn iter_enumerated<'a>(&self, bytes: &'a [u8])\n+                               -> impl Iterator<Item=(DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n+        let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n+        words.iter().enumerate().filter_map(|(index, &position)| {\n+            if position == u32::MAX {\n+                None\n+            } else {\n+                let position = u32::from_le(position) as usize;\n+                Some((DefIndex::new(index), Lazy::with_position(position)))\n+            }\n+        })\n     }\n-\n-    info!(\"write_dense_index: {} entries\", elen);\n }\n \n-fn write_be_u32<W: Write>(w: &mut W, u: u32) {\n-    let _ = w.write_all(&[\n-        (u >> 24) as u8,\n-        (u >> 16) as u8,\n-        (u >>  8) as u8,\n-        (u >>  0) as u8,\n-    ]);\n+fn bytes_to_words(b: &[u8]) -> &[u32] {\n+    unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len() / 4) }\n }\n \n-fn bytes_to_words(b: &[u8]) -> &[u32] {\n-    assert!(b.len() % 4 == 0);\n-    unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len()/4) }\n+fn words_to_bytes(w: &[u32]) -> &[u8] {\n+    unsafe { slice::from_raw_parts(w.as_ptr() as *const u8, w.len() * 4) }\n }"}, {"sha": "aeb6f63252c6efde1076d36680c82b6f0564d455", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 39, "deletions": 68, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -28,28 +28,21 @@\n //! incremental compilation purposes.\n //!\n //! The `IndexBuilder` facilitates both of these. It is created\n-//! with an RBML encoder isntance (`rbml_w`) along with an\n-//! `EncodingContext` (`ecx`), which it encapsulates. It has one main\n-//! method, `record()`. You invoke `record` like so to create a new\n-//! `data_item` element in the list:\n+//! with an `EncodingContext` (`ecx`), which it encapsulates.\n+//! It has one main method, `record()`. You invoke `record`\n+//! like so to create a new `data_item` element in the list:\n //!\n //! ```\n //! index.record(some_def_id, callback_fn, data)\n //! ```\n //!\n //! What record will do is to (a) record the current offset, (b) emit\n //! the `common::data_item` tag, and then call `callback_fn` with the\n-//! given data as well as an `ItemContentBuilder`. Once `callback_fn`\n+//! given data as well as the `EncodingContext`. Once `callback_fn`\n //! returns, the `common::data_item` tag will be closed.\n //!\n-//! The `ItemContentBuilder` is another type that just offers access\n-//! to the `ecx` and `rbml_w` that were given in, as well as\n-//! maintaining a list of `xref` instances, which are used to extract\n-//! common data so it is not re-serialized.\n-//!\n-//! `ItemContentBuilder` is a distinct type which does not offer the\n-//! `record` method, so that we can ensure that `common::data_item` elements\n-//! are never nested.\n+//! `EncodingContext` does not offer the `record` method, so that we\n+//! can ensure that `common::data_item` elements are never nested.\n //!\n //! In addition, while the `callback_fn` is executing, we will push a\n //! task `MetaData(some_def_id)`, which can then observe the\n@@ -62,59 +55,51 @@\n //! give a callback fn, rather than taking a closure: it allows us to\n //! easily control precisely what data is given to that fn.\n \n-use common::tag_items_data_item;\n use encoder::EncodeContext;\n-use index::IndexData;\n-use rbml::writer::Encoder;\n+use index::Index;\n+use schema::*;\n+\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc::ty::TyCtxt;\n use syntax::ast;\n \n+use std::ops::{Deref, DerefMut};\n+\n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n-pub struct IndexBuilder<'a, 'tcx: 'a, 'encoder: 'a> {\n-    items: IndexData,\n-    builder: ItemContentBuilder<'a, 'tcx, 'encoder>,\n+pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n+    items: Index,\n+    pub ecx: &'a mut EncodeContext<'b, 'tcx>,\n }\n \n-/// Builder that can encode the content of items, but can't start a\n-/// new item itself. Most code is attached to here.\n-pub struct ItemContentBuilder<'a, 'tcx: 'a, 'encoder: 'a> {\n-    xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n-    pub ecx: &'a EncodeContext<'a, 'tcx>,\n-    pub rbml_w: &'a mut Encoder<'encoder>,\n+impl<'a, 'b, 'tcx> Deref for IndexBuilder<'a, 'b, 'tcx> {\n+    type Target = EncodeContext<'b, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        self.ecx\n+    }\n }\n \n-/// \"interned\" entries referenced by id\n-#[derive(PartialEq, Eq, Hash)]\n-pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n+impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.ecx\n+    }\n+}\n \n-impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n-    pub fn new(ecx: &'a EncodeContext<'a, 'tcx>,\n-               rbml_w: &'a mut Encoder<'encoder>)\n-               -> Self {\n+impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n+    pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n-            items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n-            builder: ItemContentBuilder {\n-                ecx: ecx,\n-                xrefs: FnvHashMap(),\n-                rbml_w: rbml_w,\n-            },\n+            items: Index::new(ecx.tcx.map.num_local_def_ids()),\n+            ecx: ecx,\n         }\n     }\n \n-    pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n-        self.builder.ecx()\n-    }\n-\n     /// Emit the data for a def-id to the metadata. The function to\n     /// emit the data is `op`, and it will be given `data` as\n-    /// arguments. This `record` function will start/end an RBML tag\n-    /// and record the current offset for use in the index, calling\n-    /// `op` to generate the data in the RBML tag.\n+    /// arguments. This `record` function will call `op` to generate\n+    /// the `Entry` (which may point to other encoded information)\n+    /// and will then record the `Lazy<Entry>` for use in the index.\n     ///\n     /// In addition, it will setup a dep-graph task to track what data\n     /// `op` accesses to generate the metadata, which is later used by\n@@ -129,32 +114,18 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     /// content system.\n     pub fn record<DATA>(&mut self,\n                         id: DefId,\n-                        op: fn(&mut ItemContentBuilder<'a, 'tcx, 'encoder>, DATA),\n+                        op: fn(&mut EncodeContext<'b, 'tcx>, DATA) -> Entry<'tcx>,\n                         data: DATA)\n         where DATA: DepGraphRead\n     {\n-        let position = self.builder.rbml_w.mark_stable_position();\n-        self.items.record(id, position);\n-        let _task = self.ecx().tcx.dep_graph.in_task(DepNode::MetaData(id));\n-        self.builder.rbml_w.start_tag(tag_items_data_item).unwrap();\n-        data.read(self.ecx().tcx);\n-        op(&mut self.builder, data);\n-        self.builder.rbml_w.end_tag().unwrap();\n-    }\n-\n-    pub fn into_fields(self) -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n-        (self.items, self.builder.xrefs)\n-    }\n-}\n-\n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n-    pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n-        self.ecx\n+        let _task = self.tcx.dep_graph.in_task(DepNode::MetaData(id));\n+        data.read(self.tcx);\n+        let entry = op(&mut self.ecx, data);\n+        self.items.record(id, self.ecx.lazy(&entry));\n     }\n \n-    pub fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n-        let old_len = self.xrefs.len() as u32;\n-        *self.xrefs.entry(xref).or_insert(old_len)\n+    pub fn into_items(self) -> Index {\n+        self.items\n     }\n }\n "}, {"sha": "4fc5a46762d1215136d9e4291537c2a30c250e12", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -17,23 +17,23 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(conservative_impl_trait)]\n+#![feature(core_intrinsics)]\n #![feature(box_patterns)]\n #![feature(dotdot_in_tuple_patterns)]\n-#![feature(enumset)]\n #![feature(question_mark)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_macro_lib)]\n #![feature(rustc_macro_internals)]\n #![feature(rustc_private)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n-#[macro_use] #[no_link] extern crate rustc_bitflags;\n extern crate syntax_pos;\n extern crate flate;\n-extern crate rbml;\n extern crate serialize as rustc_serialize; // used by deriving\n extern crate rustc_errors as errors;\n extern crate syntax_ext;\n@@ -46,27 +46,19 @@ extern crate rustc_llvm;\n extern crate rustc_macro;\n extern crate rustc_const_math;\n \n-pub use rustc::middle;\n+mod diagnostics;\n \n-#[macro_use]\n-mod macros;\n-\n-pub mod diagnostics;\n-\n-pub mod astencode;\n-pub mod common;\n-pub mod def_key;\n-pub mod tyencode;\n-pub mod tydecode;\n-pub mod encoder;\n+mod astencode;\n mod index_builder;\n-pub mod decoder;\n+mod index;\n+mod encoder;\n+mod decoder;\n+mod csearch;\n+mod schema;\n+\n pub mod creader;\n-pub mod csearch;\n pub mod cstore;\n-pub mod index;\n pub mod loader;\n pub mod macro_import;\n-pub mod tls_context;\n \n __build_diagnostic_array! { librustc_metadata, DIAGNOSTICS }"}, {"sha": "fc94cec916aad146be7f830c77cc64040aa7912b", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 27, "deletions": 41, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -212,9 +212,8 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::loader or metadata::creader for all the juicy details!\n \n-use cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n-use common::{metadata_encoding_version, rustc_version};\n-use decoder;\n+use cstore::MetadataBlob;\n+use schema::{METADATA_HEADER, RUSTC_VERSION};\n \n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n@@ -383,7 +382,7 @@ impl<'a> Context<'a> {\n         }\n         if !self.rejected_via_version.is_empty() {\n             err.help(&format!(\"please recompile that crate using this compiler ({})\",\n-                              rustc_version()));\n+                              RUSTC_VERSION));\n             let mismatches = self.rejected_via_version.iter();\n             for (i, &CrateMismatch { ref path, ref got }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}` path #{}: {} compiled by {:?}\",\n@@ -511,9 +510,7 @@ impl<'a> Context<'a> {\n                     if let Some((ref p, _)) = lib.rlib {\n                         err.note(&format!(\"path: {}\", p.display()));\n                     }\n-                    let data = lib.metadata.as_slice();\n-                    let name = decoder::get_crate_name(data);\n-                    note_crate_name(&mut err, &name);\n+                    note_crate_name(&mut err, &lib.metadata.get_root().name);\n                 }\n                 err.emit();\n                 None\n@@ -551,7 +548,7 @@ impl<'a> Context<'a> {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let (hash, metadata) = match get_metadata_section(self.target, flavor, &lib) {\n                 Ok(blob) => {\n-                    if let Some(h) = self.crate_matches(blob.as_slice(), &lib) {\n+                    if let Some(h) = self.crate_matches(&blob, &lib) {\n                         (h, blob)\n                     } else {\n                         info!(\"metadata mismatch\");\n@@ -598,45 +595,38 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> Option<Svh> {\n-        let crate_rustc_version = decoder::crate_rustc_version(crate_data);\n-        if crate_rustc_version != Some(rustc_version()) {\n-            let message = crate_rustc_version.unwrap_or(format!(\"an unknown compiler\"));\n-            info!(\"Rejecting via version: expected {} got {}\", rustc_version(), message);\n+    fn crate_matches(&mut self, metadata: &MetadataBlob, libpath: &Path) -> Option<Svh> {\n+        let root = metadata.get_root();\n+        if root.rustc_version != RUSTC_VERSION {\n+            info!(\"Rejecting via version: expected {} got {}\",\n+                  RUSTC_VERSION, root.rustc_version);\n             self.rejected_via_version.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: message\n+                got: root.rustc_version\n             });\n             return None;\n         }\n \n         if self.should_match_name {\n-            match decoder::maybe_get_crate_name(crate_data) {\n-                Some(ref name) if self.crate_name == *name => {}\n-                _ => { info!(\"Rejecting via crate name\"); return None }\n+            if self.crate_name != root.name {\n+                info!(\"Rejecting via crate name\"); return None;\n             }\n         }\n-        let hash = match decoder::maybe_get_crate_hash(crate_data) {\n-            None => { info!(\"Rejecting via lack of crate hash\"); return None; }\n-            Some(h) => h,\n-        };\n \n-        let triple = match decoder::get_crate_triple(crate_data) {\n-            None => { debug!(\"triple not present\"); return None }\n-            Some(t) => t,\n-        };\n-        if triple != self.triple {\n-            info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, triple);\n+        if root.triple != self.triple {\n+            info!(\"Rejecting via crate triple: expected {} got {}\",\n+                  self.triple, root.triple);\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: triple.to_string()\n+                got: root.triple\n             });\n             return None;\n         }\n \n         if let Some(myhash) = self.hash {\n-            if *myhash != hash {\n-                info!(\"Rejecting via hash: expected {} got {}\", *myhash, hash);\n+            if *myhash != root.hash {\n+                info!(\"Rejecting via hash: expected {} got {}\",\n+                      *myhash, root.hash);\n                 self.rejected_via_hash.push(CrateMismatch {\n                     path: libpath.to_path_buf(),\n                     got: myhash.to_string()\n@@ -645,7 +635,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n-        Some(hash)\n+        Some(root.hash)\n     }\n \n \n@@ -766,11 +756,7 @@ impl ArchiveMetadata {\n fn verify_decompressed_encoding_version(blob: &MetadataBlob, filename: &Path)\n                                         -> Result<(), String>\n {\n-    let data = blob.as_slice_raw();\n-    if data.len() < 4+metadata_encoding_version.len() ||\n-        !<[u8]>::eq(&data[..4], &[0, 0, 0, 0]) ||\n-        &data[4..4+metadata_encoding_version.len()] != metadata_encoding_version\n-    {\n+    if !blob.is_compatible() {\n         Err((format!(\"incompatible metadata version found: '{}'\",\n                      filename.display())))\n     } else {\n@@ -805,7 +791,7 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                                    filename.display()));\n             }\n         };\n-        return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n+        return match ArchiveMetadata::new(archive).map(|ar| MetadataBlob::Archive(ar)) {\n             None => Err(format!(\"failed to read rlib metadata: '{}'\",\n                                 filename.display())),\n             Some(blob) => {\n@@ -840,12 +826,12 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n-                let vlen = metadata_encoding_version.len();\n+                let vlen = METADATA_HEADER.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let buf0 = slice::from_raw_parts(cvbuf, minsz);\n-                let version_ok = buf0 == metadata_encoding_version;\n+                let version_ok = buf0 == METADATA_HEADER;\n                 if !version_ok {\n                     return Err((format!(\"incompatible metadata version found: '{}'\",\n                                         filename.display())));\n@@ -857,7 +843,7 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n                     Ok(inflated) => {\n-                        let blob = MetadataVec(inflated);\n+                        let blob = MetadataBlob::Inflated(inflated);\n                         verify_decompressed_encoding_version(&blob, filename)?;\n                         return Ok(blob);\n                     }\n@@ -902,7 +888,7 @@ pub fn list_file_metadata(target: &Target, path: &Path,\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") { CrateFlavor::Rlib } else { CrateFlavor::Dylib };\n     match get_metadata_section(target, flavor, path) {\n-        Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n+        Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => {\n             write!(out, \"{}\\n\", msg)\n         }"}, {"sha": "ed764ebd9f95dd4e27b579342fc0f4c66e77a486", "filename": "src/librustc_metadata/macros.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacros.rs?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,46 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-macro_rules! enum_from_u32 {\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident = $e:expr,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant = $e),*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant,)*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    }\n-}"}, {"sha": "f4d1e8e17f842066e39ec459dd6d39da5ee2de29", "filename": "src/librustc_metadata/schema.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -0,0 +1,349 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use astencode;\n+use index;\n+\n+use rustc::hir;\n+use rustc::hir::def;\n+use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::middle::cstore::{LinkagePreference, NativeLibraryKind};\n+use rustc::middle::lang_items;\n+use rustc::mir;\n+use rustc::ty::{self, Ty};\n+use rustc::session::config::PanicStrategy;\n+\n+use rustc_serialize as serialize;\n+use syntax::{ast, attr};\n+use syntax_pos::{self, Span};\n+\n+use std::marker::PhantomData;\n+\n+#[cfg(not(test))]\n+pub const RUSTC_VERSION: &'static str = concat!(\"rustc \", env!(\"CFG_VERSION\"));\n+\n+#[cfg(test)]\n+pub const RUSTC_VERSION: &'static str = \"rustc 0.0.0-unit-test\";\n+\n+/// Metadata encoding version.\n+/// NB: increment this if you change the format of metadata such that\n+/// the rustc version can't be found to compare with `RUSTC_VERSION`.\n+pub const METADATA_VERSION: u8 = 3;\n+\n+/// Metadata header which includes `METADATA_VERSION`.\n+/// To get older versions of rustc to ignore this metadata,\n+/// there are 4 zero bytes at the start, which are treated\n+/// as a length of 0 by old compilers.\n+///\n+/// This header is followed by the position of the `CrateRoot`.\n+pub const METADATA_HEADER: &'static [u8; 12] = &[\n+    0, 0, 0, 0,\n+    b'r', b'u', b's', b't',\n+    0, 0, 0, METADATA_VERSION\n+];\n+\n+/// The shorthand encoding uses an enum's variant index `usize`\n+/// and is offset by this value so it never matches a real variant.\n+/// This offset is also chosen so that the first byte is never < 0x80.\n+pub const SHORTHAND_OFFSET: usize = 0x80;\n+\n+/// A value of type T referred to by its absolute position\n+/// in the metadata, and which can be decoded lazily.\n+///\n+/// Metadata is effective a tree, encoded in post-order,\n+/// and with the root's position written next to the header.\n+/// That means every single `Lazy` points to some previous\n+/// location in the metadata and is part of a larger node.\n+///\n+/// The first `Lazy` in a node is encoded as the backwards\n+/// distance from the position where the containing node\n+/// starts and where the `Lazy` points to, while the rest\n+/// use the forward distance from the previous `Lazy`.\n+/// Distances start at 1, as 0-byte nodes are invalid.\n+/// Also invalid are nodes being referred in a different\n+/// order than they were encoded in.\n+#[must_use]\n+pub struct Lazy<T> {\n+    pub position: usize,\n+    _marker: PhantomData<T>\n+}\n+\n+impl<T> Lazy<T> {\n+    pub fn with_position(position: usize) -> Lazy<T> {\n+        Lazy {\n+            position: position,\n+            _marker: PhantomData\n+        }\n+    }\n+\n+    /// Returns the minimum encoded size of a value of type `T`.\n+    // FIXME(eddyb) Give better estimates for certain types.\n+    pub fn min_size() -> usize {\n+        1\n+    }\n+}\n+\n+impl<T> Copy for Lazy<T> {}\n+impl<T> Clone for Lazy<T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+impl<T> serialize::UseSpecializedEncodable for Lazy<T> {}\n+impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n+\n+/// A sequence of type T referred to by its absolute position\n+/// in the metadata and length, and which can be decoded lazily.\n+/// The sequence is a single node for the purposes of `Lazy`.\n+///\n+/// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n+/// position, not at the position, which means that the length\n+/// doesn't need to be known before encoding all the elements.\n+///\n+/// If the length is 0, no position is encoded, but otherwise,\n+/// the encoding is that of `Lazy`, with the distinction that\n+/// the minimal distance the length of the sequence, i.e.\n+/// it's assumed there's no 0-byte element in the sequence.\n+#[must_use]\n+pub struct LazySeq<T> {\n+    pub len: usize,\n+    pub position: usize,\n+    _marker: PhantomData<T>\n+}\n+\n+impl<T> LazySeq<T> {\n+    pub fn empty() -> LazySeq<T> {\n+        LazySeq::with_position_and_length(0, 0)\n+    }\n+\n+    pub fn with_position_and_length(position: usize, len: usize) -> LazySeq<T> {\n+        LazySeq {\n+            len: len,\n+            position: position,\n+            _marker: PhantomData\n+        }\n+    }\n+\n+    /// Returns the minimum encoded size of `length` values of type `T`.\n+    pub fn min_size(length: usize) -> usize {\n+        length\n+    }\n+}\n+\n+impl<T> Copy for LazySeq<T> {}\n+impl<T> Clone for LazySeq<T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n+impl<T> serialize::UseSpecializedDecodable for LazySeq<T> {}\n+\n+/// Encoding / decoding state for `Lazy` and `LazySeq`.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum LazyState {\n+    /// Outside of a metadata node.\n+    NoNode,\n+\n+    /// Inside a metadata node, and before any `Lazy` or `LazySeq`.\n+    /// The position is that of the node itself.\n+    NodeStart(usize),\n+\n+    /// Inside a metadata node, with a previous `Lazy` or `LazySeq`.\n+    /// The position is a conservative estimate of where that\n+    /// previous `Lazy` / `LazySeq` would end (see their comments).\n+    Previous(usize)\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct CrateRoot {\n+    pub rustc_version: String,\n+    pub name: String,\n+    pub triple: String,\n+    pub hash: hir::svh::Svh,\n+    pub disambiguator: String,\n+    pub panic_strategy: PanicStrategy,\n+    pub plugin_registrar_fn: Option<DefIndex>,\n+    pub macro_derive_registrar: Option<DefIndex>,\n+\n+    pub crate_deps: LazySeq<CrateDep>,\n+    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n+    pub lang_items: LazySeq<(DefIndex, usize)>,\n+    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n+    pub native_libraries: LazySeq<(NativeLibraryKind, String)>,\n+    pub codemap: LazySeq<syntax_pos::FileMap>,\n+    pub macro_defs: LazySeq<MacroDef>,\n+    pub impls: LazySeq<TraitImpls>,\n+    pub reachable_ids: LazySeq<DefIndex>,\n+    pub index: LazySeq<index::Index>,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct CrateDep {\n+    pub name: ast::Name,\n+    pub hash: hir::svh::Svh,\n+    pub explicitly_linked: bool\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct TraitImpls {\n+    pub trait_id: (u32, DefIndex),\n+    pub impls: LazySeq<DefIndex>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct MacroDef {\n+    pub name: ast::Name,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub span: Span,\n+    pub body: String\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Entry<'tcx> {\n+    pub kind: EntryKind<'tcx>,\n+    pub visibility: ty::Visibility,\n+    pub def_key: Lazy<hir::map::DefKey>,\n+    pub attributes: LazySeq<ast::Attribute>,\n+    pub children: LazySeq<DefIndex>,\n+    pub stability: Option<Lazy<attr::Stability>>,\n+    pub deprecation: Option<Lazy<attr::Deprecation>>,\n+\n+    pub ty: Option<Lazy<Ty<'tcx>>>,\n+    pub inherent_impls: LazySeq<DefIndex>,\n+    pub variances: LazySeq<ty::Variance>,\n+    pub generics: Option<Lazy<ty::Generics<'tcx>>>,\n+    pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n+\n+    pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n+    pub mir: Option<Lazy<mir::repr::Mir<'tcx>>>\n+}\n+\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub enum EntryKind<'tcx> {\n+    Const,\n+    ImmStatic,\n+    MutStatic,\n+    ForeignImmStatic,\n+    ForeignMutStatic,\n+    ForeignMod,\n+    Type,\n+    Enum,\n+    Field,\n+    Variant(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>),\n+    Union(Lazy<VariantData>),\n+    Fn(Lazy<FnData>),\n+    ForeignFn(Lazy<FnData>),\n+    Mod(Lazy<ModData>),\n+    Closure(Lazy<ClosureData<'tcx>>),\n+    Trait(Lazy<TraitData<'tcx>>),\n+    Impl(Lazy<ImplData<'tcx>>),\n+    DefaultImpl(Lazy<ImplData<'tcx>>),\n+    Method(Lazy<MethodData<'tcx>>),\n+    AssociatedType(AssociatedContainer),\n+    AssociatedConst(AssociatedContainer)\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ModData {\n+    pub reexports: LazySeq<def::Export>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct FnData {\n+    pub constness: hir::Constness,\n+    pub arg_names: LazySeq<ast::Name>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct VariantData {\n+    pub kind: ty::VariantKind,\n+    pub disr: u64,\n+\n+    /// If this is a struct's only variant, this\n+    /// is the index of the \"struct ctor\" item.\n+    pub struct_ctor: Option<DefIndex>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct TraitData<'tcx> {\n+    pub unsafety: hir::Unsafety,\n+    pub paren_sugar: bool,\n+    pub has_default_impl: bool,\n+    pub trait_ref: Lazy<ty::TraitRef<'tcx>>,\n+    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ImplData<'tcx> {\n+    pub polarity: hir::ImplPolarity,\n+    pub parent_impl: Option<DefId>,\n+    pub coerce_unsized_kind: Option<ty::adjustment::CustomCoerceUnsized>,\n+    pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>\n+}\n+\n+/// Describes whether the container of an associated item\n+/// is a trait or an impl and whether, in a trait, it has\n+/// a default, or an in impl, whether it's marked \"default\".\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub enum AssociatedContainer {\n+    TraitRequired,\n+    TraitWithDefault,\n+    ImplDefault,\n+    ImplFinal\n+}\n+\n+impl AssociatedContainer {\n+    pub fn with_def_id(&self, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n+        match *self {\n+            AssociatedContainer::TraitRequired |\n+            AssociatedContainer::TraitWithDefault => {\n+                ty::TraitContainer(def_id)\n+            }\n+\n+            AssociatedContainer::ImplDefault |\n+            AssociatedContainer::ImplFinal => {\n+                ty::ImplContainer(def_id)\n+            }\n+        }\n+    }\n+\n+    pub fn has_body(&self) -> bool {\n+        match *self {\n+            AssociatedContainer::TraitRequired => false,\n+\n+            AssociatedContainer::TraitWithDefault |\n+            AssociatedContainer::ImplDefault |\n+            AssociatedContainer::ImplFinal => true\n+        }\n+    }\n+\n+    pub fn defaultness(&self) -> hir::Defaultness {\n+        match *self {\n+            AssociatedContainer::TraitRequired |\n+            AssociatedContainer::TraitWithDefault |\n+            AssociatedContainer::ImplDefault => hir::Defaultness::Default,\n+\n+            AssociatedContainer::ImplFinal => hir::Defaultness::Final\n+        }\n+    }\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct MethodData<'tcx> {\n+    pub fn_data: FnData,\n+    pub container: AssociatedContainer,\n+    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ClosureData<'tcx> {\n+    pub kind: ty::ClosureKind,\n+    pub ty: Lazy<ty::ClosureTy<'tcx>>\n+}"}, {"sha": "6e78cbcd28e731e663b698a6fc16d2068b041113", "filename": "src/librustc_metadata/tls_context.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,102 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This module provides implementations for the thread-local encoding and\n-// decoding context traits in rustc::middle::cstore::tls.\n-\n-use rbml::opaque::Encoder as OpaqueEncoder;\n-use rbml::opaque::Decoder as OpaqueDecoder;\n-use rustc::middle::cstore::tls;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, TyCtxt};\n-\n-use decoder::{self, Cmd};\n-use encoder;\n-use tydecode::TyDecoder;\n-use tyencode;\n-\n-impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tcx> {\n-\n-    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: ty::Ty<'tcx>) {\n-        tyencode::enc_ty(encoder.cursor, &self.ty_str_ctxt(), t);\n-    }\n-\n-    fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>) {\n-        tyencode::enc_substs(encoder.cursor, &self.ty_str_ctxt(), substs);\n-    }\n-}\n-\n-pub struct DecodingContext<'a, 'tcx: 'a> {\n-    pub crate_metadata: Cmd<'a>,\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n-impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n-\n-    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx> {\n-        let def_id_convert = &mut |did| {\n-            decoder::translate_def_id(self.crate_metadata, did)\n-        };\n-\n-        let starting_position = decoder.position();\n-\n-        let mut ty_decoder = TyDecoder::new(\n-            self.crate_metadata.data.as_slice(),\n-            self.crate_metadata.cnum,\n-            starting_position,\n-            self.tcx,\n-            def_id_convert);\n-\n-        let ty = ty_decoder.parse_ty();\n-\n-        let end_position = ty_decoder.position();\n-\n-        // We can just reuse the tydecode implementation for parsing types, but\n-        // we have to make sure to leave the rbml reader at the position just\n-        // after the type.\n-        decoder.advance(end_position - starting_position);\n-        ty\n-    }\n-\n-    fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx> {\n-        let def_id_convert = &mut |did| {\n-            decoder::translate_def_id(self.crate_metadata, did)\n-        };\n-\n-        let starting_position = decoder.position();\n-\n-        let mut ty_decoder = TyDecoder::new(\n-            self.crate_metadata.data.as_slice(),\n-            self.crate_metadata.cnum,\n-            starting_position,\n-            self.tcx,\n-            def_id_convert);\n-\n-        let substs = ty_decoder.parse_substs();\n-\n-        let end_position = ty_decoder.position();\n-\n-        decoder.advance(end_position - starting_position);\n-        substs\n-    }\n-\n-    fn translate_def_id(&self, def_id: DefId) -> DefId {\n-        decoder::translate_def_id(self.crate_metadata, def_id)\n-    }\n-}"}, {"sha": "bcaf1640bc41b0cd8a4efeb28fbce235dedcae0f", "filename": "src/librustc_metadata/tydecode.rs", "status": "removed", "additions": 0, "deletions": 750, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,750 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// Type decoding\n-\n-// tjc note: Would be great to have a `match check` macro equivalent\n-// for some of these\n-\n-#![allow(non_camel_case_types)]\n-\n-use rustc::hir;\n-\n-use rustc::hir::def_id::{DefId, DefIndex};\n-use middle::region;\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n-\n-use rbml;\n-use rbml::leb128;\n-use std::str;\n-use syntax::abi;\n-use syntax::ast;\n-use syntax::parse::token;\n-\n-// Compact string representation for Ty values. API TyStr &\n-// parse_from_str. Extra parameters are for converting to/from def_ids in the\n-// data buffer. Whatever format you choose should not contain pipe characters.\n-\n-pub type DefIdConvert<'a> = &'a mut FnMut(DefId) -> DefId;\n-\n-pub struct TyDecoder<'a, 'tcx: 'a> {\n-    data: &'a [u8],\n-    krate: ast::CrateNum,\n-    pos: usize,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    conv_def_id: DefIdConvert<'a>,\n-}\n-\n-impl<'a,'tcx> TyDecoder<'a,'tcx> {\n-    pub fn with_doc(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    crate_num: ast::CrateNum,\n-                    doc: rbml::Doc<'a>,\n-                    conv: DefIdConvert<'a>)\n-                    -> TyDecoder<'a,'tcx> {\n-        TyDecoder::new(doc.data, crate_num, doc.start, tcx, conv)\n-    }\n-\n-    pub fn new(data: &'a [u8],\n-               crate_num: ast::CrateNum,\n-               pos: usize,\n-               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               conv: DefIdConvert<'a>)\n-               -> TyDecoder<'a, 'tcx> {\n-        TyDecoder {\n-            data: data,\n-            krate: crate_num,\n-            pos: pos,\n-            tcx: tcx,\n-            conv_def_id: conv,\n-        }\n-    }\n-\n-    pub fn position(&self) -> usize {\n-        self.pos\n-    }\n-\n-    fn peek(&self) -> char {\n-        self.data[self.pos] as char\n-    }\n-\n-    fn next(&mut self) -> char {\n-        let ch = self.data[self.pos] as char;\n-        self.pos = self.pos + 1;\n-        return ch;\n-    }\n-\n-    fn next_byte(&mut self) -> u8 {\n-        let b = self.data[self.pos];\n-        self.pos = self.pos + 1;\n-        return b;\n-    }\n-\n-    fn scan<F>(&mut self, mut is_last: F) -> &'a [u8]\n-        where F: FnMut(char) -> bool,\n-    {\n-        let start_pos = self.pos;\n-        debug!(\"scan: '{}' (start)\", self.data[self.pos] as char);\n-        while !is_last(self.data[self.pos] as char) {\n-            self.pos += 1;\n-            debug!(\"scan: '{}'\", self.data[self.pos] as char);\n-        }\n-        let end_pos = self.pos;\n-        self.pos += 1;\n-        return &self.data[start_pos..end_pos];\n-    }\n-\n-    fn parse_vuint(&mut self) -> usize {\n-        let (value, bytes_read) = leb128::read_unsigned_leb128(self.data,\n-                                                               self.pos);\n-        self.pos += bytes_read;\n-        value as usize\n-    }\n-\n-    fn parse_name(&mut self, last: char) -> ast::Name {\n-        fn is_last(b: char, c: char) -> bool { return c == b; }\n-        let bytes = self.scan(|a| is_last(last, a));\n-        token::intern(str::from_utf8(bytes).unwrap())\n-    }\n-\n-    fn parse_size(&mut self) -> Option<usize> {\n-        assert_eq!(self.next(), '/');\n-\n-        if self.peek() == '|' {\n-            assert_eq!(self.next(), '|');\n-            None\n-        } else {\n-            let n = self.parse_uint();\n-            assert_eq!(self.next(), '|');\n-            Some(n)\n-        }\n-    }\n-\n-    pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n-        let mut params = vec![];\n-        assert_eq!(self.next(), '[');\n-        while self.peek() != ']' {\n-            let k = match self.next() {\n-                'r' => Kind::from(self.parse_region()),\n-                't' => Kind::from(self.parse_ty()),\n-                _ => bug!()\n-            };\n-            params.push(k);\n-        }\n-        assert_eq!(self.next(), ']');\n-\n-        Substs::new(self.tcx, params)\n-    }\n-\n-    pub fn parse_generics(&mut self) -> &'tcx ty::Generics<'tcx> {\n-        let parent = self.parse_opt(|this| this.parse_def());\n-        let parent_regions = self.parse_u32();\n-        assert_eq!(self.next(), '|');\n-        let parent_types = self.parse_u32();\n-\n-        let mut regions = vec![];\n-        let mut types = vec![];\n-        assert_eq!(self.next(), '[');\n-        while self.peek() != '|' {\n-            regions.push(self.parse_region_param_def());\n-        }\n-        assert_eq!(self.next(), '|');\n-        while self.peek() != ']' {\n-            types.push(self.parse_type_param_def());\n-        }\n-        assert_eq!(self.next(), ']');\n-\n-        self.tcx.alloc_generics(ty::Generics {\n-            parent: parent,\n-            parent_regions: parent_regions,\n-            parent_types: parent_types,\n-            regions: regions,\n-            types: types,\n-            has_self: self.next() == 'S'\n-        })\n-    }\n-\n-    fn parse_bound_region(&mut self) -> ty::BoundRegion {\n-        match self.next() {\n-            'a' => {\n-                let id = self.parse_u32();\n-                assert_eq!(self.next(), '|');\n-                ty::BrAnon(id)\n-            }\n-            '[' => {\n-                let def = self.parse_def();\n-                let name = token::intern(&self.parse_str('|'));\n-                let issue32330 = match self.next() {\n-                    'n' => {\n-                        assert_eq!(self.next(), ']');\n-                        ty::Issue32330::WontChange\n-                    }\n-                    'y' => {\n-                        ty::Issue32330::WillChange {\n-                            fn_def_id: self.parse_def(),\n-                            region_name: token::intern(&self.parse_str(']')),\n-                        }\n-                    }\n-                    c => panic!(\"expected n or y not {}\", c)\n-                };\n-                ty::BrNamed(def, name, issue32330)\n-            }\n-            'f' => {\n-                let id = self.parse_u32();\n-                assert_eq!(self.next(), '|');\n-                ty::BrFresh(id)\n-            }\n-            'e' => ty::BrEnv,\n-            _ => bug!(\"parse_bound_region: bad input\")\n-        }\n-    }\n-\n-    pub fn parse_region(&mut self) -> &'tcx ty::Region {\n-        self.tcx.mk_region(match self.next() {\n-            'b' => {\n-                assert_eq!(self.next(), '[');\n-                let id = ty::DebruijnIndex::new(self.parse_u32());\n-                assert_eq!(self.next(), '|');\n-                let br = self.parse_bound_region();\n-                assert_eq!(self.next(), ']');\n-                ty::ReLateBound(id, br)\n-            }\n-            'B' => {\n-                assert_eq!(self.next(), '[');\n-                let index = self.parse_u32();\n-                assert_eq!(self.next(), '|');\n-                let name = token::intern(&self.parse_str(']'));\n-                ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    index: index,\n-                    name: name\n-                })\n-            }\n-            'f' => {\n-                assert_eq!(self.next(), '[');\n-                let scope = self.parse_scope();\n-                assert_eq!(self.next(), '|');\n-                let br = self.parse_bound_region();\n-                assert_eq!(self.next(), ']');\n-                ty::ReFree(ty::FreeRegion { scope: scope,\n-                                            bound_region: br})\n-            }\n-            's' => {\n-                let scope = self.parse_scope();\n-                assert_eq!(self.next(), '|');\n-                ty::ReScope(scope)\n-            }\n-            't' => ty::ReStatic,\n-            'e' => ty::ReEmpty,\n-            'E' => ty::ReErased,\n-            _ => bug!(\"parse_region: bad input\")\n-        })\n-    }\n-\n-    fn parse_scope(&mut self) -> region::CodeExtent {\n-        self.tcx.region_maps.bogus_code_extent(match self.next() {\n-            // This creates scopes with the wrong NodeId. This isn't\n-            // actually a problem because scopes only exist *within*\n-            // functions, and functions aren't loaded until trans which\n-            // doesn't care about regions.\n-            //\n-            // May still be worth fixing though.\n-            'C' => {\n-                assert_eq!(self.next(), '[');\n-                let fn_id = self.parse_uint() as ast::NodeId;\n-                assert_eq!(self.next(), '|');\n-                let body_id = self.parse_uint() as ast::NodeId;\n-                assert_eq!(self.next(), ']');\n-                region::CodeExtentData::CallSiteScope {\n-                    fn_id: fn_id, body_id: body_id\n-                }\n-            }\n-            // This creates scopes with the wrong NodeId. (See note above.)\n-            'P' => {\n-                assert_eq!(self.next(), '[');\n-                let fn_id = self.parse_uint() as ast::NodeId;\n-                assert_eq!(self.next(), '|');\n-                let body_id = self.parse_uint() as ast::NodeId;\n-                assert_eq!(self.next(), ']');\n-                region::CodeExtentData::ParameterScope {\n-                    fn_id: fn_id, body_id: body_id\n-                }\n-            }\n-            'M' => {\n-                let node_id = self.parse_uint() as ast::NodeId;\n-                region::CodeExtentData::Misc(node_id)\n-            }\n-            'D' => {\n-                let node_id = self.parse_uint() as ast::NodeId;\n-                region::CodeExtentData::DestructionScope(node_id)\n-            }\n-            'B' => {\n-                assert_eq!(self.next(), '[');\n-                let node_id = self.parse_uint() as ast::NodeId;\n-                assert_eq!(self.next(), '|');\n-                let first_stmt_index = self.parse_u32();\n-                assert_eq!(self.next(), ']');\n-                let block_remainder = region::BlockRemainder {\n-                    block: node_id, first_statement_index: first_stmt_index,\n-                };\n-                region::CodeExtentData::Remainder(block_remainder)\n-            }\n-            _ => bug!(\"parse_scope: bad input\")\n-        })\n-    }\n-\n-    fn parse_opt<T, F>(&mut self, f: F) -> Option<T>\n-        where F: FnOnce(&mut TyDecoder<'a, 'tcx>) -> T,\n-    {\n-        match self.next() {\n-            'n' => None,\n-            's' => Some(f(self)),\n-            _ => bug!(\"parse_opt: bad input\")\n-        }\n-    }\n-\n-    fn parse_str(&mut self, term: char) -> String {\n-        let mut result = String::new();\n-        while self.peek() != term {\n-            unsafe {\n-                result.as_mut_vec().extend_from_slice(&[self.next_byte()])\n-            }\n-        }\n-        self.next();\n-        result\n-    }\n-\n-    pub fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n-        ty::TraitRef {\n-            def_id: self.parse_def(),\n-            substs: self.parse_substs()\n-        }\n-    }\n-\n-    pub fn parse_existential_trait_ref(&mut self) -> ty::ExistentialTraitRef<'tcx> {\n-        ty::ExistentialTraitRef {\n-            def_id: self.parse_def(),\n-            substs: self.parse_substs()\n-        }\n-    }\n-\n-    pub fn parse_ty(&mut self) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-        match self.next() {\n-            'b' => return tcx.types.bool,\n-            '!' => return tcx.types.never,\n-            'i' => { /* eat the s of is */ self.next(); return tcx.types.isize },\n-            'u' => { /* eat the s of us */ self.next(); return tcx.types.usize },\n-            'M' => {\n-                match self.next() {\n-                    'b' => return tcx.types.u8,\n-                    'w' => return tcx.types.u16,\n-                    'l' => return tcx.types.u32,\n-                    'd' => return tcx.types.u64,\n-                    'B' => return tcx.types.i8,\n-                    'W' => return tcx.types.i16,\n-                    'L' => return tcx.types.i32,\n-                    'D' => return tcx.types.i64,\n-                    'f' => return tcx.types.f32,\n-                    'F' => return tcx.types.f64,\n-                    _ => bug!(\"parse_ty: bad numeric type\")\n-                }\n-            }\n-            'c' => return tcx.types.char,\n-            'x' => {\n-                assert_eq!(self.next(), '[');\n-                let trait_ref = ty::Binder(self.parse_existential_trait_ref());\n-                let builtin_bounds = self.parse_builtin_bounds();\n-                let region_bound = self.parse_region();\n-                let mut projection_bounds = Vec::new();\n-\n-                loop {\n-                    match self.next() {\n-                        'P' => {\n-                            let bound = self.parse_existential_projection();\n-                            projection_bounds.push(ty::Binder(bound));\n-                        }\n-                        '.' => { break; }\n-                        c => {\n-                            bug!(\"parse_bounds: bad bounds ('{}')\", c)\n-                        }\n-                    }\n-                }\n-                assert_eq!(self.next(), ']');\n-                return tcx.mk_trait(ty::TraitObject {\n-                    principal: trait_ref,\n-                    region_bound: region_bound,\n-                    builtin_bounds: builtin_bounds,\n-                    projection_bounds: projection_bounds\n-                });\n-            }\n-            'p' => {\n-                assert_eq!(self.next(), '[');\n-                let index = self.parse_u32();\n-                assert_eq!(self.next(), '|');\n-                let name = token::intern(&self.parse_str(']'));\n-                return tcx.mk_param(index, name);\n-            }\n-            '~' => return tcx.mk_box(self.parse_ty()),\n-            '*' => return tcx.mk_ptr(self.parse_mt()),\n-            '&' => {\n-                return tcx.mk_ref(self.parse_region(), self.parse_mt());\n-            }\n-            'V' => {\n-                let t = self.parse_ty();\n-                return match self.parse_size() {\n-                    Some(n) => tcx.mk_array(t, n),\n-                    None => tcx.mk_slice(t)\n-                };\n-            }\n-            'v' => {\n-                return tcx.mk_str();\n-            }\n-            'T' => {\n-                assert_eq!(self.next(), '[');\n-                let mut params = Vec::new();\n-                while self.peek() != ']' { params.push(self.parse_ty()); }\n-                self.pos = self.pos + 1;\n-                return tcx.mk_tup(params);\n-            }\n-            'F' => {\n-                let def_id = self.parse_def();\n-                let substs = self.parse_substs();\n-                return tcx.mk_fn_def(def_id, substs, self.parse_bare_fn_ty());\n-            }\n-            'G' => {\n-                return tcx.mk_fn_ptr(self.parse_bare_fn_ty());\n-            }\n-            '#' => {\n-                // This is a hacky little caching scheme. The idea is that if we encode\n-                // the same type twice, the second (and third, and fourth...) time we will\n-                // just write `#123`, where `123` is the offset in the metadata of the\n-                // first appearance. Now when we are *decoding*, if we see a `#123`, we\n-                // can first check a cache (`tcx.rcache`) for that offset. If we find something,\n-                // we return it (modulo closure types, see below). But if not, then we\n-                // jump to offset 123 and read the type from there.\n-\n-                let pos = self.parse_vuint();\n-                let key = ty::CReaderCacheKey { cnum: self.krate, pos: pos };\n-                if let Some(tt) = tcx.rcache.borrow().get(&key).cloned() {\n-                    // If there is a closure buried in the type some where, then we\n-                    // need to re-convert any def ids (see case 'k', below). That means\n-                    // we can't reuse the cached version.\n-                    if !tt.has_closure_types() {\n-                        return tt;\n-                    }\n-                }\n-\n-                let mut substate = TyDecoder::new(self.data,\n-                                                  self.krate,\n-                                                  pos,\n-                                                  self.tcx,\n-                                                  self.conv_def_id);\n-                let tt = substate.parse_ty();\n-                tcx.rcache.borrow_mut().insert(key, tt);\n-                return tt;\n-            }\n-            '\\\"' => {\n-                let _ = self.parse_def();\n-                let inner = self.parse_ty();\n-                inner\n-            }\n-            'a' => {\n-                assert_eq!(self.next(), '[');\n-                let did = self.parse_def();\n-                let substs = self.parse_substs();\n-                assert_eq!(self.next(), ']');\n-                let def = self.tcx.lookup_adt_def(did);\n-                return self.tcx.mk_adt(def, substs);\n-            }\n-            'k' => {\n-                assert_eq!(self.next(), '[');\n-                let did = self.parse_def();\n-                let substs = self.parse_substs();\n-                let mut tys = vec![];\n-                while self.peek() != '.' {\n-                    tys.push(self.parse_ty());\n-                }\n-                assert_eq!(self.next(), '.');\n-                assert_eq!(self.next(), ']');\n-                return self.tcx.mk_closure(did, substs, tys);\n-            }\n-            'P' => {\n-                assert_eq!(self.next(), '[');\n-                let trait_ref = self.parse_trait_ref();\n-                let name = token::intern(&self.parse_str(']'));\n-                return tcx.mk_projection(trait_ref, name);\n-            }\n-            'A' => {\n-                assert_eq!(self.next(), '[');\n-                let def_id = self.parse_def();\n-                let substs = self.parse_substs();\n-                assert_eq!(self.next(), ']');\n-                return self.tcx.mk_anon(def_id, substs);\n-            }\n-            'e' => {\n-                return tcx.types.err;\n-            }\n-            c => { bug!(\"unexpected char in type string: {}\", c);}\n-        }\n-    }\n-\n-    fn parse_mutability(&mut self) -> hir::Mutability {\n-        match self.peek() {\n-            'm' => { self.next(); hir::MutMutable }\n-            _ => { hir::MutImmutable }\n-        }\n-    }\n-\n-    fn parse_mt(&mut self) -> ty::TypeAndMut<'tcx> {\n-        let m = self.parse_mutability();\n-        ty::TypeAndMut { ty: self.parse_ty(), mutbl: m }\n-    }\n-\n-    fn parse_def(&mut self) -> DefId {\n-        let def_id = parse_defid(self.scan(|c| c == '|'));\n-        return (self.conv_def_id)(def_id);\n-    }\n-\n-    fn parse_uint(&mut self) -> usize {\n-        let mut n = 0;\n-        loop {\n-            let cur = self.peek();\n-            if cur < '0' || cur > '9' { return n; }\n-            self.pos = self.pos + 1;\n-            n *= 10;\n-            n += (cur as usize) - ('0' as usize);\n-        };\n-    }\n-\n-    fn parse_u32(&mut self) -> u32 {\n-        let n = self.parse_uint();\n-        let m = n as u32;\n-        assert_eq!(m as usize, n);\n-        m\n-    }\n-\n-    fn parse_abi_set(&mut self) -> abi::Abi {\n-        assert_eq!(self.next(), '[');\n-        let bytes = self.scan(|c| c == ']');\n-        let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(&abi_str[..]).expect(abi_str)\n-    }\n-\n-    pub fn parse_closure_ty(&mut self) -> ty::ClosureTy<'tcx> {\n-        let unsafety = parse_unsafety(self.next());\n-        let sig = self.parse_sig();\n-        let abi = self.parse_abi_set();\n-        ty::ClosureTy {\n-            unsafety: unsafety,\n-            sig: sig,\n-            abi: abi,\n-        }\n-    }\n-\n-    pub fn parse_bare_fn_ty(&mut self) -> &'tcx ty::BareFnTy<'tcx> {\n-        let unsafety = parse_unsafety(self.next());\n-        let abi = self.parse_abi_set();\n-        let sig = self.parse_sig();\n-        self.tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: unsafety,\n-            abi: abi,\n-            sig: sig\n-        })\n-    }\n-\n-    fn parse_sig(&mut self) -> ty::PolyFnSig<'tcx> {\n-        assert_eq!(self.next(), '[');\n-        let mut inputs = Vec::new();\n-        while self.peek() != ']' {\n-            inputs.push(self.parse_ty());\n-        }\n-        self.pos += 1; // eat the ']'\n-        let variadic = match self.next() {\n-            'V' => true,\n-            'N' => false,\n-            r => bug!(\"bad variadic: {}\", r),\n-        };\n-        let output = self.parse_ty();\n-        ty::Binder(ty::FnSig {inputs: inputs,\n-                              output: output,\n-                              variadic: variadic})\n-    }\n-\n-    pub fn parse_predicate(&mut self) -> ty::Predicate<'tcx> {\n-        match self.next() {\n-            't' => ty::Binder(self.parse_trait_ref()).to_predicate(),\n-            'e' => ty::Binder(ty::EquatePredicate(self.parse_ty(),\n-                                                  self.parse_ty())).to_predicate(),\n-            'r' => ty::Binder(ty::OutlivesPredicate(self.parse_region(),\n-                                                    self.parse_region())).to_predicate(),\n-            'o' => ty::Binder(ty::OutlivesPredicate(self.parse_ty(),\n-                                                    self.parse_region())).to_predicate(),\n-            'p' => ty::Binder(self.parse_projection_predicate()).to_predicate(),\n-            'w' => ty::Predicate::WellFormed(self.parse_ty()),\n-            'O' => {\n-                let def_id = self.parse_def();\n-                assert_eq!(self.next(), '|');\n-                ty::Predicate::ObjectSafe(def_id)\n-            }\n-            'c' => {\n-                let def_id = self.parse_def();\n-                assert_eq!(self.next(), '|');\n-                let kind = match self.next() {\n-                    'f' => ty::ClosureKind::Fn,\n-                    'm' => ty::ClosureKind::FnMut,\n-                    'o' => ty::ClosureKind::FnOnce,\n-                    c => bug!(\"Encountered invalid character in metadata: {}\", c)\n-                };\n-                assert_eq!(self.next(), '|');\n-                ty::Predicate::ClosureKind(def_id, kind)\n-            }\n-            c => bug!(\"Encountered invalid character in metadata: {}\", c)\n-        }\n-    }\n-\n-    fn parse_projection_predicate(&mut self) -> ty::ProjectionPredicate<'tcx> {\n-        ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n-                trait_ref: self.parse_trait_ref(),\n-                item_name: token::intern(&self.parse_str('|')),\n-            },\n-            ty: self.parse_ty(),\n-        }\n-    }\n-\n-    fn parse_existential_projection(&mut self) -> ty::ExistentialProjection<'tcx> {\n-        ty::ExistentialProjection {\n-            trait_ref: self.parse_existential_trait_ref(),\n-            item_name: token::intern(&self.parse_str('|')),\n-            ty: self.parse_ty(),\n-        }\n-    }\n-\n-    fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n-        let name = self.parse_name(':');\n-        let def_id = self.parse_def();\n-        let index = self.parse_u32();\n-        assert_eq!(self.next(), '|');\n-        let default_def_id = self.parse_def();\n-        let default = self.parse_opt(|this| this.parse_ty());\n-        let object_lifetime_default = self.parse_object_lifetime_default();\n-\n-        ty::TypeParameterDef {\n-            name: name,\n-            def_id: def_id,\n-            index: index,\n-            default_def_id: default_def_id,\n-            default: default,\n-            object_lifetime_default: object_lifetime_default,\n-        }\n-    }\n-\n-    fn parse_region_param_def(&mut self) -> ty::RegionParameterDef<'tcx> {\n-        let name = self.parse_name(':');\n-        let def_id = self.parse_def();\n-        let index = self.parse_u32();\n-        assert_eq!(self.next(), '|');\n-        let mut bounds = vec![];\n-        loop {\n-            match self.next() {\n-                'R' => bounds.push(self.parse_region()),\n-                '.' => { break; }\n-                c => {\n-                    bug!(\"parse_region_param_def: bad bounds ('{}')\", c)\n-                }\n-            }\n-        }\n-        ty::RegionParameterDef {\n-            name: name,\n-            def_id: def_id,\n-            index: index,\n-            bounds: bounds,\n-        }\n-    }\n-\n-\n-    fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault<'tcx> {\n-        match self.next() {\n-            'a' => ty::ObjectLifetimeDefault::Ambiguous,\n-            'b' => ty::ObjectLifetimeDefault::BaseDefault,\n-            's' => {\n-                let region = self.parse_region();\n-                ty::ObjectLifetimeDefault::Specific(region)\n-            }\n-            _ => bug!(\"parse_object_lifetime_default: bad input\")\n-        }\n-    }\n-\n-    fn parse_builtin_bounds(&mut self) -> ty::BuiltinBounds {\n-        let mut builtin_bounds = ty::BuiltinBounds::empty();\n-        loop {\n-            match self.next() {\n-                'S' => {\n-                    builtin_bounds.insert(ty::BoundSend);\n-                }\n-                'Z' => {\n-                    builtin_bounds.insert(ty::BoundSized);\n-                }\n-                'P' => {\n-                    builtin_bounds.insert(ty::BoundCopy);\n-                }\n-                'T' => {\n-                    builtin_bounds.insert(ty::BoundSync);\n-                }\n-                '.' => {\n-                    return builtin_bounds;\n-                }\n-                c => {\n-                    bug!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Rust metadata parsing\n-fn parse_defid(buf: &[u8]) -> DefId {\n-    let mut colon_idx = 0;\n-    let len = buf.len();\n-    while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1; }\n-    if colon_idx == len {\n-        error!(\"didn't find ':' when parsing def id\");\n-        bug!();\n-    }\n-\n-    let crate_part = &buf[0..colon_idx];\n-    let def_part = &buf[colon_idx + 1..len];\n-\n-    let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n-        s.parse::<usize>().ok()\n-    }) {\n-        Some(cn) => cn as ast::CrateNum,\n-        None => bug!(\"internal error: parse_defid: crate number expected, found {:?}\",\n-                       crate_part)\n-    };\n-    let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n-        s.parse::<usize>().ok()\n-    }) {\n-        Some(dn) => dn,\n-        None => bug!(\"internal error: parse_defid: id expected, found {:?}\",\n-                       def_part)\n-    };\n-    let index = DefIndex::new(def_num);\n-    DefId { krate: crate_num, index: index }\n-}\n-\n-fn parse_unsafety(c: char) -> hir::Unsafety {\n-    match c {\n-        'u' => hir::Unsafety::Unsafe,\n-        'n' => hir::Unsafety::Normal,\n-        _ => bug!(\"parse_unsafety: bad unsafety {}\", c)\n-    }\n-}"}, {"sha": "dbefd3eacc24aabeac7df1a3d5fee51fa7f891ce", "filename": "src/librustc_metadata/tyencode.rs", "status": "removed", "additions": 0, "deletions": 519, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9812a59ab7247f0f52b01ca89b0793a2d289c3/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=4f9812a59ab7247f0f52b01ca89b0793a2d289c3", "patch": "@@ -1,519 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Type encoding\n-\n-#![allow(unused_must_use)] // as with encoding, everything is a no-fail MemWriter\n-#![allow(non_camel_case_types)]\n-\n-use std::cell::RefCell;\n-use std::io::Cursor;\n-use std::io::prelude::*;\n-\n-use rustc::hir::def_id::DefId;\n-use middle::region;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::nodemap::FnvHashMap;\n-\n-use rustc::hir;\n-\n-use syntax::abi::Abi;\n-use syntax::ast;\n-use errors::Handler;\n-\n-use rbml::leb128;\n-use encoder;\n-\n-pub struct ctxt<'a, 'tcx: 'a> {\n-    pub diag: &'a Handler,\n-    // Def -> str Callback:\n-    pub ds: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String,\n-    // The type context.\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub abbrevs: &'a abbrev_map<'tcx>\n-}\n-\n-impl<'a, 'tcx> encoder::EncodeContext<'a, 'tcx> {\n-    pub fn ty_str_ctxt<'b>(&'b self) -> ctxt<'b, 'tcx> {\n-        ctxt {\n-            diag: self.tcx.sess.diagnostic(),\n-            ds: encoder::def_to_string,\n-            tcx: self.tcx,\n-            abbrevs: &self.type_abbrevs\n-        }\n-    }\n-}\n-\n-// Compact string representation for Ty values. API TyStr & parse_from_str.\n-// Extra parameters are for converting to/from def_ids in the string rep.\n-// Whatever format you choose should not contain pipe characters.\n-pub struct ty_abbrev {\n-    s: Vec<u8>\n-}\n-\n-pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n-\n-pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n-    if let Some(a) = cx.abbrevs.borrow_mut().get(&t) {\n-        w.write_all(&a.s);\n-        return;\n-    }\n-\n-    let pos = w.position();\n-\n-    match t.sty {\n-        ty::TyBool => { write!(w, \"b\"); }\n-        ty::TyChar => { write!(w, \"c\"); }\n-        ty::TyNever => { write!(w, \"!\"); }\n-        ty::TyInt(t) => {\n-            match t {\n-                ast::IntTy::Is => write!(w, \"is\"),\n-                ast::IntTy::I8 => write!(w, \"MB\"),\n-                ast::IntTy::I16 => write!(w, \"MW\"),\n-                ast::IntTy::I32 => write!(w, \"ML\"),\n-                ast::IntTy::I64 => write!(w, \"MD\")\n-            };\n-        }\n-        ty::TyUint(t) => {\n-            match t {\n-                ast::UintTy::Us => write!(w, \"us\"),\n-                ast::UintTy::U8 => write!(w, \"Mb\"),\n-                ast::UintTy::U16 => write!(w, \"Mw\"),\n-                ast::UintTy::U32 => write!(w, \"Ml\"),\n-                ast::UintTy::U64 => write!(w, \"Md\")\n-            };\n-        }\n-        ty::TyFloat(t) => {\n-            match t {\n-                ast::FloatTy::F32 => write!(w, \"Mf\"),\n-                ast::FloatTy::F64 => write!(w, \"MF\"),\n-            };\n-        }\n-        ty::TyTrait(ref obj) => {\n-            write!(w, \"x[\");\n-            enc_existential_trait_ref(w, cx, obj.principal.0);\n-            enc_builtin_bounds(w, cx, &obj.builtin_bounds);\n-\n-            enc_region(w, cx, obj.region_bound);\n-\n-            for tp in &obj.projection_bounds {\n-                write!(w, \"P\");\n-                enc_existential_projection(w, cx, &tp.0);\n-            }\n-\n-            write!(w, \".\");\n-            write!(w, \"]\");\n-        }\n-        ty::TyTuple(ts) => {\n-            write!(w, \"T[\");\n-            for t in ts { enc_ty(w, cx, *t); }\n-            write!(w, \"]\");\n-        }\n-        ty::TyBox(typ) => { write!(w, \"~\"); enc_ty(w, cx, typ); }\n-        ty::TyRawPtr(mt) => { write!(w, \"*\"); enc_mt(w, cx, mt); }\n-        ty::TyRef(r, mt) => {\n-            write!(w, \"&\");\n-            enc_region(w, cx, r);\n-            enc_mt(w, cx, mt);\n-        }\n-        ty::TyArray(t, sz) => {\n-            write!(w, \"V\");\n-            enc_ty(w, cx, t);\n-            write!(w, \"/{}|\", sz);\n-        }\n-        ty::TySlice(t) => {\n-            write!(w, \"V\");\n-            enc_ty(w, cx, t);\n-            write!(w, \"/|\");\n-        }\n-        ty::TyStr => {\n-            write!(w, \"v\");\n-        }\n-        ty::TyFnDef(def_id, substs, f) => {\n-            write!(w, \"F\");\n-            write!(w, \"{}|\", (cx.ds)(cx.tcx, def_id));\n-            enc_substs(w, cx, substs);\n-            enc_bare_fn_ty(w, cx, f);\n-        }\n-        ty::TyFnPtr(f) => {\n-            write!(w, \"G\");\n-            enc_bare_fn_ty(w, cx, f);\n-        }\n-        ty::TyInfer(_) => {\n-            bug!(\"cannot encode inference variable types\");\n-        }\n-        ty::TyParam(p) => {\n-            write!(w, \"p[{}|{}]\", p.idx, p.name);\n-        }\n-        ty::TyAdt(def, substs) => {\n-            write!(w, \"a[{}|\", (cx.ds)(cx.tcx, def.did));\n-            enc_substs(w, cx, substs);\n-            write!(w, \"]\");\n-        }\n-        ty::TyClosure(def, substs) => {\n-            write!(w, \"k[{}|\", (cx.ds)(cx.tcx, def));\n-            enc_substs(w, cx, substs.func_substs);\n-            for ty in substs.upvar_tys {\n-                enc_ty(w, cx, ty);\n-            }\n-            write!(w, \".\");\n-            write!(w, \"]\");\n-        }\n-        ty::TyProjection(ref data) => {\n-            write!(w, \"P[\");\n-            enc_trait_ref(w, cx, data.trait_ref);\n-            write!(w, \"{}]\", data.item_name);\n-        }\n-        ty::TyAnon(def_id, substs) => {\n-            write!(w, \"A[{}|\", (cx.ds)(cx.tcx, def_id));\n-            enc_substs(w, cx, substs);\n-            write!(w, \"]\");\n-        }\n-        ty::TyError => {\n-            write!(w, \"e\");\n-        }\n-    }\n-\n-    let end = w.position();\n-    let len = end - pos;\n-\n-    let mut abbrev = Cursor::new(Vec::with_capacity(16));\n-    abbrev.write_all(b\"#\");\n-    {\n-        let start_position = abbrev.position() as usize;\n-        let bytes_written = leb128::write_unsigned_leb128(abbrev.get_mut(),\n-                                                          start_position,\n-                                                          pos);\n-        abbrev.set_position((start_position + bytes_written) as u64);\n-    }\n-\n-    cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n-        s: if abbrev.position() < len {\n-            abbrev.get_ref()[..abbrev.position() as usize].to_owned()\n-        } else {\n-            // if the abbreviation is longer than the real type,\n-            // don't use #-notation. However, insert it here so\n-            // other won't have to `mark_stable_position`\n-            w.get_ref()[pos as usize .. end as usize].to_owned()\n-        }\n-    });\n-}\n-\n-fn enc_mutability(w: &mut Cursor<Vec<u8>>, mt: hir::Mutability) {\n-    match mt {\n-        hir::MutImmutable => (),\n-        hir::MutMutable => {\n-            write!(w, \"m\");\n-        }\n-    };\n-}\n-\n-fn enc_mt<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                    mt: ty::TypeAndMut<'tcx>) {\n-    enc_mutability(w, mt.mutbl);\n-    enc_ty(w, cx, mt.ty);\n-}\n-\n-fn enc_opt<T, F>(w: &mut Cursor<Vec<u8>>, t: Option<T>, enc_f: F) where\n-    F: FnOnce(&mut Cursor<Vec<u8>>, T),\n-{\n-    match t {\n-        None => {\n-            write!(w, \"n\");\n-        }\n-        Some(v) => {\n-            write!(w, \"s\");\n-            enc_f(w, v);\n-        }\n-    }\n-}\n-\n-pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                            substs: &Substs<'tcx>) {\n-    write!(w, \"[\");\n-    for &k in substs.params() {\n-        if let Some(ty) = k.as_type() {\n-            write!(w, \"t\");\n-            enc_ty(w, cx, ty);\n-        } else if let Some(r) = k.as_region() {\n-            write!(w, \"r\");\n-            enc_region(w, cx, r);\n-        } else {\n-            bug!()\n-        }\n-    }\n-    write!(w, \"]\");\n-}\n-\n-pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                              generics: &ty::Generics<'tcx>) {\n-    enc_opt(w, generics.parent, |w, def_id| {\n-        write!(w, \"{}|\", (cx.ds)(cx.tcx, def_id));\n-    });\n-    write!(w, \"{}|{}[\",\n-           generics.parent_regions,\n-           generics.parent_types);\n-\n-    for r in &generics.regions {\n-        enc_region_param_def(w, cx, r)\n-    }\n-    write!(w, \"|\");\n-    for t in &generics.types {\n-        enc_type_param_def(w, cx, t);\n-    }\n-    write!(w, \"]\");\n-\n-    if generics.has_self {\n-        write!(w, \"S\");\n-    } else {\n-        write!(w, \"N\");\n-    }\n-}\n-\n-pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: &ty::Region) {\n-    match *r {\n-        ty::ReLateBound(id, br) => {\n-            write!(w, \"b[{}|\", id.depth);\n-            enc_bound_region(w, cx, br);\n-            write!(w, \"]\");\n-        }\n-        ty::ReEarlyBound(ref data) => {\n-            write!(w, \"B[{}|{}]\",\n-                   data.index,\n-                   data.name);\n-        }\n-        ty::ReFree(ref fr) => {\n-            write!(w, \"f[\");\n-            enc_scope(w, cx, fr.scope);\n-            write!(w, \"|\");\n-            enc_bound_region(w, cx, fr.bound_region);\n-            write!(w, \"]\");\n-        }\n-        ty::ReScope(scope) => {\n-            write!(w, \"s\");\n-            enc_scope(w, cx, scope);\n-            write!(w, \"|\");\n-        }\n-        ty::ReStatic => {\n-            write!(w, \"t\");\n-        }\n-        ty::ReEmpty => {\n-            write!(w, \"e\");\n-        }\n-        ty::ReErased => {\n-            write!(w, \"E\");\n-        }\n-        ty::ReVar(_) | ty::ReSkolemized(..) => {\n-            // these should not crop up after typeck\n-            bug!(\"cannot encode region variables\");\n-        }\n-    }\n-}\n-\n-fn enc_scope(w: &mut Cursor<Vec<u8>>, cx: &ctxt, scope: region::CodeExtent) {\n-    match cx.tcx.region_maps.code_extent_data(scope) {\n-        region::CodeExtentData::CallSiteScope {\n-            fn_id, body_id } => write!(w, \"C[{}|{}]\", fn_id, body_id),\n-        region::CodeExtentData::ParameterScope {\n-            fn_id, body_id } => write!(w, \"P[{}|{}]\", fn_id, body_id),\n-        region::CodeExtentData::Misc(node_id) => write!(w, \"M{}\", node_id),\n-        region::CodeExtentData::Remainder(region::BlockRemainder {\n-            block: b, first_statement_index: i }) => write!(w, \"B[{}|{}]\", b, i),\n-        region::CodeExtentData::DestructionScope(node_id) => write!(w, \"D{}\", node_id),\n-    };\n-}\n-\n-fn enc_bound_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, br: ty::BoundRegion) {\n-    match br {\n-        ty::BrAnon(idx) => {\n-            write!(w, \"a{}|\", idx);\n-        }\n-        ty::BrNamed(d, name, issue32330) => {\n-            write!(w, \"[{}|{}|\",\n-                   (cx.ds)(cx.tcx, d),\n-                   name);\n-\n-            match issue32330 {\n-                ty::Issue32330::WontChange =>\n-                    write!(w, \"n]\"),\n-                ty::Issue32330::WillChange { fn_def_id, region_name } =>\n-                    write!(w, \"y{}|{}]\", (cx.ds)(cx.tcx, fn_def_id), region_name),\n-            };\n-        }\n-        ty::BrFresh(id) => {\n-            write!(w, \"f{}|\", id);\n-        }\n-        ty::BrEnv => {\n-            write!(w, \"e|\");\n-        }\n-    }\n-}\n-\n-pub fn enc_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                               s: ty::TraitRef<'tcx>) {\n-    write!(w, \"{}|\", (cx.ds)(cx.tcx, s.def_id));\n-    enc_substs(w, cx, s.substs);\n-}\n-\n-fn enc_existential_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                       s: ty::ExistentialTraitRef<'tcx>) {\n-    write!(w, \"{}|\", (cx.ds)(cx.tcx, s.def_id));\n-    enc_substs(w, cx, s.substs);\n-}\n-\n-fn enc_unsafety(w: &mut Cursor<Vec<u8>>, p: hir::Unsafety) {\n-    match p {\n-        hir::Unsafety::Normal => write!(w, \"n\"),\n-        hir::Unsafety::Unsafe => write!(w, \"u\"),\n-    };\n-}\n-\n-fn enc_abi(w: &mut Cursor<Vec<u8>>, abi: Abi) {\n-    write!(w, \"[\");\n-    write!(w, \"{}\", abi.name());\n-    write!(w, \"]\");\n-}\n-\n-pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                ft: &ty::BareFnTy<'tcx>) {\n-    enc_unsafety(w, ft.unsafety);\n-    enc_abi(w, ft.abi);\n-    enc_fn_sig(w, cx, &ft.sig);\n-}\n-\n-pub fn enc_closure_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                ft: &ty::ClosureTy<'tcx>) {\n-    enc_unsafety(w, ft.unsafety);\n-    enc_fn_sig(w, cx, &ft.sig);\n-    enc_abi(w, ft.abi);\n-}\n-\n-fn enc_fn_sig<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                        fsig: &ty::PolyFnSig<'tcx>) {\n-    write!(w, \"[\");\n-    for ty in &fsig.0.inputs {\n-        enc_ty(w, cx, *ty);\n-    }\n-    write!(w, \"]\");\n-    if fsig.0.variadic {\n-        write!(w, \"V\");\n-    } else {\n-        write!(w, \"N\");\n-    }\n-    enc_ty(w, cx, fsig.0.output);\n-}\n-\n-fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n-    for bound in bs {\n-        match bound {\n-            ty::BoundSend => write!(w, \"S\"),\n-            ty::BoundSized => write!(w, \"Z\"),\n-            ty::BoundCopy => write!(w, \"P\"),\n-            ty::BoundSync => write!(w, \"T\"),\n-        };\n-    }\n-\n-    write!(w, \".\");\n-}\n-\n-fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                v: &ty::TypeParameterDef<'tcx>) {\n-    write!(w, \"{}:{}|{}|{}|\",\n-           v.name, (cx.ds)(cx.tcx, v.def_id),\n-           v.index, (cx.ds)(cx.tcx, v.default_def_id));\n-    enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n-    enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n-}\n-\n-fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n-                        v: &ty::RegionParameterDef) {\n-    write!(w, \"{}:{}|{}|\",\n-           v.name, (cx.ds)(cx.tcx, v.def_id), v.index);\n-    for &r in &v.bounds {\n-        write!(w, \"R\");\n-        enc_region(w, cx, r);\n-    }\n-    write!(w, \".\");\n-}\n-\n-fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n-                                         cx: &ctxt<'a, 'tcx>,\n-                                         default: ty::ObjectLifetimeDefault)\n-{\n-    match default {\n-        ty::ObjectLifetimeDefault::Ambiguous => {\n-            write!(w, \"a\");\n-        }\n-        ty::ObjectLifetimeDefault::BaseDefault => {\n-            write!(w, \"b\");\n-        }\n-        ty::ObjectLifetimeDefault::Specific(r) => {\n-            write!(w, \"s\");\n-            enc_region(w, cx, r);\n-        }\n-    }\n-}\n-\n-pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n-                               cx: &ctxt<'a, 'tcx>,\n-                               p: &ty::Predicate<'tcx>)\n-{\n-    match *p {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            write!(w, \"t\");\n-            enc_trait_ref(w, cx, trait_ref.0.trait_ref);\n-        }\n-        ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n-            write!(w, \"e\");\n-            enc_ty(w, cx, a);\n-            enc_ty(w, cx, b);\n-        }\n-        ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n-            write!(w, \"r\");\n-            enc_region(w, cx, a);\n-            enc_region(w, cx, b);\n-        }\n-        ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n-            write!(w, \"o\");\n-            enc_ty(w, cx, a);\n-            enc_region(w, cx, b);\n-        }\n-        ty::Predicate::Projection(ty::Binder(ref data)) => {\n-            write!(w, \"p\");\n-            enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n-            write!(w, \"{}|\", data.projection_ty.item_name);\n-            enc_ty(w, cx, data.ty);\n-        }\n-        ty::Predicate::WellFormed(data) => {\n-            write!(w, \"w\");\n-            enc_ty(w, cx, data);\n-        }\n-        ty::Predicate::ObjectSafe(trait_def_id) => {\n-            write!(w, \"O{}|\", (cx.ds)(cx.tcx, trait_def_id));\n-        }\n-        ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-            let kind_char = match kind {\n-                ty::ClosureKind::Fn => 'f',\n-                ty::ClosureKind::FnMut => 'm',\n-                ty::ClosureKind::FnOnce => 'o',\n-            };\n-            write!(w, \"c{}|{}|\", (cx.ds)(cx.tcx, closure_def_id), kind_char);\n-        }\n-    }\n-}\n-\n-fn enc_existential_projection<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n-                                        cx: &ctxt<'a, 'tcx>,\n-                                        data: &ty::ExistentialProjection<'tcx>) {\n-    enc_existential_trait_ref(w, cx, data.trait_ref);\n-    write!(w, \"{}|\", data.item_name);\n-    enc_ty(w, cx, data.ty);\n-}"}, {"sha": "23591f05b8774f27d6a61815335a8ca58559f332", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -197,8 +197,9 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n+            let var_id = tcx.map.as_local_node_id(fv.def.def_id()).unwrap();\n             let by_ref = tcx.upvar_capture(ty::UpvarId {\n-                var_id: fv.def.var_id(),\n+                var_id: var_id,\n                 closure_expr_id: fn_id\n             }).map_or(false, |capture| match capture {\n                 ty::UpvarCapture::ByValue => false,\n@@ -208,7 +209,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref\n             };\n-            if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(fv.def.var_id()) {\n+            if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(var_id) {\n                 if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }"}, {"sha": "6283ff2187ab8bbed00b8ff395d367627f26a409", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -271,7 +271,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n                         match cx.tcx.expect_def(fun.id) {\n-                            Def::Variant(_, variant_id) => {\n+                            Def::Variant(variant_id) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             },\n                             Def::Struct(..) => {\n@@ -480,8 +480,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                     AdtKind::Enum => {\n                         match cx.tcx.expect_def(expr.id) {\n-                            Def::Variant(enum_id, variant_id) => {\n-                                debug_assert!(adt.did == enum_id);\n+                            Def::Variant(variant_id) => {\n                                 assert!(base.is_none());\n \n                                 let index = adt.variant_index_with_id(variant_id);\n@@ -688,13 +687,12 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             },\n             ref sty => bug!(\"unexpected sty: {:?}\", sty)\n         },\n-        Def::Variant(enum_id, variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n+        Def::Variant(variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A variant constructor. Should only be reached if not called in the same\n             // expression.\n             ty::TyFnDef(..) => variant_id,\n             // A unit variant, similar special case to the struct case above.\n             ty::TyAdt(adt_def, substs) => {\n-                debug_assert!(adt_def.did == enum_id);\n                 let index = adt_def.variant_index_with_id(variant_id);\n                 return ExprKind::Adt {\n                     adt_def: adt_def,\n@@ -729,13 +727,15 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     match def {\n-        Def::Local(_, node_id) => {\n+        Def::Local(def_id) => {\n+            let node_id = cx.tcx.map.as_local_node_id(def_id).unwrap();\n             ExprKind::VarRef {\n                 id: node_id,\n             }\n         }\n \n-        Def::Upvar(_, id_var, index, closure_expr_id) => {\n+        Def::Upvar(def_id, index, closure_expr_id) => {\n+            let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n             let var_ty = cx.tcx.node_id_to_type(id_var);\n \n@@ -974,7 +974,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    freevar: &hir::Freevar,\n                                    freevar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let id_var = freevar.def.var_id();\n+    let id_var = cx.tcx.map.as_local_node_id(freevar.def.def_id()).unwrap();\n     let upvar_id = ty::UpvarId {\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,"}, {"sha": "7b8446b184fb3725f4fd8fc2170c25a23a9cbe62", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -158,7 +158,8 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             }\n \n             PatKind::Binding(bm, ref ident, ref sub) => {\n-                let id = self.cx.tcx.expect_def(pat.id).var_id();\n+                let def_id = self.cx.tcx.expect_def(pat.id).def_id();\n+                let id = self.cx.tcx.map.as_local_node_id(def_id).unwrap();\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n@@ -300,7 +301,8 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                        subpatterns: Vec<FieldPattern<'tcx>>)\n                        -> PatternKind<'tcx> {\n         match self.cx.tcx.expect_def(pat.id) {\n-            Def::Variant(enum_id, variant_id) => {\n+            Def::Variant(variant_id) => {\n+                let enum_id = self.cx.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     PatternKind::Variant {"}, {"sha": "7b6a2f5580819c98ddce4ee4265185aeb3ada921", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -20,6 +20,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{self, Visitor};\n use std::fmt;\n+use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -674,7 +675,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         where T: fmt::Debug + TypeFoldable<'tcx>\n     {\n         let mut selcx = traits::SelectionContext::new(self.infcx);\n-        let cause = traits::ObligationCause::misc(self.last_span, 0);\n+        let cause = traits::ObligationCause::misc(self.last_span, ast::CRATE_NODE_ID);\n         let traits::Normalized { value, obligations } =\n             traits::normalize(&mut selcx, cause, value);\n "}, {"sha": "0ab8e2d7fcd2812b50e8740fcf687c18629670b0", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -272,15 +272,13 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(Def::Variant(enum_id, variant_id)) => {\n-                        if let Some(enum_node_id) = self.ast_map.as_local_node_id(enum_id) {\n-                            if let hir::ItemEnum(ref enum_def, ref generics) = self.ast_map\n-                                .expect_item(enum_node_id)\n-                                .node {\n+                    Some(Def::Variant(variant_id)) => {\n+                        if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n+                            let variant = self.ast_map.expect_variant(variant_id);\n+                            let enum_id = self.ast_map.get_parent(variant_id);\n+                            let enum_item = self.ast_map.expect_item(enum_id);\n+                            if let hir::ItemEnum(ref enum_def, ref generics) = enum_item.node {\n                                 self.populate_enum_discriminants(enum_def);\n-                                let enum_id = self.ast_map.as_local_node_id(enum_id).unwrap();\n-                                let variant_id = self.ast_map.as_local_node_id(variant_id).unwrap();\n-                                let variant = self.ast_map.expect_variant(variant_id);\n                                 self.visit_variant(variant, generics, enum_id);\n                             } else {\n                                 span_bug!(e.span,"}, {"sha": "1b119fd008509c61ed7f8c2bf8f982b12c94f16e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -323,8 +323,13 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n             let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n                 Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n-                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n-                    if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n+                    if let Some(mut node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+                        // Check the trait for associated types.\n+                        if let hir::map::NodeTraitItem(_) = self.ev.tcx.map.get(node_id) {\n+                            node_id = self.ev.tcx.map.get_parent(node_id);\n+                        }\n+\n                         let item = self.ev.tcx.map.expect_item(node_id);\n                         if let Def::TyAlias(..) = def {\n                             // Type aliases are substituted. Associated type aliases are not\n@@ -947,9 +952,14 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                     return\n                 }\n                 Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n-                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n+                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n                     // Non-local means public (private items can't leave their crate, modulo bugs)\n-                    if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                    if let Some(mut node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                        // Check the trait for associated types.\n+                        if let hir::map::NodeTraitItem(_) = self.tcx.map.get(node_id) {\n+                            node_id = self.tcx.map.get_parent(node_id);\n+                        }\n+\n                         let item = self.tcx.map.expect_item(node_id);\n                         let vis = match self.substituted_alias_visibility(item, path) {\n                             Some(vis) => vis,"}, {"sha": "c9591c31831a850fe0ec7b30051ead1eac0ba45e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -21,10 +21,10 @@ use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::{ChildItem, DlDef};\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::ty::{self, VariantKind};\n+use rustc::hir::map::DefPathData;\n+use rustc::ty;\n \n use std::cell::Cell;\n \n@@ -201,7 +201,7 @@ impl<'b> Resolver<'b> {\n                     let module = self.new_extern_crate_module(parent_link, def, item.id);\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n-                    self.build_reduced_graph_for_external_crate(module);\n+                    self.populate_module_if_necessary(module);\n                 }\n             }\n \n@@ -250,8 +250,7 @@ impl<'b> Resolver<'b> {\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n-                    let item_def_id = self.definitions.local_def_id(item.id);\n-                    self.build_reduced_graph_for_variant(variant, item_def_id, module, vis);\n+                    self.build_reduced_graph_for_variant(variant, module, vis);\n                 }\n             }\n \n@@ -314,7 +313,7 @@ impl<'b> Resolver<'b> {\n                             is_static_method = !sig.decl.has_self();\n                             (Def::Method(item_def_id), ValueNS)\n                         }\n-                        TraitItemKind::Type(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n+                        TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n                         TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                     };\n \n@@ -334,7 +333,6 @@ impl<'b> Resolver<'b> {\n     // type and value namespaces.\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n-                                       item_id: DefId,\n                                        parent: Module<'b>,\n                                        vis: ty::Visibility) {\n         let name = variant.node.name.name;\n@@ -346,7 +344,7 @@ impl<'b> Resolver<'b> {\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let def = Def::Variant(item_id, self.definitions.local_def_id(variant.node.data.id()));\n+        let def = Def::Variant(self.definitions.local_def_id(variant.node.data.id()));\n         self.define(parent, name, ValueNS, (def, variant.span, vis));\n         self.define(parent, name, TypeNS, (def, variant.span, vis));\n     }\n@@ -388,38 +386,38 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, xcdef: ChildItem) {\n-        let def = match xcdef.def {\n-            DlDef(def) => def,\n-            _ => return,\n-        };\n-\n-        if let Def::ForeignMod(def_id) = def {\n-            // Foreign modules have no names. Recur and populate eagerly.\n-            for child in self.session.cstore.item_children(def_id) {\n-                self.build_reduced_graph_for_external_crate_def(parent, child);\n-            }\n+    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>,\n+                                                  child: Export) {\n+        let def_id = child.def_id;\n+        let name = child.name;\n+\n+        let def = if let Some(def) = self.session.cstore.describe_def(def_id) {\n+            def\n+        } else {\n             return;\n-        }\n+        };\n \n-        let name = xcdef.name;\n-        let vis = if parent.is_trait() { ty::Visibility::Public } else { xcdef.vis };\n+        let vis = if parent.is_trait() {\n+            ty::Visibility::Public\n+        } else {\n+            self.session.cstore.visibility(def_id)\n+        };\n \n         match def {\n-            Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) => {\n+            Def::Mod(_) | Def::Enum(..) => {\n                 debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n                        name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n                 let module = self.new_module(parent_link, Some(def), None);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n-            Def::Variant(_, variant_id) => {\n+            Def::Variant(variant_id) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n                 let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n                 let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n-                if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n+                if self.session.cstore.variant_kind(variant_id) == Some(ty::VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n                 }\n@@ -433,16 +431,18 @@ impl<'b> Resolver<'b> {\n                        name);\n                 let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n-            Def::Trait(def_id) => {\n+            Def::Trait(_) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n \n                 // If this is a trait, add all the trait item names to the trait\n                 // info.\n \n-                let trait_item_def_ids = self.session.cstore.trait_item_def_ids(def_id);\n-                for trait_item_def in &trait_item_def_ids {\n+                let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n+                for &trait_item_def in &trait_item_def_ids {\n                     let trait_item_name =\n-                        self.session.cstore.item_name(trait_item_def.def_id());\n+                        self.session.cstore.def_key(trait_item_def)\n+                            .disambiguated_data.data.get_opt_name()\n+                            .expect(\"opt_item_name returned None for trait\");\n \n                     debug!(\"(building reduced graph for external crate) ... adding trait item \\\n                             '{}'\",\n@@ -459,8 +459,10 @@ impl<'b> Resolver<'b> {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n                 let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n-            Def::Struct(def_id)\n-                if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n+            Def::Struct(_)\n+                if self.session.cstore.def_key(def_id).disambiguated_data.data !=\n+                   DefPathData::StructCtor\n+                => {\n                 debug!(\"(building reduced graph for external crate) building type and value for {}\",\n                        name);\n                 let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n@@ -473,7 +475,7 @@ impl<'b> Resolver<'b> {\n                 let fields = self.session.cstore.struct_field_names(def_id);\n                 self.structs.insert(def_id, fields);\n             }\n-            Def::Union(def_id) => {\n+            Def::Union(_) => {\n                 let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n \n                 // Record the def ID and fields of this union.\n@@ -493,15 +495,6 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n-    /// Builds the reduced graph rooted at the 'use' directive for an external\n-    /// crate.\n-    fn build_reduced_graph_for_external_crate(&mut self, root: Module<'b>) {\n-        let root_cnum = root.def_id().unwrap().krate;\n-        for child in self.session.cstore.crate_top_level_items(root_cnum) {\n-            self.build_reduced_graph_for_external_crate_def(root, child);\n-        }\n-    }\n-\n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {"}, {"sha": "016b621eabd4c598c79421e17240667754a4a777", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -49,14 +49,14 @@ use rustc::middle::cstore::MacroLoader;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n-use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n+use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -1151,8 +1151,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         self.def_map.insert(id, PathResolution::new(def));\n     }\n \n-    fn definitions(&mut self) -> Option<&mut Definitions> {\n-        Some(&mut self.definitions)\n+    fn definitions(&mut self) -> &mut Definitions {\n+        &mut self.definitions\n     }\n }\n \n@@ -1275,6 +1275,7 @@ impl<'a> Resolver<'a> {\n                                -> Module<'a> {\n         let mut module = ModuleS::new(parent_link, Some(def), Some(local_node_id));\n         module.extern_crate_id = Some(local_node_id);\n+        module.populated.set(false);\n         self.arenas.modules.alloc(module)\n     }\n \n@@ -1959,7 +1960,8 @@ impl<'a> Resolver<'a> {\n                 // Resolve the self type.\n                 this.visit_ty(self_type);\n \n-                this.with_self_rib(Def::SelfTy(trait_id, Some(item_id)), |this| {\n+                let item_def_id = this.definitions.local_def_id(item_id);\n+                this.with_self_rib(Def::SelfTy(trait_id, Some(item_def_id)), |this| {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n                             this.resolve_visibility(&impl_item.vis);\n@@ -2243,7 +2245,7 @@ impl<'a> Resolver<'a> {\n         // must not add it if it's in the bindings map\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n-        let mut def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n+        let mut def = Def::Local(self.definitions.local_def_id(pat_id));\n         match bindings.get(&ident.node).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n@@ -2559,21 +2561,21 @@ impl<'a> Resolver<'a> {\n             Def::Upvar(..) => {\n                 span_bug!(span, \"unexpected {:?} in bindings\", def)\n             }\n-            Def::Local(_, node_id) => {\n+            Def::Local(def_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n                             let prev_def = def;\n-                            let node_def_id = self.definitions.local_def_id(node_id);\n+                            let node_id = self.definitions.as_local_node_id(def_id).unwrap();\n \n                             let seen = self.freevars_seen\n                                            .entry(function_id)\n                                            .or_insert_with(|| NodeMap());\n                             if let Some(&index) = seen.get(&node_id) {\n-                                def = Def::Upvar(node_def_id, node_id, index, function_id);\n+                                def = Def::Upvar(def_id, index, function_id);\n                                 continue;\n                             }\n                             let vec = self.freevars\n@@ -2585,7 +2587,7 @@ impl<'a> Resolver<'a> {\n                                 span: span,\n                             });\n \n-                            def = Def::Upvar(node_def_id, node_id, depth, function_id);\n+                            def = Def::Upvar(def_id, depth, function_id);\n                             seen.insert(node_id, depth);\n                         }\n                         ItemRibKind | MethodRibKind(_) => {\n@@ -2755,7 +2757,7 @@ impl<'a> Resolver<'a> {\n             if let Some(resolution) = self.def_map.get(&node_id) {\n                 match resolution.base_def {\n                     Def::Enum(did) | Def::TyAlias(did) | Def::Union(did) |\n-                    Def::Struct(did) | Def::Variant(_, did) if resolution.depth == 0 => {\n+                    Def::Struct(did) | Def::Variant(did) if resolution.depth == 0 => {\n                         if let Some(fields) = self.structs.get(&did) {\n                             if fields.iter().any(|&field_name| name == field_name) {\n                                 return Field;\n@@ -2824,7 +2826,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(path_res) = self.resolve_possibly_assoc_item(expr.id,\n                                                             maybe_qself.as_ref(), path, ValueNS) {\n                     // Check if struct variant\n-                    let is_struct_variant = if let Def::Variant(_, variant_id) = path_res.base_def {\n+                    let is_struct_variant = if let Def::Variant(variant_id) = path_res.base_def {\n                         self.structs.contains_key(&variant_id)\n                     } else {\n                         false"}, {"sha": "e452a44cea5878b7fafaacd258dcbb04efcbf35a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -135,7 +135,7 @@ struct ExpansionVisitor<'b, 'a: 'b> {\n \n impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) {\n-        assert_eq!(id, self.resolver.expansion_data.len() as u32);\n+        assert_eq!(id.as_u32(), self.resolver.expansion_data.len() as u32);\n         self.resolver.expansion_data.push(ExpansionData {\n             module: self.current_module.clone(),\n         });"}, {"sha": "fc235aaf9276b7450fa4cfec91e900776573fb80", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -14,8 +14,8 @@\n //! retrieve the data from a crate.\n \n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use syntax::ast::{self, CrateNum, NodeId};\n+use rustc::hir::def_id::{CrateNum, DefId};\n+use syntax::ast::{self, NodeId};\n use syntax_pos::Span;\n \n pub struct CrateData {"}, {"sha": "79fcff7d8a166471e43dfe956b88e9bb4b891daf", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -29,15 +29,15 @@\n \n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::map::{Node, NodeItem};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt, ImplOrTraitItem, ImplOrTraitItemContainer};\n \n use std::collections::HashSet;\n use std::hash::*;\n \n-use syntax::ast::{self, NodeId, PatKind, Attribute};\n+use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n@@ -95,7 +95,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             analysis: analysis,\n             dumper: dumper,\n             span: span_utils.clone(),\n-            cur_scope: 0,\n+            cur_scope: CRATE_NODE_ID,\n             mac_defs: HashSet::new(),\n             mac_uses: HashSet::new(),\n         }\n@@ -124,7 +124,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             let lo_loc = self.span.sess.codemap().lookup_char_pos(c.span.lo);\n             ExternalCrateData {\n                 name: c.name,\n-                num: c.number,\n+                num: CrateNum::from_u32(c.number),\n                 file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             }\n         }).collect();\n@@ -252,7 +252,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             ref_id: None,\n             span: *span,\n             qualname: qualname.to_owned(),\n-            scope: 0\n+            scope: CRATE_NODE_ID\n         }.lower(self.tcx));\n \n         // write the other sub-paths\n@@ -293,8 +293,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         let def = self.tcx.expect_def(ref_id);\n         match def {\n-            Def::Mod(_) |\n-            Def::ForeignMod(_) => {\n+            Def::Mod(_) => {\n                 self.dumper.mod_ref(ModRefData {\n                     span: sub_span.expect(\"No span found for mod ref\"),\n                     ref_id: Some(def_id),\n@@ -368,7 +367,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         qualname: format!(\"{}::{}\", qualname, path_to_string(p)),\n                         type_value: typ,\n                         value: String::new(),\n-                        scope: 0,\n+                        scope: CRATE_NODE_ID,\n                         parent: None,\n                         visibility: Visibility::Inherited,\n                         docs: String::new(),\n@@ -1044,7 +1043,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     qualname: format!(\"{}${}\", path_to_string(p), id),\n                     value: value,\n                     type_value: typ,\n-                    scope: 0,\n+                    scope: CRATE_NODE_ID,\n                     parent: None,\n                     visibility: Visibility::Inherited,\n                     docs: String::new(),\n@@ -1239,7 +1238,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 let alias_span = self.span.span_for_last_ident(item.span);\n                 let cnum = match self.sess.cstore.extern_mod_stmt_cnum(item.id) {\n                     Some(cnum) => cnum,\n-                    None => 0,\n+                    None => LOCAL_CRATE,\n                 };\n \n                 if !self.span.filter_generated(alias_span, item.span) {\n@@ -1456,7 +1455,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         // process collected paths\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n             match self.tcx.expect_def(id) {\n-                Def::Local(_, id) => {\n+                Def::Local(def_id) => {\n+                    let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n                     let mut value = if immut == ast::Mutability::Immutable {\n                         self.span.snippet(p.span).to_string()\n                     } else {\n@@ -1478,7 +1478,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                             qualname: format!(\"{}${}\", path_to_string(p), id),\n                             value: value,\n                             type_value: typ,\n-                            scope: 0,\n+                            scope: CRATE_NODE_ID,\n                             parent: None,\n                             visibility: Visibility::Inherited,\n                             docs: String::new(),"}, {"sha": "5847575742342680efc3ed8742c77c1f44c8f436", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n-use syntax::ast::{CrateNum, NodeId};\n+use syntax::ast::NodeId;\n use syntax::codemap::CodeMap;\n use syntax_pos::Span;\n \n@@ -28,7 +28,10 @@ pub fn make_def_id(id: NodeId, map: &Map) -> DefId {\n }\n \n pub fn null_def_id() -> DefId {\n-    DefId { krate: u32::max_value(), index: DefIndex::from_u32(u32::max_value()) }\n+    DefId {\n+        krate: CrateNum::from_u32(u32::max_value()),\n+        index: DefIndex::from_u32(u32::max_value())\n+    }\n }\n \n #[derive(Clone, Debug, RustcEncodable)]"}, {"sha": "d56aae18a7cd1f65e49a64d55bacc1acbf47082b", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -117,7 +117,7 @@ struct Id {\n impl From<DefId> for Id {\n     fn from(id: DefId) -> Id {\n         Id {\n-            krate: id.krate,\n+            krate: id.krate.as_u32(),\n             index: id.index.as_u32(),\n         }\n     }"}, {"sha": "0378d75cc6eb1d4d57e5ce3302748095f902ae8c", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -120,7 +120,7 @@ struct Id {\n impl From<DefId> for Id {\n     fn from(id: DefId) -> Id {\n         Id {\n-            krate: id.krate,\n+            krate: id.krate.as_u32(),\n             index: id.index.as_u32(),\n         }\n     }"}, {"sha": "aa68a873120ec8670db7ed78c17699c0ad84e02f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -52,7 +52,7 @@ use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n-use syntax::ast::{self, NodeId, PatKind, Attribute};\n+use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token::{self, keywords, InternedString};\n use syntax::visit::{self, Visitor};\n@@ -120,7 +120,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             };\n             result.push(CrateData {\n                 name: (&self.tcx.sess.cstore.crate_name(n)[..]).to_owned(),\n-                number: n,\n+                number: n.as_u32(),\n                 span: span,\n             });\n         }\n@@ -374,8 +374,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let qualname = format!(\"{}::{}\", qualname, name);\n \n         let def_id = self.tcx.map.local_def_id(id);\n-        let decl_id = self.tcx.trait_item_of_item(def_id).and_then(|new_id| {\n-            let new_def_id = new_id.def_id();\n+        let decl_id = self.tcx.trait_item_of_item(def_id).and_then(|new_def_id| {\n             if new_def_id != def_id {\n                 Some(new_def_id)\n             } else {\n@@ -543,16 +542,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 .map(|mr| mr.def_id())\n                         }\n                         ty::ImplContainer(def_id) => {\n-                            let impl_items = self.tcx.impl_items.borrow();\n-                            Some(impl_items.get(&def_id)\n-                                           .unwrap()\n-                                           .iter()\n-                                           .find(|mr| {\n-                                               self.tcx.impl_or_trait_item(mr.def_id()).name() ==\n-                                               ti.name()\n-                                           })\n-                                           .unwrap()\n-                                           .def_id())\n+                            Some(*self.tcx.impl_or_trait_items(def_id).iter().find(|&&mr| {\n+                                self.tcx.impl_or_trait_item(mr).name() == ti.name()\n+                            }).unwrap())\n                         }\n                     }\n                 } else {\n@@ -676,7 +668,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     #[inline]\n     pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n-        self.tcx.map.get_enclosing_scope(id).unwrap_or(0)\n+        self.tcx.map.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)\n     }\n }\n "}, {"sha": "fdbee50992dd19fbcbd690f9c8738fd3b689cf30", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -557,9 +557,9 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n \n     let attempts;\n     match hint {\n-        attr::ReprInt(span, ity) => {\n+        attr::ReprInt(ity) => {\n             if !bounds_usable(cx, ity, bounds) {\n-                span_bug!(span, \"representation hint insufficient for discriminant range\")\n+                bug!(\"representation hint insufficient for discriminant range\")\n             }\n             return ity;\n         }"}, {"sha": "201e1e5f2ec4cf05619bbcd239d317fe69a33586", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -26,6 +26,7 @@ use CrateTranslation;\n use util::common::time;\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n use rustc_incremental::IncrementalHashesMap;\n@@ -288,7 +289,7 @@ pub fn filename_for_input(sess: &Session,\n }\n \n pub fn each_linked_rlib(sess: &Session,\n-                        f: &mut FnMut(ast::CrateNum, &Path)) {\n+                        f: &mut FnMut(CrateNum, &Path)) {\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n@@ -299,7 +300,7 @@ pub fn each_linked_rlib(sess: &Session,\n         bug!(\"could not find formats for rlibs\")\n     });\n     for (cnum, path) in crates {\n-        match fmts[cnum as usize - 1] {\n+        match fmts[cnum.as_usize() - 1] {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => continue,\n             _ => {}\n         }\n@@ -933,7 +934,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n         let src = sess.cstore.used_crate_source(cnum);\n-        match data[cnum as usize - 1] {\n+        match data[cnum.as_usize() - 1] {\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n             _ if sess.cstore.is_compiler_builtins(cnum) => {\n@@ -1003,7 +1004,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                         sess: &Session,\n                         tmpdir: &Path,\n                         crate_type: config::CrateType,\n-                        cnum: ast::CrateNum) {\n+                        cnum: CrateNum) {\n         let src = sess.cstore.used_crate_source(cnum);\n         let cratepath = &src.rlib.unwrap().0;\n         if !sess.lto() && crate_type != config::CrateTypeDylib {"}, {"sha": "dd14f98c9207fc6e97b0c24f0d7ea5b8be2ea591", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -21,10 +21,10 @@ use monomorphize::Instance;\n \n use back::archive;\n use middle::dependency_format::Linkage;\n+use rustc::hir::def_id::CrateNum;\n use session::Session;\n use session::config::CrateType;\n use session::config;\n-use syntax::ast;\n \n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n@@ -473,7 +473,7 @@ fn exported_symbols(scx: &SharedCrateContext,\n     let deps = formats[&crate_type].iter();\n     symbols.extend(deps.enumerate().filter_map(|(i, f)| {\n         if *f == Linkage::Static {\n-            Some((i + 1) as ast::CrateNum)\n+            Some(CrateNum::new(i + 1))\n         } else {\n             None\n         }"}, {"sha": "4ed860bd40d86b3f835b98aa94c7efeeca42f13f", "filename": "src/librustc_trans/back/rpath.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -12,10 +12,11 @@ use std::collections::HashSet;\n use std::env;\n use std::path::{Path, PathBuf};\n use std::fs;\n-use syntax::ast;\n+\n+use rustc::hir::def_id::CrateNum;\n \n pub struct RPathConfig<'a> {\n-    pub used_crates: Vec<(ast::CrateNum, Option<PathBuf>)>,\n+    pub used_crates: Vec<(CrateNum, Option<PathBuf>)>,\n     pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,", "previous_filename": "src/librustc_back/rpath.rs"}, {"sha": "0a668db06908090b8a7689380bdf37ffc5da243b", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -97,14 +97,15 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use common::{CrateContext, SharedCrateContext, gensym_name};\n+use common::SharedCrateContext;\n use monomorphize::Instance;\n use util::sha2::{Digest, Sha256};\n \n-use rustc::middle::{cstore, weak_lang_items};\n-use rustc::hir::def_id::DefId;\n+use rustc::middle::weak_lang_items;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::fold::TypeVisitor;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::subst::Substs;\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n@@ -114,9 +115,18 @@ use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n-pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> String {\n-    let def_path = tcx.def_path(def_id);\n-    def_path.to_string(tcx)\n+use std::hash::Hasher;\n+\n+struct Sha256Hasher<'a>(&'a mut Sha256);\n+\n+impl<'a> Hasher for Sha256Hasher<'a> {\n+    fn write(&mut self, msg: &[u8]) {\n+        self.0.input(msg)\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        bug!(\"Sha256Hasher::finish should not be called\");\n+    }\n }\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -132,53 +142,46 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n                              // values for generic type parameters,\n                              // if any.\n-                             substs: Option<&Substs<'tcx>>)\n+                             substs: Option<&'tcx Substs<'tcx>>)\n                              -> String {\n     debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n            def_path, substs);\n \n     let tcx = scx.tcx();\n \n-    return record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n-        let mut hash_state = scx.symbol_hasher().borrow_mut();\n-\n+    let mut hash_state = scx.symbol_hasher().borrow_mut();\n+    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         hash_state.reset();\n+        let mut hasher = Sha256Hasher(&mut hash_state);\n \n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        hash_state.input_str(&def_path.to_string(tcx));\n+        def_path.deterministic_hash_to(tcx, &mut hasher);\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n+        let mut hasher = ty::util::TypeIdHasher::new(tcx, hasher);\n         assert!(!item_type.has_erasable_regions());\n-        let encoded_item_type = tcx.sess.cstore.encode_type(tcx, item_type, def_id_to_string);\n-        hash_state.input(&encoded_item_type[..]);\n+        hasher.visit_ty(item_type);\n \n         // also include any type parameters (for generic items)\n         if let Some(substs) = substs {\n-            for t in substs.types() {\n-                assert!(!t.has_erasable_regions());\n-                assert!(!t.needs_subst());\n-                let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n-                hash_state.input(&encoded_type[..]);\n-            }\n+            assert!(!substs.has_erasable_regions());\n+            assert!(!substs.needs_subst());\n+            substs.visit_with(&mut hasher);\n         }\n-\n-        format!(\"h{}\", truncated_hash_result(&mut *hash_state))\n     });\n \n-    fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n-        let output = symbol_hasher.result_bytes();\n-        // 64 bits should be enough to avoid collisions.\n-        output[.. 8].to_hex()\n-    }\n+    // 64 bits should be enough to avoid collisions.\n+    let output = hash_state.result_bytes();\n+    format!(\"h{}\", output[..8].to_hex())\n }\n \n impl<'a, 'tcx> Instance<'tcx> {\n     pub fn symbol_name(self, scx: &SharedCrateContext<'a, 'tcx>) -> String {\n-        let Instance { def: def_id, ref substs } = self;\n+        let Instance { def: def_id, substs } = self;\n \n         debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n                def_id, substs);\n@@ -273,7 +276,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n             scx.tcx().push_item_path(&mut buffer, def_id);\n         });\n \n-        mangle(buffer.names.into_iter(), Some(&hash[..]))\n+        mangle(buffer.names.into_iter(), &hash)\n     }\n }\n \n@@ -298,27 +301,11 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                                     -> String {\n     let empty_def_path = DefPath {\n         data: vec![],\n-        krate: cstore::LOCAL_CRATE,\n+        krate: LOCAL_CRATE,\n     };\n     let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n     let path = [token::intern_and_get_ident(prefix)];\n-    mangle(path.iter().cloned(), Some(&hash[..]))\n-}\n-\n-/// Only symbols that are invisible outside their compilation unit should use a\n-/// name generated by this function.\n-pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                    t: Ty<'tcx>,\n-                                                    suffix: &str)\n-                                                    -> String {\n-    let path = [token::intern(&t.to_string()).as_str(),\n-                gensym_name(suffix).as_str()];\n-    let def_path = DefPath {\n-        data: vec![],\n-        krate: cstore::LOCAL_CRATE,\n-    };\n-    let hash = get_symbol_hash(ccx.shared(), &def_path, t, None);\n-    mangle(path.iter().cloned(), Some(&hash[..]))\n+    mangle(path.iter().cloned(), &hash)\n }\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n@@ -371,7 +358,7 @@ pub fn sanitize(s: &str) -> String {\n     return result;\n }\n \n-pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -> String {\n+fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: &str) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n     //\n@@ -398,9 +385,7 @@ pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -\n         push(&mut n, &data);\n     }\n \n-    if let Some(s) = hash {\n-        push(&mut n, s)\n-    }\n+    push(&mut n, hash);\n \n     n.push('E'); // End name-sequence.\n     n"}, {"sha": "1e05b31eeadf6b6f70a07f6ca80db664b0ebf67b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -1346,8 +1346,7 @@ fn write_metadata(cx: &SharedCrateContext,\n                                           cx.export_map(),\n                                           cx.link_meta(),\n                                           reachable_ids,\n-                                          cx.mir_map(),\n-                                          cx.tcx().map.krate());\n+                                          cx.mir_map());\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata));\n "}, {"sha": "8822287a0e754a6e66a8e53edb33aa1ee37dd61c", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -17,7 +17,6 @@\n pub use self::CalleeData::*;\n \n use arena::TypedArena;\n-use back::symbol_names;\n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n@@ -133,34 +132,36 @@ impl<'tcx> Callee<'tcx> {\n         let trait_ref = tcx.normalize_associated_type(&ty::Binder(trait_ref));\n         match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n-                let impl_did = vtable_impl.impl_def_id;\n-                let mname = tcx.item_name(def_id);\n-                // create a concatenated set of substitutions which includes\n-                // those from the impl and those from the method:\n-                let mth = meth::get_impl_method(tcx, substs, impl_did, vtable_impl.substs, mname);\n+                let name = tcx.item_name(def_id);\n+                let (def_id, substs) = traits::find_method(tcx, name, substs, &vtable_impl);\n \n                 // Translate the function, bypassing Callee::def.\n                 // That is because default methods have the same ID as the\n                 // trait method used to look up the impl method that ended\n                 // up here, so calling Callee::def would infinitely recurse.\n-                let (llfn, ty) = get_fn(ccx, mth.method.def_id, mth.substs);\n+                let (llfn, ty) = get_fn(ccx, def_id, substs);\n                 Callee::ptr(llfn, ty)\n             }\n             traits::VtableClosure(vtable_closure) => {\n                 // The substitutions should have no type parameters remaining\n                 // after passing through fulfill_obligation\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                let instance = Instance::new(def_id, substs);\n                 let llfn = closure::trans_closure_method(ccx,\n                                                          vtable_closure.closure_def_id,\n                                                          vtable_closure.substs,\n+                                                         instance,\n                                                          trait_closure_kind);\n \n                 let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableFnPointer(vtable_fn_pointer) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, vtable_fn_pointer.fn_ty);\n+                let instance = Instance::new(def_id, substs);\n+                let llfn = trans_fn_pointer_shim(ccx, instance,\n+                                                 trait_closure_kind,\n+                                                 vtable_fn_pointer.fn_ty);\n \n                 let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n@@ -217,9 +218,7 @@ impl<'tcx> Callee<'tcx> {\n     pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         match self.data {\n             Fn(llfn) => llfn,\n-            Virtual(idx) => {\n-                meth::trans_object_shim(ccx, self.ty, idx)\n-            }\n+            Virtual(_) => meth::trans_object_shim(ccx, self),\n             NamedTupleConstructor(disr) => match self.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n                     let instance = Instance::new(def_id, substs);\n@@ -264,8 +263,9 @@ fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n /// ```\n ///\n /// but for the bare function type given.\n-pub fn trans_fn_pointer_shim<'a, 'tcx>(\n+fn trans_fn_pointer_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n+    method_instance: Instance<'tcx>,\n     closure_kind: ty::ClosureKind,\n     bare_fn_ty: Ty<'tcx>)\n     -> ValueRef\n@@ -345,10 +345,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n-    let function_name =\n-        symbol_names::internal_name_from_type_and_suffix(ccx,\n-                                                         bare_fn_ty,\n-                                                         \"fn_pointer_shim\");\n+    let function_name = method_instance.symbol_name(ccx.shared());\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //"}, {"sha": "c0692e8085fc25ddb0b44b6a870f4b0e6ec9d430", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use arena::TypedArena;\n-use back::symbol_names;\n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use abi::{Abi, FnType};\n@@ -152,6 +151,7 @@ pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                       closure_def_id: DefId,\n                                       substs: ty::ClosureSubsts<'tcx>,\n+                                      method_instance: Instance<'tcx>,\n                                       trait_closure_kind: ty::ClosureKind)\n                                       -> ValueRef\n {\n@@ -199,7 +199,7 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n             //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n             //\n             // These are both the same at trans time.\n-            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, llfn)\n+            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, method_instance, llfn)\n         }\n         _ => {\n             bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n@@ -213,6 +213,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     closure_def_id: DefId,\n     substs: ty::ClosureSubsts<'tcx>,\n+    method_instance: Instance<'tcx>,\n     llreffn: ValueRef)\n     -> ValueRef\n {\n@@ -255,8 +256,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     }));\n \n     // Create the by-value helper.\n-    let function_name =\n-        symbol_names::internal_name_from_type_and_suffix(ccx, llonce_fn_ty, \"once_shim\");\n+    let function_name = method_instance.symbol_name(ccx.shared());\n     let lloncefn = declare::declare_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n "}, {"sha": "1b2f861a5226bdb3c00f4ebf715812c456d103af", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 36, "deletions": 70, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -210,9 +210,8 @@ use errors;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n-use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};\n+use common::{fulfill_obligation, type_is_sized};\n use glue::{self, DropGlueKind};\n-use meth;\n use monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n \n@@ -627,25 +626,23 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               def_id: DefId)\n                                               -> bool {\n-            if !match tcx.lookup_item_type(def_id).ty.sty {\n-                ty::TyFnDef(def_id, ..) => {\n+            match tcx.lookup_item_type(def_id).ty.sty {\n+                ty::TyFnDef(def_id, _, f) => {\n                     // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in\n                     // translation item. Same for FFI functions.\n-                    match tcx.map.get_if_local(def_id) {\n-                        Some(hir_map::NodeVariant(_))    |\n-                        Some(hir_map::NodeStructCtor(_)) |\n-                        Some(hir_map::NodeForeignItem(_)) => false,\n-                        Some(_) => true,\n-                        None => {\n-                            tcx.sess.cstore.variant_kind(def_id).is_none()\n+                    if let Some(hir_map::NodeForeignItem(_)) = tcx.map.get_if_local(def_id) {\n+                        return false;\n+                    }\n+\n+                    if let Some(adt_def) = f.sig.output().skip_binder().ty_adt_def() {\n+                        if adt_def.variants.iter().any(|v| def_id == v.did) {\n+                            return false;\n                         }\n                     }\n                 }\n-                ty::TyClosure(..) => true,\n-                _ => false\n-            } {\n-                return false;\n+                ty::TyClosure(..) => {}\n+                _ => return false\n             }\n \n             can_have_local_instance(tcx, def_id)\n@@ -901,17 +898,8 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n     match vtbl {\n-        traits::VtableImpl(traits::VtableImplData {\n-            impl_def_id: impl_did,\n-            substs: impl_substs,\n-            nested: _ }) =>\n-        {\n-            let impl_method = meth::get_impl_method(tcx,\n-                                                    rcvr_substs,\n-                                                    impl_did,\n-                                                    impl_substs,\n-                                                    trait_method.name);\n-            Some((impl_method.method.def_id, &impl_method.substs))\n+        traits::VtableImpl(impl_data) => {\n+            Some(traits::find_method(tcx, trait_method.name, rcvr_substs, &impl_data))\n         }\n         // If we have a closure or a function pointer, we will also encounter\n         // the concrete closure/function somewhere else (during closure or fn\n@@ -1045,43 +1033,19 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n \n     if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n         let poly_trait_ref = trait_ty.principal.with_self_ty(scx.tcx(), impl_ty);\n+        let param_substs = Substs::empty(scx.tcx());\n \n         // Walk all methods of the trait, including those of its supertraits\n-        for trait_ref in traits::supertraits(scx.tcx(), poly_trait_ref) {\n-            let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n-            match vtable {\n-                traits::VtableImpl(\n-                    traits::VtableImplData {\n-                        impl_def_id,\n-                        substs,\n-                        nested: _ }) => {\n-                    let items = meth::get_vtable_methods(scx.tcx(), impl_def_id, substs)\n-                        .into_iter()\n-                        // filter out None values\n-                        .filter_map(|opt_impl_method| opt_impl_method)\n-                        // create translation items\n-                        .filter_map(|impl_method| {\n-                            if can_have_local_instance(scx.tcx(), impl_method.method.def_id) {\n-                                Some(create_fn_trans_item(scx,\n-                                    impl_method.method.def_id,\n-                                    impl_method.substs,\n-                                    Substs::empty(scx.tcx())))\n-                            } else {\n-                                None\n-                            }\n-                        });\n-\n-                    output.extend(items);\n-                }\n-                _ => { /* */ }\n-            }\n-        }\n+        let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n+        let methods = methods.filter_map(|method| method)\n+            .filter_map(|(def_id, substs)| do_static_dispatch(scx, def_id, substs, param_substs))\n+            .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n+            .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n+        output.extend(methods);\n \n         // Also add the destructor\n         let dg_type = glue::get_drop_glue_type(scx.tcx(), impl_ty);\n-        if glue::type_needs_drop(scx.tcx(), dg_type) {\n-            output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));\n-        }\n+        output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));\n     }\n }\n \n@@ -1241,25 +1205,27 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                     let impl_substs = Substs::for_item(tcx, impl_def_id,\n                                                        |_, _| tcx.mk_region(ty::ReErased),\n                                                        |_, _| tcx.types.err);\n-                    let mth = meth::get_impl_method(tcx,\n-                                                    callee_substs,\n-                                                    impl_def_id,\n-                                                    impl_substs,\n-                                                    method.name);\n-\n-                    assert!(mth.is_provided);\n-\n-                    let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                    if !normalize_and_test_predicates(tcx, predicates) {\n+                    let impl_data = traits::VtableImplData {\n+                        impl_def_id: impl_def_id,\n+                        substs: impl_substs,\n+                        nested: vec![]\n+                    };\n+                    let (def_id, substs) = traits::find_method(tcx,\n+                                                               method.name,\n+                                                               callee_substs,\n+                                                               &impl_data);\n+\n+                    let predicates = tcx.lookup_predicates(def_id).predicates\n+                                        .subst(tcx, substs);\n+                    if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;\n                     }\n \n                     if can_have_local_instance(tcx, method.def_id) {\n-                        let empty_substs = tcx.erase_regions(&mth.substs);\n                         let item = create_fn_trans_item(scx,\n                                                         method.def_id,\n                                                         callee_substs,\n-                                                        empty_substs);\n+                                                        tcx.erase_regions(&substs));\n                         output.push(item);\n                     }\n                 }"}, {"sha": "db1a541919036087616d1329873093d873d1f2f4", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -150,15 +150,6 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     llsize_of_alloc(ccx, llty) == 0\n }\n \n-/// Generates a unique symbol based off the name given. This is used to create\n-/// unique symbols for things like closures.\n-pub fn gensym_name(name: &str) -> ast::Name {\n-    let num = token::gensym(name).0;\n-    // use one colon which will get translated to a period by the mangler, and\n-    // we're guaranteed that `num` is globally unique for this crate.\n-    token::gensym(&format!(\"{}:{}\", name, num))\n-}\n-\n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n *\n@@ -1002,35 +993,6 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     })\n }\n \n-/// Normalizes the predicates and checks whether they hold.  If this\n-/// returns false, then either normalize encountered an error or one\n-/// of the predicates did not hold. Used when creating vtables to\n-/// check for unsatisfiable methods.\n-pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               predicates: Vec<ty::Predicate<'tcx>>)\n-                                               -> bool\n-{\n-    debug!(\"normalize_and_test_predicates(predicates={:?})\",\n-           predicates);\n-\n-    tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n-        let mut selcx = SelectionContext::new(&infcx);\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let cause = traits::ObligationCause::dummy();\n-        let traits::Normalized { value: predicates, obligations } =\n-            traits::normalize(&mut selcx, cause.clone(), &predicates);\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n-        for predicate in predicates {\n-            let obligation = traits::Obligation::new(cause.clone(), predicate);\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n-\n-        fulfill_cx.select_all_or_error(&infcx).is_ok()\n-    })\n-}\n-\n pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,"}, {"sha": "2a20728f09beae1120c22f8fdc75c51098e94354", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -92,6 +92,8 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     t: Ty<'tcx>) -> Ty<'tcx> {\n     assert!(t.is_normalized_for_trans());\n \n+    let t = tcx.erase_regions(&t);\n+\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n     if !type_is_sized(tcx, t) {\n@@ -214,30 +216,14 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 g: DropGlueKind<'tcx>) -> ValueRef {\n     let g = g.map_ty(|t| get_drop_glue_type(ccx.tcx(), t));\n     match ccx.drop_glues().borrow().get(&g) {\n-        Some(&(glue, _)) => return glue,\n+        Some(&(glue, _)) => glue,\n         None => {\n-            debug!(\"Could not find drop glue for {:?} -- {} -- {}. \\\n-                    Falling back to on-demand instantiation.\",\n+            bug!(\"Could not find drop glue for {:?} -- {} -- {}.\",\n                     g,\n                     TransItem::DropGlue(g).to_raw_string(),\n                     ccx.codegen_unit().name());\n         }\n     }\n-\n-    // FIXME: #34151\n-    // Normally, getting here would indicate a bug in trans::collector,\n-    // since it seems to have missed a translation item. When we are\n-    // translating with non-MIR-based trans, however, the results of the\n-    // collector are not entirely reliable since it bases its analysis\n-    // on MIR. Thus, we'll instantiate the missing function on demand in\n-    // this codegen unit, so that things keep working.\n-\n-    TransItem::DropGlue(g).predefine(ccx, llvm::InternalLinkage);\n-    TransItem::DropGlue(g).define(ccx);\n-\n-    // Now that we made sure that the glue function is in ccx.drop_glues,\n-    // give it another try\n-    get_drop_glue_core(ccx, g)\n }\n \n pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "41c8d565d418c93a75e1639378bf76a08b84dc52", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -69,7 +69,6 @@ pub use base::trans_crate;\n pub use disr::Disr;\n \n pub mod back {\n-    pub use rustc_back::rpath;\n     pub use rustc::hir::svh;\n \n     pub mod archive;\n@@ -79,6 +78,7 @@ pub mod back {\n     pub mod symbol_names;\n     pub mod write;\n     pub mod msvc;\n+    pub mod rpath;\n }\n \n pub mod diagnostics;"}, {"sha": "e8dcaf71f2dd2fc9d053ca6934aa9b6fc9dcee5b", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 24, "deletions": 210, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,33 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n-\n use attributes;\n use arena::TypedArena;\n-use back::symbol_names;\n use llvm::{ValueRef, get_params};\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::{Subst, Substs};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use abi::FnType;\n use base::*;\n use build::*;\n-use callee::{Callee, Virtual, trans_fn_pointer_shim};\n-use closure;\n+use callee::Callee;\n use common::*;\n use consts;\n use debuginfo::DebugLoc;\n use declare;\n use glue;\n use machine;\n+use monomorphize::Instance;\n use type_::Type;\n use type_of::*;\n use value::Value;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-\n-use syntax::ast::Name;\n-use syntax_pos::DUMMY_SP;\n+use rustc::ty;\n \n // drop_glue pointer, size, align.\n const VTABLE_OFFSET: usize = 3;\n@@ -73,23 +65,26 @@ pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// In fact, all virtual calls can be thought of as normal trait calls\n /// that go through this shim function.\n pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                   method_ty: Ty<'tcx>,\n-                                   vtable_index: usize)\n+                                   callee: Callee<'tcx>)\n                                    -> ValueRef {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_object_shim(vtable_index={}, method_ty={:?})\",\n-           vtable_index,\n-           method_ty);\n+    debug!(\"trans_object_shim({:?})\", callee);\n+\n+    let (sig, abi, function_name) = match callee.ty.sty {\n+        ty::TyFnDef(def_id, substs, f) => {\n+            let instance = Instance::new(def_id, substs);\n+            (&f.sig, f.abi, instance.symbol_name(ccx.shared()))\n+        }\n+        _ => bug!()\n+    };\n \n-    let sig = tcx.erase_late_bound_regions(&method_ty.fn_sig());\n+    let sig = tcx.erase_late_bound_regions(sig);\n     let sig = tcx.normalize_associated_type(&sig);\n-    let fn_ty = FnType::new(ccx, method_ty.fn_abi(), &sig, &[]);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let function_name =\n-        symbol_names::internal_name_from_type_and_suffix(ccx, method_ty, \"object_shim\");\n-    let llfn = declare::define_internal_fn(ccx, &function_name, method_ty);\n+    let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -98,16 +93,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let mut bcx = fcx.init(false);\n \n     let dest = fcx.llretslotptr.get();\n-\n-    debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n-           vtable_index);\n-\n     let llargs = get_params(fcx.llfn);\n-\n-    let callee = Callee {\n-        data: Virtual(vtable_index),\n-        ty: method_ty\n-    };\n     bcx = callee.call(bcx, DebugLoc::None,\n                       &llargs[fcx.fn_ty.ret.is_indirect() as usize..], dest).bcx;\n \n@@ -140,72 +126,23 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     // Not in the cache. Build it.\n-    let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n-        let vtable = fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref.clone());\n-        match vtable {\n-            // Should default trait error here?\n-            traits::VtableDefaultImpl(_) |\n-            traits::VtableBuiltin(_) => {\n-                Vec::new().into_iter()\n-            }\n-            traits::VtableImpl(\n-                traits::VtableImplData {\n-                    impl_def_id: id,\n-                    substs,\n-                    nested: _ }) => {\n-                let nullptr = C_null(Type::nil(ccx).ptr_to());\n-                get_vtable_methods(tcx, id, substs)\n-                    .into_iter()\n-                    .map(|opt_mth| opt_mth.map_or(nullptr, |mth| {\n-                        Callee::def(ccx, mth.method.def_id, &mth.substs).reify(ccx)\n-                    }))\n-                    .collect::<Vec<_>>()\n-                    .into_iter()\n-            }\n-            traits::VtableClosure(\n-                traits::VtableClosureData {\n-                    closure_def_id,\n-                    substs,\n-                    nested: _ }) => {\n-                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n-                let llfn = closure::trans_closure_method(ccx,\n-                                                         closure_def_id,\n-                                                         substs,\n-                                                         trait_closure_kind);\n-                vec![llfn].into_iter()\n-            }\n-            traits::VtableFnPointer(\n-                traits::VtableFnPointerData {\n-                    fn_ty: bare_fn_ty,\n-                    nested: _ }) => {\n-                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n-                vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n-            }\n-            traits::VtableObject(ref data) => {\n-                // this would imply that the Self type being erased is\n-                // an object type; this cannot happen because we\n-                // cannot cast an unsized type into a trait object\n-                bug!(\"cannot get vtable for an object type: {:?}\",\n-                     data);\n-            }\n-            traits::VtableParam(..) => {\n-                bug!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n-                     trait_ref,\n-                     vtable);\n-            }\n-        }\n+    let nullptr = C_null(Type::nil(ccx).ptr_to());\n+    let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n+        opt_mth.map_or(nullptr, |(def_id, substs)| {\n+            Callee::def(ccx, def_id, substs).reify(ccx)\n+        })\n     });\n \n     let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n     let align = align_of(ccx, trait_ref.self_ty());\n \n-    let components: Vec<_> = vec![\n+    let components: Vec<_> = [\n         // Generate a destructor for the vtable.\n         glue::get_drop_glue(ccx, trait_ref.self_ty()),\n         C_uint(ccx, size),\n         C_uint(ccx, align)\n-    ].into_iter().chain(methods).collect();\n+    ].iter().cloned().chain(methods).collect();\n \n     let vtable_const = C_struct(ccx, &components, false);\n     let align = machine::llalign_of_pref(ccx, val_ty(vtable_const));\n@@ -214,126 +151,3 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n     vtable\n }\n-\n-pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    impl_id: DefId,\n-                                    substs: &'tcx Substs<'tcx>)\n-                                    -> Vec<Option<ImplMethod<'tcx>>>\n-{\n-    debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n-\n-    let trait_id = match tcx.impl_trait_ref(impl_id) {\n-        Some(t_id) => t_id.def_id,\n-        None       => bug!(\"make_impl_vtable: don't know how to \\\n-                            make a vtable for a type impl!\")\n-    };\n-\n-    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n-\n-    let trait_item_def_ids = tcx.trait_item_def_ids(trait_id);\n-    trait_item_def_ids\n-        .iter()\n-\n-        // Filter out non-method items.\n-        .filter_map(|item_def_id| {\n-            match *item_def_id {\n-                ty::MethodTraitItemId(def_id) => Some(def_id),\n-                _ => None,\n-            }\n-        })\n-\n-        // Now produce pointers for each remaining method. If the\n-        // method could never be called from this object, just supply\n-        // null.\n-        .map(|trait_method_def_id| {\n-            debug!(\"get_vtable_methods: trait_method_def_id={:?}\",\n-                   trait_method_def_id);\n-\n-            let trait_method_type = match tcx.impl_or_trait_item(trait_method_def_id) {\n-                ty::MethodTraitItem(m) => m,\n-                _ => bug!(\"should be a method, not other assoc item\"),\n-            };\n-            let name = trait_method_type.name;\n-\n-            // Some methods cannot be called on an object; skip those.\n-            if !tcx.is_vtable_safe_method(trait_id, &trait_method_type) {\n-                debug!(\"get_vtable_methods: not vtable safe\");\n-                return None;\n-            }\n-\n-            debug!(\"get_vtable_methods: trait_method_type={:?}\",\n-                   trait_method_type);\n-\n-            // the method may have some early-bound lifetimes, add\n-            // regions for those\n-            let method_substs = Substs::for_item(tcx, trait_method_def_id,\n-                                                 |_, _| tcx.mk_region(ty::ReErased),\n-                                                 |_, _| tcx.types.err);\n-\n-            // The substitutions we have are on the impl, so we grab\n-            // the method type from the impl to substitute into.\n-            let mth = get_impl_method(tcx, method_substs, impl_id, substs, name);\n-\n-            debug!(\"get_vtable_methods: mth={:?}\", mth);\n-\n-            // If this is a default method, it's possible that it\n-            // relies on where clauses that do not hold for this\n-            // particular set of type parameters. Note that this\n-            // method could then never be called, so we do not want to\n-            // try and trans it, in that case. Issue #23435.\n-            if mth.is_provided {\n-                let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                if !normalize_and_test_predicates(tcx, predicates) {\n-                    debug!(\"get_vtable_methods: predicates do not hold\");\n-                    return None;\n-                }\n-            }\n-\n-            Some(mth)\n-        })\n-        .collect()\n-}\n-\n-#[derive(Debug)]\n-pub struct ImplMethod<'tcx> {\n-    pub method: Rc<ty::Method<'tcx>>,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub is_provided: bool\n-}\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 substs: &'tcx Substs<'tcx>,\n-                                 impl_def_id: DefId,\n-                                 impl_substs: &'tcx Substs<'tcx>,\n-                                 name: Name)\n-                                 -> ImplMethod<'tcx>\n-{\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n-                let substs = traits::translate_substs(&infcx, impl_def_id,\n-                                                      substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            ImplMethod {\n-                method: node_item.item,\n-                substs: substs,\n-                is_provided: node_item.node.is_from_trait(),\n-            }\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n-    }\n-}"}, {"sha": "f00da120799d4b7cee1908e8265bfc4fbfc689e5", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -247,11 +247,15 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);\n-                for ac in ccx.tcx().associated_consts(vtable_impl.impl_def_id) {\n-                    if ac.name == name {\n-                        instance = Instance::new(ac.def_id, vtable_impl.substs);\n-                        break;\n-                    }\n+                let ac = ccx.tcx().impl_or_trait_items(vtable_impl.impl_def_id)\n+                    .iter().filter_map(|&def_id| {\n+                        match ccx.tcx().impl_or_trait_item(def_id) {\n+                            ty::ConstTraitItem(ac) => Some(ac),\n+                            _ => None\n+                        }\n+                    }).find(|ic| ic.name == name);\n+                if let Some(ac) = ac {\n+                    instance = Instance::new(ac.def_id, vtable_impl.substs);\n                 }\n             }\n         }"}, {"sha": "141b8506c39b8d3e50a376094e1d5f10238cfc46", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -356,7 +356,7 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         format!(\"{}<{}>\", base, strings.join(\", \"))\n     };\n \n-    if did.krate == 0 {\n+    if did.is_local() {\n         tstr\n     } else {\n         format!(\"{}.{}\", did.krate, tstr)"}, {"sha": "cbdce3229c7c76d96e6152384f7fde2cc5844b53", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -1134,16 +1134,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        let mut associated_types: FnvHashSet<(DefId, ast::Name)> =\n-            traits::supertraits(tcx, principal)\n-            .flat_map(|tr| {\n-                let trait_def = tcx.lookup_trait_def(tr.def_id());\n-                trait_def.associated_type_names\n-                    .clone()\n-                    .into_iter()\n-                    .map(move |associated_type_name| (tr.def_id(), associated_type_name))\n-            })\n-            .collect();\n+        let mut associated_types = FnvHashSet::default();\n+        for tr in traits::supertraits(tcx, principal) {\n+            if let Some(trait_id) = tcx.map.as_local_node_id(tr.def_id()) {\n+                use collect::trait_associated_type_names;\n+\n+                associated_types.extend(trait_associated_type_names(tcx, trait_id)\n+                    .map(|name| (tr.def_id(), name)))\n+            } else {\n+                let trait_items = tcx.impl_or_trait_items(tr.def_id());\n+                associated_types.extend(trait_items.iter().filter_map(|&def_id| {\n+                    match tcx.impl_or_trait_item(def_id) {\n+                        ty::TypeTraitItem(ref item) => Some(item.name),\n+                        _ => None\n+                    }\n+                }).map(|name| (tr.def_id(), name)));\n+            }\n+        }\n \n         for projection_bound in &projection_bounds {\n             let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n@@ -1284,23 +1291,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n-            (_, Def::SelfTy(Some(trait_did), Some(impl_id))) => {\n-                // For Def::SelfTy() values inlined from another crate, the\n-                // impl_id will be DUMMY_NODE_ID, which would cause problems\n-                // here. But we should never run into an impl from another crate\n-                // in this pass.\n-                assert!(impl_id != ast::DUMMY_NODE_ID);\n-\n+            (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait - we have a concrete self type and a\n                 // trait reference.\n-                let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(impl_id)).unwrap();\n+                let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n                     trait_ref.subst(tcx, free_substs)\n                 } else {\n                     trait_ref\n                 };\n \n-                if self.ensure_super_predicates(span, trait_did).is_err() {\n+                if self.ensure_super_predicates(span, trait_ref.def_id).is_err() {\n                     return (tcx.types.err, Def::Err);\n                 }\n \n@@ -1372,7 +1373,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             item.expect(\"missing associated type\").def_id()\n         };\n \n-        (ty, Def::AssociatedTy(trait_did, item_did))\n+        (ty, Def::AssociatedTy(item_did))\n     }\n \n     fn qpath_to_ty(&self,\n@@ -1504,16 +1505,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     tcx.types.err\n                 }\n             }\n-            Def::SelfTy(_, Some(impl_id)) => {\n+            Def::SelfTy(_, Some(def_id)) => {\n                 // Self in impl (we know the concrete type).\n \n-                // For Def::SelfTy() values inlined from another crate, the\n-                // impl_id will be DUMMY_NODE_ID, which would cause problems\n-                // here. But we should never run into an impl from another crate\n-                // in this pass.\n-                assert!(impl_id != ast::DUMMY_NODE_ID);\n-\n                 tcx.prohibit_type_params(base_segments);\n+                let impl_id = tcx.map.as_local_node_id(def_id).unwrap();\n                 let ty = tcx.node_id_to_type(impl_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n@@ -1526,8 +1522,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.prohibit_type_params(base_segments);\n                 tcx.mk_self_type()\n             }\n-            Def::AssociatedTy(trait_did, _) => {\n+            Def::AssociatedTy(def_id) => {\n                 tcx.prohibit_type_params(&base_segments[..base_segments.len()-2]);\n+                let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(rscope,\n                                  span,\n                                  param_mode,"}, {"sha": "de7ca479b0b6632bb72981fc627a7dea4434f1b8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -134,7 +134,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // what the type of the binding `x` ought to be\n                 match tcx.expect_def(pat.id) {\n                     Def::Err => {}\n-                    Def::Local(_, var_id) => {\n+                    Def::Local(def_id) => {\n+                        let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n                         if var_id != pat.id {\n                             let vt = self.local_ty(pat.span, var_id);\n                             self.demand_eqtype(pat.span, vt, typ);"}, {"sha": "d1fb0736d21154e465e0948ed94be55a6d84f19b", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -12,9 +12,8 @@ use super::{DeferredCallResolution, Expectation, FnCtxt,\n             TupleArgumentsFlag};\n \n use CrateCtxt;\n-use middle::cstore::LOCAL_CRATE;\n use hir::def::Def;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n use syntax::parse::token;"}, {"sha": "4a631493398e98fd318af22b4b4d36e98c64a677", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -577,7 +577,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 assoc::normalize_associated_types_in(&infcx,\n                                                      &mut fulfillment_cx,\n                                                      impl_c_span,\n-                                                     0,\n+                                                     ast::CRATE_NODE_ID,\n                                                      &impl_ty);\n \n             debug!(\"compare_const_impl: impl_ty={:?}\",\n@@ -587,7 +587,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 assoc::normalize_associated_types_in(&infcx,\n                                                      &mut fulfillment_cx,\n                                                      impl_c_span,\n-                                                     0,\n+                                                     ast::CRATE_NODE_ID,\n                                                      &trait_ty);\n \n             debug!(\"compare_const_impl: trait_ty={:?}\","}, {"sha": "73caf79c9f8d1b345c92870a239cad79fa0dd141", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = self.trait_item(trait_def_id, m_name).unwrap();\n+        let method_item = self.impl_or_trait_item(trait_def_id, m_name).unwrap();\n         let method_ty = method_item.as_opt_method().unwrap();\n         assert_eq!(method_ty.generics.types.len(), 0);\n         assert_eq!(method_ty.generics.regions.len(), 0);\n@@ -359,29 +359,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(def)\n     }\n \n-    /// Find item with name `item_name` defined in `trait_def_id`\n-    /// and return it, or `None`, if no such item.\n-    pub fn trait_item(&self,\n-                      trait_def_id: DefId,\n-                      item_name: ast::Name)\n-                      -> Option<ty::ImplOrTraitItem<'tcx>>\n+    /// Find item with name `item_name` defined in impl/trait `def_id`\n+    /// and return it, or `None`, if no such item was defined there.\n+    pub fn impl_or_trait_item(&self,\n+                              def_id: DefId,\n+                              item_name: ast::Name)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n-        let trait_items = self.tcx.trait_items(trait_def_id);\n-        trait_items.iter()\n-                   .find(|item| item.name() == item_name)\n-                   .cloned()\n-    }\n-\n-    pub fn impl_item(&self,\n-                     impl_def_id: DefId,\n-                     item_name: ast::Name)\n-                     -> Option<ty::ImplOrTraitItem<'tcx>>\n-    {\n-        let impl_items = self.tcx.impl_items.borrow();\n-        let impl_items = impl_items.get(&impl_def_id).unwrap();\n-        impl_items\n+        self.tcx.impl_or_trait_items(def_id)\n             .iter()\n-            .map(|&did| self.tcx.impl_or_trait_item(did.def_id()))\n+            .map(|&did| self.tcx.impl_or_trait_item(did))\n             .find(|m| m.name() == item_name)\n     }\n }"}, {"sha": "9fba9bcb757b6a78149d03e1dd0565fe7f7e0fba", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -403,7 +403,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let item = match self.impl_item(impl_def_id) {\n+        let item = match self.impl_or_trait_item(impl_def_id) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n         };\n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let item = match self.trait_item(bound_trait_ref.def_id()) {\n+            let item = match self.impl_or_trait_item(bound_trait_ref.def_id()) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n@@ -1292,18 +1292,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.tcx.erase_late_bound_regions(value)\n     }\n \n-    fn impl_item(&self, impl_def_id: DefId)\n-                 -> Option<ty::ImplOrTraitItem<'tcx>>\n+    /// Find item with name `item_name` defined in impl/trait `def_id`\n+    /// and return it, or `None`, if no such item was defined there.\n+    fn impl_or_trait_item(&self, def_id: DefId)\n+                          -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n-        self.fcx.impl_item(impl_def_id, self.item_name)\n-    }\n-\n-    /// Find item with name `item_name` defined in `trait_def_id`\n-    /// and return it, or `None`, if no such item.\n-    fn trait_item(&self, trait_def_id: DefId)\n-                  -> Option<ty::ImplOrTraitItem<'tcx>>\n-    {\n-        self.fcx.trait_item(trait_def_id, self.item_name)\n+        self.fcx.impl_or_trait_item(def_id, self.item_name)\n     }\n }\n "}, {"sha": "34bcd2ba046e91cbaaa967be0b26e5d3fb9e39b2", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -16,9 +16,8 @@ use CrateCtxt;\n use check::{FnCtxt};\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n-use middle::cstore;\n use hir::def::Def;\n-use hir::def_id::DefId;\n+use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::ty::subst::Substs;\n use rustc::traits::{Obligation, SelectionContext};\n@@ -92,9 +91,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = self.impl_item(impl_did, item_name)\n+                        let item = self.impl_or_trait_item(impl_did, item_name)\n                             .or_else(|| {\n-                                self.trait_item(\n+                                self.impl_or_trait_item(\n                                     self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n \n                                     item_name\n@@ -127,7 +126,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item = self.trait_item(trait_did, item_name).unwrap();\n+                        let item = self.impl_or_trait_item(trait_did, item_name).unwrap();\n                         let item_span = self.tcx.map.def_id_span(item.def_id(), span);\n                         span_note!(err, item_span,\n                                    \"candidate #{} is defined in the trait `{}`\",\n@@ -321,7 +320,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // implementing a trait would be legal but is rejected\n                 // here).\n                 (type_is_local || info.def_id.is_local())\n-                    && self.trait_item(info.def_id, item_name).is_some()\n+                    && self.impl_or_trait_item(info.def_id, item_name).is_some()\n             })\n             .collect::<Vec<_>>();\n \n@@ -449,34 +448,30 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n \n         // Cross-crate:\n         let mut external_mods = FnvHashSet();\n-        fn handle_external_def(traits: &mut AllTraitsVec,\n+        fn handle_external_def(ccx: &CrateCtxt,\n+                               traits: &mut AllTraitsVec,\n                                external_mods: &mut FnvHashSet<DefId>,\n-                               ccx: &CrateCtxt,\n-                               cstore: &for<'a> cstore::CrateStore<'a>,\n-                               dl: cstore::DefLike) {\n-            match dl {\n-                cstore::DlDef(Def::Trait(did)) => {\n-                    traits.push(TraitInfo::new(did));\n+                               def_id: DefId) {\n+            match ccx.tcx.sess.cstore.describe_def(def_id) {\n+                Some(Def::Trait(_)) => {\n+                    traits.push(TraitInfo::new(def_id));\n                 }\n-                cstore::DlDef(Def::Mod(did)) => {\n-                    if !external_mods.insert(did) {\n+                Some(Def::Mod(_)) => {\n+                    if !external_mods.insert(def_id) {\n                         return;\n                     }\n-                    for child in cstore.item_children(did) {\n-                        handle_external_def(traits, external_mods,\n-                                            ccx, cstore, child.def)\n+                    for child in ccx.tcx.sess.cstore.item_children(def_id) {\n+                        handle_external_def(ccx, traits, external_mods, child.def_id)\n                     }\n                 }\n                 _ => {}\n             }\n         }\n-        let cstore = &*ccx.tcx.sess.cstore;\n-\n         for cnum in ccx.tcx.sess.cstore.crates() {\n-            for child in cstore.crate_top_level_items(cnum) {\n-                handle_external_def(&mut traits, &mut external_mods,\n-                                    ccx, cstore, child.def)\n-            }\n+            handle_external_def(ccx, &mut traits, &mut external_mods, DefId {\n+                krate: cnum,\n+                index: CRATE_DEF_INDEX\n+            });\n         }\n \n         *ccx.all_traits.borrow_mut() = Some(traits);"}, {"sha": "e38b865842e8a9e1c7ca73c4e97518920f65089b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -83,9 +83,8 @@ use self::TupleArgumentsFlag::*;\n use astconv::{AstConv, ast_region_to_region, PathParamMode};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n-use middle::cstore::LOCAL_CRATE;\n use hir::def::{Def, PathResolution};\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n use rustc::ty::subst::{Subst, Substs};\n@@ -1349,8 +1348,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                            assoc_name: ast::Name)\n                                            -> bool\n     {\n-        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-        trait_def.associated_type_names.contains(&assoc_name)\n+        self.tcx().impl_or_trait_items(trait_def_id).iter().any(|&def_id| {\n+            match self.tcx().impl_or_trait_item(def_id) {\n+                ty::TypeTraitItem(ref item) => item.name == assoc_name,\n+                _ => false\n+            }\n+        })\n     }\n \n     fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n@@ -1450,7 +1453,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             writeback_errors: Cell::new(false),\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_ty: rty,\n-            ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, 0)),\n+            ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n+                                                     ast::CRATE_NODE_ID)),\n             inh: inh,\n         }\n     }\n@@ -2117,7 +2121,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             .unwrap_or(type_variable::Default {\n                                 ty: self.next_ty_var(),\n                                 origin_span: syntax_pos::DUMMY_SP,\n-                                def_id: self.tcx.map.local_def_id(0) // what do I put here?\n+                                // what do I put here?\n+                                def_id: self.tcx.map.local_def_id(ast::CRATE_NODE_ID)\n                             });\n \n                     // This is to ensure that we elimnate any non-determinism from the error\n@@ -3219,7 +3224,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(type_did, _) | Def::Struct(type_did) | Def::Union(type_did) => {\n+            Def::Variant(did) => {\n+                let type_did = self.tcx.parent_def_id(did).unwrap();\n+                Some((type_did, self.tcx.expect_variant_def(def)))\n+            }\n+            Def::Struct(type_did) | Def::Union(type_did) => {\n                 Some((type_did, self.tcx.expect_variant_def(def)))\n             }\n             Def::TyAlias(did) => {\n@@ -4110,10 +4119,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Case 1 and 1b. Reference to a *type* or *enum variant*.\n             Def::Struct(def_id) |\n             Def::Union(def_id) |\n-            Def::Variant(_, def_id) |\n+            Def::Variant(def_id) |\n             Def::Enum(def_id) |\n             Def::TyAlias(def_id) |\n-            Def::AssociatedTy(_, def_id) |\n+            Def::AssociatedTy(def_id) |\n             Def::Trait(def_id) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n@@ -4161,7 +4170,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // here. If they do, an error will have been reported\n             // elsewhere. (I hope)\n             Def::Mod(..) |\n-            Def::ForeignMod(..) |\n             Def::PrimTy(..) |\n             Def::SelfTy(..) |\n             Def::TyParam(..) |\n@@ -4187,7 +4195,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.prohibit_type_params(&segments[..segments.len() - poly_segments]);\n \n         match def {\n-            Def::Local(_, nid) | Def::Upvar(_, nid, ..) => {\n+            Def::Local(def_id) | Def::Upvar(def_id, ..) => {\n+                let nid = self.tcx.map.as_local_node_id(def_id).unwrap();\n                 let ty = self.local_ty(span, nid);\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(node_id, ty);"}, {"sha": "aa221c33b5ddb39e6f85b4ebdf8bf23b209cbeef", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -120,7 +120,8 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n         self.fcx.tcx.with_freevars(expr.id, |freevars| {\n             for freevar in freevars {\n-                let var_node_id = freevar.def.var_id();\n+                let def_id = freevar.def.def_id();\n+                let var_node_id = self.fcx.tcx.map.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                              closure_expr_id: expr.id };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n@@ -236,31 +237,30 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         // implemented.\n         let tcx = self.fcx.tcx;\n         tcx.with_freevars(closure_id, |freevars| {\n-            freevars.iter()\n-                    .map(|freevar| {\n-                        let freevar_node_id = freevar.def.var_id();\n-                        let freevar_ty = self.fcx.node_ty(freevar_node_id);\n-                        let upvar_id = ty::UpvarId {\n-                            var_id: freevar_node_id,\n-                            closure_expr_id: closure_id\n-                        };\n-                        let capture = self.fcx.upvar_capture(upvar_id).unwrap();\n-\n-                        debug!(\"freevar_node_id={:?} freevar_ty={:?} capture={:?}\",\n-                               freevar_node_id, freevar_ty, capture);\n-\n-                        match capture {\n-                            ty::UpvarCapture::ByValue => freevar_ty,\n-                            ty::UpvarCapture::ByRef(borrow) =>\n-                                tcx.mk_ref(borrow.region,\n-                                           ty::TypeAndMut {\n-                                               ty: freevar_ty,\n-                                               mutbl: borrow.kind.to_mutbl_lossy(),\n-                                           }),\n-                        }\n-                    })\n-                    .collect()\n-            })\n+            freevars.iter().map(|freevar| {\n+                let def_id = freevar.def.def_id();\n+                let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                let freevar_ty = self.fcx.node_ty(var_id);\n+                let upvar_id = ty::UpvarId {\n+                    var_id: var_id,\n+                    closure_expr_id: closure_id\n+                };\n+                let capture = self.fcx.upvar_capture(upvar_id).unwrap();\n+\n+                debug!(\"var_id={:?} freevar_ty={:?} capture={:?}\",\n+                       var_id, freevar_ty, capture);\n+\n+                match capture {\n+                    ty::UpvarCapture::ByValue => freevar_ty,\n+                    ty::UpvarCapture::ByRef(borrow) =>\n+                        tcx.mk_ref(borrow.region,\n+                                    ty::TypeAndMut {\n+                                        ty: freevar_ty,\n+                                        mutbl: borrow.kind.to_mutbl_lossy(),\n+                                    }),\n+                }\n+            }).collect()\n+        })\n     }\n \n     fn adjust_upvar_borrow_kind_for_consume(&mut self,"}, {"sha": "3b4c98fc71e4451246ff6286df5a3ea82ba6ed35", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -20,8 +20,7 @@ use middle::lang_items::UnsizeTraitLangItem;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{ImplOrTraitItemId, ConstTraitItemId};\n-use rustc::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n+use rustc::ty::{ParameterEnvironment};\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyTrait, TyNever, TyTuple};\n@@ -39,6 +38,8 @@ use rustc::hir::intravisit;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n+use std::rc::Rc;\n+\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -156,7 +157,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        tcx.impl_items.borrow_mut().insert(impl_did, impl_items);\n+        tcx.impl_or_trait_item_def_ids.borrow_mut().insert(impl_did, Rc::new(impl_items));\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n@@ -172,22 +173,11 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     }\n \n     // Converts an implementation in the AST to a vector of items.\n-    fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n+    fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n         match item.node {\n             ItemImpl(.., ref impl_items) => {\n                 impl_items.iter().map(|impl_item| {\n-                    let impl_def_id = self.crate_context.tcx.map.local_def_id(impl_item.id);\n-                    match impl_item.node {\n-                        hir::ImplItemKind::Const(..) => {\n-                            ConstTraitItemId(impl_def_id)\n-                        }\n-                        hir::ImplItemKind::Method(..) => {\n-                            MethodTraitItemId(impl_def_id)\n-                        }\n-                        hir::ImplItemKind::Type(_) => {\n-                            TypeTraitItemId(impl_def_id)\n-                        }\n-                    }\n+                    self.crate_context.tcx.map.local_def_id(impl_item.id)\n                 }).collect()\n             }\n             _ => {\n@@ -208,7 +198,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n         let drop_trait = tcx.lookup_trait_def(drop_trait);\n \n-        let impl_items = tcx.impl_items.borrow();\n+        let impl_items = tcx.impl_or_trait_item_def_ids.borrow();\n \n         drop_trait.for_each_impl(tcx, |impl_did| {\n             let items = impl_items.get(&impl_did).unwrap();\n@@ -221,7 +211,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             let self_type = tcx.lookup_item_type(impl_did);\n             match self_type.ty.sty {\n                 ty::TyAdt(type_def, _) => {\n-                    type_def.set_destructor(method_def_id.def_id());\n+                    type_def.set_destructor(method_def_id);\n                 }\n                 _ => {\n                     // Destructors only work on nominal types."}, {"sha": "70342a0cd258e3658372df31df5f3ae0cb590b52", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -11,8 +11,7 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::traits;\n use rustc::ty::{self, TyCtxt};\n use syntax::ast;"}, {"sha": "c42b8f8840028afecb8fdc41764c3dff85899744", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -44,29 +44,29 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         enum Namespace { Type, Value }\n \n         fn name_and_namespace<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        item: &ty::ImplOrTraitItemId)\n+                                        def_id: DefId)\n                                         -> (ast::Name, Namespace)\n         {\n-            let name = tcx.impl_or_trait_item(item.def_id()).name();\n-            (name, match *item {\n-                ty::TypeTraitItemId(..) => Namespace::Type,\n-                ty::ConstTraitItemId(..) => Namespace::Value,\n-                ty::MethodTraitItemId(..) => Namespace::Value,\n+            let item = tcx.impl_or_trait_item(def_id);\n+            (item.name(), match item {\n+                ty::TypeTraitItem(..) => Namespace::Type,\n+                ty::ConstTraitItem(..) => Namespace::Value,\n+                ty::MethodTraitItem(..) => Namespace::Value,\n             })\n         }\n \n-        let impl_items = self.tcx.impl_items.borrow();\n+        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n \n-        for item1 in &impl_items[&impl1] {\n+        for &item1 in &impl_items[&impl1][..] {\n             let (name, namespace) = name_and_namespace(self.tcx, item1);\n \n-            for item2 in &impl_items[&impl2] {\n+            for &item2 in &impl_items[&impl2][..] {\n                 if (name, namespace) == name_and_namespace(self.tcx, item2) {\n                     let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.map.as_local_node_id(item1.def_id()).unwrap();\n+                    let node_id = self.tcx.map.as_local_node_id(item1).unwrap();\n                     self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n                                            node_id,\n-                                           self.tcx.span_of_impl(item1.def_id()).unwrap(),\n+                                           self.tcx.span_of_impl(item1).unwrap(),\n                                            msg);\n                 }\n             }"}, {"sha": "e5d4d4a9dae2ccaaf83b754206204c4f66fd5407", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -361,10 +361,15 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n                                            -> bool\n     {\n         if let Some(trait_id) = self.tcx().map.as_local_node_id(trait_def_id) {\n-            trait_defines_associated_type_named(self.ccx, trait_id, assoc_name)\n+            trait_associated_type_names(self.tcx(), trait_id)\n+                .any(|name| name == assoc_name)\n         } else {\n-            let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-            trait_def.associated_type_names.contains(&assoc_name)\n+            self.tcx().impl_or_trait_items(trait_def_id).iter().any(|&def_id| {\n+                match self.tcx().impl_or_trait_item(def_id) {\n+                    ty::TypeTraitItem(ref item) => item.name == assoc_name,\n+                    _ => false\n+                }\n+            })\n         }\n     }\n \n@@ -563,6 +568,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             vis: &hir::Visibility,\n                             sig: &hir::MethodSig,\n                             defaultness: hir::Defaultness,\n+                            has_body: bool,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n     let def_id = ccx.tcx.map.local_def_id(id);\n@@ -580,15 +586,18 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               sig, untransformed_rcvr_ty, anon_scope)\n     };\n \n-    let ty_method = ty::Method::new(name,\n-                                    ty_generics,\n-                                    ty_generic_predicates,\n-                                    fty,\n-                                    explicit_self_category,\n-                                    ty::Visibility::from_hir(vis, id, ccx.tcx),\n-                                    defaultness,\n-                                    def_id,\n-                                    container);\n+    let ty_method = ty::Method {\n+        name: name,\n+        generics: ty_generics,\n+        predicates: ty_generic_predicates,\n+        fty: fty,\n+        explicit_self: explicit_self_category,\n+        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n+        defaultness: defaultness,\n+        has_body: has_body,\n+        def_id: def_id,\n+        container: container,\n+    };\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.map.span(id), def_id);\n@@ -665,6 +674,13 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      defaultness: hir::Defaultness,\n                                      ty: Option<Ty<'tcx>>)\n {\n+    let predicates = ty::GenericPredicates {\n+        parent: Some(container.id()),\n+        predicates: vec![]\n+    };\n+    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n+                                           predicates);\n+\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: name,\n         vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n@@ -822,6 +838,9 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Convert all the associated types.\n             for impl_item in impl_items {\n                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n+                    let type_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n+                    generics_of_def_id(ccx, type_def_id);\n+\n                     if opt_trait_ref.is_none() {\n                         span_err!(tcx.sess, impl_item.span, E0202,\n                                   \"associated types are not allowed in inherent impls\");\n@@ -843,7 +862,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n-                                   sig, impl_item.defaultness, selfty,\n+                                   sig, impl_item.defaultness, true, selfty,\n                                    &ty_predicates);\n                 }\n             }\n@@ -889,6 +908,9 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Convert all the associated types.\n             for trait_item in trait_items {\n                 if let hir::TypeTraitItem(_, ref opt_ty) = trait_item.node {\n+                    let type_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n+                    generics_of_def_id(ccx, type_def_id);\n+\n                     let typ = opt_ty.as_ref().map({\n                         |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n                     });\n@@ -905,14 +927,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Convert all the methods\n             for trait_item in trait_items {\n-                if let hir::MethodTraitItem(ref sig, _) = trait_item.node {\n+                if let hir::MethodTraitItem(ref sig, ref body) = trait_item.node {\n                     convert_method(ccx,\n                                    container,\n                                    trait_item.name,\n                                    trait_item.id,\n                                    &hir::Inherited,\n                                    sig,\n                                    hir::Defaultness::Default,\n+                                   body.is_some(),\n                                    tcx.mk_self_type(),\n                                    &trait_predicates);\n \n@@ -921,15 +944,10 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Add an entry mapping\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n-                let def_id = ccx.tcx.map.local_def_id(trait_item.id);\n-                match trait_item.node {\n-                    hir::ConstTraitItem(..) => ty::ConstTraitItemId(def_id),\n-                    hir::MethodTraitItem(..) => ty::MethodTraitItemId(def_id),\n-                    hir::TypeTraitItem(..) => ty::TypeTraitItemId(def_id)\n-                }\n+                ccx.tcx.map.local_def_id(trait_item.id)\n             }).collect());\n-            tcx.trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                       trait_item_def_ids);\n+            tcx.impl_or_trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                               trait_item_def_ids);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n@@ -1261,9 +1279,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return def.clone();\n     }\n \n-    let (unsafety, generics, items) = match it.node {\n-        hir::ItemTrait(unsafety, ref generics, _, ref items) => {\n-            (unsafety, generics, items)\n+    let (unsafety, generics) = match it.node {\n+        hir::ItemTrait(unsafety, ref generics, _, _) => {\n+            (unsafety, generics)\n         }\n         _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n@@ -1283,32 +1301,20 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ty_generics = generics_of_def_id(ccx, def_id);\n     let substs = mk_item_substs(&ccx.icx(generics), it.span, def_id);\n \n-    let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n-        match trait_item.node {\n-            hir::TypeTraitItem(..) => Some(trait_item.name),\n-            _ => None,\n-        }\n-    }).collect();\n-\n     let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n \n     let trait_ref = ty::TraitRef::new(def_id, substs);\n-    let trait_def = ty::TraitDef::new(unsafety,\n-                                      paren_sugar,\n-                                      ty_generics,\n-                                      trait_ref,\n-                                      associated_type_names,\n+    let trait_def = ty::TraitDef::new(unsafety, paren_sugar, ty_generics, trait_ref,\n                                       def_path_hash);\n \n     tcx.intern_trait_def(trait_def)\n }\n \n-fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n-                                       trait_node_id: ast::NodeId,\n-                                       assoc_name: ast::Name)\n-                                       -> bool\n+pub fn trait_associated_type_names<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                   trait_node_id: ast::NodeId)\n+                                                   -> impl Iterator<Item=ast::Name> + 'a\n {\n-    let item = match ccx.tcx.map.get(trait_node_id) {\n+    let item = match tcx.map.get(trait_node_id) {\n         hir_map::NodeItem(item) => item,\n         _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n     };\n@@ -1318,10 +1324,10 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n         _ => bug!(\"trait_node_id {} is not a trait\", trait_node_id)\n     };\n \n-    trait_items.iter().any(|trait_item| {\n+    trait_items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n-            hir::TypeTraitItem(..) => trait_item.name == assoc_name,\n-            _ => false,\n+            hir::TypeTraitItem(..) => Some(trait_item.name),\n+            _ => None,\n         }\n     })\n }"}, {"sha": "1f34cee5143c61e9e147bd4584efbaa3bfb121f1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -76,6 +76,7 @@ This API is completely unstable and subject to change.\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(conservative_impl_trait)]\n #![feature(dotdot_in_tuple_patterns)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "c4d6ff43eff08051cf2880519baa8d49cd1c6daf", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 63, "deletions": 53, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -15,9 +15,9 @@ use std::iter::once;\n use syntax::ast;\n use rustc::hir;\n \n-use rustc::middle::cstore;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::DefPathData;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt, VariantKind};\n use rustc::util::nodemap::FnvHashSet;\n@@ -83,7 +83,7 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         Def::Struct(did)\n                 // If this is a struct constructor, we skip it\n-                if tcx.sess.cstore.tuple_struct_definition_if_ctor(did).is_none() => {\n+                if tcx.def_key(did).disambiguated_data.data != DefPathData::StructCtor => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::StructItem(build_struct(cx, tcx, did))\n@@ -96,12 +96,12 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Def::TyAlias(did) => {\n             record_extern_fqn(cx, did, clean::TypeTypedef);\n             ret.extend(build_impls(cx, tcx, did));\n-            build_type(cx, tcx, did)\n+            clean::TypedefItem(build_type_alias(cx, tcx, did), false)\n         }\n         Def::Enum(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n             ret.extend(build_impls(cx, tcx, did));\n-            build_type(cx, tcx, did)\n+            clean::EnumItem(build_enum(cx, tcx, did))\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n@@ -200,6 +200,18 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n     }\n }\n \n+fn build_enum<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        did: DefId) -> clean::Enum {\n+    let t = tcx.lookup_item_type(did);\n+    let predicates = tcx.lookup_predicates(did);\n+\n+    clean::Enum {\n+        generics: (t.generics, &predicates).clean(cx),\n+        variants_stripped: false,\n+        variants: tcx.lookup_adt_def(did).variants.clean(cx),\n+    }\n+}\n+\n fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           did: DefId) -> clean::Struct {\n     let t = tcx.lookup_item_type(did);\n@@ -232,25 +244,15 @@ fn build_union<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        did: DefId) -> clean::ItemEnum {\n+fn build_type_alias<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              did: DefId) -> clean::Typedef {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n-    match t.ty.sty {\n-        ty::TyAdt(edef, _) if edef.is_enum() && !tcx.sess.cstore.is_typedef(did) => {\n-            return clean::EnumItem(clean::Enum {\n-                generics: (t.generics, &predicates).clean(cx),\n-                variants_stripped: false,\n-                variants: edef.variants.clean(cx),\n-            })\n-        }\n-        _ => {}\n-    }\n \n-    clean::TypedefItem(clean::Typedef {\n+    clean::Typedef {\n         type_: t.ty.clean(cx),\n         generics: (t.generics, &predicates).clean(cx),\n-    }, false)\n+    }\n }\n \n pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n@@ -264,32 +266,49 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n             build_impl(cx, tcx, did, &mut impls);\n         }\n     }\n-\n-    // If this is the first time we've inlined something from this crate, then\n-    // we inline *all* impls from the crate into this crate. Note that there's\n+    // If this is the first time we've inlined something from another crate, then\n+    // we inline *all* impls from all the crates into this crate. Note that there's\n     // currently no way for us to filter this based on type, and we likely need\n     // many impls for a variety of reasons.\n     //\n     // Primarily, the impls will be used to populate the documentation for this\n     // type being inlined, but impls can also be used when generating\n     // documentation for primitives (no way to find those specifically).\n-    if cx.populated_crate_impls.borrow_mut().insert(did.krate) {\n-        for item in tcx.sess.cstore.crate_top_level_items(did.krate) {\n-            populate_impls(cx, tcx, item.def, &mut impls);\n-        }\n+    if cx.populated_all_crate_impls.get() {\n+        return impls;\n+    }\n \n-        fn populate_impls<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    def: cstore::DefLike,\n-                                    impls: &mut Vec<clean::Item>) {\n-            match def {\n-                cstore::DlImpl(did) => build_impl(cx, tcx, did, impls),\n-                cstore::DlDef(Def::Mod(did)) => {\n-                    for item in tcx.sess.cstore.item_children(did) {\n-                        populate_impls(cx, tcx, item.def, impls)\n-                    }\n-                }\n-                _ => {}\n-            }\n+    cx.populated_all_crate_impls.set(true);\n+\n+    for did in tcx.sess.cstore.implementations_of_trait(None) {\n+        build_impl(cx, tcx, did, &mut impls);\n+    }\n+\n+    // Also try to inline primitive impls from other crates.\n+    let primitive_impls = [\n+        tcx.lang_items.isize_impl(),\n+        tcx.lang_items.i8_impl(),\n+        tcx.lang_items.i16_impl(),\n+        tcx.lang_items.i32_impl(),\n+        tcx.lang_items.i64_impl(),\n+        tcx.lang_items.usize_impl(),\n+        tcx.lang_items.u8_impl(),\n+        tcx.lang_items.u16_impl(),\n+        tcx.lang_items.u32_impl(),\n+        tcx.lang_items.u64_impl(),\n+        tcx.lang_items.f32_impl(),\n+        tcx.lang_items.f64_impl(),\n+        tcx.lang_items.char_impl(),\n+        tcx.lang_items.str_impl(),\n+        tcx.lang_items.slice_impl(),\n+        tcx.lang_items.slice_impl(),\n+        tcx.lang_items.const_ptr_impl()\n+    ];\n+\n+    for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n+        if !def_id.is_local() {\n+            tcx.populate_implementations_for_primitive_if_necessary(def_id);\n+            build_impl(cx, tcx, def_id, &mut impls);\n         }\n     }\n \n@@ -348,12 +367,10 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n     }\n \n     let predicates = tcx.lookup_predicates(did);\n-    let trait_items = tcx.sess.cstore.impl_items(did)\n+    let trait_items = tcx.sess.cstore.impl_or_trait_items(did)\n             .iter()\n-            .filter_map(|did| {\n-        let did = did.def_id();\n-        let impl_item = tcx.impl_or_trait_item(did);\n-        match impl_item {\n+            .filter_map(|&did| {\n+        match tcx.impl_or_trait_item(did) {\n             ty::ConstTraitItem(ref assoc_const) => {\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);\n@@ -453,7 +470,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             for_: for_,\n             generics: (ty.generics, &predicates).clean(cx),\n             items: trait_items,\n-            polarity: polarity.map(|p| { p.clean(cx) }),\n+            polarity: Some(polarity.clean(cx)),\n         }),\n         source: clean::Span::empty(),\n         name: None,\n@@ -481,20 +498,13 @@ fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // visit each node at most once.\n         let mut visited = FnvHashSet();\n         for item in tcx.sess.cstore.item_children(did) {\n-            match item.def {\n-                cstore::DlDef(Def::ForeignMod(did)) => {\n-                    fill_in(cx, tcx, did, items);\n-                }\n-                cstore::DlDef(def) if item.vis == ty::Visibility::Public => {\n-                    if !visited.insert(def) { continue }\n+            if tcx.sess.cstore.visibility(item.def_id) == ty::Visibility::Public {\n+                if !visited.insert(item.def_id) { continue }\n+                if let Some(def) = tcx.sess.cstore.describe_def(item.def_id) {\n                     if let Some(i) = try_inline_def(cx, tcx, def) {\n                         items.extend(i)\n                     }\n                 }\n-                cstore::DlDef(..) => {}\n-                // All impls were inlined above\n-                cstore::DlImpl(..) => {}\n-                cstore::DlField => panic!(\"unimplemented field\"),\n             }\n         }\n     }"}, {"sha": "0ae059509bd1057a6ba16d3b4d5c1f1d9a7f9353", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 68, "deletions": 99, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -33,12 +33,10 @@ use syntax::print::pprust as syntax_pprust;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc_trans::back::link;\n-use rustc::middle::cstore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n-use rustc::hir::fold::Folder;\n+use rustc::hir::def_id::{self, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n@@ -116,15 +114,15 @@ pub struct Crate {\n     pub name: String,\n     pub src: PathBuf,\n     pub module: Option<Item>,\n-    pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n+    pub externs: Vec<(def_id::CrateNum, ExternalCrate)>,\n     pub primitives: Vec<PrimitiveType>,\n     pub access_levels: Arc<AccessLevels<DefId>>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n     pub external_traits: FnvHashMap<DefId, Trait>,\n }\n \n-struct CrateNum(ast::CrateNum);\n+struct CrateNum(def_id::CrateNum);\n \n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n@@ -239,19 +237,16 @@ pub struct ExternalCrate {\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n+        let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n         cx.tcx_opt().map(|tcx| {\n-            for item in tcx.sess.cstore.crate_top_level_items(self.0) {\n-                let did = match item.def {\n-                    cstore::DlDef(Def::Mod(did)) => did,\n-                    _ => continue\n-                };\n-                let attrs = inline::load_attrs(cx, tcx, did);\n+            for item in tcx.sess.cstore.item_children(root) {\n+                let attrs = inline::load_attrs(cx, tcx, item.def_id);\n                 PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n             }\n         });\n         ExternalCrate {\n             name: (&cx.sess().cstore.crate_name(self.0)[..]).to_owned(),\n-            attrs: cx.sess().cstore.crate_attrs(self.0).clean(cx),\n+            attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n             primitives: primitives,\n         }\n     }\n@@ -774,7 +769,20 @@ impl Lifetime {\n }\n \n impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, _: &DocContext) -> Lifetime {\n+    fn clean(&self, cx: &DocContext) -> Lifetime {\n+        if let Some(tcx) = cx.tcx_opt() {\n+            let def = tcx.named_region_map.defs.get(&self.id).cloned();\n+            match def {\n+                Some(DefEarlyBoundRegion(_, node_id)) |\n+                Some(DefLateBoundRegion(_, node_id)) |\n+                Some(DefFreeRegion(_, node_id)) => {\n+                    if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n+                        return lt;\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n         Lifetime(self.name.to_string())\n     }\n }\n@@ -1149,7 +1157,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n         let mut names = if cx.map.as_local_node_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n-            cx.tcx().sess.cstore.method_arg_names(did).into_iter()\n+            cx.tcx().sess.cstore.fn_arg_names(did).into_iter()\n         }.peekable();\n         FnDecl {\n             output: Return(sig.0.output.clean(cx)),\n@@ -1159,8 +1167,8 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n                 values: sig.0.inputs.iter().map(|t| {\n                     Argument {\n                         type_: t.clean(cx),\n-                        id: 0,\n-                        name: names.next().unwrap_or(\"\".to_string()),\n+                        id: ast::CRATE_NODE_ID,\n+                        name: names.next().map_or(\"\".to_string(), |name| name.to_string()),\n                     }\n                 }).collect(),\n             },\n@@ -1629,42 +1637,6 @@ impl From<ast::FloatTy> for PrimitiveType {\n     }\n }\n \n-// Poor man's type parameter substitution at HIR level.\n-// Used to replace private type aliases in public signatures with their aliased types.\n-struct SubstAlias<'a, 'tcx: 'a> {\n-    tcx: &'a ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    // Table type parameter definition -> substituted type\n-    ty_substs: FnvHashMap<Def, hir::Ty>,\n-    // Table node id of lifetime parameter definition -> substituted lifetime\n-    lt_substs: FnvHashMap<ast::NodeId, hir::Lifetime>,\n-}\n-\n-impl<'a, 'tcx: 'a, 'b: 'tcx> Folder for SubstAlias<'a, 'tcx> {\n-    fn fold_ty(&mut self, ty: P<hir::Ty>) -> P<hir::Ty> {\n-        if let hir::TyPath(..) = ty.node {\n-            let def = self.tcx.expect_def(ty.id);\n-            if let Some(new_ty) = self.ty_substs.get(&def).cloned() {\n-                return P(new_ty);\n-            }\n-        }\n-        hir::fold::noop_fold_ty(ty, self)\n-    }\n-    fn fold_lifetime(&mut self, lt: hir::Lifetime) -> hir::Lifetime {\n-        let def = self.tcx.named_region_map.defs.get(&lt.id).cloned();\n-        match def {\n-            Some(DefEarlyBoundRegion(_, node_id)) |\n-            Some(DefLateBoundRegion(_, node_id)) |\n-            Some(DefFreeRegion(_, node_id)) => {\n-                if let Some(lt) = self.lt_substs.get(&node_id).cloned() {\n-                    return lt;\n-                }\n-            }\n-            _ => {}\n-        }\n-        hir::fold::noop_fold_lifetime(lt, self)\n-    }\n-}\n-\n impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use rustc::hir::*;\n@@ -1696,43 +1668,47 @@ impl Clean<Type> for hir::Ty {\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(None, ref path) => {\n-                if let Some(tcx) = cx.tcx_opt() {\n-                    // Substitute private type aliases\n-                    let def = tcx.expect_def(self.id);\n+                let tcx_and_def = cx.tcx_opt().map(|tcx| (tcx, tcx.expect_def(self.id)));\n+                if let Some((_, def)) = tcx_and_def {\n+                    if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n+                        return new_ty;\n+                    }\n+                }\n+\n+                let tcx_and_alias = tcx_and_def.and_then(|(tcx, def)| {\n                     if let Def::TyAlias(def_id) = def {\n-                        if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+                        // Substitute private type aliases\n+                        tcx.map.as_local_node_id(def_id).and_then(|node_id| {\n                             if !cx.access_levels.borrow().is_exported(def_id) {\n-                                let item = tcx.map.expect_item(node_id);\n-                                if let hir::ItemTy(ref ty, ref generics) = item.node {\n-                                    let provided_params = &path.segments.last().unwrap().parameters;\n-                                    let mut ty_substs = FnvHashMap();\n-                                    let mut lt_substs = FnvHashMap();\n-                                    for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                                        let ty_param_def = tcx.expect_def(ty_param.id);\n-                                        if let Some(ty) = provided_params.types().get(i).cloned()\n-                                                                                        .cloned() {\n-                                            ty_substs.insert(ty_param_def, ty.unwrap());\n-                                        } else if let Some(default) = ty_param.default.clone() {\n-                                            ty_substs.insert(ty_param_def, default.unwrap());\n-                                        }\n-                                    }\n-                                    for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n-                                        if let Some(lt) = provided_params.lifetimes().get(i)\n-                                                                                     .cloned()\n-                                                                                     .cloned() {\n-                                            lt_substs.insert(lt_param.lifetime.id, lt);\n-                                        }\n-                                    }\n-                                    let mut subst_alias = SubstAlias {\n-                                        tcx: &tcx,\n-                                        ty_substs: ty_substs,\n-                                        lt_substs: lt_substs\n-                                    };\n-                                    return subst_alias.fold_ty(ty.clone()).clean(cx);\n-                                }\n+                                Some((tcx, &tcx.map.expect_item(node_id).node))\n+                            } else {\n+                                None\n                             }\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                });\n+                if let Some((tcx, &hir::ItemTy(ref ty, ref generics))) = tcx_and_alias {\n+                    let provided_params = &path.segments.last().unwrap().parameters;\n+                    let mut ty_substs = FnvHashMap();\n+                    let mut lt_substs = FnvHashMap();\n+                    for (i, ty_param) in generics.ty_params.iter().enumerate() {\n+                        let ty_param_def = tcx.expect_def(ty_param.id);\n+                        if let Some(ty) = provided_params.types().get(i).cloned()\n+                                                                        .cloned() {\n+                            ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n+                        } else if let Some(default) = ty_param.default.clone() {\n+                            ty_substs.insert(ty_param_def, default.unwrap().clean(cx));\n+                        }\n+                    }\n+                    for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n+                        if let Some(lt) = provided_params.lifetimes().get(i).cloned()\n+                                                                            .cloned() {\n+                            lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n                         }\n                     }\n+                    return cx.enter_alias(ty_substs, lt_substs, || ty.clean(cx));\n                 }\n                 resolve_type(cx, path.clean(cx), self.id)\n             }\n@@ -1808,7 +1784,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (cx.map.local_def_id(0), &fty.sig).clean(cx),\n+                decl: (cx.map.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n                 abi: fty.abi,\n             }),\n             ty::TyAdt(def, substs) => {\n@@ -1897,11 +1873,9 @@ impl Clean<Item> for hir::StructField {\n \n impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        // FIXME: possible O(n^2)-ness! Not my fault.\n-        let attr_map = cx.tcx().sess.cstore.crate_struct_field_attrs(self.did.krate);\n         Item {\n             name: Some(self.name).clean(cx),\n-            attrs: attr_map.get(&self.did).unwrap_or(&Vec::new()).clean(cx),\n+            attrs: cx.tcx().get_attrs(self.did).clean(cx),\n             source: Span::empty(),\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),\n@@ -2590,7 +2564,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(0),\n+            def_id: cx.map.local_def_id(ast::CRATE_NODE_ID),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n@@ -2779,6 +2753,8 @@ fn resolve_type(cx: &DocContext,\n fn register_def(cx: &DocContext, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n+    let tcx = cx.tcx();\n+\n     let (did, kind) = match def {\n         Def::Fn(i) => (i, TypeFunction),\n         Def::TyAlias(i) => (i, TypeTypedef),\n@@ -2788,21 +2764,14 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Union(i) => (i, TypeUnion),\n         Def::Mod(i) => (i, TypeModule),\n         Def::Static(i, _) => (i, TypeStatic),\n-        Def::Variant(i, _) => (i, TypeEnum),\n+        Def::Variant(i) => (tcx.parent_def_id(i).unwrap(), TypeEnum),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeTrait),\n-        Def::SelfTy(_, Some(impl_id)) => {\n-            // For Def::SelfTy() values inlined from another crate, the\n-            // impl_id will be DUMMY_NODE_ID, which would cause problems.\n-            // But we should never run into an impl from another crate here.\n-            return cx.map.local_def_id(impl_id)\n+        Def::SelfTy(_, Some(impl_def_id)) => {\n+            return impl_def_id\n         }\n         _ => return def.def_id()\n     };\n     if did.is_local() { return did }\n-    let tcx = match cx.tcx_opt() {\n-        Some(tcx) => tcx,\n-        None => return did\n-    };\n     inline::record_extern_fqn(cx, did, kind);\n     if let TypeTrait = kind {\n         let t = inline::build_external_trait(cx, tcx, did);"}, {"sha": "c52497dc89bd6b7c824ff2b3acc0010afddee7ab", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -14,11 +14,12 @@ use rustc_driver::{driver, target_features, abort_on_err};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n+use rustc::hir::def::Def;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::FnvHashMap;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -29,6 +30,7 @@ use errors;\n use errors::emitter::ColorConfig;\n \n use std::cell::{RefCell, Cell};\n+use std::mem;\n use std::rc::Rc;\n \n use visit_ast::RustdocVisitor;\n@@ -51,7 +53,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub map: &'a hir_map::Map<'tcx>,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n-    pub populated_crate_impls: RefCell<FnvHashSet<ast::CrateNum>>,\n+    pub populated_all_crate_impls: Cell<bool>,\n     pub deref_trait_did: Cell<Option<DefId>>,\n     pub deref_mut_trait_did: Cell<Option<DefId>>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n@@ -63,6 +65,14 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n     pub external_traits: RefCell<FnvHashMap<DefId, clean::Trait>>,\n+\n+    // The current set of type and lifetime substitutions,\n+    // for expanding type aliases at the HIR level:\n+\n+    /// Table type parameter definition -> substituted type\n+    pub ty_substs: RefCell<FnvHashMap<Def, clean::Type>>,\n+    /// Table node id of lifetime parameter definition -> substituted lifetime\n+    pub lt_substs: RefCell<FnvHashMap<ast::NodeId, clean::Lifetime>>,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -84,6 +94,22 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n         let tcx_opt = self.tcx_opt();\n         tcx_opt.expect(\"tcx not present\")\n     }\n+\n+    /// Call the closure with the given parameters set as\n+    /// the substitutions for a type alias' RHS.\n+    pub fn enter_alias<F, R>(&self,\n+                             ty_substs: FnvHashMap<Def, clean::Type>,\n+                             lt_substs: FnvHashMap<ast::NodeId, clean::Lifetime>,\n+                             f: F) -> R\n+    where F: FnOnce() -> R {\n+        let (old_tys, old_lts) =\n+            (mem::replace(&mut *self.ty_substs.borrow_mut(), ty_substs),\n+             mem::replace(&mut *self.lt_substs.borrow_mut(), lt_substs));\n+        let r = f();\n+        *self.ty_substs.borrow_mut() = old_tys;\n+        *self.lt_substs.borrow_mut() = old_lts;\n+        r\n+    }\n }\n \n pub trait DocAccessLevels {\n@@ -179,12 +205,14 @@ pub fn run_core(search_paths: SearchPaths,\n             map: &tcx.map,\n             maybe_typed: Typed(tcx),\n             input: input,\n-            populated_crate_impls: RefCell::new(FnvHashSet()),\n+            populated_all_crate_impls: Cell::new(false),\n             deref_trait_did: Cell::new(None),\n             deref_mut_trait_did: Cell::new(None),\n             access_levels: RefCell::new(access_levels),\n-            external_traits: RefCell::new(FnvHashMap()),\n-            renderinfo: RefCell::new(Default::default()),\n+            external_traits: Default::default(),\n+            renderinfo: Default::default(),\n+            ty_substs: Default::default(),\n+            lt_substs: Default::default(),\n         };\n         debug!(\"crate: {:?}\", ctxt.map.krate());\n "}, {"sha": "609ae0c0e6daf60f9cee7a8bc22d1cb0c4d4bc5c", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -21,6 +21,7 @@ use syntax::ptr::P;\n use syntax_pos::{self, Span};\n \n use rustc::hir;\n+use rustc::hir::def_id::CrateNum;\n \n pub struct Module {\n     pub name: Option<Name>,\n@@ -53,7 +54,7 @@ impl Module {\n     pub fn new(name: Option<Name>) -> Module {\n         Module {\n             name       : name,\n-            id: 0,\n+            id: ast::CRATE_NODE_ID,\n             vis: hir::Inherited,\n             stab: None,\n             depr: None,\n@@ -245,7 +246,7 @@ pub struct Macro {\n \n pub struct ExternCrate {\n     pub name: Name,\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n     pub path: Option<String>,\n     pub vis: hir::Visibility,\n     pub attrs: hir::HirVec<ast::Attribute>,"}, {"sha": "adcdc7aaab4005d252381e41dc8dbcca2d3fa158", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -18,8 +18,7 @@\n use std::fmt;\n use std::iter::repeat;\n \n-use rustc::middle::cstore::LOCAL_CRATE;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use syntax::abi::Abi;\n use rustc::hir;\n "}, {"sha": "03d772d1a6db3f0294cfc088e306d37d1cfb1b2a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -53,10 +53,9 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n-use syntax::{abi, ast};\n+use syntax::abi;\n use syntax::feature_gate::UnstableFeatures;\n-use rustc::middle::cstore::LOCAL_CRATE;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n@@ -246,10 +245,10 @@ pub struct Cache {\n     pub implementors: FnvHashMap<DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FnvHashMap<ast::CrateNum, (String, ExternalLocation)>,\n+    pub extern_locations: FnvHashMap<CrateNum, (String, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FnvHashMap<clean::PrimitiveType, ast::CrateNum>,\n+    pub primitive_locations: FnvHashMap<clean::PrimitiveType, CrateNum>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing"}, {"sha": "4518945dd9857ffd99bed3791eb02f264dee4341", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::{RefCell, Cell};\n+use std::cell::Cell;\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n@@ -28,7 +28,6 @@ use rustc::session::{self, config};\n use rustc::session::config::{get_unstable_features_setting, OutputType,\n                              OutputTypes, Externs};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n@@ -107,12 +106,14 @@ pub fn run(input: &str,\n         map: &map,\n         maybe_typed: core::NotTyped(&sess),\n         input: input,\n-        external_traits: RefCell::new(FnvHashMap()),\n-        populated_crate_impls: RefCell::new(FnvHashSet()),\n+        populated_all_crate_impls: Cell::new(false),\n+        external_traits: Default::default(),\n         deref_trait_did: Cell::new(None),\n         deref_mut_trait_did: Cell::new(None),\n         access_levels: Default::default(),\n         renderinfo: Default::default(),\n+        ty_substs: Default::default(),\n+        lt_substs: Default::default(),\n     };\n \n     let mut v = RustdocVisitor::new(&ctx);"}, {"sha": "a29566f7a0717abb390205bedd1290f48e810f9b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -20,6 +20,7 @@ use syntax_pos::Span;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::privacy::AccessLevel;\n use rustc::util::nodemap::FnvHashSet;\n \n@@ -339,7 +340,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let cstore = &self.cx.sess().cstore;\n                 om.extern_crates.push(ExternCrate {\n                     cnum: cstore.extern_mod_stmt_cnum(item.id)\n-                                .unwrap_or(ast::CrateNum::max_value()),\n+                                .unwrap_or(LOCAL_CRATE),\n                     name: name,\n                     path: p.map(|x|x.to_string()),\n                     vis: item.vis.clone(),"}, {"sha": "285b47fe60abf54290b11a5ddf90ba420c7db9c4", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::middle::cstore::{CrateStore, ChildItem, DefLike};\n+use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty::Visibility;\n-use syntax::ast;\n \n use std::cell::RefMut;\n \n@@ -42,7 +41,7 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    pub fn visit_lib(&mut self, cnum: ast::CrateNum) {\n+    pub fn visit_lib(&mut self, cnum: CrateNum) {\n         let did = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n         self.update(did, Some(AccessLevel::Public));\n         self.visit_mod(did);\n@@ -65,45 +64,27 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    pub fn visit_mod(&mut self, did: DefId) {\n-        for item in self.cstore.item_children(did) {\n-            if let DefLike::DlDef(def) = item.def {\n-                match def {\n-                    Def::Mod(did) |\n-                    Def::ForeignMod(did) |\n-                    Def::Trait(did) |\n-                    Def::Struct(did) |\n-                    Def::Union(did) |\n-                    Def::Enum(did) |\n-                    Def::TyAlias(did) |\n-                    Def::Fn(did) |\n-                    Def::Method(did) |\n-                    Def::Static(did, _) |\n-                    Def::Const(did) => self.visit_item(did, item),\n-                    _ => {}\n-                }\n-            }\n+    pub fn visit_mod(&mut self, def_id: DefId) {\n+        for item in self.cstore.item_children(def_id) {\n+            self.visit_item(item.def_id);\n         }\n     }\n \n-    fn visit_item(&mut self, did: DefId, item: ChildItem) {\n-        let inherited_item_level = match item.def {\n-            DefLike::DlImpl(..) | DefLike::DlField => unreachable!(),\n-            DefLike::DlDef(def) => {\n-                match def {\n-                    Def::ForeignMod(..) => self.prev_level,\n-                    _ => if item.vis == Visibility::Public { self.prev_level } else { None }\n-                }\n-            }\n+    fn visit_item(&mut self, def_id: DefId) {\n+        let vis = self.cstore.visibility(def_id);\n+        let inherited_item_level = if vis == Visibility::Public {\n+            self.prev_level\n+        } else {\n+            None\n         };\n \n-        let item_level = self.update(did, inherited_item_level);\n+        let item_level = self.update(def_id, inherited_item_level);\n \n-        if let DefLike::DlDef(Def::Mod(did)) = item.def {\n+        if let Some(Def::Mod(_)) = self.cstore.describe_def(def_id) {\n             let orig_level = self.prev_level;\n \n             self.prev_level = item_level;\n-            self.visit_mod(did);\n+            self.visit_mod(def_id);\n             self.prev_level = orig_level;\n         }\n     }"}, {"sha": "ba9bf2b86a60fbcf1de9f0873ddbd2898ac0915f", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -134,7 +134,7 @@ impl<\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let mut bits = 0;\n         for item in self {\n-            bits |= item.to_usize();\n+            bits |= 1 << item.to_usize();\n         }\n         s.emit_usize(bits)\n     }\n@@ -148,7 +148,7 @@ impl<\n         let mut set = EnumSet::new();\n         for bit in 0..(mem::size_of::<usize>()*8) {\n             if bits & (1 << bit) != 0 {\n-                set.insert(CLike::from_usize(1 << bit));\n+                set.insert(CLike::from_usize(bit));\n             }\n         }\n         Ok(set)"}, {"sha": "0c5356c0222359c70151d13a3da43bdc8aa07ce4", "filename": "src/libserialize/leb128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "previous_filename": "src/librbml/leb128.rs"}, {"sha": "7cb02e2412c65808e6363456bce5b9c0901f90ba", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -29,8 +29,10 @@ Core encoding and decoding interfaces.\n \n #![feature(box_syntax)]\n #![feature(collections)]\n+#![feature(core_intrinsics)]\n #![feature(enumset)]\n #![feature(rustc_private)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unicode)]\n #![feature(question_mark)]\n@@ -43,15 +45,20 @@ Core encoding and decoding interfaces.\n extern crate rustc_unicode;\n extern crate collections;\n \n-pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n-                          DecoderHelpers, EncoderHelpers};\n+pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n+\n+pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};\n+pub use self::serialize::{UseSpecializedEncodable, UseSpecializedDecodable};\n \n mod serialize;\n mod collection_impls;\n \n pub mod hex;\n pub mod json;\n \n+pub mod opaque;\n+pub mod leb128;\n+\n mod rustc_serialize {\n     pub use serialize::*;\n }"}, {"sha": "e97834f63cee4eaf7756c0e884a852fef11654a7", "filename": "src/libserialize/opaque.rs", "status": "renamed", "additions": 4, "deletions": 263, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use Error as DecodeError;\n-use writer::EncodeResult;\n use leb128::{read_signed_leb128, read_unsigned_leb128, write_signed_leb128, write_unsigned_leb128};\n use std::io::{self, Write};\n use serialize;\n@@ -18,6 +16,8 @@ use serialize;\n // Encoder\n // -----------------------------------------------------------------------------\n \n+pub type EncodeResult = io::Result<()>;\n+\n pub struct Encoder<'a> {\n     pub cursor: &'a mut io::Cursor<Vec<u8>>,\n }\n@@ -124,141 +124,12 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         let _ = self.cursor.write_all(v.as_bytes());\n         Ok(())\n     }\n-\n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant<F>(&mut self,\n-                            _v_name: &str,\n-                            v_id: usize,\n-                            _len: usize,\n-                            f: F)\n-                            -> EncodeResult\n-        where F: FnOnce(&mut Self) -> EncodeResult\n-    {\n-        self.emit_usize(v_id)?;\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_struct_variant<F>(&mut self,\n-                                   v_name: &str,\n-                                   v_id: usize,\n-                                   cnt: usize,\n-                                   f: F)\n-                                   -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_enum_variant(v_name, v_id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_seq(len, f)\n-    }\n-\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_seq(len, f)\n-    }\n-\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_enum(\"Option\", f)\n-    }\n-\n-    fn emit_option_none(&mut self) -> EncodeResult {\n-        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-    }\n-\n-    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_enum_variant(\"Some\", 1, 1, f)\n-    }\n-\n-    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_usize(len)?;\n-        f(self)\n-    }\n-\n-    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        self.emit_usize(len)?;\n-        f(self)\n-    }\n-\n-    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-    {\n-        f(self)\n-    }\n }\n \n impl<'a> Encoder<'a> {\n     pub fn position(&self) -> usize {\n         self.cursor.position() as usize\n     }\n-\n-    pub fn from_rbml<'b: 'c, 'c>(rbml: &'c mut ::writer::Encoder<'b>) -> Encoder<'c> {\n-        Encoder { cursor: rbml.writer }\n-    }\n }\n \n // -----------------------------------------------------------------------------\n@@ -305,7 +176,7 @@ macro_rules! read_sleb128 {\n \n \n impl<'a> serialize::Decoder for Decoder<'a> {\n-    type Error = DecodeError;\n+    type Error = String;\n \n     fn read_nil(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n@@ -382,138 +253,8 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         Ok(s.to_string())\n     }\n \n-    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n-    {\n-        let disr = self.read_usize()?;\n-        f(self, disr)\n-    }\n-\n-    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n-    {\n-        let disr = self.read_usize()?;\n-        f(self, disr)\n-    }\n-\n-    fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                            _name: &str,\n-                                            _idx: usize,\n-                                            f: F)\n-                                            -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_struct<T, F>(&mut self, _name: &str, _: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_struct_field<T, F>(&mut self, _name: &str, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        self.read_seq(move |d, len| {\n-            if len == tuple_len {\n-                f(d)\n-            } else {\n-                let err = format!(\"Invalid tuple length. Expected {}, found {}\",\n-                                  tuple_len,\n-                                  len);\n-                Err(DecodeError::Expected(err))\n-            }\n-        })\n-    }\n-\n-    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        self.read_seq_elt(idx, f)\n-    }\n-\n-    fn read_tuple_struct<T, F>(&mut self, _name: &str, len: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        self.read_tuple(len, f)\n-    }\n-\n-    fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        self.read_tuple_arg(idx, f)\n-    }\n-\n-    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Decoder<'a>, bool) -> Result<T, Self::Error>\n-    {\n-        self.read_enum(\"Option\", move |this| {\n-            this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                match idx {\n-                    0 => f(this, false),\n-                    1 => f(this, true),\n-                    _ => {\n-                        let msg = format!(\"Invalid Option index: {}\", idx);\n-                        Err(DecodeError::Expected(msg))\n-                    }\n-                }\n-            })\n-        })\n-    }\n-\n-    fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n-    {\n-        let len = self.read_usize()?;\n-        f(self, len)\n-    }\n-\n-    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n-    {\n-        let len = self.read_usize()?;\n-        f(self, len)\n-    }\n-\n-    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>\n-    {\n-        f(self)\n-    }\n-\n     fn error(&mut self, err: &str) -> Self::Error {\n-        DecodeError::ApplicationError(err.to_string())\n+        err.to_string()\n     }\n }\n ", "previous_filename": "src/librbml/opaque.rs"}, {"sha": "6650a981884d8eaad31fd551d948c72161a7fead", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 216, "deletions": 95, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -14,6 +14,7 @@\n Core encoding and decoding interfaces.\n */\n \n+use std::intrinsics;\n use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n@@ -41,66 +42,99 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n \n     // Compound types:\n-    fn emit_enum<F>(&mut self, name: &str, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_enum<F>(&mut self, _name: &str, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n-    fn emit_enum_variant<F>(&mut self, v_name: &str,\n+    fn emit_enum_variant<F>(&mut self, _v_name: &str,\n                             v_id: usize,\n-                            len: usize,\n+                            _len: usize,\n                             f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_enum_variant_arg<F>(&mut self, a_idx: usize, f: F)\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_usize(v_id)?;\n+        f(self)\n+    }\n+    fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F)\n                                 -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n     fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n                                    v_id: usize,\n                                    len: usize,\n                                    f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_enum_variant(v_name, v_id, len, f)\n+    }\n     fn emit_enum_struct_variant_field<F>(&mut self,\n-                                         f_name: &str,\n+                                         _f_name: &str,\n                                          f_idx: usize,\n                                          f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_enum_variant_arg(f_idx, f)\n+    }\n \n-    fn emit_struct<F>(&mut self, name: &str, len: usize, f: F)\n+    fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F)\n                       -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: usize, f: F)\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+    fn emit_struct_field<F>(&mut self, _f_name: &str, _f_idx: usize, f: F)\n                             -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_tuple<F>(&mut self, _len: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+    fn emit_tuple_arg<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n-    fn emit_tuple_struct<F>(&mut self, name: &str, len: usize, f: F)\n+    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F)\n                             -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_tuple(len, f)\n+    }\n     fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F)\n                                 -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_tuple_arg(f_idx, f)\n+    }\n \n     // Specialized types:\n     fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_option_none(&mut self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_enum(\"Option\", f)\n+    }\n+    fn emit_option_none(&mut self) -> Result<(), Self::Error> {\n+        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n+    }\n     fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+\n+        self.emit_enum_variant(\"Some\", 1, 1, f)\n+    }\n \n     fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_usize(len)?;\n+        f(self)\n+    }\n+    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n     fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_map_elt_val<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        self.emit_usize(len)?;\n+        f(self)\n+    }\n+    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n }\n \n pub trait Decoder {\n@@ -125,66 +159,101 @@ pub trait Decoder {\n     fn read_str(&mut self) -> Result<String, Self::Error>;\n \n     // Compound types:\n-    fn read_enum<T, F>(&mut self, name: &str, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n-    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F)\n+    fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F)\n                                -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>;\n-    fn read_enum_variant_arg<T, F>(&mut self, a_idx: usize, f: F)\n+        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n+    {\n+        let disr = self.read_usize()?;\n+        f(self, disr)\n+    }\n+    fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F)\n                                    -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F)\n                                       -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>;\n+        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n+    {\n+        self.read_enum_variant(names, f)\n+    }\n     fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                            &f_name: &str,\n+                                            _f_name: &str,\n                                             f_idx: usize,\n                                             f: F)\n                                             -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        self.read_enum_variant_arg(f_idx, f)\n+    }\n \n-    fn read_struct<T, F>(&mut self, s_name: &str, len: usize, f: F)\n+    fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F)\n                          -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n     fn read_struct_field<T, F>(&mut self,\n-                               f_name: &str,\n-                               f_idx: usize,\n+                               _f_name: &str,\n+                               _f_idx: usize,\n                                f: F)\n                                -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n-    fn read_tuple<T, F>(&mut self, len: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_tuple_arg<T, F>(&mut self, a_idx: usize, f: F)\n+    fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+    fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F)\n                             -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n-    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: usize, f: F)\n+    fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F)\n                                -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        self.read_tuple(len, f)\n+    }\n     fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F)\n                                    -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        self.read_tuple_arg(a_idx, f)\n+    }\n \n     // Specialized types:\n-    fn read_option<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>;\n+    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n+        where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>\n+    {\n+        self.read_enum(\"Option\", move |this| {\n+            this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n+                match idx {\n+                    0 => f(this, false),\n+                    1 => f(this, true),\n+                    _ => Err(this.error(\"read_option: expected 0 for None or 1 for Some\")),\n+                }\n+            })\n+        })\n+    }\n \n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>;\n-    fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n+    {\n+        let len = self.read_usize()?;\n+        f(self, len)\n+    }\n+    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>;\n-    fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F)\n+        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n+    {\n+        let len = self.read_usize()?;\n+        f(self, len)\n+    }\n+    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F)\n                               -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F)\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F)\n                               -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n     // Failure\n     fn error(&mut self, err: &str) -> Self::Error;\n@@ -593,45 +662,97 @@ impl<T:Decodable+Send+Sync> Decodable for Arc<T> {\n }\n \n // ___________________________________________________________________________\n-// Helper routines\n+// Specialization-based interface for multi-dispatch Encodable/Decodable.\n \n-pub trait EncoderHelpers: Encoder {\n-    fn emit_from_vec<T, F>(&mut self, v: &[T], f: F)\n-                           -> Result<(), Self::Error>\n-        where F: FnMut(&mut Self, &T) -> Result<(), Self::Error>;\n+/// Implement this trait on your `{Encodable,Decodable}::Error` types\n+/// to override the default panic behavior for missing specializations.\n+pub trait SpecializationError {\n+    /// Create an error for a missing method specialization.\n+    /// Defaults to panicking with type, trait & method names.\n+    /// `S` is the encoder/decoder state type,\n+    /// `T` is the type being encoded/decoded, and\n+    /// the arguments are the names of the trait\n+    /// and method that should've been overriden.\n+    fn not_found<S, T: ?Sized>(trait_name: &'static str,\n+                               method_name: &'static str) -> Self;\n }\n \n-impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T, F>(&mut self, v: &[T], mut f: F) -> Result<(), S::Error> where\n-        F: FnMut(&mut S, &T) -> Result<(), S::Error>,\n-    {\n-        self.emit_seq(v.len(), |this| {\n-            for (i, e) in v.iter().enumerate() {\n-                this.emit_seq_elt(i, |this| {\n-                    f(this, e)\n-                })?;\n-            }\n-            Ok(())\n-        })\n+impl<E> SpecializationError for E {\n+    default fn not_found<S, T: ?Sized>(trait_name: &'static str,\n+                                       method_name: &'static str) -> E {\n+        panic!(\"missing specializaiton: `<{} as {}<{}>>::{}` not overriden\",\n+               unsafe { intrinsics::type_name::<S>() },\n+               trait_name,\n+               unsafe { intrinsics::type_name::<T>() },\n+               method_name);\n     }\n }\n \n-pub trait DecoderHelpers: Decoder {\n-    fn read_to_vec<T, F>(&mut self, f: F)\n-                         -> Result<Vec<T>, Self::Error> where\n-        F: FnMut(&mut Self) -> Result<T, Self::Error>;\n+/// Implement this trait on encoders, with `T` being the type\n+/// you want to encode (employing `UseSpecializedEncodable`),\n+/// using a strategy specific to the encoder.\n+pub trait SpecializedEncoder<T: ?Sized + UseSpecializedEncodable>: Encoder {\n+    /// Encode the value in a manner specific to this encoder state.\n+    fn specialized_encode(&mut self, value: &T) -> Result<(), Self::Error>;\n }\n \n-impl<D: Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T, F>(&mut self, mut f: F) -> Result<Vec<T>, D::Error> where F:\n-        FnMut(&mut D) -> Result<T, D::Error>,\n-    {\n-        self.read_seq(|this, len| {\n-            let mut v = Vec::with_capacity(len);\n-            for i in 0..len {\n-                v.push(this.read_seq_elt(i, |this| f(this))?);\n-            }\n-            Ok(v)\n-        })\n+impl<E: Encoder, T: ?Sized + UseSpecializedEncodable> SpecializedEncoder<T> for E {\n+    default fn specialized_encode(&mut self, value: &T) -> Result<(), E::Error> {\n+        value.default_encode(self)\n+    }\n+}\n+\n+/// Implement this trait on decoders, with `T` being the type\n+/// you want to decode (employing `UseSpecializedDecodable`),\n+/// using a strategy specific to the decoder.\n+pub trait SpecializedDecoder<T: UseSpecializedDecodable>: Decoder {\n+    /// Decode a value in a manner specific to this decoder state.\n+    fn specialized_decode(&mut self) -> Result<T, Self::Error>;\n+}\n+\n+impl<D: Decoder, T: UseSpecializedDecodable> SpecializedDecoder<T> for D {\n+    default fn specialized_decode(&mut self) -> Result<T, D::Error> {\n+        T::default_decode(self)\n+    }\n+}\n+\n+/// Implement this trait on your type to get an `Encodable`\n+/// implementation which goes through `SpecializedEncoder`.\n+pub trait UseSpecializedEncodable {\n+    /// Defaults to returning an error (see `SpecializationError`).\n+    fn default_encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n+        Err(E::Error::not_found::<E, Self>(\"SpecializedEncoder\", \"specialized_encode\"))\n+    }\n+}\n+\n+impl<T: ?Sized + UseSpecializedEncodable> Encodable for T {\n+    default fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        E::specialized_encode(e, self)\n+    }\n+}\n+\n+/// Implement this trait on your type to get an `Decodable`\n+/// implementation which goes through `SpecializedDecoder`.\n+pub trait UseSpecializedDecodable: Sized {\n+    /// Defaults to returning an error (see `SpecializationError`).\n+    fn default_decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n+        Err(D::Error::not_found::<D, Self>(\"SpecializedDecoder\", \"specialized_decode\"))\n     }\n }\n+\n+impl<T: UseSpecializedDecodable> Decodable for T {\n+    default fn decode<D: Decoder>(d: &mut D) -> Result<T, D::Error> {\n+        D::specialized_decode(d)\n+    }\n+}\n+\n+// Can't avoid specialization for &T and Box<T> impls,\n+// as proxy impls on them are blankets that conflict\n+// with the Encodable and Decodable impls above,\n+// which only have `default` on their methods\n+// for this exact reason.\n+// May be fixable in a simpler fashion via the\n+// more complex lattice model for specialization.\n+impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {}\n+impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {}\n+impl<T: Decodable> UseSpecializedDecodable for Box<T> {}"}, {"sha": "c18b36161dfcf3a190d3c3e4b71324912d5828d8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -27,7 +27,9 @@ use tokenstream::{TokenTree};\n \n use std::fmt;\n use std::rc::Rc;\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n+use std::u32;\n+\n+use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n@@ -298,17 +300,53 @@ pub struct ParenthesizedParameterData {\n     pub output: Option<P<Ty>>,\n }\n \n-pub type CrateNum = u32;\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Debug)]\n+pub struct NodeId(u32);\n+\n+impl NodeId {\n+    pub fn new(x: usize) -> NodeId {\n+        assert!(x < (u32::MAX as usize));\n+        NodeId(x as u32)\n+    }\n+\n+    pub fn from_u32(x: u32) -> NodeId {\n+        NodeId(x)\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+}\n \n-pub type NodeId = u32;\n+impl fmt::Display for NodeId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl serialize::UseSpecializedEncodable for NodeId {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u32(self.0)\n+    }\n+}\n+\n+impl serialize::UseSpecializedDecodable for NodeId {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<NodeId, D::Error> {\n+        d.read_u32().map(NodeId)\n+    }\n+}\n \n /// Node id used to represent the root of the crate.\n-pub const CRATE_NODE_ID: NodeId = 0;\n+pub const CRATE_NODE_ID: NodeId = NodeId(0);\n \n /// When parsing and doing expansions, we initially give all AST nodes this AST\n /// node value. Then later, in the renumber pass, we renumber them to have\n /// small, positive ids.\n-pub const DUMMY_NODE_ID: NodeId = !0;\n+pub const DUMMY_NODE_ID: NodeId = NodeId(!0);\n \n /// The AST represents all type param bounds as types.\n /// typeck::collect::compute_bounds matches these against"}, {"sha": "dc02c26039c15e9b46ce5f23f519aed47fb479ed", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -895,7 +895,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         \"packed\" => Some(ReprPacked),\n                         \"simd\" => Some(ReprSimd),\n                         _ => match int_type_of_word(word) {\n-                            Some(ity) => Some(ReprInt(item.span, ity)),\n+                            Some(ity) => Some(ReprInt(ity)),\n                             None => {\n                                 // Not a word we recognize\n                                 span_err!(diagnostic, item.span, E0552,\n@@ -939,7 +939,7 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n #[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub enum ReprAttr {\n     ReprAny,\n-    ReprInt(Span, IntType),\n+    ReprInt(IntType),\n     ReprExtern,\n     ReprPacked,\n     ReprSimd,\n@@ -949,7 +949,7 @@ impl ReprAttr {\n     pub fn is_ffi_safe(&self) -> bool {\n         match *self {\n             ReprAny => false,\n-            ReprInt(_sp, ity) => ity.is_ffi_safe(),\n+            ReprInt(ity) => ity.is_ffi_safe(),\n             ReprExtern => true,\n             ReprPacked => false,\n             ReprSimd => true,"}, {"sha": "db0183a8b3a2778402cc771303a5f36de8eef9b3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -242,11 +242,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n                 let expansion = expansion.fold_with(&mut placeholder_expander);\n-                placeholder_expander.add(mark, expansion);\n+                placeholder_expander.add(ast::NodeId::from_u32(mark), expansion);\n             }\n         }\n \n-        placeholder_expander.remove(0)\n+        placeholder_expander.remove(ast::NodeId::from_u32(0))\n     }\n \n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n@@ -424,7 +424,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             expansion_kind: expansion_kind,\n             expansion_data: ExpansionData { mark: mark, ..self.cx.current_expansion.clone() },\n         });\n-        placeholder(expansion_kind, mark.as_u32())\n+        placeholder(expansion_kind, ast::NodeId::from_u32(mark.as_u32()))\n     }\n \n     fn collect_bang("}, {"sha": "118ceb17ab4a4538c639e2c493348c44a95fd326", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -33,6 +33,7 @@\n #![feature(unicode)]\n #![feature(question_mark)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(specialization)]\n \n extern crate serialize;\n extern crate term;"}, {"sha": "e307925a6ed83907b03de79f5b25d2b13188b4f2", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -780,17 +780,17 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n                 attr::ReprAny | attr::ReprPacked | attr::ReprSimd => continue,\n                 attr::ReprExtern => \"i32\",\n \n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::Is)) => \"isize\",\n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I8)) => \"i8\",\n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n-\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::Us)) => \"usize\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::Is)) => \"isize\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I8)) => \"i8\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n+\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::Us)) => \"usize\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n             }\n         }\n     }"}, {"sha": "8c8b4173fe588a3cd54211872a0bec8fc09b9d08", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -28,6 +28,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n+#![feature(specialization)]\n \n use std::cell::{Cell, RefCell};\n use std::ops::{Add, Sub};\n@@ -137,8 +138,8 @@ pub struct SpanLabel {\n     pub label: Option<String>,\n }\n \n-impl Encodable for Span {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl serialize::UseSpecializedEncodable for Span {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"Span\", 2, |s| {\n             s.emit_struct_field(\"lo\", 0, |s| {\n                 self.lo.encode(s)\n@@ -151,17 +152,11 @@ impl Encodable for Span {\n     }\n }\n \n-impl Decodable for Span {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n+impl serialize::UseSpecializedDecodable for Span {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n         d.read_struct(\"Span\", 2, |d| {\n-            let lo = d.read_struct_field(\"lo\", 0, |d| {\n-                BytePos::decode(d)\n-            })?;\n-\n-            let hi = d.read_struct_field(\"hi\", 1, |d| {\n-                BytePos::decode(d)\n-            })?;\n-\n+            let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n+            let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n             Ok(mk_sp(lo, hi))\n         })\n     }"}, {"sha": "69e3eab22e91291cf1e2305ca1c5ca57ec9d575a", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -50,14 +50,6 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rbml\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"log 0.0.0\",\n- \"serialize 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc\"\n version = \"0.0.0\"\n@@ -67,7 +59,6 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.0.0\",\n- \"rbml 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -185,7 +176,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.0.0\",\n- \"rbml 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -227,10 +217,8 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n  \"log 0.0.0\",\n- \"rbml 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n- \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "ad466671cf79bb540fbb48f03c73b9ea0f1a8c98", "filename": "src/test/codegen-units/item-collection/instantiation-through-vtable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -31,6 +31,7 @@ impl<T> Trait for Struct<T> {\n fn main() {\n     let s1 = Struct { _a: 0u32 };\n \n+    //~ TRANS_ITEM drop-glue i8\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u32>\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u32>\n     let _ = &s1 as &Trait;"}, {"sha": "cd4cc258f7a682edbbaa4a30cfa263fa55d670f3", "filename": "src/test/codegen-units/item-collection/unsizing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -57,6 +57,7 @@ fn main()\n {\n     // simple case\n     let bool_sized = &true;\n+    //~ TRANS_ITEM drop-glue i8\n     //~ TRANS_ITEM fn unsizing::{{impl}}[0]::foo[0]\n     let _bool_unsized = bool_sized as &Trait;\n "}, {"sha": "0007eaae2897185c3dcff2c21b0a02921534dc3d", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -69,6 +69,7 @@ mod mod1 {\n \n //~ TRANS_ITEM fn vtable_through_const::main[0] @@ vtable_through_const[External]\n fn main() {\n+    //~ TRANS_ITEM drop-glue i8 @@ vtable_through_const[Internal]\n \n     // Since Trait1::do_something() is instantiated via its default implementation,\n     // it is considered a generic and is instantiated here only because it is"}, {"sha": "205566e4b1f54afda5d78bae232873894c9440b8", "filename": "src/test/compile-fail/auxiliary/issue_19452_aux.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue_19452_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue_19452_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue_19452_aux.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub enum Homura {\n+    Madoka { age: u32 }\n+}"}, {"sha": "34872b7c8c503edbb0e9521674e34f18f594b3b1", "filename": "src/test/compile-fail/issue-19452.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcompile-fail%2Fissue-19452.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Fcompile-fail%2Fissue-19452.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19452.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// aux-build:issue_19452_aux.rs\n+extern crate issue_19452_aux;\n+\n enum Homura {\n     Madoka { age: u32 }\n }\n@@ -16,4 +19,8 @@ fn main() {\n     let homura = Homura::Madoka;\n     //~^ ERROR uses it like a function\n     //~| struct called like a function\n+\n+    let homura = issue_19452_aux::Homura::Madoka;\n+    //~^ ERROR uses it like a function\n+    //~| struct called like a function\n }"}, {"sha": "914e3dd4932488b7f8c3dbb49e58b50e4a83c3aa", "filename": "src/test/run-pass-fulldeps/issue-11881.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -11,7 +11,6 @@\n \n #![feature(rustc_private)]\n \n-extern crate rbml;\n extern crate serialize;\n \n use std::io::Cursor;\n@@ -21,8 +20,7 @@ use std::slice;\n \n use serialize::{Encodable, Encoder};\n use serialize::json;\n-\n-use rbml::writer;\n+use serialize::opaque;\n \n #[derive(Encodable)]\n struct Foo {\n@@ -36,15 +34,15 @@ struct Bar {\n \n enum WireProtocol {\n     JSON,\n-    RBML,\n+    Opaque,\n     // ...\n }\n \n fn encode_json<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n     write!(wr, \"{}\", json::as_json(val));\n }\n-fn encode_rbml<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n-    let mut encoder = writer::Encoder::new(wr);\n+fn encode_opaque<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n+    let mut encoder = opaque::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n \n@@ -54,6 +52,6 @@ pub fn main() {\n     let proto = WireProtocol::JSON;\n     match proto {\n         WireProtocol::JSON => encode_json(&target, &mut wr),\n-        WireProtocol::RBML => encode_rbml(&target, &mut wr)\n+        WireProtocol::Opaque => encode_opaque(&target, &mut wr)\n     }\n }"}, {"sha": "cf7fdd7f983f0e545d1851629925d84459fa0c4d", "filename": "src/test/run-pass/auxiliary/issue-17718-aux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-17718-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-17718-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-17718-aux.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -14,11 +14,10 @@ use std::sync::atomic;\n \n pub const C1: usize = 1;\n pub const C2: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n-pub const C3: fn() = foo;\n+pub const C3: fn() = { fn foo() {} foo };\n pub const C4: usize = C1 * C1 + C1 / C1;\n pub const C5: &'static usize = &C4;\n \n pub static S1: usize = 3;\n pub static S2: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n \n-fn foo() {}"}, {"sha": "54d5415a5539b6e952803c7c597434da22e3c054", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf592fa40ca4104b59b867817881ca056f408ad/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=1cf592fa40ca4104b59b867817881ca056f408ad", "patch": "@@ -87,4 +87,8 @@ pub fn main() {\n     assert_eq!(other1::id_u32_iterator(), other2::id_u32_iterator());\n     assert!(other1::id_i32_iterator() != other1::id_u32_iterator());\n     assert!(TypeId::of::<other1::I32Iterator>() != TypeId::of::<other1::U32Iterator>());\n+\n+    // Check fn pointer against collisions\n+    assert!(TypeId::of::<fn(fn(A) -> A) -> A>() !=\n+            TypeId::of::<fn(fn() -> A, A) -> A>());\n }"}]}