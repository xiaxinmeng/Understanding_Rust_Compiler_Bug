{"sha": "f5e2f731785029c2fa50f590f41ff14f5e83299d", "node_id": "C_kwDOAAsO6NoAKGY1ZTJmNzMxNzg1MDI5YzJmYTUwZjU5MGY0MWZmMTRmNWU4MzI5OWQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-01T09:04:33Z"}, "committer": {"name": "Christian Poveda", "email": "git@pvdrz.com", "date": "2022-09-13T20:16:40Z"}, "message": "move clock stuff to separate file", "tree": {"sha": "4c93f940ecb0572e9612151305b683fae72f0b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c93f940ecb0572e9612151305b683fae72f0b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5e2f731785029c2fa50f590f41ff14f5e83299d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCYyDlKAAKCRAnUl7150IK\nUApTAPwMQSeYGLet3pcazsZ8r4C45gFhC2Rq6P+lkXj+4sNgiwEApV/AXWZQIiif\nuBBZKPWYRYqAPSV+9W9i+MavCQU4UAk=\n=JTdl\n-----END PGP SIGNATURE-----", "payload": "tree 4c93f940ecb0572e9612151305b683fae72f0b53\nparent ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e\nauthor Ralf Jung <post@ralfj.de> 1662023073 +0200\ncommitter Christian Poveda <git@pvdrz.com> 1663100200 -0500\n\nmove clock stuff to separate file\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e2f731785029c2fa50f590f41ff14f5e83299d", "html_url": "https://github.com/rust-lang/rust/commit/f5e2f731785029c2fa50f590f41ff14f5e83299d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5e2f731785029c2fa50f590f41ff14f5e83299d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e", "html_url": "https://github.com/rust-lang/rust/commit/ad69e0b36aa7f7c1eaf85bf9657372feaffcfe4e"}], "stats": {"total": 303, "additions": 154, "deletions": 149}, "files": [{"sha": "faf2d7fda6c4b9d133212f6197a7bf3a5326ade5", "filename": "src/clock.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fclock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fclock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclock.rs?ref=f5e2f731785029c2fa50f590f41ff14f5e83299d", "patch": "@@ -0,0 +1,131 @@\n+use std::sync::atomic::AtomicU64;\n+use std::time::{Duration, Instant as StdInstant};\n+\n+use rustc_data_structures::sync::Ordering;\n+\n+use crate::*;\n+\n+/// When using a virtual clock, this defines how many nanoseconds do we pretend\n+/// are passing for each basic block.\n+const NANOSECOND_PER_BASIC_BLOCK: u64 = 10;\n+\n+#[derive(Debug)]\n+pub struct Instant {\n+    kind: InstantKind,\n+}\n+\n+#[derive(Debug)]\n+enum InstantKind {\n+    Host(StdInstant),\n+    Virtual { nanoseconds: u64 },\n+}\n+\n+/// A monotone clock used for `Instant` simulation.\n+#[derive(Debug)]\n+pub struct Clock {\n+    kind: ClockKind,\n+}\n+\n+#[derive(Debug)]\n+enum ClockKind {\n+    Host {\n+        /// The \"time anchor\" for this machine's monotone clock.\n+        time_anchor: StdInstant,\n+    },\n+    Virtual {\n+        /// The \"current virtual time\".\n+        nanoseconds: AtomicU64,\n+    },\n+}\n+\n+impl Clock {\n+    /// Create a new clock based on the availability of communication with the host.\n+    pub fn new(communicate: bool) -> Self {\n+        let kind = if communicate {\n+            ClockKind::Host { time_anchor: StdInstant::now() }\n+        } else {\n+            ClockKind::Virtual { nanoseconds: 0.into() }\n+        };\n+\n+        Self { kind }\n+    }\n+\n+    /// Get the current time relative to this clock.\n+    pub fn get(&self) -> Duration {\n+        match &self.kind {\n+            ClockKind::Host { time_anchor } =>\n+                StdInstant::now().saturating_duration_since(*time_anchor),\n+            ClockKind::Virtual { nanoseconds } =>\n+                Duration::from_nanos(nanoseconds.load(Ordering::Relaxed)),\n+        }\n+    }\n+\n+    /// Let the time pass for a small interval.\n+    pub fn tick(&self) {\n+        match &self.kind {\n+            ClockKind::Host { .. } => {\n+                // Time will pass without us doing anything.\n+            }\n+            ClockKind::Virtual { nanoseconds } => {\n+                nanoseconds.fetch_add(NANOSECOND_PER_BASIC_BLOCK, Ordering::Relaxed);\n+            }\n+        }\n+    }\n+\n+    /// Sleep for the desired duration.\n+    pub fn sleep(&self, duration: Duration) {\n+        match &self.kind {\n+            ClockKind::Host { .. } => std::thread::sleep(duration),\n+            ClockKind::Virtual { nanoseconds } => {\n+                // Just pretend that we have slept for some time.\n+                nanoseconds.fetch_add(duration.as_nanos().try_into().unwrap(), Ordering::Relaxed);\n+            }\n+        }\n+    }\n+\n+    /// Compute `now + duration` relative to this clock.\n+    pub fn get_time_relative(&self, duration: Duration) -> Option<Instant> {\n+        match &self.kind {\n+            ClockKind::Host { .. } =>\n+                StdInstant::now()\n+                    .checked_add(duration)\n+                    .map(|instant| Instant { kind: InstantKind::Host(instant) }),\n+            ClockKind::Virtual { nanoseconds } =>\n+                nanoseconds\n+                    .load(Ordering::Relaxed)\n+                    .checked_add(duration.as_nanos().try_into().unwrap())\n+                    .map(|nanoseconds| Instant { kind: InstantKind::Virtual { nanoseconds } }),\n+        }\n+    }\n+\n+    /// Compute `start + duration` relative to this clock where `start` is the instant of time when\n+    /// this clock was created.\n+    pub fn get_time_absolute(&self, duration: Duration) -> Option<Instant> {\n+        match &self.kind {\n+            ClockKind::Host { time_anchor } =>\n+                time_anchor\n+                    .checked_add(duration)\n+                    .map(|instant| Instant { kind: InstantKind::Host(instant) }),\n+            ClockKind::Virtual { .. } =>\n+                Some(Instant {\n+                    kind: InstantKind::Virtual {\n+                        nanoseconds: duration.as_nanos().try_into().unwrap(),\n+                    },\n+                }),\n+        }\n+    }\n+\n+    /// Returns the duration until the given instant.\n+    pub fn duration_until(&self, instant: &Instant) -> Duration {\n+        match (&instant.kind, &self.kind) {\n+            (InstantKind::Host(instant), ClockKind::Host { .. }) =>\n+                instant.saturating_duration_since(StdInstant::now()),\n+            (\n+                InstantKind::Virtual { nanoseconds },\n+                ClockKind::Virtual { nanoseconds: current_ns },\n+            ) =>\n+                Duration::from_nanos(nanoseconds.saturating_sub(current_ns.load(Ordering::Relaxed))),\n+            _ => panic!(),\n+        }\n+    }\n+}"}, {"sha": "b39a671684801e0c8c0c76787f5119a76dd15189", "filename": "src/concurrency/thread.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fthread.rs?ref=f5e2f731785029c2fa50f590f41ff14f5e83299d", "patch": "@@ -16,7 +16,6 @@ use rustc_target::spec::abi::Abi;\n \n use crate::concurrency::data_race;\n use crate::concurrency::sync::SynchronizationState;\n-use crate::shims::time::{Clock, Instant};\n use crate::*;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n@@ -188,6 +187,17 @@ pub enum Time {\n     RealTime(SystemTime),\n }\n \n+impl Time {\n+    /// How long do we have to wait from now until the specified time?\n+    fn get_wait_time(&self, clock: &Clock) -> Duration {\n+        match self {\n+            Time::Monotonic(instant) => clock.duration_until(instant),\n+            Time::RealTime(time) =>\n+                time.duration_since(SystemTime::now()).unwrap_or(Duration::new(0, 0)),\n+        }\n+    }\n+}\n+\n /// Callbacks are used to implement timeouts. For example, waiting on a\n /// conditional variable with a timeout creates a callback that is called after\n /// the specified time and unblocks the thread. If another thread signals on the\n@@ -489,7 +499,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         for thread in self.threads.indices() {\n             match self.timeout_callbacks.entry(thread) {\n                 Entry::Occupied(entry) =>\n-                    if clock.get_wait_time(&entry.get().call_time) == Duration::new(0, 0) {\n+                    if entry.get().call_time.get_wait_time(clock) == Duration::new(0, 0) {\n                         return Some((thread, entry.remove().callback));\n                     },\n                 Entry::Vacant(_) => {}\n@@ -573,7 +583,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         // at the time of the call\".\n         // <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html>\n         let potential_sleep_time =\n-            self.timeout_callbacks.values().map(|info| clock.get_wait_time(&info.call_time)).min();\n+            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time(clock)).min();\n         if potential_sleep_time == Some(Duration::new(0, 0)) {\n             return Ok(SchedulingAction::ExecuteTimeoutCallback);\n         }"}, {"sha": "016ed01f4dac28bd2ec4ec88da97797f39087f5f", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f5e2f731785029c2fa50f590f41ff14f5e83299d", "patch": "@@ -51,6 +51,7 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n \n+mod clock;\n mod concurrency;\n mod diagnostics;\n mod eval;\n@@ -81,6 +82,7 @@ pub use crate::shims::time::EvalContextExt as _;\n pub use crate::shims::tls::{EvalContextExt as _, TlsData};\n pub use crate::shims::EvalContextExt as _;\n \n+pub use crate::clock::{Clock, Instant};\n pub use crate::concurrency::{\n     data_race::{\n         AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n@@ -89,7 +91,7 @@ pub use crate::concurrency::{\n     sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId},\n     thread::{\n         EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager,\n-        ThreadState,\n+        ThreadState, Time,\n     },\n };\n pub use crate::diagnostics::{"}, {"sha": "4cfedd3bdf425a841b7e43fbe30badb3c04fc168", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=f5e2f731785029c2fa50f590f41ff14f5e83299d", "patch": "@@ -27,7 +27,7 @@ use rustc_target::spec::abi::Abi;\n \n use crate::{\n     concurrency::{data_race, weak_memory},\n-    shims::{time::Clock, unix::FileHandler},\n+    shims::unix::FileHandler,\n     *,\n };\n "}, {"sha": "46164e478f82c44c6af7bf97b86fddb97d2812ab", "filename": "src/shims/time.rs", "status": "modified", "additions": 3, "deletions": 141, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=f5e2f731785029c2fa50f590f41ff14f5e83299d", "patch": "@@ -1,145 +1,7 @@\n-use std::sync::atomic::AtomicU64;\n-use std::time::{Duration, Instant as StdInstant, SystemTime};\n+use std::time::{Duration, SystemTime};\n \n-use rustc_data_structures::sync::Ordering;\n-\n-use crate::concurrency::thread::Time;\n use crate::*;\n \n-/// When using a virtual clock, this defines how many nanoseconds do we pretend\n-/// are passing for each basic block.\n-const NANOSECOND_PER_BASIC_BLOCK: u64 = 10;\n-\n-#[derive(Debug)]\n-pub struct Instant {\n-    kind: InstantKind,\n-}\n-\n-#[derive(Debug)]\n-enum InstantKind {\n-    Host(StdInstant),\n-    Virtual { nanoseconds: u64 },\n-}\n-\n-/// A monotone clock used for `Instant` simulation.\n-#[derive(Debug)]\n-pub struct Clock {\n-    kind: ClockKind,\n-}\n-\n-#[derive(Debug)]\n-enum ClockKind {\n-    Host {\n-        /// The \"time anchor\" for this machine's monotone clock.\n-        time_anchor: StdInstant,\n-    },\n-    Virtual {\n-        /// The \"current virtual time\".\n-        nanoseconds: AtomicU64,\n-    },\n-}\n-\n-impl Clock {\n-    /// Create a new clock based on the availability of communication with the host.\n-    pub fn new(communicate: bool) -> Self {\n-        let kind = if communicate {\n-            ClockKind::Host { time_anchor: StdInstant::now() }\n-        } else {\n-            ClockKind::Virtual { nanoseconds: 0.into() }\n-        };\n-\n-        Self { kind }\n-    }\n-\n-    /// Get the current time relative to this clock.\n-    pub fn get(&self) -> Duration {\n-        match &self.kind {\n-            ClockKind::Host { time_anchor } =>\n-                StdInstant::now().saturating_duration_since(*time_anchor),\n-            ClockKind::Virtual { nanoseconds } =>\n-                Duration::from_nanos(nanoseconds.load(Ordering::Relaxed)),\n-        }\n-    }\n-\n-    /// Let the time pass for a small interval.\n-    pub fn tick(&self) {\n-        match &self.kind {\n-            ClockKind::Host { .. } => {\n-                // Time will pass without us doing anything.\n-            }\n-            ClockKind::Virtual { nanoseconds } => {\n-                nanoseconds.fetch_add(NANOSECOND_PER_BASIC_BLOCK, Ordering::Relaxed);\n-            }\n-        }\n-    }\n-\n-    /// Sleep for the desired duration.\n-    pub fn sleep(&self, duration: Duration) {\n-        match &self.kind {\n-            ClockKind::Host { .. } => std::thread::sleep(duration),\n-            ClockKind::Virtual { nanoseconds } => {\n-                // Just pretend that we have slept for some time.\n-                nanoseconds.fetch_add(duration.as_nanos().try_into().unwrap(), Ordering::Relaxed);\n-            }\n-        }\n-    }\n-\n-    /// Compute `now + duration` relative to this clock.\n-    pub fn get_time_relative(&self, duration: Duration) -> Option<Time> {\n-        match &self.kind {\n-            ClockKind::Host { .. } =>\n-                StdInstant::now()\n-                    .checked_add(duration)\n-                    .map(|instant| Time::Monotonic(Instant { kind: InstantKind::Host(instant) })),\n-            ClockKind::Virtual { nanoseconds } =>\n-                nanoseconds\n-                    .load(Ordering::Relaxed)\n-                    .checked_add(duration.as_nanos().try_into().unwrap())\n-                    .map(|nanoseconds| {\n-                        Time::Monotonic(Instant { kind: InstantKind::Virtual { nanoseconds } })\n-                    }),\n-        }\n-    }\n-\n-    /// Compute `start + duration` relative to this clock where `start` is the instant of time when\n-    /// this clock was created.\n-    pub fn get_time_absolute(&self, duration: Duration) -> Option<Time> {\n-        match &self.kind {\n-            ClockKind::Host { time_anchor } =>\n-                time_anchor\n-                    .checked_add(duration)\n-                    .map(|instant| Time::Monotonic(Instant { kind: InstantKind::Host(instant) })),\n-            ClockKind::Virtual { .. } =>\n-                Some(Time::Monotonic(Instant {\n-                    kind: InstantKind::Virtual {\n-                        nanoseconds: duration.as_nanos().try_into().unwrap(),\n-                    },\n-                })),\n-        }\n-    }\n-\n-    /// How long do we have to wait from now until the specified time?\n-    pub fn get_wait_time(&self, time: &Time) -> Duration {\n-        match time {\n-            Time::Monotonic(instant) =>\n-                match (&instant.kind, &self.kind) {\n-                    (InstantKind::Host(instant), ClockKind::Host { .. }) =>\n-                        instant.saturating_duration_since(StdInstant::now()),\n-                    (\n-                        InstantKind::Virtual { nanoseconds },\n-                        ClockKind::Virtual { nanoseconds: current_ns },\n-                    ) =>\n-                        Duration::from_nanos(\n-                            nanoseconds.saturating_sub(current_ns.load(Ordering::Relaxed)),\n-                        ),\n-                    _ => panic!(),\n-                },\n-            Time::RealTime(time) =>\n-                time.duration_since(SystemTime::now()).unwrap_or(Duration::new(0, 0)),\n-        }\n-    }\n-}\n-\n /// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n pub fn system_time_to_duration<'tcx>(time: &SystemTime) -> InterpResult<'tcx, Duration> {\n     time.duration_since(SystemTime::UNIX_EPOCH)\n@@ -354,7 +216,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.register_timeout_callback(\n             active_thread,\n-            timeout_time,\n+            Time::Monotonic(timeout_time),\n             Box::new(move |ecx| {\n                 ecx.unblock_thread(active_thread);\n                 Ok(())\n@@ -380,7 +242,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.register_timeout_callback(\n             active_thread,\n-            timeout_time,\n+            Time::Monotonic(timeout_time),\n             Box::new(move |ecx| {\n                 ecx.unblock_thread(active_thread);\n                 Ok(())"}, {"sha": "b2c2fa14d52f5594af6a92ff2093009dfe8a9c92", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=f5e2f731785029c2fa50f590f41ff14f5e83299d", "patch": "@@ -106,14 +106,14 @@ pub fn futex<'tcx>(\n                     if op & futex_realtime != 0 {\n                         Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n                     } else {\n-                        this.machine.clock.get_time_absolute(duration).unwrap()\n+                        Time::Monotonic(this.machine.clock.get_time_absolute(duration).unwrap())\n                     }\n                 } else {\n                     // FUTEX_WAIT uses a relative timestamp.\n                     if op & futex_realtime != 0 {\n                         Time::RealTime(SystemTime::now().checked_add(duration).unwrap())\n                     } else {\n-                        this.machine.clock.get_time_relative(duration).unwrap()\n+                        Time::Monotonic(this.machine.clock.get_time_relative(duration).unwrap())\n                     }\n                 })\n             };"}, {"sha": "446293e03cb1dbd5aa41d6c1289f259858931e01", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e2f731785029c2fa50f590f41ff14f5e83299d/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=f5e2f731785029c2fa50f590f41ff14f5e83299d", "patch": "@@ -840,7 +840,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n             Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n         } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n-            this.machine.clock.get_time_absolute(duration).unwrap()\n+            Time::Monotonic(this.machine.clock.get_time_absolute(duration).unwrap())\n         } else {\n             throw_unsup_format!(\"unsupported clock id: {}\", clock_id);\n         };"}]}