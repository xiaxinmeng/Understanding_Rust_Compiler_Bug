{"sha": "c858eb06546ce2be77fd284f707f76cb820c6211", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NThlYjA2NTQ2Y2UyYmU3N2ZkMjg0ZjcwN2Y3NmNiODIwYzYyMTE=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-17T22:16:09Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-18T00:46:31Z"}, "message": "Modernize bitv somewhat", "tree": {"sha": "e686ec64ed9382443f37f193f1dea69469d3a665", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e686ec64ed9382443f37f193f1dea69469d3a665"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c858eb06546ce2be77fd284f707f76cb820c6211", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c858eb06546ce2be77fd284f707f76cb820c6211", "html_url": "https://github.com/rust-lang/rust/commit/c858eb06546ce2be77fd284f707f76cb820c6211", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c858eb06546ce2be77fd284f707f76cb820c6211/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee855caa5df4a9224aaf7b4ab5f644d3ef071f1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee855caa5df4a9224aaf7b4ab5f644d3ef071f1b", "html_url": "https://github.com/rust-lang/rust/commit/ee855caa5df4a9224aaf7b4ab5f644d3ef071f1b"}], "stats": {"total": 61, "additions": 41, "deletions": 20}, "files": [{"sha": "74dadc556ebc2cb085d10eb1c84d969526547c1e", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c858eb06546ce2be77fd284f707f76cb820c6211/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c858eb06546ce2be77fd284f707f76cb820c6211/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=c858eb06546ce2be77fd284f707f76cb820c6211", "patch": "@@ -15,16 +15,20 @@ export is_false;\n export to_vec;\n export to_str;\n export eq_vec;\n+export methods;\n \n // FIXME (#2341): With recursive object types, we could implement binary\n // methods like union, intersection, and difference. At that point, we could\n // write an optimizing version of this module that produces a different obj\n // for the case where nbits <= 32.\n \n /// The bitvector type\n-type bitv = @{storage: ~[mut uint], nbits: uint};\n+type bitv = {storage: ~[mut uint], nbits: uint};\n \n-const uint_bits: uint = 32u + (1u << 32u >> 27u);\n+#[cfg(target_arch=\"x86\")]\n+const uint_bits: uint = 32;\n+#[cfg(target_arch=\"x86_64\")]\n+const uint_bits: uint = 64;\n \n /**\n  * Constructs a bitvector\n@@ -37,7 +41,7 @@ const uint_bits: uint = 32u + (1u << 32u >> 27u);\n fn bitv(nbits: uint, init: bool) -> bitv {\n     let elt = if init { !0u } else { 0u };\n     let storage = vec::to_mut(vec::from_elem(nbits / uint_bits + 1u, elt));\n-    ret @{storage: storage, nbits: nbits};\n+    ret {storage: storage, nbits: nbits};\n }\n \n fn process(v0: bitv, v1: bitv, op: fn(uint, uint) -> uint) -> bool {\n@@ -55,23 +59,24 @@ fn process(v0: bitv, v1: bitv, op: fn(uint, uint) -> uint) -> bool {\n }\n \n \n-fn lor(w0: uint, w1: uint) -> uint { ret w0 | w1; }\n-\n+/**\n+ * Calculates the union of two bitvectors\n+ *\n+ * Sets `v0` to the union of `v0` and `v1`. Both bitvectors must be the\n+ * same length. Returns 'true' if `v0` was changed.\n+ */\n fn union(v0: bitv, v1: bitv) -> bool {\n-    let sub = lor; ret process(v0, v1, sub);\n+    process(v0, v1, |a, b| a | b)\n }\n \n-fn land(w0: uint, w1: uint) -> uint { ret w0 & w1; }\n-\n /**\n  * Calculates the intersection of two bitvectors\n  *\n  * Sets `v0` to the intersection of `v0` and `v1`. Both bitvectors must be the\n  * same length. Returns 'true' if `v0` was changed.\n  */\n fn intersect(v0: bitv, v1: bitv) -> bool {\n-    let sub = land;\n-    ret process(v0, v1, sub);\n+    process(v0, v1, |a, b| a & b)\n }\n \n fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n@@ -87,10 +92,7 @@ fn assign(v0: bitv, v1: bitv) -> bool {\n \n /// Makes a copy of a bitvector\n fn clone(v: bitv) -> bitv {\n-    let storage = vec::to_mut(vec::from_elem(v.nbits / uint_bits + 1u, 0u));\n-    let len = vec::len(v.storage);\n-    for uint::range(0u, len) |i| { storage[i] = v.storage[i]; };\n-    ret @{storage: storage, nbits: v.nbits};\n+    copy v\n }\n \n /// Retrieve the value at index `i`\n@@ -174,18 +176,13 @@ fn is_false(v: bitv) -> bool {\n     ret true;\n }\n \n-fn init_to_vec(v: bitv, i: uint) -> uint {\n-    ret if get(v, i) { 1u } else { 0u };\n-}\n-\n /**\n  * Converts the bitvector to a vector of uint with the same length.\n  *\n  * Each uint in the resulting vector has either value 0u or 1u.\n  */\n fn to_vec(v: bitv) -> ~[uint] {\n-    let sub = |x| init_to_vec(v, x);\n-    ret vec::from_fn::<uint>(v.nbits, sub);\n+    vec::from_fn::<uint>(v.nbits, |i| if get(v, i) { 1 } else { 0 })\n }\n \n #[inline(always)]\n@@ -238,6 +235,30 @@ fn eq_vec(v0: bitv, v1: ~[uint]) -> bool {\n     ret true;\n }\n \n+impl methods for bitv {\n+    fn union(rhs: bitv) -> bool { union(self, rhs) }\n+    fn intersect(rhs: bitv) -> bool { intersect(self, rhs) }\n+    fn assign(rhs: bitv) -> bool { assign(self, rhs) }\n+    fn get(i: uint) -> bool { get(self, i) }\n+    fn [](i: uint) -> bool { self.get(i) }\n+    fn eq(rhs: bitv) -> bool { equal(self, rhs) }\n+    fn clear() { clear(self) }\n+    fn set_all() { set_all(self) }\n+    fn invert() { invert(self) }\n+    fn difference(rhs: bitv) -> bool { difference(self, rhs) }\n+    fn set(i: uint, x: bool) { set(self, i, x) }\n+    fn is_true() -> bool { is_true(self) }\n+    fn is_false() -> bool { is_false(self) }\n+    fn to_vec() -> ~[uint] { to_vec(self) }\n+    fn each(f: fn(bool) -> bool) { each(self, f) }\n+    fn each_storage(f: fn(&uint) -> bool) { each_storage(self, f) }\n+    fn eq_vec(v: ~[uint]) -> bool { eq_vec(self, v) }\n+}\n+\n+impl of to_str::to_str for bitv {\n+    fn to_str() -> ~str { to_str(self) }\n+}\n+\n #[cfg(test)]\n mod tests {\n     #[test]"}]}