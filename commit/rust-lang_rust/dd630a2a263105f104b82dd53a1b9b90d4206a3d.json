{"sha": "dd630a2a263105f104b82dd53a1b9b90d4206a3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNjMwYTJhMjYzMTA1ZjEwNGI4MmRkNTNhMWI5YjkwZDQyMDZhM2Q=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-06T07:39:31Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-06T07:39:31Z"}, "message": "Rename lvalue to place", "tree": {"sha": "04ca0e4e82b240b87ca4228d52fe1203484061ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04ca0e4e82b240b87ca4228d52fe1203484061ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd630a2a263105f104b82dd53a1b9b90d4206a3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd630a2a263105f104b82dd53a1b9b90d4206a3d", "html_url": "https://github.com/rust-lang/rust/commit/dd630a2a263105f104b82dd53a1b9b90d4206a3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd630a2a263105f104b82dd53a1b9b90d4206a3d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf26b96dc7506b2f1fac9265489a6f3cd4d99dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf26b96dc7506b2f1fac9265489a6f3cd4d99dfc", "html_url": "https://github.com/rust-lang/rust/commit/bf26b96dc7506b2f1fac9265489a6f3cd4d99dfc"}], "stats": {"total": 98, "additions": 49, "deletions": 49}, "files": [{"sha": "1d02c979ba74e15bfb412874d1752b0d2fa13e81", "filename": "miri/fn_call.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dd630a2a263105f104b82dd53a1b9b90d4206a3d/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd630a2a263105f104b82dd53a1b9b90d4206a3d/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=dd630a2a263105f104b82dd53a1b9b90d4206a3d", "patch": "@@ -21,7 +21,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         def_id: DefId,\n         args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n+        dest: Place,\n         dest_ty: Ty<'tcx>,\n         dest_block: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n@@ -31,7 +31,7 @@ pub trait EvalContextExt<'tcx> {\n     fn call_missing_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n+        destination: Option<(Place, mir::BasicBlock)>,\n         args: &[ValTy<'tcx>],\n         sig: ty::FnSig<'tcx>,\n         path: String,\n@@ -40,20 +40,20 @@ pub trait EvalContextExt<'tcx> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n+        destination: Option<(Place, mir::BasicBlock)>,\n         args: &[ValTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool>;\n \n-    fn write_null(&mut self, dest: Lvalue, dest_ty: Ty<'tcx>) -> EvalResult<'tcx>;\n+    fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx>;\n }\n \n impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n+        destination: Option<(Place, mir::BasicBlock)>,\n         args: &[ValTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -75,16 +75,16 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             Err(other) => return Err(other),\n         };\n \n-        let (return_lvalue, return_to_block) = match destination {\n-            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n-            None => (Lvalue::undef(), StackPopCleanup::None),\n+        let (return_place, return_to_block) = match destination {\n+            Some((place, block)) => (place, StackPopCleanup::Goto(block)),\n+            None => (Place::undef(), StackPopCleanup::None),\n         };\n \n         self.push_stack_frame(\n             instance,\n             span,\n             mir,\n-            return_lvalue,\n+            return_place,\n             return_to_block,\n         )?;\n \n@@ -95,7 +95,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         &mut self,\n         def_id: DefId,\n         args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n+        dest: Place,\n         dest_ty: Ty<'tcx>,\n         dest_block: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     f_instance,\n                     mir.span,\n                     mir,\n-                    Lvalue::undef(),\n+                    Place::undef(),\n                     StackPopCleanup::Goto(dest_block),\n                 )?;\n                 let mut args = self.frame().mir.args_iter();\n@@ -187,7 +187,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                             .to_owned(),\n                     ),\n                 )?;\n-                let arg_dest = self.eval_lvalue(&mir::Place::Local(arg_local))?;\n+                let arg_dest = self.eval_place(&mir::Place::Local(arg_local))?;\n                 self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n \n                 assert!(args.next().is_none(), \"__rust_maybe_catch_panic argument has more arguments than expected\");\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = args[0].ty.builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                let key_type = args[0].ty.builtin_deref(true, ty::PlacePreference::NoPreference)\n                                    .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n                 let key_size = self.type_layout(key_type)?.size;\n \n@@ -516,7 +516,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n     fn call_missing_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n+        destination: Option<(Place, mir::BasicBlock)>,\n         args: &[ValTy<'tcx>],\n         sig: ty::FnSig<'tcx>,\n         path: String,\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         return Ok(());\n     }\n \n-    fn write_null(&mut self, dest: Lvalue, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n     }\n }"}, {"sha": "0db3f4f2542fa981c929b3f643e47d463a6d204b", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dd630a2a263105f104b82dd53a1b9b90d4206a3d/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd630a2a263105f104b82dd53a1b9b90d4206a3d/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=dd630a2a263105f104b82dd53a1b9b90d4206a3d", "patch": "@@ -3,7 +3,7 @@ use rustc::traits::Reveal;\n use rustc::ty::layout::TyLayout;\n use rustc::ty;\n \n-use rustc::mir::interpret::{EvalResult, Lvalue, LvalueExtra, PrimVal, PrimValKind, Value, Pointer,\n+use rustc::mir::interpret::{EvalResult, Place, PlaceExtra, PrimVal, PrimValKind, Value, Pointer,\n                             HasMemory, AccessKind, EvalContext, PtrAndAlign, ValTy};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n@@ -13,7 +13,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n+        dest: Place,\n         dest_layout: TyLayout<'tcx>,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n@@ -24,7 +24,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n+        dest: Place,\n         dest_layout: TyLayout<'tcx>,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 };\n                 self.write_primval(dest, old, ty)?;\n                 self.write_primval(\n-                    Lvalue::from_primval_ptr(ptr),\n+                    Place::from_primval_ptr(ptr),\n                     change,\n                     ty,\n                 )?;\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 };\n                 self.write_value(valty, dest)?;\n                 self.write_primval(\n-                    Lvalue::from_primval_ptr(ptr),\n+                    Place::from_primval_ptr(ptr),\n                     change,\n                     ty,\n                 )?;\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 };\n                 // FIXME: what do atomics do on overflow?\n                 let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n-                self.write_primval(Lvalue::from_primval_ptr(ptr), val, ty)?;\n+                self.write_primval(Place::from_primval_ptr(ptr), val, ty)?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -240,8 +240,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = args[0].into_ptr(&self.memory)?;\n-                let lval = Lvalue::from_primval_ptr(adt_ptr);\n-                let discr_val = self.read_discriminant_value(lval, ty)?;\n+                let place = Place::from_primval_ptr(adt_ptr);\n+                let discr_val = self.read_discriminant_value(place, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_layout.ty)?;\n             }\n \n@@ -336,12 +336,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     Ok(zero_val)\n                 };\n                 match dest {\n-                    Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n-                    Lvalue::Ptr {\n+                    Place::Local { frame, local } => self.modify_local(frame, local, init)?,\n+                    Place::Ptr {\n                         ptr: PtrAndAlign { ptr, aligned: true },\n-                        extra: LvalueExtra::None,\n+                        extra: PlaceExtra::None,\n                     } => self.memory.write_repeat(ptr, 0, size)?,\n-                    Lvalue::Ptr { .. } => {\n+                    Place::Ptr { .. } => {\n                         bug!(\"init intrinsic tried to write to fat or unaligned ptr target\")\n                     }\n                 }\n@@ -623,12 +623,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     _ => Ok(Value::ByVal(PrimVal::Undef)),\n                 };\n                 match dest {\n-                    Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n-                    Lvalue::Ptr {\n+                    Place::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n+                    Place::Ptr {\n                         ptr: PtrAndAlign { ptr, aligned: true },\n-                        extra: LvalueExtra::None,\n+                        extra: PlaceExtra::None,\n                     } => self.memory.mark_definedness(ptr, size, false)?,\n-                    Lvalue::Ptr { .. } => {\n+                    Place::Ptr { .. } => {\n                         bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\")\n                     }\n                 }"}, {"sha": "399418f6734bcad1c9dfb04ef5fc74c5c284100a", "filename": "miri/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dd630a2a263105f104b82dd53a1b9b90d4206a3d/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd630a2a263105f104b82dd53a1b9b90d4206a3d/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=dd630a2a263105f104b82dd53a1b9b90d4206a3d", "patch": "@@ -79,15 +79,15 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 start_instance,\n                 start_mir.span,\n                 start_mir,\n-                Lvalue::from_ptr(ret_ptr),\n+                Place::from_ptr(ret_ptr),\n                 StackPopCleanup::None,\n             )?;\n \n             let mut args = ecx.frame().mir.args_iter();\n \n             // First argument: pointer to main()\n             let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n-            let dest = ecx.eval_lvalue(&mir::Place::Local(args.next().unwrap()))?;\n+            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n             let main_ty = main_instance.def.def_ty(ecx.tcx);\n             let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n             ecx.write_value(\n@@ -99,13 +99,13 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             )?;\n \n             // Second argument (argc): 1\n-            let dest = ecx.eval_lvalue(&mir::Place::Local(args.next().unwrap()))?;\n+            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n             let ty = ecx.tcx.types.isize;\n             ecx.write_primval(dest, PrimVal::Bytes(1), ty)?;\n \n             // FIXME: extract main source file path\n             // Third argument (argv): &[b\"foo\"]\n-            let dest = ecx.eval_lvalue(&mir::Place::Local(args.next().unwrap()))?;\n+            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n             let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n             let foo = ecx.memory.allocate_cached(b\"foo\\0\");\n             let ptr_size = ecx.memory.pointer_size();\n@@ -120,7 +120,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 main_instance,\n                 main_mir.span,\n                 main_mir,\n-                Lvalue::undef(),\n+                Place::undef(),\n                 StackPopCleanup::None,\n             )?;\n \n@@ -195,7 +195,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n+        destination: Option<(Place, mir::BasicBlock)>,\n         args: &[ValTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -207,7 +207,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ecx: &mut rustc::mir::interpret::EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n+        dest: Place,\n         dest_layout: TyLayout<'tcx>,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n@@ -237,7 +237,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n     fn box_alloc<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         ty: ty::Ty<'tcx>,\n-        dest: Lvalue,\n+        dest: Place,\n     ) -> EvalResult<'tcx> {\n         let size = ecx.type_size(ty)?.expect(\"box only works with sized types\");\n         let align = ecx.type_align(ty)?;\n@@ -261,7 +261,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         let usize = ecx.tcx.types.usize;\n \n         // First argument: size\n-        let dest = ecx.eval_lvalue(&mir::Place::Local(args.next().unwrap()))?;\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_value(\n             ValTy {\n                 value: Value::ByVal(PrimVal::Bytes(size as u128)),\n@@ -271,7 +271,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         )?;\n \n         // Second argument: align\n-        let dest = ecx.eval_lvalue(&mir::Place::Local(args.next().unwrap()))?;\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_value(\n             ValTy {\n                 value: Value::ByVal(PrimVal::Bytes(align as u128)),"}, {"sha": "0a0ba1c03b67200ccabdb6d08a8528b13c44f447", "filename": "miri/tls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd630a2a263105f104b82dd53a1b9b90d4206a3d/miri%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd630a2a263105f104b82dd53a1b9b90d4206a3d/miri%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ftls.rs?ref=dd630a2a263105f104b82dd53a1b9b90d4206a3d", "patch": "@@ -1,6 +1,6 @@\n use rustc::{ty, mir};\n \n-use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Pointer, Memory, Evaluator, Lvalue,\n+use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Pointer, Memory, Evaluator, Place,\n             StackPopCleanup, EvalContext};\n \n pub trait MemoryExt<'tcx> {\n@@ -119,13 +119,13 @@ impl<'a, 'tcx: 'a> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n                 instance,\n                 mir.span,\n                 mir,\n-                Lvalue::undef(),\n+                Place::undef(),\n                 StackPopCleanup::None,\n             )?;\n             let arg_local = self.frame().mir.args_iter().next().ok_or(\n                 EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n             )?;\n-            let dest = self.eval_lvalue(&mir::Place::Local(arg_local))?;\n+            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n             let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n             self.write_ptr(dest, ptr, ty)?;\n "}, {"sha": "27a063de0272aed0f19a1e03d442e4ba4b506c51", "filename": "tex/report/miri-report.tex", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd630a2a263105f104b82dd53a1b9b90d4206a3d/tex%2Freport%2Fmiri-report.tex", "raw_url": "https://github.com/rust-lang/rust/raw/dd630a2a263105f104b82dd53a1b9b90d4206a3d/tex%2Freport%2Fmiri-report.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Fmiri-report.tex?ref=dd630a2a263105f104b82dd53a1b9b90d4206a3d", "patch": "@@ -52,10 +52,10 @@ \\section{Background}\n The Rust compiler generates an instance of \\rust{Mir} for each function [\\autoref{fig:mir}]. Each\n \\rust{Mir} structure represents a control-flow graph for a given function, and contains a list of\n ``basic blocks'' which in turn contain a list of statements followed by a single terminator. Each\n-statement is of the form \\rust{lvalue = rvalue}. An \\rust{Lvalue} is used for referencing variables\n+statement is of the form \\rust{place = rvalue}. An \\rust{Place} is used for referencing variables\n and calculating addresses such as when dereferencing pointers, accessing fields, or indexing arrays.\n An \\rust{Rvalue} represents the core set of operations possible in MIR, including reading a value\n-from an lvalue, performing math operations, creating new pointers, structures, and arrays, and so\n+from an place, performing math operations, creating new pointers, structures, and arrays, and so\n on. Finally, a terminator decides where control will flow next, optionally based on the value of a\n boolean or integer.\n \n@@ -73,7 +73,7 @@ \\section{Background}\n     }\n \n     struct Statement {\n-        lvalue: Lvalue,\n+        place: Place,\n         rvalue: Rvalue\n     }\n \n@@ -99,7 +99,7 @@ \\subsection{Basic operation}\n To investigate the possibility of executing Rust at compile-time I wrote an interpreter for MIR\n called Miri\\footnote{\\url{https://github.com/solson/miri}}. The structure of the interpreter closely\n mirrors the structure of MIR itself. It starts executing a function by iterating the statement list\n-in the starting basic block, translating the lvalue into a pointer and using the rvalue to decide\n+in the starting basic block, translating the place into a pointer and using the rvalue to decide\n what to write into that pointer. Evaluating the rvalue may involve reads (such as for the two sides\n of a binary operation) or construction of new values. When the terminator is reached, it is used to\n decide which basic block to jump to next. Finally, Miri repeats this entire process, reading\n@@ -343,7 +343,7 @@ \\subsection{Aggregates}\n closures. Miri supports all common usage of all of these types. The main missing piece is to handle\n \\texttt{\\#[repr(..)]} annotations which adjust the layout of a \\rust{struct} or \\rust{enum}.\n \n-\\subsection{Lvalue projections}\n+\\subsection{Place projections}\n \n This category includes field accesses, dereferencing, accessing data in an \\rust{enum} variant, and\n indexing arrays. Miri supports all of these, including nested projections such as"}]}