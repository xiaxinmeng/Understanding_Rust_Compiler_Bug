{"sha": "9bc8e6d1472a57441afe3592078838d2bc767996", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYzhlNmQxNDcyYTU3NDQxYWZlMzU5MjA3ODgzOGQyYmM3Njc5OTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-08T04:33:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-08T22:24:23Z"}, "message": "trans: Link rlibs to dylibs with --whole-archive\n\nThis commit starts passing the `--whole-archive` flag (`-force_load` on OSX) to\nthe linker when linking rlibs into dylibs. The primary purpose of this commit is\nto ensure that the linker doesn't strip out objects from an archive when\ncreating a dynamic library. Information on how this can go wrong can be found in\nissues #14344 and #25185.\n\nThe unfortunate part about passing this flag to the linker is that we have to\npreprocess the rlib to remove the metadata and compressed bytecode found within.\nThis means that creating a dylib will now take longer to link as we've got to\ncopy around the input rlibs to a temporary location, modify them, and then\ninvoke the linker. This isn't done for executables, however, so the \"hello\nworld\" compile time is not affected.\n\nThis fix was instigated because of the previous commit where rlibs may not\ncontain multiple object files instead of one due to codegen units being greater\nthan one. That change prevented the main distribution from being compiled with\nmore than one codegen-unit and this commit fixes that.\n\nCloses #14344\nCloses #25185", "tree": {"sha": "07bb476f368f42c89b476671ecc9082175d91b69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07bb476f368f42c89b476671ecc9082175d91b69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bc8e6d1472a57441afe3592078838d2bc767996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8e6d1472a57441afe3592078838d2bc767996", "html_url": "https://github.com/rust-lang/rust/commit/9bc8e6d1472a57441afe3592078838d2bc767996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8e6d1472a57441afe3592078838d2bc767996/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d23239b48e2066d3f38eb03e2429427bffade822", "url": "https://api.github.com/repos/rust-lang/rust/commits/d23239b48e2066d3f38eb03e2429427bffade822", "html_url": "https://github.com/rust-lang/rust/commit/d23239b48e2066d3f38eb03e2429427bffade822"}], "stats": {"total": 358, "additions": 229, "deletions": 129}, "files": [{"sha": "905012bbb64d851e8deda1eeb03fee3641024311", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -148,4 +148,5 @@ pub fn oom() -> ! {\n //                optimize it out).\n #[doc(hidden)]\n #[unstable(feature = \"issue_14344_fixme\")]\n+#[cfg(stage0)]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}"}, {"sha": "3c90a2c54e128fc4bb552cfd2ab3ecf5810afe07", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -138,6 +138,7 @@ pub mod btree_set {\n // FIXME(#14344) this shouldn't be necessary\n #[doc(hidden)]\n #[unstable(feature = \"issue_14344_fixme\")]\n+#[cfg(stage0)]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}\n \n #[cfg(not(test))]"}, {"sha": "102894bec133ed46ecc163f3e08610cea895c70a", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -6431,6 +6431,7 @@ pub mod funcs {\n }\n \n #[doc(hidden)]\n+#[cfg(stage0)]\n pub fn issue_14344_workaround() {} // FIXME #14344 force linkage to happen correctly\n \n #[test] fn work_on_windows() { } // FIXME #10872 needed for a happy windows"}, {"sha": "a9e9f17bdce75e31170e6b392c4097cf21f3a110", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -2136,11 +2136,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     let mut rbml_w = Encoder::new(wr);\n \n     encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name);\n-    encode_crate_triple(&mut rbml_w,\n-                        &tcx.sess\n-                           .opts\n-                           .target_triple\n-                           );\n+    encode_crate_triple(&mut rbml_w, &tcx.sess.opts.target_triple);\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n "}, {"sha": "9541076df82be575eb3e80b12858558ca25bc949", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -804,8 +804,8 @@ fn write_out_deps(sess: &Session,\n         match *output_type {\n             config::OutputTypeExe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output,\n-                                                     id, &file);\n+                    let p = link::filename_for_input(sess, *output, id,\n+                                                     outputs);\n                     out_filenames.push(p);\n                 }\n             }"}, {"sha": "282971daa28369d6df9143274ac4d8f15c73733a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -452,10 +452,8 @@ impl RustcDefaultCalls {\n                     let metadata = driver::collect_crate_metadata(sess, attrs);\n                     *sess.crate_metadata.borrow_mut() = metadata;\n                     for &style in &crate_types {\n-                        let fname = link::filename_for_input(sess,\n-                                                             style,\n-                                                             &id,\n-                                                             &t_outputs.with_extension(\"\"));\n+                        let fname = link::filename_for_input(sess, style, &id,\n+                                                             &t_outputs);\n                         println!(\"{}\", fname.file_name().unwrap()\n                                             .to_string_lossy());\n                     }"}, {"sha": "21bc61593c9cdbf451fadcb726ba0277e753be5d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 94, "deletions": 86, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -464,26 +464,25 @@ fn is_writeable(p: &Path) -> bool {\n \n pub fn filename_for_input(sess: &Session,\n                           crate_type: config::CrateType,\n-                          name: &str,\n-                          out_filename: &Path) -> PathBuf {\n-    let libname = format!(\"{}{}\", name, sess.opts.cg.extra_filename);\n+                          crate_name: &str,\n+                          outputs: &OutputFilenames) -> PathBuf {\n+    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n     match crate_type {\n         config::CrateTypeRlib => {\n-            out_filename.with_file_name(&format!(\"lib{}.rlib\", libname))\n+            outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n             let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n                                     &sess.target.target.options.dll_suffix);\n-            out_filename.with_file_name(&format!(\"{}{}{}\",\n-                                                  prefix,\n-                                                 libname,\n-                                                 suffix))\n+            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n+                                                suffix))\n         }\n         config::CrateTypeStaticlib => {\n-            out_filename.with_file_name(&format!(\"lib{}.a\", libname))\n+            outputs.out_directory.join(&format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n             let suffix = &sess.target.target.options.exe_suffix;\n+            let out_filename = outputs.path(OutputTypeExe);\n             if suffix.is_empty() {\n                 out_filename.to_path_buf()\n             } else {\n@@ -501,10 +500,7 @@ fn link_binary_output(sess: &Session,\n     let objects = object_filenames(sess, outputs);\n     let out_filename = match outputs.single_output_file {\n         Some(ref file) => file.clone(),\n-        None => {\n-            let out_filename = outputs.path(OutputTypeExe);\n-            filename_for_input(sess, crate_type, crate_name, &out_filename)\n-        }\n+        None => filename_for_input(sess, crate_type, crate_name, outputs),\n     };\n \n     // Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n@@ -551,6 +547,19 @@ fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     return search;\n }\n \n+fn archive_config<'a>(sess: &'a Session,\n+                      output: &Path) -> ArchiveConfig<'a> {\n+    ArchiveConfig {\n+        handler: &sess.diagnostic().handler,\n+        dst: output.to_path_buf(),\n+        lib_search_paths: archive_search_paths(sess),\n+        slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n+        slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n+        ar_prog: get_ar_prog(sess),\n+        command_path: command_path(sess),\n+    }\n+}\n+\n // Create an 'rlib'\n //\n // An rlib in its current incarnation is essentially a renamed .a file. The\n@@ -562,17 +571,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                  objects: &[PathBuf],\n                  out_filename: &Path) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib from {:?} to {:?}\", objects, out_filename);\n-    let handler = &sess.diagnostic().handler;\n-    let config = ArchiveConfig {\n-        handler: handler,\n-        dst: out_filename.to_path_buf(),\n-        lib_search_paths: archive_search_paths(sess),\n-        slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n-        slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n-        ar_prog: get_ar_prog(sess),\n-        command_path: command_path(sess),\n-    };\n-    let mut ab = ArchiveBuilder::create(config);\n+    let mut ab = ArchiveBuilder::create(archive_config(sess, out_filename));\n     for obj in objects {\n         ab.add_file(obj).unwrap();\n     }\n@@ -1131,7 +1130,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n                 add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n             }\n             cstore::RequireStatic => {\n-                add_static_crate(cmd, sess, tmpdir, &src.rlib.unwrap().0)\n+                add_static_crate(cmd, sess, tmpdir, dylib, &src.rlib.unwrap().0)\n             }\n         }\n \n@@ -1147,71 +1146,80 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n+    // There's a bit of magic which happens here specifically related to LTO and\n+    // dynamic libraries. Specifically:\n+    //\n+    // * For LTO, we remove upstream object files.\n+    // * For dylibs we remove metadata and bytecode from upstream rlibs\n+    //\n+    // When performing LTO, all of the bytecode from the upstream libraries has\n+    // already been included in our object file output. As a result we need to\n+    // remove the object files in the upstream libraries so the linker doesn't\n+    // try to include them twice (or whine about duplicate symbols). We must\n+    // continue to include the rest of the rlib, however, as it may contain\n+    // static native libraries which must be linked in.\n+    //\n+    // When making a dynamic library, linkers by default don't include any\n+    // object files in an archive if they're not necessary to resolve the link.\n+    // We basically want to convert the archive (rlib) to a dylib, though, so we\n+    // *do* want everything included in the output, regardless of whether the\n+    // linker thinks it's needed or not. As a result we must use the\n+    // --whole-archive option (or the platform equivalent). When using this\n+    // option the linker will fail if there are non-objects in the archive (such\n+    // as our own metadata and/or bytecode). All in all, for rlibs to be\n+    // entirely included in dylibs, we need to remove all non-object files.\n+    //\n+    // Note, however, that if we're not doing LTO or we're not producing a dylib\n+    // (aka we're making an executable), we can just pass the rlib blindly to\n+    // the linker (fast) because it's fine if it's not actually included as\n+    // we're at the end of the dependency chain.\n     fn add_static_crate(cmd: &mut Linker, sess: &Session, tmpdir: &Path,\n-                        cratepath: &Path) {\n-        // When performing LTO on an executable output, all of the\n-        // bytecode from the upstream libraries has already been\n-        // included in our object file output. We need to modify all of\n-        // the upstream archives to remove their corresponding object\n-        // file to make sure we don't pull the same code in twice.\n-        //\n-        // We must continue to link to the upstream archives to be sure\n-        // to pull in native static dependencies. As the final caveat,\n-        // on Linux it is apparently illegal to link to a blank archive,\n-        // so if an archive no longer has any object files in it after\n-        // we remove `lib.o`, then don't link against it at all.\n-        //\n-        // If we're not doing LTO, then our job is simply to just link\n-        // against the archive.\n-        if sess.lto() {\n-            let name = cratepath.file_name().unwrap().to_str().unwrap();\n-            let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-            time(sess.time_passes(),\n-                 &format!(\"altering {}.rlib\", name),\n-                 (), |()| {\n-                let dst = tmpdir.join(cratepath.file_name().unwrap());\n-                match fs::copy(&cratepath, &dst) {\n-                    Ok(..) => {}\n-                    Err(e) => {\n-                        sess.fatal(&format!(\"failed to copy {} to {}: {}\",\n-                                            cratepath.display(),\n-                                            dst.display(), e));\n-                    }\n+                        dylib: bool, cratepath: &Path) {\n+        if !sess.lto() && !dylib {\n+            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n+            return\n+        }\n+\n+        let dst = tmpdir.join(cratepath.file_name().unwrap());\n+        let name = cratepath.file_name().unwrap().to_str().unwrap();\n+        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+\n+        time(sess.time_passes(), &format!(\"altering {}.rlib\", name), (), |()| {\n+            let err = (|| {\n+                io::copy(&mut try!(fs::File::open(&cratepath)),\n+                         &mut try!(fs::File::create(&dst)))\n+            })();\n+            if let Err(e) = err {\n+                sess.fatal(&format!(\"failed to copy {} to {}: {}\",\n+                                    cratepath.display(), dst.display(), e));\n+            }\n+\n+            let mut archive = Archive::open(archive_config(sess, &dst));\n+            archive.remove_file(METADATA_FILENAME);\n+\n+            let mut any_objects = false;\n+            for f in archive.files() {\n+                if f.ends_with(\"bytecode.deflate\") {\n+                    archive.remove_file(&f);\n+                    continue\n                 }\n-                // Fix up permissions of the copy, as fs::copy() preserves\n-                // permissions, but the original file may have been installed\n-                // by a package manager and may be read-only.\n-                match fs::metadata(&dst).and_then(|m| {\n-                    let mut perms = m.permissions();\n-                    perms.set_readonly(false);\n-                    fs::set_permissions(&dst, perms)\n-                }) {\n-                    Ok(..) => {}\n-                    Err(e) => {\n-                        sess.fatal(&format!(\"failed to chmod {} when preparing \\\n-                                             for LTO: {}\", dst.display(), e));\n+                let canonical = f.replace(\"-\", \"_\");\n+                let canonical_name = name.replace(\"-\", \"_\");\n+                if sess.lto() && canonical.starts_with(&canonical_name) &&\n+                   canonical.ends_with(\".o\") {\n+                    let num = &f[name.len()..f.len() - 2];\n+                    if num.len() > 0 && num[1..].parse::<u32>().is_ok() {\n+                        archive.remove_file(&f);\n+                        continue\n                     }\n                 }\n-                let handler = &sess.diagnostic().handler;\n-                let config = ArchiveConfig {\n-                    handler: handler,\n-                    dst: dst.clone(),\n-                    lib_search_paths: archive_search_paths(sess),\n-                    slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n-                    slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n-                    ar_prog: get_ar_prog(sess),\n-                    command_path: command_path(sess),\n-                };\n-                let mut archive = Archive::open(config);\n-                archive.remove_file(&format!(\"{}.o\", name));\n-                let files = archive.files();\n-                if files.iter().any(|s| s.ends_with(\".o\")) {\n-                    cmd.link_rlib(&dst);\n-                }\n-            });\n-        } else {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n-        }\n+                any_objects = true;\n+            }\n+\n+            if any_objects {\n+                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n+            }\n+        });\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates."}, {"sha": "518a6c248407a995e38a6edc990b791c8fd18ad9", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -30,6 +30,7 @@ pub trait Linker {\n     fn link_framework(&mut self, framework: &str);\n     fn link_staticlib(&mut self, lib: &str);\n     fn link_rlib(&mut self, lib: &Path);\n+    fn link_whole_rlib(&mut self, lib: &Path);\n     fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]);\n     fn include_path(&mut self, path: &Path);\n     fn framework_path(&mut self, path: &Path);\n@@ -96,6 +97,17 @@ impl<'a> Linker for GnuLinker<'a> {\n         }\n     }\n \n+    fn link_whole_rlib(&mut self, lib: &Path) {\n+        if self.sess.target.target.options.is_like_osx {\n+            let mut v = OsString::from(\"-Wl,-force_load,\");\n+            v.push(lib);\n+            self.cmd.arg(&v);\n+        } else {\n+            self.cmd.arg(\"-Wl,--whole-archive\").arg(lib)\n+                    .arg(\"-Wl,--no-whole-archive\");\n+        }\n+    }\n+\n     fn gc_sections(&mut self, is_dylib: bool) {\n         // The dead_strip option to the linker specifies that functions and data\n         // unreachable by the entry point will be removed. This is quite useful\n@@ -250,6 +262,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n         // not supported?\n         self.link_staticlib(lib);\n     }\n+    fn link_whole_rlib(&mut self, path: &Path) {\n+        // not supported?\n+        self.link_rlib(path);\n+    }\n     fn optimize(&mut self) {\n         // Needs more investigation of `/OPT` arguments\n     }"}, {"sha": "dfeb866c5b3f00a2fd7b69e8079bad0a50edb58d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -56,33 +56,14 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n-        let file = path.file_name().unwrap().to_str().unwrap();\n-        let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n-        debug!(\"reading {}\", file);\n-        for i in 0.. {\n-            let filename = format!(\"{}.{}.bytecode.deflate\", file, i);\n-            let msg = format!(\"check for {}\", filename);\n-            let bc_encoded = time(sess.time_passes(), &msg, (), |_| {\n-                archive.iter().find(|section| {\n-                    section.name() == Some(&filename[..])\n-                })\n-            });\n-            let bc_encoded = match bc_encoded {\n-                Some(data) => data,\n-                None => {\n-                    if i == 0 {\n-                        // No bitcode was found at all.\n-                        sess.fatal(&format!(\"missing compressed bytecode in {}\",\n-                                           path.display()));\n-                    }\n-                    // No more bitcode files to read.\n-                    break\n-                }\n-            };\n-            let bc_encoded = bc_encoded.data();\n+        let bytecodes = archive.iter().filter_map(|child| {\n+            child.name().map(|name| (name, child))\n+        }).filter(|&(name, _)| name.ends_with(\"bytecode.deflate\"));\n+        for (name, data) in bytecodes {\n+            let bc_encoded = data.data();\n \n             let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n-                time(sess.time_passes(), &format!(\"decode {}.{}.bc\", file, i), (), |_| {\n+                time(sess.time_passes(), &format!(\"decode {}\", name), (), |_| {\n                     // Read the version\n                     let version = extract_bytecode_format_version(bc_encoded);\n \n@@ -106,7 +87,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     }\n                 })\n             } else {\n-                time(sess.time_passes(), &format!(\"decode {}.{}.bc\", file, i), (), |_| {\n+                time(sess.time_passes(), &format!(\"decode {}\", name), (), |_| {\n                 // the object must be in the old, pre-versioning format, so simply\n                 // inflate everything and let LLVM decide if it can make sense of it\n                     match flate::inflate_bytes(bc_encoded) {\n@@ -120,10 +101,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             };\n \n             let ptr = bc_decoded.as_ptr();\n-            debug!(\"linking {}, part {}\", name, i);\n-            time(sess.time_passes(),\n-                 &format!(\"ll link {}.{}\", name, i),\n-                 (),\n+            debug!(\"linking {}\", name);\n+            time(sess.time_passes(), &format!(\"ll link {}\", name), (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,"}, {"sha": "78c03bac33f27bc31b581707770ff7b55d0f829f", "filename": "src/test/auxiliary/issue-14344-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Fauxiliary%2Fissue-14344-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Fauxiliary%2Fissue-14344-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-14344-1.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+\n+pub fn foo() {}"}, {"sha": "9df35e50adba9ce73eeafa60bb761789190fc636", "filename": "src/test/auxiliary/issue-14344-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Fauxiliary%2Fissue-14344-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Fauxiliary%2Fissue-14344-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-14344-2.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate issue_14344_1;\n+\n+pub fn bar() {}"}, {"sha": "b9da39cbbcb4e35a516c4456b5b9a2c0f16b5ef6", "filename": "src/test/auxiliary/issue-25185-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n+extern {\n+    pub fn rust_dbg_extern_identity_u32(u: u32) -> u32;\n+}"}, {"sha": "00b5277d6c00e852e3682969f7c68c62e4cc4f60", "filename": "src/test/auxiliary/issue-25185-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Fauxiliary%2Fissue-25185-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Fauxiliary%2Fissue-25185-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-25185-2.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate issue_25185_1;\n+\n+pub use issue_25185_1::rust_dbg_extern_identity_u32;"}, {"sha": "79a9a3c640f03b62cc294be160d9e82f48372ab2", "filename": "src/test/run-make/extern-fn-reachable/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2FMakefile?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -4,6 +4,6 @@\n TARGET_RPATH_DIR:=$(TARGET_RPATH_DIR):$(TMPDIR)\n \n all:\n-\t$(RUSTC) dylib.rs -o $(TMPDIR)/libdylib.so\n-\t$(RUSTC) main.rs\n+\t$(RUSTC) dylib.rs -o $(TMPDIR)/libdylib.so -C prefer-dynamic\n+\t$(RUSTC) main.rs -C prefer-dynamic\n \t$(call RUN,main)"}, {"sha": "06b8f44ed260ccc778a9e43edaeb3d466885badb", "filename": "src/test/run-pass/issue-14344.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Frun-pass%2Fissue-14344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Frun-pass%2Fissue-14344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14344.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-14344-1.rs\n+// aux-build:issue-14344-2.rs\n+\n+extern crate issue_14344_1;\n+extern crate issue_14344_2;\n+\n+fn main() {\n+    issue_14344_1::foo();\n+    issue_14344_2::bar();\n+}"}, {"sha": "d8d2d5078c5e71342490d9a082b68e0bab8a6151", "filename": "src/test/run-pass/issue-25185.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Frun-pass%2Fissue-25185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8e6d1472a57441afe3592078838d2bc767996/src%2Ftest%2Frun-pass%2Fissue-25185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25185.rs?ref=9bc8e6d1472a57441afe3592078838d2bc767996", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-25185-1.rs\n+// aux-build:issue-25185-2.rs\n+\n+extern crate issue_25185_2;\n+\n+fn main() {\n+    let x = unsafe {\n+        issue_25185_2::rust_dbg_extern_identity_u32(1)\n+    };\n+    assert_eq!(x, 1);\n+}"}]}