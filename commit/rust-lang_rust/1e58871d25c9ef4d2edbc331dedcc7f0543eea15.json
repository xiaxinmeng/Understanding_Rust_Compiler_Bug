{"sha": "1e58871d25c9ef4d2edbc331dedcc7f0543eea15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNTg4NzFkMjVjOWVmNGQyZWRiYzMzMWRlZGNjN2YwNTQzZWVhMTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-15T09:46:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-15T09:46:22Z"}, "message": "Auto merge of #75518 - davidtwco:issue-75326-polymorphization-symbol-mangling-v0-predicates, r=lcnr\n\npolymorphize: `I` used if `T` used in `I: Foo<T>`\n\nFixes #75326.\n\nThis PR adjusts polymorphization's handling of predicates so that after ensuring that `T` is used in `I: Foo<T>` if `I` is used, it now ensures that `I` is used if `T` is used in `I: Foo<T>`. This is necessary to mark generic parameters that only exist in impl parameters as used - thereby avoiding symbol clashes when using the new mangling scheme.\n\nWith this PR, rustc will now fully bootstrap with polymorphization and the new symbol mangling scheme enabled - not all tests pass, but I'm not sure how much of that is the interaction of the two features, I'll be looking into that soon. All tests pass with only polymorphization enabled.\n\nr? @lcnr (this isn't sufficiently complex that I need to add to eddy's review queue)\ncc @eddyb", "tree": {"sha": "9cb5e10d1d8bb7b5e301235fb706378534f1bbdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cb5e10d1d8bb7b5e301235fb706378534f1bbdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e58871d25c9ef4d2edbc331dedcc7f0543eea15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e58871d25c9ef4d2edbc331dedcc7f0543eea15", "html_url": "https://github.com/rust-lang/rust/commit/1e58871d25c9ef4d2edbc331dedcc7f0543eea15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e58871d25c9ef4d2edbc331dedcc7f0543eea15/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5205b974d588a41798a7438b91bf26a6f084e0dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5205b974d588a41798a7438b91bf26a6f084e0dd", "html_url": "https://github.com/rust-lang/rust/commit/5205b974d588a41798a7438b91bf26a6f084e0dd"}, {"sha": "bf3ef26713b8208e0127f4c51725897dbcd11bd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf3ef26713b8208e0127f4c51725897dbcd11bd9", "html_url": "https://github.com/rust-lang/rust/commit/bf3ef26713b8208e0127f4c51725897dbcd11bd9"}], "stats": {"total": 220, "additions": 189, "deletions": 31}, "files": [{"sha": "d946c1947c2df0178f7891976d8ab3455f23ee15", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 119, "deletions": 31, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/1e58871d25c9ef4d2edbc331dedcc7f0543eea15/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e58871d25c9ef4d2edbc331dedcc7f0543eea15/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=1e58871d25c9ef4d2edbc331dedcc7f0543eea15", "patch": "@@ -69,8 +69,7 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n \n     // Visit MIR and accumululate used generic parameters.\n     let body = tcx.optimized_mir(def_id);\n-    let mut vis =\n-        UsedGenericParametersVisitor { tcx, def_id, unused_parameters: &mut unused_parameters };\n+    let mut vis = MarkUsedGenericParams { tcx, def_id, unused_parameters: &mut unused_parameters };\n     vis.visit_body(body);\n     debug!(\"unused_generic_params: (after visitor) unused_parameters={:?}\", unused_parameters);\n \n@@ -120,45 +119,101 @@ fn mark_used_by_predicates<'tcx>(\n     def_id: DefId,\n     unused_parameters: &mut FiniteBitSet<u32>,\n ) {\n-    let def_id = tcx.closure_base_def_id(def_id);\n-\n-    let is_self_ty_used = |unused_parameters: &mut FiniteBitSet<u32>, self_ty: Ty<'tcx>| {\n-        debug!(\"unused_generic_params: self_ty={:?}\", self_ty);\n-        if let ty::Param(param) = self_ty.kind {\n-            !unused_parameters.contains(param.index).unwrap_or(false)\n-        } else {\n-            false\n-        }\n+    let is_ty_used = |unused_parameters: &FiniteBitSet<u32>, ty: Ty<'tcx>| -> bool {\n+        let mut vis = IsUsedGenericParams { unused_parameters };\n+        ty.visit_with(&mut vis)\n     };\n \n     let mark_ty = |unused_parameters: &mut FiniteBitSet<u32>, ty: Ty<'tcx>| {\n-        let mut vis = UsedGenericParametersVisitor { tcx, def_id, unused_parameters };\n+        let mut vis = MarkUsedGenericParams { tcx, def_id, unused_parameters };\n         ty.visit_with(&mut vis);\n     };\n \n+    let def_id = tcx.closure_base_def_id(def_id);\n     let predicates = tcx.explicit_predicates_of(def_id);\n-    debug!(\"mark_parameters_used_in_predicates: predicates_of={:?}\", predicates);\n-    for (predicate, _) in predicates.predicates {\n-        match predicate.skip_binders() {\n-            ty::PredicateAtom::Trait(predicate, ..) => {\n-                let trait_ref = predicate.trait_ref;\n-                if is_self_ty_used(unused_parameters, trait_ref.self_ty()) {\n+    debug!(\"mark_used_by_predicates: predicates_of={:?}\", predicates);\n+\n+    let mut current_unused_parameters = FiniteBitSet::new_empty();\n+    // Run to a fixed point to support `where T: Trait<U>, U: Trait<V>`, starting with an empty\n+    // bit set so that this is skipped if all parameters are already used.\n+    while current_unused_parameters != *unused_parameters {\n+        debug!(\n+            \"mark_used_by_predicates: current_unused_parameters={:?} = unused_parameters={:?}\",\n+            current_unused_parameters, unused_parameters\n+        );\n+        current_unused_parameters = *unused_parameters;\n+\n+        for (predicate, _) in predicates.predicates {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(predicate, ..) => {\n+                    let trait_ref = predicate.trait_ref;\n+                    debug!(\"mark_used_by_predicates: (trait) trait_ref={:?}\", trait_ref);\n+\n+                    // Consider `T` used if `I` is used in predicates of the form\n+                    // `I: Iterator<Item = T>`\n+                    debug!(\"mark_used_by_predicates: checking self\");\n+                    if is_ty_used(unused_parameters, trait_ref.self_ty()) {\n+                        debug!(\"mark_used_by_predicates: used!\");\n+                        for ty in trait_ref.substs.types() {\n+                            mark_ty(unused_parameters, ty);\n+                        }\n+\n+                        // No need to check for a type being used in the substs if `self_ty` was\n+                        // used.\n+                        continue;\n+                    }\n+\n+                    // Consider `I` used if `T` is used in predicates of the form\n+                    // `I: Iterator<Item = &'a (T, E)>` (see rust-lang/rust#75326)\n+                    debug!(\"mark_used_by_predicates: checking substs\");\n                     for ty in trait_ref.substs.types() {\n-                        debug!(\"unused_generic_params: (trait) ty={:?}\", ty);\n-                        mark_ty(unused_parameters, ty);\n+                        if is_ty_used(unused_parameters, ty) {\n+                            debug!(\"mark_used_by_predicates: used!\");\n+                            mark_ty(unused_parameters, trait_ref.self_ty());\n+                        }\n                     }\n                 }\n-            }\n-            ty::PredicateAtom::Projection(proj, ..) => {\n-                let self_ty = proj.projection_ty.self_ty();\n-                if is_self_ty_used(unused_parameters, self_ty) {\n-                    debug!(\"unused_generic_params: (projection ty={:?}\", proj.ty);\n-                    mark_ty(unused_parameters, proj.ty);\n+                ty::PredicateAtom::Projection(proj, ..) => {\n+                    let self_ty = proj.projection_ty.self_ty();\n+                    debug!(\n+                        \"mark_used_by_predicates: (projection) self_ty={:?} proj.ty={:?}\",\n+                        self_ty, proj.ty\n+                    );\n+\n+                    // Consider `T` used if `I` is used in predicates of the form\n+                    // `<I as Iterator>::Item = T`\n+                    debug!(\"mark_used_by_predicates: checking self\");\n+                    if is_ty_used(unused_parameters, self_ty) {\n+                        debug!(\"mark_used_by_predicates: used!\");\n+                        mark_ty(unused_parameters, proj.ty);\n+\n+                        // No need to check for projection type being used if `self_ty` was used.\n+                        continue;\n+                    }\n+\n+                    // Consider `I` used if `T` is used in predicates of the form\n+                    // `<I as Iterator>::Item = &'a (T, E)` (see rust-lang/rust#75326)\n+                    debug!(\"mark_used_by_predicates: checking projection ty\");\n+                    if is_ty_used(unused_parameters, proj.ty) {\n+                        debug!(\"mark_used_by_predicates: used!\");\n+                        mark_ty(unused_parameters, self_ty);\n+                    }\n                 }\n+                ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::TypeOutlives(..)\n+                | ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => (),\n             }\n-            _ => (),\n         }\n     }\n+\n+    if let Some(parent) = predicates.parent {\n+        mark_used_by_predicates(tcx, parent, unused_parameters);\n+    }\n }\n \n /// Emit errors for the function annotated by `#[rustc_polymorphize_error]`, labelling each generic\n@@ -204,13 +259,13 @@ fn emit_unused_generic_params_error<'tcx>(\n }\n \n /// Visitor used to aggregate generic parameter uses.\n-struct UsedGenericParametersVisitor<'a, 'tcx> {\n+struct MarkUsedGenericParams<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     unused_parameters: &'a mut FiniteBitSet<u32>,\n }\n \n-impl<'a, 'tcx> UsedGenericParametersVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> MarkUsedGenericParams<'a, 'tcx> {\n     /// Invoke `unused_generic_params` on a body contained within the current item (e.g.\n     /// a closure, generator or constant).\n     fn visit_child_body(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) {\n@@ -229,7 +284,7 @@ impl<'a, 'tcx> UsedGenericParametersVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n         debug!(\"visit_local_decl: local_decl={:?}\", local_decl);\n         if local == Local::from_usize(1) {\n@@ -256,7 +311,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> bool {\n         debug!(\"visit_const: c={:?}\", c);\n         if !c.has_param_types_or_consts() {\n@@ -318,3 +373,36 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n         }\n     }\n }\n+\n+/// Visitor used to check if a generic parameter is used.\n+struct IsUsedGenericParams<'a> {\n+    unused_parameters: &'a FiniteBitSet<u32>,\n+}\n+\n+impl<'a, 'tcx> TypeVisitor<'tcx> for IsUsedGenericParams<'a> {\n+    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> bool {\n+        debug!(\"visit_const: c={:?}\", c);\n+        if !c.has_param_types_or_consts() {\n+            return false;\n+        }\n+\n+        match c.val {\n+            ty::ConstKind::Param(param) => {\n+                !self.unused_parameters.contains(param.index).unwrap_or(false)\n+            }\n+            _ => c.super_visit_with(self),\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        debug!(\"visit_ty: ty={:?}\", ty);\n+        if !ty.has_param_types_or_consts() {\n+            return false;\n+        }\n+\n+        match ty.kind {\n+            ty::Param(param) => !self.unused_parameters.contains(param.index).unwrap_or(false),\n+            _ => ty.super_visit_with(self),\n+        }\n+    }\n+}"}, {"sha": "60555dc12dcacc8e57a3a1a3cb2cf9f73f429add", "filename": "src/test/ui/polymorphization/predicates.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1e58871d25c9ef4d2edbc331dedcc7f0543eea15/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e58871d25c9ef4d2edbc331dedcc7f0543eea15/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs?ref=1e58871d25c9ef4d2edbc331dedcc7f0543eea15", "patch": "@@ -18,7 +18,55 @@ where\n     bar::<I>()\n }\n \n+#[rustc_polymorphize_error]\n+fn baz<I, T>(_: I)\n+where\n+    std::iter::Repeat<I>: Iterator<Item = T>,\n+{\n+    bar::<I>()\n+}\n+\n+// In addition, check that `I` is considered used in `next::{{closure}}`, because `T` is used and\n+// `T` is really just `I::Item`. `E` is used due to the fixed-point marking of predicates.\n+\n+pub(crate) struct Foo<'a, I, E>(I, &'a E);\n+\n+impl<'a, I, T: 'a, E> Iterator for Foo<'a, I, E>\n+where\n+    I: Iterator<Item = &'a (T, E)>,\n+{\n+    type Item = T;\n+\n+    #[rustc_polymorphize_error]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.find(|_| true)\n+    }\n+}\n+\n+// Furthermore, check that `B` is considered used because `C` is used, and that `A` is considered\n+// used because `B` is now used.\n+\n+trait Baz<Z> {}\n+\n+impl Baz<u16> for u8 {}\n+impl Baz<u32> for u16 {}\n+\n+#[rustc_polymorphize_error]\n+fn quux<A, B, C: Default>() -> usize\n+where\n+    A: Baz<B>,\n+    B: Baz<C>,\n+{\n+    std::mem::size_of::<C>()\n+}\n+\n fn main() {\n     let x = &[2u32];\n     foo(x.iter());\n+    baz(x.iter());\n+\n+    let mut a = Foo([(1u32, 1u16)].iter(), &1u16);\n+    let _ = a.next();\n+\n+    let _ = quux::<u8, u16, u32>();\n }"}, {"sha": "d97bae183d9c21712d1be11eef2fba9285a62e52", "filename": "src/test/ui/polymorphization/symbol-ambiguity.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e58871d25c9ef4d2edbc331dedcc7f0543eea15/src%2Ftest%2Fui%2Fpolymorphization%2Fsymbol-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e58871d25c9ef4d2edbc331dedcc7f0543eea15/src%2Ftest%2Fui%2Fpolymorphization%2Fsymbol-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fsymbol-ambiguity.rs?ref=1e58871d25c9ef4d2edbc331dedcc7f0543eea15", "patch": "@@ -0,0 +1,22 @@\n+// build-pass\n+// compile-flags: -Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+pub(crate) struct Foo<'a, I, E>(I, &'a E);\n+\n+impl<'a, I, T: 'a, E> Iterator for Foo<'a, I, E>\n+where\n+    I: Iterator<Item = &'a (T, E)>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.find(|_| true)\n+    }\n+}\n+\n+fn main() {\n+    let mut a = Foo([(1u32, 1u16)].iter(), &1u16);\n+    let mut b = Foo([(1u16, 1u32)].iter(), &1u32);\n+    let _ = a.next();\n+    let _ = b.next();\n+}"}]}