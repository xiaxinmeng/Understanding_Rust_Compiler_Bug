{"sha": "38c17dc324b82f8f7be2e9f87930e0bd11a38e1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YzE3ZGMzMjRiODJmOGY3YmUyZTlmODc5MzBlMGJkMTFhMzhlMWM=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-17T20:13:56Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-17T20:19:56Z"}, "message": "libtest: DSTify `Stats`", "tree": {"sha": "76dac4f9c1a9f73846979276d5af1efc25228a5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76dac4f9c1a9f73846979276d5af1efc25228a5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38c17dc324b82f8f7be2e9f87930e0bd11a38e1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38c17dc324b82f8f7be2e9f87930e0bd11a38e1c", "html_url": "https://github.com/rust-lang/rust/commit/38c17dc324b82f8f7be2e9f87930e0bd11a38e1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38c17dc324b82f8f7be2e9f87930e0bd11a38e1c/comments", "author": null, "committer": null, "parents": [{"sha": "88c743def3cf42ee943ca09dda1e6dccf4894db9", "url": "https://api.github.com/repos/rust-lang/rust/commits/88c743def3cf42ee943ca09dda1e6dccf4894db9", "html_url": "https://github.com/rust-lang/rust/commit/88c743def3cf42ee943ca09dda1e6dccf4894db9"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "5161d1de7eecdbb3ebe2dd162bcab0dbe08ed3b6", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/38c17dc324b82f8f7be2e9f87930e0bd11a38e1c/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c17dc324b82f8f7be2e9f87930e0bd11a38e1c/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=38c17dc324b82f8f7be2e9f87930e0bd11a38e1c", "patch": "@@ -38,7 +38,7 @@ fn local_sort<T: Float>(v: &mut [T]) {\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: FloatMath + FromPrimitive>{\n+pub trait Stats <T: FloatMath + FromPrimitive> for Sized? {\n \n     /// Sum of the samples.\n     ///\n@@ -47,24 +47,24 @@ pub trait Stats <T: FloatMath + FromPrimitive>{\n     /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n     /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n     /// *Discrete & Computational Geometry 18*, 3 (Oct 1997), 305-363, Shewchuk J.R.\n-    fn sum(self) -> T;\n+    fn sum(&self) -> T;\n \n     /// Minimum value of the samples.\n-    fn min(self) -> T;\n+    fn min(&self) -> T;\n \n     /// Maximum value of the samples.\n-    fn max(self) -> T;\n+    fn max(&self) -> T;\n \n     /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Arithmetic_mean\n-    fn mean(self) -> T;\n+    fn mean(&self) -> T;\n \n     /// Median of the samples: value separating the lower half of the samples from the higher half.\n     /// Equal to `self.percentile(50.0)`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Median\n-    fn median(self) -> T;\n+    fn median(&self) -> T;\n \n     /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n     /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n@@ -73,21 +73,21 @@ pub trait Stats <T: FloatMath + FromPrimitive>{\n     /// than `n`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Variance\n-    fn var(self) -> T;\n+    fn var(&self) -> T;\n \n     /// Standard deviation: the square root of the sample variance.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev` for unknown distributions.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Standard_deviation\n-    fn std_dev(self) -> T;\n+    fn std_dev(&self) -> T;\n \n     /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev_pct` for unknown distributions.\n-    fn std_dev_pct(self) -> T;\n+    fn std_dev_pct(&self) -> T;\n \n     /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n     /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n@@ -96,10 +96,10 @@ pub trait Stats <T: FloatMath + FromPrimitive>{\n     /// deviation.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Median_absolute_deviation\n-    fn median_abs_dev(self) -> T;\n+    fn median_abs_dev(&self) -> T;\n \n     /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n-    fn median_abs_dev_pct(self) -> T;\n+    fn median_abs_dev_pct(&self) -> T;\n \n     /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n     /// percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\n@@ -108,21 +108,21 @@ pub trait Stats <T: FloatMath + FromPrimitive>{\n     /// Calculated by linear interpolation between closest ranks.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Percentile\n-    fn percentile(self, pct: T) -> T;\n+    fn percentile(&self, pct: T) -> T;\n \n     /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n     /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n     /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n     /// is otherwise equivalent.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Quartile\n-    fn quartiles(self) -> (T,T,T);\n+    fn quartiles(&self) -> (T,T,T);\n \n     /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n     /// percentile (3rd quartile). See `quartiles`.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Interquartile_range\n-    fn iqr(self) -> T;\n+    fn iqr(&self) -> T;\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n@@ -163,9 +163,9 @@ impl<T: FloatMath + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n+impl<T: FloatMath + FromPrimitive> Stats<T> for [T] {\n     // FIXME #11059 handle NaN, inf and overflow\n-    fn sum(self) -> T {\n+    fn sum(&self) -> T {\n         let mut partials = vec![];\n \n         for &mut x in self.iter() {\n@@ -198,26 +198,26 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n         partials.iter().fold(zero, |p, q| p + *q)\n     }\n \n-    fn min(self) -> T {\n+    fn min(&self) -> T {\n         assert!(self.len() != 0);\n         self.iter().fold(self[0], |p, q| p.min(*q))\n     }\n \n-    fn max(self) -> T {\n+    fn max(&self) -> T {\n         assert!(self.len() != 0);\n         self.iter().fold(self[0], |p, q| p.max(*q))\n     }\n \n-    fn mean(self) -> T {\n+    fn mean(&self) -> T {\n         assert!(self.len() != 0);\n         self.sum() / FromPrimitive::from_uint(self.len()).unwrap()\n     }\n \n-    fn median(self) -> T {\n+    fn median(&self) -> T {\n         self.percentile(FromPrimitive::from_uint(50).unwrap())\n     }\n \n-    fn var(self) -> T {\n+    fn var(&self) -> T {\n         if self.len() < 2 {\n             Float::zero()\n         } else {\n@@ -235,16 +235,16 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n         }\n     }\n \n-    fn std_dev(self) -> T {\n+    fn std_dev(&self) -> T {\n         self.var().sqrt()\n     }\n \n-    fn std_dev_pct(self) -> T {\n+    fn std_dev_pct(&self) -> T {\n         let hundred = FromPrimitive::from_uint(100).unwrap();\n         (self.std_dev() / self.mean()) * hundred\n     }\n \n-    fn median_abs_dev(self) -> T {\n+    fn median_abs_dev(&self) -> T {\n         let med = self.median();\n         let abs_devs: Vec<T> = self.iter().map(|&v| (med - v).abs()).collect();\n         // This constant is derived by smarter statistics brains than me, but it is\n@@ -253,18 +253,18 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n         abs_devs.as_slice().median() * number\n     }\n \n-    fn median_abs_dev_pct(self) -> T {\n+    fn median_abs_dev_pct(&self) -> T {\n         let hundred = FromPrimitive::from_uint(100).unwrap();\n         (self.median_abs_dev() / self.median()) * hundred\n     }\n \n-    fn percentile(self, pct: T) -> T {\n+    fn percentile(&self, pct: T) -> T {\n         let mut tmp = self.to_vec();\n         local_sort(tmp.as_mut_slice());\n         percentile_of_sorted(tmp.as_slice(), pct)\n     }\n \n-    fn quartiles(self) -> (T,T,T) {\n+    fn quartiles(&self) -> (T,T,T) {\n         let mut tmp = self.to_vec();\n         local_sort(tmp.as_mut_slice());\n         let first = FromPrimitive::from_uint(25).unwrap();\n@@ -276,7 +276,7 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n         (a,b,c)\n     }\n \n-    fn iqr(self) -> T {\n+    fn iqr(&self) -> T {\n         let (a,_,c) = self.quartiles();\n         c - a\n     }"}]}