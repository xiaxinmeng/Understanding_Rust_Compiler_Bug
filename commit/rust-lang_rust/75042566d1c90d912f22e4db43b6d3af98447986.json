{"sha": "75042566d1c90d912f22e4db43b6d3af98447986", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MDQyNTY2ZDFjOTBkOTEyZjIyZTRkYjQzYjZkM2FmOTg0NDc5ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-15T02:21:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-15T02:21:18Z"}, "message": "Auto merge of #79065 - Dylan-DPC:rollup-gag1drk, r=Dylan-DPC\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #78352 (Do not call `unwrap` with `signatures` option enabled)\n - #78590 (refactor: removing alloc::collections::vec_deque ignore-tidy-filelength)\n - #78848 (Bump minimal supported LLVM version to 9)\n - #78856 (Explicitly checking for or-pattern before test)\n - #78948 (test: add `()=()=()=...` to weird-exprs.rs)\n - #78962 (Add a test for r# identifiers)\n - #78963 (Added some unit tests as requested)\n - #78966 (Never inline C variadics, cold functions, functions with incompatible attributes ...)\n - #78968 (Include llvm-as in llvm-tools-preview component)\n - #78969 (Normalize function type during validation)\n - #78980 (Fix rustc_ast_pretty print_qpath resulting in invalid macro input)\n - #78986 (Avoid installing external LLVM dylibs)\n - #78988 (Fix an intrinsic invocation on threaded wasm)\n - #78993 (rustc_target: Fix dash vs underscore mismatches in option names)\n - #79013 (Clean up outdated `use_once_payload` pretty printer comment)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "59ffa44ee35633cf8ff80b132e2cf0919c3dd787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59ffa44ee35633cf8ff80b132e2cf0919c3dd787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75042566d1c90d912f22e4db43b6d3af98447986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75042566d1c90d912f22e4db43b6d3af98447986", "html_url": "https://github.com/rust-lang/rust/commit/75042566d1c90d912f22e4db43b6d3af98447986", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75042566d1c90d912f22e4db43b6d3af98447986/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "361c4ea22486557ec50c4fc6a93d60e7476ecbea", "url": "https://api.github.com/repos/rust-lang/rust/commits/361c4ea22486557ec50c4fc6a93d60e7476ecbea", "html_url": "https://github.com/rust-lang/rust/commit/361c4ea22486557ec50c4fc6a93d60e7476ecbea"}, {"sha": "96515ccc7a41cc8968ee742cb4d65205582e0fe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/96515ccc7a41cc8968ee742cb4d65205582e0fe9", "html_url": "https://github.com/rust-lang/rust/commit/96515ccc7a41cc8968ee742cb4d65205582e0fe9"}], "stats": {"total": 2426, "additions": 1732, "deletions": 694}, "files": [{"sha": "f10b6ca7ea94d82a94569476f9e0f654d859ae8d", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -43,7 +43,7 @@ jobs:\n           - name: mingw-check\n             os: ubuntu-latest-xl\n             env: {}\n-          - name: x86_64-gnu-llvm-8\n+          - name: x86_64-gnu-llvm-9\n             os: ubuntu-latest-xl\n             env: {}\n           - name: x86_64-gnu-tools\n@@ -265,7 +265,7 @@ jobs:\n           - name: x86_64-gnu-distcheck\n             os: ubuntu-latest-xl\n             env: {}\n-          - name: x86_64-gnu-llvm-8\n+          - name: x86_64-gnu-llvm-9\n             env:\n               RUST_BACKTRACE: 1\n             os: ubuntu-latest-xl"}, {"sha": "f02ae7ef6cfa3ace4295d90979aa6e99b9c28dc8", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -721,6 +721,13 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a21fa21941700a3cd8fcb4091f361a6a712fac632f85d9f487cc892045d55c6\"\n \n+[[package]]\n+name = \"coverage_test_macros\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n [[package]]\n name = \"cpuid-bool\"\n version = \"0.1.2\"\n@@ -3922,6 +3929,7 @@ dependencies = [\n name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"coverage_test_macros\",\n  \"either\",\n  \"itertools 0.9.0\",\n  \"polonius-engine\","}, {"sha": "958219cbebf3fd051faf3f242b0c6d9540c451e2", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -2327,11 +2327,12 @@ impl<'a> State<'a> {\n             self.print_path(path, false, depth);\n         }\n         self.s.word(\">\");\n-        self.s.word(\"::\");\n-        let item_segment = path.segments.last().unwrap();\n-        self.print_ident(item_segment.ident);\n-        if let Some(ref args) = item_segment.args {\n-            self.print_generic_args(args, colons_before_params)\n+        for item_segment in &path.segments[qself.position..] {\n+            self.s.word(\"::\");\n+            self.print_ident(item_segment.ident);\n+            if let Some(ref args) = item_segment.args {\n+                self.print_generic_args(args, colons_before_params)\n+            }\n         }\n     }\n "}, {"sha": "e06e2d45665b1aae29ac40afefb27e4707d4b617", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -144,25 +144,6 @@ fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     );\n }\n \n-fn translate_obsolete_target_features(feature: &str) -> &str {\n-    const LLVM9_FEATURE_CHANGES: &[(&str, &str)] =\n-        &[(\"+fp-only-sp\", \"-fp64\"), (\"-fp-only-sp\", \"+fp64\"), (\"+d16\", \"-d32\"), (\"-d16\", \"+d32\")];\n-    if llvm_util::get_major_version() >= 9 {\n-        for &(old, new) in LLVM9_FEATURE_CHANGES {\n-            if feature == old {\n-                return new;\n-            }\n-        }\n-    } else {\n-        for &(old, new) in LLVM9_FEATURE_CHANGES {\n-            if feature == new {\n-                return old;\n-            }\n-        }\n-    }\n-    feature\n-}\n-\n pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n     const RUSTC_SPECIFIC_FEATURES: &[&str] = &[\"crt-static\"];\n \n@@ -172,12 +153,7 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n         .target_feature\n         .split(',')\n         .filter(|f| !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)));\n-    sess.target\n-        .features\n-        .split(',')\n-        .chain(cmdline)\n-        .filter(|l| !l.is_empty())\n-        .map(translate_obsolete_target_features)\n+    sess.target.features.split(',').chain(cmdline).filter(|l| !l.is_empty())\n }\n \n pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {"}, {"sha": "6f956c3bcc1ce5da4c405adda97e32f75a79068f", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -377,11 +377,6 @@ fn get_pgo_use_path(config: &ModuleConfig) -> Option<CString> {\n }\n \n pub(crate) fn should_use_new_llvm_pass_manager(config: &ModuleConfig) -> bool {\n-    // We only support the new pass manager starting with LLVM 9.\n-    if llvm_util::get_major_version() < 9 {\n-        return false;\n-    }\n-\n     // The new pass manager is disabled by default.\n     config.new_llvm_pass_manager\n }"}, {"sha": "8dd40308075edd3a706c85c2935aced09c580457", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -100,11 +100,6 @@ fn to_llvm_tls_model(tls_model: TlsModel) -> llvm::ThreadLocalMode {\n     }\n }\n \n-fn strip_function_ptr_alignment(data_layout: String) -> String {\n-    // FIXME: Make this more general.\n-    data_layout.replace(\"-Fi8-\", \"-\")\n-}\n-\n fn strip_x86_address_spaces(data_layout: String) -> String {\n     data_layout.replace(\"-p270:32:32-p271:32:32-p272:64:64-\", \"-\")\n }\n@@ -119,9 +114,6 @@ pub unsafe fn create_module(\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n     let mut target_data_layout = sess.target.data_layout.clone();\n-    if llvm_util::get_major_version() < 9 {\n-        target_data_layout = strip_function_ptr_alignment(target_data_layout);\n-    }\n     if llvm_util::get_major_version() < 10\n         && (sess.target.arch == \"x86\" || sess.target.arch == \"x86_64\")\n     {"}, {"sha": "cc71b6289faf1ac217391b377fec12c2c371cbe3", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -104,7 +104,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         }\n     }\n \n-    if sess.opts.debugging_opts.llvm_time_trace && get_major_version() >= 9 {\n+    if sess.opts.debugging_opts.llvm_time_trace {\n         // time-trace is not thread safe and running it in parallel will cause seg faults.\n         if !sess.opts.debugging_opts.no_parallel_llvm {\n             bug!(\"`-Z llvm-time-trace` requires `-Z no-parallel-llvm\")\n@@ -122,10 +122,8 @@ unsafe fn configure_llvm(sess: &Session) {\n \n pub fn time_trace_profiler_finish(file_name: &str) {\n     unsafe {\n-        if get_major_version() >= 9 {\n-            let file_name = CString::new(file_name).unwrap();\n-            llvm::LLVMTimeTraceProfilerFinish(file_name.as_ptr());\n-        }\n+        let file_name = CString::new(file_name).unwrap();\n+        llvm::LLVMTimeTraceProfilerFinish(file_name.as_ptr());\n     }\n }\n "}, {"sha": "f74e1fe61e7ef209f14667dcd19b79bd74fe6de4", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -32,9 +32,6 @@ use crate::abort_on_err;\n // Note that since the `&PrinterSupport` is freshly constructed on each\n // call, it would not make sense to try to attach the lifetime of `self`\n // to the lifetime of the `&PrinterObject`.\n-//\n-// (The `use_once_payload` is working around the current lack of once\n-// functions in the compiler.)\n \n /// Constructs a `PrinterSupport` object and passes it to `f`.\n fn call_with_pp_support<'tcx, A, F>("}, {"sha": "01d76bb3e94f2b471f5e325caf9c9a64b01d5229", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -16,9 +16,7 @@\n #include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/Object/IRObjectFile.h\"\n #include \"llvm/Passes/PassBuilder.h\"\n-#if LLVM_VERSION_GE(9, 0)\n #include \"llvm/Passes/StandardInstrumentations.h\"\n-#endif\n #include \"llvm/Support/CBindingWrapping.h\"\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/Host.h\"\n@@ -31,15 +29,11 @@\n #include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n #include \"llvm/Transforms/Instrumentation.h\"\n-#if LLVM_VERSION_GE(9, 0)\n #include \"llvm/Transforms/Instrumentation/AddressSanitizer.h\"\n #include \"llvm/Support/TimeProfiler.h\"\n-#endif\n #include \"llvm/Transforms/Instrumentation/ThreadSanitizer.h\"\n #include \"llvm/Transforms/Instrumentation/MemorySanitizer.h\"\n-#if LLVM_VERSION_GE(9, 0)\n #include \"llvm/Transforms/Utils/CanonicalizeAliases.h\"\n-#endif\n #include \"llvm/Transforms/Utils/NameAnonGlobals.h\"\n \n using namespace llvm;\n@@ -73,20 +67,18 @@ extern \"C\" void LLVMTimeTraceProfilerInitialize() {\n   timeTraceProfilerInitialize(\n       /* TimeTraceGranularity */ 0,\n       /* ProcName */ \"rustc\");\n-#elif LLVM_VERSION_GE(9, 0)\n+#else\n   timeTraceProfilerInitialize();\n #endif\n }\n \n extern \"C\" void LLVMTimeTraceProfilerFinish(const char* FileName) {\n-#if LLVM_VERSION_GE(9, 0)\n   StringRef FN(FileName);\n   std::error_code EC;\n   raw_fd_ostream OS(FN, EC, sys::fs::CD_CreateAlways);\n \n   timeTraceProfilerWrite(OS);\n   timeTraceProfilerCleanup();\n-#endif\n }\n \n enum class LLVMRustPassKind {\n@@ -127,22 +119,14 @@ extern \"C\" LLVMPassRef LLVMRustCreateAddressSanitizerFunctionPass(bool Recover)\n extern \"C\" LLVMPassRef LLVMRustCreateModuleAddressSanitizerPass(bool Recover) {\n   const bool CompileKernel = false;\n \n-#if LLVM_VERSION_GE(9, 0)\n   return wrap(createModuleAddressSanitizerLegacyPassPass(CompileKernel, Recover));\n-#else\n-  return wrap(createAddressSanitizerModulePass(CompileKernel, Recover));\n-#endif\n }\n \n extern \"C\" LLVMPassRef LLVMRustCreateMemorySanitizerPass(int TrackOrigins, bool Recover) {\n-#if LLVM_VERSION_GE(9, 0)\n   const bool CompileKernel = false;\n \n   return wrap(createMemorySanitizerLegacyPassPass(\n       MemorySanitizerOptions{TrackOrigins, Recover, CompileKernel}));\n-#else\n-  return wrap(createMemorySanitizerLegacyPassPass(TrackOrigins, Recover));\n-#endif\n }\n \n extern \"C\" LLVMPassRef LLVMRustCreateThreadSanitizerPass() {\n@@ -657,8 +641,6 @@ extern \"C\" typedef void (*LLVMRustSelfProfileBeforePassCallback)(void*, // LlvmS\n                                                       const char*);     // IR name\n extern \"C\" typedef void (*LLVMRustSelfProfileAfterPassCallback)(void*); // LlvmSelfProfiler\n \n-#if LLVM_VERSION_GE(9, 0)\n-\n std::string LLVMRustwrappedIrGetName(const llvm::Any &WrappedIr) {\n   if (any_isa<const Module *>(WrappedIr))\n     return any_cast<const Module *>(WrappedIr)->getName().str();\n@@ -706,7 +688,6 @@ void LLVMSelfProfileInitializeCallbacks(\n         AfterPassCallback(LlvmSelfProfiler);\n       });\n }\n-#endif\n \n enum class LLVMRustOptStage {\n   PreLinkNoLTO,\n@@ -739,7 +720,6 @@ LLVMRustOptimizeWithNewPassManager(\n     void* LlvmSelfProfiler,\n     LLVMRustSelfProfileBeforePassCallback BeforePassCallback,\n     LLVMRustSelfProfileAfterPassCallback AfterPassCallback) {\n-#if LLVM_VERSION_GE(9, 0)\n   Module *TheModule = unwrap(ModuleRef);\n   TargetMachine *TM = unwrap(TMRef);\n   PassBuilder::OptimizationLevel OptLevel = fromRust(OptLevelRust);\n@@ -970,11 +950,6 @@ LLVMRustOptimizeWithNewPassManager(\n     UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n \n   MPM.run(*TheModule, MAM);\n-#else\n-  // The new pass manager has been available for a long time,\n-  // but we don't bother supporting it on old LLVM versions.\n-  report_fatal_error(\"New pass manager only supported since LLVM 9\");\n-#endif\n }\n \n // Callback to demangle function name\n@@ -1325,12 +1300,9 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n                               GlobalValue::LinkageTypes NewLinkage) {\n     Ret->ResolvedODR[ModuleIdentifier][GUID] = NewLinkage;\n   };\n-#if LLVM_VERSION_GE(9, 0)\n+\n   thinLTOResolvePrevailingInIndex(Ret->Index, isPrevailing, recordNewLinkage,\n                                   Ret->GUIDPreservedSymbols);\n-#else\n-  thinLTOResolvePrevailingInIndex(Ret->Index, isPrevailing, recordNewLinkage);\n-#endif\n \n   // Here we calculate an `ExportedGUIDs` set for use in the `isExported`\n   // callback below. This callback below will dictate the linkage for all"}, {"sha": "9b0c176b692034bc8aaa5db7377a9fb1601e791c", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -124,9 +124,7 @@ extern \"C\" LLVMValueRef LLVMRustGetOrInsertFunction(LLVMModuleRef M,\n   return wrap(unwrap(M)\n                   ->getOrInsertFunction(StringRef(Name, NameLen),\n                                         unwrap<FunctionType>(FunctionTy))\n-#if LLVM_VERSION_GE(9, 0)\n                   .getCallee()\n-#endif\n   );\n }\n \n@@ -251,11 +249,7 @@ extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n extern \"C\" void LLVMRustAddByValCallSiteAttr(LLVMValueRef Instr, unsigned Index,\n                                              LLVMTypeRef Ty) {\n   CallBase *Call = unwrap<CallBase>(Instr);\n-#if LLVM_VERSION_GE(9, 0)\n   Attribute Attr = Attribute::getWithByValType(Call->getContext(), unwrap(Ty));\n-#else\n-  Attribute Attr = Attribute::get(Call->getContext(), Attribute::ByVal);\n-#endif\n   Call->addAttribute(Index, Attr);\n }\n \n@@ -296,11 +290,7 @@ extern \"C\" void LLVMRustAddDereferenceableOrNullAttr(LLVMValueRef Fn,\n extern \"C\" void LLVMRustAddByValAttr(LLVMValueRef Fn, unsigned Index,\n                                      LLVMTypeRef Ty) {\n   Function *F = unwrap<Function>(Fn);\n-#if LLVM_VERSION_GE(9, 0)\n   Attribute Attr = Attribute::getWithByValType(F->getContext(), unwrap(Ty));\n-#else\n-  Attribute Attr = Attribute::get(F->getContext(), Attribute::ByVal);\n-#endif\n   F->addAttribute(Index, Attr);\n }\n \n@@ -616,11 +606,9 @@ static DISubprogram::DISPFlags fromRust(LLVMRustDISPFlags SPFlags) {\n   if (isSet(SPFlags & LLVMRustDISPFlags::SPFlagOptimized)) {\n     Result |= DISubprogram::DISPFlags::SPFlagOptimized;\n   }\n-#if LLVM_VERSION_GE(9, 0)\n   if (isSet(SPFlags & LLVMRustDISPFlags::SPFlagMainSubprogram)) {\n     Result |= DISubprogram::DISPFlags::SPFlagMainSubprogram;\n   }\n-#endif\n \n   return Result;\n }\n@@ -744,10 +732,6 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n       DITemplateParameterArray(unwrap<MDTuple>(TParam));\n   DISubprogram::DISPFlags llvmSPFlags = fromRust(SPFlags);\n   DINode::DIFlags llvmFlags = fromRust(Flags);\n-#if LLVM_VERSION_LT(9, 0)\n-  if (isSet(SPFlags & LLVMRustDISPFlags::SPFlagMainSubprogram))\n-    llvmFlags |= DINode::DIFlags::FlagMainSubprogram;\n-#endif\n   DISubprogram *Sub = Builder->createFunction(\n       unwrapDI<DIScope>(Scope),\n       StringRef(Name, NameLen),"}, {"sha": "db11746971d18b2ce79a1e09b43ab0b82242a8e8", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -611,6 +611,18 @@ pub struct TyS<'tcx> {\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n+impl<'tcx> TyS<'tcx> {\n+    /// A constructor used only for internal testing.\n+    #[allow(rustc::usage_of_ty_tykind)]\n+    pub fn make_for_test(\n+        kind: TyKind<'tcx>,\n+        flags: TypeFlags,\n+        outer_exclusive_binder: ty::DebruijnIndex,\n+    ) -> TyS<'tcx> {\n+        TyS { kind, flags, outer_exclusive_binder }\n+    }\n+}\n+\n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(TyS<'_>, 32);"}, {"sha": "9bfd1da0391203c9b5461dcbf83690c3df4fefe3", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -31,3 +31,6 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+\n+[dev-dependencies]\n+coverage_test_macros = { path = \"src/transform/coverage/test_macros\" }"}, {"sha": "20f6a16e0f75712190548ed9aa573a4310f4f673", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::mir::coverage::*;\n \n /// Manages the counter and expression indexes/IDs to generate `CoverageKind` components for MIR\n /// `Coverage` statements.\n-pub(crate) struct CoverageCounters {\n+pub(super) struct CoverageCounters {\n     function_source_hash: u64,\n     next_counter_id: u32,\n     num_expressions: u32,\n@@ -37,7 +37,7 @@ impl CoverageCounters {\n         self.debug_counters.enable();\n     }\n \n-    /// Makes `CoverageKind` `Counter`s and `Expressions` for the `BasicCoverageBlocks` directly or\n+    /// Makes `CoverageKind` `Counter`s and `Expressions` for the `BasicCoverageBlock`s directly or\n     /// indirectly associated with `CoverageSpans`, and returns additional `Expression`s\n     /// representing intermediate values.\n     pub fn make_bcb_counters(\n@@ -120,7 +120,6 @@ struct BcbCounters<'a> {\n     basic_coverage_blocks: &'a mut CoverageGraph,\n }\n \n-// FIXME(richkadel): Add unit tests for `BcbCounters` functions/algorithms.\n impl<'a> BcbCounters<'a> {\n     fn new(\n         coverage_counters: &'a mut CoverageCounters,"}, {"sha": "7f1dc3844b21dc2cc1481ba310a03a6f1e4e802c", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -127,7 +127,7 @@ pub const NESTED_INDENT: &str = \"    \";\n \n const RUSTC_COVERAGE_DEBUG_OPTIONS: &str = \"RUSTC_COVERAGE_DEBUG_OPTIONS\";\n \n-pub(crate) fn debug_options<'a>() -> &'a DebugOptions {\n+pub(super) fn debug_options<'a>() -> &'a DebugOptions {\n     static DEBUG_OPTIONS: SyncOnceCell<DebugOptions> = SyncOnceCell::new();\n \n     &DEBUG_OPTIONS.get_or_init(|| DebugOptions::from_env())\n@@ -136,7 +136,7 @@ pub(crate) fn debug_options<'a>() -> &'a DebugOptions {\n /// Parses and maintains coverage-specific debug options captured from the environment variable\n /// \"RUSTC_COVERAGE_DEBUG_OPTIONS\", if set.\n #[derive(Debug, Clone)]\n-pub(crate) struct DebugOptions {\n+pub(super) struct DebugOptions {\n     pub allow_unused_expressions: bool,\n     counter_format: ExpressionFormat,\n }\n@@ -250,7 +250,7 @@ impl Default for ExpressionFormat {\n ///\n /// `DebugCounters` supports a recursive rendering of `Expression` counters, so they can be\n /// presented as nested expressions such as `(bcb3 - (bcb0 + bcb1))`.\n-pub(crate) struct DebugCounters {\n+pub(super) struct DebugCounters {\n     some_counters: Option<FxHashMap<ExpressionOperandId, DebugCounter>>,\n }\n \n@@ -386,7 +386,7 @@ impl DebugCounter {\n \n /// If enabled, this data structure captures additional debugging information used when generating\n /// a Graphviz (.dot file) representation of the `CoverageGraph`, for debugging purposes.\n-pub(crate) struct GraphvizData {\n+pub(super) struct GraphvizData {\n     some_bcb_to_coverage_spans_with_counters:\n         Option<FxHashMap<BasicCoverageBlock, Vec<(CoverageSpan, CoverageKind)>>>,\n     some_bcb_to_dependency_counters: Option<FxHashMap<BasicCoverageBlock, Vec<CoverageKind>>>,\n@@ -496,7 +496,7 @@ impl GraphvizData {\n /// directly or indirectly, to compute the coverage counts for all `CoverageSpan`s, and any that are\n /// _not_ used are retained in the `unused_expressions` Vec, to be included in debug output (logs\n /// and/or a `CoverageGraph` graphviz output).\n-pub(crate) struct UsedExpressions {\n+pub(super) struct UsedExpressions {\n     some_used_expression_operands:\n         Option<FxHashMap<ExpressionOperandId, Vec<InjectedExpressionId>>>,\n     some_unused_expressions:\n@@ -626,7 +626,7 @@ impl UsedExpressions {\n }\n \n /// Generates the MIR pass `CoverageSpan`-specific spanview dump file.\n-pub(crate) fn dump_coverage_spanview(\n+pub(super) fn dump_coverage_spanview(\n     tcx: TyCtxt<'tcx>,\n     mir_body: &mir::Body<'tcx>,\n     basic_coverage_blocks: &CoverageGraph,\n@@ -666,7 +666,7 @@ fn span_viewables(\n }\n \n /// Generates the MIR pass coverage-specific graphviz dump file.\n-pub(crate) fn dump_coverage_graphviz(\n+pub(super) fn dump_coverage_graphviz(\n     tcx: TyCtxt<'tcx>,\n     mir_body: &mir::Body<'tcx>,\n     pass_name: &str,\n@@ -815,7 +815,7 @@ fn bcb_to_string_sections(\n \n /// Returns a simple string representation of a `TerminatorKind` variant, indenpendent of any\n /// values it might hold.\n-pub(crate) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n+pub(super) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n     match kind {\n         TerminatorKind::Goto { .. } => \"Goto\",\n         TerminatorKind::SwitchInt { .. } => \"SwitchInt\","}, {"sha": "9d375633dcf5108ce083c10abeb5996efe3c5e17", "filename": "compiler/rustc_mir/src/transform/coverage/graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -17,7 +17,8 @@ const ID_SEPARATOR: &str = \",\";\n /// `CoverageKind` counter (to be added by `CoverageCounters::make_bcb_counters`), and an optional\n /// set of additional counters--if needed--to count incoming edges, if there are more than one.\n /// (These \"edge counters\" are eventually converted into new MIR `BasicBlock`s.)\n-pub(crate) struct CoverageGraph {\n+#[derive(Debug)]\n+pub(super) struct CoverageGraph {\n     bcbs: IndexVec<BasicCoverageBlock, BasicCoverageBlockData>,\n     bb_to_bcb: IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n     pub successors: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n@@ -275,7 +276,7 @@ impl graph::WithPredecessors for CoverageGraph {\n \n rustc_index::newtype_index! {\n     /// A node in the [control-flow graph][CFG] of CoverageGraph.\n-    pub(crate) struct BasicCoverageBlock {\n+    pub(super) struct BasicCoverageBlock {\n         DEBUG_FORMAT = \"bcb{}\",\n     }\n }\n@@ -305,7 +306,7 @@ rustc_index::newtype_index! {\n /// queries (`is_dominated_by()`, `predecessors`, `successors`, etc.) have branch (control flow)\n /// significance.\n #[derive(Debug, Clone)]\n-pub(crate) struct BasicCoverageBlockData {\n+pub(super) struct BasicCoverageBlockData {\n     pub basic_blocks: Vec<BasicBlock>,\n     pub counter_kind: Option<CoverageKind>,\n     edge_from_bcbs: Option<FxHashMap<BasicCoverageBlock, CoverageKind>>,\n@@ -431,7 +432,7 @@ impl BasicCoverageBlockData {\n /// the specific branching BCB, representing the edge between the two. The latter case\n /// distinguishes this incoming edge from other incoming edges to the same `target_bcb`.\n #[derive(Clone, Copy, PartialEq, Eq)]\n-pub(crate) struct BcbBranch {\n+pub(super) struct BcbBranch {\n     pub edge_from_bcb: Option<BasicCoverageBlock>,\n     pub target_bcb: BasicCoverageBlock,\n }\n@@ -498,9 +499,8 @@ fn bcb_filtered_successors<'a, 'tcx>(\n /// Maintains separate worklists for each loop in the BasicCoverageBlock CFG, plus one for the\n /// CoverageGraph outside all loops. This supports traversing the BCB CFG in a way that\n /// ensures a loop is completely traversed before processing Blocks after the end of the loop.\n-// FIXME(richkadel): Add unit tests for TraversalContext.\n #[derive(Debug)]\n-pub(crate) struct TraversalContext {\n+pub(super) struct TraversalContext {\n     /// From one or more backedges returning to a loop header.\n     pub loop_backedges: Option<(Vec<BasicCoverageBlock>, BasicCoverageBlock)>,\n \n@@ -510,7 +510,7 @@ pub(crate) struct TraversalContext {\n     pub worklist: Vec<BasicCoverageBlock>,\n }\n \n-pub(crate) struct TraverseCoverageGraphWithLoops {\n+pub(super) struct TraverseCoverageGraphWithLoops {\n     pub backedges: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n     pub context_stack: Vec<TraversalContext>,\n     visited: BitSet<BasicCoverageBlock>,\n@@ -642,7 +642,7 @@ impl TraverseCoverageGraphWithLoops {\n     }\n }\n \n-fn find_loop_backedges(\n+pub(super) fn find_loop_backedges(\n     basic_coverage_blocks: &CoverageGraph,\n ) -> IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>> {\n     let num_bcbs = basic_coverage_blocks.num_nodes();"}, {"sha": "192bb6680e42014b643248944c8d79903639288a", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -5,6 +5,9 @@ mod debug;\n mod graph;\n mod spans;\n \n+#[cfg(test)]\n+mod tests;\n+\n use counters::CoverageCounters;\n use graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph};\n use spans::{CoverageSpan, CoverageSpans};\n@@ -31,7 +34,7 @@ use rustc_span::{CharPos, Pos, SourceFile, Span, Symbol};\n \n /// A simple error message wrapper for `coverage::Error`s.\n #[derive(Debug)]\n-pub(crate) struct Error {\n+struct Error {\n     message: String,\n }\n "}, {"sha": "95c49922262f628fb82f726cac1b4cf0b8b58201", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -17,7 +17,7 @@ use rustc_span::{BytePos, Span, SyntaxContext};\n use std::cmp::Ordering;\n \n #[derive(Debug, Copy, Clone)]\n-pub(crate) enum CoverageStatement {\n+pub(super) enum CoverageStatement {\n     Statement(BasicBlock, Span, usize),\n     Terminator(BasicBlock, Span),\n }\n@@ -66,7 +66,7 @@ impl CoverageStatement {\n /// or is subsumed by the `Span` associated with this `CoverageSpan`, and it's `BasicBlock`\n /// `is_dominated_by()` the `BasicBlock`s in this `CoverageSpan`.\n #[derive(Debug, Clone)]\n-pub(crate) struct CoverageSpan {\n+pub(super) struct CoverageSpan {\n     pub span: Span,\n     pub bcb: BasicCoverageBlock,\n     pub coverage_statements: Vec<CoverageStatement>,\n@@ -214,7 +214,7 @@ pub struct CoverageSpans<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n-    pub(crate) fn generate_coverage_spans(\n+    pub(super) fn generate_coverage_spans(\n         mir_body: &'a mir::Body<'tcx>,\n         body_span: Span,\n         basic_coverage_blocks: &'a CoverageGraph,\n@@ -645,7 +645,10 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n }\n \n-fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> Option<Span> {\n+pub(super) fn filtered_statement_span(\n+    statement: &'a Statement<'tcx>,\n+    body_span: Span,\n+) -> Option<Span> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -686,7 +689,10 @@ fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> O\n     }\n }\n \n-fn filtered_terminator_span(terminator: &'a Terminator<'tcx>, body_span: Span) -> Option<Span> {\n+pub(super) fn filtered_terminator_span(\n+    terminator: &'a Terminator<'tcx>,\n+    body_span: Span,\n+) -> Option<Span> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from"}, {"sha": "a9d6f0c803d2e2de2ff3c822663dccbcd2416b55", "filename": "compiler/rustc_mir/src/transform/coverage/test_macros/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"coverage_test_macros\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+proc-macro = true\n+doctest = false\n+\n+[dependencies]\n+proc-macro2 = \"1\""}, {"sha": "3d6095d2738cb562deecb28361595667663d888b", "filename": "compiler/rustc_mir/src/transform/coverage/test_macros/src/lib.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,6 @@\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn let_bcb(item: TokenStream) -> TokenStream {\n+    format!(\"let bcb{} = graph::BasicCoverageBlock::from_usize({});\", item, item).parse().unwrap()\n+}"}, {"sha": "d36f1b8e5f6705e92e5c472c3fe1e6cc5bf82ba1", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "added", "additions": 714, "deletions": 0, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,714 @@\n+//! This crate hosts a selection of \"unit tests\" for components of the `InstrumentCoverage` MIR\n+//! pass.\n+//!\n+//! The tests construct a few \"mock\" objects, as needed, to support the `InstrumentCoverage`\n+//! functions and algorithms. Mocked objects include instances of `mir::Body`; including\n+//! `Terminator`s of various `kind`s, and `Span` objects. Some functions used by or used on\n+//! real, runtime versions of these mocked-up objects have constraints (such as cross-thread\n+//! limitations) and deep dependencies on other elements of the full Rust compiler (which is\n+//! *not* constructed or mocked for these tests).\n+//!\n+//! Of particular note, attempting to simply print elements of the `mir::Body` with default\n+//! `Debug` formatting can fail because some `Debug` format implementations require the\n+//! `TyCtxt`, obtained via a static global variable that is *not* set for these tests.\n+//! Initializing the global type context is prohibitively complex for the scope and scale of these\n+//! tests (essentially requiring initializing the entire compiler).\n+//!\n+//! Also note, some basic features of `Span` also rely on the `Span`s own \"session globals\", which\n+//! are unrelated to the `TyCtxt` global. Without initializing the `Span` session globals, some\n+//! basic, coverage-specific features would be impossible to test, but thankfully initializing these\n+//! globals is comparitively simpler. The easiest way is to wrap the test in a closure argument\n+//! to: `rustc_span::with_default_session_globals(|| { test_here(); })`.\n+\n+use super::counters;\n+use super::debug;\n+use super::graph;\n+use super::spans;\n+\n+use coverage_test_macros::let_bcb;\n+\n+use rustc_data_structures::graph::WithNumNodes;\n+use rustc_data_structures::graph::WithSuccessors;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::mir::coverage::CoverageKind;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, DebruijnIndex, TyS, TypeFlags};\n+use rustc_span::{self, BytePos, Pos, Span, DUMMY_SP};\n+\n+// All `TEMP_BLOCK` targets should be replaced before calling `to_body() -> mir::Body`.\n+const TEMP_BLOCK: BasicBlock = BasicBlock::MAX;\n+\n+fn dummy_ty() -> &'static TyS<'static> {\n+    thread_local! {\n+        static DUMMY_TYS: &'static TyS<'static> = Box::leak(box TyS::make_for_test(\n+            ty::Bool,\n+            TypeFlags::empty(),\n+            DebruijnIndex::from_usize(0),\n+        ));\n+    }\n+\n+    &DUMMY_TYS.with(|tys| *tys)\n+}\n+\n+struct MockBlocks<'tcx> {\n+    blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    dummy_place: Place<'tcx>,\n+    next_local: usize,\n+}\n+\n+impl<'tcx> MockBlocks<'tcx> {\n+    fn new() -> Self {\n+        Self {\n+            blocks: IndexVec::new(),\n+            dummy_place: Place { local: RETURN_PLACE, projection: ty::List::empty() },\n+            next_local: 0,\n+        }\n+    }\n+\n+    fn new_temp(&mut self) -> Local {\n+        let index = self.next_local;\n+        self.next_local += 1;\n+        Local::new(index)\n+    }\n+\n+    fn push(&mut self, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+        let next_lo = if let Some(last) = self.blocks.last() {\n+            self.blocks[last].terminator().source_info.span.hi()\n+        } else {\n+            BytePos(1)\n+        };\n+        let next_hi = next_lo + BytePos(1);\n+        self.blocks.push(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                source_info: SourceInfo::outermost(Span::with_root_ctxt(next_lo, next_hi)),\n+                kind,\n+            }),\n+            is_cleanup: false,\n+        })\n+    }\n+\n+    fn link(&mut self, from_block: BasicBlock, to_block: BasicBlock) {\n+        match self.blocks[from_block].terminator_mut().kind {\n+            TerminatorKind::Assert { ref mut target, .. }\n+            | TerminatorKind::Call { destination: Some((_, ref mut target)), .. }\n+            | TerminatorKind::Drop { ref mut target, .. }\n+            | TerminatorKind::DropAndReplace { ref mut target, .. }\n+            | TerminatorKind::FalseEdge { real_target: ref mut target, .. }\n+            | TerminatorKind::FalseUnwind { real_target: ref mut target, .. }\n+            | TerminatorKind::Goto { ref mut target }\n+            | TerminatorKind::InlineAsm { destination: Some(ref mut target), .. }\n+            | TerminatorKind::Yield { resume: ref mut target, .. } => *target = to_block,\n+            ref invalid => bug!(\"Invalid from_block: {:?}\", invalid),\n+        }\n+    }\n+\n+    fn add_block_from(\n+        &mut self,\n+        some_from_block: Option<BasicBlock>,\n+        to_kind: TerminatorKind<'tcx>,\n+    ) -> BasicBlock {\n+        let new_block = self.push(to_kind);\n+        if let Some(from_block) = some_from_block {\n+            self.link(from_block, new_block);\n+        }\n+        new_block\n+    }\n+\n+    fn set_branch(&mut self, switchint: BasicBlock, branch_index: usize, to_block: BasicBlock) {\n+        match self.blocks[switchint].terminator_mut().kind {\n+            TerminatorKind::SwitchInt { ref mut targets, .. } => {\n+                let mut branches = targets.iter().collect::<Vec<_>>();\n+                let otherwise = if branch_index == branches.len() {\n+                    to_block\n+                } else {\n+                    let old_otherwise = targets.otherwise();\n+                    if branch_index > branches.len() {\n+                        branches.push((branches.len() as u128, old_otherwise));\n+                        while branches.len() < branch_index {\n+                            branches.push((branches.len() as u128, TEMP_BLOCK));\n+                        }\n+                        to_block\n+                    } else {\n+                        branches[branch_index] = (branch_index as u128, to_block);\n+                        old_otherwise\n+                    }\n+                };\n+                *targets = SwitchTargets::new(branches.into_iter(), otherwise);\n+            }\n+            ref invalid => bug!(\"Invalid BasicBlock kind or no to_block: {:?}\", invalid),\n+        }\n+    }\n+\n+    fn call(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(\n+            some_from_block,\n+            TerminatorKind::Call {\n+                func: Operand::Copy(self.dummy_place.clone()),\n+                args: vec![],\n+                destination: Some((self.dummy_place.clone(), TEMP_BLOCK)),\n+                cleanup: None,\n+                from_hir_call: false,\n+                fn_span: DUMMY_SP,\n+            },\n+        )\n+    }\n+\n+    fn goto(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(some_from_block, TerminatorKind::Goto { target: TEMP_BLOCK })\n+    }\n+\n+    fn switchint(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        let switchint_kind = TerminatorKind::SwitchInt {\n+            discr: Operand::Move(Place::from(self.new_temp())),\n+            switch_ty: dummy_ty(),\n+            targets: SwitchTargets::static_if(0, TEMP_BLOCK, TEMP_BLOCK),\n+        };\n+        self.add_block_from(some_from_block, switchint_kind)\n+    }\n+\n+    fn return_(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(some_from_block, TerminatorKind::Return)\n+    }\n+\n+    fn to_body(self) -> Body<'tcx> {\n+        Body::new_cfg_only(self.blocks)\n+    }\n+}\n+\n+fn debug_basic_blocks(mir_body: &Body<'tcx>) -> String {\n+    format!(\n+        \"{:?}\",\n+        mir_body\n+            .basic_blocks()\n+            .iter_enumerated()\n+            .map(|(bb, data)| {\n+                let term = &data.terminator();\n+                let kind = &term.kind;\n+                let span = term.source_info.span;\n+                let sp = format!(\"(span:{},{})\", span.lo().to_u32(), span.hi().to_u32());\n+                match kind {\n+                    TerminatorKind::Assert { target, .. }\n+                    | TerminatorKind::Call { destination: Some((_, target)), .. }\n+                    | TerminatorKind::Drop { target, .. }\n+                    | TerminatorKind::DropAndReplace { target, .. }\n+                    | TerminatorKind::FalseEdge { real_target: target, .. }\n+                    | TerminatorKind::FalseUnwind { real_target: target, .. }\n+                    | TerminatorKind::Goto { target }\n+                    | TerminatorKind::InlineAsm { destination: Some(target), .. }\n+                    | TerminatorKind::Yield { resume: target, .. } => {\n+                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, debug::term_type(kind), target)\n+                    }\n+                    TerminatorKind::SwitchInt { targets, .. } => {\n+                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, debug::term_type(kind), targets)\n+                    }\n+                    _ => format!(\"{}{:?}:{}\", sp, bb, debug::term_type(kind)),\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+    )\n+}\n+\n+static PRINT_GRAPHS: bool = false;\n+\n+fn print_mir_graphviz(name: &str, mir_body: &Body<'_>) {\n+    if PRINT_GRAPHS {\n+        println!(\n+            \"digraph {} {{\\n{}\\n}}\",\n+            name,\n+            mir_body\n+                .basic_blocks()\n+                .iter_enumerated()\n+                .map(|(bb, data)| {\n+                    format!(\n+                        \"    {:?} [label=\\\"{:?}: {}\\\"];\\n{}\",\n+                        bb,\n+                        bb,\n+                        debug::term_type(&data.terminator().kind),\n+                        mir_body\n+                            .successors(bb)\n+                            .map(|successor| { format!(\"    {:?} -> {:?};\", bb, successor) })\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\")\n+                    )\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+        );\n+    }\n+}\n+\n+fn print_coverage_graphviz(\n+    name: &str,\n+    mir_body: &Body<'_>,\n+    basic_coverage_blocks: &graph::CoverageGraph,\n+) {\n+    if PRINT_GRAPHS {\n+        println!(\n+            \"digraph {} {{\\n{}\\n}}\",\n+            name,\n+            basic_coverage_blocks\n+                .iter_enumerated()\n+                .map(|(bcb, bcb_data)| {\n+                    format!(\n+                        \"    {:?} [label=\\\"{:?}: {}\\\"];\\n{}\",\n+                        bcb,\n+                        bcb,\n+                        debug::term_type(&bcb_data.terminator(mir_body).kind),\n+                        basic_coverage_blocks\n+                            .successors(bcb)\n+                            .map(|successor| { format!(\"    {:?} -> {:?};\", bcb, successor) })\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\")\n+                    )\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+        );\n+    }\n+}\n+\n+/// Create a mock `Body` with a simple flow.\n+fn goto_switchint() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let goto = blocks.goto(Some(start));\n+    let switchint = blocks.switchint(Some(goto));\n+    let then_call = blocks.call(None);\n+    let else_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    blocks.set_branch(switchint, 1, else_call);\n+    blocks.return_(Some(then_call));\n+    blocks.return_(Some(else_call));\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_goto_switchint\", &mir_body);\n+    /* Graphviz character plots created using: `graph-easy --as=boxart`:\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb1: Goto    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502  bb4: Call  \u2502 \u25c0\u2500\u2500 \u2502 bb2: SwitchInt \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                   \u2502\n+      \u2502                   \u2502\n+      \u25bc                   \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb6: Return \u2502     \u2502   bb3: Call    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502  bb5: Return   \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+macro_rules! assert_successors {\n+    ($basic_coverage_blocks:ident, $i:ident, [$($successor:ident),*]) => {\n+        let mut successors = $basic_coverage_blocks.successors[$i].clone();\n+        successors.sort_unstable();\n+        assert_eq!(successors, vec![$($successor),*]);\n+    }\n+}\n+\n+#[test]\n+fn test_covgraph_goto_switchint() {\n+    let mir_body = goto_switchint();\n+    if false {\n+        println!(\"basic_blocks = {}\", debug_basic_blocks(&mir_body));\n+    }\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\"covgraph_goto_switchint \", &mir_body, &basic_coverage_blocks);\n+    /*\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb2: Return \u2502 \u25c0\u2500\u2500 \u2502 bcb0: SwitchInt \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                           \u2502\n+                           \u2502\n+                           \u25bc\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                         \u2502  bcb1: Return   \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        3,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1, bcb2]);\n+    assert_successors!(basic_coverage_blocks, bcb1, []);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+}\n+\n+/// Create a mock `Body` with a loop.\n+fn switchint_then_loop_else_return() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let switchint = blocks.switchint(Some(start));\n+    let then_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    let backedge_goto = blocks.goto(Some(then_call));\n+    blocks.link(backedge_goto, switchint);\n+    let else_return = blocks.return_(None);\n+    blocks.set_branch(switchint, 1, else_return);\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_switchint_then_loop_else_return\", &mir_body);\n+    /*\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb4: Return \u2502 \u25c0\u2500\u2500 \u2502 bb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                          \u2502                 \u2502\n+                          \u2502                 \u2502\n+                          \u25bc                 \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                        \u2502   bb2: Call    \u2502  \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                          \u2502                 \u2502\n+                          \u2502                 \u2502\n+                          \u25bc                 \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                        \u2502   bb3: Goto    \u2502 \u2500\u2518\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+#[test]\n+fn test_covgraph_switchint_then_loop_else_return() {\n+    let mir_body = switchint_then_loop_else_return();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\n+        \"covgraph_switchint_then_loop_else_return\",\n+        &mir_body,\n+        &basic_coverage_blocks,\n+    );\n+    /*\n+                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                       \u2502   bcb0: Call    \u2502\n+                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                         \u2502\n+                         \u2502\n+                         \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb3: Goto \u2502 \u25c0\u2500\u2500 \u2502 bcb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+      \u2502                  \u2502                  \u2502\n+      \u2502                  \u2502                  \u2502\n+      \u2502                  \u25bc                  \u2502\n+      \u2502                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+      \u2502                \u2502  bcb2: Return   \u2502  \u2502\n+      \u2502                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+      \u2502                                     \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        4,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+    let_bcb!(3);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+    assert_successors!(basic_coverage_blocks, bcb3, [bcb1]);\n+}\n+\n+/// Create a mock `Body` with nested loops.\n+fn switchint_loop_then_inner_loop_else_break() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let switchint = blocks.switchint(Some(start));\n+    let then_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    let else_return = blocks.return_(None);\n+    blocks.set_branch(switchint, 1, else_return);\n+\n+    let inner_start = blocks.call(Some(then_call));\n+    let inner_switchint = blocks.switchint(Some(inner_start));\n+    let inner_then_call = blocks.call(None);\n+    blocks.set_branch(inner_switchint, 0, inner_then_call);\n+    let inner_backedge_goto = blocks.goto(Some(inner_then_call));\n+    blocks.link(inner_backedge_goto, inner_switchint);\n+    let inner_else_break_goto = blocks.goto(None);\n+    blocks.set_branch(inner_switchint, 1, inner_else_break_goto);\n+\n+    let backedge_goto = blocks.goto(Some(inner_else_break_goto));\n+    blocks.link(backedge_goto, switchint);\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_switchint_loop_then_inner_loop_else_break\", &mir_body);\n+    /*\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb3: Return \u2502 \u25c0\u2500\u2500 \u2502 bb1: SwitchInt \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+                        \u2502   bb2: Call    \u2502       \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+                        \u2502   bb4: Call    \u2502       \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+    \u2502  bb8: Goto  \u2502 \u25c0\u2500\u2500 \u2502 bb5: SwitchInt \u2502 \u25c0\u2510    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+      \u2502                   \u2502                 \u2502    \u2502\n+      \u2502                   \u2502                 \u2502    \u2502\n+      \u25bc                   \u25bc                 \u2502    \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+    \u2502  bb9: Goto  \u2502 \u2500\u2510  \u2502   bb6: Call    \u2502  \u2502    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+                     \u2502    \u2502                 \u2502    \u2502\n+                     \u2502    \u2502                 \u2502    \u2502\n+                     \u2502    \u25bc                 \u2502    \u2502\n+                     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+                     \u2502  \u2502   bb7: Goto    \u2502 \u2500\u2518    \u2502\n+                     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                     \u2502                           \u2502\n+                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+#[test]\n+fn test_covgraph_switchint_loop_then_inner_loop_else_break() {\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\n+        \"covgraph_switchint_loop_then_inner_loop_else_break\",\n+        &mir_body,\n+        &basic_coverage_blocks,\n+    );\n+    /*\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                         \u2502   bcb0: Call    \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                           \u2502\n+                           \u2502\n+                           \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb2: Return \u2502 \u25c0\u2500\u2500 \u2502 bcb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                           \u2502                  \u2502\n+                           \u2502                  \u2502\n+                           \u25bc                  \u2502\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                         \u2502   bcb3: Call    \u2502  \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                           \u2502                  \u2502\n+                           \u2502                  \u2502\n+                           \u25bc                  \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+    \u2502  bcb6: Goto  \u2502 \u25c0\u2500\u2500 \u2502 bcb4: SwitchInt \u2502 \u25c0\u253c\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+      \u2502                    \u2502                  \u2502    \u2502\n+      \u2502                    \u2502                  \u2502    \u2502\n+      \u2502                    \u25bc                  \u2502    \u2502\n+      \u2502                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+      \u2502                  \u2502   bcb5: Goto    \u2502 \u2500\u2518    \u2502\n+      \u2502                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+      \u2502                                            \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        7,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+    let_bcb!(3);\n+    let_bcb!(4);\n+    let_bcb!(5);\n+    let_bcb!(6);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+    assert_successors!(basic_coverage_blocks, bcb3, [bcb4]);\n+    assert_successors!(basic_coverage_blocks, bcb4, [bcb5, bcb6]);\n+    assert_successors!(basic_coverage_blocks, bcb5, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb6, [bcb4]);\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_none() {\n+    let mir_body = goto_switchint();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    if false {\n+        println!(\n+            \"basic_coverage_blocks = {:?}\",\n+            basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+        );\n+        println!(\"successors = {:?}\", basic_coverage_blocks.successors);\n+    }\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        0,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_one() {\n+    let mir_body = switchint_then_loop_else_return();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        1,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+\n+    let_bcb!(1);\n+    let_bcb!(3);\n+\n+    assert_eq!(backedges[bcb1], vec![bcb3]);\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_two() {\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        2,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+\n+    let_bcb!(1);\n+    let_bcb!(4);\n+    let_bcb!(5);\n+    let_bcb!(6);\n+\n+    assert_eq!(backedges[bcb1], vec![bcb5]);\n+    assert_eq!(backedges[bcb4], vec![bcb6]);\n+}\n+\n+#[test]\n+fn test_traverse_coverage_with_loops() {\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    let mut traversed_in_order = Vec::new();\n+    let mut traversal = graph::TraverseCoverageGraphWithLoops::new(&basic_coverage_blocks);\n+    while let Some(bcb) = traversal.next(&basic_coverage_blocks) {\n+        traversed_in_order.push(bcb);\n+    }\n+\n+    let_bcb!(6);\n+\n+    // bcb0 is visited first. Then bcb1 starts the first loop, and all remaining nodes, *except*\n+    // bcb6 are inside the first loop.\n+    assert_eq!(\n+        *traversed_in_order.last().expect(\"should have elements\"),\n+        bcb6,\n+        \"bcb6 should not be visited until all nodes inside the first loop have been visited\"\n+    );\n+}\n+\n+fn synthesize_body_span_from_terminators(mir_body: &Body<'_>) -> Span {\n+    let mut some_span: Option<Span> = None;\n+    for (_, data) in mir_body.basic_blocks().iter_enumerated() {\n+        let term_span = data.terminator().source_info.span;\n+        if let Some(span) = some_span.as_mut() {\n+            *span = span.to(term_span);\n+        } else {\n+            some_span = Some(term_span)\n+        }\n+    }\n+    some_span.expect(\"body must have at least one BasicBlock\")\n+}\n+\n+#[test]\n+fn test_make_bcb_counters() {\n+    rustc_span::with_default_session_globals(|| {\n+        let mir_body = goto_switchint();\n+        let body_span = synthesize_body_span_from_terminators(&mir_body);\n+        let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+        let mut coverage_spans = Vec::new();\n+        for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n+            if let Some(span) =\n+                spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n+            {\n+                coverage_spans.push(spans::CoverageSpan::for_terminator(span, bcb, data.last_bb()));\n+            }\n+        }\n+        let mut coverage_counters = counters::CoverageCounters::new(0);\n+        let intermediate_expressions = coverage_counters\n+            .make_bcb_counters(&mut basic_coverage_blocks, &coverage_spans)\n+            .expect(\"should be Ok\");\n+        assert_eq!(intermediate_expressions.len(), 0);\n+\n+        let_bcb!(1);\n+        assert_eq!(\n+            1, // coincidentally, bcb1 has a `Counter` with id = 1\n+            match basic_coverage_blocks[bcb1].counter().expect(\"should have a counter\") {\n+                CoverageKind::Counter { id, .. } => id,\n+                _ => panic!(\"expected a Counter\"),\n+            }\n+            .as_u32()\n+        );\n+\n+        let_bcb!(2);\n+        assert_eq!(\n+            2, // coincidentally, bcb2 has a `Counter` with id = 2\n+            match basic_coverage_blocks[bcb2].counter().expect(\"should have a counter\") {\n+                CoverageKind::Counter { id, .. } => id,\n+                _ => panic!(\"expected a Counter\"),\n+            }\n+            .as_u32()\n+        );\n+    });\n+}"}, {"sha": "aae98f5b6d8d691a1091b95814568e5f875cb06d", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -7,6 +7,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ConstKind, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_span::{hygiene::ExpnKind, ExpnData, Span};\n use rustc_target::spec::abi::Abi;\n@@ -28,6 +29,7 @@ pub struct Inline;\n #[derive(Copy, Clone, Debug)]\n struct CallSite<'tcx> {\n     callee: Instance<'tcx>,\n+    fn_sig: ty::PolyFnSig<'tcx>,\n     block: BasicBlock,\n     target: Option<BasicBlock>,\n     source_info: SourceInfo,\n@@ -173,22 +175,23 @@ impl Inliner<'tcx> {\n \n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n-        if let TerminatorKind::Call { func: ref op, ref destination, .. } = terminator.kind {\n-            if let ty::FnDef(callee_def_id, substs) = *op.ty(caller_body, self.tcx).kind() {\n-                // To resolve an instance its substs have to be fully normalized, so\n-                // we do this here.\n-                let normalized_substs = self.tcx.normalize_erasing_regions(self.param_env, substs);\n+        if let TerminatorKind::Call { ref func, ref destination, .. } = terminator.kind {\n+            let func_ty = func.ty(caller_body, self.tcx);\n+            if let ty::FnDef(def_id, substs) = *func_ty.kind() {\n+                // To resolve an instance its substs have to be fully normalized.\n+                let substs = self.tcx.normalize_erasing_regions(self.param_env, substs);\n                 let callee =\n-                    Instance::resolve(self.tcx, self.param_env, callee_def_id, normalized_substs)\n-                        .ok()\n-                        .flatten()?;\n+                    Instance::resolve(self.tcx, self.param_env, def_id, substs).ok().flatten()?;\n \n                 if let InstanceDef::Virtual(..) | InstanceDef::Intrinsic(_) = callee.def {\n                     return None;\n                 }\n \n+                let fn_sig = self.tcx.fn_sig(def_id).subst(self.tcx, substs);\n+\n                 return Some(CallSite {\n                     callee,\n+                    fn_sig,\n                     block: bb,\n                     target: destination.map(|(_, target)| target),\n                     source_info: terminator.source_info,\n@@ -203,9 +206,8 @@ impl Inliner<'tcx> {\n         debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n \n-        // Cannot inline generators which haven't been transformed yet\n-        if callee_body.yield_ty.is_some() {\n-            debug!(\"    yield ty present - not inlining\");\n+        if callsite.fn_sig.c_variadic() {\n+            debug!(\"callee is variadic - not inlining\");\n             return false;\n         }\n \n@@ -218,11 +220,7 @@ impl Inliner<'tcx> {\n             return false;\n         }\n \n-        let self_no_sanitize =\n-            self.codegen_fn_attrs.no_sanitize & self.tcx.sess.opts.debugging_opts.sanitizer;\n-        let callee_no_sanitize =\n-            codegen_fn_attrs.no_sanitize & self.tcx.sess.opts.debugging_opts.sanitizer;\n-        if self_no_sanitize != callee_no_sanitize {\n+        if self.codegen_fn_attrs.no_sanitize != codegen_fn_attrs.no_sanitize {\n             debug!(\"`callee has incompatible no_sanitize attribute - not inlining\");\n             return false;\n         }\n@@ -256,9 +254,9 @@ impl Inliner<'tcx> {\n             self.tcx.sess.opts.debugging_opts.inline_mir_threshold\n         };\n \n-        // Significantly lower the threshold for inlining cold functions\n         if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n-            threshold /= 5;\n+            debug!(\"#[cold] present - not inlining\");\n+            return false;\n         }\n \n         // Give a bonus functions with a small number of blocks,\n@@ -447,7 +445,7 @@ impl Inliner<'tcx> {\n                 };\n \n                 // Copy the arguments if needed.\n-                let args: Vec<_> = self.make_call_args(args, &callsite, caller_body);\n+                let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, &callee_body);\n \n                 let mut integrator = Integrator {\n                     args: &args,\n@@ -528,6 +526,7 @@ impl Inliner<'tcx> {\n         args: Vec<Operand<'tcx>>,\n         callsite: &CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n+        callee_body: &Body<'tcx>,\n     ) -> Vec<Local> {\n         let tcx = self.tcx;\n \n@@ -554,9 +553,7 @@ impl Inliner<'tcx> {\n         //     tmp2 = tuple_tmp.2\n         //\n         // and the vector is `[closure_ref, tmp0, tmp1, tmp2]`.\n-        // FIXME(eddyb) make this check for `\"rust-call\"` ABI combined with\n-        // `callee_body.spread_arg == None`, instead of special-casing closures.\n-        if tcx.is_closure(callsite.callee.def_id()) {\n+        if callsite.fn_sig.abi() == Abi::RustCall && callee_body.spread_arg.is_none() {\n             let mut args = args.into_iter();\n             let self_ = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n             let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);"}, {"sha": "876ecee80c6a1222b17a3ba799914e0a5724770f", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -38,7 +38,9 @@ pub struct Validator {\n impl<'tcx> MirPass<'tcx> for Validator {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = body.source.def_id();\n-        let param_env = tcx.param_env(def_id);\n+        // We need to param_env_reveal_all_normalized, as some optimizations\n+        // change types in ways that require unfolding opaque types.\n+        let param_env = tcx.param_env_reveal_all_normalized(def_id);\n         let mir_phase = self.mir_phase;\n \n         let always_live_locals = AlwaysLiveLocals::new(body);\n@@ -79,7 +81,6 @@ pub fn equal_up_to_regions(\n     }\n \n     // Normalize lifetimes away on both sides, then compare.\n-    let param_env = param_env.with_reveal_all_normalized(tcx);\n     let normalize = |ty: Ty<'tcx>| {\n         tcx.normalize_erasing_regions(\n             param_env,\n@@ -167,17 +168,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n         // Normalize projections and things like that.\n-        // FIXME: We need to reveal_all, as some optimizations change types in ways\n-        // that require unfolding opaque types.\n-        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n-        let src = self.tcx.normalize_erasing_regions(param_env, src);\n-        let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n+        let src = self.tcx.normalize_erasing_regions(self.param_env, src);\n+        let dest = self.tcx.normalize_erasing_regions(self.param_env, dest);\n \n         // Type-changing assignments can happen when subtyping is used. While\n         // all normal lifetimes are erased, higher-ranked types with their\n         // late-bound lifetimes are still around and can lead to type\n         // differences. So we compare ignoring lifetimes.\n-        equal_up_to_regions(self.tcx, param_env, src, dest)\n+        equal_up_to_regions(self.tcx, self.param_env, src, dest)\n     }\n }\n \n@@ -358,6 +356,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Call { func, args, destination, cleanup, .. } => {\n                 let func_ty = func.ty(&self.body.local_decls, self.tcx);\n+                let func_ty = self.tcx.normalize_erasing_regions(self.param_env, func_ty);\n                 match func_ty.kind() {\n                     ty::FnPtr(..) | ty::FnDef(..) => {}\n                     _ => self.fail("}, {"sha": "07173f41cd6db84fbea6be47ccf3d7f9d74b7809", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -671,6 +671,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             (&TestKind::Range { .. }, _) => None,\n \n             (&TestKind::Eq { .. } | &TestKind::Len { .. }, _) => {\n+                // The call to `self.test(&match_pair)` below is not actually used to generate any\n+                // MIR. Instead, we just want to compare with `test` (the parameter of the method)\n+                // to see if it is the same.\n+                //\n+                // However, at this point we can still encounter or-patterns that were extracted\n+                // from previous calls to `sort_candidate`, so we need to manually address that\n+                // case to avoid panicking in `self.test()`.\n+                if let PatKind::Or { .. } = &*match_pair.pattern.kind {\n+                    return None;\n+                }\n+\n                 // These are all binary tests.\n                 //\n                 // FIXME(#29623) we can be more clever here"}, {"sha": "2f82d0546ba98a88b2c48616514e46d902f67301", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -21,7 +21,7 @@\n // references.\n //\n // Signatures do not include visibility info. I'm not sure if this is a feature\n-// or an ommission (FIXME).\n+// or an omission (FIXME).\n //\n // FIXME where clauses need implementing, defs/refs in generics are mostly missing.\n \n@@ -677,7 +677,7 @@ impl<'hir> Sig for hir::Variant<'hir> {\n         let mut text = self.ident.to_string();\n         match self.data {\n             hir::VariantData::Struct(fields, r) => {\n-                let id = parent_id.unwrap();\n+                let id = parent_id.ok_or(\"Missing id for Variant's parent\")?;\n                 let name_def = SigElement {\n                     id: id_from_hir_id(id, scx),\n                     start: offset,"}, {"sha": "045da7963c5673bc2cb9701529b2b40d9d294f90", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -1444,8 +1444,8 @@ impl Target {\n         }\n \n         key!(is_builtin, bool);\n-        key!(endian = \"target_endian\");\n-        key!(c_int_width = \"target_c_int_width\");\n+        key!(endian = \"target-endian\");\n+        key!(c_int_width = \"target-c-int-width\");\n         key!(os);\n         key!(env);\n         key!(vendor);\n@@ -1482,7 +1482,7 @@ impl Target {\n         key!(exe_suffix);\n         key!(staticlib_prefix);\n         key!(staticlib_suffix);\n-        key!(os_family = \"target_family\", optional);\n+        key!(os_family = \"target-family\", optional);\n         key!(abi_return_struct_as_int, bool);\n         key!(is_like_osx, bool);\n         key!(is_like_solaris, bool);\n@@ -1527,7 +1527,7 @@ impl Target {\n         key!(limit_rdylib_exports, bool);\n         key!(override_export_symbols, opt_list);\n         key!(merge_functions, MergeFunctions)?;\n-        key!(mcount = \"target_mcount\");\n+        key!(mcount = \"target-mcount\");\n         key!(llvm_abiname);\n         key!(relax_elf_relocations, bool);\n         key!(llvm_args, list);\n@@ -1679,8 +1679,8 @@ impl ToJson for Target {\n         target_val!(data_layout);\n \n         target_option_val!(is_builtin);\n-        target_option_val!(endian, \"target_endian\");\n-        target_option_val!(c_int_width, \"target_c_int_width\");\n+        target_option_val!(endian, \"target-endian\");\n+        target_option_val!(c_int_width, \"target-c-int-width\");\n         target_option_val!(os);\n         target_option_val!(env);\n         target_option_val!(vendor);\n@@ -1717,7 +1717,7 @@ impl ToJson for Target {\n         target_option_val!(exe_suffix);\n         target_option_val!(staticlib_prefix);\n         target_option_val!(staticlib_suffix);\n-        target_option_val!(os_family, \"target_family\");\n+        target_option_val!(os_family, \"target-family\");\n         target_option_val!(abi_return_struct_as_int);\n         target_option_val!(is_like_osx);\n         target_option_val!(is_like_solaris);\n@@ -1762,7 +1762,7 @@ impl ToJson for Target {\n         target_option_val!(limit_rdylib_exports);\n         target_option_val!(override_export_symbols);\n         target_option_val!(merge_functions);\n-        target_option_val!(mcount, \"target_mcount\");\n+        target_option_val!(mcount, \"target-mcount\");\n         target_option_val!(llvm_abiname);\n         target_option_val!(relax_elf_relocations);\n         target_option_val!(llvm_args);"}, {"sha": "465b058cd98e9fed8c69b8fafadc08f980dbd246", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,57 @@\n+use core::fmt;\n+use core::iter::FusedIterator;\n+\n+use super::VecDeque;\n+\n+/// An owning iterator over the elements of a `VecDeque`.\n+///\n+/// This `struct` is created by the [`into_iter`] method on [`VecDeque`]\n+/// (provided by the `IntoIterator` trait). See its documentation for more.\n+///\n+/// [`into_iter`]: VecDeque::into_iter\n+#[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IntoIter<T> {\n+    pub(crate) inner: VecDeque<T>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"IntoIter\").field(&self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop_front()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.inner.len();\n+        (len, Some(len))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.pop_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for IntoIter<T> {\n+    fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for IntoIter<T> {}"}, {"sha": "ad31b991cb6c34f078c36232fa194c37812cf7ef", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,159 @@\n+use core::fmt;\n+use core::iter::FusedIterator;\n+use core::ops::Try;\n+\n+use super::{count, wrap_index, RingSlices};\n+\n+/// An iterator over the elements of a `VecDeque`.\n+///\n+/// This `struct` is created by the [`iter`] method on [`super::VecDeque`]. See its\n+/// documentation for more.\n+///\n+/// [`iter`]: super::VecDeque::iter\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Iter<'a, T: 'a> {\n+    pub(crate) ring: &'a [T],\n+    pub(crate) tail: usize,\n+    pub(crate) head: usize,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        f.debug_tuple(\"Iter\").field(&front).field(&back).finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Clone for Iter<'_, T> {\n+    fn clone(&self) -> Self {\n+        Iter { ring: self.ring, tail: self.tail, head: self.head }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+        unsafe { Some(self.ring.get_unchecked(tail)) }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = count(self.tail, self.head, self.ring.len());\n+        (len, Some(len))\n+    }\n+\n+    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = front.iter().fold(accum, &mut f);\n+        back.iter().fold(accum, &mut f)\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let (mut iter, final_res);\n+        if self.tail <= self.head {\n+            // single slice self.ring[self.tail..self.head]\n+            iter = self.ring[self.tail..self.head].iter();\n+            final_res = iter.try_fold(init, &mut f);\n+        } else {\n+            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            let (front, back) = self.ring.split_at(self.tail);\n+            let mut back_iter = back.iter();\n+            let res = back_iter.try_fold(init, &mut f);\n+            let len = self.ring.len();\n+            self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n+            iter = front[..self.head].iter();\n+            final_res = iter.try_fold(res?, &mut f);\n+        }\n+        self.tail = self.head - iter.len();\n+        final_res\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n+        unsafe { Some(self.ring.get_unchecked(self.head)) }\n+    }\n+\n+    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = back.iter().rfold(accum, &mut f);\n+        front.iter().rfold(accum, &mut f)\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let (mut iter, final_res);\n+        if self.tail <= self.head {\n+            // single slice self.ring[self.tail..self.head]\n+            iter = self.ring[self.tail..self.head].iter();\n+            final_res = iter.try_rfold(init, &mut f);\n+        } else {\n+            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            let (front, back) = self.ring.split_at(self.tail);\n+            let mut front_iter = front[..self.head].iter();\n+            let res = front_iter.try_rfold(init, &mut f);\n+            self.head = front_iter.len();\n+            iter = back.iter();\n+            final_res = iter.try_rfold(res?, &mut f);\n+        }\n+        self.head = self.tail + iter.len();\n+        final_res\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for Iter<'_, T> {\n+    fn is_empty(&self) -> bool {\n+        self.head == self.tail\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Iter<'_, T> {}"}, {"sha": "3d0c3094e26cd02d9cb6437cbc5e217684923bef", "filename": "library/alloc/src/collections/vec_deque/iter_mut.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,128 @@\n+use core::fmt;\n+use core::iter::FusedIterator;\n+use core::marker::PhantomData;\n+\n+use super::{count, wrap_index, RingSlices};\n+\n+/// A mutable iterator over the elements of a `VecDeque`.\n+///\n+/// This `struct` is created by the [`iter_mut`] method on [`super::VecDeque`]. See its\n+/// documentation for more.\n+///\n+/// [`iter_mut`]: super::VecDeque::iter_mut\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IterMut<'a, T: 'a> {\n+    // Internal safety invariant: the entire slice is dereferencable.\n+    pub(crate) ring: *mut [T],\n+    pub(crate) tail: usize,\n+    pub(crate) head: usize,\n+    pub(crate) phantom: PhantomData<&'a mut [T]>,\n+}\n+\n+// SAFETY: we do nothing thread-local and there is no interior mutability,\n+// so the usual structural `Send`/`Sync` apply.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send> Send for IterMut<'_, T> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&*front, &*back) };\n+        f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+\n+        unsafe {\n+            let elem = self.ring.get_unchecked_mut(tail);\n+            Some(&mut *elem)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = count(self.tail, self.head, self.ring.len());\n+        (len, Some(len))\n+    }\n+\n+    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&mut *front, &mut *back) };\n+        accum = front.iter_mut().fold(accum, &mut f);\n+        back.iter_mut().fold(accum, &mut f)\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut T> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n+\n+        unsafe {\n+            let elem = self.ring.get_unchecked_mut(self.head);\n+            Some(&mut *elem)\n+        }\n+    }\n+\n+    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&mut *front, &mut *back) };\n+        accum = back.iter_mut().rfold(accum, &mut f);\n+        front.iter_mut().rfold(accum, &mut f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for IterMut<'_, T> {\n+    fn is_empty(&self) -> bool {\n+        self.head == self.tail\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for IterMut<'_, T> {}"}, {"sha": "0d59d312cf406d35c224e88f27b6a748f3e54598", "filename": "library/alloc/src/collections/vec_deque/macros.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,19 @@\n+macro_rules! __impl_slice_eq1 {\n+    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n+        #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n+        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n+        where\n+            A: PartialEq<B>,\n+            $($constraints)*\n+        {\n+            fn eq(&self, other: &$rhs) -> bool {\n+                if self.len() != other.len() {\n+                    return false;\n+                }\n+                let (sa, sb) = self.as_slices();\n+                let (oa, ob) = other[..].split_at(sa.len());\n+                sa == oa && sb == ob\n+            }\n+        }\n+    }\n+}"}, {"sha": "1c183858e7a5e814554e2280568a78cd47ed9c85", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "renamed", "additions": 29, "deletions": 472, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -7,28 +7,51 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-// ignore-tidy-filelength\n-\n-use core::array;\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::iter::{repeat_with, FromIterator, FusedIterator};\n+use core::iter::{repeat_with, FromIterator};\n use core::marker::PhantomData;\n-use core::mem::{self, replace, ManuallyDrop};\n-use core::ops::{Index, IndexMut, Range, RangeBounds, Try};\n+use core::mem::{self, ManuallyDrop};\n+use core::ops::{Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice;\n \n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n+#[macro_use]\n+mod macros;\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub use self::drain::Drain;\n \n mod drain;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::iter_mut::IterMut;\n+\n+mod iter_mut;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::into_iter::IntoIter;\n+\n+mod into_iter;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::iter::Iter;\n+\n+mod iter;\n+\n+use self::pair_slices::PairSlices;\n+\n+mod pair_slices;\n+\n+use self::ring_slices::RingSlices;\n+\n+mod ring_slices;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -68,67 +91,6 @@ pub struct VecDeque<T> {\n     buf: RawVec<T>,\n }\n \n-/// PairSlices pairs up equal length slice parts of two deques\n-///\n-/// For example, given deques \"A\" and \"B\" with the following division into slices:\n-///\n-/// A: [0 1 2] [3 4 5]\n-/// B: [a b] [c d e]\n-///\n-/// It produces the following sequence of matching slices:\n-///\n-/// ([0 1], [a b])\n-/// (\\[2\\], \\[c\\])\n-/// ([3 4], [d e])\n-///\n-/// and the uneven remainder of either A or B is skipped.\n-struct PairSlices<'a, 'b, T> {\n-    a0: &'a mut [T],\n-    a1: &'a mut [T],\n-    b0: &'b [T],\n-    b1: &'b [T],\n-}\n-\n-impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n-    fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n-        let (a0, a1) = to.as_mut_slices();\n-        let (b0, b1) = from.as_slices();\n-        PairSlices { a0, a1, b0, b1 }\n-    }\n-\n-    fn has_remainder(&self) -> bool {\n-        !self.b0.is_empty()\n-    }\n-\n-    fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n-        array::IntoIter::new([self.b0, self.b1])\n-    }\n-}\n-\n-impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T> {\n-    type Item = (&'a mut [T], &'b [T]);\n-    fn next(&mut self) -> Option<Self::Item> {\n-        // Get next part length\n-        let part = cmp::min(self.a0.len(), self.b0.len());\n-        if part == 0 {\n-            return None;\n-        }\n-        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n-        let (q0, q1) = self.b0.split_at(part);\n-\n-        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n-        self.a0 = p1;\n-        self.b0 = q1;\n-        if self.a0.is_empty() {\n-            self.a0 = replace(&mut self.a1, &mut []);\n-        }\n-        if self.b0.is_empty() {\n-            self.b0 = replace(&mut self.b1, &[]);\n-        }\n-        Some((p0, q0))\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for VecDeque<T> {\n     fn clone(&self) -> VecDeque<T> {\n@@ -2605,398 +2567,13 @@ fn wrap_index(index: usize, size: usize) -> usize {\n     index & (size - 1)\n }\n \n-/// Returns the two slices that cover the `VecDeque`'s valid range\n-trait RingSlices: Sized {\n-    fn slice(self, from: usize, to: usize) -> Self;\n-    fn split_at(self, i: usize) -> (Self, Self);\n-\n-    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n-        let contiguous = tail <= head;\n-        if contiguous {\n-            let (empty, buf) = buf.split_at(0);\n-            (buf.slice(tail, head), empty)\n-        } else {\n-            let (mid, right) = buf.split_at(tail);\n-            let (left, _) = mid.split_at(head);\n-            (right, left)\n-        }\n-    }\n-}\n-\n-impl<T> RingSlices for &[T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        &self[from..to]\n-    }\n-    fn split_at(self, i: usize) -> (Self, Self) {\n-        (*self).split_at(i)\n-    }\n-}\n-\n-impl<T> RingSlices for &mut [T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        &mut self[from..to]\n-    }\n-    fn split_at(self, i: usize) -> (Self, Self) {\n-        (*self).split_at_mut(i)\n-    }\n-}\n-\n-impl<T> RingSlices for *mut [T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        assert!(from <= to && to < self.len());\n-        // Not using `get_unchecked_mut` to keep this a safe operation.\n-        let len = to - from;\n-        ptr::slice_from_raw_parts_mut(self.as_mut_ptr().wrapping_add(from), len)\n-    }\n-\n-    fn split_at(self, mid: usize) -> (Self, Self) {\n-        let len = self.len();\n-        let ptr = self.as_mut_ptr();\n-        assert!(mid <= len);\n-        (\n-            ptr::slice_from_raw_parts_mut(ptr, mid),\n-            ptr::slice_from_raw_parts_mut(ptr.wrapping_add(mid), len - mid),\n-        )\n-    }\n-}\n-\n /// Calculate the number of elements left to be read in the buffer\n #[inline]\n fn count(tail: usize, head: usize, size: usize) -> usize {\n     // size is always a power of 2\n     (head.wrapping_sub(tail)) & (size - 1)\n }\n \n-/// An iterator over the elements of a `VecDeque`.\n-///\n-/// This `struct` is created by the [`iter`] method on [`VecDeque`]. See its\n-/// documentation for more.\n-///\n-/// [`iter`]: VecDeque::iter\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T: 'a> {\n-    ring: &'a [T],\n-    tail: usize,\n-    head: usize,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        f.debug_tuple(\"Iter\").field(&front).field(&back).finish()\n-    }\n-}\n-\n-// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Iter<'_, T> {\n-    fn clone(&self) -> Self {\n-        Iter { ring: self.ring, tail: self.tail, head: self.head }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Iterator for Iter<'a, T> {\n-    type Item = &'a T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-        unsafe { Some(self.ring.get_unchecked(tail)) }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n-        (len, Some(len))\n-    }\n-\n-    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        accum = front.iter().fold(accum, &mut f);\n-        back.iter().fold(accum, &mut f)\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        let (mut iter, final_res);\n-        if self.tail <= self.head {\n-            // single slice self.ring[self.tail..self.head]\n-            iter = self.ring[self.tail..self.head].iter();\n-            final_res = iter.try_fold(init, &mut f);\n-        } else {\n-            // two slices: self.ring[self.tail..], self.ring[..self.head]\n-            let (front, back) = self.ring.split_at(self.tail);\n-            let mut back_iter = back.iter();\n-            let res = back_iter.try_fold(init, &mut f);\n-            let len = self.ring.len();\n-            self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n-            iter = front[..self.head].iter();\n-            final_res = iter.try_fold(res?, &mut f);\n-        }\n-        self.tail = self.head - iter.len();\n-        final_res\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        if n >= count(self.tail, self.head, self.ring.len()) {\n-            self.tail = self.head;\n-            None\n-        } else {\n-            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n-            self.next()\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a T> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-        unsafe { Some(self.ring.get_unchecked(self.head)) }\n-    }\n-\n-    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        accum = back.iter().rfold(accum, &mut f);\n-        front.iter().rfold(accum, &mut f)\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        let (mut iter, final_res);\n-        if self.tail <= self.head {\n-            // single slice self.ring[self.tail..self.head]\n-            iter = self.ring[self.tail..self.head].iter();\n-            final_res = iter.try_rfold(init, &mut f);\n-        } else {\n-            // two slices: self.ring[self.tail..], self.ring[..self.head]\n-            let (front, back) = self.ring.split_at(self.tail);\n-            let mut front_iter = front[..self.head].iter();\n-            let res = front_iter.try_rfold(init, &mut f);\n-            self.head = front_iter.len();\n-            iter = back.iter();\n-            final_res = iter.try_rfold(res?, &mut f);\n-        }\n-        self.head = self.tail + iter.len();\n-        final_res\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for Iter<'_, T> {\n-    fn is_empty(&self) -> bool {\n-        self.head == self.tail\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Iter<'_, T> {}\n-\n-/// A mutable iterator over the elements of a `VecDeque`.\n-///\n-/// This `struct` is created by the [`iter_mut`] method on [`VecDeque`]. See its\n-/// documentation for more.\n-///\n-/// [`iter_mut`]: VecDeque::iter_mut\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, T: 'a> {\n-    // Internal safety invariant: the entire slice is dereferencable.\n-    ring: *mut [T],\n-    tail: usize,\n-    head: usize,\n-    phantom: PhantomData<&'a mut [T]>,\n-}\n-\n-// SAFETY: we do nothing thread-local and there is no interior mutability,\n-// so the usual structural `Send`/`Sync` apply.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for IterMut<'_, T> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferencable.\n-        let (front, back) = unsafe { (&*front, &*back) };\n-        f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Iterator for IterMut<'a, T> {\n-    type Item = &'a mut T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-\n-        unsafe {\n-            let elem = self.ring.get_unchecked_mut(tail);\n-            Some(&mut *elem)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n-        (len, Some(len))\n-    }\n-\n-    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferencable.\n-        let (front, back) = unsafe { (&mut *front, &mut *back) };\n-        accum = front.iter_mut().fold(accum, &mut f);\n-        back.iter_mut().fold(accum, &mut f)\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        if n >= count(self.tail, self.head, self.ring.len()) {\n-            self.tail = self.head;\n-            None\n-        } else {\n-            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n-            self.next()\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a mut T> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-\n-        unsafe {\n-            let elem = self.ring.get_unchecked_mut(self.head);\n-            Some(&mut *elem)\n-        }\n-    }\n-\n-    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferencable.\n-        let (front, back) = unsafe { (&mut *front, &mut *back) };\n-        accum = back.iter_mut().rfold(accum, &mut f);\n-        front.iter_mut().rfold(accum, &mut f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IterMut<'_, T> {\n-    fn is_empty(&self) -> bool {\n-        self.head == self.tail\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IterMut<'_, T> {}\n-\n-/// An owning iterator over the elements of a `VecDeque`.\n-///\n-/// This `struct` is created by the [`into_iter`] method on [`VecDeque`]\n-/// (provided by the `IntoIterator` trait). See its documentation for more.\n-///\n-/// [`into_iter`]: VecDeque::into_iter\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<T> {\n-    inner: VecDeque<T>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\").field(&self.inner).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Iterator for IntoIter<T> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        self.inner.pop_front()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.inner.len();\n-        (len, Some(len))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        self.inner.pop_back()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {\n-    fn is_empty(&self) -> bool {\n-        self.inner.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IntoIter<T> {}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for VecDeque<A> {\n     fn eq(&self, other: &VecDeque<A>) -> bool {\n@@ -3039,26 +2616,6 @@ impl<A: PartialEq> PartialEq for VecDeque<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for VecDeque<A> {}\n \n-macro_rules! __impl_slice_eq1 {\n-    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n-        #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n-        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n-        where\n-            A: PartialEq<B>,\n-            $($constraints)*\n-        {\n-            fn eq(&self, other: &$rhs) -> bool {\n-                if self.len() != other.len() {\n-                    return false;\n-                }\n-                let (sa, sb) = self.as_slices();\n-                let (oa, ob) = other[..].split_at(sa.len());\n-                sa == oa && sb == ob\n-            }\n-        }\n-    }\n-}\n-\n __impl_slice_eq1! { [] VecDeque<A>, Vec<B>, }\n __impl_slice_eq1! { [] VecDeque<A>, &[B], }\n __impl_slice_eq1! { [] VecDeque<A>, &mut [B], }", "previous_filename": "library/alloc/src/collections/vec_deque.rs"}, {"sha": "812765d0b0ded37655344c9eb6321708612fe28f", "filename": "library/alloc/src/collections/vec_deque/pair_slices.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,66 @@\n+use core::array;\n+use core::cmp::{self};\n+use core::mem::replace;\n+\n+use super::VecDeque;\n+\n+/// PairSlices pairs up equal length slice parts of two deques\n+///\n+/// For example, given deques \"A\" and \"B\" with the following division into slices:\n+///\n+/// A: [0 1 2] [3 4 5]\n+/// B: [a b] [c d e]\n+///\n+/// It produces the following sequence of matching slices:\n+///\n+/// ([0 1], [a b])\n+/// (\\[2\\], \\[c\\])\n+/// ([3 4], [d e])\n+///\n+/// and the uneven remainder of either A or B is skipped.\n+pub struct PairSlices<'a, 'b, T> {\n+    pub(crate) a0: &'a mut [T],\n+    pub(crate) a1: &'a mut [T],\n+    pub(crate) b0: &'b [T],\n+    pub(crate) b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    pub fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n+        let (a0, a1) = to.as_mut_slices();\n+        let (b0, b1) = from.as_slices();\n+        PairSlices { a0, a1, b0, b1 }\n+    }\n+\n+    pub fn has_remainder(&self) -> bool {\n+        !self.b0.is_empty()\n+    }\n+\n+    pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n+        array::IntoIter::new([self.b0, self.b1])\n+    }\n+}\n+\n+impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T> {\n+    type Item = (&'a mut [T], &'b [T]);\n+    fn next(&mut self) -> Option<Self::Item> {\n+        // Get next part length\n+        let part = cmp::min(self.a0.len(), self.b0.len());\n+        if part == 0 {\n+            return None;\n+        }\n+        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n+        let (q0, q1) = self.b0.split_at(part);\n+\n+        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n+        self.a0 = p1;\n+        self.b0 = q1;\n+        if self.a0.is_empty() {\n+            self.a0 = replace(&mut self.a1, &mut []);\n+        }\n+        if self.b0.is_empty() {\n+            self.b0 = replace(&mut self.b1, &[]);\n+        }\n+        Some((p0, q0))\n+    }\n+}"}, {"sha": "dd0fa7d6074c00cbfed25293c649745930f564e9", "filename": "library/alloc/src/collections/vec_deque/ring_slices.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,56 @@\n+use core::ptr::{self};\n+\n+/// Returns the two slices that cover the `VecDeque`'s valid range\n+pub trait RingSlices: Sized {\n+    fn slice(self, from: usize, to: usize) -> Self;\n+    fn split_at(self, i: usize) -> (Self, Self);\n+\n+    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n+        let contiguous = tail <= head;\n+        if contiguous {\n+            let (empty, buf) = buf.split_at(0);\n+            (buf.slice(tail, head), empty)\n+        } else {\n+            let (mid, right) = buf.split_at(tail);\n+            let (left, _) = mid.split_at(head);\n+            (right, left)\n+        }\n+    }\n+}\n+\n+impl<T> RingSlices for &[T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        &self[from..to]\n+    }\n+    fn split_at(self, i: usize) -> (Self, Self) {\n+        (*self).split_at(i)\n+    }\n+}\n+\n+impl<T> RingSlices for &mut [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        &mut self[from..to]\n+    }\n+    fn split_at(self, i: usize) -> (Self, Self) {\n+        (*self).split_at_mut(i)\n+    }\n+}\n+\n+impl<T> RingSlices for *mut [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        assert!(from <= to && to < self.len());\n+        // Not using `get_unchecked_mut` to keep this a safe operation.\n+        let len = to - from;\n+        ptr::slice_from_raw_parts_mut(self.as_mut_ptr().wrapping_add(from), len)\n+    }\n+\n+    fn split_at(self, mid: usize) -> (Self, Self) {\n+        let len = self.len();\n+        let ptr = self.as_mut_ptr();\n+        assert!(mid <= len);\n+        (\n+            ptr::slice_from_raw_parts_mut(ptr, mid),\n+            ptr::slice_from_raw_parts_mut(ptr.wrapping_add(mid), len - mid),\n+        )\n+    }\n+}"}, {"sha": "5ff0ec052b6f4c0cdc95f4f85942f107d5b47b3f", "filename": "library/std/src/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -138,7 +138,7 @@ impl ReentrantMutex {\n                 self.owner.swap(0, SeqCst);\n                 // SAFETY: the caller must gurantee that `self.ptr()` is valid i32.\n                 unsafe {\n-                    wasm32::atomic_notify(self.ptr() as *mut i32, 1);\n+                    wasm32::memory_atomic_notify(self.ptr() as *mut i32, 1);\n                 } // wake up one waiter, if any\n             }\n             ref mut n => *n -= 1,"}, {"sha": "514be9e6864ba01e9d1ccdabd92ffd2043903ba8", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -2357,6 +2357,22 @@ fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir\n         return;\n     }\n \n+    if let Some(config) = builder.config.target_config.get(&target) {\n+        if config.llvm_config.is_some() {\n+            // If the LLVM was externally provided, then we don't currently copy\n+            // artifacts into the sysroot. This is not necessarily the right\n+            // choice (in particular, it will require the LLVM dylib to be in\n+            // the linker's load path at runtime), but the common use case for\n+            // external LLVMs is distribution provided LLVMs, and in that case\n+            // they're usually in the standard search path (e.g., /usr/lib) and\n+            // copying them here is going to cause problems as we may end up\n+            // with the wrong files and isn't what distributions want.\n+            //\n+            // This behavior may be revisited in the future though.\n+            return;\n+        }\n+    }\n+\n     // On macOS, rustc (and LLVM tools) link to an unversioned libLLVM.dylib\n     // instead of libLLVM-11-rust-....dylib, as on linux. It's not entirely\n     // clear why this is the case, though. llvm-config will emit the versioned"}, {"sha": "ca140b9d278287911d6277f84cb7d25d4c698f9b", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -178,6 +178,7 @@ const LLVM_TOOLS: &[&str] = &[\n     \"llvm-size\",     // used to prints the size of the linker sections of a program\n     \"llvm-strip\",    // used to discard symbols from binary files to reduce their size\n     \"llvm-ar\",       // used for creating and modifying archive files\n+    \"llvm-as\",       // used to convert LLVM assembly to LLVM bitcode\n     \"llvm-dis\",      // used to disassemble LLVM bitcode\n     \"llc\",           // used to compile LLVM bytecode\n     \"opt\",           // used to optimize LLVM bytecode"}, {"sha": "d716b23af6004c03b0006992417daae4b93e6c14", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -348,11 +348,11 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2).filter_map(|s| s.parse::<u32>().ok());\n     if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n-        if major >= 8 {\n+        if major >= 9 {\n             return;\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=8.0\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=9.0\\n\\n\", version)\n }\n \n fn configure_cmake("}, {"sha": "0ab1f727a29a0c75216a07e9c99261dd5ad550dd", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-9/Dockerfile", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-9%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-9%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-9%2FDockerfile?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -13,7 +13,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  llvm-8-tools \\\n+  llvm-9-tools \\\n+  llvm-9-dev \\\n   libedit-dev \\\n   libssl-dev \\\n   pkg-config \\\n@@ -27,7 +28,7 @@ RUN sh /scripts/sccache.sh\n # using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-8 \\\n+      --llvm-root=/usr/lib/llvm-9 \\\n       --enable-llvm-link-shared \\\n       --set rust.thin-lto-import-instr-limit=10\n ", "previous_filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-8/Dockerfile"}, {"sha": "9eea6243dfa57ea809ecd467b4b23a6d930e980b", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -280,7 +280,7 @@ jobs:\n           - name: mingw-check\n             <<: *job-linux-xl\n \n-          - name: x86_64-gnu-llvm-8\n+          - name: x86_64-gnu-llvm-9\n             <<: *job-linux-xl\n \n           - name: x86_64-gnu-tools\n@@ -412,7 +412,7 @@ jobs:\n           - name: x86_64-gnu-distcheck\n             <<: *job-linux-xl\n \n-          - name: x86_64-gnu-llvm-8\n+          - name: x86_64-gnu-llvm-9\n             env:\n               RUST_BACKTRACE: 1\n             <<: *job-linux-xl"}, {"sha": "6cb2728359b9597954063d3bd9aa011db4681b94", "filename": "src/test/codegen/abi-efiapi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -1,7 +1,6 @@\n // Checks if the correct annotation for the efiapi ABI is passed to llvm.\n \n // revisions:x86_64 i686 aarch64 arm riscv\n-// min-llvm-version: 9.0\n // needs-llvm-components: aarch64 arm riscv\n \n //[x86_64] compile-flags: --target x86_64-unknown-uefi"}, {"sha": "4c0a5602c6dad73ecb37e59e3431696749631f2a", "filename": "src/test/codegen/force-unwind-tables.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fcodegen%2Fforce-unwind-tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fcodegen%2Fforce-unwind-tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fforce-unwind-tables.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 8.0\n // compile-flags: -C no-prepopulate-passes -C force-unwind-tables=y\n \n #![crate_type=\"lib\"]"}, {"sha": "30aff0a64efb91ff24c9c1cf24e74531e4502080", "filename": "src/test/mir-opt/inline/inline-compatibility.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-compatibility.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -1,12 +1,11 @@\n // Checks that only functions with compatible attributes are inlined.\n //\n // only-x86_64\n-// needs-sanitizer-address\n-// compile-flags: -Zsanitizer=address\n \n #![crate_type = \"lib\"]\n #![feature(no_sanitize)]\n #![feature(target_feature_11)]\n+#![feature(c_variadic)]\n \n // EMIT_MIR inline_compatibility.inlined_target_feature.Inline.diff\n #[target_feature(enable = \"sse2\")]\n@@ -35,5 +34,22 @@ pub unsafe fn not_inlined_no_sanitize() {\n pub unsafe fn target_feature() {}\n \n #[inline]\n-#[no_sanitize(address, memory)]\n+#[no_sanitize(address)]\n pub unsafe fn no_sanitize() {}\n+\n+// EMIT_MIR inline_compatibility.not_inlined_c_variadic.Inline.diff\n+pub unsafe fn not_inlined_c_variadic() {\n+    let s = sum(4u32, 4u32, 30u32, 200u32, 1000u32);\n+}\n+\n+#[no_mangle]\n+#[inline(always)]\n+unsafe extern \"C\" fn sum(n: u32, mut vs: ...) -> u32 {\n+    let mut s = 0;\n+    let mut i = 0;\n+    while i != n {\n+        s += vs.arg::<u32>();\n+        i += 1;\n+    }\n+    s\n+}"}, {"sha": "d11b3e548f721f25d2a253057dcaff1953d196a4", "filename": "src/test/mir-opt/inline/inline-generator.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-generator.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,16 @@\n+// ignore-wasm32-bare compiled with panic=abort by default\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+use std::pin::Pin;\n+\n+// EMIT_MIR inline_generator.main.Inline.diff\n+fn main() {\n+    let _r = Pin::new(&mut g()).resume(false);\n+}\n+\n+#[inline(always)]\n+pub fn g() -> impl Generator<bool> {\n+    #[inline(always)]\n+    |a| { yield if a { 7 } else { 13 } }\n+}"}, {"sha": "c95cf47695785de07fa671541204b37003f4e371", "filename": "src/test/mir-opt/inline/inline_compatibility.inlined_no_sanitize.Inline.diff", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -2,24 +2,24 @@\n + // MIR for `inlined_no_sanitize` after Inline\n   \n   fn inlined_no_sanitize() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:24:37: 24:37\n-      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:25:5: 25:18\n-+     scope 1 (inlined no_sanitize) {      // at $DIR/inline-compatibility.rs:25:5: 25:18\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:23:37: 23:37\n+      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:24:5: 24:18\n++     scope 1 (inlined no_sanitize) {      // at $DIR/inline-compatibility.rs:24:5: 24:18\n +     }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:25:5: 25:18\n--         _1 = no_sanitize() -> bb1;       // scope 0 at $DIR/inline-compatibility.rs:25:5: 25:18\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:24:5: 24:18\n+-         _1 = no_sanitize() -> bb1;       // scope 0 at $DIR/inline-compatibility.rs:24:5: 24:18\n -                                          // mir::Constant\n--                                          // + span: $DIR/inline-compatibility.rs:25:5: 25:16\n+-                                          // + span: $DIR/inline-compatibility.rs:24:5: 24:16\n -                                          // + literal: Const { ty: unsafe fn() {no_sanitize}, val: Value(Scalar(<ZST>)) }\n -     }\n - \n -     bb1: {\n-+         _1 = const ();                   // scope 1 at $DIR/inline-compatibility.rs:25:5: 25:18\n-          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:25:18: 25:19\n-          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:24:37: 26:2\n-          return;                          // scope 0 at $DIR/inline-compatibility.rs:26:2: 26:2\n++         _1 = const ();                   // scope 1 at $DIR/inline-compatibility.rs:24:5: 24:18\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:24:18: 24:19\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:23:37: 25:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:25:2: 25:2\n       }\n   }\n   "}, {"sha": "2bb928343229fd190b82304de92676ea03cba704", "filename": "src/test/mir-opt/inline/inline_compatibility.inlined_target_feature.Inline.diff", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -2,24 +2,24 @@\n + // MIR for `inlined_target_feature` after Inline\n   \n   fn inlined_target_feature() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:13:40: 13:40\n-      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:14:5: 14:21\n-+     scope 1 (inlined target_feature) {   // at $DIR/inline-compatibility.rs:14:5: 14:21\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:12:40: 12:40\n+      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:13:5: 13:21\n++     scope 1 (inlined target_feature) {   // at $DIR/inline-compatibility.rs:13:5: 13:21\n +     }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:14:5: 14:21\n--         _1 = target_feature() -> bb1;    // scope 0 at $DIR/inline-compatibility.rs:14:5: 14:21\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:13:5: 13:21\n+-         _1 = target_feature() -> bb1;    // scope 0 at $DIR/inline-compatibility.rs:13:5: 13:21\n -                                          // mir::Constant\n--                                          // + span: $DIR/inline-compatibility.rs:14:5: 14:19\n+-                                          // + span: $DIR/inline-compatibility.rs:13:5: 13:19\n -                                          // + literal: Const { ty: unsafe fn() {target_feature}, val: Value(Scalar(<ZST>)) }\n -     }\n - \n -     bb1: {\n-+         _1 = const ();                   // scope 1 at $DIR/inline-compatibility.rs:14:5: 14:21\n-          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:14:21: 14:22\n-          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:13:40: 15:2\n-          return;                          // scope 0 at $DIR/inline-compatibility.rs:15:2: 15:2\n++         _1 = const ();                   // scope 1 at $DIR/inline-compatibility.rs:13:5: 13:21\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:13:21: 13:22\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:12:40: 14:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:14:2: 14:2\n       }\n   }\n   "}, {"sha": "09bca903c80e892da07a8573341cfc1460ef6748", "filename": "src/test/mir-opt/inline/inline_compatibility.not_inlined_c_variadic.Inline.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_c_variadic.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_c_variadic.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_c_variadic.Inline.diff?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `not_inlined_c_variadic` before Inline\n++ // MIR for `not_inlined_c_variadic` after Inline\n+  \n+  fn not_inlined_c_variadic() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:41:40: 41:40\n+      let _1: u32;                         // in scope 0 at $DIR/inline-compatibility.rs:42:9: 42:10\n+      scope 1 {\n+          debug s => _1;                   // in scope 1 at $DIR/inline-compatibility.rs:42:9: 42:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:42:9: 42:10\n+          _1 = sum(const 4_u32, const 4_u32, const 30_u32, const 200_u32, const 1000_u32) -> bb1; // scope 0 at $DIR/inline-compatibility.rs:42:13: 42:52\n+                                           // mir::Constant\n+                                           // + span: $DIR/inline-compatibility.rs:42:13: 42:16\n+                                           // + literal: Const { ty: unsafe extern \"C\" fn(u32, ...) -> u32 {sum}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:41:40: 43:2\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:43:1: 43:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:43:2: 43:2\n+      }\n+  }\n+  "}, {"sha": "5af3946f2e501d32622dc4d0d526e8f279e7e633", "filename": "src/test/mir-opt/inline/inline_compatibility.not_inlined_no_sanitize.Inline.diff", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_no_sanitize.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_no_sanitize.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_no_sanitize.Inline.diff?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -2,21 +2,21 @@\n + // MIR for `not_inlined_no_sanitize` after Inline\n   \n   fn not_inlined_no_sanitize() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:29:41: 29:41\n-      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:30:5: 30:18\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:28:41: 28:41\n+      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:29:5: 29:18\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:30:5: 30:18\n-          _1 = no_sanitize() -> bb1;       // scope 0 at $DIR/inline-compatibility.rs:30:5: 30:18\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:29:5: 29:18\n+          _1 = no_sanitize() -> bb1;       // scope 0 at $DIR/inline-compatibility.rs:29:5: 29:18\n                                            // mir::Constant\n-                                           // + span: $DIR/inline-compatibility.rs:30:5: 30:16\n+                                           // + span: $DIR/inline-compatibility.rs:29:5: 29:16\n                                            // + literal: Const { ty: unsafe fn() {no_sanitize}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb1: {\n-          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:30:18: 30:19\n-          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:29:41: 31:2\n-          return;                          // scope 0 at $DIR/inline-compatibility.rs:31:2: 31:2\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:29:18: 29:19\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:28:41: 30:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:30:2: 30:2\n       }\n   }\n   "}, {"sha": "8c9fa573ce218ca550f536608d8aa809266b659b", "filename": "src/test/mir-opt/inline/inline_compatibility.not_inlined_target_feature.Inline.diff", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_target_feature.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_target_feature.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_target_feature.Inline.diff?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -2,21 +2,21 @@\n + // MIR for `not_inlined_target_feature` after Inline\n   \n   fn not_inlined_target_feature() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:18:44: 18:44\n-      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:19:5: 19:21\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:17:44: 17:44\n+      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:18:5: 18:21\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:19:5: 19:21\n-          _1 = target_feature() -> bb1;    // scope 0 at $DIR/inline-compatibility.rs:19:5: 19:21\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:18:5: 18:21\n+          _1 = target_feature() -> bb1;    // scope 0 at $DIR/inline-compatibility.rs:18:5: 18:21\n                                            // mir::Constant\n-                                           // + span: $DIR/inline-compatibility.rs:19:5: 19:19\n+                                           // + span: $DIR/inline-compatibility.rs:18:5: 18:19\n                                            // + literal: Const { ty: unsafe fn() {target_feature}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb1: {\n-          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:19:21: 19:22\n-          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:18:44: 20:2\n-          return;                          // scope 0 at $DIR/inline-compatibility.rs:20:2: 20:2\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:18:21: 18:22\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:17:44: 19:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:19:2: 19:2\n       }\n   }\n   "}, {"sha": "aa32daa82dd51135f81ceb0b2e2f91f03adbb1a8", "filename": "src/test/mir-opt/inline/inline_generator.main.Inline.diff", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,123 @@\n+- // MIR for `main` before Inline\n++ // MIR for `main` after Inline\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-generator.rs:8:11: 8:11\n+      let _1: std::ops::GeneratorState<<impl std::ops::Generator<bool> as std::ops::Generator<bool>>::Yield, <impl std::ops::Generator<bool> as std::ops::Generator<bool>>::Return>; // in scope 0 at $DIR/inline-generator.rs:9:9: 9:11\n+      let mut _2: std::pin::Pin<&mut impl std::ops::Generator<bool>>; // in scope 0 at $DIR/inline-generator.rs:9:14: 9:32\n+      let mut _3: &mut impl std::ops::Generator<bool>; // in scope 0 at $DIR/inline-generator.rs:9:23: 9:31\n+      let mut _4: impl std::ops::Generator<bool>; // in scope 0 at $DIR/inline-generator.rs:9:28: 9:31\n++     let mut _7: bool;                    // in scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n+      scope 1 {\n+          debug _r => _1;                  // in scope 1 at $DIR/inline-generator.rs:9:9: 9:11\n+      }\n++     scope 2 (inlined g) {                // at $DIR/inline-generator.rs:9:28: 9:31\n++     }\n++     scope 3 (inlined Pin::<&mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]>::new) { // at $DIR/inline-generator.rs:9:14: 9:32\n++         debug pointer => _3;             // in scope 3 at $DIR/inline-generator.rs:9:14: 9:32\n++         let mut _5: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]; // in scope 3 at $DIR/inline-generator.rs:9:14: 9:32\n++         scope 4 {\n++             scope 5 (inlined Pin::<&mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]>::new_unchecked) { // at $DIR/inline-generator.rs:9:14: 9:32\n++                 debug pointer => _5;     // in scope 5 at $DIR/inline-generator.rs:9:14: 9:32\n++                 let mut _6: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]; // in scope 5 at $DIR/inline-generator.rs:9:14: 9:32\n++             }\n++         }\n++     }\n++     scope 6 (inlined g::{closure#0}) {   // at $DIR/inline-generator.rs:9:14: 9:46\n++         debug a => _8;                   // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         let mut _8: bool;                // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         let mut _9: u32;                 // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-generator.rs:9:9: 9:11\n+          StorageLive(_2);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:32\n+          StorageLive(_3);                 // scope 0 at $DIR/inline-generator.rs:9:23: 9:31\n+          StorageLive(_4);                 // scope 0 at $DIR/inline-generator.rs:9:28: 9:31\n+-         _4 = g() -> bb1;                 // scope 0 at $DIR/inline-generator.rs:9:28: 9:31\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-generator.rs:9:28: 9:29\n+-                                          // + literal: Const { ty: fn() -> impl std::ops::Generator<bool> {g}, val: Value(Scalar(<ZST>)) }\n+-     }\n+- \n+-     bb1: {\n++         discriminant(_4) = 0;            // scope 2 at $DIR/inline-generator.rs:9:28: 9:31\n+          _3 = &mut _4;                    // scope 0 at $DIR/inline-generator.rs:9:23: 9:31\n+-         _2 = Pin::<&mut impl Generator<bool>>::new(move _3) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/inline-generator.rs:9:14: 9:32\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-generator.rs:9:14: 9:22\n+-                                          // + user_ty: UserType(0)\n+-                                          // + literal: Const { ty: fn(&mut impl std::ops::Generator<bool>) -> std::pin::Pin<&mut impl std::ops::Generator<bool>> {std::pin::Pin::<&mut impl std::ops::Generator<bool>>::new}, val: Value(Scalar(<ZST>)) }\n+-     }\n+- \n+-     bb2: {\n++         StorageLive(_5);                 // scope 4 at $DIR/inline-generator.rs:9:14: 9:32\n++         _5 = move _3;                    // scope 4 at $DIR/inline-generator.rs:9:14: 9:32\n++         StorageLive(_6);                 // scope 5 at $DIR/inline-generator.rs:9:14: 9:32\n++         _6 = move _5;                    // scope 5 at $DIR/inline-generator.rs:9:14: 9:32\n++         (_2.0: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]) = move _6; // scope 5 at $DIR/inline-generator.rs:9:14: 9:32\n++         StorageDead(_6);                 // scope 5 at $DIR/inline-generator.rs:9:14: 9:32\n++         StorageDead(_5);                 // scope 4 at $DIR/inline-generator.rs:9:14: 9:32\n+          StorageDead(_3);                 // scope 0 at $DIR/inline-generator.rs:9:31: 9:32\n+-         _1 = <impl Generator<bool> as Generator<bool>>::resume(move _2, const false) -> [return: bb3, unwind: bb4]; // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-generator.rs:9:33: 9:39\n+-                                          // + literal: Const { ty: for<'r> fn(std::pin::Pin<&'r mut impl std::ops::Generator<bool>>, bool) -> std::ops::GeneratorState<<impl std::ops::Generator<bool> as std::ops::Generator<bool>>::Yield, <impl std::ops::Generator<bool> as std::ops::Generator<bool>>::Return> {<impl std::ops::Generator<bool> as std::ops::Generator<bool>>::resume}, val: Value(Scalar(<ZST>)) }\n++         StorageLive(_7);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n++         _7 = const false;                // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n++         _9 = discriminant((*(_2.0: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]))); // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         switchInt(move _9) -> [0_u32: bb3, 1_u32: bb8, 3_u32: bb7, otherwise: bb9]; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n+      }\n+  \n+-     bb3: {\n++     bb1: {\n++         StorageDead(_7);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n+          StorageDead(_2);                 // scope 0 at $DIR/inline-generator.rs:9:45: 9:46\n+          StorageDead(_4);                 // scope 0 at $DIR/inline-generator.rs:9:46: 9:47\n+          _0 = const ();                   // scope 0 at $DIR/inline-generator.rs:8:11: 10:2\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-generator.rs:10:1: 10:2\n+          return;                          // scope 0 at $DIR/inline-generator.rs:10:2: 10:2\n+      }\n+  \n+-     bb4 (cleanup): {\n++     bb2 (cleanup): {\n+          resume;                          // scope 0 at $DIR/inline-generator.rs:8:1: 10:2\n++     }\n++ \n++     bb3: {\n++         _8 = move _7;                    // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         switchInt(_8) -> [false: bb4, otherwise: bb5]; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++     }\n++ \n++     bb4: {\n++         ((_1 as Yielded).0: i32) = const 13_i32; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         goto -> bb6;                     // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++     }\n++ \n++     bb5: {\n++         ((_1 as Yielded).0: i32) = const 7_i32; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         goto -> bb6;                     // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++     }\n++ \n++     bb6: {\n++         discriminant(_1) = 0;            // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         discriminant((*(_2.0: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]))) = 3; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         goto -> bb1;                     // scope 0 at $DIR/inline-generator.rs:15:11: 15:39\n++     }\n++ \n++     bb7: {\n++         ((_1 as Complete).0: bool) = move _7; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         discriminant(_1) = 1;            // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         discriminant((*(_2.0: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]))) = 1; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         goto -> bb1;                     // scope 0 at $DIR/inline-generator.rs:15:41: 15:41\n++     }\n++ \n++     bb8: {\n++         assert(const false, \"generator resumed after completion\") -> [success: bb8, unwind: bb2]; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++     }\n++ \n++     bb9: {\n++         unreachable;                     // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n+      }\n+  }\n+  "}, {"sha": "e06885e03882bc6d5d99a79b76c1d3b8b51a9b4e", "filename": "src/test/pretty/qpath-associated-type-bound.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fpretty%2Fqpath-associated-type-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fpretty%2Fqpath-associated-type-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fqpath-associated-type-bound.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,16 @@\n+// pp-exact\n+\n+\n+mod m {\n+    pub trait Tr {\n+        type Ts: super::Tu;\n+    }\n+}\n+\n+trait Tu {\n+    fn dummy() { }\n+}\n+\n+fn foo<T: m::Tr>() { <T as m::Tr>::Ts::dummy(); }\n+\n+fn main() { }"}, {"sha": "f895a4c2104ba611dbab43927a4ba59e94aa858b", "filename": "src/test/rustdoc/raw-ident-eliminate-r-hashtag.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,22 @@\n+// ignore-tidy-linelength\n+\n+#![crate_type=\"lib\"]\n+\n+pub mod internal {\n+    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.mod.html'\n+    pub struct r#mod;\n+\n+    /// See [name], [other name]\n+    ///\n+    /// [name]: mod\n+    /// [other name]: crate::internal::mod\n+    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"../../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'name'\n+    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"../../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'other name'\n+    pub struct B;\n+}\n+\n+/// See [name].\n+///\n+/// [name]: internal::mod\n+// @has 'raw_ident_eliminate_r_hashtag/struct.A.html' '//*a[@href=\"../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'name'\n+pub struct A;"}, {"sha": "216b31586da3e6438db2063666b11cf25fb20d0d", "filename": "src/test/ui/hygiene/panic-location.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -1,2 +1,2 @@\n-thread 'main' panicked at 'capacity overflow', $SRC_DIR/alloc/src/collections/vec_deque.rs:LL:COL\n+thread 'main' panicked at 'capacity overflow', $SRC_DIR/alloc/src/collections/vec_deque/mod.rs:LL:COL\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "f3a51b415facac0719b55f2e6f27f624def40e4b", "filename": "src/test/ui/issues/issue-50865-private-impl-trait/auxiliary/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -1,7 +1,3 @@\n-// revisions: default miropt\n-//[miropt]compile-flags: -Z mir-opt-level=2\n-// ~^ This flag is for #77668, it used to be ICE.\n-\n #![crate_type = \"lib\"]\n \n pub fn bar<P>( // Error won't happen if \"bar\" is not generic"}, {"sha": "5b933edc8205ed414cc53136b0a0a7829a0d8a5f", "filename": "src/test/ui/match/issue-72680.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fmatch%2Fissue-72680.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fmatch%2Fissue-72680.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-72680.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -0,0 +1,65 @@\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+fn main() {\n+    assert!(f(\"\", 0));\n+    assert!(f(\"a\", 1));\n+    assert!(f(\"b\", 1));\n+\n+    assert!(!f(\"\", 1));\n+    assert!(!f(\"a\", 0));\n+    assert!(!f(\"b\", 0));\n+\n+    assert!(!f(\"asdf\", 32));\n+\n+    ////\n+\n+    assert!(!g(true, true, true));\n+    assert!(!g(false, true, true));\n+    assert!(!g(true, false, true));\n+    assert!(!g(false, false, true));\n+    assert!(!g(true, true, false));\n+\n+    assert!(g(false, true, false));\n+    assert!(g(true, false, false));\n+    assert!(g(false, false, false));\n+\n+    ////\n+\n+    assert!(!h(true, true, true));\n+    assert!(!h(false, true, true));\n+    assert!(!h(true, false, true));\n+    assert!(!h(false, false, true));\n+    assert!(!h(true, true, false));\n+\n+    assert!(h(false, true, false));\n+    assert!(h(true, false, false));\n+    assert!(h(false, false, false));\n+}\n+\n+fn f(s: &str, num: usize) -> bool {\n+    match (s, num) {\n+        (\"\", 0) | (\"a\" | \"b\", 1) => true,\n+\n+        _ => false,\n+    }\n+}\n+\n+fn g(x: bool, y: bool, z: bool) -> bool {\n+    match (x, y, x, z) {\n+        (true | false, false, true, false) => true,\n+        (false, true | false, true | false, false) => true,\n+        (true | false, true | false, true | false, true) => false,\n+        (true, true | false, true | false, false) => false,\n+    }\n+}\n+\n+fn h(x: bool, y: bool, z: bool) -> bool {\n+    match (x, (y, (x, (z,)))) {\n+        (true | false, (false, (true, (false,)))) => true,\n+        (false, (true | false, (true | false, (false,)))) => true,\n+        (true | false, (true | false, (true | false, (true,)))) => false,\n+        (true, (true | false, (true | false, (false,)))) => false,\n+    }\n+}"}, {"sha": "ccb279f7fa212c076a65348238bba678d7bc94f7", "filename": "src/test/ui/mir/mir-inlining/ice-issue-77306-1.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77306-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77306-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77306-1.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -1,17 +1,27 @@\n-// run-pass\n+// Regression test for various issues related to normalization & inlining.\n+// * #68347, #77306, #77668 - missed normalization during inlining.\n+// * #78442 - missed normalization in validator after inlining.\n+//\n+// build-pass\n // compile-flags:-Zmir-opt-level=2\n \n-// Previously ICEd because we did not normalize during inlining,\n-// see https://github.com/rust-lang/rust/pull/77306 for more discussion.\n-\n pub fn write() {\n     create()()\n }\n \n+pub fn write_generic<T>(_t: T) {\n+    hide()();\n+}\n+\n pub fn create() -> impl FnOnce() {\n    || ()\n }\n \n+pub fn hide() -> impl Fn() {\n+    write\n+}\n+\n fn main() {\n     write();\n+    write_generic(());\n }"}, {"sha": "1542c7f311848808903b90d2cafe388b49cb6754", "filename": "src/test/ui/sanitize/new-llvm-pass-manager-thin-lto.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fnew-llvm-pass-manager-thin-lto.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -2,7 +2,6 @@\n // being run when compiling with new LLVM pass manager and ThinLTO.\n // Note: The issue occurred only on non-zero opt-level.\n //\n-// min-llvm-version: 9.0\n // needs-sanitizer-support\n // needs-sanitizer-address\n //"}, {"sha": "2d7ebbf1d5b049c3343b96defd1998f5dc40ce9d", "filename": "src/test/ui/weird-exprs.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75042566d1c90d912f22e4db43b6d3af98447986/src%2Ftest%2Fui%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fweird-exprs.rs?ref=75042566d1c90d912f22e4db43b6d3af98447986", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n \n #![feature(generators)]\n+#![feature(destructuring_assignment)]\n \n #![allow(non_camel_case_types)]\n #![allow(dead_code)]\n@@ -159,6 +160,11 @@ fn match_nested_if() {\n     assert!(val);\n }\n \n+fn monkey_barrel() {\n+    let val = ()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=()=();\n+    assert_eq!(val, ());\n+}\n+\n pub fn main() {\n     strange();\n     funny();\n@@ -177,4 +183,5 @@ pub fn main() {\n     r#match();\n     i_yield();\n     match_nested_if();\n+    monkey_barrel();\n }"}]}