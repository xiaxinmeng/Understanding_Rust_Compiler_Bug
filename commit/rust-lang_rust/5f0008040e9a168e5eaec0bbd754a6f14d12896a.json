{"sha": "5f0008040e9a168e5eaec0bbd754a6f14d12896a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMDAwODA0MGU5YTE2OGU1ZWFlYzBiYmQ3NTRhNmYxNGQxMjg5NmE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-30T13:14:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-30T13:20:47Z"}, "message": "Allow to set env vars and pipe stdin via not_bash", "tree": {"sha": "16c81aefd811feaee103ebb617cacaf13eb9e412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16c81aefd811feaee103ebb617cacaf13eb9e412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f0008040e9a168e5eaec0bbd754a6f14d12896a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f0008040e9a168e5eaec0bbd754a6f14d12896a", "html_url": "https://github.com/rust-lang/rust/commit/5f0008040e9a168e5eaec0bbd754a6f14d12896a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f0008040e9a168e5eaec0bbd754a6f14d12896a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36775ef0d056b374b8e2b89f7399200e09d4daca", "url": "https://api.github.com/repos/rust-lang/rust/commits/36775ef0d056b374b8e2b89f7399200e09d4daca", "html_url": "https://github.com/rust-lang/rust/commit/36775ef0d056b374b8e2b89f7399200e09d4daca"}], "stats": {"total": 171, "additions": 79, "deletions": 92}, "files": [{"sha": "2b7a461e568d3b0cebb429a1a2d74e1c2327b598", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 30, "deletions": 81, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5f0008040e9a168e5eaec0bbd754a6f14d12896a/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f0008040e9a168e5eaec0bbd754a6f14d12896a/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=5f0008040e9a168e5eaec0bbd754a6f14d12896a", "patch": "@@ -12,21 +12,18 @@ mod ast_src;\n \n use std::{\n     env,\n-    io::Write,\n     path::{Path, PathBuf},\n-    process::{Command, Stdio},\n };\n+\n use walkdir::{DirEntry, WalkDir};\n \n use crate::{\n     codegen::Mode,\n-    not_bash::{date_iso, fs2, pushd, rm_rf, run},\n+    not_bash::{date_iso, fs2, pushd, pushenv, rm_rf, run},\n };\n \n pub use anyhow::{bail, Context as _, Result};\n \n-const RUSTFMT_TOOLCHAIN: &str = \"stable\";\n-\n pub fn project_root() -> PathBuf {\n     Path::new(\n         &env::var(\"CARGO_MANIFEST_DIR\").unwrap_or_else(|_| env!(\"CARGO_MANIFEST_DIR\").to_owned()),\n@@ -54,77 +51,44 @@ pub fn rust_files(path: &Path) -> impl Iterator<Item = PathBuf> {\n \n pub fn run_rustfmt(mode: Mode) -> Result<()> {\n     let _dir = pushd(project_root());\n+    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"stable\");\n     ensure_rustfmt()?;\n-\n-    if Command::new(\"cargo\")\n-        .env(\"RUSTUP_TOOLCHAIN\", RUSTFMT_TOOLCHAIN)\n-        .args(&[\"fmt\", \"--\"])\n-        .args(if mode == Mode::Verify { &[\"--check\"][..] } else { &[] })\n-        .stderr(Stdio::inherit())\n-        .status()?\n-        .success()\n-    {\n-        Ok(())\n-    } else {\n-        bail!(\"Rustfmt failed\");\n-    }\n+    match mode {\n+        Mode::Overwrite => run!(\"cargo fmt\"),\n+        Mode::Verify => run!(\"cargo fmt -- --check\"),\n+    }?;\n+    Ok(())\n }\n \n fn reformat(text: impl std::fmt::Display) -> Result<String> {\n+    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"stable\");\n     ensure_rustfmt()?;\n-    let mut rustfmt = Command::new(\"rustfmt\")\n-        .env(\"RUSTUP_TOOLCHAIN\", RUSTFMT_TOOLCHAIN)\n-        .args(&[\"--config-path\"])\n-        .arg(project_root().join(\"rustfmt.toml\"))\n-        .args(&[\"--config\", \"fn_single_line=true\"])\n-        .stdin(Stdio::piped())\n-        .stdout(Stdio::piped())\n-        .spawn()?;\n-    write!(rustfmt.stdin.take().unwrap(), \"{}\", text)?;\n-    let output = rustfmt.wait_with_output()?;\n-    let stdout = String::from_utf8(output.stdout)?;\n+    let stdout = run!(\n+        \"rustfmt --config-path {} --config fn_single_line=true\", project_root().join(\"rustfmt.toml\").display();\n+        <text.to_string().as_bytes()\n+    )?;\n     let preamble = \"Generated file, do not edit by hand, see `xtask/src/codegen`\";\n-    Ok(format!(\"//! {}\\n\\n{}\", preamble, stdout))\n+    Ok(format!(\"//! {}\\n\\n{}\\n\", preamble, stdout))\n }\n \n fn ensure_rustfmt() -> Result<()> {\n-    match Command::new(\"rustfmt\")\n-        .args(&[\"--version\"])\n-        .env(\"RUSTUP_TOOLCHAIN\", RUSTFMT_TOOLCHAIN)\n-        .stdout(Stdio::piped())\n-        .stderr(Stdio::null())\n-        .spawn()\n-        .and_then(|child| child.wait_with_output())\n-    {\n-        Ok(output)\n-            if output.status.success()\n-                && std::str::from_utf8(&output.stdout)?.contains(RUSTFMT_TOOLCHAIN) =>\n-        {\n-            Ok(())\n-        }\n-        _ => {\n-            bail!(\n-                \"Failed to run rustfmt from toolchain '{0}'. \\\n-                Please run `rustup component add rustfmt --toolchain {0}` to install it.\",\n-                RUSTFMT_TOOLCHAIN,\n-            );\n-        }\n+    let out = run!(\"rustfmt --version\")?;\n+    if !out.contains(\"stable\") {\n+        bail!(\n+            \"Failed to run rustfmt from toolchain 'stable'. \\\n+             Please run `rustup component add rustfmt --toolchain stable` to install it.\",\n+        )\n     }\n+    Ok(())\n }\n \n pub fn run_clippy() -> Result<()> {\n-    match Command::new(\"cargo\")\n-        .args(&[\"clippy\", \"--version\"])\n-        .stderr(Stdio::null())\n-        .stdout(Stdio::null())\n-        .status()\n-    {\n-        Ok(status) if status.success() => (),\n-        _ => bail!(\n+    if run!(\"cargo clippy --version\").is_err() {\n+        bail!(\n             \"Failed run cargo clippy. \\\n             Please run `rustup component add clippy` to install it.\",\n-        ),\n-    };\n+        )\n+    }\n \n     let allowed_lints = [\n         \"clippy::collapsible_if\",\n@@ -138,33 +102,18 @@ pub fn run_clippy() -> Result<()> {\n \n pub fn run_fuzzer() -> Result<()> {\n     let _d = pushd(\"./crates/ra_syntax\");\n+    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"nightly\");\n     if run!(\"cargo fuzz --help\").is_err() {\n         run!(\"cargo install cargo-fuzz\")?;\n     };\n \n     // Expecting nightly rustc\n-    match Command::new(\"rustc\")\n-        .args(&[\"--version\"])\n-        .env(\"RUSTUP_TOOLCHAIN\", \"nightly\")\n-        .stdout(Stdio::piped())\n-        .stderr(Stdio::null())\n-        .spawn()\n-        .and_then(|child| child.wait_with_output())\n-    {\n-        Ok(output)\n-            if output.status.success()\n-                && std::str::from_utf8(&output.stdout)?.contains(\"nightly\") => {}\n-        _ => bail!(\"fuzz tests require nightly rustc\"),\n+    let out = run!(\"rustc --version\")?;\n+    if !out.contains(\"nightly\") {\n+        bail!(\"fuzz tests require nightly rustc\")\n     }\n \n-    let status = Command::new(\"cargo\")\n-        .env(\"RUSTUP_TOOLCHAIN\", \"nightly\")\n-        .args(&[\"fuzz\", \"run\", \"parser\"])\n-        .stderr(Stdio::inherit())\n-        .status()?;\n-    if !status.success() {\n-        bail!(\"{}\", status);\n-    }\n+    run!(\"cargo fuzz run parser\")?;\n     Ok(())\n }\n "}, {"sha": "a6431e58633c18b0cad2b6244eb70c0212476e09", "filename": "xtask/src/not_bash.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5f0008040e9a168e5eaec0bbd754a6f14d12896a/xtask%2Fsrc%2Fnot_bash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f0008040e9a168e5eaec0bbd754a6f14d12896a/xtask%2Fsrc%2Fnot_bash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fnot_bash.rs?ref=5f0008040e9a168e5eaec0bbd754a6f14d12896a", "patch": "@@ -3,6 +3,8 @@\n use std::{\n     cell::RefCell,\n     env,\n+    ffi::OsString,\n+    io::Write,\n     path::{Path, PathBuf},\n     process::{Command, Stdio},\n };\n@@ -57,7 +59,10 @@ macro_rules! _run {\n         run!($($expr),*; echo = true)\n     };\n     ($($expr:expr),* ; echo = $echo:expr) => {\n-        $crate::not_bash::run_process(format!($($expr),*), $echo)\n+        $crate::not_bash::run_process(format!($($expr),*), $echo, None)\n+    };\n+    ($($expr:expr),* ;  <$stdin:expr) => {\n+        $crate::not_bash::run_process(format!($($expr),*), false, Some($stdin))\n     };\n }\n pub(crate) use _run as run;\n@@ -77,6 +82,21 @@ impl Drop for Pushd {\n     }\n }\n \n+pub struct Pushenv {\n+    _p: (),\n+}\n+\n+pub fn pushenv(var: &str, value: &str) -> Pushenv {\n+    Env::with(|env| env.pushenv(var.into(), value.into()));\n+    Pushenv { _p: () }\n+}\n+\n+impl Drop for Pushenv {\n+    fn drop(&mut self) {\n+        Env::with(|env| env.popenv())\n+    }\n+}\n+\n pub fn rm_rf(path: impl AsRef<Path>) -> Result<()> {\n     let path = path.as_ref();\n     if !path.exists() {\n@@ -90,15 +110,15 @@ pub fn rm_rf(path: impl AsRef<Path>) -> Result<()> {\n }\n \n #[doc(hidden)]\n-pub fn run_process(cmd: String, echo: bool) -> Result<String> {\n-    run_process_inner(&cmd, echo).with_context(|| format!(\"process `{}` failed\", cmd))\n+pub fn run_process(cmd: String, echo: bool, stdin: Option<&[u8]>) -> Result<String> {\n+    run_process_inner(&cmd, echo, stdin).with_context(|| format!(\"process `{}` failed\", cmd))\n }\n \n pub fn date_iso() -> Result<String> {\n     run!(\"date --iso --utc\")\n }\n \n-fn run_process_inner(cmd: &str, echo: bool) -> Result<String> {\n+fn run_process_inner(cmd: &str, echo: bool, stdin: Option<&[u8]>) -> Result<String> {\n     let mut args = shelx(cmd);\n     let binary = args.remove(0);\n     let current_dir = Env::with(|it| it.cwd().to_path_buf());\n@@ -107,12 +127,17 @@ fn run_process_inner(cmd: &str, echo: bool) -> Result<String> {\n         println!(\"> {}\", cmd)\n     }\n \n-    let output = Command::new(binary)\n-        .args(args)\n-        .current_dir(current_dir)\n-        .stdin(Stdio::null())\n-        .stderr(Stdio::inherit())\n-        .output()?;\n+    let mut command = Command::new(binary);\n+    command.args(args).current_dir(current_dir).stderr(Stdio::inherit());\n+    let output = match stdin {\n+        None => command.stdin(Stdio::null()).output(),\n+        Some(stdin) => {\n+            command.stdin(Stdio::piped()).stdout(Stdio::piped());\n+            let mut process = command.spawn()?;\n+            process.stdin.take().unwrap().write_all(stdin)?;\n+            process.wait_with_output()\n+        }\n+    }?;\n     let stdout = String::from_utf8(output.stdout)?;\n \n     if echo {\n@@ -133,13 +158,15 @@ fn shelx(cmd: &str) -> Vec<String> {\n \n struct Env {\n     pushd_stack: Vec<PathBuf>,\n+    pushenv_stack: Vec<(OsString, Option<OsString>)>,\n }\n \n impl Env {\n     fn with<F: FnOnce(&mut Env) -> T, T>(f: F) -> T {\n         thread_local! {\n             static ENV: RefCell<Env> = RefCell::new(Env {\n-                pushd_stack: vec![env::current_dir().unwrap()]\n+                pushd_stack: vec![env::current_dir().unwrap()],\n+                pushenv_stack: vec![],\n             });\n         }\n         ENV.with(|it| f(&mut *it.borrow_mut()))\n@@ -154,6 +181,17 @@ impl Env {\n         self.pushd_stack.pop().unwrap();\n         env::set_current_dir(self.cwd()).unwrap();\n     }\n+    fn pushenv(&mut self, var: OsString, value: OsString) {\n+        self.pushenv_stack.push((var.clone(), env::var_os(&var)));\n+        env::set_var(var, value)\n+    }\n+    fn popenv(&mut self) {\n+        let (var, value) = self.pushenv_stack.pop().unwrap();\n+        match value {\n+            None => env::remove_var(var),\n+            Some(value) => env::set_var(var, value),\n+        }\n+    }\n     fn cwd(&self) -> &Path {\n         self.pushd_stack.last().unwrap()\n     }"}]}