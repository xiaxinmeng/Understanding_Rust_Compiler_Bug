{"sha": "11426a4d502cac062773071cf7fd320a383564ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNDI2YTRkNTAyY2FjMDYyNzczMDcxY2Y3ZmQzMjBhMzgzNTY0ZmY=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-05-10T04:49:58Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-05-10T08:13:22Z"}, "message": "refactor some `FnType` stuff to `rustc::ty::layout`", "tree": {"sha": "428433a6b503ce00a2390819f21f93cd59a608ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/428433a6b503ce00a2390819f21f93cd59a608ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11426a4d502cac062773071cf7fd320a383564ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11426a4d502cac062773071cf7fd320a383564ff", "html_url": "https://github.com/rust-lang/rust/commit/11426a4d502cac062773071cf7fd320a383564ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11426a4d502cac062773071cf7fd320a383564ff/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eda0699443b076387651c7647fa1cf931c6df2f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda0699443b076387651c7647fa1cf931c6df2f6", "html_url": "https://github.com/rust-lang/rust/commit/eda0699443b076387651c7647fa1cf931c6df2f6"}], "stats": {"total": 640, "additions": 349, "deletions": 291}, "files": [{"sha": "58d27d4c5dbe43b51e1630d3734ecc17879dfc1f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/11426a4d502cac062773071cf7fd320a383564ff/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11426a4d502cac062773071cf7fd320a383564ff/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=11426a4d502cac062773071cf7fd320a383564ff", "patch": "@@ -19,6 +19,12 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n pub use rustc_target::abi::*;\n+use rustc_target::spec::HasTargetSpec;\n+use rustc_target::abi::call::{\n+    ArgAttribute, ArgAttributes, ArgType, Conv, FnType, IgnoreMode, PassMode\n+};\n+\n+\n \n pub trait IntegerExt {\n     fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n@@ -2259,3 +2265,346 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LayoutError<'gcx>\n         }\n     }\n }\n+\n+pub trait FnTypeExt<'tcx, C> {\n+    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self\n+    where\n+        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+            + HasDataLayout\n+            + HasTargetSpec\n+            + HasTyCtxt<'tcx>\n+            + HasParamEnv<'tcx>;\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self\n+    where\n+        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+            + HasDataLayout\n+            + HasTargetSpec\n+            + HasTyCtxt<'tcx>\n+            + HasParamEnv<'tcx>;\n+    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self\n+    where\n+        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+            + HasDataLayout\n+            + HasTargetSpec\n+            + HasTyCtxt<'tcx>\n+            + HasParamEnv<'tcx>;\n+    fn new_internal(\n+        cx: &C,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>],\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self\n+    where\n+        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+            + HasDataLayout\n+            + HasTargetSpec\n+            + HasTyCtxt<'tcx>\n+            + HasParamEnv<'tcx>;\n+}\n+\n+\n+impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>> {\n+    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self\n+    where\n+        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+            + HasDataLayout\n+            + HasTargetSpec\n+            + HasTargetSpec\n+            + HasTyCtxt<'tcx>\n+            + HasParamEnv<'tcx>,\n+    {\n+        let sig = instance.fn_sig(cx.tcx());\n+        let sig = cx\n+            .tcx()\n+            .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        call::FnType::new(cx, sig, &[])\n+    }\n+\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self\n+    where\n+        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+            + HasDataLayout\n+            + HasTargetSpec\n+            + HasTyCtxt<'tcx>\n+            + HasParamEnv<'tcx>,\n+    {\n+        call::FnType::new_internal(cx, sig, extra_args, |ty, _| ArgType::new(cx.layout_of(ty)))\n+    }\n+\n+\n+    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self\n+    where\n+        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+            + HasDataLayout\n+            + HasTargetSpec\n+            + HasTyCtxt<'tcx>\n+            + HasParamEnv<'tcx>,\n+    {\n+        FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+            let mut layout = cx.layout_of(ty);\n+            // Don't pass the vtable, it's not an argument of the virtual fn.\n+            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n+            if arg_idx == Some(0) {\n+                let fat_pointer_ty = if layout.is_unsized() {\n+                    // unsized `self` is passed as a pointer to `self`\n+                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+                    cx.tcx().mk_mut_ptr(layout.ty)\n+                } else {\n+                    match layout.abi {\n+                        Abi::ScalarPair(..) => (),\n+                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout),\n+                    }\n+\n+                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n+                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n+                    // elsewhere in the compiler as a method on a `dyn Trait`.\n+                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n+                    // get a built-in pointer type\n+                    let mut fat_pointer_layout = layout;\n+                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+                        && !fat_pointer_layout.ty.is_region_ptr()\n+                    {\n+                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n+                            let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                            if !field_layout.is_zst() {\n+                                fat_pointer_layout = field_layout;\n+                                continue 'descend_newtypes;\n+                            }\n+                        }\n+\n+                        bug!(\n+                            \"receiver has no non-zero-sized fields {:?}\",\n+                            fat_pointer_layout\n+                        );\n+                    }\n+\n+                    fat_pointer_layout.ty\n+                };\n+\n+                // we now have a type like `*mut RcBox<dyn Trait>`\n+                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+                // this is understood as a special case elsewhere in the compiler\n+                let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n+                layout = cx.layout_of(unit_pointer_ty);\n+                layout.ty = fat_pointer_ty;\n+            }\n+            ArgType::new(layout)\n+        })\n+    }\n+\n+    fn new_internal(\n+    cx: &C,\n+    sig: ty::FnSig<'tcx>,\n+    extra_args: &[Ty<'tcx>],\n+    mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self\n+    where\n+        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+            + HasDataLayout\n+            + HasTargetSpec\n+            + HasTargetSpec\n+            + HasTyCtxt<'tcx>\n+            + HasParamEnv<'tcx>,\n+    {\n+        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n+\n+        use rustc_target::spec::abi::Abi::*;\n+        let conv = match cx.tcx().sess.target.target.adjust_abi(sig.abi) {\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::C,\n+\n+            // It's the ABI's job to select this, not ours.\n+            System => bug!(\"system abi should be selected elsewhere\"),\n+\n+            Stdcall => Conv::X86Stdcall,\n+            Fastcall => Conv::X86Fastcall,\n+            Vectorcall => Conv::X86VectorCall,\n+            Thiscall => Conv::X86ThisCall,\n+            C => Conv::C,\n+            Unadjusted => Conv::C,\n+            Win64 => Conv::X86_64Win64,\n+            SysV64 => Conv::X86_64SysV,\n+            Aapcs => Conv::ArmAapcs,\n+            PtxKernel => Conv::PtxKernel,\n+            Msp430Interrupt => Conv::Msp430Intr,\n+            X86Interrupt => Conv::X86Intr,\n+            AmdGpuKernel => Conv::AmdGpuKernel,\n+\n+            // These API constants ought to be more specific...\n+            Cdecl => Conv::C,\n+        };\n+\n+        let mut inputs = sig.inputs();\n+        let extra_args = if sig.abi == RustCall {\n+            assert!(!sig.c_variadic && extra_args.is_empty());\n+\n+            match sig.inputs().last().unwrap().sty {\n+                ty::Tuple(tupled_arguments) => {\n+                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n+                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n+                }\n+                _ => {\n+                    bug!(\n+                        \"argument to function with \\\"rust-call\\\" ABI \\\n+                         is not a tuple\"\n+                    );\n+                }\n+            }\n+        } else {\n+            assert!(sig.c_variadic || extra_args.is_empty());\n+            extra_args.to_vec()\n+        };\n+\n+        let target = &cx.tcx().sess.target.target;\n+        let win_x64_gnu =\n+            target.target_os == \"windows\" && target.arch == \"x86_64\" && target.target_env == \"gnu\";\n+        let linux_s390x =\n+            target.target_os == \"linux\" && target.arch == \"s390x\" && target.target_env == \"gnu\";\n+        let linux_sparc64 =\n+            target.target_os == \"linux\" && target.arch == \"sparc64\" && target.target_env == \"gnu\";\n+        let rust_abi = match sig.abi {\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n+            _ => false,\n+        };\n+\n+        // Handle safe Rust thin and fat pointers.\n+        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n+                                      scalar: &Scalar,\n+                                      layout: TyLayout<'tcx>,\n+                                      offset: Size,\n+                                      is_return: bool| {\n+            // Booleans are always an i1 that needs to be zero-extended.\n+            if scalar.is_bool() {\n+                attrs.set(ArgAttribute::ZExt);\n+                return;\n+            }\n+\n+            // Only pointer types handled below.\n+            if scalar.value != Pointer {\n+                return;\n+            }\n+\n+            if scalar.valid_range.start() < scalar.valid_range.end() {\n+                if *scalar.valid_range.start() > 0 {\n+                    attrs.set(ArgAttribute::NonNull);\n+                }\n+            }\n+\n+            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n+                if let Some(kind) = pointee.safe {\n+                    attrs.pointee_size = pointee.size;\n+                    attrs.pointee_align = Some(pointee.align);\n+\n+                    // `Box` pointer parameters never alias because ownership is transferred\n+                    // `&mut` pointer parameters never alias other parameters,\n+                    // or mutable global data\n+                    //\n+                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n+                    // and can be marked as both `readonly` and `noalias`, as\n+                    // LLVM's definition of `noalias` is based solely on memory\n+                    // dependencies rather than pointer equality\n+                    let no_alias = match kind {\n+                        PointerKind::Shared => false,\n+                        PointerKind::UniqueOwned => true,\n+                        PointerKind::Frozen | PointerKind::UniqueBorrowed => !is_return,\n+                    };\n+                    if no_alias {\n+                        attrs.set(ArgAttribute::NoAlias);\n+                    }\n+\n+                    if kind == PointerKind::Frozen && !is_return {\n+                        attrs.set(ArgAttribute::ReadOnly);\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Store the index of the last argument. This is useful for working with\n+        // C-compatible variadic arguments.\n+        let last_arg_idx = if sig.inputs().is_empty() {\n+            None\n+        } else {\n+            Some(sig.inputs().len() - 1)\n+        };\n+\n+        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n+            let is_return = arg_idx.is_none();\n+            let mut arg = mk_arg_type(ty, arg_idx);\n+            if arg.layout.is_zst() {\n+                // For some forsaken reason, x86_64-pc-windows-gnu\n+                // doesn't ignore zero-sized struct arguments.\n+                // The same is true for s390x-unknown-linux-gnu\n+                // and sparc64-unknown-linux-gnu.\n+                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n+                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n+                }\n+            }\n+\n+            // If this is a C-variadic function, this is not the return value,\n+            // and there is one or more fixed arguments; ensure that the `VaList`\n+            // is ignored as an argument.\n+            if sig.c_variadic {\n+                match (last_arg_idx, arg_idx) {\n+                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n+                        let va_list_did = match cx.tcx().lang_items().va_list() {\n+                            Some(did) => did,\n+                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n+                        };\n+                        match ty.sty {\n+                            ty::Adt(def, _) if def.did == va_list_did => {\n+                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n+                                // so that it will be ignored.\n+                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n+                            }\n+                            _ => (),\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n+            if !is_return && rust_abi {\n+                if let Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n+                    let mut a_attrs = ArgAttributes::new();\n+                    let mut b_attrs = ArgAttributes::new();\n+                    adjust_for_rust_scalar(&mut a_attrs, a, arg.layout, Size::ZERO, false);\n+                    adjust_for_rust_scalar(\n+                        &mut b_attrs,\n+                        b,\n+                        arg.layout,\n+                        a.value.size(cx).align_to(b.value.align(cx).abi),\n+                        false,\n+                    );\n+                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n+                    return arg;\n+                }\n+            }\n+\n+            if let Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    adjust_for_rust_scalar(attrs, scalar, arg.layout, Size::ZERO, is_return);\n+                }\n+            }\n+\n+            arg\n+        };\n+\n+        let fn_ty = FnType {\n+            ret: arg_of(sig.output(), None),\n+            args: inputs\n+                .iter()\n+                .cloned()\n+                .chain(extra_args)\n+                .enumerate()\n+                .map(|(i, ty)| arg_of(ty, Some(i)))\n+                .collect(),\n+            c_variadic: sig.c_variadic,\n+            conv,\n+        };\n+        // FIXME: uncomment this after figuring out wwhere should adjust_for_abi reside.\n+        //fn_ty.adjust_for_abi(cx, sig.abi);\n+        fn_ty\n+    }\n+}"}, {"sha": "cf4a523d9caa57156a4808f06c4cf0bd224c04f7", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/11426a4d502cac062773071cf7fd320a383564ff/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11426a4d502cac062773071cf7fd320a383564ff/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=11426a4d502cac062773071cf7fd320a383564ff", "patch": "@@ -295,19 +295,6 @@ impl ArgTypeMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n }\n \n pub trait FnTypeExt<'tcx> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self;\n-    fn new(cx: &CodegenCx<'ll, 'tcx>,\n-           sig: ty::FnSig<'tcx>,\n-           extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                  sig: ty::FnSig<'tcx>,\n-                  extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_internal(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self;\n     fn adjust_for_abi(&mut self,\n                       cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi);\n@@ -319,284 +306,6 @@ pub trait FnTypeExt<'tcx> {\n }\n \n impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self {\n-        let sig = instance.fn_sig(cx.tcx);\n-        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        FnType::new(cx, sig, &[])\n-    }\n-\n-    fn new(cx: &CodegenCx<'ll, 'tcx>,\n-           sig: ty::FnSig<'tcx>,\n-           extra_args: &[Ty<'tcx>]) -> Self {\n-        FnType::new_internal(cx, sig, extra_args, |ty, _| {\n-            ArgType::new(cx.layout_of(ty))\n-        })\n-    }\n-\n-    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                  sig: ty::FnSig<'tcx>,\n-                  extra_args: &[Ty<'tcx>]) -> Self {\n-        FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n-            let mut layout = cx.layout_of(ty);\n-            // Don't pass the vtable, it's not an argument of the virtual fn.\n-            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n-            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if arg_idx == Some(0) {\n-                let fat_pointer_ty = if layout.is_unsized() {\n-                    // unsized `self` is passed as a pointer to `self`\n-                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n-                    cx.tcx.mk_mut_ptr(layout.ty)\n-                } else {\n-                    match layout.abi {\n-                        LayoutAbi::ScalarPair(..) => (),\n-                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout)\n-                    }\n-\n-                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n-                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n-                    // elsewhere in the compiler as a method on a `dyn Trait`.\n-                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n-                    // get a built-in pointer type\n-                    let mut fat_pointer_layout = layout;\n-                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n-                        && !fat_pointer_layout.ty.is_region_ptr()\n-                    {\n-                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n-                            let field_layout = fat_pointer_layout.field(cx, i);\n-\n-                            if !field_layout.is_zst() {\n-                                fat_pointer_layout = field_layout;\n-                                continue 'descend_newtypes\n-                            }\n-                        }\n-\n-                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n-                    }\n-\n-                    fat_pointer_layout.ty\n-                };\n-\n-                // we now have a type like `*mut RcBox<dyn Trait>`\n-                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n-                // this is understood as a special case elsewhere in the compiler\n-                let unit_pointer_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_unit());\n-                layout = cx.layout_of(unit_pointer_ty);\n-                layout.ty = fat_pointer_ty;\n-            }\n-            ArgType::new(layout)\n-        })\n-    }\n-\n-    fn new_internal(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self {\n-        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n-\n-        use self::Abi::*;\n-        let conv = match cx.sess().target.target.adjust_abi(sig.abi) {\n-            RustIntrinsic | PlatformIntrinsic |\n-            Rust | RustCall => Conv::C,\n-\n-            // It's the ABI's job to select this, not ours.\n-            System => bug!(\"system abi should be selected elsewhere\"),\n-\n-            Stdcall => Conv::X86Stdcall,\n-            Fastcall => Conv::X86Fastcall,\n-            Vectorcall => Conv::X86VectorCall,\n-            Thiscall => Conv::X86ThisCall,\n-            C => Conv::C,\n-            Unadjusted => Conv::C,\n-            Win64 => Conv::X86_64Win64,\n-            SysV64 => Conv::X86_64SysV,\n-            Aapcs => Conv::ArmAapcs,\n-            PtxKernel => Conv::PtxKernel,\n-            Msp430Interrupt => Conv::Msp430Intr,\n-            X86Interrupt => Conv::X86Intr,\n-            AmdGpuKernel => Conv::AmdGpuKernel,\n-\n-            // These API constants ought to be more specific...\n-            Cdecl => Conv::C,\n-        };\n-\n-        let mut inputs = sig.inputs();\n-        let extra_args = if sig.abi == RustCall {\n-            assert!(!sig.c_variadic && extra_args.is_empty());\n-\n-            match sig.inputs().last().unwrap().sty {\n-                ty::Tuple(tupled_arguments) => {\n-                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n-                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n-                }\n-                _ => {\n-                    bug!(\"argument to function with \\\"rust-call\\\" ABI \\\n-                          is not a tuple\");\n-                }\n-            }\n-        } else {\n-            assert!(sig.c_variadic || extra_args.is_empty());\n-            extra_args.to_vec()\n-        };\n-\n-        let target = &cx.sess().target.target;\n-        let win_x64_gnu = target.target_os == \"windows\"\n-                       && target.arch == \"x86_64\"\n-                       && target.target_env == \"gnu\";\n-        let linux_s390x = target.target_os == \"linux\"\n-                       && target.arch == \"s390x\"\n-                       && target.target_env == \"gnu\";\n-        let linux_sparc64 = target.target_os == \"linux\"\n-                       && target.arch == \"sparc64\"\n-                       && target.target_env == \"gnu\";\n-        let rust_abi = match sig.abi {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n-            _ => false\n-        };\n-\n-        // Handle safe Rust thin and fat pointers.\n-        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n-                                      scalar: &layout::Scalar,\n-                                      layout: TyLayout<'tcx, Ty<'tcx>>,\n-                                      offset: Size,\n-                                      is_return: bool| {\n-            // Booleans are always an i1 that needs to be zero-extended.\n-            if scalar.is_bool() {\n-                attrs.set(ArgAttribute::ZExt);\n-                return;\n-            }\n-\n-            // Only pointer types handled below.\n-            if scalar.value != layout::Pointer {\n-                return;\n-            }\n-\n-            if scalar.valid_range.start() < scalar.valid_range.end() {\n-                if *scalar.valid_range.start() > 0 {\n-                    attrs.set(ArgAttribute::NonNull);\n-                }\n-            }\n-\n-            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n-                if let Some(kind) = pointee.safe {\n-                    attrs.pointee_size = pointee.size;\n-                    attrs.pointee_align = Some(pointee.align);\n-\n-                    // `Box` pointer parameters never alias because ownership is transferred\n-                    // `&mut` pointer parameters never alias other parameters,\n-                    // or mutable global data\n-                    //\n-                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n-                    // and can be marked as both `readonly` and `noalias`, as\n-                    // LLVM's definition of `noalias` is based solely on memory\n-                    // dependencies rather than pointer equality\n-                    let no_alias = match kind {\n-                        PointerKind::Shared => false,\n-                        PointerKind::UniqueOwned => true,\n-                        PointerKind::Frozen |\n-                        PointerKind::UniqueBorrowed => !is_return\n-                    };\n-                    if no_alias {\n-                        attrs.set(ArgAttribute::NoAlias);\n-                    }\n-\n-                    if kind == PointerKind::Frozen && !is_return {\n-                        attrs.set(ArgAttribute::ReadOnly);\n-                    }\n-                }\n-            }\n-        };\n-\n-        // Store the index of the last argument. This is useful for working with\n-        // C-compatible variadic arguments.\n-        let last_arg_idx = if sig.inputs().is_empty() {\n-            None\n-        } else {\n-            Some(sig.inputs().len() - 1)\n-        };\n-\n-        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n-            let is_return = arg_idx.is_none();\n-            let mut arg = mk_arg_type(ty, arg_idx);\n-            if arg.layout.is_zst() {\n-                // For some forsaken reason, x86_64-pc-windows-gnu\n-                // doesn't ignore zero-sized struct arguments.\n-                // The same is true for s390x-unknown-linux-gnu\n-                // and sparc64-unknown-linux-gnu.\n-                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n-                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n-                }\n-            }\n-\n-            // If this is a C-variadic function, this is not the return value,\n-            // and there is one or more fixed arguments; ensure that the `VaList`\n-            // is ignored as an argument.\n-            if sig.c_variadic {\n-                match (last_arg_idx, arg_idx) {\n-                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n-                        let va_list_did = match cx.tcx.lang_items().va_list() {\n-                            Some(did) => did,\n-                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n-                        };\n-                        match ty.sty {\n-                            ty::Adt(def, _) if def.did == va_list_did => {\n-                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n-                                // so that it will be ignored.\n-                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n-            if !is_return && rust_abi {\n-                if let layout::Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n-                    let mut a_attrs = ArgAttributes::new();\n-                    let mut b_attrs = ArgAttributes::new();\n-                    adjust_for_rust_scalar(&mut a_attrs,\n-                                           a,\n-                                           arg.layout,\n-                                           Size::ZERO,\n-                                           false);\n-                    adjust_for_rust_scalar(&mut b_attrs,\n-                                           b,\n-                                           arg.layout,\n-                                           a.value.size(cx).align_to(b.value.align(cx).abi),\n-                                           false);\n-                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n-                    return arg;\n-                }\n-            }\n-\n-            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n-                if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    adjust_for_rust_scalar(attrs,\n-                                           scalar,\n-                                           arg.layout,\n-                                           Size::ZERO,\n-                                           is_return);\n-                }\n-            }\n-\n-            arg\n-        };\n-\n-        let mut fn_ty = FnType {\n-            ret: arg_of(sig.output(), None),\n-            args: inputs.iter().cloned().chain(extra_args).enumerate().map(|(i, ty)| {\n-                arg_of(ty, Some(i))\n-            }).collect(),\n-            c_variadic: sig.c_variadic,\n-            conv,\n-        };\n-        fn_ty.adjust_for_abi(cx, sig.abi);\n-        fn_ty\n-    }\n-\n     fn adjust_for_abi(&mut self,\n                       cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi) {"}]}