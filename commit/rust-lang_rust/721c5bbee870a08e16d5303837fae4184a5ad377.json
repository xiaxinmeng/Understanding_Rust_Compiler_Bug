{"sha": "721c5bbee870a08e16d5303837fae4184a5ad377", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMWM1YmJlZTg3MGEwOGUxNmQ1MzAzODM3ZmFlNDE4NGE1YWQzNzc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-08T00:54:22Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-08T01:08:17Z"}, "message": "More work on proper linkage name-mangling. Almost right, aside from version numbers.", "tree": {"sha": "58d5b200ced70e7c2459385d12a229500923f4f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58d5b200ced70e7c2459385d12a229500923f4f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/721c5bbee870a08e16d5303837fae4184a5ad377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/721c5bbee870a08e16d5303837fae4184a5ad377", "html_url": "https://github.com/rust-lang/rust/commit/721c5bbee870a08e16d5303837fae4184a5ad377", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/721c5bbee870a08e16d5303837fae4184a5ad377/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7034a28241763df5fbb6c5ae748f2455b46975f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7034a28241763df5fbb6c5ae748f2455b46975f8", "html_url": "https://github.com/rust-lang/rust/commit/7034a28241763df5fbb6c5ae748f2455b46975f8"}], "stats": {"total": 524, "additions": 381, "deletions": 143}, "files": [{"sha": "6469bbd3ced259a967adfe4f7aab274951cbe6f7", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 244, "deletions": 2, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -1,8 +1,18 @@\n import driver::session;\n import lib::llvm::llvm;\n import middle::trans;\n+import middle::metadata;\n+import middle::ty;\n import std::str;\n import std::fs;\n+import std::vec;\n+import std::option;\n+import option::some;\n+import option::none;\n+import std::sha1::sha1;\n+import std::sort;\n+import trans::crate_ctxt;\n+import front::ast;\n \n import lib::llvm::llvm::ModuleRef;\n import lib::llvm::llvm::ValueRef;\n@@ -49,7 +59,7 @@ fn link_intrinsics(session::session sess, ModuleRef llmod) {\n \n     auto linkres = llvm::LLVMLinkModules(llmod, llintrinsicsmod);\n     llvm::LLVMDisposeModule(llintrinsicsmod);\n-    \n+\n     if (linkres == False) {\n         llvm_err(sess, \"couldn't link the module with the intrinsics\");\n         fail;\n@@ -58,7 +68,7 @@ fn link_intrinsics(session::session sess, ModuleRef llmod) {\n \n mod write {\n     fn is_object_or_assembly_or_exe(output_type ot) -> bool {\n-        if ( (ot == output_type_assembly) || \n+        if ( (ot == output_type_assembly) ||\n              (ot == output_type_object) ||\n              (ot == output_type_exe) ) {\n             ret true;\n@@ -218,3 +228,235 @@ mod write {\n     }\n }\n \n+/*\n+ * Name mangling and its relationship to metadata. This is complex. Read\n+ * carefully.\n+ *\n+ * The semantic model of Rust linkage is, broadly, that \"there's no global\n+ * namespace\" between crates. Our aim is to preserve the illusion of this\n+ * model despite the fact that it's not *quite* possible to implement on\n+ * modern linkers. We initially didn't use system linkers at all, but have\n+ * been convinced of their utility.\n+ *\n+ * There are a few issues to handle:\n+ *\n+ *  - Linkers operate on a flat namespace, so we have to flatten names.\n+ *    We do this using the C++ namespace-mangling technique. Foo::bar\n+ *    symbols and such.\n+ *\n+ *  - Symbols with the same name but different types need to get different\n+ *    linkage-names. We do this by hashing a string-encoding of the type into\n+ *    a fixed-size (currently 16-byte hex) cryptographic hash function (CHF:\n+ *    we use SHA1) to \"prevent collisions\". This is not airtight but 16 hex\n+ *    digits on uniform probability means you're going to need 2**32 same-name\n+ *    symbols in the same process before you're even hitting birthday-paradox\n+ *    collision probability.\n+ *\n+ *  - Symbols in dirrerent crates but with same names \"within\" the crate need\n+ *    to get different linkage-names.\n+ *\n+ * So here is what we do:\n+ *\n+ *  - Separate the meta tags into two sets: exported and local. Only work with\n+ *    the exported ones when considering linkage.\n+ *\n+ *  - Consider two exported tags as special (and madatory): name and vers.\n+ *    Every crate gets them; if it doesn't name them explicitly we infer them\n+ *    as basename(crate) and \"0.1\", respectively. Call these CNAME, CVERS.\n+ *\n+ *  - Define CMETA as all the non-name, non-vers exported meta tags in the\n+ *    crate (in sorted order).\n+ *\n+ *  - Define CMH as hash(CMETA).\n+ *\n+ *  - Compile our crate to lib CNAME-CMH-CVERS.so\n+ *\n+ *  - Define STH(sym) as hash(CNAME, CMH, type_str(sym))\n+ *\n+ *  - Suffix a mangled sym with ::STH@CVERS, so that it is unique in the\n+ *    name, non-name metadata, and type sense, and versioned in the way\n+ *    system linkers understand.\n+ *\n+ */\n+\n+\n+iter crate_export_metas(ast::crate c) -> @ast::meta_item {\n+    for (@ast::crate_directive cdir in c.node.directives) {\n+        alt (cdir.node) {\n+            case (ast::cdir_meta(?v, ?mis)) {\n+                if (v == ast::export_meta) {\n+                    for (@ast::meta_item mi in mis) {\n+                        put mi;\n+                    }\n+                }\n+            }\n+            case (_) {}\n+        }\n+    }\n+}\n+fn get_crate_meta(&session::session sess,\n+                  &ast::crate c, str k, str default,\n+                  bool warn_default) -> str {\n+    let vec[@ast::meta_item] v = [];\n+    for each (@ast::meta_item mi in crate_export_metas(c)) {\n+        if (mi.node.name == k) {\n+            v += [mi];\n+        }\n+    }\n+    alt (vec::len(v)) {\n+        case (0u) {\n+            if (warn_default) {\n+                sess.warn(#fmt(\"missing meta '%s', using '%s' as default\",\n+                               k, default));\n+            }\n+            ret default;\n+        }\n+        case (1u) {\n+            ret v.(0).node.value;\n+        }\n+        case (_) {\n+            sess.span_err(v.(1).span, #fmt(\"duplicate meta '%s'\", k));\n+        }\n+    }\n+}\n+\n+// This calculates CMH as defined above\n+fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n+    fn lteq(&@ast::meta_item ma,\n+            &@ast::meta_item mb) -> bool {\n+        ret ma.node.name <= mb.node.name;\n+    }\n+\n+    fn len_and_str(&str s) -> str {\n+        ret #fmt(\"%u_%s\", str::byte_len(s), s);\n+    }\n+\n+    let vec[mutable @ast::meta_item] v = [mutable];\n+    for each (@ast::meta_item mi in crate_export_metas(crate)) {\n+        if (mi.node.name != \"name\" &&\n+            mi.node.name != \"vers\") {\n+            v += [mutable mi];\n+        }\n+    }\n+    sort::quick_sort(lteq, v);\n+    sha.reset();\n+    for (@ast::meta_item m in v) {\n+        sha.input_str(len_and_str(m.node.name));\n+        sha.input_str(len_and_str(m.node.value));\n+    }\n+    ret truncated_sha1_result(sha);\n+}\n+\n+fn crate_meta_name(&session::session sess, &ast::crate crate,\n+                       &str output) -> str {\n+    auto os = str::split(fs::basename(output), '.' as u8);\n+    assert vec::len(os) >= 2u;\n+    vec::pop(os);\n+    ret get_crate_meta(sess, crate, \"name\", str::connect(os, \".\"),\n+                       sess.get_opts().shared);\n+}\n+\n+fn crate_meta_vers(&session::session sess, &ast::crate crate) -> str {\n+    ret get_crate_meta(sess, crate, \"vers\", \"0.0\",\n+                       sess.get_opts().shared);\n+}\n+\n+fn truncated_sha1_result(sha1 sha) -> str {\n+    ret str::substr(sha.result_str(), 0u, 16u);\n+}\n+\n+\n+\n+// This calculates STH for a symbol, as defined above\n+fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t,\n+               str crate_meta_name,\n+               str crate_meta_extras_hash) -> str {\n+    // NB: do *not* use abbrevs here as we want the symbol names\n+    // to be independent of one another in the crate.\n+    auto cx = @rec(ds=metadata::def_to_str, tcx=tcx,\n+                   abbrevs=metadata::ac_no_abbrevs);\n+    sha.reset();\n+    sha.input_str(crate_meta_name);\n+    sha.input_str(\"-\");\n+    sha.input_str(crate_meta_name);\n+    sha.input_str(\"-\");\n+    sha.input_str(metadata::Encode::ty_str(cx, t));\n+    auto hash = truncated_sha1_result(sha);\n+    // Prefix with _ so that it never blends into adjacent digits\n+    ret \"_\" + hash;\n+}\n+\n+fn get_symbol_hash(&@crate_ctxt ccx, &ty::t t) -> str {\n+    auto hash = \"\";\n+    alt (ccx.type_sha1s.find(t)) {\n+        case (some(?h)) { hash = h; }\n+        case (none) {\n+            hash = symbol_hash(ccx.tcx, ccx.sha, t,\n+                               ccx.crate_meta_name,\n+                               ccx.crate_meta_extras_hash);\n+            ccx.type_sha1s.insert(t, hash);\n+        }\n+    }\n+    ret hash;\n+}\n+\n+\n+fn mangle(&vec[str] ss) -> str {\n+\n+    // Follow C++ namespace-mangling style\n+\n+    auto n = \"_ZN\"; // Begin name-sequence.\n+\n+    for (str s in ss) {\n+        n += #fmt(\"%u%s\", str::byte_len(s), s);\n+    }\n+\n+    n += \"E\"; // End name-sequence.\n+    ret n;\n+}\n+\n+\n+fn exported_name(&vec[str] path, &str hash, &str vers) -> str {\n+    // FIXME: versioning isn't working yet\n+    ret mangle(path + [hash]); //  + \"@\" + vers;\n+}\n+\n+fn mangle_exported_name(&@crate_ctxt ccx, &vec[str] path,\n+                        &ty::t t) -> str {\n+    auto hash = get_symbol_hash(ccx, t);\n+    ret exported_name(path, hash, ccx.crate_meta_vers);\n+}\n+\n+fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t,\n+                                     &str name) -> str {\n+    auto f = metadata::def_to_str;\n+    auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata::ac_no_abbrevs);\n+    auto s = ty::ty_to_short_str(ccx.tcx, t);\n+\n+    auto hash = get_symbol_hash(ccx, t);\n+    ret mangle([name, s, hash]);\n+}\n+\n+fn mangle_internal_name_by_path_and_seq(&@crate_ctxt ccx, &vec[str] path,\n+                                       &str flav) -> str {\n+    ret mangle(path + [ccx.names.next(flav)]);\n+}\n+\n+fn mangle_internal_name_by_path(&@crate_ctxt ccx, &vec[str] path) -> str {\n+    ret mangle(path);\n+}\n+\n+fn mangle_internal_name_by_seq(&@crate_ctxt ccx, &str flav) -> str {\n+    ret ccx.names.next(flav);\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "e0080ca2651560c42c84d85efa3cc5c76b9a4a06", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -6,6 +6,9 @@ import std::uint;\n import std::term;\n import std::io;\n import std::map;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n \n tag os {\n     os_win32;\n@@ -48,9 +51,16 @@ fn span_to_str(span sp, codemap::codemap cm) -> str {\n               lo.col, hi.line, hi.col));\n }\n \n-fn emit_diagnostic(span sp, str msg, str kind, u8 color,\n+fn emit_diagnostic(option::t[span] sp, str msg, str kind, u8 color,\n                    codemap::codemap cm) {\n-    io::stdout().write_str(span_to_str(sp, cm) + \": \");\n+    auto ss = \"<input>:0:0:0:0\";\n+    alt (sp) {\n+        case (some(?ssp)) {\n+            ss = span_to_str(ssp, cm);\n+        }\n+        case (none) {}\n+    }\n+    io::stdout().write_str(ss + \": \");\n \n     if (term::color_supported()) {\n         term::fg(io::stdout().get_buf_writer(), color);\n@@ -85,12 +95,12 @@ state obj session(ast::crate_num cnum,\n \n     fn span_err(span sp, str msg) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        emit_diagnostic(sp, msg, \"error\", 9u8, cm);\n+        emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n         fail;\n     }\n \n     fn err(str msg) -> ! {\n-        log_err #fmt(\"error: %s\", msg);\n+        emit_diagnostic(none[span], msg, \"error\", 9u8, cm);\n         fail;\n     }\n \n@@ -103,29 +113,32 @@ state obj session(ast::crate_num cnum,\n \n     fn span_warn(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        emit_diagnostic(sp, msg, \"warning\", 11u8, cm);\n+        emit_diagnostic(some(sp), msg, \"warning\", 11u8, cm);\n+    }\n+\n+    fn warn(str msg) {\n+        emit_diagnostic(none[span], msg, \"warning\", 11u8, cm);\n     }\n \n     fn span_note(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n+        emit_diagnostic(some(sp), msg, \"note\", 10u8, cm);\n+    }\n+\n+    fn span_bug(span sp, str msg) -> ! {\n+        self.span_err(sp, #fmt(\"internal compiler error %s\", msg));\n     }\n \n     fn bug(str msg) -> ! {\n-        log_err #fmt(\"error: internal compiler error %s\", msg);\n-        fail;\n+        self.err(#fmt(\"internal compiler error %s\", msg));\n     }\n \n     fn span_unimpl(span sp, str msg) -> ! {\n-        // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        emit_diagnostic(sp, \"internal compiler error: unimplemented \" + msg,\n-                        \"error\", 9u8, cm);\n-        fail;\n+        self.span_bug(sp, \"unimplemented \" + msg);\n     }\n-    \n+\n     fn unimpl(str msg) -> ! {\n-        log_err #fmt(\"error: unimplemented %s\", msg);\n-        fail;\n+        self.bug(\"unimplemented \" + msg);\n     }\n \n     fn get_external_crate(int num) -> crate_metadata {"}, {"sha": "f670c2760a7c5b13c17bb1617129648cf4bd3bf0", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -71,6 +71,11 @@ type crate = spanned[crate_];\n type crate_ = rec(vec[@crate_directive] directives,\n                   _mod module);\n \n+tag meta_visibility {\n+    export_meta;\n+    local_meta;\n+}\n+\n tag crate_directive_ {\n     cdir_expr(@expr);\n     // FIXME: cdir_let should be eliminated\n@@ -80,7 +85,7 @@ tag crate_directive_ {\n     cdir_src_mod(ident, option::t[filename]);\n     cdir_dir_mod(ident, option::t[filename], vec[@crate_directive]);\n     cdir_view_item(@view_item);\n-    cdir_meta(vec[@meta_item]);\n+    cdir_meta(meta_visibility, vec[@meta_item]);\n     cdir_syntax(path);\n     cdir_auth(path, _auth);\n }"}, {"sha": "a8e881ee036c3605003925da38b5171bdfb6fc52", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -418,8 +418,13 @@ fn eval_crate_directive(ctx cx,\n             vec::push[@ast::view_item](view_items, vi);\n         }\n \n-        case (ast::cdir_meta(?mi)) {\n-            cx.sess.add_metadata(mi);\n+        case (ast::cdir_meta(?vi, ?mi)) {\n+            // FIXME: we should actually record, for documentation-sake,\n+            // the metadata that's not exported. It would be nice to have\n+            // compiled-in to the target crate, not just in theh AST.\n+            if (vi == ast::export_meta) {\n+                cx.sess.add_metadata(mi);\n+            }\n         }\n \n         case (ast::cdir_syntax(?pth)) {}"}, {"sha": "b84a740a917de519e4352d1ad7b9c7a7a962f8ee", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -2362,10 +2362,14 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive\n         expect(p, token::SEMI);\n         ret spanned(lo, hi, ast::cdir_auth(n, a));\n     } else if (eat_word(p, \"meta\")) {\n+        auto mv = ast::local_meta;\n+        if (eat_word(p, \"export\")) {\n+            mv = ast::export_meta;\n+        }\n         auto mis = parse_meta(p);\n         auto hi = p.get_hi_pos();\n         expect(p, token::SEMI);\n-        ret spanned(lo, hi, ast::cdir_meta(mis));\n+        ret spanned(lo, hi, ast::cdir_meta(mv, mis));\n     } else if (eat_word(p, \"mod\")) {\n         auto id = parse_ident(p);\n         auto file_opt = none[filename];"}, {"sha": "1687a62fa577726d765d436d782661d44d6754bf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 71, "deletions": 118, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -6,7 +6,7 @@\n // particular definition to the LLVM IR output we're producing.\n //\n // Hopefully useful general knowledge about trans:\n-// \n+//\n //   * There's no way to find out the ty::t type of a ValueRef.  Doing so\n //     would be \"trying to get the eggs out of an omelette\" (credit:\n //     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n@@ -24,6 +24,7 @@ import std::map::hashmap;\n import std::option;\n import std::option::some;\n import std::option::none;\n+import std::fs;\n \n import front::ast;\n import front::creader;\n@@ -62,6 +63,15 @@ import lib::llvm::False;\n import lib::llvm::True;\n import lib::llvm::Bool;\n \n+import link::mangle_internal_name_by_type_only;\n+import link::mangle_internal_name_by_seq;\n+import link::mangle_internal_name_by_path;\n+import link::mangle_internal_name_by_path_and_seq;\n+import link::mangle_exported_name;\n+import link::crate_meta_name;\n+import link::crate_meta_vers;\n+import link::crate_meta_extras_hash;\n+\n state obj namegen(mutable int i) {\n     fn next(str prefix) -> str {\n         i += 1;\n@@ -119,6 +129,9 @@ state type crate_ctxt = rec(session::session sess,\n                                     @ast::native_item] native_items,\n                             hashmap[ast::def_id, str] item_symbols,\n                             mutable option::t[ValueRef] main_fn,\n+                            str crate_meta_name,\n+                            str crate_meta_vers,\n+                            str crate_meta_extras_hash,\n                             // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n                             hashmap[ty::t, uint] tag_sizes,\n                             hashmap[ast::def_id, ValueRef] discrims,\n@@ -166,14 +179,14 @@ type fn_ctxt = rec(\n     ValueRef lltaskptr,\n     ValueRef llenv,\n     ValueRef llretptr,\n-    \n+\n     // The next three elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in the\n     // function, due to LLVM's quirks.\n \n     // A block for all the function's allocas, so that LLVM will coalesce them\n     // into a single alloca call.\n-    mutable BasicBlockRef llallocas, \n+    mutable BasicBlockRef llallocas,\n \n     // A block containing code that copies incoming arguments to space already\n     // allocated by code in the llallocas block.  (LLVM requires that\n@@ -313,73 +326,6 @@ fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n   ret @rec(path = cx.path + [name] with *cx);\n }\n \n-fn get_type_sha1(&@crate_ctxt ccx, &ty::t t) -> str {\n-    auto hash = \"\";\n-    alt (ccx.type_sha1s.find(t)) {\n-        case (some(?h)) { hash = h; }\n-        case (none) {\n-            ccx.sha.reset();\n-            auto f = metadata::def_to_str;\n-            // NB: do *not* use abbrevs here as we want the symbol names\n-            // to be independent of one another in the crate.\n-            auto cx = @rec(ds=f,\n-                           tcx=ccx.tcx,\n-                           abbrevs=metadata::ac_no_abbrevs);\n-\n-            ccx.sha.input_str(metadata::Encode::ty_str(cx, t));\n-            hash = str::substr(ccx.sha.result_str(), 0u, 16u);\n-            // Prefix with _ so that it never blends into adjacent digits\n-            hash = \"_\" + hash;\n-            ccx.type_sha1s.insert(t, hash);\n-        }\n-    }\n-    ret hash;\n-}\n-\n-fn mangle(&vec[str] ss) -> str {\n-\n-    if (vec::len(ss) > 0u && str::eq(vec::top(ss), \"main\")) {\n-        ret \"_rust_main\";\n-    }\n-    // Follow C++ namespace-mangling style\n-\n-    auto n = \"_ZN\"; // Begin name-sequence.\n-\n-    for (str s in ss) {\n-        n += #fmt(\"%u%s\", str::byte_len(s), s);\n-    }\n-\n-    n += \"E\"; // End name-sequence.\n-    ret n;\n-}\n-\n-fn mangle_name_by_type(&@crate_ctxt ccx, &vec[str] path, &ty::t t) -> str {\n-    auto hash = get_type_sha1(ccx, t);\n-    ret mangle(path + [hash]);\n-}\n-\n-fn mangle_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) -> str {\n-    auto f = metadata::def_to_str;\n-    auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata::ac_no_abbrevs);\n-    auto s = ty::ty_to_short_str(ccx.tcx, t);\n-\n-    auto hash = get_type_sha1(ccx, t);\n-    ret mangle([name, s, hash]);\n-}\n-\n-fn mangle_name_by_path_and_seq(&@crate_ctxt ccx, &vec[str] path,\n-                               &str flav) -> str {\n-    ret mangle(path + [ccx.names.next(flav)]);\n-}\n-\n-fn mangle_name_by_path(&vec[str] path) -> str {\n-    ret mangle(path);\n-}\n-\n-fn mangle_name_by_seq(&@crate_ctxt ccx, &str flav) -> str {\n-    ret ccx.names.next(flav);\n-}\n-\n fn res(@block_ctxt bcx, ValueRef val) -> result {\n     ret rec(bcx = bcx,\n             val = val);\n@@ -1917,10 +1863,10 @@ fn declare_tydesc(&@local_ctxt cx, &span sp, &ty::t t,\n \n     auto name;\n     if (cx.ccx.sess.get_opts().debuginfo) {\n-        name = mangle_name_by_type_only(cx.ccx, t, \"tydesc\");\n+        name = mangle_internal_name_by_type_only(cx.ccx, t, \"tydesc\");\n         name = sanitize(name);\n     } else {\n-        name = mangle_name_by_seq(cx.ccx, \"tydesc\");\n+        name = mangle_internal_name_by_seq(cx.ccx, \"tydesc\");\n     }\n \n     auto gvar = llvm::LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n@@ -1951,10 +1897,12 @@ fn declare_generic_glue(&@local_ctxt cx,\n                         &str name) -> ValueRef {\n     auto fn_nm;\n     if (cx.ccx.sess.get_opts().debuginfo) {\n-        fn_nm = mangle_name_by_type_only(cx.ccx, t, \"glue_\" + name);\n+        fn_nm = mangle_internal_name_by_type_only(cx.ccx, t,\n+                                                  \"glue_\" + name);\n         fn_nm = sanitize(fn_nm);\n     } else {\n-        fn_nm = mangle_name_by_seq(cx.ccx,  \"glue_\" + name);\n+        fn_nm = mangle_internal_name_by_seq(cx.ccx,\n+                                            \"glue_\" + name);\n     }\n     auto llfn = decl_fastcall_fn(cx.ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(cx, llfn, t);\n@@ -4106,7 +4054,8 @@ fn trans_for_each(&@block_ctxt cx,\n \n     // Step 2: Declare foreach body function.\n \n-    let str s = mangle_name_by_path_and_seq(lcx.ccx, lcx.path, \"foreach\");\n+    let str s = mangle_internal_name_by_path_and_seq(lcx.ccx, lcx.path,\n+                                                     \"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n@@ -4805,7 +4754,8 @@ fn trans_bind_thunk(&@local_ctxt cx,\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty:\n \n-    let str s = mangle_name_by_path_and_seq(cx.ccx, cx.path, \"thunk\");\n+    let str s = mangle_internal_name_by_path_and_seq(cx.ccx, cx.path,\n+                                                     \"thunk\");\n     let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx.ccx, sp,\n                                                     incoming_fty));\n     let ValueRef llthunk = decl_internal_fastcall_fn(cx.ccx.llmod,\n@@ -5823,13 +5773,17 @@ fn load_if_immediate(&@block_ctxt cx, ValueRef v, &ty::t t) -> ValueRef {\n \n fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n     auto lcx = cx.fcx.lcx;\n-    auto modname = str::connect(lcx.module_path, \"::\");\n+    auto modname = link::mangle_internal_name_by_path(lcx.ccx,\n+                                                      lcx.module_path);\n     auto global;\n     if (lcx.ccx.module_data.contains_key(modname)) {\n         global = lcx.ccx.module_data.get(modname);\n     } else {\n-        global = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n-                                    str::buf(\"_rust_mod_log_\" + modname));\n+        auto s =\n+            link::mangle_internal_name_by_path_and_seq(lcx.ccx,\n+                                                       lcx.module_path,\n+                                                       \"loglevel\");\n+        global = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), str::buf(s));\n         llvm::LLVMSetGlobalConstant(global, False);\n         llvm::LLVMSetInitializer(global, C_null(T_int()));\n         llvm::LLVMSetLinkage(global, lib::llvm::LLVMInternalLinkage\n@@ -6225,8 +6179,8 @@ fn trans_spawn(&@block_ctxt cx,\n     ret res(bcx, new_task);\n }\n \n-fn mk_spawn_wrapper(&@block_ctxt cx, \n-                    &@ast::expr func, \n+fn mk_spawn_wrapper(&@block_ctxt cx,\n+                    &@ast::expr func,\n                     &ty::t args_ty) -> result {\n     auto llmod = cx.fcx.lcx.ccx.llmod;\n     let TypeRef args_ty_tref = type_of(cx.fcx.lcx.ccx, cx.sp, args_ty);\n@@ -6239,9 +6193,9 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n \n     // TODO: construct a name based on tname\n     let str wrap_name =\n-        mangle_name_by_path_and_seq(cx.fcx.lcx.ccx,\n-                                    cx.fcx.lcx.path,\n-                                    \"spawn_wrapper\");\n+        mangle_internal_name_by_path_and_seq(cx.fcx.lcx.ccx,\n+                                             cx.fcx.lcx.path,\n+                                             \"spawn_wrapper\");\n     auto llfndecl = decl_fastcall_fn(llmod, wrap_name,\n                                      wrapper_fn_type);\n \n@@ -6252,7 +6206,7 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n     // 3u to skip the three implicit args\n     let ValueRef arg = llvm::LLVMGetParam(fcx.llfn, 3u);\n \n-    let vec[ValueRef] child_args = \n+    let vec[ValueRef] child_args =\n         [llvm::LLVMGetParam(fcx.llfn, 0u),\n          llvm::LLVMGetParam(fcx.llfn, 1u),\n          llvm::LLVMGetParam(fcx.llfn, 2u)];\n@@ -6271,19 +6225,19 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n             }\n         }\n     }\n-    \n+\n     // Find the function\n     auto fnptr = trans_lval(fbcx, func).res;\n     fbcx = fnptr.bcx;\n-    \n+\n     auto llfnptr = fbcx.build.GEP(fnptr.val,\n                                   [C_int(0), C_int(0)]);\n     auto llfn = fbcx.build.Load(llfnptr);\n-    \n+\n     fbcx.build.FastCall(llfn,\n                         child_args);\n     fbcx.build.RetVoid();\n-    \n+\n     finish_fn(fcx, fbcx.llbb);\n \n     // TODO: make sure we clean up everything we need to.\n@@ -6719,7 +6673,7 @@ fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n     let vec[ast::ty_param] obj_typarams = [];\n     let vec[ast::obj_field] obj_fields = [];\n     ret @rec(path=pth,\n-             module_path=[crate_name(ccx, \"main\")],\n+             module_path=[ccx.crate_meta_name],\n              obj_typarams = obj_typarams,\n              obj_fields = obj_fields,\n              ccx = ccx);\n@@ -7094,7 +7048,7 @@ fn create_vtbl(@local_ctxt cx,\n \n         let @local_ctxt mcx = @rec(path = cx.path + [\"method\",\n                                                      m.node.ident] with *cx);\n-        let str s = mangle_name_by_path(mcx.path);\n+        let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n         let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s,\n                                                       llfnty);\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n@@ -7106,7 +7060,8 @@ fn create_vtbl(@local_ctxt cx,\n         methods += [llfn];\n     }\n     auto vtbl = C_struct(methods);\n-    auto vtbl_name = mangle_name_by_path(cx.path + [\"vtbl\"]);\n+    auto vtbl_name = mangle_internal_name_by_path(cx.ccx,\n+                                                  cx.path + [\"vtbl\"]);\n     auto gvar = llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl),\n                                    str::buf(vtbl_name));\n     llvm::LLVMSetInitializer(gvar, vtbl);\n@@ -7123,7 +7078,7 @@ fn trans_dtor(@local_ctxt cx,\n               &@ast::method dtor) -> ValueRef {\n \n     auto llfnty = T_dtor(cx.ccx, dtor.span, llself_ty);\n-    let str s = mangle_name_by_path(cx.path + [\"drop\"]);\n+    let str s = mangle_internal_name_by_path(cx.ccx, cx.path + [\"drop\"]);\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n     cx.ccx.item_ids.insert(dtor.node.id, llfn);\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n@@ -7516,25 +7471,29 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp,\n         }\n     }\n \n+    let bool is_main = (str::eq(vec::top(path), \"main\") &&\n+                        !ccx.sess.get_opts().shared);\n+\n     // Declare the function itself.\n-    let str s = mangle_name_by_path(path);\n+    let str s =\n+        if (is_main) { \"_rust_main\" }\n+        else { mangle_internal_name_by_path(ccx, path) };\n+\n     let ValueRef llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n \n     // Declare the global constant pair that points to it.\n-    let str ps = mangle_name_by_type(ccx, path, node_ann_type(ccx, ann));\n-\n+    let str ps = mangle_exported_name(ccx, path, node_ann_type(ccx, ann));\n     register_fn_pair(ccx, ps, llpairty, llfn, id);\n \n-    if (str::eq(vec::top(path), \"main\") &&\n-        !ccx.sess.get_opts().shared) {\n+    if (is_main) {\n         if (ccx.main_fn != none[ValueRef]) {\n             ccx.sess.span_err(sp, \"multiple 'main' functions\");\n         }\n-        log #fmt(\"registering %s as main function for crate\", ps);\n         llvm::LLVMSetLinkage(llfn, lib::llvm::LLVMExternalLinkage\n                              as llvm::Linkage);\n         ccx.main_fn = some(llfn);\n     }\n+\n }\n \n fn register_fn_pair(&@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n@@ -7565,7 +7524,7 @@ fn native_fn_ty_param_count(&@crate_ctxt cx, &ast::def_id id) -> uint {\n     alt (native_item.node) {\n         case (ast::native_item_ty(_,_)) {\n             cx.sess.bug(\"decl_native_fn_and_pair(): native fn isn't \" +\n-                        \"actually a fn?!\");\n+                        \"actually a fn\");\n         }\n         case (ast::native_item_fn(_, _, _, ?tps, _, _)) {\n             count = vec::len[ast::ty_param](tps);\n@@ -7594,13 +7553,13 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n     // Declare the wrapper.\n     auto t = node_ann_type(ccx, ann);\n     auto wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n-    let str s = mangle_name_by_path(path);\n+    let str s = mangle_internal_name_by_path(ccx, path);\n     let ValueRef wrapper_fn = decl_internal_fastcall_fn(ccx.llmod, s,\n                                                         wrapper_type);\n \n     // Declare the global constant pair that points to it.\n     auto wrapper_pair_type = T_fn_pair(ccx.tn, wrapper_type);\n-    let str ps = mangle_name_by_type(ccx, path, node_ann_type(ccx, ann));\n+    let str ps = mangle_exported_name(ccx, path, node_ann_type(ccx, ann));\n \n     register_fn_pair(ccx, ps, wrapper_pair_type, wrapper_fn, id);\n \n@@ -7938,7 +7897,7 @@ fn trans_constant(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item it) {\n                 auto discrim_val = C_int(i as int);\n \n                 auto p = wcx.path + [ident, variant.node.name, \"discrim\"];\n-                auto s = mangle_name_by_type(ccx, p, ty::mk_int(ccx.tcx));\n+                auto s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n                 auto discrim_gvar = llvm::LLVMAddGlobal(ccx.llmod, T_int(),\n                                                        str::buf(s));\n \n@@ -7957,8 +7916,8 @@ fn trans_constant(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item it) {\n             // with consts.\n             auto v = C_int(1);\n             ccx.item_ids.insert(cid, v);\n-            auto s = mangle_name_by_type(ccx, wcx.path + [name],\n-                                         node_ann_type(ccx, ann));\n+            auto s = mangle_exported_name(ccx, wcx.path + [name],\n+                                          node_ann_type(ccx, ann));\n             ccx.item_symbols.insert(cid, s);\n         }\n \n@@ -8178,15 +8137,6 @@ fn create_module_map(&@crate_ctxt ccx) -> ValueRef {\n     ret map;\n }\n \n-fn crate_name(&@crate_ctxt ccx, &str deflt) -> str {\n-    for (@ast::meta_item item in ccx.sess.get_metadata()) {\n-        if (str::eq(item.node.name, \"name\")) {\n-            ret item.node.value;\n-        }\n-    }\n-    ret deflt;\n-}\n-\n // FIXME use hashed metadata instead of crate names once we have that\n fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n     let vec[ValueRef] subcrates = [];\n@@ -8199,10 +8149,9 @@ fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n         i += 1;\n     }\n     vec::push[ValueRef](subcrates, C_int(0));\n-    auto cname = crate_name(ccx, \"__none__\");\n     auto mapname;\n     if (ccx.sess.get_opts().shared) {\n-        mapname = cname;\n+        mapname = ccx.crate_meta_name;\n     } else {\n         mapname = \"toplevel\";\n     }\n@@ -8240,7 +8189,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n     auto sha1s = map::mk_hashmap[ty::t,str](hasher, eqer);\n     auto abbrevs = map::mk_hashmap[ty::t,metadata::ty_abbrev](hasher, eqer);\n     auto short_names = map::mk_hashmap[ty::t,str](hasher, eqer);\n-\n+    auto sha = std::sha1::mk_sha1();\n     auto ccx = @rec(sess = sess,\n                     llmod = llmod,\n                     td = td,\n@@ -8252,6 +8201,10 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n                     native_items = new_def_hash[@ast::native_item](),\n                     item_symbols = new_def_hash[str](),\n                     mutable main_fn = none[ValueRef],\n+                    crate_meta_name = crate_meta_name(sess, *crate, output),\n+                    crate_meta_vers = crate_meta_vers(sess, *crate),\n+                    crate_meta_extras_hash =\n+                    crate_meta_extras_hash(sha, *crate),\n                     tag_sizes = tag_sizes,\n                     discrims = new_def_hash[ValueRef](),\n                     discrim_symbols = new_def_hash[str](),\n@@ -8263,7 +8216,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n                     lltypes = lltypes,\n                     glues = glues,\n                     names = namegen(0),\n-                    sha = std::sha1::mk_sha1(),\n+                    sha = sha,\n                     type_sha1s = sha1s,\n                     type_abbrevs = abbrevs,\n                     type_short_names = short_names,"}, {"sha": "1ecafe1f02fe5b2c27f37269c4c35904022a6787", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -68,7 +68,7 @@ fn walk_crate_directive(&ast_visitor v, @ast::crate_directive cd) {\n         case (ast::cdir_view_item(?vi)) {\n             walk_view_item(v, vi);\n         }\n-        case (ast::cdir_meta(_)) {}\n+        case (ast::cdir_meta(_,_)) {}\n         case (ast::cdir_syntax(_)) {}\n         case (ast::cdir_auth(_, _)) {}\n     }"}, {"sha": "92e90e62cbf42f06f95e141ee74c2781352573ee", "filename": "src/lib/fs.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -19,6 +19,20 @@ fn dirname(path p) -> path {\n     ret str::substr(p, 0u, i as uint);\n }\n \n+fn basename(path p) -> path {\n+    let int i = str::rindex(p, os_fs::path_sep as u8);\n+    if (i == -1) {\n+        i = str::rindex(p, os_fs::alt_path_sep as u8);\n+        if (i == -1) {\n+            ret p;\n+        }\n+    }\n+    auto len = str::byte_len(p);\n+    if ((i+1) as uint >= len) { ret p; }\n+\n+    ret str::slice(p, i+1 as uint, len);\n+}\n+\n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n fn connect(path pre, path post) -> path {\n     auto len = str::byte_len(pre);"}, {"sha": "b35b150528d9cb816d4452fa28acb732e4264706", "filename": "src/lib/std.rc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/721c5bbee870a08e16d5303837fae4184a5ad377/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=721c5bbee870a08e16d5303837fae4184a5ad377", "patch": "@@ -1,8 +1,10 @@\n meta (name = \"std\",\n-      desc = \"Rust standard library\",\n+      vers = \"0.1\",\n       uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\",\n-      url = \"http://rust-lang.org/src/std\",\n-      ver = \"0.0.1\");\n+      url = \"http://rust-lang.org/src/std\");\n+\n+meta (comment = \"Rust standard library\",\n+      license = \"BSD\");\n \n // Built-in types support modules.\n "}]}