{"sha": "1f213d983ddf44df10eb52627d3c24213d102e39", "node_id": "C_kwDOAAsO6NoAKDFmMjEzZDk4M2RkZjQ0ZGYxMGViNTI2MjdkM2MyNDIxM2QxMDJlMzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-11T00:08:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-11T00:08:23Z"}, "message": "Auto merge of #92601 - camelid:more-intra-doc-cleanup, r=Manishearth\n\nrustdoc: Remove the intra-doc links side channel\n\nThe side channel made the code much more complex and harder to\nunderstand. It was added as a temporary workaround in\n0c99d806eabd32a2ee2e6c71b400222b99c659e1, but it's no longer necessary.\n\nThe addition of `UrlFragment` in #92088 was the key to getting rid of\nthe side channel. The semantic information (rather than the strings that\nused to be used for fragments) that is now captured by `UrlFragment` is\nenough to obviate the side channel. An additional change had to be made\nto `UrlFragment` in this PR to make this possible: it now records\n`DefId`s rather than item names.\n\nThis PR also consolidates the checks for anchor conflicts into one place.\n\nr? `@Manishearth`", "tree": {"sha": "29dca430bb1d7a48cf35aa0fad775c1afdde9f5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29dca430bb1d7a48cf35aa0fad775c1afdde9f5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f213d983ddf44df10eb52627d3c24213d102e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f213d983ddf44df10eb52627d3c24213d102e39", "html_url": "https://github.com/rust-lang/rust/commit/1f213d983ddf44df10eb52627d3c24213d102e39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f213d983ddf44df10eb52627d3c24213d102e39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89b9f7b284aacc5f8613438b80e4dd7bdd10549e", "url": "https://api.github.com/repos/rust-lang/rust/commits/89b9f7b284aacc5f8613438b80e4dd7bdd10549e", "html_url": "https://github.com/rust-lang/rust/commit/89b9f7b284aacc5f8613438b80e4dd7bdd10549e"}, {"sha": "a626da4e7833598b26d89de01237150986582af4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a626da4e7833598b26d89de01237150986582af4", "html_url": "https://github.com/rust-lang/rust/commit/a626da4e7833598b26d89de01237150986582af4"}], "stats": {"total": 290, "additions": 148, "deletions": 142}, "files": [{"sha": "00c6e38839f5489623c3568e3bed382459295b3e", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f213d983ddf44df10eb52627d3c24213d102e39/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f213d983ddf44df10eb52627d3c24213d102e39/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=1f213d983ddf44df10eb52627d3c24213d102e39", "patch": "@@ -1,6 +1,5 @@\n use std::cell::RefCell;\n use std::default::Default;\n-use std::fmt::Write;\n use std::hash::Hash;\n use std::lazy::SyncOnceCell as OnceCell;\n use std::path::PathBuf;\n@@ -496,7 +495,7 @@ impl Item {\n                 if let Ok((mut href, ..)) = href(*did, cx) {\n                     debug!(?href);\n                     if let Some(ref fragment) = *fragment {\n-                        write!(href, \"{}\", fragment).unwrap()\n+                        fragment.render(&mut href, cx.tcx()).unwrap()\n                     }\n                     Some(RenderedLink {\n                         original_text: s.clone(),"}, {"sha": "9d1a8b3f80fec09da93a8d117b425d6f0eaccb1a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 147, "deletions": 140, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/1f213d983ddf44df10eb52627d3c24213d102e39/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f213d983ddf44df10eb52627d3c24213d102e39/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=1f213d983ddf44df10eb52627d3c24213d102e39", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::{\n     PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n@@ -25,8 +25,8 @@ use smallvec::{smallvec, SmallVec};\n use pulldown_cmark::LinkType;\n \n use std::borrow::Cow;\n-use std::cell::Cell;\n use std::convert::{TryFrom, TryInto};\n+use std::fmt::Write;\n use std::mem;\n use std::ops::Range;\n \n@@ -47,12 +47,8 @@ crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n };\n \n fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    let mut collector = LinkCollector {\n-        cx,\n-        mod_ids: Vec::new(),\n-        kind_side_channel: Cell::new(None),\n-        visited_links: FxHashMap::default(),\n-    };\n+    let mut collector =\n+        LinkCollector { cx, mod_ids: Vec::new(), visited_links: FxHashMap::default() };\n     collector.visit_crate(&krate);\n     krate\n }\n@@ -240,53 +236,73 @@ enum AnchorFailure {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n crate enum UrlFragment {\n-    Method(Symbol),\n-    TyMethod(Symbol),\n-    AssociatedConstant(Symbol),\n-    AssociatedType(Symbol),\n-\n-    StructField(Symbol),\n-    Variant(Symbol),\n-    VariantField { variant: Symbol, field: Symbol },\n-\n+    Item(ItemFragment),\n     UserWritten(String),\n }\n \n impl UrlFragment {\n+    /// Render the fragment, including the leading `#`.\n+    crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+        match self {\n+            UrlFragment::Item(frag) => frag.render(s, tcx),\n+            UrlFragment::UserWritten(raw) => write!(s, \"#{}\", raw),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+crate struct ItemFragment(FragmentKind, DefId);\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+crate enum FragmentKind {\n+    Method,\n+    TyMethod,\n+    AssociatedConstant,\n+    AssociatedType,\n+\n+    StructField,\n+    Variant,\n+    VariantField,\n+}\n+\n+impl ItemFragment {\n     /// Create a fragment for an associated item.\n     ///\n     /// `is_prototype` is whether this associated item is a trait method\n     /// without a default definition.\n-    fn from_assoc_item(name: Symbol, kind: ty::AssocKind, is_prototype: bool) -> Self {\n+    fn from_assoc_item(def_id: DefId, kind: ty::AssocKind, is_prototype: bool) -> Self {\n         match kind {\n             ty::AssocKind::Fn => {\n                 if is_prototype {\n-                    UrlFragment::TyMethod(name)\n+                    ItemFragment(FragmentKind::TyMethod, def_id)\n                 } else {\n-                    UrlFragment::Method(name)\n+                    ItemFragment(FragmentKind::Method, def_id)\n                 }\n             }\n-            ty::AssocKind::Const => UrlFragment::AssociatedConstant(name),\n-            ty::AssocKind::Type => UrlFragment::AssociatedType(name),\n+            ty::AssocKind::Const => ItemFragment(FragmentKind::AssociatedConstant, def_id),\n+            ty::AssocKind::Type => ItemFragment(FragmentKind::AssociatedType, def_id),\n         }\n     }\n-}\n \n-/// Render the fragment, including the leading `#`.\n-impl std::fmt::Display for UrlFragment {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"#\")?;\n-        match self {\n-            UrlFragment::Method(name) => write!(f, \"method.{}\", name),\n-            UrlFragment::TyMethod(name) => write!(f, \"tymethod.{}\", name),\n-            UrlFragment::AssociatedConstant(name) => write!(f, \"associatedconstant.{}\", name),\n-            UrlFragment::AssociatedType(name) => write!(f, \"associatedtype.{}\", name),\n-            UrlFragment::StructField(name) => write!(f, \"structfield.{}\", name),\n-            UrlFragment::Variant(name) => write!(f, \"variant.{}\", name),\n-            UrlFragment::VariantField { variant, field } => {\n-                write!(f, \"variant.{}.field.{}\", variant, field)\n+    /// Render the fragment, including the leading `#`.\n+    crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+        write!(s, \"#\")?;\n+        match *self {\n+            ItemFragment(kind, def_id) => {\n+                let name = tcx.item_name(def_id);\n+                match kind {\n+                    FragmentKind::Method => write!(s, \"method.{}\", name),\n+                    FragmentKind::TyMethod => write!(s, \"tymethod.{}\", name),\n+                    FragmentKind::AssociatedConstant => write!(s, \"associatedconstant.{}\", name),\n+                    FragmentKind::AssociatedType => write!(s, \"associatedtype.{}\", name),\n+                    FragmentKind::StructField => write!(s, \"structfield.{}\", name),\n+                    FragmentKind::Variant => write!(s, \"variant.{}\", name),\n+                    FragmentKind::VariantField => {\n+                        let variant = tcx.item_name(tcx.parent(def_id).unwrap());\n+                        write!(s, \"variant.{}.field.{}\", variant, name)\n+                    }\n+                }\n             }\n-            UrlFragment::UserWritten(raw) => write!(f, \"{}\", raw),\n         }\n     }\n }\n@@ -296,7 +312,7 @@ struct ResolutionInfo {\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n-    extra_fragment: Option<UrlFragment>,\n+    extra_fragment: Option<String>,\n }\n \n #[derive(Clone)]\n@@ -310,7 +326,6 @@ struct DiagnosticInfo<'a> {\n #[derive(Clone, Debug, Hash)]\n struct CachedLink {\n     pub res: (Res, Option<UrlFragment>),\n-    pub side_channel: Option<(DefKind, DefId)>,\n }\n \n struct LinkCollector<'a, 'tcx> {\n@@ -320,10 +335,6 @@ struct LinkCollector<'a, 'tcx> {\n     /// The last module will be used if the parent scope of the current item is\n     /// unknown.\n     mod_ids: Vec<DefId>,\n-    /// This is used to store the kind of associated items,\n-    /// because `clean` and the disambiguator code expect them to be different.\n-    /// See the code for associated items on inherent impls for details.\n-    kind_side_channel: Cell<Option<(DefKind, DefId)>>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n     /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n     visited_links: FxHashMap<ResolutionInfo, Option<CachedLink>>,\n@@ -340,7 +351,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &'path str,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n+    ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n         let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n             module_id,\n@@ -387,14 +398,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 match tcx.type_of(did).kind() {\n                     ty::Adt(def, _) if def.is_enum() => {\n-                        if def.all_fields().any(|item| item.ident.name == variant_field_name) {\n-                            Ok((\n-                                ty_res,\n-                                Some(UrlFragment::VariantField {\n-                                    variant: variant_name,\n-                                    field: variant_field_name,\n-                                }),\n-                            ))\n+                        if let Some(field) =\n+                            def.all_fields().find(|f| f.ident.name == variant_field_name)\n+                        {\n+                            Ok((ty_res, Some(ItemFragment(FragmentKind::VariantField, field.did))))\n                         } else {\n                             Err(ResolutionFailure::NotResolved {\n                                 module_id,\n@@ -422,16 +429,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, UrlFragment, Option<(DefKind, DefId)>)> {\n+    ) -> Option<(Res, ItemFragment)> {\n         let tcx = self.cx.tcx;\n \n         prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                 .map(|item| {\n                     let kind = item.kind;\n-                    let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n-                    (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n+                    let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                    (Res::Primitive(prim_ty), fragment)\n                 })\n         })\n     }\n@@ -505,19 +512,41 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         ns: Namespace,\n         module_id: DefId,\n-        extra_fragment: &Option<UrlFragment>,\n+        user_fragment: &Option<String>,\n     ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n+        let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, module_id)?;\n+        let chosen_fragment = match (user_fragment, rustdoc_fragment) {\n+            (Some(_), Some(r_frag)) => {\n+                let diag_res = match r_frag {\n+                    ItemFragment(_, did) => Res::Def(self.cx.tcx.def_kind(did), did),\n+                };\n+                let failure = AnchorFailure::RustdocAnchorConflict(diag_res);\n+                return Err(ErrorKind::AnchorFailure(failure));\n+            }\n+            (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n+            (None, Some(r_frag)) => Some(UrlFragment::Item(r_frag)),\n+            (None, None) => None,\n+        };\n+        Ok((res, chosen_fragment))\n+    }\n+\n+    fn resolve_inner<'path>(\n+        &mut self,\n+        path_str: &'path str,\n+        ns: Namespace,\n+        module_id: DefId,\n+    ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n                 // item a separate function.\n                 Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => assert_eq!(ns, ValueNS),\n                 Res::Def(DefKind::AssocTy, _) => assert_eq!(ns, TypeNS),\n                 Res::Def(DefKind::Variant, _) => {\n-                    return handle_variant(self.cx, res, extra_fragment);\n+                    return handle_variant(self.cx, res);\n                 }\n                 // Not a trait item; just return what we found.\n-                _ => return Ok((res, extra_fragment.clone())),\n+                _ => return Ok((res, None)),\n             }\n         }\n \n@@ -548,23 +577,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n             .and_then(|ty_res| {\n-                let (res, fragment, side_channel) =\n+                let (res, fragment) =\n                     self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n-                let result = if extra_fragment.is_some() {\n-                    // NOTE: can never be a primitive since `side_channel.is_none()` only when `res`\n-                    // is a trait (and the side channel DefId is always an associated item).\n-                    let diag_res = side_channel.map_or(res, |(k, r)| Res::Def(k, r));\n-                    Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(diag_res)))\n-                } else {\n-                    // HACK(jynelson): `clean` expects the type, not the associated item\n-                    // but the disambiguator logic expects the associated item.\n-                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                    if let Some((kind, id)) = side_channel {\n-                        self.kind_side_channel.set(Some((kind, id)));\n-                    }\n-                    Ok((res, Some(fragment)))\n-                };\n-                Some(result)\n+\n+                Some(Ok((res, Some(fragment))))\n             })\n             .unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {\n@@ -661,7 +677,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, UrlFragment, Option<(DefKind, DefId)>)> {\n+    ) -> Option<(Res, ItemFragment)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n@@ -676,11 +692,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n                     assoc_item.map(|item| {\n                         let kind = item.kind;\n-                        let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n-                        // HACK(jynelson): `clean` expects the type, not the associated item\n-                        // but the disambiguator logic expects the associated item.\n-                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                        (root_res, fragment, Some((kind.as_def_kind(), item.def_id)))\n+                        let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                        (root_res, fragment)\n                     })\n                 })\n             }\n@@ -730,11 +743,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n                 if let Some(item) = assoc_item {\n                     let kind = item.kind;\n-                    let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n-                    // HACK(jynelson): `clean` expects the type, not the associated item\n-                    // but the disambiguator logic expects the associated item.\n-                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                    return Some((root_res, fragment, Some((kind.as_def_kind(), item.def_id))));\n+                    let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                    return Some((root_res, fragment));\n                 }\n \n                 if ns != Namespace::ValueNS {\n@@ -765,23 +775,19 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .fields\n                     .iter()\n                     .find(|item| item.ident.name == item_name)?;\n-                Some((\n-                    root_res,\n-                    UrlFragment::StructField(field.ident.name),\n-                    Some((DefKind::Field, field.did)),\n-                ))\n+                Some((root_res, ItemFragment(FragmentKind::StructField, field.did)))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n-                    let fragment = UrlFragment::from_assoc_item(\n-                        item_name,\n+                    let fragment = ItemFragment::from_assoc_item(\n+                        item.def_id,\n                         item.kind,\n                         !item.defaultness.has_value(),\n                     );\n                     let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                    (res, fragment, None)\n+                    (res, fragment)\n                 }),\n             _ => None,\n         }\n@@ -798,23 +804,32 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         path_str: &str,\n         module_id: DefId,\n-        extra_fragment: &Option<UrlFragment>,\n+        extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n-            Namespace::MacroNS => self.resolve_macro(path_str, module_id).map_err(ErrorKind::from),\n+            Namespace::MacroNS => self\n+                .resolve_macro(path_str, module_id)\n+                .map(|res| (res, None))\n+                .map_err(ErrorKind::from),\n             Namespace::TypeNS | Namespace::ValueNS => {\n-                self.resolve(path_str, ns, module_id, extra_fragment).map(|(res, _)| res)\n+                self.resolve(path_str, ns, module_id, extra_fragment)\n             }\n         };\n \n         let res = match result {\n-            Ok(res) => Some(res),\n+            Ok((res, frag)) => {\n+                if let Some(UrlFragment::Item(ItemFragment(_, id))) = frag {\n+                    Some(Res::Def(self.cx.tcx.def_kind(id), id))\n+                } else {\n+                    Some(res)\n+                }\n+            }\n             Err(ErrorKind::Resolve(box kind)) => kind.full_res(),\n             Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => Some(res),\n             Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n         };\n-        self.kind_side_channel.take().map(|(kind, id)| Res::Def(kind, id)).or(res)\n+        res\n     }\n }\n \n@@ -912,8 +927,6 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n \n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        use rustc_middle::ty::DefIdTree;\n-\n         let parent_node =\n             item.def_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n         if parent_node.is_some() {\n@@ -1033,7 +1046,7 @@ impl From<AnchorFailure> for PreprocessingError<'_> {\n struct PreprocessingInfo {\n     path_str: String,\n     disambiguator: Option<Disambiguator>,\n-    extra_fragment: Option<UrlFragment>,\n+    extra_fragment: Option<String>,\n     link_text: String,\n }\n \n@@ -1119,7 +1132,7 @@ fn preprocess_link<'a>(\n     Some(Ok(PreprocessingInfo {\n         path_str,\n         disambiguator,\n-        extra_fragment: extra_fragment.map(|frag| UrlFragment::UserWritten(frag.to_owned())),\n+        extra_fragment: extra_fragment.map(|frag| frag.to_owned()),\n         link_text: link_text.to_owned(),\n     }))\n }\n@@ -1286,7 +1299,11 @@ impl LinkCollector<'_, '_> {\n         };\n \n         let verify = |kind: DefKind, id: DefId| {\n-            let (kind, id) = self.kind_side_channel.take().unwrap_or((kind, id));\n+            let (kind, id) = if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n+                (self.cx.tcx.def_kind(id), id)\n+            } else {\n+                (kind, id)\n+            };\n             debug!(\"intra-doc link to {} resolved to {:?} (id: {:?})\", path_str, res, id);\n \n             // Disallow e.g. linking to enums with `struct@`\n@@ -1330,7 +1347,9 @@ impl LinkCollector<'_, '_> {\n \n         match res {\n             Res::Primitive(prim) => {\n-                if let Some((kind, id)) = self.kind_side_channel.take() {\n+                if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n+                    let kind = self.cx.tcx.def_kind(id);\n+\n                     // We're actually resolving an associated item of a primitive, so we need to\n                     // verify the disambiguator (if any) matches the type of the associated item.\n                     // This case should really follow the same flow as the `Res::Def` branch below,\n@@ -1347,22 +1366,7 @@ impl LinkCollector<'_, '_> {\n                         && item.def_id.is_local()\n                         && !self.cx.tcx.features().intra_doc_pointers\n                     {\n-                        let span = super::source_span_for_markdown_range(\n-                            self.cx.tcx,\n-                            dox,\n-                            &ori_link.range,\n-                            &item.attrs,\n-                        )\n-                        .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n-\n-                        rustc_session::parse::feature_err(\n-                            &self.cx.tcx.sess.parse_sess,\n-                            sym::intra_doc_pointers,\n-                            span,\n-                            \"linking to associated items of raw pointers is experimental\",\n-                        )\n-                        .note(\"rustdoc does not allow disambiguating between `*const` and `*mut`, and pointers are unstable until it does\")\n-                        .emit();\n+                        self.report_rawptr_assoc_feature_gate(dox, &ori_link, item);\n                     }\n                 } else {\n                     match disambiguator {\n@@ -1389,6 +1393,20 @@ impl LinkCollector<'_, '_> {\n         }\n     }\n \n+    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &MarkdownLink, item: &Item) {\n+        let span =\n+            super::source_span_for_markdown_range(self.cx.tcx, dox, &ori_link.range, &item.attrs)\n+                .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n+        rustc_session::parse::feature_err(\n+            &self.cx.tcx.sess.parse_sess,\n+            sym::intra_doc_pointers,\n+            span,\n+            \"linking to associated items of raw pointers is experimental\",\n+        )\n+        .note(\"rustdoc does not allow disambiguating between `*const` and `*mut`, and pointers are unstable until it does\")\n+        .emit();\n+    }\n+\n     fn resolve_with_disambiguator_cached(\n         &mut self,\n         key: ResolutionInfo,\n@@ -1399,7 +1417,6 @@ impl LinkCollector<'_, '_> {\n         if let Some(ref cached) = self.visited_links.get(&key) {\n             match cached {\n                 Some(cached) => {\n-                    self.kind_side_channel.set(cached.side_channel);\n                     return Some(cached.res.clone());\n                 }\n                 None if cache_resolution_failure => return None,\n@@ -1416,13 +1433,7 @@ impl LinkCollector<'_, '_> {\n         // Cache only if resolved successfully - don't silence duplicate errors\n         if let Some(res) = res {\n             // Store result for the actual namespace\n-            self.visited_links.insert(\n-                key,\n-                Some(CachedLink {\n-                    res: res.clone(),\n-                    side_channel: self.kind_side_channel.clone().into_inner(),\n-                }),\n-            );\n+            self.visited_links.insert(key, Some(CachedLink { res: res.clone() }));\n \n             Some(res)\n         } else {\n@@ -1484,7 +1495,7 @@ impl LinkCollector<'_, '_> {\n                 let mut candidates = PerNS {\n                     macro_ns: self\n                         .resolve_macro(path_str, base_node)\n-                        .map(|res| (res, extra_fragment.clone())),\n+                        .map(|res| (res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n                     type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n@@ -1516,7 +1527,10 @@ impl LinkCollector<'_, '_> {\n                                         // Shouldn't happen but who knows?\n                                         Ok((res, Some(fragment)))\n                                     }\n-                                    (fragment, None) | (None, fragment) => Ok((res, fragment)),\n+                                    (fragment, None) => Ok((res, fragment)),\n+                                    (None, fragment) => {\n+                                        Ok((res, fragment.map(UrlFragment::UserWritten)))\n+                                    }\n                                 }\n                             }\n                         }\n@@ -1553,7 +1567,7 @@ impl LinkCollector<'_, '_> {\n             }\n             Some(MacroNS) => {\n                 match self.resolve_macro(path_str, base_node) {\n-                    Ok(res) => Some((res, extra_fragment.clone())),\n+                    Ok(res) => Some((res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for ns in [TypeNS, ValueNS] {\n@@ -2272,20 +2286,13 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n fn handle_variant(\n     cx: &DocContext<'_>,\n     res: Res,\n-    extra_fragment: &Option<UrlFragment>,\n-) -> Result<(Res, Option<UrlFragment>), ErrorKind<'static>> {\n-    use rustc_middle::ty::DefIdTree;\n-\n-    if extra_fragment.is_some() {\n-        // NOTE: `res` can never be a primitive since this function is only called when `tcx.def_kind(res) == DefKind::Variant`.\n-        return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res)));\n-    }\n+) -> Result<(Res, Option<ItemFragment>), ErrorKind<'static>> {\n     cx.tcx\n         .parent(res.def_id(cx.tcx))\n         .map(|parent| {\n             let parent_def = Res::Def(DefKind::Enum, parent);\n             let variant = cx.tcx.expect_variant_res(res.as_hir_res().unwrap());\n-            (parent_def, Some(UrlFragment::Variant(variant.ident.name)))\n+            (parent_def, Some(ItemFragment(FragmentKind::Variant, variant.def_id)))\n         })\n         .ok_or_else(|| ResolutionFailure::NoParentItem.into())\n }"}]}