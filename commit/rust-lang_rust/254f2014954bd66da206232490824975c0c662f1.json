{"sha": "254f2014954bd66da206232490824975c0c662f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NGYyMDE0OTU0YmQ2NmRhMjA2MjMyNDkwODI0OTc1YzBjNjYyZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-06T06:15:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-06T06:15:44Z"}, "message": "Auto merge of #61988 - Centril:there-is-only-loop, r=matthewjasper\n\n[let_chains, 3/6] And then there was only Loop\n\nHere we remove `hir::ExprKind::While`.\nInstead, we desugar: `'label: while $cond $body` into:\n\n```rust\n'label: loop {\n    match DropTemps($cond) {\n        true => $body,\n        _ => break,\n    }\n}\n```\n\nPer https://github.com/rust-lang/rust/issues/53667#issuecomment-471583239.\nThis is a follow up to https://github.com/rust-lang/rust/pull/59288 which did the same for `if` expressions.\n\nr? @matthewjasper", "tree": {"sha": "0692cdd08d580f827d1ee5b7837cf2a2f3c4ce52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0692cdd08d580f827d1ee5b7837cf2a2f3c4ce52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/254f2014954bd66da206232490824975c0c662f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/254f2014954bd66da206232490824975c0c662f1", "html_url": "https://github.com/rust-lang/rust/commit/254f2014954bd66da206232490824975c0c662f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/254f2014954bd66da206232490824975c0c662f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b820c761744db080ff7a4ba3ac88d259065cb836", "url": "https://api.github.com/repos/rust-lang/rust/commits/b820c761744db080ff7a4ba3ac88d259065cb836", "html_url": "https://github.com/rust-lang/rust/commit/b820c761744db080ff7a4ba3ac88d259065cb836"}, {"sha": "9b1d513e47b22180f5b73f64bb97ef7390efe7a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1d513e47b22180f5b73f64bb97ef7390efe7a0", "html_url": "https://github.com/rust-lang/rust/commit/9b1d513e47b22180f5b73f64bb97ef7390efe7a0"}], "stats": {"total": 896, "additions": 409, "deletions": 487}, "files": [{"sha": "f81d18694136e5871e40706c5e3b11068f3d0569", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -165,48 +165,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n-            hir::ExprKind::While(ref cond, ref body, _) => {\n-                //\n-                //         [pred]\n-                //           |\n-                //           v 1\n-                //       [loopback] <--+ 5\n-                //           |         |\n-                //           v 2       |\n-                //   +-----[cond]      |\n-                //   |       |         |\n-                //   |       v 4       |\n-                //   |     [body] -----+\n-                //   v 3\n-                // [expr]\n-                //\n-                // Note that `break` and `continue` statements\n-                // may cause additional edges.\n-\n-                let loopback = self.add_dummy_node(&[pred]);              // 1\n-\n-                // Create expr_exit without pred (cond_exit)\n-                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);         // 3\n-\n-                // The LoopScope needs to be on the loop_scopes stack while evaluating the\n-                // condition and the body of the loop (both can break out of the loop)\n-                self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.hir_id.local_id,\n-                    continue_index: loopback,\n-                    break_index: expr_exit\n-                });\n-\n-                let cond_exit = self.expr(&cond, loopback);             // 2\n-\n-                // Add pred (cond_exit) to expr_exit\n-                self.add_contained_edge(cond_exit, expr_exit);\n-\n-                let body_exit = self.block(&body, cond_exit);          // 4\n-                self.add_contained_edge(body_exit, loopback);            // 5\n-                self.loop_scopes.pop();\n-                expr_exit\n-            }\n-\n             hir::ExprKind::Loop(ref body, _, _) => {\n                 //\n                 //     [pred]"}, {"sha": "2d82314f86ac233887006f1b686eb2011b28ec65", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1026,11 +1026,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::DropTemps(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_block(block);\n-        }\n         ExprKind::Loop(ref block, ref opt_label, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);"}, {"sha": "3c967fa6d8317c0b88228aa1c5d2dd8d103eac52", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 72, "deletions": 66, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -63,7 +63,7 @@ use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::print::pprust;\n use syntax::source_map::{self, respan, ExpnInfo, CompilerDesugaringKind, Spanned};\n-use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n+use syntax::source_map::CompilerDesugaringKind::CondTemporary;\n use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n@@ -4394,21 +4394,18 @@ impl<'a> LoweringContext<'a> {\n                 let then_blk = self.lower_block(then, false);\n                 let then_expr = self.expr_block(then_blk, ThinVec::new());\n                 let (then_pats, scrutinee, desugar) = match cond.node {\n-                    // `<pat> => <then>`\n+                    // `<pat> => <then>`:\n                     ExprKind::Let(ref pats, ref scrutinee) => {\n                         let scrutinee = self.lower_expr(scrutinee);\n                         let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n                         let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n                         (pats, scrutinee, desugar)\n                     }\n-                    // `true => then`:\n+                    // `true => <then>`:\n                     _ => {\n                         // Lower condition:\n                         let cond = self.lower_expr(cond);\n-                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n-                        // to preserve drop semantics since `if cond { ... }`\n-                        // don't let temporaries live outside of `cond`.\n-                        let span_block = self.mark_span_with_reason(IfTemporary, cond.span, None);\n+                        let span_block = self.mark_span_with_reason(CondTemporary, cond.span, None);\n                         // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                         // to preserve drop semantics since `if cond { ... }` does not\n                         // let temporaries live outside of `cond`.\n@@ -4424,69 +4421,78 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n             }\n             // FIXME(#53667): handle lowering of && and parens.\n-            ExprKind::While(ref cond, ref body, opt_label) => {\n-                // Desugar `ExprWhileLet`\n-                // from: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-                if let ExprKind::Let(ref pats, ref sub_expr) = cond.node {\n-                    // to:\n-                    //\n-                    //   [opt_ident]: loop {\n-                    //     match <sub_expr> {\n-                    //       <pat> => <body>,\n-                    //       _ => break\n-                    //     }\n-                    //   }\n-\n-                    // Note that the block AND the condition are evaluated in the loop scope.\n-                    // This is done to allow `break` from inside the condition of the loop.\n-                    let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| {\n-                        (\n-                            this.lower_block(body, false),\n-                            this.expr_break(e.span, ThinVec::new()),\n-                            this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n-                        )\n-                    });\n+            ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                // Note that the block AND the condition are evaluated in the loop scope.\n+                // This is done to allow `break` from inside the condition of the loop.\n \n-                    // `<pat> => <body>`\n-                    let pat_arm = {\n-                        let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                        let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                        self.arm(pats, body_expr)\n-                    };\n+                // `_ => break`:\n+                let else_arm = {\n+                    let else_pat = this.pat_wild(e.span);\n+                    let else_expr = this.expr_break(e.span, ThinVec::new());\n+                    this.arm(hir_vec![else_pat], else_expr)\n+                };\n \n-                    // `_ => break`\n-                    let break_arm = {\n-                        let pat_under = self.pat_wild(e.span);\n-                        self.arm(hir_vec![pat_under], break_expr)\n-                    };\n+                // Handle then + scrutinee:\n+                let then_blk = this.lower_block(body, false);\n+                let then_expr = this.expr_block(then_blk, ThinVec::new());\n+                let (then_pats, scrutinee, desugar, source) = match cond.node {\n+                    ExprKind::Let(ref pats, ref scrutinee) => {\n+                        // to:\n+                        //\n+                        //   [opt_ident]: loop {\n+                        //     match <sub_expr> {\n+                        //       <pat> => <body>,\n+                        //       _ => break\n+                        //     }\n+                        //   }\n+                        let scrutinee = this.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n+                        let pats = pats.iter().map(|pat| this.lower_pat(pat)).collect();\n+                        let desugar = hir::MatchSource::WhileLetDesugar;\n+                        (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                    }\n+                    _ => {\n+                        // We desugar: `'label: while $cond $body` into:\n+                        //\n+                        // ```\n+                        // 'label: loop {\n+                        //     match DropTemps($cond) {\n+                        //         true => $body,\n+                        //         _ => break,\n+                        //     }\n+                        // }\n+                        // ```\n \n-                    // `match <sub_expr> { ... }`\n-                    let arms = hir_vec![pat_arm, break_arm];\n-                    let match_expr = self.expr(\n-                        sub_expr.span,\n-                        hir::ExprKind::Match(sub_expr, arms, hir::MatchSource::WhileLetDesugar),\n-                        ThinVec::new(),\n-                    );\n+                        // Lower condition:\n+                        let cond = this.with_loop_condition_scope(|this| this.lower_expr(cond));\n+                        let span_block = this.mark_span_with_reason(CondTemporary, cond.span, None);\n+                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                        // to preserve drop semantics since `while cond { ... }` does not\n+                        // let temporaries live outside of `cond`.\n+                        let cond = this.expr_drop_temps(span_block, P(cond), ThinVec::new());\n \n-                    // `[opt_ident]: loop { ... }`\n-                    let loop_block = P(self.block_expr(P(match_expr)));\n-                    let loop_expr = hir::ExprKind::Loop(\n-                        loop_block,\n-                        self.lower_label(opt_label),\n-                        hir::LoopSource::WhileLet,\n-                    );\n-                    // Add attributes to the outer returned expr node.\n-                    loop_expr\n-                } else {\n-                    self.with_loop_scope(e.id, |this| {\n-                        hir::ExprKind::While(\n-                            this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n-                            this.lower_block(body, false),\n-                            this.lower_label(opt_label),\n-                        )\n-                    })\n-                }\n-            }\n+                        let desugar = hir::MatchSource::WhileDesugar;\n+                        // `true => <then>`:\n+                        let pats = hir_vec![this.pat_bool(e.span, true)];\n+                        (pats, cond, desugar, hir::LoopSource::While)\n+                    }\n+                };\n+                let then_arm = this.arm(then_pats, P(then_expr));\n+\n+                // `match <scrutinee> { ... }`\n+                let match_expr = this.expr_match(\n+                    scrutinee.span,\n+                    P(scrutinee),\n+                    hir_vec![then_arm, else_arm],\n+                    desugar,\n+                );\n+\n+                // `[opt_ident]: loop { ... }`\n+                hir::ExprKind::Loop(\n+                    P(this.block_expr(P(match_expr))),\n+                    this.lower_label(opt_label),\n+                    source\n+                )\n+            }),\n             ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n                 hir::ExprKind::Loop(\n                     this.lower_block(body, false),"}, {"sha": "63f60d0ab9528a564f210b70f39cb0b1bc65c60d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -731,7 +731,7 @@ impl<'hir> Map<'hir> {\n             match *node {\n                 Node::Expr(ref expr) => {\n                     match expr.node {\n-                        ExprKind::While(..) | ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n+                        ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n                         _ => false,\n                     }\n                 }"}, {"sha": "7b760a872387e9c3999a1de7c8cc0dc15d14203f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1405,7 +1405,6 @@ impl Expr {\n             ExprKind::Lit(_) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n             ExprKind::DropTemps(ref expr, ..) => expr.precedence(),\n-            ExprKind::While(..) => ExprPrecedence::While,\n             ExprKind::Loop(..) => ExprPrecedence::Loop,\n             ExprKind::Match(..) => ExprPrecedence::Match,\n             ExprKind::Closure(..) => ExprPrecedence::Closure,\n@@ -1464,7 +1463,6 @@ impl Expr {\n             ExprKind::Break(..) |\n             ExprKind::Continue(..) |\n             ExprKind::Ret(..) |\n-            ExprKind::While(..) |\n             ExprKind::Loop(..) |\n             ExprKind::Assign(..) |\n             ExprKind::InlineAsm(..) |\n@@ -1532,10 +1530,6 @@ pub enum ExprKind {\n     /// This construct only exists to tweak the drop order in HIR lowering.\n     /// An example of that is the desugaring of `for` loops.\n     DropTemps(P<Expr>),\n-    /// A while loop, with an optional label\n-    ///\n-    /// I.e., `'label: while expr { <block> }`.\n-    While(P<Expr>, P<Block>, Option<Label>),\n     /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// I.e., `'label: loop { <block> }`.\n@@ -1653,6 +1647,8 @@ pub enum MatchSource {\n     IfLetDesugar {\n         contains_else_clause: bool,\n     },\n+    /// A `while _ { .. }` (which was desugared to a `loop { match _ { .. } }`).\n+    WhileDesugar,\n     /// A `while let _ = _ { .. }` (which was desugared to a\n     /// `loop { match _ { .. } }`).\n     WhileLetDesugar,\n@@ -1669,12 +1665,25 @@ pub enum MatchSource {\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n+    /// A `while _ { .. }` loop.\n+    While,\n     /// A `while let _ = _ { .. }` loop.\n     WhileLet,\n     /// A `for _ in _ { .. }` loop.\n     ForLoop,\n }\n \n+impl LoopSource {\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            LoopSource::Loop => \"loop\",\n+            LoopSource::While => \"while\",\n+            LoopSource::WhileLet => \"while let\",\n+            LoopSource::ForLoop => \"for\",\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LoopIdError {\n     OutsideLoopScope,"}, {"sha": "367e4dba042cd7998de1cb79980660b6c94a11be", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1299,16 +1299,6 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, indent_unit, true);\n             }\n-            hir::ExprKind::While(ref test, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"while\");\n-                self.print_expr_as_cond(&test);\n-                self.s.space();\n-                self.print_block(&blk);\n-            }\n             hir::ExprKind::Loop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n@@ -2289,7 +2279,6 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n         hir::ExprKind::Match(..) |\n         hir::ExprKind::Block(..) |\n-        hir::ExprKind::While(..) |\n         hir::ExprKind::Loop(..) => false,\n         _ => true,\n     }"}, {"sha": "1db18d30282582eb61364224b12e59ea24ff4f1b", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -415,7 +415,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n });\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n-    IfTemporary,\n+    CondTemporary,\n     Async,\n     Await,\n     QuestionMark,"}, {"sha": "2448db032b9654c39348188af6db5593e87a4c4e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -487,11 +487,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprKind::While(ref cond_expr, ref blk, _) => {\n-                self.consume_expr(&cond_expr);\n-                self.walk_block(&blk);\n-            }\n-\n             hir::ExprKind::Unary(_, ref lhs) => {\n                 self.consume_expr(&lhs);\n             }"}, {"sha": "daf0d8103a2c027fcd23b925f60b33c7845641f7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 18, "deletions": 62, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -93,7 +93,6 @@\n //!   It is the responsibility of typeck to ensure that there are no\n //!   `return` expressions in a function declared as diverging.\n \n-use self::LoopKind::*;\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n@@ -120,14 +119,6 @@ use crate::hir::{Expr, HirId};\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n-/// For use with `propagate_through_loop`.\n-enum LoopKind<'a> {\n-    /// An endless `loop` loop.\n-    LoopLoop,\n-    /// A `while` loop, with the given expression as condition.\n-    WhileLoop(&'a Expr),\n-}\n-\n #[derive(Copy, Clone, PartialEq)]\n struct Variable(u32);\n \n@@ -517,7 +508,6 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n \n       // live nodes required for interesting control flow:\n       hir::ExprKind::Match(..) |\n-      hir::ExprKind::While(..) |\n       hir::ExprKind::Loop(..) => {\n         ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n@@ -1055,14 +1045,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 })\n             }\n \n-            hir::ExprKind::While(ref cond, ref blk, _) => {\n-                self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n-            }\n-\n             // Note that labels have been resolved, so we don't need to look\n             // at the label ident\n             hir::ExprKind::Loop(ref blk, _, _) => {\n-                self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n+                self.propagate_through_loop(expr, &blk, succ)\n             }\n \n             hir::ExprKind::Match(ref e, ref arms, _) => {\n@@ -1353,74 +1339,44 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_loop(&mut self,\n-                              expr: &Expr,\n-                              kind: LoopKind<'_>,\n-                              body: &hir::Block,\n-                              succ: LiveNode)\n-                              -> LiveNode {\n+    fn propagate_through_loop(\n+        &mut self,\n+        expr: &Expr,\n+        body: &hir::Block,\n+        succ: LiveNode\n+    ) -> LiveNode {\n         /*\n-\n         We model control flow like this:\n \n-              (cond) <--+\n-                |       |\n-                v       |\n-          +-- (expr)    |\n-          |     |       |\n-          |     v       |\n-          |   (body) ---+\n-          |\n-          |\n-          v\n-        (succ)\n+              (expr) <-+\n+                |      |\n+                v      |\n+              (body) --+\n \n+        Note that a `continue` expression targeting the `loop` will have a successor of `expr`.\n+        Meanwhile, a `break` expression will have a successor of `succ`.\n         */\n \n-\n         // first iteration:\n         let mut first_merge = true;\n         let ln = self.live_node(expr.hir_id, expr.span);\n         self.init_empty(ln, succ);\n-        match kind {\n-            LoopLoop => {}\n-            _ => {\n-                // If this is not a `loop` loop, then it's possible we bypass\n-                // the body altogether. Otherwise, the only way is via a `break`\n-                // in the loop body.\n-                self.merge_from_succ(ln, succ, first_merge);\n-                first_merge = false;\n-            }\n-        }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.hir_id, self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n         self.break_ln.insert(expr.hir_id, succ);\n \n-        let cond_ln = match kind {\n-            LoopLoop => ln,\n-            WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n-        };\n-\n-        self.cont_ln.insert(expr.hir_id, cond_ln);\n+        self.cont_ln.insert(expr.hir_id, ln);\n \n-        let body_ln = self.propagate_through_block(body, cond_ln);\n+        let body_ln = self.propagate_through_block(body, ln);\n \n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n-\n-            let new_cond_ln = match kind {\n-                LoopLoop => ln,\n-                WhileLoop(ref cond) => {\n-                    self.propagate_through_expr(&cond, ln)\n-                }\n-            };\n-            assert_eq!(cond_ln, new_cond_ln);\n-            assert_eq!(body_ln, self.propagate_through_block(body, cond_ln));\n+            assert_eq!(body_ln, self.propagate_through_block(body, ln));\n         }\n \n-        cond_ln\n+        ln\n     }\n }\n \n@@ -1520,7 +1476,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n \n         // no correctness conditions related to liveness\n         hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) |\n-        hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n+        hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) |\n         hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n         hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |\n         hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) | hir::ExprKind::Unary(..) |"}, {"sha": "66d8a2cc1115d1d1ec9b6f7529a724c9b495e0e4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -696,7 +696,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n             hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) |\n             hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) |\n-            hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n+            hir::ExprKind::Binary(..) |\n             hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n             hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n             hir::ExprKind::Continue(..) | hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |"}, {"sha": "88c19715811d79661a84b45899e6090104f2fd0b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -915,11 +915,6 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprKind::While(ref expr, ref body, _) => {\n-                terminating(expr.hir_id.local_id);\n-                terminating(body.hir_id.local_id);\n-            }\n-\n             hir::ExprKind::DropTemps(ref expr) => {\n                 // `DropTemps(expr)` does not denote a conditional scope.\n                 // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`."}, {"sha": "3221b41ee1d4430ee8507f2b9d64d61cb0cf1166", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1201,11 +1201,10 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n-        match ex.node {\n-            hir::ExprKind::While(.., Some(label)) | hir::ExprKind::Loop(_, Some(label), _) => {\n-                Some(label.ident)\n-            }\n-            _ => None,\n+        if let hir::ExprKind::Loop(_, Some(label), _) = ex.node {\n+            Some(label.ident)\n+        } else {\n+            None\n         }\n     }\n "}, {"sha": "c9605445c24014eac9a6d26c0eeb7d766ecb5a8c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -64,22 +64,30 @@ declare_lint! {\n \n declare_lint_pass!(WhileTrue => [WHILE_TRUE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n-        if let hir::ExprKind::While(ref cond, ..) = e.node {\n-            if let hir::ExprKind::Lit(ref lit) = cond.node {\n+/// Traverse through any amount of parenthesis and return the first non-parens expression.\n+fn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n+    while let ast::ExprKind::Paren(sub) = &expr.node {\n+        expr = sub;\n+    }\n+    expr\n+}\n+\n+impl EarlyLintPass for WhileTrue {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        if let ast::ExprKind::While(cond, ..) = &e.node {\n+            if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n                     if lit.span.ctxt() == SyntaxContext::empty() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n-                        let condition_span = cx.tcx.sess.source_map().def_span(e.span);\n-                        let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);\n-                        err.span_suggestion_short(\n-                            condition_span,\n-                            \"use `loop`\",\n-                            \"loop\".to_owned(),\n-                            Applicability::MachineApplicable\n-                        );\n-                        err.emit();\n+                        let condition_span = cx.sess.source_map().def_span(e.span);\n+                        cx.struct_span_lint(WHILE_TRUE, condition_span, msg)\n+                            .span_suggestion_short(\n+                                condition_span,\n+                                \"use `loop`\",\n+                                \"loop\".to_owned(),\n+                                Applicability::MachineApplicable\n+                            )\n+                            .emit();\n                     }\n                 }\n             }"}, {"sha": "2519981fa21b2e021a2961678f1524ad7027d042", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -96,6 +96,7 @@ macro_rules! early_lint_passes {\n             EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),\n             NonCamelCaseTypes: NonCamelCaseTypes,\n             DeprecatedAttr: DeprecatedAttr::new(),\n+            WhileTrue: WhileTrue,\n         ]);\n     )\n }\n@@ -140,7 +141,6 @@ macro_rules! late_lint_mod_passes {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n             HardwiredLints: HardwiredLints,\n-            WhileTrue: WhileTrue,\n             ImproperCTypes: ImproperCTypes,\n             VariantSizeDifferences: VariantSizeDifferences,\n             BoxPointers: BoxPointers,"}, {"sha": "e433da904a67877bd22a318ae5094ec104b21f68", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 11, "deletions": 40, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -138,19 +138,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 join_block.unit()\n             }\n-            ExprKind::Loop {\n-                condition: opt_cond_expr,\n-                body,\n-            } => {\n-                // [block] --> [loop_block] -/eval. cond./-> [loop_block_end] -1-> [exit_block]\n-                //                  ^                               |\n-                //                  |                               0\n-                //                  |                               |\n-                //                  |                               v\n-                //           [body_block_end] <-/eval. body/-- [body_block]\n-                //\n-                // If `opt_cond_expr` is `None`, then the graph is somewhat simplified:\n-                //\n+            ExprKind::Loop { body } => {\n                 // [block]\n                 //    |\n                 //   [loop_block] -> [body_block] -/eval. body/-> [body_block_end]\n@@ -177,33 +165,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     destination.clone(),\n                     move |this| {\n                         // conduct the test, if necessary\n-                        let body_block;\n-                        if let Some(cond_expr) = opt_cond_expr {\n-                            let cond_expr = this.hir.mirror(cond_expr);\n-                            let (true_block, false_block)\n-                                = this.test_bool(loop_block, cond_expr, source_info);\n-                            body_block = true_block;\n-\n-                            // if the test is false, there's no `break` to assign `destination`, so\n-                            // we have to do it\n-                            this.cfg.push_assign_unit(false_block, source_info, destination);\n-                            this.cfg.terminate(\n-                                false_block,\n-                                source_info,\n-                                TerminatorKind::Goto { target: exit_block },\n-                            );\n-                        } else {\n-                            body_block = this.cfg.start_new_block();\n-                            let diverge_cleanup = this.diverge_cleanup();\n-                            this.cfg.terminate(\n-                                loop_block,\n-                                source_info,\n-                                TerminatorKind::FalseUnwind {\n-                                    real_target: body_block,\n-                                    unwind: Some(diverge_cleanup),\n-                                },\n-                            )\n-                        }\n+                        let body_block = this.cfg.start_new_block();\n+                        let diverge_cleanup = this.diverge_cleanup();\n+                        this.cfg.terminate(\n+                            loop_block,\n+                            source_info,\n+                            TerminatorKind::FalseUnwind {\n+                                real_target: body_block,\n+                                unwind: Some(diverge_cleanup),\n+                            },\n+                        );\n \n                         // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n                         // introduce a unit temporary as the destination for the loop body."}, {"sha": "242afcf5abb2e410f417562b95b00f6ee6381e67", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -599,15 +599,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n             }\n         }\n-        hir::ExprKind::While(ref cond, ref body, _) => {\n-            ExprKind::Loop {\n-                condition: Some(cond.to_ref()),\n-                body: block::to_expr_ref(cx, body),\n-            }\n-        }\n         hir::ExprKind::Loop(ref body, _, _) => {\n             ExprKind::Loop {\n-                condition: None,\n                 body: block::to_expr_ref(cx, body),\n             }\n         }"}, {"sha": "0638cb462f73b32cc7282aff27b914402b9a8c87", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -173,7 +173,6 @@ pub enum ExprKind<'tcx> {\n         source: ExprRef<'tcx>,\n     },\n     Loop {\n-        condition: Option<ExprRef<'tcx>>,\n         body: ExprRef<'tcx>,\n     },\n     Match {"}, {"sha": "d822a26ce591b094b0ca95bc11d255d9153ddffb", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -371,7 +371,8 @@ fn check_arms<'a, 'tcx>(\n             match is_useful(cx, &seen, &v, LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n-                        hir::MatchSource::IfDesugar { .. } => bug!(),\n+                        hir::MatchSource::IfDesugar { .. } |\n+                        hir::MatchSource::WhileDesugar => bug!(),\n                         hir::MatchSource::IfLetDesugar { .. } => {\n                             cx.tcx.lint_hir(\n                                 lint::builtin::IRREFUTABLE_LET_PATTERNS,"}, {"sha": "afe4c78dcfc374194f6293c980fa8aa6659645bc", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -12,27 +12,10 @@ use syntax::struct_span_err;\n use syntax_pos::Span;\n use errors::Applicability;\n \n-#[derive(Clone, Copy, Debug, PartialEq)]\n-enum LoopKind {\n-    Loop(hir::LoopSource),\n-    WhileLoop,\n-}\n-\n-impl LoopKind {\n-    fn name(self) -> &'static str {\n-        match self {\n-            LoopKind::Loop(hir::LoopSource::Loop) => \"loop\",\n-            LoopKind::Loop(hir::LoopSource::WhileLet) => \"while let\",\n-            LoopKind::Loop(hir::LoopSource::ForLoop) => \"for\",\n-            LoopKind::WhileLoop => \"while\",\n-        }\n-    }\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum Context {\n     Normal,\n-    Loop(LoopKind),\n+    Loop(hir::LoopSource),\n     Closure,\n     LabeledBlock,\n     AnonConst,\n@@ -71,14 +54,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n     fn visit_expr(&mut self, e: &'hir hir::Expr) {\n         match e.node {\n-            hir::ExprKind::While(ref e, ref b, _) => {\n-                self.with_context(Loop(LoopKind::WhileLoop), |v| {\n-                    v.visit_expr(&e);\n-                    v.visit_block(&b);\n-                });\n-            }\n             hir::ExprKind::Loop(ref b, _, source) => {\n-                self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n+                self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n             hir::ExprKind::Closure(_, ref function_decl, b, _, _) => {\n                 self.visit_fn_decl(&function_decl);\n@@ -117,15 +94,14 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                         None\n                     } else {\n                         Some(match self.hir_map.expect_expr(loop_id).node {\n-                            hir::ExprKind::While(..) => LoopKind::WhileLoop,\n-                            hir::ExprKind::Loop(_, _, source) => LoopKind::Loop(source),\n+                            hir::ExprKind::Loop(_, _, source) => source,\n                             ref r => span_bug!(e.span,\n                                                \"break label resolved to a non-loop: {:?}\", r),\n                         })\n                     };\n                     match loop_kind {\n                         None |\n-                        Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),\n+                        Some(hir::LoopSource::Loop) => (),\n                         Some(kind) => {\n                             struct_span_err!(self.sess, e.span, E0571,\n                                              \"`break` with value from a `{}` loop\","}, {"sha": "8ba3a25e3947c1fafa394d69f0dc022efddeb52e", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -520,13 +520,6 @@ fn check_expr_kind<'a, 'tcx>(\n             NotPromotable\n         }\n \n-        // Loops (not very meaningful in constants).\n-        hir::ExprKind::While(ref expr, ref box_block, ref _option_label) => {\n-            let _ = v.check_expr(expr);\n-            let _ = v.check_block(box_block);\n-            NotPromotable\n-        }\n-\n         hir::ExprKind::Loop(ref box_block, ref _option_label, ref _loop_source) => {\n             let _ = v.check_block(box_block);\n             NotPromotable"}, {"sha": "d24f92a6fafef5a451989c59afdbe6be5da60225", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -180,7 +180,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // then that's equivalent to there existing a LUB.\n                 if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n                     err.emit_unless(discrim_span\n-                        .filter(|&s| s.is_compiler_desugaring(CompilerDesugaringKind::IfTemporary))\n+                        .filter(|&s| {\n+                            // In the case of `if`- and `while`-expressions we've already checked\n+                            // that `scrutinee: bool`. We know that the pattern is `true`,\n+                            // so an error here would be a duplicate and from the wrong POV.\n+                            s.is_compiler_desugaring(CompilerDesugaringKind::CondTemporary)\n+                        })\n                         .is_some());\n                 }\n \n@@ -624,14 +629,15 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let tcx = self.tcx;\n \n         use hir::MatchSource::*;\n-        let (source_if, if_no_else, if_desugar) = match match_src {\n+        let (source_if, if_no_else, force_scrutinee_bool) = match match_src {\n             IfDesugar { contains_else_clause } => (true, !contains_else_clause, true),\n             IfLetDesugar { contains_else_clause } => (true, !contains_else_clause, false),\n+            WhileDesugar => (false, false, true),\n             _ => (false, false, false),\n         };\n \n         // Type check the descriminant and get its type.\n-        let discrim_ty = if if_desugar {\n+        let discrim_ty = if force_scrutinee_bool {\n             // Here we want to ensure:\n             //\n             // 1. That default match bindings are *not* accepted in the condition of an\n@@ -651,7 +657,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             return tcx.types.never;\n         }\n \n-        self.warn_arms_when_scrutinee_diverges(arms, source_if);\n+        self.warn_arms_when_scrutinee_diverges(arms, match_src);\n \n         // Otherwise, we have to union together the types that the\n         // arms produce and so forth.\n@@ -726,7 +732,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             if source_if {\n                 let then_expr = &arms[0].body;\n                 match (i, if_no_else) {\n-                    (0, _) => coercion.coerce(self, &self.misc(span), then_expr, arm_ty),\n+                    (0, _) => coercion.coerce(self, &self.misc(span), &arm.body, arm_ty),\n                     (_, true) => self.if_fallback_coercion(span, then_expr, &mut coercion),\n                     (_, _) => {\n                         let then_ty = prior_arm_ty.unwrap();\n@@ -771,9 +777,14 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n-    fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm], source_if: bool) {\n+    fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm], source: hir::MatchSource) {\n         if self.diverges.get().always() {\n-            let msg = if source_if { \"block in `if` expression\" } else { \"arm\" };\n+            use hir::MatchSource::*;\n+            let msg = match source {\n+                IfDesugar { .. } | IfLetDesugar { .. } => \"block in `if` expression\",\n+                WhileDesugar { .. } | WhileLetDesugar { .. } => \"block in `while` expression\",\n+                _ => \"arm\",\n+            };\n             for arm in arms {\n                 self.warn_if_unreachable(arm.body.hir_id, arm.body.span, msg);\n             }"}, {"sha": "b02a7c21027d43e475cf686f670057cf5e23d5ca", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -159,11 +159,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n-            ExprKind::Block(..) |\n-            ExprKind::Loop(..) | ExprKind::While(..) |\n-            ExprKind::Match(..) => {}\n-\n-            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n+            ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n+            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\"),\n         }\n \n         // Any expression that produces a value of type `!` must have diverged\n@@ -245,9 +242,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.check_expr_assign(expr, expected, lhs, rhs)\n             }\n-            ExprKind::While(ref cond, ref body, _) => {\n-                self.check_expr_while(cond, body, expr)\n-            }\n             ExprKind::Loop(ref body, _, source) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n@@ -702,36 +696,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_while(\n-        &self,\n-        cond: &'tcx hir::Expr,\n-        body: &'tcx hir::Block,\n-        expr: &'tcx hir::Expr\n-    ) -> Ty<'tcx> {\n-        let ctxt = BreakableCtxt {\n-            // Cannot use break with a value from a while loop.\n-            coerce: None,\n-            may_break: false, // Will get updated if/when we find a `break`.\n-        };\n-\n-        let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n-            self.check_expr_has_type_or_error(&cond, self.tcx.types.bool);\n-            let cond_diverging = self.diverges.get();\n-            self.check_block_no_value(&body);\n-\n-            // We may never reach the body so it diverging means nothing.\n-            self.diverges.set(cond_diverging);\n-        });\n-\n-        if ctxt.may_break {\n-            // No way to know whether it's diverging because\n-            // of a `break` or an outer `break` or `return`.\n-            self.diverges.set(Diverges::Maybe);\n-        }\n-\n-        self.tcx.mk_unit()\n-    }\n-\n     fn check_expr_loop(\n         &self,\n         body: &'tcx hir::Block,\n@@ -746,6 +710,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(CoerceMany::new(coerce_to))\n             }\n \n+            hir::LoopSource::While |\n             hir::LoopSource::WhileLet |\n             hir::LoopSource::ForLoop => {\n                 None"}, {"sha": "3bfb3477d4774c7f04150c406a90877e6fd25225", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -2161,10 +2161,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// function is unreachable, and there hasn't been another warning.\n     fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n         if self.diverges.get() == Diverges::Always &&\n-            // If span arose from a desugaring of `if` then it is the condition itself,\n-            // which diverges, that we are about to lint on. This gives suboptimal diagnostics\n-            // and so we stop here and allow the block of the `if`-expression to be linted instead.\n-            !span.is_compiler_desugaring(CompilerDesugaringKind::IfTemporary) {\n+            // If span arose from a desugaring of `if` or `while`, then it is the condition itself,\n+            // which diverges, that we are about to lint on. This gives suboptimal diagnostics.\n+            // Instead, stop here so that the `if`- or `while`-expression's block is linted instead.\n+            !span.is_compiler_desugaring(CompilerDesugaringKind::CondTemporary) {\n             self.diverges.set(Diverges::WarnedAlways);\n \n             debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n@@ -3865,7 +3865,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match expression.node {\n                 ExprKind::Call(..) |\n                 ExprKind::MethodCall(..) |\n-                ExprKind::While(..) |\n                 ExprKind::Loop(..) |\n                 ExprKind::Match(..) |\n                 ExprKind::Block(..) => {"}, {"sha": "f9ebe762e522fbf7e3af53ac991fa4a03aff66c6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -685,16 +685,6 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n                 self.set_repeating_scope(repeating_scope);\n             }\n \n-            hir::ExprKind::While(ref cond, ref body, _) => {\n-                let repeating_scope = self.set_repeating_scope(cond.hir_id);\n-                self.visit_expr(&cond);\n-\n-                self.set_repeating_scope(body.hir_id);\n-                self.visit_block(&body);\n-\n-                self.set_repeating_scope(repeating_scope);\n-            }\n-\n             hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n                 debug!("}, {"sha": "a6c8c76cf23f7375b2bdc13cd0d75d3c2c984a3c", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -723,7 +723,8 @@ pub enum CompilerDesugaringKind {\n     /// We desugar `if c { i } else { e }` to `match $ExprKind::Use(c) { true => i, _ => e }`.\n     /// However, we do not want to blame `c` for unreachability but rather say that `i`\n     /// is unreachable. This desugaring kind allows us to avoid blaming `c`.\n-    IfTemporary,\n+    /// This also applies to `while` loops.\n+    CondTemporary,\n     QuestionMark,\n     TryBlock,\n     /// Desugaring of an `impl Trait` in return type position\n@@ -738,7 +739,7 @@ pub enum CompilerDesugaringKind {\n impl CompilerDesugaringKind {\n     pub fn name(self) -> Symbol {\n         Symbol::intern(match self {\n-            CompilerDesugaringKind::IfTemporary => \"if\",\n+            CompilerDesugaringKind::CondTemporary => \"if and while condition\",\n             CompilerDesugaringKind::Async => \"async\",\n             CompilerDesugaringKind::Await => \"await\",\n             CompilerDesugaringKind::QuestionMark => \"?\","}, {"sha": "a993d811d327f851f95f082107b35dac12f7eea4", "filename": "src/test/compile-fail/issue-52443.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -2,6 +2,7 @@ fn main() {\n     [(); & { loop { continue } } ]; //~ ERROR mismatched types\n     [(); loop { break }]; //~ ERROR mismatched types\n     [(); {while true {break}; 0}]; //~ ERROR constant contains unimplemented expression type\n+    //~^ WARN denote infinite loops with\n     [(); { for _ in 0usize.. {}; 0}]; //~ ERROR calls in constants are limited to constant functions\n     //~^ ERROR constant contains unimplemented expression type\n     //~| ERROR constant contains unimplemented expression type"}, {"sha": "39b28ec1906395d7435ab1cac0e418a2d7b42263", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -141,7 +141,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -191,7 +191,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;"}, {"sha": "06072185469509b26a645bba6104e4da5e031ca7", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -191,7 +191,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;"}, {"sha": "86c3f79d3a70693709eef25f816d1d42bd53d5aa", "filename": "src/test/mir-opt/while-storage.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -24,36 +24,33 @@ fn main() {\n //     StorageLive(_2);\n //     StorageLive(_3);\n //     _3 = _1;\n-//     _2 = const get_bool(move _3) -> bb2;\n+//     _2 = const get_bool(move _3) -> bb1;\n // }\n // bb1: {\n-//     return;\n+//     StorageDead(_3);\n+//     switchInt(_2) -> [false: bb6, otherwise: bb2];\n // }\n // bb2: {\n-//     StorageDead(_3);\n-//     switchInt(move _2) -> [false: bb4, otherwise: bb3];\n+//      StorageLive(_4);\n+//      StorageLive(_5);\n+//      _5 = _1;\n+//      _4 = const get_bool(move _5) -> bb3;\n // }\n // bb3: {\n-//     StorageDead(_2);\n-//     StorageLive(_4);\n-//     StorageLive(_5);\n-//     _5 = _1;\n-//     _4 = const get_bool(move _5) -> bb5;\n+//      StorageDead(_5);\n+//      switchInt(_4) -> [false: bb4, otherwise: bb5];\n // }\n // bb4: {\n-//     StorageDead(_2);\n-//     goto -> bb1;\n-// }\n-// bb5: {\n-//     StorageDead(_5);\n-//     switchInt(_4) -> [false: bb6, otherwise: bb7];\n-// }\n-// bb6: {\n-//     StorageDead(_4);\n-//     goto -> bb0;\n-// }\n-// bb7: {\n-//     StorageDead(_4);\n-//     goto -> bb1;\n-// }\n+//      StorageDead(_4);\n+//      StorageDead(_2);\n+//      goto -> bb0;\n+// }\n+//  bb5: {\n+//      StorageDead(_4);\n+//      goto -> bb6;\n+//  }\n+//  bb6: {\n+//      StorageDead(_2);\n+//      return;\n+//  }\n // END rustc.while_loop.PreCodegen.after.mir"}, {"sha": "108b9bc9e9b29c9adfddb81d48dd3e32051d1ab4", "filename": "src/test/ui/block-result/block-must-not-have-result-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    while true {\n+    while true { //~ WARN denote infinite loops with\n         true //~  ERROR mismatched types\n              //~| expected type `()`\n              //~| found type `bool`"}, {"sha": "c41afcc9121c697bf1e248e65ddce2ce9a860099", "filename": "src/test/ui/block-result/block-must-not-have-result-while.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-while.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1,3 +1,11 @@\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/block-must-not-have-result-while.rs:2:5\n+   |\n+LL |     while true {\n+   |     ^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: #[warn(while_true)] on by default\n+\n error[E0308]: mismatched types\n   --> $DIR/block-must-not-have-result-while.rs:3:9\n    |"}, {"sha": "22667906e12d6c546e50552042a54b966fc54b51", "filename": "src/test/ui/borrowck/mut-borrow-in-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -12,7 +12,7 @@ impl<'a, T : 'a> FuncWrapper<'a, T> {\n     }\n \n     fn in_while(self, arg : &'a mut T) {\n-        while true {\n+        while true { //~ WARN denote infinite loops with\n             (self.func)(arg) //~ ERROR cannot borrow\n         }\n     }"}, {"sha": "59cf4d533def8d760369bb9dd98ffc08356a5524", "filename": "src/test/ui/borrowck/mut-borrow-in-loop.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1,3 +1,11 @@\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/mut-borrow-in-loop.rs:15:9\n+   |\n+LL |         while true {\n+   |         ^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: #[warn(while_true)] on by default\n+\n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:10:25\n    |"}, {"sha": "512ad9427ea54c681946da8cfa5e2fa92453985b", "filename": "src/test/ui/consts/const-labeled-break.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fconst-labeled-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fconst-labeled-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-labeled-break.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -4,7 +4,6 @@\n // See https://github.com/rust-lang/rust/issues/51350 for more information.\n \n const CRASH: () = 'a: while break 'a {};\n+//~^ ERROR constant contains unimplemented expression type\n \n-fn main() {\n-    println!(\"{:?}\", CRASH);\n-}\n+fn main() {}", "previous_filename": "src/test/run-pass/consts/const-labeled-break.rs"}, {"sha": "2009e92235566cfd8cc89d1fce35d4c8c08ff3e3", "filename": "src/test/ui/consts/const-labeled-break.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fconst-labeled-break.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fconst-labeled-break.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-labeled-break.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -0,0 +1,9 @@\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/const-labeled-break.rs:6:19\n+   |\n+LL | const CRASH: () = 'a: while break 'a {};\n+   |                   ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0019`."}, {"sha": "afe48ee9ae5421366a474e6807eca211c2bb551b", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.nll.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -169,7 +169,7 @@ LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: loops and conditional expressions are not stable in const fn\n+error[E0723]: loops are not allowed in const fn\n   --> $DIR/min_const_fn.rs:102:29\n    |\n LL | const fn foo30_5(b: bool) { while b { } }\n@@ -179,7 +179,7 @@ LL | const fn foo30_5(b: bool) { while b { } }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n-  --> $DIR/min_const_fn.rs:104:44\n+  --> $DIR/min_const_fn.rs:105:44\n    |\n LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    |                                            ^^^^^^\n@@ -188,7 +188,7 @@ LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n-  --> $DIR/min_const_fn.rs:106:44\n+  --> $DIR/min_const_fn.rs:107:44\n    |\n LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n    |                                            ^^^^^^\n@@ -197,7 +197,7 @@ LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:108:14\n+  --> $DIR/min_const_fn.rs:109:14\n    |\n LL | const fn inc(x: &mut i32) { *x += 1 }\n    |              ^\n@@ -206,7 +206,7 @@ LL | const fn inc(x: &mut i32) { *x += 1 }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:113:6\n+  --> $DIR/min_const_fn.rs:114:6\n    |\n LL | impl<T: std::fmt::Debug> Foo<T> {\n    |      ^\n@@ -215,7 +215,7 @@ LL | impl<T: std::fmt::Debug> Foo<T> {\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:118:6\n+  --> $DIR/min_const_fn.rs:119:6\n    |\n LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n    |      ^\n@@ -224,7 +224,7 @@ LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:123:6\n+  --> $DIR/min_const_fn.rs:124:6\n    |\n LL | impl<T: Sync + Sized> Foo<T> {\n    |      ^\n@@ -233,7 +233,7 @@ LL | impl<T: Sync + Sized> Foo<T> {\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:129:24\n+  --> $DIR/min_const_fn.rs:130:24\n    |\n LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -242,7 +242,7 @@ LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:131:34\n+  --> $DIR/min_const_fn.rs:132:34\n    |\n LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -251,7 +251,7 @@ LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:133:22\n+  --> $DIR/min_const_fn.rs:134:22\n    |\n LL | const fn no_apit(_x: impl std::fmt::Debug) {}\n    |                      ^^^^^^^^^^^^^^^^^^^^\n@@ -260,7 +260,7 @@ LL | const fn no_apit(_x: impl std::fmt::Debug) {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:134:23\n+  --> $DIR/min_const_fn.rs:135:23\n    |\n LL | const fn no_rpit() -> impl std::fmt::Debug {}\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -269,7 +269,7 @@ LL | const fn no_rpit() -> impl std::fmt::Debug {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:135:23\n+  --> $DIR/min_const_fn.rs:136:23\n    |\n LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {}\n    |                       ^^\n@@ -278,7 +278,7 @@ LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:136:32\n+  --> $DIR/min_const_fn.rs:137:32\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -287,7 +287,7 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0515]: cannot return reference to temporary value\n-  --> $DIR/min_const_fn.rs:136:63\n+  --> $DIR/min_const_fn.rs:137:63\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                                               ^--\n@@ -296,7 +296,7 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                                               returns a reference to data owned by the current function\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:144:41\n+  --> $DIR/min_const_fn.rs:145:41\n    |\n LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1 }\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -305,7 +305,7 @@ LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:147:21\n+  --> $DIR/min_const_fn.rs:148:21\n    |\n LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n@@ -314,7 +314,7 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:149:27\n+  --> $DIR/min_const_fn.rs:150:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^"}, {"sha": "8b423da78829290c4b06841f46649547804f5010", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -99,7 +99,8 @@ const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize } }\n //~^ ERROR casting pointers to ints is unstable\n const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n //~^ ERROR loops and conditional expressions are not stable in const fn\n-const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n+const fn foo30_5(b: bool) { while b { } }\n+//~^ ERROR loops are not allowed in const fn\n const fn foo30_6() -> bool { let x = true; x }\n const fn foo36(a: bool, b: bool) -> bool { a && b }\n //~^ ERROR loops and conditional expressions are not stable in const fn"}, {"sha": "66cfe7fa0247ce9a942d542ec023aeb88d1891e9", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -169,7 +169,7 @@ LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: loops and conditional expressions are not stable in const fn\n+error[E0723]: loops are not allowed in const fn\n   --> $DIR/min_const_fn.rs:102:29\n    |\n LL | const fn foo30_5(b: bool) { while b { } }\n@@ -179,7 +179,7 @@ LL | const fn foo30_5(b: bool) { while b { } }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n-  --> $DIR/min_const_fn.rs:104:44\n+  --> $DIR/min_const_fn.rs:105:44\n    |\n LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    |                                            ^^^^^^\n@@ -188,7 +188,7 @@ LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n-  --> $DIR/min_const_fn.rs:106:44\n+  --> $DIR/min_const_fn.rs:107:44\n    |\n LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n    |                                            ^^^^^^\n@@ -197,7 +197,7 @@ LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:108:14\n+  --> $DIR/min_const_fn.rs:109:14\n    |\n LL | const fn inc(x: &mut i32) { *x += 1 }\n    |              ^\n@@ -206,7 +206,7 @@ LL | const fn inc(x: &mut i32) { *x += 1 }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:113:6\n+  --> $DIR/min_const_fn.rs:114:6\n    |\n LL | impl<T: std::fmt::Debug> Foo<T> {\n    |      ^\n@@ -215,7 +215,7 @@ LL | impl<T: std::fmt::Debug> Foo<T> {\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:118:6\n+  --> $DIR/min_const_fn.rs:119:6\n    |\n LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n    |      ^\n@@ -224,7 +224,7 @@ LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:123:6\n+  --> $DIR/min_const_fn.rs:124:6\n    |\n LL | impl<T: Sync + Sized> Foo<T> {\n    |      ^\n@@ -233,7 +233,7 @@ LL | impl<T: Sync + Sized> Foo<T> {\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:129:24\n+  --> $DIR/min_const_fn.rs:130:24\n    |\n LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -242,7 +242,7 @@ LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:131:34\n+  --> $DIR/min_const_fn.rs:132:34\n    |\n LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -251,7 +251,7 @@ LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:133:22\n+  --> $DIR/min_const_fn.rs:134:22\n    |\n LL | const fn no_apit(_x: impl std::fmt::Debug) {}\n    |                      ^^^^^^^^^^^^^^^^^^^^\n@@ -260,7 +260,7 @@ LL | const fn no_apit(_x: impl std::fmt::Debug) {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:134:23\n+  --> $DIR/min_const_fn.rs:135:23\n    |\n LL | const fn no_rpit() -> impl std::fmt::Debug {}\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -269,7 +269,7 @@ LL | const fn no_rpit() -> impl std::fmt::Debug {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:135:23\n+  --> $DIR/min_const_fn.rs:136:23\n    |\n LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {}\n    |                       ^^\n@@ -278,7 +278,7 @@ LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:136:32\n+  --> $DIR/min_const_fn.rs:137:32\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -287,7 +287,7 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n warning[E0515]: cannot return reference to temporary value\n-  --> $DIR/min_const_fn.rs:136:63\n+  --> $DIR/min_const_fn.rs:137:63\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                                               ^--\n@@ -300,7 +300,7 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    = note: for more information, try `rustc --explain E0729`\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:144:41\n+  --> $DIR/min_const_fn.rs:145:41\n    |\n LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1 }\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -309,7 +309,7 @@ LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:147:21\n+  --> $DIR/min_const_fn.rs:148:21\n    |\n LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n@@ -318,7 +318,7 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:149:27\n+  --> $DIR/min_const_fn.rs:150:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^"}, {"sha": "ca3df0fdde45d457898041b1bae7234efdd726cb", "filename": "src/test/ui/if/if-no-match-bindings.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -19,4 +19,10 @@ fn main() {\n     if b_mut_ref() {} //~ ERROR mismatched types [E0308]\n     if &true {} //~ ERROR mismatched types [E0308]\n     if &mut true {} //~ ERROR mismatched types [E0308]\n+\n+    // This is also NOT:\n+    while b_ref() {} //~ ERROR mismatched types [E0308]\n+    while b_mut_ref() {} //~ ERROR mismatched types [E0308]\n+    while &true {} //~ ERROR mismatched types [E0308]\n+    while &mut true {} //~ ERROR mismatched types [E0308]\n }"}, {"sha": "cbf52476ae37f5dffe46478494984365de7212ee", "filename": "src/test/ui/if/if-no-match-bindings.stderr", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -34,6 +34,42 @@ LL |     if &mut true {}\n    = note: expected type `bool`\n               found type `&mut bool`\n \n-error: aborting due to 4 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/if-no-match-bindings.rs:24:11\n+   |\n+LL |     while b_ref() {}\n+   |           ^^^^^^^ expected bool, found &bool\n+   |\n+   = note: expected type `bool`\n+              found type `&bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/if-no-match-bindings.rs:25:11\n+   |\n+LL |     while b_mut_ref() {}\n+   |           ^^^^^^^^^^^ expected bool, found &mut bool\n+   |\n+   = note: expected type `bool`\n+              found type `&mut bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/if-no-match-bindings.rs:26:11\n+   |\n+LL |     while &true {}\n+   |           ^^^^^ expected bool, found &bool\n+   |\n+   = note: expected type `bool`\n+              found type `&bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/if-no-match-bindings.rs:27:11\n+   |\n+LL |     while &mut true {}\n+   |           ^^^^^^^^^ expected bool, found &mut bool\n+   |\n+   = note: expected type `bool`\n+              found type `&mut bool`\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "517c1f2e6c7cc2b4cbb1b073fc9d5d6390450fa0", "filename": "src/test/ui/issues/issue-27042.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fissues%2Fissue-27042.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fissues%2Fissue-27042.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27042.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -6,6 +6,7 @@ fn main() {\n         loop { break }; //~ ERROR mismatched types\n     let _: i32 =\n         'b: //~ ERROR mismatched types\n+        //~^ WARN denote infinite loops with\n         while true { break }; // but here we cite the whole loop\n     let _: i32 =\n         'c: //~ ERROR mismatched types"}, {"sha": "c67b8ad738155533d0854284a57dfc619f66e623", "filename": "src/test/ui/issues/issue-27042.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1,3 +1,13 @@\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/issue-27042.rs:8:9\n+   |\n+LL | /         'b:\n+LL | |\n+LL | |         while true { break }; // but here we cite the whole loop\n+   | |____________________________^ help: use `loop`\n+   |\n+   = note: #[warn(while_true)] on by default\n+\n error[E0308]: mismatched types\n   --> $DIR/issue-27042.rs:6:16\n    |\n@@ -11,14 +21,15 @@ error[E0308]: mismatched types\n   --> $DIR/issue-27042.rs:8:9\n    |\n LL | /         'b:\n+LL | |\n LL | |         while true { break }; // but here we cite the whole loop\n    | |____________________________^ expected i32, found ()\n    |\n    = note: expected type `i32`\n               found type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-27042.rs:11:9\n+  --> $DIR/issue-27042.rs:12:9\n    |\n LL | /         'c:\n LL | |         for _ in None { break }; // but here we cite the whole loop\n@@ -28,7 +39,7 @@ LL | |         for _ in None { break }; // but here we cite the whole loop\n               found type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-27042.rs:14:9\n+  --> $DIR/issue-27042.rs:15:9\n    |\n LL | /         'd:\n LL | |         while let Some(_) = None { break };"}, {"sha": "2c9a264287c9675e62d8af6d216d0f39b29c7a18", "filename": "src/test/ui/lint/lint-impl-fn.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Flint%2Flint-impl-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Flint%2Flint-impl-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-impl-fn.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -11,25 +11,25 @@ LL |     #[deny(while_true)]\n    |            ^^^^^^^^^^\n \n error: denote infinite loops with `loop { ... }`\n-  --> $DIR/lint-impl-fn.rs:27:5\n+  --> $DIR/lint-impl-fn.rs:18:25\n    |\n-LL |     while true {}\n-   |     ^^^^^^^^^^ help: use `loop`\n+LL |         fn foo(&self) { while true {} }\n+   |                         ^^^^^^^^^^ help: use `loop`\n    |\n note: lint level defined here\n-  --> $DIR/lint-impl-fn.rs:25:8\n+  --> $DIR/lint-impl-fn.rs:13:8\n    |\n LL | #[deny(while_true)]\n    |        ^^^^^^^^^^\n \n error: denote infinite loops with `loop { ... }`\n-  --> $DIR/lint-impl-fn.rs:18:25\n+  --> $DIR/lint-impl-fn.rs:27:5\n    |\n-LL |         fn foo(&self) { while true {} }\n-   |                         ^^^^^^^^^^ help: use `loop`\n+LL |     while true {}\n+   |     ^^^^^^^^^^ help: use `loop`\n    |\n note: lint level defined here\n-  --> $DIR/lint-impl-fn.rs:13:8\n+  --> $DIR/lint-impl-fn.rs:25:8\n    |\n LL | #[deny(while_true)]\n    |        ^^^^^^^^^^"}, {"sha": "811bc87eb0e2eee5afe81311b39301f29fa79d37", "filename": "src/test/ui/lint/lint-unnecessary-parens.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -19,6 +19,7 @@ fn main() {\n \n     if (true) {} //~ ERROR unnecessary parentheses around `if` condition\n     while (true) {} //~ ERROR unnecessary parentheses around `while` condition\n+    //~^ WARN denote infinite loops with\n     match (true) { //~ ERROR unnecessary parentheses around `match` head expression\n         _ => {}\n     }"}, {"sha": "05ecbfdf4fa39a173a6e976f949a5ed944f8638b", "filename": "src/test/ui/lint/lint-unnecessary-parens.stderr", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -34,44 +34,52 @@ error: unnecessary parentheses around `while` condition\n LL |     while (true) {}\n    |           ^^^^^^ help: remove these parentheses\n \n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/lint-unnecessary-parens.rs:21:5\n+   |\n+LL |     while (true) {}\n+   |     ^^^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: #[warn(while_true)] on by default\n+\n error: unnecessary parentheses around `match` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:22:11\n+  --> $DIR/lint-unnecessary-parens.rs:23:11\n    |\n LL |     match (true) {\n    |           ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `let` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:25:16\n+  --> $DIR/lint-unnecessary-parens.rs:26:16\n    |\n LL |     if let 1 = (1) {}\n    |                ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `let` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:26:19\n+  --> $DIR/lint-unnecessary-parens.rs:27:19\n    |\n LL |     while let 1 = (2) {}\n    |                   ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around method argument\n-  --> $DIR/lint-unnecessary-parens.rs:40:24\n+  --> $DIR/lint-unnecessary-parens.rs:41:24\n    |\n LL |     X { y: false }.foo((true));\n    |                        ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:42:18\n+  --> $DIR/lint-unnecessary-parens.rs:43:18\n    |\n LL |     let mut _a = (0);\n    |                  ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:43:10\n+  --> $DIR/lint-unnecessary-parens.rs:44:10\n    |\n LL |     _a = (0);\n    |          ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:44:11\n+  --> $DIR/lint-unnecessary-parens.rs:45:11\n    |\n LL |     _a += (1);\n    |           ^^^ help: remove these parentheses"}, {"sha": "de7c1fb898679e0ea5fde2850739b3967b9b7f7e", "filename": "src/test/ui/lint/suggestions.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1,3 +1,11 @@\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/suggestions.rs:46:5\n+   |\n+LL |     while true {\n+   |     ^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: #[warn(while_true)] on by default\n+\n warning: unnecessary parentheses around assigned value\n   --> $DIR/suggestions.rs:49:31\n    |\n@@ -65,14 +73,6 @@ LL | pub fn defiant<T>(_t: T) {}\n    |\n    = note: #[warn(no_mangle_generic_items)] on by default\n \n-warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/suggestions.rs:46:5\n-   |\n-LL |     while true {\n-   |     ^^^^^^^^^^ help: use `loop`\n-   |\n-   = note: #[warn(while_true)] on by default\n-\n warning: the `warp_factor:` in this pattern is redundant\n   --> $DIR/suggestions.rs:61:23\n    |"}, {"sha": "9f3ebf1362b823fc736e10d3999584a826e2a5dd", "filename": "src/test/ui/liveness/liveness-move-in-while.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -6,5 +6,8 @@ fn main() {\n     loop {\n         println!(\"{}\", y); //~ ERROR borrow of moved value: `y`\n         while true { while true { while true { x = y; x.clone(); } } }\n+        //~^ WARN denote infinite loops with\n+        //~| WARN denote infinite loops with\n+        //~| WARN denote infinite loops with\n     }\n }"}, {"sha": "bbf5e50f1e09d3662a259cacf0aab17f6f5c1e39", "filename": "src/test/ui/liveness/liveness-move-in-while.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1,3 +1,23 @@\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/liveness-move-in-while.rs:8:9\n+   |\n+LL |         while true { while true { while true { x = y; x.clone(); } } }\n+   |         ^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: #[warn(while_true)] on by default\n+\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/liveness-move-in-while.rs:8:22\n+   |\n+LL |         while true { while true { while true { x = y; x.clone(); } } }\n+   |                      ^^^^^^^^^^ help: use `loop`\n+\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/liveness-move-in-while.rs:8:35\n+   |\n+LL |         while true { while true { while true { x = y; x.clone(); } } }\n+   |                                   ^^^^^^^^^^ help: use `loop`\n+\n error[E0382]: borrow of moved value: `y`\n   --> $DIR/liveness-move-in-while.rs:7:24\n    |"}, {"sha": "7c2f63ec51a79d0bf22f3241df642b86511cadd9", "filename": "src/test/ui/loops/loop-break-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -23,7 +23,7 @@ fn main() {\n         };\n     };\n \n-    'while_loop: while true {\n+    'while_loop: while true { //~ WARN denote infinite loops with\n         break;\n         break (); //~ ERROR `break` with value from a `while` loop\n         loop {"}, {"sha": "f458c88ea4892989b7fac8a14b94ee6adf510578", "filename": "src/test/ui/loops/loop-break-value.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1,3 +1,11 @@\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/loop-break-value.rs:26:5\n+   |\n+LL |     'while_loop: while true {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: #[warn(while_true)] on by default\n+\n error[E0571]: `break` with value from a `while` loop\n   --> $DIR/loop-break-value.rs:28:9\n    |"}, {"sha": "10a4b69939f12505c04a971367fe9842ae5563f0", "filename": "src/test/ui/reachable/expr_while.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_while.rs?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -5,8 +5,8 @@\n \n fn foo() {\n     while {return} {\n+        //~^ ERROR unreachable block in `while` expression\n         println!(\"Hello, world!\");\n-        //~^ ERROR unreachable\n     }\n }\n \n@@ -20,11 +20,10 @@ fn bar() {\n fn baz() {\n     // Here, we cite the `while` loop as dead.\n     while {return} {\n+        //~^ ERROR unreachable block in `while` expression\n         println!(\"I am dead.\");\n-        //~^ ERROR unreachable\n     }\n     println!(\"I am, too.\");\n-    //~^ ERROR unreachable\n }\n \n fn main() { }"}, {"sha": "fc528926b4c97bdb60be6d0729d37f8265b46ee6", "filename": "src/test/ui/reachable/expr_while.stderr", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/254f2014954bd66da206232490824975c0c662f1/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_while.stderr?ref=254f2014954bd66da206232490824975c0c662f1", "patch": "@@ -1,31 +1,28 @@\n-error: unreachable statement\n-  --> $DIR/expr_while.rs:8:9\n+error: unreachable block in `while` expression\n+  --> $DIR/expr_while.rs:7:20\n    |\n-LL |         println!(\"Hello, world!\");\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       while {return} {\n+   |  ____________________^\n+LL | |\n+LL | |         println!(\"Hello, world!\");\n+LL | |     }\n+   | |_____^\n    |\n note: lint level defined here\n   --> $DIR/expr_while.rs:4:9\n    |\n LL | #![deny(unreachable_code)]\n    |         ^^^^^^^^^^^^^^^^\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: unreachable statement\n-  --> $DIR/expr_while.rs:23:9\n+error: unreachable block in `while` expression\n+  --> $DIR/expr_while.rs:22:20\n    |\n-LL |         println!(\"I am dead.\");\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-error: unreachable statement\n-  --> $DIR/expr_while.rs:26:5\n-   |\n-LL |     println!(\"I am, too.\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+LL |       while {return} {\n+   |  ____________________^\n+LL | |\n+LL | |         println!(\"I am dead.\");\n+LL | |     }\n+   | |_____^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}]}