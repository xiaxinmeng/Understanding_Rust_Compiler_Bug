{"sha": "b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "node_id": "C_kwDOAAsO6NoAKGI1YTRmYTEzMjJmZTdhODEyMGE3NmZmY2I0MDM3ZjNhZGNmZTE5YmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-31T14:20:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-31T14:20:17Z"}, "message": "Auto merge of #10222 - Alexendoo:needless-lifetime-suggestion, r=flip1995\n\nAdd machine applicable suggestion for `needless_lifetimes`\n\nchangelog: [`needless_lifetimes`]: Add machine applicable suggestion\n\nFixes #9360\n\nIt doesn't make suggestions for async functions as the input lifetime spans are funky there\n\nThe examples in #5787 and #7271 no longer seem to FP this PR aside, I added tests for them rather than disabling the lint entirely for async functions, I don't know if there are further FPs there though\n\nCloses #5787\nCloses #7271", "tree": {"sha": "4ac85e5ae4e59aa7aafc122c94298697f8eda9cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ac85e5ae4e59aa7aafc122c94298697f8eda9cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "html_url": "https://github.com/rust-lang/rust/commit/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "607e3e893e5963c55986880db1cd1031a910d3af", "url": "https://api.github.com/repos/rust-lang/rust/commits/607e3e893e5963c55986880db1cd1031a910d3af", "html_url": "https://github.com/rust-lang/rust/commit/607e3e893e5963c55986880db1cd1031a910d3af"}, {"sha": "6a8b20230b4e1ccdc5936d9cde5a6018d3b8fc74", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8b20230b4e1ccdc5936d9cde5a6018d3b8fc74", "html_url": "https://github.com/rust-lang/rust/commit/6a8b20230b4e1ccdc5936d9cde5a6018d3b8fc74"}], "stats": {"total": 1201, "additions": 1019, "deletions": 182}, "files": [{"sha": "3cccc2cfe2aa3409a316a6f607f7422e9e505a52", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 146, "deletions": 107, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "patch": "@@ -1,22 +1,21 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::nested_filter::{self as hir_nested_filter, NestedFilter};\n use rustc_hir::intravisit::{\n-    walk_fn_decl, walk_generic_arg, walk_generic_param, walk_generics, walk_impl_item_ref, walk_item, walk_param_bound,\n+    walk_fn_decl, walk_generic_param, walk_generics, walk_impl_item_ref, walk_item, walk_param_bound,\n     walk_poly_trait_ref, walk_trait_ref, walk_ty, Visitor,\n };\n-use rustc_hir::lang_items;\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n-    BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, LifetimeParamKind, PolyTraitRef, PredicateOrigin, TraitFn,\n-    TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n+    lang_items, BareFnTy, BodyId, FnDecl, FnSig, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics,\n+    Impl, ImplItem, ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, LifetimeParamKind, Node, PolyTraitRef,\n+    PredicateOrigin, TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::TyCtxt;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n@@ -35,8 +34,6 @@ declare_clippy_lint! {\n     /// ### Known problems\n     /// - We bail out if the function has a `where` clause where lifetimes\n     /// are mentioned due to potential false positives.\n-    /// - Lifetime bounds such as `impl Foo + 'a` and `T: 'a` must be elided with the\n-    /// placeholder notation `'_` because the fully elided notation leaves the type bound to `'static`.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -94,7 +91,7 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, generics, id) = item.kind {\n-            check_fn_inner(cx, sig.decl, Some(id), None, generics, item.span, true);\n+            check_fn_inner(cx, sig, Some(id), None, generics, item.span, true);\n         } else if let ItemKind::Impl(impl_) = item.kind {\n             if !item.span.from_expansion() {\n                 report_extra_impl_lifetimes(cx, impl_);\n@@ -107,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n             let report_extra_lifetimes = trait_ref_of_method(cx, item.owner_id.def_id).is_none();\n             check_fn_inner(\n                 cx,\n-                sig.decl,\n+                sig,\n                 Some(id),\n                 None,\n                 item.generics,\n@@ -123,22 +120,14 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 TraitFn::Required(sig) => (None, Some(sig)),\n                 TraitFn::Provided(id) => (Some(id), None),\n             };\n-            check_fn_inner(cx, sig.decl, body, trait_sig, item.generics, item.span, true);\n+            check_fn_inner(cx, sig, body, trait_sig, item.generics, item.span, true);\n         }\n     }\n }\n \n-/// The lifetime of a &-reference.\n-#[derive(PartialEq, Eq, Hash, Debug, Clone)]\n-enum RefLt {\n-    Unnamed,\n-    Static,\n-    Named(LocalDefId),\n-}\n-\n fn check_fn_inner<'tcx>(\n     cx: &LateContext<'tcx>,\n-    decl: &'tcx FnDecl<'_>,\n+    sig: &'tcx FnSig<'_>,\n     body: Option<BodyId>,\n     trait_sig: Option<&[Ident]>,\n     generics: &'tcx Generics<'_>,\n@@ -164,7 +153,7 @@ fn check_fn_inner<'tcx>(\n             for bound in pred.bounds {\n                 let mut visitor = RefVisitor::new(cx);\n                 walk_param_bound(&mut visitor, bound);\n-                if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n+                if visitor.lts.iter().any(|lt| matches!(lt.res, LifetimeName::Param(_))) {\n                     return;\n                 }\n                 if let GenericBound::Trait(ref trait_ref, _) = *bound {\n@@ -191,34 +180,112 @@ fn check_fn_inner<'tcx>(\n         }\n     }\n \n-    if let Some(elidable_lts) = could_use_elision(cx, decl, body, trait_sig, generics.params) {\n+    if let Some((elidable_lts, usages)) = could_use_elision(cx, sig.decl, body, trait_sig, generics.params) {\n         let lts = elidable_lts\n             .iter()\n             // In principle, the result of the call to `Node::ident` could be `unwrap`ped, as `DefId` should refer to a\n             // `Node::GenericParam`.\n-            .filter_map(|&(def_id, _)| cx.tcx.hir().get_by_def_id(def_id).ident())\n+            .filter_map(|&def_id| cx.tcx.hir().get_by_def_id(def_id).ident())\n             .map(|ident| ident.to_string())\n             .collect::<Vec<_>>()\n             .join(\", \");\n \n         span_lint_and_then(\n             cx,\n             NEEDLESS_LIFETIMES,\n-            span.with_hi(decl.output.span().hi()),\n+            span.with_hi(sig.decl.output.span().hi()),\n             &format!(\"the following explicit lifetimes could be elided: {lts}\"),\n             |diag| {\n-                if let Some(span) = elidable_lts.iter().find_map(|&(_, span)| span) {\n-                    diag.span_help(span, \"replace with `'_` in generic arguments such as here\");\n+                if sig.header.is_async() {\n+                    // async functions have usages whose spans point at the lifetime declaration which messes up\n+                    // suggestions\n+                    return;\n+                };\n+\n+                if let Some(suggestions) = elision_suggestions(cx, generics, &elidable_lts, &usages) {\n+                    diag.multipart_suggestion(\"elide the lifetimes\", suggestions, Applicability::MachineApplicable);\n                 }\n             },\n         );\n     }\n \n     if report_extra_lifetimes {\n-        self::report_extra_lifetimes(cx, decl, generics);\n+        self::report_extra_lifetimes(cx, sig.decl, generics);\n     }\n }\n \n+fn elision_suggestions(\n+    cx: &LateContext<'_>,\n+    generics: &Generics<'_>,\n+    elidable_lts: &[LocalDefId],\n+    usages: &[Lifetime],\n+) -> Option<Vec<(Span, String)>> {\n+    let explicit_params = generics\n+        .params\n+        .iter()\n+        .filter(|param| !param.is_elided_lifetime() && !param.is_impl_trait())\n+        .collect::<Vec<_>>();\n+\n+    let mut suggestions = if elidable_lts.len() == explicit_params.len() {\n+        // if all the params are elided remove the whole generic block\n+        //\n+        // fn x<'a>() {}\n+        //     ^^^^\n+        vec![(generics.span, String::new())]\n+    } else {\n+        elidable_lts\n+            .iter()\n+            .map(|&id| {\n+                let pos = explicit_params.iter().position(|param| param.def_id == id)?;\n+                let param = explicit_params.get(pos)?;\n+\n+                let span = if let Some(next) = explicit_params.get(pos + 1) {\n+                    // fn x<'prev, 'a, 'next>() {}\n+                    //             ^^^^\n+                    param.span.until(next.span)\n+                } else {\n+                    // `pos` should be at least 1 here, because the param in position 0 would either have a `next`\n+                    // param or would have taken the `elidable_lts.len() == explicit_params.len()` branch.\n+                    let prev = explicit_params.get(pos - 1)?;\n+\n+                    // fn x<'prev, 'a>() {}\n+                    //           ^^^^\n+                    param.span.with_lo(prev.span.hi())\n+                };\n+\n+                Some((span, String::new()))\n+            })\n+            .collect::<Option<Vec<_>>>()?\n+    };\n+\n+    suggestions.extend(\n+        usages\n+            .iter()\n+            .filter(|usage| named_lifetime(usage).map_or(false, |id| elidable_lts.contains(&id)))\n+            .map(|usage| {\n+                match cx.tcx.hir().get_parent(usage.hir_id) {\n+                    Node::Ty(Ty {\n+                        kind: TyKind::Ref(..), ..\n+                    }) => {\n+                        // expand `&'a T` to `&'a T`\n+                        //          ^^         ^^^\n+                        let span = cx\n+                            .sess()\n+                            .source_map()\n+                            .span_extend_while(usage.ident.span, |ch| ch.is_ascii_whitespace())\n+                            .unwrap_or(usage.ident.span);\n+\n+                        (span, String::new())\n+                    },\n+                    // `T<'a>` and `impl Foo + 'a` should be replaced by `'_`\n+                    _ => (usage.ident.span, String::from(\"'_\")),\n+                }\n+            }),\n+    );\n+\n+    Some(suggestions)\n+}\n+\n // elision doesn't work for explicit self types, see rust-lang/rust#69064\n fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident: Option<Ident>) -> bool {\n     if_chain! {\n@@ -238,21 +305,28 @@ fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident:\n     }\n }\n \n+fn named_lifetime(lt: &Lifetime) -> Option<LocalDefId> {\n+    match lt.res {\n+        LifetimeName::Param(id) if !lt.is_anonymous() => Some(id),\n+        _ => None,\n+    }\n+}\n+\n fn could_use_elision<'tcx>(\n     cx: &LateContext<'tcx>,\n     func: &'tcx FnDecl<'_>,\n     body: Option<BodyId>,\n     trait_sig: Option<&[Ident]>,\n     named_generics: &'tcx [GenericParam<'_>],\n-) -> Option<Vec<(LocalDefId, Option<Span>)>> {\n+) -> Option<(Vec<LocalDefId>, Vec<Lifetime>)> {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n     // All lifetimes must be unnamed, 'static or defined without bounds on the\n     // level of the current item.\n \n     // check named LTs\n-    let allowed_lts = allowed_lts_from(cx.tcx, named_generics);\n+    let allowed_lts = allowed_lts_from(named_generics);\n \n     // these will collect all the lifetimes for references in arg/return types\n     let mut input_visitor = RefVisitor::new(cx);\n@@ -302,32 +376,24 @@ fn could_use_elision<'tcx>(\n \n     // check for lifetimes from higher scopes\n     for lt in input_lts.iter().chain(output_lts.iter()) {\n-        if !allowed_lts.contains(lt) {\n+        if let Some(id) = named_lifetime(lt)\n+            && !allowed_lts.contains(&id)\n+        {\n             return None;\n         }\n     }\n \n     // check for higher-ranked trait bounds\n     if !input_visitor.nested_elision_site_lts.is_empty() || !output_visitor.nested_elision_site_lts.is_empty() {\n-        let allowed_lts: FxHashSet<_> = allowed_lts\n-            .iter()\n-            .filter_map(|lt| match lt {\n-                RefLt::Named(def_id) => Some(cx.tcx.item_name(def_id.to_def_id())),\n-                _ => None,\n-            })\n-            .collect();\n+        let allowed_lts: FxHashSet<_> = allowed_lts.iter().map(|id| cx.tcx.item_name(id.to_def_id())).collect();\n         for lt in input_visitor.nested_elision_site_lts {\n-            if let RefLt::Named(def_id) = lt {\n-                if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n-                    return None;\n-                }\n+            if allowed_lts.contains(&lt.ident.name) {\n+                return None;\n             }\n         }\n         for lt in output_visitor.nested_elision_site_lts {\n-            if let RefLt::Named(def_id) = lt {\n-                if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n-                    return None;\n-                }\n+            if allowed_lts.contains(&lt.ident.name) {\n+                return None;\n             }\n         }\n     }\n@@ -339,47 +405,45 @@ fn could_use_elision<'tcx>(\n     let elidable_lts = named_lifetime_occurrences(&input_lts)\n         .into_iter()\n         .filter_map(|(def_id, occurrences)| {\n-            if occurrences == 1 && (input_lts.len() == 1 || !output_lts.contains(&RefLt::Named(def_id))) {\n-                Some((\n-                    def_id,\n-                    input_visitor\n-                        .lifetime_generic_arg_spans\n-                        .get(&def_id)\n-                        .or_else(|| output_visitor.lifetime_generic_arg_spans.get(&def_id))\n-                        .copied(),\n-                ))\n+            if occurrences == 1\n+                && (input_lts.len() == 1 || !output_lts.iter().any(|lt| named_lifetime(lt) == Some(def_id)))\n+            {\n+                Some(def_id)\n             } else {\n                 None\n             }\n         })\n         .collect::<Vec<_>>();\n \n     if elidable_lts.is_empty() {\n-        None\n-    } else {\n-        Some(elidable_lts)\n+        return None;\n     }\n+\n+    let usages = itertools::chain(input_lts, output_lts).collect();\n+\n+    Some((elidable_lts, usages))\n }\n \n-fn allowed_lts_from(tcx: TyCtxt<'_>, named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n-    let mut allowed_lts = FxHashSet::default();\n-    for par in named_generics.iter() {\n-        if let GenericParamKind::Lifetime { .. } = par.kind {\n-            allowed_lts.insert(RefLt::Named(tcx.hir().local_def_id(par.hir_id)));\n-        }\n-    }\n-    allowed_lts.insert(RefLt::Unnamed);\n-    allowed_lts.insert(RefLt::Static);\n-    allowed_lts\n+fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<LocalDefId> {\n+    named_generics\n+        .iter()\n+        .filter_map(|par| {\n+            if let GenericParamKind::Lifetime { .. } = par.kind {\n+                Some(par.def_id)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect()\n }\n \n /// Number of times each named lifetime occurs in the given slice. Returns a vector to preserve\n /// relative order.\n #[must_use]\n-fn named_lifetime_occurrences(lts: &[RefLt]) -> Vec<(LocalDefId, usize)> {\n+fn named_lifetime_occurrences(lts: &[Lifetime]) -> Vec<(LocalDefId, usize)> {\n     let mut occurrences = Vec::new();\n     for lt in lts {\n-        if let &RefLt::Named(curr_def_id) = lt {\n+        if let Some(curr_def_id) = named_lifetime(lt) {\n             if let Some(pair) = occurrences\n                 .iter_mut()\n                 .find(|(prev_def_id, _)| *prev_def_id == curr_def_id)\n@@ -393,12 +457,10 @@ fn named_lifetime_occurrences(lts: &[RefLt]) -> Vec<(LocalDefId, usize)> {\n     occurrences\n }\n \n-/// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    lts: Vec<RefLt>,\n-    lifetime_generic_arg_spans: FxHashMap<LocalDefId, Span>,\n-    nested_elision_site_lts: Vec<RefLt>,\n+    lts: Vec<Lifetime>,\n+    nested_elision_site_lts: Vec<Lifetime>,\n     unelided_trait_object_lifetime: bool,\n }\n \n@@ -407,32 +469,16 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         Self {\n             cx,\n             lts: Vec::new(),\n-            lifetime_generic_arg_spans: FxHashMap::default(),\n             nested_elision_site_lts: Vec::new(),\n             unelided_trait_object_lifetime: false,\n         }\n     }\n \n-    fn record(&mut self, lifetime: &Option<Lifetime>) {\n-        if let Some(ref lt) = *lifetime {\n-            if lt.is_static() {\n-                self.lts.push(RefLt::Static);\n-            } else if lt.is_anonymous() {\n-                // Fresh lifetimes generated should be ignored.\n-                self.lts.push(RefLt::Unnamed);\n-            } else if let LifetimeName::Param(def_id) = lt.res {\n-                self.lts.push(RefLt::Named(def_id));\n-            }\n-        } else {\n-            self.lts.push(RefLt::Unnamed);\n-        }\n-    }\n-\n-    fn all_lts(&self) -> Vec<RefLt> {\n+    fn all_lts(&self) -> Vec<Lifetime> {\n         self.lts\n             .iter()\n             .chain(self.nested_elision_site_lts.iter())\n-            .cloned()\n+            .copied()\n             .collect::<Vec<_>>()\n     }\n \n@@ -444,7 +490,7 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        self.record(&Some(*lifetime));\n+        self.lts.push(*lifetime);\n     }\n \n     fn visit_poly_trait_ref(&mut self, poly_tref: &'tcx PolyTraitRef<'tcx>) {\n@@ -469,11 +515,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 walk_item(self, item);\n                 self.lts.truncate(len);\n                 self.lts.extend(bounds.iter().filter_map(|bound| match bound {\n-                    GenericArg::Lifetime(l) => Some(if let LifetimeName::Param(def_id) = l.res {\n-                        RefLt::Named(def_id)\n-                    } else {\n-                        RefLt::Unnamed\n-                    }),\n+                    GenericArg::Lifetime(&l) => Some(l),\n                     _ => None,\n                 }));\n             },\n@@ -493,13 +535,6 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             _ => walk_ty(self, ty),\n         }\n     }\n-\n-    fn visit_generic_arg(&mut self, generic_arg: &'tcx GenericArg<'tcx>) {\n-        if let GenericArg::Lifetime(l) = generic_arg && let LifetimeName::Param(def_id) = l.res {\n-            self.lifetime_generic_arg_spans.entry(def_id).or_insert(l.ident.span);\n-        }\n-        walk_generic_arg(self, generic_arg);\n-    }\n }\n \n /// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n@@ -517,14 +552,18 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, generics: &'tcx Generics<'_\n                     return true;\n                 }\n                 // if the bounds define new lifetimes, they are fine to occur\n-                let allowed_lts = allowed_lts_from(cx.tcx, pred.bound_generic_params);\n+                let allowed_lts = allowed_lts_from(pred.bound_generic_params);\n                 // now walk the bounds\n                 for bound in pred.bounds.iter() {\n                     walk_param_bound(&mut visitor, bound);\n                 }\n                 // and check that all lifetimes are allowed\n-                if visitor.all_lts().iter().any(|it| !allowed_lts.contains(it)) {\n-                    return true;\n+                for lt in visitor.all_lts() {\n+                    if let Some(id) = named_lifetime(&lt)\n+                        && !allowed_lts.contains(&id)\n+                    {\n+                        return true;\n+                    }\n                 }\n             },\n             WherePredicate::EqPredicate(ref pred) => {"}, {"sha": "c5ea0b16d1be472b035885bf1d13201ae42bd4d8", "filename": "tests/ui/crashes/ice-2774.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fcrashes%2Fice-2774.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fcrashes%2Fice-2774.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-2774.stderr?ref=b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "patch": "@@ -5,6 +5,11 @@ LL | pub fn add_barfoos_to_foos<'a>(bars: &HashSet<&'a Bar>) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::needless-lifetimes` implied by `-D warnings`\n+help: elide the lifetimes\n+   |\n+LL - pub fn add_barfoos_to_foos<'a>(bars: &HashSet<&'a Bar>) {\n+LL + pub fn add_barfoos_to_foos(bars: &HashSet<&Bar>) {\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "0b0e0ad2684a902adc90a854f25345394ec4ea14", "filename": "tests/ui/crashes/needless_lifetimes_impl_trait.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr?ref=b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "patch": "@@ -9,6 +9,11 @@ note: the lint level is defined here\n    |\n LL | #![deny(clippy::needless_lifetimes)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: elide the lifetimes\n+   |\n+LL -     fn baz<'a>(&'a self) -> impl Foo + 'a {\n+LL +     fn baz(&self) -> impl Foo + '_ {\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "270cd1afc6792650df8a863a2121f731d68a8850", "filename": "tests/ui/needless_lifetimes.fixed", "status": "added", "additions": 537, "deletions": 0, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fneedless_lifetimes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fneedless_lifetimes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.fixed?ref=b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "patch": "@@ -0,0 +1,537 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::needless_lifetimes)]\n+#![allow(\n+    unused,\n+    clippy::boxed_local,\n+    clippy::needless_pass_by_value,\n+    clippy::unnecessary_wraps,\n+    dyn_drop,\n+    clippy::get_first\n+)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+fn distinct_lifetimes(_x: &u8, _y: &u8, _z: u8) {}\n+\n+fn distinct_and_static(_x: &u8, _y: &u8, _z: &'static u8) {}\n+\n+// No error; same lifetime on two params.\n+fn same_lifetime_on_input<'a>(_x: &'a u8, _y: &'a u8) {}\n+\n+// No error; static involved.\n+fn only_static_on_input(_x: &u8, _y: &u8, _z: &'static u8) {}\n+\n+fn mut_and_static_input(_x: &mut u8, _y: &'static str) {}\n+\n+fn in_and_out(x: &u8, _y: u8) -> &u8 {\n+    x\n+}\n+\n+// No error; multiple input refs.\n+fn multiple_in_and_out_1<'a>(x: &'a u8, _y: &'a u8) -> &'a u8 {\n+    x\n+}\n+\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn multiple_in_and_out_2a<'a>(x: &'a u8, _y: &u8) -> &'a u8\n+//                                                ^^^\n+fn multiple_in_and_out_2a<'a>(x: &'a u8, _y: &u8) -> &'a u8 {\n+    x\n+}\n+\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn multiple_in_and_out_2b<'b>(_x: &u8, y: &'b u8) -> &'b u8\n+//                                     ^^^\n+fn multiple_in_and_out_2b<'b>(_x: &u8, y: &'b u8) -> &'b u8 {\n+    y\n+}\n+\n+// No error; multiple input refs\n+async fn func<'a>(args: &[&'a str]) -> Option<&'a str> {\n+    args.get(0).cloned()\n+}\n+\n+// No error; static involved.\n+fn in_static_and_out<'a>(x: &'a u8, _y: &'static u8) -> &'a u8 {\n+    x\n+}\n+\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn deep_reference_1a<'a>(x: &'a u8, _y: &u8) -> Result<&'a u8, ()>\n+//                                           ^^^\n+fn deep_reference_1a<'a>(x: &'a u8, _y: &u8) -> Result<&'a u8, ()> {\n+    Ok(x)\n+}\n+\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn deep_reference_1b<'b>(_x: &u8, y: &'b u8) -> Result<&'b u8, ()>\n+//                                ^^^\n+fn deep_reference_1b<'b>(_x: &u8, y: &'b u8) -> Result<&'b u8, ()> {\n+    Ok(y)\n+}\n+\n+// No error; two input refs.\n+fn deep_reference_2<'a>(x: Result<&'a u8, &'a u8>) -> &'a u8 {\n+    x.unwrap()\n+}\n+\n+fn deep_reference_3(x: &u8, _y: u8) -> Result<&u8, ()> {\n+    Ok(x)\n+}\n+\n+// Where-clause, but without lifetimes.\n+fn where_clause_without_lt<T>(x: &u8, _y: u8) -> Result<&u8, ()>\n+where\n+    T: Copy,\n+{\n+    Ok(x)\n+}\n+\n+type Ref<'r> = &'r u8;\n+\n+// No error; same lifetime on two params.\n+fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) {}\n+\n+fn lifetime_param_2(_x: Ref<'_>, _y: &u8) {}\n+\n+// No error; bounded lifetime.\n+fn lifetime_param_3<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) {}\n+\n+// No error; bounded lifetime.\n+fn lifetime_param_4<'a, 'b>(_x: Ref<'a>, _y: &'b u8)\n+where\n+    'b: 'a,\n+{\n+}\n+\n+struct Lt<'a, I: 'static> {\n+    x: &'a I,\n+}\n+\n+// No error; fn bound references `'a`.\n+fn fn_bound<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n+where\n+    F: Fn(Lt<'a, I>) -> Lt<'a, I>,\n+{\n+    unreachable!()\n+}\n+\n+fn fn_bound_2<F, I>(_m: Lt<'_, I>, _f: F) -> Lt<'_, I>\n+where\n+    for<'x> F: Fn(Lt<'x, I>) -> Lt<'x, I>,\n+{\n+    unreachable!()\n+}\n+\n+// No error; see below.\n+fn fn_bound_3<'a, F: FnOnce(&'a i32)>(x: &'a i32, f: F) {\n+    f(x);\n+}\n+\n+fn fn_bound_3_cannot_elide() {\n+    let x = 42;\n+    let p = &x;\n+    let mut q = &x;\n+    // This will fail if we elide lifetimes of `fn_bound_3`.\n+    fn_bound_3(p, |y| q = y);\n+}\n+\n+// No error; multiple input refs.\n+fn fn_bound_4<'a, F: FnOnce() -> &'a ()>(cond: bool, x: &'a (), f: F) -> &'a () {\n+    if cond { x } else { f() }\n+}\n+\n+struct X {\n+    x: u8,\n+}\n+\n+impl X {\n+    fn self_and_out(&self) -> &u8 {\n+        &self.x\n+    }\n+\n+    // Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+    //   fn self_and_in_out_1<'s>(&'s self, _x: &u8) -> &'s u8\n+    //                                          ^^^\n+    fn self_and_in_out_1<'s>(&'s self, _x: &u8) -> &'s u8 {\n+        &self.x\n+    }\n+\n+    // Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+    //   fn self_and_in_out_2<'t>(&self, x: &'t u8) -> &'t u8\n+    //                            ^^^^^\n+    fn self_and_in_out_2<'t>(&self, x: &'t u8) -> &'t u8 {\n+        x\n+    }\n+\n+    fn distinct_self_and_in(&self, _x: &u8) {}\n+\n+    // No error; same lifetimes on two params.\n+    fn self_and_same_in<'s>(&'s self, _x: &'s u8) {}\n+}\n+\n+struct Foo<'a>(&'a u8);\n+\n+impl<'a> Foo<'a> {\n+    // No error; lifetime `'a` not defined in method.\n+    fn self_shared_lifetime(&self, _: &'a u8) {}\n+    // No error; bounds exist.\n+    fn self_bound_lifetime<'b: 'a>(&self, _: &'b u8) {}\n+}\n+\n+fn already_elided<'a>(_: &u8, _: &'a u8) -> &'a u8 {\n+    unimplemented!()\n+}\n+\n+fn struct_with_lt(_foo: Foo<'_>) -> &str {\n+    unimplemented!()\n+}\n+\n+// No warning; two input lifetimes (named on the reference, anonymous on `Foo`).\n+fn struct_with_lt2<'a>(_foo: &'a Foo) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// No warning; two input lifetimes (anonymous on the reference, named on `Foo`).\n+fn struct_with_lt3<'a>(_foo: &Foo<'a>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn struct_with_lt4a<'a>(_foo: &'a Foo<'_>) -> &'a str\n+//                                         ^^\n+fn struct_with_lt4a<'a>(_foo: &'a Foo<'_>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str\n+//                                 ^^^^\n+fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str {\n+    unimplemented!()\n+}\n+\n+trait WithLifetime<'a> {}\n+\n+type WithLifetimeAlias<'a> = dyn WithLifetime<'a>;\n+\n+// Should not warn because it won't build without the lifetime.\n+fn trait_obj_elided<'a>(_arg: &'a dyn WithLifetime) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Should warn because there is no lifetime on `Drop`, so this would be\n+// unambiguous if we elided the lifetime.\n+fn trait_obj_elided2(_arg: &dyn Drop) -> &str {\n+    unimplemented!()\n+}\n+\n+type FooAlias<'a> = Foo<'a>;\n+\n+fn alias_with_lt(_foo: FooAlias<'_>) -> &str {\n+    unimplemented!()\n+}\n+\n+// No warning; two input lifetimes (named on the reference, anonymous on `FooAlias`).\n+fn alias_with_lt2<'a>(_foo: &'a FooAlias) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// No warning; two input lifetimes (anonymous on the reference, named on `FooAlias`).\n+fn alias_with_lt3<'a>(_foo: &FooAlias<'a>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str\n+//                                             ^^\n+fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn alias_with_lt4b<'b>(_foo: &FooAlias<'b>) -> &'b str\n+//                                ^^^^^^^^^\n+fn alias_with_lt4b<'b>(_foo: &FooAlias<'b>) -> &'b str {\n+    unimplemented!()\n+}\n+\n+fn named_input_elided_output(_arg: &str) -> &str {\n+    unimplemented!()\n+}\n+\n+fn elided_input_named_output<'a>(_arg: &str) -> &'a str {\n+    unimplemented!()\n+}\n+\n+fn trait_bound_ok<T: WithLifetime<'static>>(_: &u8, _: T) {\n+    unimplemented!()\n+}\n+fn trait_bound<'a, T: WithLifetime<'a>>(_: &'a u8, _: T) {\n+    unimplemented!()\n+}\n+\n+// Don't warn on these; see issue #292.\n+fn trait_bound_bug<'a, T: WithLifetime<'a>>() {\n+    unimplemented!()\n+}\n+\n+// See issue #740.\n+struct Test {\n+    vec: Vec<usize>,\n+}\n+\n+impl Test {\n+    fn iter<'a>(&'a self) -> Box<dyn Iterator<Item = usize> + 'a> {\n+        unimplemented!()\n+    }\n+}\n+\n+trait LintContext<'a> {}\n+\n+fn f<'a, T: LintContext<'a>>(_: &T) {}\n+\n+fn test<'a>(x: &'a [u8]) -> u8 {\n+    let y: &'a u8 = &x[5];\n+    *y\n+}\n+\n+// Issue #3284: give hint regarding lifetime in return type.\n+struct Cow<'a> {\n+    x: &'a str,\n+}\n+fn out_return_type_lts(e: &str) -> Cow<'_> {\n+    unimplemented!()\n+}\n+\n+// Make sure we still warn on implementations\n+mod issue4291 {\n+    trait BadTrait {\n+        fn needless_lt(x: &u8) {}\n+    }\n+\n+    impl BadTrait for () {\n+        fn needless_lt(_x: &u8) {}\n+    }\n+}\n+\n+mod issue2944 {\n+    trait Foo {}\n+    struct Bar;\n+    struct Baz<'a> {\n+        bar: &'a Bar,\n+    }\n+\n+    impl<'a> Foo for Baz<'a> {}\n+    impl Bar {\n+        fn baz(&self) -> impl Foo + '_ {\n+            Baz { bar: self }\n+        }\n+    }\n+}\n+\n+mod nested_elision_sites {\n+    // issue #issue2944\n+\n+    // closure trait bounds subject to nested elision\n+    // don't lint because they refer to outer lifetimes\n+    fn trait_fn<'a>(i: &'a i32) -> impl Fn() -> &'a i32 {\n+        move || i\n+    }\n+    fn trait_fn_mut<'a>(i: &'a i32) -> impl FnMut() -> &'a i32 {\n+        move || i\n+    }\n+    fn trait_fn_once<'a>(i: &'a i32) -> impl FnOnce() -> &'a i32 {\n+        move || i\n+    }\n+\n+    // don't lint\n+    fn impl_trait_in_input_position<'a>(f: impl Fn() -> &'a i32) -> &'a i32 {\n+        f()\n+    }\n+    fn impl_trait_in_output_position<'a>(i: &'a i32) -> impl Fn() -> &'a i32 {\n+        move || i\n+    }\n+    // lint\n+    fn impl_trait_elidable_nested_named_lifetimes<'a>(i: &'a i32, f: impl for<'b> Fn(&'b i32) -> &'b i32) -> &'a i32 {\n+        f(i)\n+    }\n+    fn impl_trait_elidable_nested_anonymous_lifetimes(i: &i32, f: impl Fn(&i32) -> &i32) -> &i32 {\n+        f(i)\n+    }\n+\n+    // don't lint\n+    fn generics_not_elidable<'a, T: Fn() -> &'a i32>(f: T) -> &'a i32 {\n+        f()\n+    }\n+    // lint\n+    fn generics_elidable<T: Fn(&i32) -> &i32>(i: &i32, f: T) -> &i32 {\n+        f(i)\n+    }\n+\n+    // don't lint\n+    fn where_clause_not_elidable<'a, T>(f: T) -> &'a i32\n+    where\n+        T: Fn() -> &'a i32,\n+    {\n+        f()\n+    }\n+    // lint\n+    fn where_clause_elidadable<T>(i: &i32, f: T) -> &i32\n+    where\n+        T: Fn(&i32) -> &i32,\n+    {\n+        f(i)\n+    }\n+\n+    // don't lint\n+    fn pointer_fn_in_input_position<'a>(f: fn(&'a i32) -> &'a i32, i: &'a i32) -> &'a i32 {\n+        f(i)\n+    }\n+    fn pointer_fn_in_output_position<'a>(_: &'a i32) -> fn(&'a i32) -> &'a i32 {\n+        |i| i\n+    }\n+    // lint\n+    fn pointer_fn_elidable(i: &i32, f: fn(&i32) -> &i32) -> &i32 {\n+        f(i)\n+    }\n+\n+    // don't lint\n+    fn nested_fn_pointer_1<'a>(_: &'a i32) -> fn(fn(&'a i32) -> &'a i32) -> i32 {\n+        |f| 42\n+    }\n+    fn nested_fn_pointer_2<'a>(_: &'a i32) -> impl Fn(fn(&'a i32)) {\n+        |f| ()\n+    }\n+\n+    // lint\n+    fn nested_fn_pointer_3(_: &i32) -> fn(fn(&i32) -> &i32) -> i32 {\n+        |f| 42\n+    }\n+    fn nested_fn_pointer_4(_: &i32) -> impl Fn(fn(&i32)) {\n+        |f| ()\n+    }\n+}\n+\n+mod issue6159 {\n+    use std::ops::Deref;\n+    pub fn apply_deref<'a, T, F, R>(x: &'a T, f: F) -> R\n+    where\n+        T: Deref,\n+        F: FnOnce(&'a T::Target) -> R,\n+    {\n+        f(x.deref())\n+    }\n+}\n+\n+mod issue7296 {\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    struct Foo;\n+    impl Foo {\n+        fn implicit(&self) -> &() {\n+            &()\n+        }\n+        fn implicit_mut(&mut self) -> &() {\n+            &()\n+        }\n+\n+        fn explicit<'a>(self: &'a Arc<Self>) -> &'a () {\n+            &()\n+        }\n+        fn explicit_mut<'a>(self: &'a mut Rc<Self>) -> &'a () {\n+            &()\n+        }\n+\n+        fn lifetime_elsewhere(self: Box<Self>, here: &()) -> &() {\n+            &()\n+        }\n+    }\n+\n+    trait Bar {\n+        fn implicit(&self) -> &();\n+        fn implicit_provided(&self) -> &() {\n+            &()\n+        }\n+\n+        fn explicit<'a>(self: &'a Arc<Self>) -> &'a ();\n+        fn explicit_provided<'a>(self: &'a Arc<Self>) -> &'a () {\n+            &()\n+        }\n+\n+        fn lifetime_elsewhere(self: Box<Self>, here: &()) -> &();\n+        fn lifetime_elsewhere_provided(self: Box<Self>, here: &()) -> &() {\n+            &()\n+        }\n+    }\n+}\n+\n+mod pr_9743_false_negative_fix {\n+    #![allow(unused)]\n+\n+    fn foo(x: &u8, y: &'_ u8) {}\n+\n+    fn bar(x: &u8, y: &'_ u8, z: &'_ u8) {}\n+}\n+\n+mod pr_9743_output_lifetime_checks {\n+    #![allow(unused)]\n+\n+    // lint: only one input\n+    fn one_input(x: &u8) -> &u8 {\n+        unimplemented!()\n+    }\n+\n+    // lint: multiple inputs, output would not be elided\n+    fn multiple_inputs_output_not_elided<'b>(x: &u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n+        unimplemented!()\n+    }\n+\n+    // don't lint: multiple inputs, output would be elided (which would create an ambiguity)\n+    fn multiple_inputs_output_would_be_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'a u8 {\n+        unimplemented!()\n+    }\n+}\n+\n+mod in_macro {\n+    macro_rules! local_one_input_macro {\n+        () => {\n+            fn one_input(x: &u8) -> &u8 {\n+                unimplemented!()\n+            }\n+        };\n+    }\n+\n+    // lint local macro expands to function with needless lifetimes\n+    local_one_input_macro!();\n+\n+    // no lint on external macro\n+    macro_rules::needless_lifetime!();\n+}\n+\n+mod issue5787 {\n+    use std::sync::MutexGuard;\n+\n+    struct Foo;\n+\n+    impl Foo {\n+        // doesn't get linted without async\n+        pub async fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> MutexGuard<'a, T> {\n+            guard\n+        }\n+    }\n+\n+    async fn foo<'a>(_x: &i32, y: &'a str) -> &'a str {\n+        y\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5d4dc971b8d28529a26dd6d4606baf5d1d35ca63", "filename": "tests/ui/needless_lifetimes.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fneedless_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fneedless_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.rs?ref=b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "patch": "@@ -1,7 +1,9 @@\n+// run-rustfix\n // aux-build:macro_rules.rs\n+\n #![warn(clippy::needless_lifetimes)]\n #![allow(\n-    dead_code,\n+    unused,\n     clippy::boxed_local,\n     clippy::needless_pass_by_value,\n     clippy::unnecessary_wraps,\n@@ -515,4 +517,21 @@ mod in_macro {\n     macro_rules::needless_lifetime!();\n }\n \n+mod issue5787 {\n+    use std::sync::MutexGuard;\n+\n+    struct Foo;\n+\n+    impl Foo {\n+        // doesn't get linted without async\n+        pub async fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> MutexGuard<'a, T> {\n+            guard\n+        }\n+    }\n+\n+    async fn foo<'a>(_x: &i32, y: &'a str) -> &'a str {\n+        y\n+    }\n+}\n+\n fn main() {}"}, {"sha": "afe637ac38887282df5eb9cfe61198cf5b77424e", "filename": "tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 306, "deletions": 74, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc/tests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.stderr?ref=b5a4fa1322fe7a8120a76ffcb4037f3adcfe19bc", "patch": "@@ -1,319 +1,546 @@\n error: the following explicit lifetimes could be elided: 'a, 'b\n-  --> $DIR/needless_lifetimes.rs:15:1\n+  --> $DIR/needless_lifetimes.rs:17:1\n    |\n LL | fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::needless-lifetimes` implied by `-D warnings`\n+help: elide the lifetimes\n+   |\n+LL - fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n+LL + fn distinct_lifetimes(_x: &u8, _y: &u8, _z: u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a, 'b\n-  --> $DIR/needless_lifetimes.rs:17:1\n+  --> $DIR/needless_lifetimes.rs:19:1\n    |\n LL | fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n+LL + fn distinct_and_static(_x: &u8, _y: &u8, _z: &'static u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:27:1\n+  --> $DIR/needless_lifetimes.rs:29:1\n    |\n LL | fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n+LL + fn in_and_out(x: &u8, _y: u8) -> &u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'b\n-  --> $DIR/needless_lifetimes.rs:39:1\n+  --> $DIR/needless_lifetimes.rs:41:1\n    |\n LL | fn multiple_in_and_out_2a<'a, 'b>(x: &'a u8, _y: &'b u8) -> &'a u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn multiple_in_and_out_2a<'a, 'b>(x: &'a u8, _y: &'b u8) -> &'a u8 {\n+LL + fn multiple_in_and_out_2a<'a>(x: &'a u8, _y: &u8) -> &'a u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:46:1\n+  --> $DIR/needless_lifetimes.rs:48:1\n    |\n LL | fn multiple_in_and_out_2b<'a, 'b>(_x: &'a u8, y: &'b u8) -> &'b u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn multiple_in_and_out_2b<'a, 'b>(_x: &'a u8, y: &'b u8) -> &'b u8 {\n+LL + fn multiple_in_and_out_2b<'b>(_x: &u8, y: &'b u8) -> &'b u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'b\n-  --> $DIR/needless_lifetimes.rs:63:1\n+  --> $DIR/needless_lifetimes.rs:65:1\n    |\n LL | fn deep_reference_1a<'a, 'b>(x: &'a u8, _y: &'b u8) -> Result<&'a u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn deep_reference_1a<'a, 'b>(x: &'a u8, _y: &'b u8) -> Result<&'a u8, ()> {\n+LL + fn deep_reference_1a<'a>(x: &'a u8, _y: &u8) -> Result<&'a u8, ()> {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:70:1\n+  --> $DIR/needless_lifetimes.rs:72:1\n    |\n LL | fn deep_reference_1b<'a, 'b>(_x: &'a u8, y: &'b u8) -> Result<&'b u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn deep_reference_1b<'a, 'b>(_x: &'a u8, y: &'b u8) -> Result<&'b u8, ()> {\n+LL + fn deep_reference_1b<'b>(_x: &u8, y: &'b u8) -> Result<&'b u8, ()> {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:79:1\n+  --> $DIR/needless_lifetimes.rs:81:1\n    |\n LL | fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n+LL + fn deep_reference_3(x: &u8, _y: u8) -> Result<&u8, ()> {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:84:1\n+  --> $DIR/needless_lifetimes.rs:86:1\n    |\n LL | fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n+LL + fn where_clause_without_lt<T>(x: &u8, _y: u8) -> Result<&u8, ()>\n+   |\n \n error: the following explicit lifetimes could be elided: 'a, 'b\n-  --> $DIR/needless_lifetimes.rs:96:1\n+  --> $DIR/needless_lifetimes.rs:98:1\n    |\n LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:96:37\n+help: elide the lifetimes\n+   |\n+LL - fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n+LL + fn lifetime_param_2(_x: Ref<'_>, _y: &u8) {}\n    |\n-LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n-   |                                     ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:120:1\n+  --> $DIR/needless_lifetimes.rs:122:1\n    |\n LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:120:32\n+help: elide the lifetimes\n+   |\n+LL - fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n+LL + fn fn_bound_2<F, I>(_m: Lt<'_, I>, _f: F) -> Lt<'_, I>\n    |\n-LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n-   |                                ^^\n \n error: the following explicit lifetimes could be elided: 's\n-  --> $DIR/needless_lifetimes.rs:150:5\n+  --> $DIR/needless_lifetimes.rs:152:5\n    |\n LL |     fn self_and_out<'s>(&'s self) -> &'s u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn self_and_out<'s>(&'s self) -> &'s u8 {\n+LL +     fn self_and_out(&self) -> &u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 't\n-  --> $DIR/needless_lifetimes.rs:157:5\n+  --> $DIR/needless_lifetimes.rs:159:5\n    |\n LL |     fn self_and_in_out_1<'s, 't>(&'s self, _x: &'t u8) -> &'s u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn self_and_in_out_1<'s, 't>(&'s self, _x: &'t u8) -> &'s u8 {\n+LL +     fn self_and_in_out_1<'s>(&'s self, _x: &u8) -> &'s u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 's\n-  --> $DIR/needless_lifetimes.rs:164:5\n+  --> $DIR/needless_lifetimes.rs:166:5\n    |\n LL |     fn self_and_in_out_2<'s, 't>(&'s self, x: &'t u8) -> &'t u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn self_and_in_out_2<'s, 't>(&'s self, x: &'t u8) -> &'t u8 {\n+LL +     fn self_and_in_out_2<'t>(&self, x: &'t u8) -> &'t u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 's, 't\n-  --> $DIR/needless_lifetimes.rs:168:5\n+  --> $DIR/needless_lifetimes.rs:170:5\n    |\n LL |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n+LL +     fn distinct_self_and_in(&self, _x: &u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:187:1\n+  --> $DIR/needless_lifetimes.rs:189:1\n    |\n LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:187:33\n+help: elide the lifetimes\n+   |\n+LL - fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n+LL + fn struct_with_lt(_foo: Foo<'_>) -> &str {\n    |\n-LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n-   |                                 ^^\n \n error: the following explicit lifetimes could be elided: 'b\n-  --> $DIR/needless_lifetimes.rs:205:1\n+  --> $DIR/needless_lifetimes.rs:207:1\n    |\n LL | fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:205:43\n+help: elide the lifetimes\n+   |\n+LL - fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n+LL + fn struct_with_lt4a<'a>(_foo: &'a Foo<'_>) -> &'a str {\n    |\n-LL | fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n-   |                                           ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:213:1\n+  --> $DIR/needless_lifetimes.rs:215:1\n    |\n LL | fn struct_with_lt4b<'a, 'b>(_foo: &'a Foo<'b>) -> &'b str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn struct_with_lt4b<'a, 'b>(_foo: &'a Foo<'b>) -> &'b str {\n+LL + fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:228:1\n+  --> $DIR/needless_lifetimes.rs:230:1\n    |\n LL | fn trait_obj_elided2<'a>(_arg: &'a dyn Drop) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn trait_obj_elided2<'a>(_arg: &'a dyn Drop) -> &'a str {\n+LL + fn trait_obj_elided2(_arg: &dyn Drop) -> &str {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:234:1\n+  --> $DIR/needless_lifetimes.rs:236:1\n    |\n LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:234:37\n+help: elide the lifetimes\n+   |\n+LL - fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n+LL + fn alias_with_lt(_foo: FooAlias<'_>) -> &str {\n    |\n-LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n-   |                                     ^^\n \n error: the following explicit lifetimes could be elided: 'b\n-  --> $DIR/needless_lifetimes.rs:252:1\n+  --> $DIR/needless_lifetimes.rs:254:1\n    |\n LL | fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:252:47\n+help: elide the lifetimes\n+   |\n+LL - fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n+LL + fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str {\n    |\n-LL | fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n-   |                                               ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:260:1\n+  --> $DIR/needless_lifetimes.rs:262:1\n    |\n LL | fn alias_with_lt4b<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'b str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn alias_with_lt4b<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'b str {\n+LL + fn alias_with_lt4b<'b>(_foo: &FooAlias<'b>) -> &'b str {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:264:1\n+  --> $DIR/needless_lifetimes.rs:266:1\n    |\n LL | fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n+LL + fn named_input_elided_output(_arg: &str) -> &str {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:272:1\n+  --> $DIR/needless_lifetimes.rs:274:1\n    |\n LL | fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n+LL + fn trait_bound_ok<T: WithLifetime<'static>>(_: &u8, _: T) {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:308:1\n+  --> $DIR/needless_lifetimes.rs:310:1\n    |\n LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:308:47\n+help: elide the lifetimes\n+   |\n+LL - fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n+LL + fn out_return_type_lts(e: &str) -> Cow<'_> {\n    |\n-LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n-   |                                               ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:315:9\n+  --> $DIR/needless_lifetimes.rs:317:9\n    |\n LL |         fn needless_lt<'a>(x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn needless_lt<'a>(x: &'a u8) {}\n+LL +         fn needless_lt(x: &u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:319:9\n+  --> $DIR/needless_lifetimes.rs:321:9\n    |\n LL |         fn needless_lt<'a>(_x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn needless_lt<'a>(_x: &'a u8) {}\n+LL +         fn needless_lt(_x: &u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:332:9\n+  --> $DIR/needless_lifetimes.rs:334:9\n    |\n LL |         fn baz<'a>(&'a self) -> impl Foo + 'a {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn baz<'a>(&'a self) -> impl Foo + 'a {\n+LL +         fn baz(&self) -> impl Foo + '_ {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:364:5\n+  --> $DIR/needless_lifetimes.rs:366:5\n    |\n LL |     fn impl_trait_elidable_nested_anonymous_lifetimes<'a>(i: &'a i32, f: impl Fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn impl_trait_elidable_nested_anonymous_lifetimes<'a>(i: &'a i32, f: impl Fn(&i32) -> &i32) -> &'a i32 {\n+LL +     fn impl_trait_elidable_nested_anonymous_lifetimes(i: &i32, f: impl Fn(&i32) -> &i32) -> &i32 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:373:5\n+  --> $DIR/needless_lifetimes.rs:375:5\n    |\n LL |     fn generics_elidable<'a, T: Fn(&i32) -> &i32>(i: &'a i32, f: T) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn generics_elidable<'a, T: Fn(&i32) -> &i32>(i: &'a i32, f: T) -> &'a i32 {\n+LL +     fn generics_elidable<T: Fn(&i32) -> &i32>(i: &i32, f: T) -> &i32 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:385:5\n+  --> $DIR/needless_lifetimes.rs:387:5\n    |\n LL |     fn where_clause_elidadable<'a, T>(i: &'a i32, f: T) -> &'a i32\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn where_clause_elidadable<'a, T>(i: &'a i32, f: T) -> &'a i32\n+LL +     fn where_clause_elidadable<T>(i: &i32, f: T) -> &i32\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:400:5\n+  --> $DIR/needless_lifetimes.rs:402:5\n    |\n LL |     fn pointer_fn_elidable<'a>(i: &'a i32, f: fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn pointer_fn_elidable<'a>(i: &'a i32, f: fn(&i32) -> &i32) -> &'a i32 {\n+LL +     fn pointer_fn_elidable(i: &i32, f: fn(&i32) -> &i32) -> &i32 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:413:5\n+  --> $DIR/needless_lifetimes.rs:415:5\n    |\n LL |     fn nested_fn_pointer_3<'a>(_: &'a i32) -> fn(fn(&i32) -> &i32) -> i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn nested_fn_pointer_3<'a>(_: &'a i32) -> fn(fn(&i32) -> &i32) -> i32 {\n+LL +     fn nested_fn_pointer_3(_: &i32) -> fn(fn(&i32) -> &i32) -> i32 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:416:5\n+  --> $DIR/needless_lifetimes.rs:418:5\n    |\n LL |     fn nested_fn_pointer_4<'a>(_: &'a i32) -> impl Fn(fn(&i32)) {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn nested_fn_pointer_4<'a>(_: &'a i32) -> impl Fn(fn(&i32)) {\n+LL +     fn nested_fn_pointer_4(_: &i32) -> impl Fn(fn(&i32)) {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:438:9\n+  --> $DIR/needless_lifetimes.rs:440:9\n    |\n LL |         fn implicit<'a>(&'a self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn implicit<'a>(&'a self) -> &'a () {\n+LL +         fn implicit(&self) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:441:9\n+  --> $DIR/needless_lifetimes.rs:443:9\n    |\n LL |         fn implicit_mut<'a>(&'a mut self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn implicit_mut<'a>(&'a mut self) -> &'a () {\n+LL +         fn implicit_mut(&mut self) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:452:9\n+  --> $DIR/needless_lifetimes.rs:454:9\n    |\n LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n+LL +         fn lifetime_elsewhere(self: Box<Self>, here: &()) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:458:9\n+  --> $DIR/needless_lifetimes.rs:460:9\n    |\n LL |         fn implicit<'a>(&'a self) -> &'a ();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn implicit<'a>(&'a self) -> &'a ();\n+LL +         fn implicit(&self) -> &();\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:459:9\n+  --> $DIR/needless_lifetimes.rs:461:9\n    |\n LL |         fn implicit_provided<'a>(&'a self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn implicit_provided<'a>(&'a self) -> &'a () {\n+LL +         fn implicit_provided(&self) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:468:9\n+  --> $DIR/needless_lifetimes.rs:470:9\n    |\n LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a ();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a ();\n+LL +         fn lifetime_elsewhere(self: Box<Self>, here: &()) -> &();\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:469:9\n+  --> $DIR/needless_lifetimes.rs:471:9\n    |\n LL |         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n+LL +         fn lifetime_elsewhere_provided(self: Box<Self>, here: &()) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:478:5\n+  --> $DIR/needless_lifetimes.rs:480:5\n    |\n LL |     fn foo<'a>(x: &'a u8, y: &'_ u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn foo<'a>(x: &'a u8, y: &'_ u8) {}\n+LL +     fn foo(x: &u8, y: &'_ u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:480:5\n+  --> $DIR/needless_lifetimes.rs:482:5\n    |\n LL |     fn bar<'a>(x: &'a u8, y: &'_ u8, z: &'_ u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn bar<'a>(x: &'a u8, y: &'_ u8, z: &'_ u8) {}\n+LL +     fn bar(x: &u8, y: &'_ u8, z: &'_ u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:487:5\n+  --> $DIR/needless_lifetimes.rs:489:5\n    |\n LL |     fn one_input<'a>(x: &'a u8) -> &'a u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn one_input<'a>(x: &'a u8) -> &'a u8 {\n+LL +     fn one_input(x: &u8) -> &u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:492:5\n+  --> $DIR/needless_lifetimes.rs:494:5\n    |\n LL |     fn multiple_inputs_output_not_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn multiple_inputs_output_not_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n+LL +     fn multiple_inputs_output_not_elided<'b>(x: &u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:505:13\n+  --> $DIR/needless_lifetimes.rs:507:13\n    |\n LL |             fn one_input<'a>(x: &'a u8) -> &'a u8 {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -322,6 +549,11 @@ LL |     local_one_input_macro!();\n    |     ------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `local_one_input_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: elide the lifetimes\n+   |\n+LL -             fn one_input<'a>(x: &'a u8) -> &'a u8 {\n+LL +             fn one_input(x: &u8) -> &u8 {\n+   |\n \n error: aborting due to 46 previous errors\n "}]}