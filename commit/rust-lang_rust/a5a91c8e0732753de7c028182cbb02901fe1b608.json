{"sha": "a5a91c8e0732753de7c028182cbb02901fe1b608", "node_id": "C_kwDOAAsO6NoAKGE1YTkxYzhlMDczMjc1M2RlN2MwMjgxODJjYmIwMjkwMWZlMWI2MDg", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2021-12-19T01:02:03Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2021-12-19T01:02:03Z"}, "message": "Derive src pointers in sort drop guards from &T\n\nThe src pointers in CopyOnDrop and InsertionHole used to be *mut T, and\nwere derived via automatic conversion from &mut T. According to Stacked\nBorrows 2.1, this means that those pointers become invalidated by\ninterior mutation in the comparison function.\n\nBut there's no need for mutability in this code path. Thus, we can\nchange the drop guards to use *const and derive those from &T.", "tree": {"sha": "557a6e8f8733687f53f3981841e2ada13156de81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/557a6e8f8733687f53f3981841e2ada13156de81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5a91c8e0732753de7c028182cbb02901fe1b608", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5a91c8e0732753de7c028182cbb02901fe1b608", "html_url": "https://github.com/rust-lang/rust/commit/a5a91c8e0732753de7c028182cbb02901fe1b608", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5a91c8e0732753de7c028182cbb02901fe1b608/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daf2204aa4954a9426cee93eb1baa2b26eb69070", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf2204aa4954a9426cee93eb1baa2b26eb69070", "html_url": "https://github.com/rust-lang/rust/commit/daf2204aa4954a9426cee93eb1baa2b26eb69070"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "8853577371ad6d7dd62e1d65bba4c851eea5bbc6", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5a91c8e0732753de7c028182cbb02901fe1b608/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5a91c8e0732753de7c028182cbb02901fe1b608/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=a5a91c8e0732753de7c028182cbb02901fe1b608", "patch": "@@ -892,7 +892,7 @@ where\n             //    performance than with the 2nd method.\n             //\n             // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n-            let mut tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n+            let tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n \n             // Intermediate state of the insertion process is always tracked by `hole`, which\n             // serves two purposes:\n@@ -904,7 +904,7 @@ where\n             // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n-            let mut hole = InsertionHole { src: &mut *tmp, dest: &mut v[1] };\n+            let mut hole = InsertionHole { src: &*tmp, dest: &mut v[1] };\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n@@ -920,7 +920,7 @@ where\n \n     // When dropped, copies from `src` into `dest`.\n     struct InsertionHole<T> {\n-        src: *mut T,\n+        src: *const T,\n         dest: *mut T,\n     }\n "}, {"sha": "8f58e8897b34bc493ce01a38fbda4d0ad838d0e5", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a5a91c8e0732753de7c028182cbb02901fe1b608/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5a91c8e0732753de7c028182cbb02901fe1b608/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=a5a91c8e0732753de7c028182cbb02901fe1b608", "patch": "@@ -12,7 +12,7 @@ use crate::ptr;\n \n /// When dropped, copies from `src` into `dest`.\n struct CopyOnDrop<T> {\n-    src: *mut T,\n+    src: *const T,\n     dest: *mut T,\n }\n \n@@ -54,9 +54,9 @@ where\n             // Read the first element into a stack-allocated variable. If a following comparison\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n-            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n+            let tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n             let v = v.as_mut_ptr();\n-            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.add(1) };\n+            let mut hole = CopyOnDrop { src: &*tmp, dest: v.add(1) };\n             ptr::copy_nonoverlapping(v.add(1), v.add(0), 1);\n \n             for i in 2..len {\n@@ -100,9 +100,9 @@ where\n             // Read the last element into a stack-allocated variable. If a following comparison\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n-            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n+            let tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n             let v = v.as_mut_ptr();\n-            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.add(len - 2) };\n+            let mut hole = CopyOnDrop { src: &*tmp, dest: v.add(len - 2) };\n             ptr::copy_nonoverlapping(v.add(len - 2), v.add(len - 1), 1);\n \n             for i in (0..len - 2).rev() {\n@@ -498,8 +498,8 @@ where\n         // operation panics, the pivot will be automatically written back into the slice.\n \n         // SAFETY: `pivot` is a reference to the first element of `v`, so `ptr::read` is safe.\n-        let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-        let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n+        let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n+        let _pivot_guard = CopyOnDrop { src: &*tmp, dest: pivot };\n         let pivot = &*tmp;\n \n         // Find the first pair of out-of-order elements.\n@@ -551,8 +551,8 @@ where\n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n     // SAFETY: The pointer here is valid because it is obtained from a reference to a slice.\n-    let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-    let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n+    let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n+    let _pivot_guard = CopyOnDrop { src: &*tmp, dest: pivot };\n     let pivot = &*tmp;\n \n     // Now partition the slice."}]}