{"sha": "5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "node_id": "C_kwDOAAsO6NoAKDVlNmVkMTMyZmE4YTFiZDFlYzZiMzY1ZTYxZTllMjkwNTI4YzkwZjU", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-10-10T18:50:49Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2023-04-06T08:34:16Z"}, "message": "Add `UnwindAction::Unreachable`\n\nThis also makes eval machine's `StackPopUnwind`\nredundant so that is replaced.", "tree": {"sha": "1e0d532ba1afa977d46dcd187a260d499d6467b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e0d532ba1afa977d46dcd187a260d499d6467b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "html_url": "https://github.com/rust-lang/rust/commit/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daeb844e0ccddb9e058128974b290f2022e88be7", "url": "https://api.github.com/repos/rust-lang/rust/commits/daeb844e0ccddb9e058128974b290f2022e88be7", "html_url": "https://github.com/rust-lang/rust/commit/daeb844e0ccddb9e058128974b290f2022e88be7"}], "stats": {"total": 311, "additions": 161, "deletions": 150}, "files": [{"sha": "15d748a9e75324284e3cf7369cc285884731138b", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -1612,47 +1612,27 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             TerminatorKind::Drop { target, unwind, .. }\n             | TerminatorKind::Assert { target, unwind, .. } => {\n                 self.assert_iscleanup(body, block_data, target, is_cleanup);\n-                if let UnwindAction::Cleanup(unwind) = unwind {\n-                    if is_cleanup {\n-                        span_mirbug!(self, block_data, \"unwind on cleanup block\")\n-                    }\n-                    self.assert_iscleanup(body, block_data, unwind, true);\n-                }\n+                self.assert_iscleanup_unwind(body, block_data, unwind, is_cleanup);\n             }\n             TerminatorKind::Call { ref target, unwind, .. } => {\n                 if let &Some(target) = target {\n                     self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 }\n-                if let UnwindAction::Cleanup(cleanup) = unwind {\n-                    if is_cleanup {\n-                        span_mirbug!(self, block_data, \"cleanup on cleanup block\")\n-                    }\n-                    self.assert_iscleanup(body, block_data, cleanup, true);\n-                }\n+                self.assert_iscleanup_unwind(body, block_data, unwind, is_cleanup);\n             }\n             TerminatorKind::FalseEdge { real_target, imaginary_target } => {\n                 self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n                 self.assert_iscleanup(body, block_data, imaginary_target, is_cleanup);\n             }\n             TerminatorKind::FalseUnwind { real_target, unwind } => {\n                 self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n-                if let UnwindAction::Cleanup(unwind) = unwind {\n-                    if is_cleanup {\n-                        span_mirbug!(self, block_data, \"cleanup in cleanup block via false unwind\");\n-                    }\n-                    self.assert_iscleanup(body, block_data, unwind, true);\n-                }\n+                self.assert_iscleanup_unwind(body, block_data, unwind, is_cleanup);\n             }\n             TerminatorKind::InlineAsm { destination, unwind, .. } => {\n                 if let Some(target) = destination {\n                     self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 }\n-                if let UnwindAction::Cleanup(cleanup) = unwind {\n-                    if is_cleanup {\n-                        span_mirbug!(self, block_data, \"cleanup on cleanup block\")\n-                    }\n-                    self.assert_iscleanup(body, block_data, cleanup, true);\n-                }\n+                self.assert_iscleanup_unwind(body, block_data, unwind, is_cleanup);\n             }\n         }\n     }\n@@ -1669,6 +1649,25 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    fn assert_iscleanup_unwind(\n+        &mut self,\n+        body: &Body<'tcx>,\n+        ctxt: &dyn fmt::Debug,\n+        unwind: UnwindAction,\n+        is_cleanup: bool,\n+    ) {\n+        match unwind {\n+            UnwindAction::Cleanup(unwind) => {\n+                if is_cleanup {\n+                    span_mirbug!(self, ctxt, \"unwind on cleanup block\")\n+                }\n+                self.assert_iscleanup(body, ctxt, unwind, true);\n+            }\n+            UnwindAction::Continue => (),\n+            UnwindAction::Unreachable => (),\n+        }\n+    }\n+\n     fn check_local(&mut self, body: &Body<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n         match body.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {"}, {"sha": "66bec6f30deadb7fc0d43bf2a45d52eda1ea486e", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -156,35 +156,36 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         fn_ptr: Bx::Value,\n         llargs: &[Bx::Value],\n         destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n-        unwind: mir::UnwindAction,\n+        mut unwind: mir::UnwindAction,\n         copied_constant_arguments: &[PlaceRef<'tcx, <Bx as BackendTypes>::Value>],\n         mergeable_succ: bool,\n     ) -> MergingSucc {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n-        let cleanup = match unwind {\n-            mir::UnwindAction::Cleanup(cleanup) => Some(cleanup),\n+        if !fn_abi.can_unwind {\n+            unwind = mir::UnwindAction::Unreachable;\n+        }\n+\n+        let unwind_block = match unwind {\n+            mir::UnwindAction::Cleanup(cleanup) => Some(self.llbb_with_cleanup(fx, cleanup)),\n+            _ if fx.mir[self.bb].is_cleanup\n+                && fn_abi.can_unwind\n+                && !base::wants_msvc_seh(fx.cx.tcx().sess) =>\n+            {\n+                // Exception must not propagate out of the execution of a cleanup (doing so\n+                // can cause undefined behaviour). We insert a double unwind guard for\n+                // functions that can potentially unwind to protect against this.\n+                //\n+                // This is not necessary for SEH which does not use successive unwinding\n+                // like Itanium EH. EH frames in SEH are different from normal function\n+                // frames and SEH will abort automatically if an exception tries to\n+                // propagate out from cleanup.\n+                Some(fx.double_unwind_guard())\n+            }\n             mir::UnwindAction::Continue => None,\n-        };\n-        let unwind_block = if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n-            Some(self.llbb_with_cleanup(fx, cleanup))\n-        } else if fx.mir[self.bb].is_cleanup\n-            && fn_abi.can_unwind\n-            && !base::wants_msvc_seh(fx.cx.tcx().sess)\n-        {\n-            // Exception must not propagate out of the execution of a cleanup (doing so\n-            // can cause undefined behaviour). We insert a double unwind guard for\n-            // functions that can potentially unwind to protect against this.\n-            //\n-            // This is not necessary for SEH which does not use successive unwinding\n-            // like Itanium EH. EH frames in SEH are different from normal function\n-            // frames and SEH will abort automatically if an exception tries to\n-            // propagate out from cleanup.\n-            Some(fx.double_unwind_guard())\n-        } else {\n-            None\n+            mir::UnwindAction::Unreachable => None,\n         };\n \n         if let Some(unwind_block) = unwind_block {\n@@ -640,7 +641,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (fn_abi, llfn) = common::build_langcall(bx, Some(span), LangItem::PanicCannotUnwind);\n \n         // Codegen the actual panic invoke/call.\n-        let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &[], None, mir::UnwindAction::Continue, &[], false);\n+        let merging_succ = helper.do_call(\n+            self,\n+            bx,\n+            fn_abi,\n+            llfn,\n+            &[],\n+            None,\n+            mir::UnwindAction::Unreachable,\n+            &[],\n+            false,\n+        );\n         assert_eq!(merging_succ, MergingSucc::False);\n     }\n "}, {"sha": "a5dfd1072f0aaf0e0b489d7741d637adceae7633", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -23,7 +23,7 @@ use rustc_target::spec::abi::Abi as CallAbi;\n \n use crate::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, FnVal, Frame, ImmTy, InterpCx,\n-    InterpResult, OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n+    InterpResult, OpTy, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n@@ -271,7 +271,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n                         /* with_caller_location = */ false,\n                         dest,\n                         ret,\n-                        StackPopUnwind::NotAllowed,\n+                        mir::UnwindAction::Unreachable,\n                     )?;\n                     Ok(ControlFlow::Break(()))\n                 } else {\n@@ -401,7 +401,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         args: &[OpTy<'tcx>],\n         dest: &PlaceTy<'tcx>,\n         ret: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind, // unwinding is not supported in consts\n+        _unwind: mir::UnwindAction, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n \n@@ -450,7 +450,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         args: &[OpTy<'tcx>],\n         dest: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         // Shared intrinsics.\n         if ecx.emulate_intrinsic(instance, args, dest, target)? {"}, {"sha": "94f3563cf762072c63aa457de74a7a55d944d542", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -139,25 +139,14 @@ pub struct FrameInfo<'tcx> {\n     pub lint_root: Option<hir::HirId>,\n }\n \n-/// Unwind information.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n-pub enum StackPopUnwind {\n-    /// The cleanup block.\n-    Cleanup(mir::BasicBlock),\n-    /// No cleanup needs to be done.\n-    Skip,\n-    /// Unwinding is not allowed (UB).\n-    NotAllowed,\n-}\n-\n #[derive(Clone, Copy, Eq, PartialEq, Debug)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n     /// we can validate it at that layout.\n     /// `ret` stores the block we jump to on a normal return, while `unwind`\n     /// stores the block used for cleanup during unwinding.\n-    Goto { ret: Option<mir::BasicBlock>, unwind: StackPopUnwind },\n+    Goto { ret: Option<mir::BasicBlock>, unwind: mir::UnwindAction },\n     /// The root frame of the stack: nowhere else to jump to.\n     /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n@@ -735,16 +724,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// *Unwind* to the given `target` basic block.\n     /// Do *not* use for returning! Use `return_to_block` instead.\n     ///\n-    /// If `target` is `StackPopUnwind::Skip`, that indicates the function does not need cleanup\n+    /// If `target` is `UnwindAction::Continue`, that indicates the function does not need cleanup\n     /// during unwinding, and we will just keep propagating that upwards.\n     ///\n-    /// If `target` is `StackPopUnwind::NotAllowed`, that indicates the function does not allow\n+    /// If `target` is `UnwindAction::Unreachable`, that indicates the function does not allow\n     /// unwinding, and doing so is UB.\n-    pub fn unwind_to_block(&mut self, target: StackPopUnwind) -> InterpResult<'tcx> {\n+    pub fn unwind_to_block(&mut self, target: mir::UnwindAction) -> InterpResult<'tcx> {\n         self.frame_mut().loc = match target {\n-            StackPopUnwind::Cleanup(block) => Left(mir::Location { block, statement_index: 0 }),\n-            StackPopUnwind::Skip => Right(self.frame_mut().body.span),\n-            StackPopUnwind::NotAllowed => {\n+            mir::UnwindAction::Cleanup(block) => Left(mir::Location { block, statement_index: 0 }),\n+            mir::UnwindAction::Continue => Right(self.frame_mut().body.span),\n+            mir::UnwindAction::Unreachable => {\n                 throw_ub_format!(\"unwinding past a stack frame that does not allow unwinding\")\n             }\n         };"}, {"sha": "dda4f6e00f385879ca2b0cd5c01371f57ca13b2e", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -18,7 +18,7 @@ use crate::const_eval::CheckAlignment;\n \n use super::{\n     AllocBytes, AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx,\n-    InterpResult, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n+    InterpResult, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -185,7 +185,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::Provenance>],\n         destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>>;\n \n     /// Execute `fn_val`. It is the hook's responsibility to advance the instruction\n@@ -197,7 +197,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::Provenance>],\n         destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx>;\n \n     /// Directly process an intrinsic without pushing a stack frame. It is the hook's\n@@ -208,7 +208,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::Provenance>],\n         destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx>;\n \n     /// Called to evaluate `Assert` MIR terminators that trigger a panic.\n@@ -487,7 +487,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         _args: &[OpTy<$tcx>],\n         _destination: &PlaceTy<$tcx, Self::Provenance>,\n         _target: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: mir::UnwindAction,\n     ) -> InterpResult<$tcx> {\n         match fn_val {}\n     }"}, {"sha": "898d62361ab2aae810f18693c90ae85fb7bebd84", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -20,9 +20,7 @@ mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n-pub use self::eval_context::{\n-    Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup, StackPopUnwind,\n-};\n+pub use self::eval_context::{Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n pub use self::memory::{AllocKind, AllocRef, AllocRefMut, FnVal, Memory, MemoryKind};"}, {"sha": "c8be2603ae9a1c7f05499134ec7e6fbd6f64f97c", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -13,7 +13,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     FnVal, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine, MemoryKind, OpTy, Operand,\n-    PlaceTy, Scalar, StackPopCleanup, StackPopUnwind,\n+    PlaceTy, Scalar, StackPopCleanup,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -60,7 +60,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ref args,\n                 destination,\n                 target,\n-                ref unwind,\n+                unwind,\n                 from_hir_call: _,\n                 fn_span: _,\n             } => {\n@@ -106,13 +106,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     with_caller_location,\n                     &destination,\n                     target,\n-                    match (unwind, fn_abi.can_unwind) {\n-                        (mir::UnwindAction::Cleanup(cleanup), true) => {\n-                            StackPopUnwind::Cleanup(*cleanup)\n-                        }\n-                        (mir::UnwindAction::Continue, true) => StackPopUnwind::Skip,\n-                        (_, false) => StackPopUnwind::NotAllowed,\n-                    },\n+                    if fn_abi.can_unwind { unwind } else { mir::UnwindAction::Unreachable },\n                 )?;\n                 // Sanity-check that `eval_fn_call` either pushed a new frame or\n                 // did a jump to another block.\n@@ -353,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         with_caller_location: bool,\n         destination: &PlaceTy<'tcx, M::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        mut unwind: StackPopUnwind,\n+        mut unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n \n@@ -412,9 +406,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n \n-                if !matches!(unwind, StackPopUnwind::NotAllowed) && !callee_fn_abi.can_unwind {\n-                    // The callee cannot unwind.\n-                    unwind = StackPopUnwind::NotAllowed;\n+                if !callee_fn_abi.can_unwind {\n+                    // The callee cannot unwind, so force the `Unreachable` unwind handling.\n+                    unwind = mir::UnwindAction::Unreachable;\n                 }\n \n                 self.push_stack_frame(\n@@ -719,10 +713,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             false,\n             &ret.into(),\n             Some(target),\n-            match unwind {\n-                mir::UnwindAction::Cleanup(cleanup) => StackPopUnwind::Cleanup(cleanup),\n-                mir::UnwindAction::Continue => StackPopUnwind::Skip,\n-            },\n+            unwind,\n         )\n     }\n }"}, {"sha": "0f533dbb59463b6dec6c0c5294688dee48dc8e41", "filename": "compiler/rustc_middle/src/mir/patch.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -12,6 +12,8 @@ pub struct MirPatch<'tcx> {\n     new_statements: Vec<(Location, StatementKind<'tcx>)>,\n     new_locals: Vec<LocalDecl<'tcx>>,\n     resume_block: Option<BasicBlock>,\n+    // Only for unreachable in cleanup path.\n+    unreachable_block: Option<BasicBlock>,\n     body_span: Span,\n     next_local: usize,\n }\n@@ -25,11 +27,12 @@ impl<'tcx> MirPatch<'tcx> {\n             new_locals: vec![],\n             next_local: body.local_decls.len(),\n             resume_block: None,\n+            unreachable_block: None,\n             body_span: body.span,\n         };\n \n-        // Check if we already have a resume block\n         for (bb, block) in body.basic_blocks.iter_enumerated() {\n+            // Check if we already have a resume block\n             if let TerminatorKind::Resume = block.terminator().kind && block.statements.is_empty() {\n                 result.resume_block = Some(bb);\n                 break;"}, {"sha": "f7f2fc59ca520278130fde7cf277b3de4b76f043", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -753,12 +753,17 @@ pub enum TerminatorKind<'tcx> {\n }\n \n /// Action to be taken when a stack unwind happens.\n-#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub enum UnwindAction {\n-    // No action is to be taken. Continue unwinding.\n+    /// No action is to be taken. Continue unwinding.\n+    ///\n+    /// This is similar to `Cleanup(bb)` where `bb` does nothing but `Resume`, but they are not\n+    /// equivalent, as presence of `Cleanup(_)` will make a frame non-POF.\n     Continue,\n-    // Cleanups to be done.\n+    /// Triggers undefined behavior if unwind happens.\n+    Unreachable,\n+    /// Cleanups to be done.\n     Cleanup(BasicBlock),\n }\n "}, {"sha": "1ef2a197d86e57c7110f8473e9fd905f13297559", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -270,11 +270,16 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n         let labels = self.fmt_successor_labels();\n         assert_eq!(successor_count, labels.len());\n \n-        match successor_count {\n-            0 => Ok(()),\n-\n-            1 => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n-\n+        let unwind = match self.unwind() {\n+            // Not needed or included in successors\n+            None | Some(UnwindAction::Continue) | Some(UnwindAction::Cleanup(_)) => None,\n+            Some(UnwindAction::Unreachable) => Some(\"unwind unreachable\"),\n+        };\n+\n+        match (successor_count, unwind) {\n+            (0, None) => Ok(()),\n+            (0, Some(unwind)) => write!(fmt, \" -> {}\", unwind),\n+            (1, None) => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n             _ => {\n                 write!(fmt, \" -> [\")?;\n                 for (i, target) in self.successors().enumerate() {\n@@ -283,6 +288,9 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n                     }\n                     write!(fmt, \"{}: {:?}\", labels[i], target)?;\n                 }\n+                if let Some(unwind) = unwind {\n+                    write!(fmt, \", {unwind}\")?;\n+                }\n                 write!(fmt, \"]\")\n             }\n         }\n@@ -391,30 +399,32 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Call { target: Some(_), unwind: UnwindAction::Cleanup(_), .. } => {\n                 vec![\"return\".into(), \"unwind\".into()]\n             }\n-            Call { target: Some(_), unwind: UnwindAction::Continue, .. } => vec![\"return\".into()],\n+            Call { target: Some(_), unwind: _, .. } => vec![\"return\".into()],\n             Call { target: None, unwind: UnwindAction::Cleanup(_), .. } => vec![\"unwind\".into()],\n-            Call { target: None, unwind: UnwindAction::Continue, .. } => vec![],\n+            Call { target: None, unwind: _, .. } => vec![],\n             Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n             Yield { drop: None, .. } => vec![\"resume\".into()],\n-            Drop { unwind: UnwindAction::Continue, .. } => vec![\"return\".into()],\n             Drop { unwind: UnwindAction::Cleanup(_), .. } => vec![\"return\".into(), \"unwind\".into()],\n-            Assert { unwind: UnwindAction::Continue, .. } => vec![\"\".into()],\n-            Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n+            Drop { unwind: _, .. } => vec![\"return\".into()],\n+            Assert { unwind: UnwindAction::Cleanup(_), .. } => {\n+                vec![\"success\".into(), \"unwind\".into()]\n+            }\n+            Assert { unwind: _, .. } => vec![\"success\".into()],\n             FalseEdge { .. } => vec![\"real\".into(), \"imaginary\".into()],\n             FalseUnwind { unwind: UnwindAction::Cleanup(_), .. } => {\n-                vec![\"real\".into(), \"cleanup\".into()]\n+                vec![\"real\".into(), \"unwind\".into()]\n             }\n-            FalseUnwind { unwind: UnwindAction::Continue, .. } => vec![\"real\".into()],\n+            FalseUnwind { unwind: _, .. } => vec![\"real\".into()],\n             InlineAsm { destination: Some(_), unwind: UnwindAction::Cleanup(_), .. } => {\n                 vec![\"return\".into(), \"unwind\".into()]\n             }\n-            InlineAsm { destination: Some(_), unwind: UnwindAction::Continue, .. } => {\n+            InlineAsm { destination: Some(_), unwind: _, .. } => {\n                 vec![\"return\".into()]\n             }\n             InlineAsm { destination: None, unwind: UnwindAction::Cleanup(_), .. } => {\n                 vec![\"unwind\".into()]\n             }\n-            InlineAsm { destination: None, unwind: UnwindAction::Continue, .. } => vec![],\n+            InlineAsm { destination: None, unwind: _, .. } => vec![],\n         }\n     }\n }"}, {"sha": "f48016450604d253e2960b33423243f681f843be", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -946,7 +946,7 @@ where\n             args,\n             destination: unit_temp,\n             target: Some(target),\n-            unwind: UnwindAction::Continue,\n+            unwind: UnwindAction::Unreachable,\n             from_hir_call: false,\n             fn_span: self.source_info.span,\n         }; // FIXME(#43234)"}, {"sha": "513499927b32b83bab9554b826b3afef93e0fa23", "filename": "compiler/rustc_mir_transform/src/abort_unwinding_calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n \n         for id in cleanups_to_remove {\n             let cleanup = body.basic_blocks_mut()[id].terminator_mut().unwind_mut().unwrap();\n-            *cleanup = UnwindAction::Continue;\n+            *cleanup = UnwindAction::Unreachable;\n         }\n \n         // We may have invalidated some `cleanup` blocks so clean those up now."}, {"sha": "92c07ef5193aad207e6806c9b7573342216bf13f", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -24,7 +24,7 @@ use crate::MirPass;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n     ImmTy, Immediate, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer,\n-    Scalar, StackPopCleanup, StackPopUnwind,\n+    Scalar, StackPopCleanup,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -209,7 +209,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _args: &[OpTy<'tcx>],\n         _destination: &PlaceTy<'tcx>,\n         _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: UnwindAction,\n     ) -> InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n         Ok(None)\n     }\n@@ -220,7 +220,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _args: &[OpTy<'tcx>],\n         _destination: &PlaceTy<'tcx>,\n         _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: UnwindAction,\n     ) -> InterpResult<'tcx> {\n         throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n     }"}, {"sha": "7d4d33f74501d87523176dbf72b8e58832933f59", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -399,7 +399,6 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             let loc = Location { block: bb, statement_index: data.statements.len() };\n             let terminator = data.terminator();\n \n-            let resume_block = self.patch.resume_block();\n             match terminator.kind {\n                 TerminatorKind::Drop { mut place, target, unwind } => {\n                     if let Some(new_place) = self.un_derefer.derefer(place.as_ref(), self.body) {\n@@ -408,22 +407,29 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n                     self.init_data.seek_before(loc);\n                     match self.move_data().rev_lookup.find(place.as_ref()) {\n-                        LookupResult::Exact(path) => elaborate_drop(\n-                            &mut Elaborator { ctxt: self },\n-                            terminator.source_info,\n-                            place,\n-                            path,\n-                            target,\n-                            if data.is_cleanup {\n+                        LookupResult::Exact(path) => {\n+                            let unwind = if data.is_cleanup {\n                                 Unwind::InCleanup\n                             } else {\n                                 match unwind {\n                                     UnwindAction::Cleanup(cleanup) => Unwind::To(cleanup),\n-                                    UnwindAction::Continue => Unwind::To(resume_block),\n+                                    UnwindAction::Continue => Unwind::To(self.patch.resume_block()),\n+                                    UnwindAction::Unreachable => {\n+                                        Unwind::To(self.patch.unreachable_block())\n+                                    }\n+                                    UnwindAction::Terminate => Unwind::To(self.patch.terminate_block()),\n                                 }\n-                            },\n-                            bb,\n-                        ),\n+                            };\n+                            elaborate_drop(\n+                                &mut Elaborator { ctxt: self },\n+                                terminator.source_info,\n+                                place,\n+                                path,\n+                                target,\n+                                unwind,\n+                                bb,\n+                            )\n+                        }\n                         LookupResult::Parent(..) => {\n                             if !matches!(\n                                 terminator.source_info.span.desugaring_kind(),"}, {"sha": "8a4c3cc247a94895ef510aac93f0fd416719ef37", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -1063,6 +1063,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             Unwind::To(match *unwind {\n                 UnwindAction::Cleanup(tgt) => tgt,\n                 UnwindAction::Continue => elaborator.patch.resume_block(),\n+                UnwindAction::Unreachable => elaborator.patch.unreachable_block(),\n             })\n         };\n         elaborate_drop("}, {"sha": "a4a1acfe428888d1995f84c18a1cb97590b8938e", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -1020,11 +1020,12 @@ impl Integrator<'_, '_> {\n                 UnwindAction::Cleanup(_) => {\n                     bug!(\"cleanup on cleanup block\");\n                 }\n-                UnwindAction::Continue => return unwind,\n+                UnwindAction::Continue | UnwindAction::Unreachable => return unwind,\n             }\n         }\n \n         match unwind {\n+            UnwindAction::Unreachable => unwind,\n             UnwindAction::Cleanup(target) => UnwindAction::Cleanup(self.map_block(target)),\n             // Add an unwind edge to the original call's cleanup block\n             UnwindAction::Continue => self.cleanup_block,\n@@ -1140,6 +1141,9 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n                     terminator.kind = TerminatorKind::Goto { target: tgt };\n                 }\n                 UnwindAction::Continue => (),\n+                UnwindAction::Unreachable => {\n+                    terminator.kind = TerminatorKind::Unreachable;\n+                }\n             },\n             TerminatorKind::Abort => {}\n             TerminatorKind::Unreachable => {}"}, {"sha": "565fe4eb72042b57512555321cfd54c5a8bb6a19", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -54,7 +54,7 @@ fn lower_slice_len_call<'tcx>(\n             args,\n             destination,\n             target: Some(bb),\n-            unwind: UnwindAction::Continue,\n+            unwind: UnwindAction::Unreachable,\n             from_hir_call: true,\n             ..\n         } => {"}, {"sha": "8f6ae72949174de9fb7ec8f9f71635aa2d94e2d0", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -951,7 +951,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         if this.machine.panic_on_unsupported {\n             // message is slightly different here to make automated analysis easier\n             let error_msg = format!(\"unsupported Miri functionality: {}\", error_msg.as_ref());\n-            this.start_panic(error_msg.as_ref(), StackPopUnwind::Skip)?;\n+            this.start_panic(error_msg.as_ref(), mir::UnwindAction::Continue)?;\n             Ok(())\n         } else {\n             throw_unsup_format!(\"{}\", error_msg.as_ref());"}, {"sha": "477d8d33ebba7786a4662ec108be25f5bce853e7", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -834,7 +834,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         args: &[OpTy<'tcx, Provenance>],\n         dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         ecx.find_mir_or_eval_fn(instance, abi, args, dest, ret, unwind)\n     }\n@@ -847,7 +847,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         args: &[OpTy<'tcx, Provenance>],\n         dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         ecx.call_dlsym(fn_val, abi, args, dest, ret)\n     }\n@@ -859,7 +859,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         args: &[OpTy<'tcx, Provenance>],\n         dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         ecx.call_intrinsic(instance, args, dest, ret, unwind)\n     }"}, {"sha": "fcee381ff7132a4e405f70652ae693ac7600727b", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -258,7 +258,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         args: &[OpTy<'tcx, Provenance>],\n         dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         let this = self.eval_context_mut();\n         let link_name = this.item_link_name(def_id);"}, {"sha": "ca2c1652dc1993387eec11033cf975ac8c871178", "filename": "src/tools/miri/src/shims/intrinsics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -26,7 +26,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         args: &[OpTy<'tcx, Provenance>],\n         dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n "}, {"sha": "918efda3777fa0e5aa61faa5b6f7c90fa491deed", "filename": "src/tools/miri/src/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -34,7 +34,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         args: &[OpTy<'tcx, Provenance>],\n         dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         let this = self.eval_context_mut();\n         trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest);\n@@ -70,7 +70,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         align_op: &OpTy<'tcx, Provenance>,\n         dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n         let ret = ret.unwrap();"}, {"sha": "4f898e62773a1584cf48f25a705c24b1ad484d91", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "patch": "@@ -53,7 +53,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         abi: Abi,\n         link_name: Symbol,\n         args: &[OpTy<'tcx, Provenance>],\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -106,7 +106,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             &[data.into()],\n             None,\n             // Directly return to caller.\n-            StackPopCleanup::Goto { ret: Some(ret), unwind: StackPopUnwind::Skip },\n+            StackPopCleanup::Goto { ret: Some(ret), unwind: mir::UnwindAction::Continue },\n         )?;\n \n         // We ourselves will return `0`, eventually (will be overwritten if we catch a panic).\n@@ -157,7 +157,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 &[catch_unwind.data.into(), payload.into()],\n                 None,\n                 // Directly return to caller of `try`.\n-                StackPopCleanup::Goto { ret: Some(catch_unwind.ret), unwind: StackPopUnwind::Skip },\n+                StackPopCleanup::Goto { ret: Some(catch_unwind.ret), unwind: mir::UnwindAction::Continue },\n             )?;\n \n             // We pushed a new stack frame, the engine should not do any jumping now!\n@@ -168,7 +168,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     /// Start a panic in the interpreter with the given message as payload.\n-    fn start_panic(&mut self, msg: &str, unwind: StackPopUnwind) -> InterpResult<'tcx> {\n+    fn start_panic(&mut self, msg: &str, unwind: mir::UnwindAction) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         // First arg: message.\n@@ -213,10 +213,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     None,\n                     StackPopCleanup::Goto {\n                         ret: None,\n-                        unwind: match unwind {\n-                            Some(cleanup) => StackPopUnwind::Cleanup(cleanup),\n-                            None => StackPopUnwind::Skip,\n-                        },\n+                        unwind,\n                     },\n                 )?;\n             }\n@@ -252,10 +249,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Forward everything else to `panic` lang item.\n                 this.start_panic(\n                     msg.description(),\n-                    match unwind {\n-                        Some(cleanup) => StackPopUnwind::Cleanup(cleanup),\n-                        None => StackPopUnwind::Skip,\n-                    },\n+                    unwind,\n                 )?;\n             }\n         }"}]}