{"sha": "fa78d5bb87d136f793c56f9861957ce41080bd7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNzhkNWJiODdkMTM2Zjc5M2M1NmY5ODYxOTU3Y2U0MTA4MGJkN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-16T05:41:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-16T05:41:11Z"}, "message": "Auto merge of #41565 - rkruppe:llvm-sys, r=eddyb\n\nMake only rustc_trans depend on rustc_llvm\n\nWith these changes, only rustc_trans depends directly on rustc_llvm (and no crate gained a new dependency on trans). This means changing LLVM doesn't rebuild librustc or rustc_metadata, only rustc_trans, rustc_driver and the rustc executable\nAlso, rustc_driver technically doesn't know about LLVM any more (of course, it still handles a ton of options that conceptually refer to LLVM, but it delegates their implementation to trans).\n\nWhat I *didn't* implement was merging most or all of rustc_llvm into rustc_trans. I ran into a nasty bug, which was probably just a silly typo somewhere but I probably won't have the time to figure it out in the next week or two. I opened #41699 for that step.\n\nFixes #41473", "tree": {"sha": "1ca5ebfb27f1a50803b5961486d46e61304f19bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ca5ebfb27f1a50803b5961486d46e61304f19bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa78d5bb87d136f793c56f9861957ce41080bd7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa78d5bb87d136f793c56f9861957ce41080bd7e", "html_url": "https://github.com/rust-lang/rust/commit/fa78d5bb87d136f793c56f9861957ce41080bd7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa78d5bb87d136f793c56f9861957ce41080bd7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae33d99bcd1c1f99b4605d2bb1150c590ffa3044", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae33d99bcd1c1f99b4605d2bb1150c590ffa3044", "html_url": "https://github.com/rust-lang/rust/commit/ae33d99bcd1c1f99b4605d2bb1150c590ffa3044"}, {"sha": "04a16ff5acaaccf6332f706f090442f0ab9b0f95", "url": "https://api.github.com/repos/rust-lang/rust/commits/04a16ff5acaaccf6332f706f090442f0ab9b0f95", "html_url": "https://github.com/rust-lang/rust/commit/04a16ff5acaaccf6332f706f090442f0ab9b0f95"}], "stats": {"total": 752, "additions": 425, "deletions": 327}, "files": [{"sha": "6d7b13f66f7eaf3a9a6440c0f8c09a81e32c5282", "filename": "src/Cargo.lock", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -405,6 +405,14 @@ name = \"open\"\n version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"owning_ref\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"panic_abort\"\n version = \"0.0.0\"\n@@ -531,12 +539,12 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -646,7 +654,6 @@ dependencies = [\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_lint 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_passes 0.0.0\",\n@@ -720,13 +727,13 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n@@ -828,6 +835,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n@@ -923,6 +931,11 @@ dependencies = [\n name = \"serialize\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"stable_deref_trait\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"std\"\n version = \"0.0.0\"\n@@ -1167,6 +1180,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1cbfa3781f3fe73dc05321bed52a06d2d491eaa764c52335cf4399f046ece99\"\n \"checksum num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca313f1862c7ec3e0dfe8ace9fa91b1d9cb5c84ace3d00f5ec4216238e93c167\"\n \"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n+\"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n \"checksum pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9ab1e588ef8efd702c7ed9d2bd774db5e6f4d878bb5a1a9f371828fbdff6973\"\n \"checksum pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1058d7bb927ca067656537eec4e02c2b4b70eaaa129664c5b90c111e20326f41\"\n@@ -1180,6 +1194,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d931a44fdaa43b8637009e7632a02adc4f2b2e0733c08caa4cf00e8da4a117a7\"\n \"checksum serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a702319c807c016e51f672e5c77d6f0b46afddd744b5e437d6b8436b888b458f\"\n \"checksum serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbc45439552eb8fb86907a2c41c1fd0ef97458efb87ff7f878db466eb581824e\"\n+\"checksum stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15132e0e364248108c5e2c02e3ab539be8d6f5d52a01ca9bbf27ed657316f02b\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n \"checksum tar 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab0ef9ead2fe0aa9e18475a96a207bfd5143f4124779ef7429503a8665416ce8\"\n \"checksum term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07b6c1ac5b3fffd75073276bca1ceed01f67a28537097a2a9539e116e50fb21a\""}, {"sha": "9d64f511914d6d3c2ec5b16a95a28886a2f3c8ba", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -13,12 +13,12 @@ arena = { path = \"../libarena\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "f32ee7900646b0e4f1c82e9b415362e85dbc533d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -54,7 +54,7 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate rustc_llvm as llvm;\n+extern crate owning_ref;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate serialize;"}, {"sha": "a68aca4600054ac2ba3e9d87b7df727ad2d0f09b", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -36,8 +36,9 @@ use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n \n use std::any::Any;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n+use owning_ref::ErasedBoxRef;\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n@@ -201,11 +202,33 @@ impl EncodedMetadataHashes {\n     }\n }\n \n+/// The backend's way to give the crate store access to the metadata in a library.\n+/// Note that it returns the raw metadata bytes stored in the library file, whether\n+/// it is compressed, uncompressed, some weird mix, etc.\n+/// rmeta files are backend independent and not handled here.\n+///\n+/// At the time of this writing, there is only one backend and one way to store\n+/// metadata in library -- this trait just serves to decouple rustc_metadata from\n+/// the archive reader, which depends on LLVM.\n+pub trait MetadataLoader {\n+    fn get_rlib_metadata(&self,\n+                         target: &Target,\n+                         filename: &Path)\n+                         -> Result<ErasedBoxRef<[u8]>, String>;\n+    fn get_dylib_metadata(&self,\n+                          target: &Target,\n+                          filename: &Path)\n+                          -> Result<ErasedBoxRef<[u8]>, String>;\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n pub trait CrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n \n+    // access to the metadata loader\n+    fn metadata_loader(&self) -> &MetadataLoader;\n+\n     // item info\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n@@ -275,8 +298,6 @@ pub trait CrateStore {\n     fn used_link_args(&self) -> Vec<String>;\n \n     // utility functions\n-    fn metadata_filename(&self) -> &str;\n-    fn metadata_section_name(&self, target: &Target) -> &str;\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n@@ -413,8 +434,6 @@ impl CrateStore for DummyCrateStore {\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions\n-    fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n-    fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n@@ -427,6 +446,9 @@ impl CrateStore for DummyCrateStore {\n         bug!(\"encode_metadata\")\n     }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n+\n+    // access to the metadata loader\n+    fn metadata_loader(&self) -> &MetadataLoader { bug!(\"metadata_loader\") }\n }\n \n pub trait CrateLoader {"}, {"sha": "4212fa1f8b12e1488f94e2d34a312931f4a7118f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -328,7 +328,7 @@ top_level_options!(\n     }\n );\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PrintRequest {\n     FileNames,\n     Sysroot,"}, {"sha": "814246330a4c2f7b8da5e640ebbb536c83910423", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -37,19 +37,16 @@ use syntax_pos::{Span, MultiSpan, FileMap};\n use rustc_back::{LinkerFlavor, PanicStrategy};\n use rustc_back::target::Target;\n use rustc_data_structures::flock;\n-use llvm;\n \n use std::path::{Path, PathBuf};\n use std::cell::{self, Cell, RefCell};\n use std::collections::HashMap;\n use std::env;\n-use std::ffi::CString;\n use std::io::Write;\n use std::rc::Rc;\n use std::fmt;\n use std::time::Duration;\n use std::sync::Arc;\n-use libc::c_int;\n \n mod code_stats;\n pub mod config;\n@@ -713,8 +710,6 @@ pub fn build_session_(sopts: config::Options,\n         out_of_fuel: Cell::new(false),\n     };\n \n-    init_llvm(&sess);\n-\n     sess\n }\n \n@@ -743,55 +738,6 @@ pub enum IncrCompSession {\n     }\n }\n \n-fn init_llvm(sess: &Session) {\n-    unsafe {\n-        // Before we touch LLVM, make sure that multithreading is enabled.\n-        use std::sync::Once;\n-        static INIT: Once = Once::new();\n-        static mut POISONED: bool = false;\n-        INIT.call_once(|| {\n-            if llvm::LLVMStartMultithreaded() != 1 {\n-                // use an extra bool to make sure that all future usage of LLVM\n-                // cannot proceed despite the Once not running more than once.\n-                POISONED = true;\n-            }\n-\n-            configure_llvm(sess);\n-        });\n-\n-        if POISONED {\n-            bug!(\"couldn't enable multi-threaded LLVM\");\n-        }\n-    }\n-}\n-\n-unsafe fn configure_llvm(sess: &Session) {\n-    let mut llvm_c_strs = Vec::new();\n-    let mut llvm_args = Vec::new();\n-\n-    {\n-        let mut add = |arg: &str| {\n-            let s = CString::new(arg).unwrap();\n-            llvm_args.push(s.as_ptr());\n-            llvm_c_strs.push(s);\n-        };\n-        add(\"rustc\"); // fake program name\n-        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n-        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n-\n-        for arg in &sess.opts.cg.llvm_args {\n-            add(&(*arg));\n-        }\n-    }\n-\n-    llvm::LLVMInitializePasses();\n-\n-    llvm::initialize_available_targets();\n-\n-    llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n-                                 llvm_args.as_ptr());\n-}\n-\n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {"}, {"sha": "2e949f48c175ee7e44c9126d771043367b352e30", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -22,7 +22,6 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_lint = { path = \"../librustc_lint\" }\n-rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_passes = { path = \"../librustc_passes\" }"}, {"sha": "34f636d0b9a12db2225e9c212d5c390b3e9309fc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -56,7 +56,6 @@ extern crate rustc_save_analysis;\n extern crate rustc_trans;\n extern crate rustc_typeck;\n extern crate serialize;\n-extern crate rustc_llvm as llvm;\n #[macro_use]\n extern crate log;\n extern crate syntax;\n@@ -70,7 +69,7 @@ use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc_trans::back::link;\n-use rustc_trans::back::write::{create_target_machine, RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n+use rustc_trans::back::write::{RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n@@ -182,7 +181,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n-        unsafe { llvm::LLVMRustSetDebug(1); }\n+        rustc_trans::enable_llvm_debug();\n     }\n \n     let descriptions = diagnostics_registry();\n@@ -204,13 +203,14 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n     );\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n@@ -409,12 +409,13 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph));\n+                let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n                 let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,\n                     descriptions.clone(),\n                     cstore.clone());\n+                rustc_trans::init(&sess);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n                 target_features::add_configuration(&mut cfg, &sess);\n@@ -558,7 +559,11 @@ impl RustcDefaultCalls {\n                 &Input::File(ref ifile) => {\n                     let path = &(*ifile);\n                     let mut v = Vec::new();\n-                    locator::list_file_metadata(&sess.target.target, path, &mut v).unwrap();\n+                    locator::list_file_metadata(&sess.target.target,\n+                                                path,\n+                                                sess.cstore.metadata_loader(),\n+                                                &mut v)\n+                            .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());\n                 }\n                 &Input::Str { .. } => {\n@@ -665,14 +670,6 @@ impl RustcDefaultCalls {\n                         println!(\"{}\", cfg);\n                     }\n                 }\n-                PrintRequest::TargetCPUs => {\n-                    let tm = create_target_machine(sess);\n-                    unsafe { llvm::LLVMRustPrintTargetCPUs(tm); }\n-                }\n-                PrintRequest::TargetFeatures => {\n-                    let tm = create_target_machine(sess);\n-                    unsafe { llvm::LLVMRustPrintTargetFeatures(tm); }\n-                }\n                 PrintRequest::RelocationModels => {\n                     println!(\"Available relocation models:\");\n                     for &(name, _) in RELOC_MODEL_ARGS.iter() {\n@@ -687,6 +684,9 @@ impl RustcDefaultCalls {\n                     }\n                     println!(\"\");\n                 }\n+                PrintRequest::TargetCPUs | PrintRequest::TargetFeatures => {\n+                    rustc_trans::print(*req, sess);\n+                }\n             }\n         }\n         return Compilation::Stop;\n@@ -724,10 +724,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n-        unsafe {\n-            println!(\"LLVM version: {}.{}\",\n-                     llvm::LLVMRustVersionMajor(), llvm::LLVMRustVersionMinor());\n-        }\n+        rustc_trans::print_version();\n     }\n }\n \n@@ -1020,9 +1017,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n-        unsafe {\n-            ::llvm::LLVMRustPrintPasses();\n-        }\n+        rustc_trans::print_passes();\n         return None;\n     }\n "}, {"sha": "bee61bb398029756511fcc1a2300c1209b9ac618", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -9,46 +9,20 @@\n // except according to those terms.\n \n use syntax::ast;\n-use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n-use rustc_trans::back::write::create_target_machine;\n use syntax::symbol::Symbol;\n-use libc::c_char;\n-\n-// WARNING: the features must be known to LLVM or the feature\n-// detection code will walk past the end of the feature array,\n-// leading to crashes.\n-\n-const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n-\n-const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n-                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n-                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n-                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\"];\n-\n-const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+use rustc_trans;\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n ///\n /// This is performed by checking whether a whitelisted set of\n /// features is available on the target machine, by querying LLVM.\n pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n-    let target_machine = create_target_machine(sess);\n-\n-    let whitelist = match &*sess.target.target.arch {\n-        \"arm\" => ARM_WHITELIST,\n-        \"x86\" | \"x86_64\" => X86_WHITELIST,\n-        \"hexagon\" => HEXAGON_WHITELIST,\n-        _ => &[],\n-    };\n-\n     let tf = Symbol::intern(\"target_feature\");\n-    for feat in whitelist {\n-        assert_eq!(feat.chars().last(), Some('\\0'));\n-        if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.insert((tf, Some(Symbol::intern(&feat[..feat.len() - 1]))));\n-        }\n+\n+    for feat in rustc_trans::target_features(sess) {\n+        cfg.insert((tf, Some(feat)));\n     }\n \n     let requested_features = sess.opts.cg.target_feature.split(',');"}, {"sha": "1d236a96bf62ed97c313cfad34909734a9def2aa", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -14,6 +14,7 @@ use driver;\n use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n+use rustc_trans;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region::{CodeExtent, RegionMaps};\n@@ -104,13 +105,14 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let sess = session::build_session_(options,\n                                        &dep_graph,\n                                        None,\n                                        diagnostic_handler,\n                                        Rc::new(CodeMap::new(FilePathMapping::empty())),\n                                        cstore.clone());\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: driver::anon_src(),"}, {"sha": "f47788ee036dc5e312d4a05754a3f4b0cd8c7143", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -11,13 +11,13 @@ crate-type = [\"dylib\"]\n [dependencies]\n flate = { path = \"../libflate\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n proc_macro = { path = \"../libproc_macro\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }"}, {"sha": "dc7be42e452cb357352c9d9bbb8b9e41ebdc8bcb", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -393,6 +393,7 @@ impl<'a> CrateLoader<'a> {\n                 rejected_via_filename: vec![],\n                 should_match_name: true,\n                 is_proc_macro: Some(false),\n+                metadata_loader: &*self.cstore.metadata_loader,\n             };\n \n             self.load(&mut locate_ctxt).or_else(|| {\n@@ -554,6 +555,7 @@ impl<'a> CrateLoader<'a> {\n             rejected_via_filename: vec![],\n             should_match_name: true,\n             is_proc_macro: None,\n+            metadata_loader: &*self.cstore.metadata_loader,\n         };\n         let library = self.load(&mut locate_ctxt).or_else(|| {\n             if !is_cross {"}, {"sha": "d2ad6d0ab344999a00dbf6375cda9e8b45bb51b2", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -11,21 +11,20 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use locator;\n use schema::{self, Tracked};\n \n use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::{DepKind, ExternCrate};\n+use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n-use flate::Bytes;\n+use owning_ref::ErasedBoxRef;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n@@ -43,11 +42,7 @@ pub use cstore_impl::provide;\n // own crate numbers.\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-pub enum MetadataBlob {\n-    Inflated(Bytes),\n-    Archive(locator::ArchiveMetadata),\n-    Raw(Vec<u8>),\n-}\n+pub struct MetadataBlob(pub ErasedBoxRef<[u8]>);\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n /// See `imported_filemaps()` for more information.\n@@ -103,10 +98,11 @@ pub struct CStore {\n     statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n+    pub metadata_loader: Box<MetadataLoader>,\n }\n \n impl CStore {\n-    pub fn new(dep_graph: &DepGraph) -> CStore {\n+    pub fn new(dep_graph: &DepGraph, metadata_loader: Box<MetadataLoader>) -> CStore {\n         CStore {\n             dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FxHashMap()),\n@@ -116,6 +112,7 @@ impl CStore {\n             statically_included_foreign_items: RefCell::new(FxHashSet()),\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n+            metadata_loader: metadata_loader,\n         }\n     }\n "}, {"sha": "1a2298d3fb1bacc2fb534674e3bf33dff9d5ba34", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -10,12 +10,11 @@\n \n use cstore;\n use encoder;\n-use locator;\n use schema;\n \n use rustc::dep_graph::DepTrackingMapConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n-                            ExternCrate, NativeLibrary, LinkMeta,\n+                            ExternCrate, NativeLibrary, MetadataLoader, LinkMeta,\n                             LinkagePreference, LoadedMacro, EncodedMetadata};\n use rustc::hir::def;\n use rustc::middle::lang_items;\n@@ -38,7 +37,6 @@ use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION};\n use rustc::hir::svh::Svh;\n-use rustc_back::target::Target;\n use rustc::hir;\n \n macro_rules! provide {\n@@ -135,6 +133,10 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(krate)\n     }\n \n+    fn metadata_loader(&self) -> &MetadataLoader {\n+        &*self.metadata_loader\n+    }\n+\n     fn visibility(&self, def: DefId) -> ty::Visibility {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_visibility(def.index)\n@@ -420,17 +422,6 @@ impl CrateStore for cstore::CStore {\n     {\n         self.get_used_link_args().borrow().clone()\n     }\n-\n-    fn metadata_filename(&self) -> &str\n-    {\n-        locator::METADATA_FILENAME\n-    }\n-\n-    fn metadata_section_name(&self, target: &Target) -> &str\n-    {\n-        locator::meta_section_name(target)\n-    }\n-\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n     {\n         self.do_get_used_crates(prefer)\n@@ -522,4 +513,4 @@ impl CrateStore for cstore::CStore {\n         drop(visible_parent_map);\n         self.visible_parent_map.borrow()\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "c734b9f411c2fb05ef112595893544fefacd1f5f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -77,11 +77,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n     fn raw_bytes(self) -> &'a [u8] {\n-        match *self {\n-            MetadataBlob::Inflated(ref vec) => vec,\n-            MetadataBlob::Archive(ref ar) => ar.as_slice(),\n-            MetadataBlob::Raw(ref vec) => vec,\n-        }\n+        &self.0\n     }\n }\n "}, {"sha": "e3d9e5ac74a062a6a53e5fa9909651117d726858", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -37,6 +37,7 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate flate;\n extern crate serialize as rustc_serialize; // used by deriving\n+extern crate owning_ref;\n extern crate rustc_errors as errors;\n extern crate syntax_ext;\n extern crate proc_macro;\n@@ -46,7 +47,6 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n-extern crate rustc_llvm;\n \n mod diagnostics;\n "}, {"sha": "34b07af9f01f439cf84e551c5ff5cd629b6bcf98", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 61, "deletions": 164, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -224,15 +224,12 @@ use creader::Library;\n use schema::{METADATA_HEADER, rustc_version};\n \n use rustc::hir::svh::Svh;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::session::{config, Session};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n-use rustc::util::common;\n use rustc::util::nodemap::FxHashMap;\n \n-use rustc_llvm as llvm;\n-use rustc_llvm::{False, ObjectFile, mk_section_iter};\n-use rustc_llvm::archive_ro::ArchiveRO;\n use errors::DiagnosticBuilder;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -243,11 +240,10 @@ use std::fmt;\n use std::fs::{self, File};\n use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n-use std::ptr;\n-use std::slice;\n use std::time::Instant;\n \n use flate;\n+use owning_ref::{ErasedBoxRef, OwningRef};\n \n pub struct CrateMismatch {\n     path: PathBuf,\n@@ -272,12 +268,7 @@ pub struct Context<'a> {\n     pub rejected_via_filename: Vec<CrateMismatch>,\n     pub should_match_name: bool,\n     pub is_proc_macro: Option<bool>,\n-}\n-\n-pub struct ArchiveMetadata {\n-    _archive: ArchiveRO,\n-    // points into self._archive\n-    data: *const [u8],\n+    pub metadata_loader: &'a MetadataLoader,\n }\n \n pub struct CratePaths {\n@@ -287,8 +278,6 @@ pub struct CratePaths {\n     pub rmeta: Option<PathBuf>,\n }\n \n-pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n-\n #[derive(Copy, Clone, PartialEq)]\n enum CrateFlavor {\n     Rlib,\n@@ -596,20 +585,21 @@ impl<'a> Context<'a> {\n         let mut err: Option<DiagnosticBuilder> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n-            let (hash, metadata) = match get_metadata_section(self.target, flavor, &lib) {\n-                Ok(blob) => {\n-                    if let Some(h) = self.crate_matches(&blob, &lib) {\n-                        (h, blob)\n-                    } else {\n-                        info!(\"metadata mismatch\");\n+            let (hash, metadata) =\n+                match get_metadata_section(self.target, flavor, &lib, self.metadata_loader) {\n+                    Ok(blob) => {\n+                        if let Some(h) = self.crate_matches(&blob, &lib) {\n+                            (h, blob)\n+                        } else {\n+                            info!(\"metadata mismatch\");\n+                            continue;\n+                        }\n+                    }\n+                    Err(err) => {\n+                        info!(\"no metadata found: {}\", err);\n                         continue;\n                     }\n-                }\n-                Err(err) => {\n-                    info!(\"no metadata found: {}\", err);\n-                    continue;\n-                }\n-            };\n+                };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n             if slot.as_ref().map_or(false, |s| s.0 != hash) {\n                 let mut e = struct_span_err!(self.sess,\n@@ -833,50 +823,14 @@ pub fn note_crate_name(err: &mut DiagnosticBuilder, name: &str) {\n     err.note(&format!(\"crate name: {}\", name));\n }\n \n-impl ArchiveMetadata {\n-    fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n-        let data = {\n-            let section = ar.iter()\n-                .filter_map(|s| s.ok())\n-                .find(|sect| sect.name() == Some(METADATA_FILENAME));\n-            match section {\n-                Some(s) => s.data() as *const [u8],\n-                None => {\n-                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                    return None;\n-                }\n-            }\n-        };\n-\n-        Some(ArchiveMetadata {\n-            _archive: ar,\n-            data: data,\n-        })\n-    }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n-        unsafe { &*self.data }\n-    }\n-}\n-\n-fn verify_decompressed_encoding_version(blob: &MetadataBlob,\n-                                        filename: &Path)\n-                                        -> Result<(), String> {\n-    if !blob.is_compatible() {\n-        Err((format!(\"incompatible metadata version found: '{}'\",\n-                     filename.display())))\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n // Just a small wrapper to time how long reading metadata takes.\n fn get_metadata_section(target: &Target,\n                         flavor: CrateFlavor,\n-                        filename: &Path)\n+                        filename: &Path,\n+                        loader: &MetadataLoader)\n                         -> Result<MetadataBlob, String> {\n     let start = Instant::now();\n-    let ret = get_metadata_section_imp(target, flavor, filename);\n+    let ret = get_metadata_section_imp(target, flavor, filename, loader);\n     info!(\"reading {:?} => {:?}\",\n           filename.file_name().unwrap(),\n           start.elapsed());\n@@ -885,118 +839,61 @@ fn get_metadata_section(target: &Target,\n \n fn get_metadata_section_imp(target: &Target,\n                             flavor: CrateFlavor,\n-                            filename: &Path)\n+                            filename: &Path,\n+                            loader: &MetadataLoader)\n                             -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n-    if flavor == CrateFlavor::Rlib {\n-        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n-        // internally to read the file. We also avoid even using a memcpy by\n-        // just keeping the archive along while the metadata is in use.\n-        let archive = match ArchiveRO::open(filename) {\n-            Some(ar) => ar,\n-            None => {\n-                debug!(\"llvm didn't like `{}`\", filename.display());\n-                return Err(format!(\"failed to read rlib metadata: '{}'\", filename.display()));\n+    let raw_bytes: ErasedBoxRef<[u8]> = match flavor {\n+        CrateFlavor::Rlib => loader.get_rlib_metadata(target, filename)?,\n+        CrateFlavor::Dylib => {\n+            let buf = loader.get_dylib_metadata(target, filename)?;\n+            // The header is uncompressed\n+            let header_len = METADATA_HEADER.len();\n+            debug!(\"checking {} bytes of metadata-version stamp\", header_len);\n+            let header = &buf[..cmp::min(header_len, buf.len())];\n+            if header != METADATA_HEADER {\n+                return Err(format!(\"incompatible metadata version found: '{}'\",\n+                                   filename.display()));\n             }\n-        };\n-        return match ArchiveMetadata::new(archive).map(|ar| MetadataBlob::Archive(ar)) {\n-            None => Err(format!(\"failed to read rlib metadata: '{}'\", filename.display())),\n-            Some(blob) => {\n-                verify_decompressed_encoding_version(&blob, filename)?;\n-                Ok(blob)\n-            }\n-        };\n-    } else if flavor == CrateFlavor::Rmeta {\n-        let mut file = File::open(filename).map_err(|_|\n-            format!(\"could not open file: '{}'\", filename.display()))?;\n-        let mut buf = vec![];\n-        file.read_to_end(&mut buf).map_err(|_|\n-            format!(\"failed to read rlib metadata: '{}'\", filename.display()))?;\n-        let blob = MetadataBlob::Raw(buf);\n-        verify_decompressed_encoding_version(&blob, filename)?;\n-        return Ok(blob);\n-    }\n-    unsafe {\n-        let buf = common::path2cstr(filename);\n-        let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n-        if mb as isize == 0 {\n-            return Err(format!(\"error reading library: '{}'\", filename.display()));\n-        }\n-        let of = match ObjectFile::new(mb) {\n-            Some(of) => of,\n-            _ => {\n-                return Err((format!(\"provided path not an object file: '{}'\", filename.display())))\n-            }\n-        };\n-        let si = mk_section_iter(of.llof);\n-        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n-            let mut name_buf = ptr::null();\n-            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = slice::from_raw_parts(name_buf as *const u8, name_len as usize).to_vec();\n-            let name = String::from_utf8(name).unwrap();\n-            debug!(\"get_metadata_section: name {}\", name);\n-            if read_meta_section_name(target) == name {\n-                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n-                let cvbuf: *const u8 = cbuf as *const u8;\n-                let vlen = METADATA_HEADER.len();\n-                debug!(\"checking {} bytes of metadata-version stamp\", vlen);\n-                let minsz = cmp::min(vlen, csz);\n-                let buf0 = slice::from_raw_parts(cvbuf, minsz);\n-                let version_ok = buf0 == METADATA_HEADER;\n-                if !version_ok {\n-                    return Err((format!(\"incompatible metadata version found: '{}'\",\n-                                        filename.display())));\n-                }\n \n-                let cvbuf1 = cvbuf.offset(vlen as isize);\n-                debug!(\"inflating {} bytes of compressed metadata\", csz - vlen);\n-                let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n-                match flate::inflate_bytes(bytes) {\n-                    Ok(inflated) => {\n-                        let blob = MetadataBlob::Inflated(inflated);\n-                        verify_decompressed_encoding_version(&blob, filename)?;\n-                        return Ok(blob);\n-                    }\n-                    Err(_) => {}\n+            // Header is okay -> inflate the actual metadata\n+            let compressed_bytes = &buf[header_len..];\n+            debug!(\"inflating {} bytes of compressed metadata\", compressed_bytes.len());\n+            match flate::inflate_bytes(compressed_bytes) {\n+                Ok(inflated) => {\n+                    let buf = unsafe { OwningRef::new_assert_stable_address(inflated) };\n+                    buf.map_owner_box().erase_owner()\n+                }\n+                Err(_) => {\n+                    return Err(format!(\"failed to decompress metadata: {}\", filename.display()));\n                 }\n             }\n-            llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        Err(format!(\"metadata not found: '{}'\", filename.display()))\n-    }\n-}\n-\n-pub fn meta_section_name(target: &Target) -> &'static str {\n-    // Historical note:\n-    //\n-    // When using link.exe it was seen that the section name `.note.rustc`\n-    // was getting shortened to `.note.ru`, and according to the PE and COFF\n-    // specification:\n-    //\n-    // > Executable images do not use a string table and do not support\n-    // > section names longer than 8\u00a0characters\n-    //\n-    // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n-    //\n-    // As a result, we choose a slightly shorter name! As to why\n-    // `.note.rustc` works on MinGW, that's another good question...\n-\n-    if target.options.is_like_osx {\n-        \"__DATA,.rustc\"\n+        CrateFlavor::Rmeta => {\n+            let mut file = File::open(filename).map_err(|_|\n+                format!(\"could not open file: '{}'\", filename.display()))?;\n+            let mut buf = vec![];\n+            file.read_to_end(&mut buf).map_err(|_|\n+                format!(\"failed to read rmeta metadata: '{}'\", filename.display()))?;\n+            OwningRef::new(buf).map_owner_box().erase_owner()\n+        }\n+    };\n+    let blob = MetadataBlob(raw_bytes);\n+    if blob.is_compatible() {\n+        Ok(blob)\n     } else {\n-        \".rustc\"\n+        Err(format!(\"incompatible metadata version found: '{}'\", filename.display()))\n     }\n }\n \n-pub fn read_meta_section_name(_target: &Target) -> &'static str {\n-    \".rustc\"\n-}\n-\n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) -> io::Result<()> {\n+pub fn list_file_metadata(target: &Target,\n+                          path: &Path,\n+                          loader: &MetadataLoader,\n+                          out: &mut io::Write)\n+                          -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n@@ -1005,7 +902,7 @@ pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) ->\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path) {\n+    match get_metadata_section(target, flavor, path, loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "4ccc85257f3c990ba313df23fa87a9de43476721", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -12,6 +12,7 @@ test = false\n [dependencies]\n flate = { path = \"../libflate\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }"}, {"sha": "902065c8688d0d808fb6c2c29d25c82d8bbd219a", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -20,6 +20,7 @@ use std::str;\n use libc;\n use llvm::archive_ro::{ArchiveRO, Child};\n use llvm::{self, ArchiveKind};\n+use metadata::METADATA_FILENAME;\n use rustc::session::Session;\n \n pub struct ArchiveConfig<'a> {\n@@ -158,11 +159,9 @@ impl<'a> ArchiveBuilder<'a> {\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n-        let metadata_filename =\n-            self.config.sess.cstore.metadata_filename().to_owned();\n \n         self.add_archive(rlib, move |fname: &str| {\n-            if fname.ends_with(bc_ext) || fname == metadata_filename {\n+            if fname.ends_with(bc_ext) || fname == METADATA_FILENAME {\n                 return true\n             }\n "}, {"sha": "b8aabef65a984adf76c8364ba0337797460ee009", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -13,6 +13,7 @@ use super::linker::Linker;\n use super::rpath::RPathConfig;\n use super::rpath;\n use super::msvc;\n+use metadata::METADATA_FILENAME;\n use session::config;\n use session::config::NoDebugInfo;\n use session::config::{OutputFilenames, Input, OutputType};\n@@ -521,7 +522,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // contain the metadata in a separate file. We use a temp directory\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n-            let metadata = tmpdir.join(sess.cstore.metadata_filename());\n+            let metadata = tmpdir.join(METADATA_FILENAME);\n             emit_metadata(sess, trans, &metadata);\n             ab.add_file(&metadata);\n \n@@ -1141,8 +1142,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         archive.update_symbols();\n \n         for f in archive.src_files() {\n-            if f.ends_with(\"bytecode.deflate\") ||\n-                f == sess.cstore.metadata_filename() {\n+            if f.ends_with(\"bytecode.deflate\") || f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue\n                 }\n@@ -1217,8 +1217,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n             let mut any_objects = false;\n             for f in archive.src_files() {\n-                if f.ends_with(\"bytecode.deflate\") ||\n-                   f == sess.cstore.metadata_filename() {\n+                if f.ends_with(\"bytecode.deflate\") || f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue\n                 }"}, {"sha": "437ced85b2e4ad48ec97d7186ea54f5d50820764", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -34,6 +34,7 @@ use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n+use metadata;\n use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n use middle::cstore::EncodedMetadata;\n@@ -778,8 +779,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let section_name =\n-            tcx.sess.cstore.metadata_section_name(&tcx.sess.target.target);\n+        let section_name = metadata::metadata_section_name(&tcx.sess.target.target);\n         let name = CString::new(section_name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n "}, {"sha": "3ac0d88b90d7b7be0f6894313951a6b6595cf235", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -45,6 +45,7 @@ use syntax_pos::symbol::Symbol;\n \n extern crate flate;\n extern crate libc;\n+extern crate owning_ref;\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n@@ -70,6 +71,9 @@ pub use rustc::util;\n pub use base::trans_crate;\n pub use back::symbol_names::provide;\n \n+pub use metadata::LlvmMetadataLoader;\n+pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n+\n pub mod back {\n     pub use rustc::hir::svh;\n \n@@ -119,7 +123,9 @@ mod debuginfo;\n mod declare;\n mod glue;\n mod intrinsic;\n+mod llvm_util;\n mod machine;\n+mod metadata;\n mod meth;\n mod mir;\n mod monomorphize;"}, {"sha": "15f56036b0c1b933aebe49308108f51080d3f441", "filename": "src/librustc_trans/llvm_util.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax_pos::symbol::Symbol;\n+use back::write::create_target_machine;\n+use llvm;\n+use rustc::session::Session;\n+use rustc::session::config::PrintRequest;\n+use libc::{c_int, c_char};\n+use std::ffi::CString;\n+\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::sync::Once;\n+\n+pub fn init(sess: &Session) {\n+    unsafe {\n+        // Before we touch LLVM, make sure that multithreading is enabled.\n+        static POISONED: AtomicBool = AtomicBool::new(false);\n+        static INIT: Once = Once::new();\n+        INIT.call_once(|| {\n+            if llvm::LLVMStartMultithreaded() != 1 {\n+                // use an extra bool to make sure that all future usage of LLVM\n+                // cannot proceed despite the Once not running more than once.\n+                POISONED.store(true, Ordering::SeqCst);\n+            }\n+\n+            configure_llvm(sess);\n+        });\n+\n+        if POISONED.load(Ordering::SeqCst) {\n+            bug!(\"couldn't enable multi-threaded LLVM\");\n+        }\n+    }\n+}\n+\n+unsafe fn configure_llvm(sess: &Session) {\n+    let mut llvm_c_strs = Vec::new();\n+    let mut llvm_args = Vec::new();\n+\n+    {\n+        let mut add = |arg: &str| {\n+            let s = CString::new(arg).unwrap();\n+            llvm_args.push(s.as_ptr());\n+            llvm_c_strs.push(s);\n+        };\n+        add(\"rustc\"); // fake program name\n+        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n+        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n+\n+        for arg in &sess.opts.cg.llvm_args {\n+            add(&(*arg));\n+        }\n+    }\n+\n+    llvm::LLVMInitializePasses();\n+\n+    llvm::initialize_available_targets();\n+\n+    llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n+                                 llvm_args.as_ptr());\n+}\n+\n+// WARNING: the features must be known to LLVM or the feature\n+// detection code will walk past the end of the feature array,\n+// leading to crashes.\n+\n+const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n+\n+const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n+                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n+                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n+                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\"];\n+\n+const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+\n+pub fn target_features(sess: &Session) -> Vec<Symbol> {\n+    let target_machine = create_target_machine(sess);\n+\n+    let whitelist = match &*sess.target.target.arch {\n+        \"arm\" => ARM_WHITELIST,\n+        \"x86\" | \"x86_64\" => X86_WHITELIST,\n+        \"hexagon\" => HEXAGON_WHITELIST,\n+        _ => &[],\n+    };\n+\n+    let mut features = Vec::new();\n+    for feat in whitelist {\n+        assert_eq!(feat.chars().last(), Some('\\0'));\n+        if unsafe { llvm::LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n+            features.push(Symbol::intern(&feat[..feat.len() - 1]));\n+        }\n+    }\n+    features\n+}\n+\n+pub fn print_version() {\n+    unsafe {\n+        println!(\"LLVM version: {}.{}\",\n+                 llvm::LLVMRustVersionMajor(), llvm::LLVMRustVersionMinor());\n+    }\n+}\n+\n+pub fn print_passes() {\n+    unsafe { llvm::LLVMRustPrintPasses(); }\n+}\n+\n+pub fn print(req: PrintRequest, sess: &Session) {\n+    let tm = create_target_machine(sess);\n+    unsafe {\n+        match req {\n+            PrintRequest::TargetCPUs => llvm::LLVMRustPrintTargetCPUs(tm),\n+            PrintRequest::TargetFeatures => llvm::LLVMRustPrintTargetFeatures(tm),\n+            _ => bug!(\"rustc_trans can't handle print request: {:?}\", req),\n+        }\n+    }\n+}\n+\n+pub fn enable_llvm_debug() {\n+    unsafe { llvm::LLVMRustSetDebug(1); }\n+}"}, {"sha": "2c0148dfbb371851958c0e4b0c10464818ab0b65", "filename": "src/librustc_trans/metadata.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustc_trans%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmetadata.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::common;\n+use rustc::middle::cstore::MetadataLoader;\n+use rustc_back::target::Target;\n+use llvm;\n+use llvm::{False, ObjectFile, mk_section_iter};\n+use llvm::archive_ro::ArchiveRO;\n+\n+use owning_ref::{ErasedBoxRef, OwningRef};\n+use std::path::Path;\n+use std::ptr;\n+use std::slice;\n+\n+pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n+\n+pub struct LlvmMetadataLoader;\n+\n+impl MetadataLoader for LlvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n+        // internally to read the file. We also avoid even using a memcpy by\n+        // just keeping the archive along while the metadata is in use.\n+        let archive = ArchiveRO::open(filename)\n+            .map(|ar| OwningRef::new(box ar))\n+            .ok_or_else(|| {\n+                            debug!(\"llvm didn't like `{}`\", filename.display());\n+                            format!(\"failed to read rlib metadata: '{}'\", filename.display())\n+                        })?;\n+        let buf: OwningRef<_, [u8]> = archive\n+            .try_map(|ar| {\n+                ar.iter()\n+                    .filter_map(|s| s.ok())\n+                    .find(|sect| sect.name() == Some(METADATA_FILENAME))\n+                    .map(|s| s.data())\n+                    .ok_or_else(|| {\n+                                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                                    format!(\"failed to read rlib metadata: '{}'\",\n+                                            filename.display())\n+                                })\n+            })?;\n+        Ok(buf.erase_owner())\n+    }\n+\n+    fn get_dylib_metadata(&self,\n+                          target: &Target,\n+                          filename: &Path)\n+                          -> Result<ErasedBoxRef<[u8]>, String> {\n+        unsafe {\n+            let buf = common::path2cstr(filename);\n+            let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n+            if mb as isize == 0 {\n+                return Err(format!(\"error reading library: '{}'\", filename.display()));\n+            }\n+            let of = ObjectFile::new(mb)\n+                .map(|of| OwningRef::new(box of))\n+                .ok_or_else(|| format!(\"provided path not an object file: '{}'\",\n+                                        filename.display()))?;\n+            let buf = of.try_map(|of| search_meta_section(of, target, filename))?;\n+            Ok(buf.erase_owner())\n+        }\n+    }\n+}\n+\n+fn search_meta_section<'a>(of: &'a ObjectFile,\n+                           target: &Target,\n+                           filename: &Path)\n+                           -> Result<&'a [u8], String> {\n+    unsafe {\n+        let si = mk_section_iter(of.llof);\n+        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n+            let mut name_buf = ptr::null();\n+            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n+            let name = slice::from_raw_parts(name_buf as *const u8, name_len as usize).to_vec();\n+            let name = String::from_utf8(name).unwrap();\n+            debug!(\"get_metadata_section: name {}\", name);\n+            if read_metadata_section_name(target) == name {\n+                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n+                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n+                // The buffer is valid while the object file is around\n+                let buf: &'a [u8] = slice::from_raw_parts(cbuf as *const u8, csz);\n+                return Ok(buf);\n+            }\n+            llvm::LLVMMoveToNextSection(si.llsi);\n+        }\n+    }\n+    Err(format!(\"metadata not found: '{}'\", filename.display()))\n+}\n+\n+pub fn metadata_section_name(target: &Target) -> &'static str {\n+    // Historical note:\n+    //\n+    // When using link.exe it was seen that the section name `.note.rustc`\n+    // was getting shortened to `.note.ru`, and according to the PE and COFF\n+    // specification:\n+    //\n+    // > Executable images do not use a string table and do not support\n+    // > section names longer than 8\u00a0characters\n+    //\n+    // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n+    //\n+    // As a result, we choose a slightly shorter name! As to why\n+    // `.note.rustc` works on MinGW, that's another good question...\n+\n+    if target.options.is_like_osx {\n+        \"__DATA,.rustc\"\n+    } else {\n+        \".rustc\"\n+    }\n+}\n+\n+fn read_metadata_section_name(_target: &Target) -> &'static str {\n+    \".rustc\"\n+}"}, {"sha": "9a689ed079ee259f8240a652942966c3ddd7ec57", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::{self, TyCtxt, GlobalArenas};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_trans;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -138,10 +139,11 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, cpath, diagnostic_handler, codemap, cstore.clone()\n     );\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));"}, {"sha": "cfe2fad0fa4695a59d1b840da41c493305086a6c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -34,6 +34,7 @@ use rustc_driver::{self, driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n+use rustc_trans;\n use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n@@ -81,10 +82,11 @@ pub fn run(input: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, Some(input_path.clone()), handler, codemap.clone(), cstore.clone(),\n     );\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess.parse_sess.config =\n         config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n@@ -229,10 +231,11 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let dep_graph = DepGraph::new(false);\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, None, diagnostic_handler, codemap, cstore.clone(),\n     );\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));"}, {"sha": "e96588c6e5aea6a3978b4ea67d4f46ed4d903d3a", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -15,6 +15,7 @@ extern crate rustc_driver;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_errors;\n+extern crate rustc_trans;\n extern crate syntax;\n \n use rustc::dep_graph::DepGraph;\n@@ -58,8 +59,9 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let dep_graph = DepGraph::new(opts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, Box::new(rustc_trans::LlvmMetadataLoader)));\n     let sess = build_session(opts, &dep_graph, None, descriptions, cstore.clone());\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     (sess, cstore)\n }"}, {"sha": "37aab2bbd059aa61579de5e914b41bdb71381abc", "filename": "src/test/run-make/llvm-pass/plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa78d5bb87d136f793c56f9861957ce41080bd7e/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs?ref=fa78d5bb87d136f793c56f9861957ce41080bd7e", "patch": "@@ -14,6 +14,7 @@\n \n extern crate rustc;\n extern crate rustc_plugin;\n+extern crate rustc_trans;\n \n #[link(name = \"llvm-function-pass\", kind = \"static\")]\n #[link(name = \"llvm-module-pass\", kind = \"static\")]"}]}