{"sha": "e4791e086d671d429db864787f6b60547a28b0f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NzkxZTA4NmQ2NzFkNDI5ZGI4NjQ3ODdmNmI2MDU0N2EyOGIwZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-28T17:19:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-28T17:19:52Z"}, "message": "Auto merge of #35984 - jonas-schievink:reproducible-builds, r=eddyb\n\nSteps towards reproducible builds\n\ncc #34902\n\nRunning `make dist` twice will result in a rustc tarball where only `librustc_back.so`, `librustc_llvm.so` and `librustc_trans.so` differ. Building `libstd` and `libcore` twice with the same compiler and flags produces identical artifacts.\n\nThe third commit should close #24473", "tree": {"sha": "7da08b4d6361aae2c56fc77622d56b88bad95e90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7da08b4d6361aae2c56fc77622d56b88bad95e90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4791e086d671d429db864787f6b60547a28b0f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4791e086d671d429db864787f6b60547a28b0f5", "html_url": "https://github.com/rust-lang/rust/commit/e4791e086d671d429db864787f6b60547a28b0f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4791e086d671d429db864787f6b60547a28b0f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fd13fad9349a4c36a61a6f2766406cff7bcee8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fd13fad9349a4c36a61a6f2766406cff7bcee8a", "html_url": "https://github.com/rust-lang/rust/commit/6fd13fad9349a4c36a61a6f2766406cff7bcee8a"}, {"sha": "8766c18473c23502c37a6edfe999999ed86053c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8766c18473c23502c37a6edfe999999ed86053c2", "html_url": "https://github.com/rust-lang/rust/commit/8766c18473c23502c37a6edfe999999ed86053c2"}], "stats": {"total": 268, "additions": 135, "deletions": 133}, "files": [{"sha": "f793d489cab064866ce927a07b32a8f707bf396a", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -32,15 +32,16 @@\n \n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeFolder;\n-use std::collections::hash_map::{self, Entry};\n+use util::nodemap::FnvHashMap;\n+use std::collections::hash_map::Entry;\n \n use super::InferCtxt;\n use super::unify_key::ToType;\n \n pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n-    freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n+    freshen_map: FnvHashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -49,7 +50,7 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx: infcx,\n             freshen_count: 0,\n-            freshen_map: hash_map::HashMap::new(),\n+            freshen_map: FnvHashMap(),\n         }\n     }\n "}, {"sha": "f44b149a84617de12abdabd5d27af7f54e67f66a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -22,8 +22,8 @@ use ty::{self, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId};\n use lint;\n+use util::nodemap::FnvHashSet;\n \n-use std::collections::HashSet;\n use syntax::{ast, codemap};\n use syntax::attr;\n use syntax_pos;\n@@ -48,7 +48,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<HashSet<ast::NodeId>>,\n+    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n     inherited_pub_visibility: bool,\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             tcx: tcx,\n-            live_symbols: box HashSet::new(),\n+            live_symbols: box FnvHashSet(),\n             struct_has_extern_repr: false,\n             ignore_non_const_paths: false,\n             inherited_pub_visibility: false,\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn mark_live_symbols(&mut self) {\n-        let mut scanned = HashSet::new();\n+        let mut scanned = FnvHashSet();\n         while !self.worklist.is_empty() {\n             let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n@@ -395,7 +395,7 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n-                       -> Box<HashSet<ast::NodeId>> {\n+                       -> Box<FnvHashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n@@ -413,7 +413,7 @@ fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<HashSet<ast::NodeId>>,\n+    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {"}, {"sha": "e29a7cf9d68467a332147ee06ccf853825231ff6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -22,9 +22,8 @@ use hir::def_id::DefId;\n use ty::{self, TyCtxt};\n use middle::privacy;\n use session::config;\n-use util::nodemap::NodeSet;\n+use util::nodemap::{NodeSet, FnvHashSet};\n \n-use std::collections::HashSet;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n@@ -204,7 +203,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&mut self) {\n-        let mut scanned = HashSet::new();\n+        let mut scanned = FnvHashSet();\n         loop {\n             let search_item = match self.worklist.pop() {\n                 Some(item) => item,"}, {"sha": "f99bdf3b890cb42db8669cd37790c2c362c2f99f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -862,8 +862,13 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           xrefs: FnvHashMap<XRef<'tcx>, u32>)\n {\n     let mut xref_positions = vec![0; xrefs.len()];\n+\n+    // Encode XRefs sorted by their ID\n+    let mut sorted_xrefs: Vec<_> = xrefs.into_iter().collect();\n+    sorted_xrefs.sort_by_key(|&(_, id)| id);\n+\n     rbml_w.start_tag(tag_xref_data);\n-    for (xref, id) in xrefs.into_iter() {\n+    for (xref, id) in sorted_xrefs.into_iter() {\n         xref_positions[id as usize] = rbml_w.mark_stable_position() as u32;\n         match xref {\n             XRef::Predicate(p) => {"}, {"sha": "b2c87db8ef56636293142e40894fef91b49152ed", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -221,6 +221,7 @@ use rustc::session::Session;\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::common;\n+use rustc::util::nodemap::FnvHashMap;\n \n use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n@@ -230,7 +231,6 @@ use syntax_pos::Span;\n use rustc_back::target::Target;\n \n use std::cmp;\n-use std::collections::HashMap;\n use std::fmt;\n use std::fs;\n use std::io;\n@@ -413,7 +413,7 @@ impl<'a> Context<'a> {\n         let rlib_prefix = format!(\"lib{}\", self.crate_name);\n         let staticlib_prefix = format!(\"{}{}\", staticpair.0, self.crate_name);\n \n-        let mut candidates = HashMap::new();\n+        let mut candidates = FnvHashMap();\n         let mut staticlibs = vec!();\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n@@ -456,7 +456,7 @@ impl<'a> Context<'a> {\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                                 .or_insert_with(|| (HashMap::new(), HashMap::new()));\n+                                 .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             fs::canonicalize(path).map(|p| {\n                 if rlib {\n@@ -477,7 +477,7 @@ impl<'a> Context<'a> {\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n-        let mut libraries = HashMap::new();\n+        let mut libraries = FnvHashMap();\n         for (_hash, (rlibs, dylibs)) in candidates {\n             let mut slot = None;\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n@@ -527,7 +527,7 @@ impl<'a> Context<'a> {\n     // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n-    fn extract_one(&mut self, m: HashMap<PathBuf, PathKind>, flavor: CrateFlavor,\n+    fn extract_one(&mut self, m: FnvHashMap<PathBuf, PathKind>, flavor: CrateFlavor,\n                    slot: &mut Option<(Svh, MetadataBlob)>) -> Option<(PathBuf, PathKind)> {\n         let mut ret: Option<(PathBuf, PathKind)> = None;\n         let mut error = 0;\n@@ -669,8 +669,8 @@ impl<'a> Context<'a> {\n         // rlibs/dylibs.\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n-        let mut rlibs = HashMap::new();\n-        let mut dylibs = HashMap::new();\n+        let mut rlibs = FnvHashMap();\n+        let mut dylibs = FnvHashMap();\n         {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {"}, {"sha": "2cd60f04e69a1dadc22e2b8375b63f79cccbe64e", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -14,8 +14,8 @@ use creader::CrateReader;\n use cstore::CStore;\n \n use rustc::session::Session;\n+use rustc::util::nodemap::{FnvHashSet, FnvHashMap};\n \n-use std::collections::{HashSet, HashMap};\n use syntax::parse::token;\n use syntax::ast;\n use syntax::attr;\n@@ -45,13 +45,13 @@ pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n     span_err!(a, b, E0467, \"bad macro reexport\");\n }\n \n-pub type MacroSelection = HashMap<token::InternedString, Span>;\n+pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n \n impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<ast::MacroDef> {\n         // Parse the attributes relating to macros.\n-        let mut import = Some(HashMap::new());  // None => load all\n-        let mut reexport = HashMap::new();\n+        let mut import = Some(FnvHashMap());  // None => load all\n+        let mut reexport = FnvHashMap();\n \n         for attr in &extern_crate.attrs {\n             let mut used = true;\n@@ -120,7 +120,7 @@ impl<'a> MacroLoader<'a> {\n         }\n \n         let mut macros = Vec::new();\n-        let mut seen = HashSet::new();\n+        let mut seen = FnvHashSet();\n \n         for mut def in self.reader.read_exported_macros(vi) {\n             let name = def.ident.name.as_str();"}, {"sha": "a9e3c6ffe9ed887d028208dab5d64fa7e49d70e3", "filename": "src/librustc_resolve/assign_ids.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -10,14 +10,14 @@\n \n use Resolver;\n use rustc::session::Session;\n+use rustc::util::nodemap::FnvHashMap;\n use syntax::ast;\n use syntax::ext::hygiene::Mark;\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::util::move_map::MoveMap;\n use syntax::util::small_vector::SmallVector;\n \n-use std::collections::HashMap;\n use std::mem;\n \n impl<'a> Resolver<'a> {\n@@ -31,7 +31,7 @@ impl<'a> Resolver<'a> {\n \n struct NodeIdAssigner<'a> {\n     sess: &'a Session,\n-    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<Mark>>,\n+    macros_at_scope: &'a mut FnvHashMap<ast::NodeId, Vec<Mark>>,\n }\n \n impl<'a> Folder for NodeIdAssigner<'a> {"}, {"sha": "6a4a48377c783280e9ae40b379337fc99c00aea0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -68,7 +68,6 @@ use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, T\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n-use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n@@ -498,7 +497,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = HashMap<ast::Ident, BindingInfo>;\n+type BindingMap = FnvHashMap<ast::Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -703,14 +702,14 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: HashMap<ast::Ident, Def>,\n+    bindings: FnvHashMap<ast::Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n impl<'a> Rib<'a> {\n     fn new(kind: RibKind<'a>) -> Rib<'a> {\n         Rib {\n-            bindings: HashMap::new(),\n+            bindings: FnvHashMap(),\n             kind: kind,\n         }\n     }\n@@ -773,7 +772,7 @@ pub struct ModuleS<'a> {\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n \n-    resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    resolutions: RefCell<FnvHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n     no_implicit_prelude: Cell<bool>,\n \n@@ -797,7 +796,7 @@ impl<'a> ModuleS<'a> {\n             parent_link: parent_link,\n             def: def,\n             extern_crate_id: None,\n-            resolutions: RefCell::new(HashMap::new()),\n+            resolutions: RefCell::new(FnvHashMap()),\n             no_implicit_prelude: Cell::new(false),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -930,12 +929,12 @@ impl<'a> NameBinding<'a> {\n \n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n-    primitive_types: HashMap<Name, PrimTy>,\n+    primitive_types: FnvHashMap<Name, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n     fn new() -> PrimitiveTypeTable {\n-        let mut table = PrimitiveTypeTable { primitive_types: HashMap::new() };\n+        let mut table = PrimitiveTypeTable { primitive_types: FnvHashMap() };\n \n         table.intern(\"bool\", TyBool);\n         table.intern(\"char\", TyChar);\n@@ -969,7 +968,7 @@ pub struct Resolver<'a> {\n \n     // Maps the node id of a statement to the expansions of the `macro_rules!`s\n     // immediately above the statement (if appropriate).\n-    macros_at_scope: HashMap<NodeId, Vec<Mark>>,\n+    macros_at_scope: FnvHashMap<NodeId, Vec<Mark>>,\n \n     graph_root: Module<'a>,\n \n@@ -1043,8 +1042,8 @@ pub struct Resolver<'a> {\n     // all imports, but only glob imports are actually interesting).\n     pub glob_map: GlobMap,\n \n-    used_imports: HashSet<(NodeId, Namespace)>,\n-    used_crates: HashSet<CrateNum>,\n+    used_imports: FnvHashSet<(NodeId, Namespace)>,\n+    used_crates: FnvHashSet<CrateNum>,\n     pub maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n@@ -1164,7 +1163,7 @@ impl<'a> Resolver<'a> {\n             session: session,\n \n             definitions: Definitions::new(),\n-            macros_at_scope: HashMap::new(),\n+            macros_at_scope: FnvHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1199,8 +1198,8 @@ impl<'a> Resolver<'a> {\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n-            used_imports: HashSet::new(),\n-            used_crates: HashSet::new(),\n+            used_imports: FnvHashSet(),\n+            used_crates: FnvHashSet(),\n             maybe_unused_trait_imports: NodeSet(),\n \n             privacy_errors: Vec::new(),\n@@ -1729,7 +1728,7 @@ impl<'a> Resolver<'a> {\n         match type_parameters {\n             HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n-                let mut seen_bindings = HashMap::new();\n+                let mut seen_bindings = FnvHashMap();\n                 for type_parameter in &generics.ty_params {\n                     let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n@@ -1793,7 +1792,7 @@ impl<'a> Resolver<'a> {\n         self.label_ribs.push(Rib::new(rib_kind));\n \n         // Add each argument to the rib.\n-        let mut bindings_list = HashMap::new();\n+        let mut bindings_list = FnvHashMap();\n         for argument in &declaration.inputs {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n \n@@ -1994,15 +1993,15 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut HashMap::new());\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FnvHashMap());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n     // this is done hygienically. This could arise for a macro\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n-        let mut binding_map = HashMap::new();\n+        let mut binding_map = FnvHashMap();\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n@@ -2062,7 +2061,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_arm(&mut self, arm: &Arm) {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n-        let mut bindings_list = HashMap::new();\n+        let mut bindings_list = FnvHashMap();\n         for pattern in &arm.pats {\n             self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n@@ -2202,7 +2201,7 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut HashMap<ast::Ident, NodeId>)\n+                     bindings: &mut FnvHashMap<ast::Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n@@ -2303,7 +2302,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut HashMap<ast::Ident, NodeId>) {\n+                       bindings: &mut FnvHashMap<ast::Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -3016,7 +3015,7 @@ impl<'a> Resolver<'a> {\n                 self.visit_expr(subexpression);\n \n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::IfLet, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FnvHashMap());\n                 self.visit_block(if_block);\n                 self.value_ribs.pop();\n \n@@ -3026,7 +3025,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FnvHashMap());\n \n                 self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n@@ -3036,7 +3035,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::For, &mut FnvHashMap());\n \n                 self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n@@ -3297,7 +3296,7 @@ impl<'a> Resolver<'a> {\n \n     fn report_privacy_errors(&self) {\n         if self.privacy_errors.len() == 0 { return }\n-        let mut reported_spans = HashSet::new();\n+        let mut reported_spans = FnvHashSet();\n         for &PrivacyError(span, name, binding) in &self.privacy_errors {\n             if !reported_spans.insert(span) { continue }\n             if binding.is_extern_crate() {"}, {"sha": "a183fc0858aa8feb46ac35344dce4d9887ec60f6", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -80,14 +80,13 @@ use type_of;\n use value::Value;\n use Disr;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeSet, FnvHashSet};\n+use util::nodemap::{NodeSet, FnvHashMap, FnvHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n-use std::collections::HashMap;\n use std::ptr;\n use std::rc::Rc;\n use std::str;\n@@ -1915,7 +1914,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n     }\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n-        let mut item_to_cgus = HashMap::new();\n+        let mut item_to_cgus = FnvHashMap();\n \n         for cgu in &codegen_units {\n             for (&trans_item, &linkage) in cgu.items() {"}, {"sha": "79b6ae0c83f34d5db011cb9a4b96182094f2e2df", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -16,9 +16,9 @@ use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n+use rustc::util::nodemap::FnvHashMap;\n use {CrateCtxt, require_same_types};\n \n-use std::collections::{HashMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::parse::token;\n@@ -370,7 +370,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                         return\n                     }\n \n-                    let mut structural_to_nomimal = HashMap::new();\n+                    let mut structural_to_nomimal = FnvHashMap();\n \n                     let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n                     if intr.inputs.len() != sig.inputs.len() {\n@@ -410,7 +410,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         ccx: &CrateCtxt<'a, 'tcx>,\n         position: &str,\n         span: Span,\n-        structural_to_nominal: &mut HashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n+        structural_to_nominal: &mut FnvHashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n         expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n {\n     use intrinsics::Type::*;"}, {"sha": "29366823fffdc89feb9ecb176daa1f2879ae0132", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -20,10 +20,10 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n+use rustc::util::nodemap::FnvHashSet;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir;\n-use std::collections::HashSet;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -40,7 +40,7 @@ struct ProbeContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n-    impl_dups: HashSet<DefId>,\n+    impl_dups: FnvHashSet<DefId>,\n     import_id: Option<ast::NodeId>,\n \n     /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n@@ -255,7 +255,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             item_name: item_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n-            impl_dups: HashSet::new(),\n+            impl_dups: FnvHashSet(),\n             import_id: None,\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n@@ -574,7 +574,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                          expr_id: ast::NodeId)\n                                                          -> Result<(), MethodError<'tcx>>\n     {\n-        let mut duplicates = HashSet::new();\n+        let mut duplicates = FnvHashSet();\n         let opt_applicable_traits = self.tcx.trait_map.get(&expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits {\n@@ -591,7 +591,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n-        let mut duplicates = HashSet::new();\n+        let mut duplicates = FnvHashSet();\n         for trait_info in suggest::all_traits(self.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n                 self.assemble_extension_candidates_for_trait(trait_info.def_id)?;"}, {"sha": "fb24971c4251dfdc53ce617860f063e709b2fa40", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -104,10 +104,9 @@ use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n-use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::{HashSet};\n use std::mem::replace;\n use std::ops::Deref;\n use syntax::abi::Abi;\n@@ -2045,7 +2044,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .filter_map(|t| self.default(t).map(|d| (t, d)))\n                     .collect();\n \n-            let mut unbound_tyvars = HashSet::new();\n+            let mut unbound_tyvars = FnvHashSet();\n \n             debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", default_map);\n \n@@ -2192,7 +2191,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // table then apply defaults until we find a conflict. That default must be the one\n     // that caused conflict earlier.\n     fn find_conflicting_default(&self,\n-                                unbound_vars: &HashSet<Ty<'tcx>>,\n+                                unbound_vars: &FnvHashSet<Ty<'tcx>>,\n                                 default_map: &FnvHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n                                 conflict: Ty<'tcx>)\n                                 -> Option<type_variable::Default<'tcx>> {"}, {"sha": "6b6a688bf1d18779e31057a9835d2e09baa1496a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -16,8 +16,8 @@ use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::util::nodemap::FnvHashSet;\n \n-use std::collections::HashSet;\n use syntax::ast;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -456,7 +456,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n-        let mut constrained_parameters: HashSet<_> =\n+        let mut constrained_parameters: FnvHashSet<_> =\n             variances[ast_generics.lifetimes.len()..]\n                      .iter().enumerate()\n                      .filter(|&(_, &variance)| variance != ty::Bivariant)\n@@ -519,7 +519,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n     let parent = tcx.lookup_generics(generics.parent.unwrap());\n-    let impl_params: HashSet<_> = parent.types.iter().map(|tp| tp.name).collect();\n+    let impl_params: FnvHashSet<_> = parent.types.iter().map(|tp| tp.name).collect();\n \n     for method_param in &generics.types {\n         if impl_params.contains(&method_param.name) {"}, {"sha": "30b9d15587069e704361635dfe35175a59410cd1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -73,13 +73,12 @@ use rustc::ty::util::IntTypeExt;\n use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n-use util::nodemap::{NodeMap, FnvHashMap};\n+use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n use {CrateCtxt, write_ty_to_tcx};\n \n use rustc_const_math::ConstInt;\n \n use std::cell::RefCell;\n-use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::rc::Rc;\n \n@@ -1927,9 +1926,9 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n     let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n-    let all_bounds: HashSet<_> = inline_bounds.into_iter()\n-                                              .chain(where_bounds)\n-                                              .collect();\n+    let all_bounds: FnvHashSet<_> = inline_bounds.into_iter()\n+                                                 .chain(where_bounds)\n+                                                 .collect();\n     return if all_bounds.len() > 1 {\n         ty::ObjectLifetimeDefault::Ambiguous\n     } else if all_bounds.len() == 0 {\n@@ -2146,7 +2145,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n-    let mut input_parameters: HashSet<_> =\n+    let mut input_parameters: FnvHashSet<_> =\n         ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n@@ -2175,15 +2174,15 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let impl_predicates = ccx.tcx.lookup_predicates(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n-    let mut input_parameters: HashSet<_> =\n+    let mut input_parameters: FnvHashSet<_> =\n         ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n     ctp::identify_constrained_type_params(\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n-    let lifetimes_in_associated_types: HashSet<_> = impl_items.iter()\n+    let lifetimes_in_associated_types: FnvHashSet<_> = impl_items.iter()\n         .map(|item| ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(item.id)))\n         .filter_map(|item| match item {\n             ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,"}, {"sha": "9e5c3a5d575bff6988c30b44ee6b1a0aaea11717", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::{self, Ty};\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n-use std::collections::HashSet;\n+use rustc::util::nodemap::FnvHashSet;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Parameter {\n@@ -71,7 +71,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n \n pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>],\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                              input_parameters: &mut HashSet<Parameter>)\n+                                              input_parameters: &mut FnvHashSet<Parameter>)\n {\n     let mut predicates = predicates.to_owned();\n     setup_constraining_predicates(&mut predicates, impl_trait_ref, input_parameters);\n@@ -120,7 +120,7 @@ pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>]\n /// think of any.\n pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                           input_parameters: &mut HashSet<Parameter>)\n+                                           input_parameters: &mut FnvHashSet<Parameter>)\n {\n     // The canonical way of doing the needed topological sort\n     // would be a DFS, but getting the graph and its ownership"}, {"sha": "20d4c417655401024c9c9cb110837c53d08bc5eb", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -10,7 +10,6 @@\n \n //! Support for inlining external documentation into the current AST.\n \n-use std::collections::HashSet;\n use std::iter::once;\n \n use syntax::ast;\n@@ -21,6 +20,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n+use rustc::util::nodemap::FnvHashSet;\n \n use rustc_const_eval::lookup_const_by_id;\n \n@@ -425,7 +425,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 .into_iter()\n                 .map(|meth| meth.name.to_string())\n                 .collect()\n-    }).unwrap_or(HashSet::new());\n+    }).unwrap_or(FnvHashSet());\n \n     ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n@@ -461,7 +461,7 @@ fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // If we're reexporting a reexport it may actually reexport something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n-        let mut visited = HashSet::new();\n+        let mut visited = FnvHashSet();\n         for item in tcx.sess.cstore.item_children(did) {\n             match item.def {\n                 cstore::DlDef(Def::ForeignMod(did)) => {"}, {"sha": "cd425b7c9ebbd0451af93b8f6da3555773c3dc49", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -43,10 +43,10 @@ use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty;\n use rustc::middle::stability;\n+use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n \n use rustc::hir;\n \n-use std::collections::{HashMap, HashSet};\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -121,7 +121,7 @@ pub struct Crate {\n     pub access_levels: Arc<AccessLevels<DefId>>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: HashMap<DefId, Trait>,\n+    pub external_traits: FnvHashMap<DefId, Trait>,\n }\n \n struct CrateNum(ast::CrateNum);\n@@ -1010,7 +1010,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n         // Note that associated types also have a sized bound by default, but we\n         // don't actually know the set of associated types right here so that's\n         // handled in cleaning associated types\n-        let mut sized_params = HashSet::new();\n+        let mut sized_params = FnvHashSet();\n         where_predicates.retain(|pred| {\n             match *pred {\n                 WP::BoundPredicate { ty: Generic(ref g), ref bounds } => {\n@@ -1656,9 +1656,9 @@ impl From<ast::FloatTy> for PrimitiveType {\n struct SubstAlias<'a, 'tcx: 'a> {\n     tcx: &'a ty::TyCtxt<'a, 'tcx, 'tcx>,\n     // Table type parameter definition -> substituted type\n-    ty_substs: HashMap<Def, hir::Ty>,\n+    ty_substs: FnvHashMap<Def, hir::Ty>,\n     // Table node id of lifetime parameter definition -> substituted lifetime\n-    lt_substs: HashMap<ast::NodeId, hir::Lifetime>,\n+    lt_substs: FnvHashMap<ast::NodeId, hir::Lifetime>,\n }\n \n impl<'a, 'tcx: 'a, 'b: 'tcx> Folder for SubstAlias<'a, 'tcx> {\n@@ -1727,8 +1727,8 @@ impl Clean<Type> for hir::Ty {\n                                 let item = tcx.map.expect_item(node_id);\n                                 if let hir::ItemTy(ref ty, ref generics) = item.node {\n                                     let provided_params = &path.segments.last().unwrap().parameters;\n-                                    let mut ty_substs = HashMap::new();\n-                                    let mut lt_substs = HashMap::new();\n+                                    let mut ty_substs = FnvHashMap();\n+                                    let mut lt_substs = FnvHashMap();\n                                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n                                         let ty_param_def = tcx.expect_def(ty_param.id);\n                                         if let Some(ty) = provided_params.types().get(i).cloned()\n@@ -2384,7 +2384,7 @@ impl Clean<ImplPolarity> for hir::ImplPolarity {\n pub struct Impl {\n     pub unsafety: hir::Unsafety,\n     pub generics: Generics,\n-    pub provided_trait_methods: HashSet<String>,\n+    pub provided_trait_methods: FnvHashSet<String>,\n     pub trait_: Option<Type>,\n     pub for_: Type,\n     pub items: Vec<Item>,\n@@ -2410,7 +2410,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                    .map(|meth| meth.name.to_string())\n                    .collect()\n             })\n-        }).unwrap_or(HashSet::new());\n+        }).unwrap_or(FnvHashSet());\n \n         ret.push(Item {\n             name: None,"}, {"sha": "26f792a1fdf99c14e249952d67f522929ae208b4", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -18,6 +18,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n+use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -28,7 +29,6 @@ use errors;\n use errors::emitter::ColorConfig;\n \n use std::cell::{RefCell, Cell};\n-use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n \n use visit_ast::RustdocVisitor;\n@@ -45,13 +45,13 @@ pub enum MaybeTyped<'a, 'tcx: 'a> {\n     NotTyped(&'a session::Session)\n }\n \n-pub type ExternalPaths = HashMap<DefId, (Vec<String>, clean::TypeKind)>;\n+pub type ExternalPaths = FnvHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n     pub map: &'a hir_map::Map<'tcx>,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n-    pub populated_crate_impls: RefCell<HashSet<ast::CrateNum>>,\n+    pub populated_crate_impls: RefCell<FnvHashSet<ast::CrateNum>>,\n     pub deref_trait_did: Cell<Option<DefId>>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -61,7 +61,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n-    pub external_traits: RefCell<HashMap<DefId, clean::Trait>>,\n+    pub external_traits: RefCell<FnvHashMap<DefId, clean::Trait>>,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -178,10 +178,10 @@ pub fn run_core(search_paths: SearchPaths,\n             map: &tcx.map,\n             maybe_typed: Typed(tcx),\n             input: input,\n-            populated_crate_impls: RefCell::new(HashSet::new()),\n+            populated_crate_impls: RefCell::new(FnvHashSet()),\n             deref_trait_did: Cell::new(None),\n             access_levels: RefCell::new(access_levels),\n-            external_traits: RefCell::new(HashMap::new()),\n+            external_traits: RefCell::new(FnvHashMap()),\n             renderinfo: RefCell::new(Default::default()),\n         };\n         debug!(\"crate: {:?}\", ctxt.map.krate());"}, {"sha": "5cb5cc051870b41c64dd23ddbca21a258668f257", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -37,7 +37,7 @@ pub use self::ExternalLocation::*;\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n-use std::collections::{BTreeMap, HashMap, HashSet};\n+use std::collections::BTreeMap;\n use std::default::Default;\n use std::error;\n use std::fmt::{self, Display, Formatter};\n@@ -61,6 +61,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n use rustc::hir;\n+use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n \n use clean::{self, Attributes, GetDefId};\n use doctree;\n@@ -114,9 +115,9 @@ pub struct SharedContext {\n     /// `true`.\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n-    pub local_sources: HashMap<PathBuf, String>,\n+    pub local_sources: FnvHashMap<PathBuf, String>,\n     /// All the passes that were run on this crate.\n-    pub passes: HashSet<String>,\n+    pub passes: FnvHashSet<String>,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n     /// an issue number.\n     pub issue_tracker_base_url: Option<String>,\n@@ -211,43 +212,43 @@ pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n     /// painfully maintain a context like this)\n-    pub typarams: HashMap<DefId, String>,\n+    pub typarams: FnvHashMap<DefId, String>,\n \n     /// Maps a type id to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<DefId, Vec<Impl>>,\n+    pub impls: FnvHashMap<DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: HashMap<DefId, (Vec<String>, ItemType)>,\n+    pub paths: FnvHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: HashMap<DefId, (Vec<String>, ItemType)>,\n+    pub external_paths: FnvHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    pub traits: HashMap<DefId, clean::Trait>,\n+    pub traits: FnvHashMap<DefId, clean::Trait>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: HashMap<DefId, Vec<Implementor>>,\n+    pub implementors: FnvHashMap<DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: HashMap<ast::CrateNum, (String, ExternalLocation)>,\n+    pub extern_locations: FnvHashMap<ast::CrateNum, (String, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: HashMap<clean::PrimitiveType, ast::CrateNum>,\n+    pub primitive_locations: FnvHashMap<clean::PrimitiveType, ast::CrateNum>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -260,7 +261,7 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n-    seen_modules: HashSet<DefId>,\n+    seen_modules: FnvHashSet<DefId>,\n     seen_mod: bool,\n     stripped_mod: bool,\n     deref_trait_did: Option<DefId>,\n@@ -277,9 +278,9 @@ pub struct Cache {\n /// Later on moved into `CACHE_KEY`.\n #[derive(Default)]\n pub struct RenderInfo {\n-    pub inlined: HashSet<DefId>,\n+    pub inlined: FnvHashSet<DefId>,\n     pub external_paths: ::core::ExternalPaths,\n-    pub external_typarams: HashMap<DefId, String>,\n+    pub external_typarams: FnvHashMap<DefId, String>,\n     pub deref_trait_did: Option<DefId>,\n }\n \n@@ -377,10 +378,10 @@ impl ToJson for IndexItemFunctionType {\n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n                     RefCell::new(Vec::new()));\n-thread_local!(static USED_ID_MAP: RefCell<HashMap<String, usize>> =\n+thread_local!(static USED_ID_MAP: RefCell<FnvHashMap<String, usize>> =\n                     RefCell::new(init_ids()));\n \n-fn init_ids() -> HashMap<String, usize> {\n+fn init_ids() -> FnvHashMap<String, usize> {\n     [\n      \"main\",\n      \"search\",\n@@ -407,7 +408,7 @@ pub fn reset_ids(embedded: bool) {\n         *s.borrow_mut() = if embedded {\n             init_ids()\n         } else {\n-            HashMap::new()\n+            FnvHashMap()\n         };\n     });\n }\n@@ -432,7 +433,7 @@ pub fn derive_id(candidate: String) -> String {\n pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n            dst: PathBuf,\n-           passes: HashSet<String>,\n+           passes: FnvHashSet<String>,\n            css_file_extension: Option<PathBuf>,\n            renderinfo: RenderInfo) -> Result<(), Error> {\n     let src_root = match krate.src.parent() {\n@@ -443,7 +444,7 @@ pub fn run(mut krate: clean::Crate,\n         src_root: src_root,\n         passes: passes,\n         include_sources: true,\n-        local_sources: HashMap::new(),\n+        local_sources: FnvHashMap(),\n         issue_tracker_base_url: None,\n         layout: layout::Layout {\n             logo: \"\".to_string(),\n@@ -513,22 +514,22 @@ pub fn run(mut krate: clean::Crate,\n         .collect();\n \n     let mut cache = Cache {\n-        impls: HashMap::new(),\n+        impls: FnvHashMap(),\n         external_paths: external_paths,\n-        paths: HashMap::new(),\n-        implementors: HashMap::new(),\n+        paths: FnvHashMap(),\n+        implementors: FnvHashMap(),\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n         search_index: Vec::new(),\n         parent_is_trait_impl: false,\n-        extern_locations: HashMap::new(),\n-        primitive_locations: HashMap::new(),\n-        seen_modules: HashSet::new(),\n+        extern_locations: FnvHashMap(),\n+        primitive_locations: FnvHashMap(),\n+        seen_modules: FnvHashSet(),\n         seen_mod: false,\n         stripped_mod: false,\n         access_levels: krate.access_levels.clone(),\n         orphan_methods: Vec::new(),\n-        traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n+        traits: mem::replace(&mut krate.external_traits, FnvHashMap()),\n         deref_trait_did: deref_trait_did,\n         typarams: external_typarams,\n     };\n@@ -574,7 +575,7 @@ pub fn run(mut krate: clean::Crate,\n \n /// Build the search index from the collected metadata\n fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n-    let mut nodeid_to_pathid = HashMap::new();\n+    let mut nodeid_to_pathid = FnvHashMap();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = Vec::<Json>::new();\n \n@@ -2515,7 +2516,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n #[derive(Copy, Clone)]\n enum AssocItemLink<'a> {\n     Anchor(Option<&'a str>),\n-    GotoSource(DefId, &'a HashSet<String>),\n+    GotoSource(DefId, &'a FnvHashSet<String>),\n }\n \n impl<'a> AssocItemLink<'a> {"}, {"sha": "e7edf8d1cabe28ff8c4b3fbdb1620de8fbccadf4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::cell::{RefCell, Cell};\n-use std::collections::{HashMap, HashSet};\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n@@ -29,6 +28,7 @@ use rustc::session::{self, config};\n use rustc::session::config::{get_unstable_features_setting, OutputType,\n                              OutputTypes, Externs};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n+use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n@@ -107,8 +107,8 @@ pub fn run(input: &str,\n         map: &map,\n         maybe_typed: core::NotTyped(&sess),\n         input: input,\n-        external_traits: RefCell::new(HashMap::new()),\n-        populated_crate_impls: RefCell::new(HashSet::new()),\n+        external_traits: RefCell::new(FnvHashMap()),\n+        populated_crate_impls: RefCell::new(FnvHashSet()),\n         deref_trait_did: Cell::new(None),\n         access_levels: Default::default(),\n         renderinfo: Default::default(),"}, {"sha": "f6084180f0bd1814c5bb88cc071bbb0f437826d0", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4791e086d671d429db864787f6b60547a28b0f5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e4791e086d671d429db864787f6b60547a28b0f5", "patch": "@@ -11,7 +11,6 @@\n //! Rust AST Visitor. Extracts useful information and massages it into a form\n //! usable for clean\n \n-use std::collections::HashSet;\n use std::mem;\n \n use syntax::abi;\n@@ -23,6 +22,7 @@ use syntax_pos::Span;\n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n use rustc::middle::privacy::AccessLevel;\n+use rustc::util::nodemap::FnvHashSet;\n \n use rustc::hir;\n \n@@ -42,14 +42,14 @@ pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n-    view_item_stack: HashSet<ast::NodeId>,\n+    view_item_stack: FnvHashSet<ast::NodeId>,\n     inlining_from_glob: bool,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn new(cx: &'a core::DocContext<'a, 'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is reexported, terminate all recursion.\n-        let mut stack = HashSet::new();\n+        let mut stack = FnvHashSet();\n         stack.insert(ast::CRATE_NODE_ID);\n         RustdocVisitor {\n             module: Module::new(None),"}]}