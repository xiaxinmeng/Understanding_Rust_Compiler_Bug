{"sha": "2f221c766b10867a30d799d0899125b2dcccb872", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMjIxYzc2NmIxMDg2N2EzMGQ3OTlkMDg5OTEyNWIyZGNjY2I4NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-31T14:56:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-31T14:56:39Z"}, "message": "auto merge of #14563 : dotdash/rust/clone_kill, r=huonw\n\nBy dropping the intermediate vector that holds the relevant candidates\r\nincluding duplicates and directly building the vector that has the\r\nduplicates removed we can eliminate quite a few allocations. This\r\nreduces the times for type checking by 5-10% (measured with libstd,\r\nlibsyntax and librustc).", "tree": {"sha": "f0cad347ce5b9bc8d461fc2eb94949e4ee4c3a9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0cad347ce5b9bc8d461fc2eb94949e4ee4c3a9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f221c766b10867a30d799d0899125b2dcccb872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f221c766b10867a30d799d0899125b2dcccb872", "html_url": "https://github.com/rust-lang/rust/commit/2f221c766b10867a30d799d0899125b2dcccb872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f221c766b10867a30d799d0899125b2dcccb872/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0839e940a517fcf6cf8124b22399e75c31703e2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0839e940a517fcf6cf8124b22399e75c31703e2c", "html_url": "https://github.com/rust-lang/rust/commit/0839e940a517fcf6cf8124b22399e75c31703e2c"}, {"sha": "cd844c5fb54913bced99a046230e9af7b3704c9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd844c5fb54913bced99a046230e9af7b3704c9e", "html_url": "https://github.com/rust-lang/rust/commit/cd844c5fb54913bced99a046230e9af7b3704c9e"}], "stats": {"total": 44, "additions": 10, "deletions": 34}, "files": [{"sha": "9afb5b48be5ec181a5143d832f2d61ceefbdaf97", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2f221c766b10867a30d799d0899125b2dcccb872/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f221c766b10867a30d799d0899125b2dcccb872/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2f221c766b10867a30d799d0899125b2dcccb872", "patch": "@@ -1026,13 +1026,7 @@ impl<'a> LookupContext<'a> {\n     fn consider_candidates(&self, rcvr_ty: ty::t,\n                            candidates: &[Candidate])\n                            -> Option<MethodCallee> {\n-        // FIXME(pcwalton): Do we need to clone here?\n-        let relevant_candidates: Vec<Candidate> =\n-            candidates.iter().map(|c| (*c).clone()).\n-                filter(|c| self.is_relevant(rcvr_ty, c)).collect();\n-\n-        let relevant_candidates =\n-            self.merge_candidates(relevant_candidates.as_slice());\n+        let relevant_candidates = self.filter_candidates(rcvr_ty, candidates);\n \n         if relevant_candidates.len() == 0 {\n             return None;\n@@ -1069,22 +1063,16 @@ impl<'a> LookupContext<'a> {\n         Some(self.confirm_candidate(rcvr_ty, relevant_candidates.get(0)))\n     }\n \n-    fn merge_candidates(&self, candidates: &[Candidate]) -> Vec<Candidate> {\n-        let mut merged = Vec::new();\n-        let mut i = 0;\n-        while i < candidates.len() {\n-            let candidate_a = &candidates[i];\n-\n-            let mut skip = false;\n+    fn filter_candidates(&self, rcvr_ty: ty::t, candidates: &[Candidate]) -> Vec<Candidate> {\n+        let mut relevant_candidates: Vec<Candidate> = Vec::new();\n \n-            let mut j = i + 1;\n-            while j < candidates.len() {\n-                let candidate_b = &candidates[j];\n+        for candidate_a in candidates.iter().filter(|&c| self.is_relevant(rcvr_ty, c)) {\n+            // Skip this one if we already have one like it\n+            if !relevant_candidates.iter().any(|candidate_b| {\n                 debug!(\"attempting to merge {} and {}\",\n                        candidate_a.repr(self.tcx()),\n                        candidate_b.repr(self.tcx()));\n-                let candidates_same = match (&candidate_a.origin,\n-                                             &candidate_b.origin) {\n+                match (&candidate_a.origin, &candidate_b.origin) {\n                     (&MethodParam(ref p1), &MethodParam(ref p2)) => {\n                         let same_trait = p1.trait_id == p2.trait_id;\n                         let same_method = p1.method_num == p2.method_num;\n@@ -1095,25 +1083,13 @@ impl<'a> LookupContext<'a> {\n                         same_trait && same_method && same_param\n                     }\n                     _ => false\n-                };\n-                if candidates_same {\n-                    skip = true;\n-                    break;\n                 }\n-                j += 1;\n-            }\n-\n-            i += 1;\n-\n-            if skip {\n-                // There are more than one of these and we need only one\n-                continue;\n-            } else {\n-                merged.push(candidate_a.clone());\n+            }) {\n+                relevant_candidates.push(candidate_a.clone());\n             }\n         }\n \n-        return merged;\n+        relevant_candidates\n     }\n \n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)"}]}