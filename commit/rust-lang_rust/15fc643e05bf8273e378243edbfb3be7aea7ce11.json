{"sha": "15fc643e05bf8273e378243edbfb3be7aea7ce11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZmM2NDNlMDViZjgyNzNlMzc4MjQzZWRiZmIzYmU3YWVhN2NlMTE=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-01-10T17:26:18Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-01-11T22:33:04Z"}, "message": "Fix ordering problem between qualifying paths and substituting params", "tree": {"sha": "9b5bad379840dd25b548158ad962fadd31c54d33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b5bad379840dd25b548158ad962fadd31c54d33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15fc643e05bf8273e378243edbfb3be7aea7ce11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15fc643e05bf8273e378243edbfb3be7aea7ce11", "html_url": "https://github.com/rust-lang/rust/commit/15fc643e05bf8273e378243edbfb3be7aea7ce11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15fc643e05bf8273e378243edbfb3be7aea7ce11/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12905e5b58f22df026ef30afa6f0bdf7319cbddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/12905e5b58f22df026ef30afa6f0bdf7319cbddd", "html_url": "https://github.com/rust-lang/rust/commit/12905e5b58f22df026ef30afa6f0bdf7319cbddd"}], "stats": {"total": 332, "additions": 206, "deletions": 126}, "files": [{"sha": "bf1136193d376fde8a4e34172d497e639393c0b7", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 8, "deletions": 113, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=15fc643e05bf8273e378243edbfb3be7aea7ce11", "patch": "@@ -1,12 +1,13 @@\n-use std::collections::HashMap;\n-\n-use hir::{db::HirDatabase, HasSource};\n+use hir::{db::HirDatabase, HasSource, InFile};\n use ra_syntax::{\n     ast::{self, edit, make, AstNode, NameOwner},\n     SmolStr,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n+    Assist, AssistCtx, AssistId,\n+};\n \n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {\n@@ -146,24 +147,11 @@ fn add_missing_impl_members_inner(\n             None,\n         )\n         .module();\n-        let substs = get_syntactic_substs(impl_node).unwrap_or_default();\n-        let generic_def: hir::GenericDef = trait_.into();\n-        let substs_by_param: HashMap<_, _> = generic_def\n-            .params(db)\n-            .into_iter()\n-            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n-            .skip(1)\n-            .zip(substs.into_iter())\n-            .collect();\n+        let ast_transform = QualifyPaths::new(db, module)\n+            .or(SubstituteTypeParams::for_trait_impl(db, trait_, impl_node));\n         let items = missing_items\n             .into_iter()\n-            .map(|it| {\n-                substitute_type_params(db, hir::InFile::new(trait_file_id, it), &substs_by_param)\n-            })\n-            .map(|it| match module {\n-                Some(module) => qualify_paths(db, hir::InFile::new(trait_file_id, it), module),\n-                None => it,\n-            })\n+            .map(|it| ast_transform::apply(&*ast_transform, InFile::new(trait_file_id, it)))\n             .map(|it| match it {\n                 ast::ImplItem::FnDef(def) => ast::ImplItem::FnDef(add_body(def)),\n                 _ => it,\n@@ -188,99 +176,6 @@ fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n     }\n }\n \n-// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n-// trait ref, and then go from the types in the substs back to the syntax)\n-// FIXME: This should be a general utility (not even just for assists)\n-fn get_syntactic_substs(impl_block: ast::ImplBlock) -> Option<Vec<ast::TypeRef>> {\n-    let target_trait = impl_block.target_trait()?;\n-    let path_type = match target_trait {\n-        ast::TypeRef::PathType(path) => path,\n-        _ => return None,\n-    };\n-    let type_arg_list = path_type.path()?.segment()?.type_arg_list()?;\n-    let mut result = Vec::new();\n-    for type_arg in type_arg_list.type_args() {\n-        let type_arg: ast::TypeArg = type_arg;\n-        result.push(type_arg.type_ref()?);\n-    }\n-    Some(result)\n-}\n-\n-// FIXME: This should be a general utility (not even just for assists)\n-fn substitute_type_params<N: AstNode + Clone>(\n-    db: &impl HirDatabase,\n-    node: hir::InFile<N>,\n-    substs: &HashMap<hir::TypeParam, ast::TypeRef>,\n-) -> N {\n-    let type_param_replacements = node\n-        .clone()\n-        .descendants::<ast::TypeRef>()\n-        .filter_map(|n| {\n-            let path = match &n.value {\n-                ast::TypeRef::PathType(path_type) => path_type.path()?,\n-                _ => return None,\n-            };\n-            let analyzer = hir::SourceAnalyzer::new(db, n.syntax(), None);\n-            let resolution = analyzer.resolve_path(db, &path)?;\n-            match resolution {\n-                hir::PathResolution::TypeParam(tp) => Some((n.value, substs.get(&tp)?.clone())),\n-                _ => None,\n-            }\n-        })\n-        .collect::<Vec<_>>();\n-\n-    if type_param_replacements.is_empty() {\n-        node.value\n-    } else {\n-        edit::replace_descendants(&node.value, type_param_replacements.into_iter())\n-    }\n-}\n-\n-use hir::PathResolution;\n-\n-// FIXME extract this to a general utility as well\n-// FIXME handle value ns?\n-// FIXME this doesn't 'commute' with `substitute_type_params`, since type params in newly generated type arg lists don't resolve. Currently we can avoid this problem, but it's worth thinking about a solution\n-fn qualify_paths<N: AstNode>(db: &impl HirDatabase, node: hir::InFile<N>, from: hir::Module) -> N {\n-    let path_replacements = node\n-        .value\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::Path::cast)\n-        .filter_map(|p| {\n-            if p.segment().and_then(|s| s.param_list()).is_some() {\n-                // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n-                return None;\n-            }\n-            // FIXME check if some ancestor is already being replaced, if so skip this\n-            let analyzer = hir::SourceAnalyzer::new(db, node.with_value(p.syntax()), None);\n-            let resolution = analyzer.resolve_path(db, &p)?;\n-            match resolution {\n-                PathResolution::Def(def) => {\n-                    let found_path = from.find_path(db, def)?;\n-                    // TODO fix type arg replacements being qualified\n-                    let args = p\n-                        .segment()\n-                        .and_then(|s| s.type_arg_list())\n-                        .map(|arg_list| qualify_paths(db, node.with_value(arg_list), from));\n-                    Some((p, make::path_with_type_arg_list(found_path.to_ast(), args)))\n-                }\n-                PathResolution::Local(_)\n-                | PathResolution::TypeParam(_)\n-                | PathResolution::SelfType(_) => None,\n-                PathResolution::Macro(_) => None,\n-                PathResolution::AssocItem(_) => None,\n-            }\n-        })\n-        .collect::<Vec<_>>();\n-\n-    if path_replacements.is_empty() {\n-        node.value\n-    } else {\n-        edit::replace_descendants(&node.value, path_replacements.into_iter())\n-    }\n-}\n-\n /// Given an `ast::ImplBlock`, resolves the target trait (the one being\n /// implemented) to a `ast::TraitDef`.\n fn resolve_target_trait_def("}, {"sha": "846661587813544fcb02324da2e7011d76d36ecf", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=15fc643e05bf8273e378243edbfb3be7aea7ce11", "patch": "@@ -0,0 +1,178 @@\n+//! `AstTransformer`s are functions that replace nodes in an AST and can be easily combined.\n+use std::collections::HashMap;\n+\n+use hir::{db::HirDatabase, InFile, PathResolution};\n+use ra_syntax::ast::{self, make, AstNode};\n+\n+pub trait AstTransform<'a> {\n+    fn get_substitution(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode>;\n+\n+    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a>;\n+    fn or<T: AstTransform<'a> + 'a>(self, other: T) -> Box<dyn AstTransform<'a> + 'a>\n+    where\n+        Self: Sized + 'a,\n+    {\n+        self.chain_before(Box::new(other))\n+    }\n+}\n+\n+struct NullTransformer;\n+\n+impl<'a> AstTransform<'a> for NullTransformer {\n+    fn get_substitution(\n+        &self,\n+        _node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        None\n+    }\n+    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n+        other\n+    }\n+}\n+\n+pub struct SubstituteTypeParams<'a, DB: HirDatabase> {\n+    db: &'a DB,\n+    substs: HashMap<hir::TypeParam, ast::TypeRef>,\n+    previous: Box<dyn AstTransform<'a> + 'a>,\n+}\n+\n+impl<'a, DB: HirDatabase> SubstituteTypeParams<'a, DB> {\n+    pub fn for_trait_impl(\n+        db: &'a DB,\n+        trait_: hir::Trait,\n+        impl_block: ast::ImplBlock,\n+    ) -> SubstituteTypeParams<'a, DB> {\n+        let substs = get_syntactic_substs(impl_block).unwrap_or_default();\n+        let generic_def: hir::GenericDef = trait_.into();\n+        let substs_by_param: HashMap<_, _> = generic_def\n+            .params(db)\n+            .into_iter()\n+            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n+            .skip(1)\n+            .zip(substs.into_iter())\n+            .collect();\n+        return SubstituteTypeParams {\n+            db,\n+            substs: substs_by_param,\n+            previous: Box::new(NullTransformer),\n+        };\n+\n+        fn get_syntactic_substs(impl_block: ast::ImplBlock) -> Option<Vec<ast::TypeRef>> {\n+            let target_trait = impl_block.target_trait()?;\n+            let path_type = match target_trait {\n+                ast::TypeRef::PathType(path) => path,\n+                _ => return None,\n+            };\n+            let type_arg_list = path_type.path()?.segment()?.type_arg_list()?;\n+            let mut result = Vec::new();\n+            for type_arg in type_arg_list.type_args() {\n+                let type_arg: ast::TypeArg = type_arg;\n+                result.push(type_arg.type_ref()?);\n+            }\n+            Some(result)\n+        }\n+    }\n+    fn get_substitution_inner(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        let type_ref = ast::TypeRef::cast(node.value.clone())?;\n+        let path = match &type_ref {\n+            ast::TypeRef::PathType(path_type) => path_type.path()?,\n+            _ => return None,\n+        };\n+        let analyzer = hir::SourceAnalyzer::new(self.db, node, None);\n+        let resolution = analyzer.resolve_path(self.db, &path)?;\n+        match resolution {\n+            hir::PathResolution::TypeParam(tp) => Some(self.substs.get(&tp)?.syntax().clone()),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl<'a, DB: HirDatabase> AstTransform<'a> for SubstituteTypeParams<'a, DB> {\n+    fn get_substitution(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n+    }\n+    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n+        Box::new(SubstituteTypeParams { previous: other, ..self })\n+    }\n+}\n+\n+pub struct QualifyPaths<'a, DB: HirDatabase> {\n+    db: &'a DB,\n+    from: Option<hir::Module>,\n+    previous: Box<dyn AstTransform<'a> + 'a>,\n+}\n+\n+impl<'a, DB: HirDatabase> QualifyPaths<'a, DB> {\n+    pub fn new(db: &'a DB, from: Option<hir::Module>) -> Self {\n+        Self { db, from, previous: Box::new(NullTransformer) }\n+    }\n+\n+    fn get_substitution_inner(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        // FIXME handle value ns?\n+        let from = self.from?;\n+        let p = ast::Path::cast(node.value.clone())?;\n+        if p.segment().and_then(|s| s.param_list()).is_some() {\n+            // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n+            return None;\n+        }\n+        let analyzer = hir::SourceAnalyzer::new(self.db, node, None);\n+        let resolution = analyzer.resolve_path(self.db, &p)?;\n+        match resolution {\n+            PathResolution::Def(def) => {\n+                let found_path = from.find_path(self.db, def)?;\n+                let args = p\n+                    .segment()\n+                    .and_then(|s| s.type_arg_list())\n+                    .map(|arg_list| apply(self, node.with_value(arg_list)));\n+                Some(make::path_with_type_arg_list(found_path.to_ast(), args).syntax().clone())\n+            }\n+            PathResolution::Local(_)\n+            | PathResolution::TypeParam(_)\n+            | PathResolution::SelfType(_) => None,\n+            PathResolution::Macro(_) => None,\n+            PathResolution::AssocItem(_) => None,\n+        }\n+    }\n+}\n+\n+pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: InFile<N>) -> N {\n+    let syntax = node.value.syntax();\n+    let result = ra_syntax::algo::replace_descendants(syntax, &|element| match element {\n+        ra_syntax::SyntaxElement::Node(n) => {\n+            let replacement = transformer.get_substitution(node.with_value(&n))?;\n+            Some(replacement.into())\n+        }\n+        _ => None,\n+    });\n+    N::cast(result).unwrap()\n+}\n+\n+impl<'a, DB: HirDatabase> AstTransform<'a> for QualifyPaths<'a, DB> {\n+    fn get_substitution(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n+    }\n+    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n+        Box::new(QualifyPaths { previous: other, ..self })\n+    }\n+}\n+\n+// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n+// trait ref, and then go from the types in the substs back to the syntax)\n+// FIXME: This should be a general utility (not even just for assists)\n+\n+// FIXME: This should be a general utility (not even just for assists)"}, {"sha": "712ff6f6a5f84daceb70029fd55e1d77d597fe54", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=15fc643e05bf8273e378243edbfb3be7aea7ce11", "patch": "@@ -11,6 +11,7 @@ mod marks;\n mod doc_tests;\n #[cfg(test)]\n mod test_db;\n+pub mod ast_transform;\n \n use hir::db::HirDatabase;\n use ra_db::FileRange;"}, {"sha": "0f7b6e875f7dc86ae78514df9df4c9dc0d9ceef6", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=15fc643e05bf8273e378243edbfb3be7aea7ce11", "patch": "@@ -7,8 +7,7 @@ use rustc_hash::FxHashMap;\n \n use ra_syntax::{\n     algo::{find_node_at_offset, replace_descendants},\n-    ast::{self},\n-    AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T,\n+    ast, AstNode, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, WalkEvent, T,\n };\n \n pub struct ExpandedMacro {\n@@ -43,7 +42,7 @@ fn expand_macro_recur(\n     let mut expanded: SyntaxNode = db.parse_or_expand(macro_file_id)?;\n \n     let children = expanded.descendants().filter_map(ast::MacroCall::cast);\n-    let mut replaces = FxHashMap::default();\n+    let mut replaces: FxHashMap<SyntaxElement, SyntaxElement> = FxHashMap::default();\n \n     for child in children.into_iter() {\n         let node = hir::InFile::new(macro_file_id, &child);\n@@ -59,7 +58,7 @@ fn expand_macro_recur(\n         }\n     }\n \n-    Some(replace_descendants(&expanded, &replaces))\n+    Some(replace_descendants(&expanded, &|n| replaces.get(n).cloned()))\n }\n \n // FIXME: It would also be cool to share logic here and in the mbe tests,"}, {"sha": "30a479f015fcbd838fb17bb62436dc063de9f697", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=15fc643e05bf8273e378243edbfb3be7aea7ce11", "patch": "@@ -184,17 +184,17 @@ pub fn replace_children(\n /// to create a type-safe abstraction on top of it instead.\n pub fn replace_descendants(\n     parent: &SyntaxNode,\n-    map: &FxHashMap<SyntaxElement, SyntaxElement>,\n+    map: &impl Fn(&SyntaxElement) -> Option<SyntaxElement>,\n ) -> SyntaxNode {\n     //  FIXME: this could be made much faster.\n     let new_children = parent.children_with_tokens().map(|it| go(map, it)).collect::<Vec<_>>();\n     return with_children(parent, new_children);\n \n     fn go(\n-        map: &FxHashMap<SyntaxElement, SyntaxElement>,\n+        map: &impl Fn(&SyntaxElement) -> Option<SyntaxElement>,\n         element: SyntaxElement,\n     ) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n-        if let Some(replacement) = map.get(&element) {\n+        if let Some(replacement) = map(&element) {\n             return match replacement {\n                 NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n                 NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),"}, {"sha": "b736098acc0852616ea43ca1f9cf893ee21ac1f0", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=15fc643e05bf8273e378243edbfb3be7aea7ce11", "patch": "@@ -236,8 +236,8 @@ pub fn replace_descendants<N: AstNode, D: AstNode>(\n ) -> N {\n     let map = replacement_map\n         .map(|(from, to)| (from.syntax().clone().into(), to.syntax().clone().into()))\n-        .collect::<FxHashMap<_, _>>();\n-    let new_syntax = algo::replace_descendants(parent.syntax(), &map);\n+        .collect::<FxHashMap<SyntaxElement, _>>();\n+    let new_syntax = algo::replace_descendants(parent.syntax(), &|n| map.get(n).cloned());\n     N::cast(new_syntax).unwrap()\n }\n \n@@ -292,7 +292,7 @@ impl IndentLevel {\n                 )\n             })\n             .collect();\n-        algo::replace_descendants(&node, &replacements)\n+        algo::replace_descendants(&node, &|n| replacements.get(n).cloned())\n     }\n \n     pub fn decrease_indent<N: AstNode>(self, node: N) -> N {\n@@ -320,7 +320,7 @@ impl IndentLevel {\n                 )\n             })\n             .collect();\n-        algo::replace_descendants(&node, &replacements)\n+        algo::replace_descendants(&node, &|n| replacements.get(n).cloned())\n     }\n }\n "}, {"sha": "9781b748f1db028efed90d73c667d79d9f6c056b", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fc643e05bf8273e378243edbfb3be7aea7ce11/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=15fc643e05bf8273e378243edbfb3be7aea7ce11", "patch": "@@ -2,7 +2,7 @@\n //! of smaller pieces.\n use itertools::Itertools;\n \n-use crate::{ast, AstNode, SourceFile};\n+use crate::{algo, ast, AstNode, SourceFile};\n \n pub fn name(text: &str) -> ast::Name {\n     ast_from_text(&format!(\"mod {};\", text))\n@@ -23,7 +23,14 @@ fn path_from_text(text: &str) -> ast::Path {\n }\n pub fn path_with_type_arg_list(path: ast::Path, args: Option<ast::TypeArgList>) -> ast::Path {\n     if let Some(args) = args {\n-        ast_from_text(&format!(\"const X: {}{}\", path.syntax(), args.syntax()))\n+        let syntax = path.syntax();\n+        // FIXME: remove existing type args\n+        let new_syntax = algo::insert_children(\n+            syntax,\n+            crate::algo::InsertPosition::Last,\n+            &mut Some(args).into_iter().map(|n| n.syntax().clone().into()),\n+        );\n+        ast::Path::cast(new_syntax).unwrap()\n     } else {\n         path\n     }"}]}