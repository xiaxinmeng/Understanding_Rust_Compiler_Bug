{"sha": "340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MGU3ZWIyYTczMzBmZDczZTZhZTc0NTY5MGZiN2Q5MmRkYmE0ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-21T15:21:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-21T15:21:09Z"}, "message": "Auto merge of #31024 - oli-obk:move_checks_out_of_librustc, r=arielb1\n\n-    check_const\n-    check_static_recursion\n-    check_loop\n-    check_rvalues\n\nr? @arielb1", "tree": {"sha": "0433ab5d3c83fd6d077d1eb775537a1947d864de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0433ab5d3c83fd6d077d1eb775537a1947d864de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "html_url": "https://github.com/rust-lang/rust/commit/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "038de0f95e35acc6748aa305dff97dea7b814a1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/038de0f95e35acc6748aa305dff97dea7b814a1a", "html_url": "https://github.com/rust-lang/rust/commit/038de0f95e35acc6748aa305dff97dea7b814a1a"}, {"sha": "c124deca7b3d93e72b5d849b392a5bea83eacfb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c124deca7b3d93e72b5d849b392a5bea83eacfb5", "html_url": "https://github.com/rust-lang/rust/commit/c124deca7b3d93e72b5d849b392a5bea83eacfb5"}], "stats": {"total": 1280, "additions": 645, "deletions": 635}, "files": [{"sha": "f47c4857ef86132d99b4a1541430e760de71c1c6", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -102,7 +102,7 @@ DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_metadata := rustc rustc_front syntax rbml\n-DEPS_rustc_passes := syntax rustc core\n+DEPS_rustc_passes := syntax rustc core rustc_front\n DEPS_rustc_mir := rustc rustc_front syntax\n DEPS_rustc_resolve := arena rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm"}, {"sha": "e5942e64a9e409dab00e72c6cc4fa7ec4bd12d4a", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 540, "changes": 540, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -215,187 +215,6 @@ match x {\n ```\n \"##,\n \n-E0010: r##\"\n-The value of statics and constants must be known at compile time, and they live\n-for the entire lifetime of a program. Creating a boxed value allocates memory on\n-the heap at runtime, and therefore cannot be done at compile time. Erroneous\n-code example:\n-\n-```\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n-```\n-\"##,\n-\n-E0011: r##\"\n-Initializers for constants and statics are evaluated at compile time.\n-User-defined operators rely on user-defined functions, which cannot be evaluated\n-at compile time.\n-\n-Bad example:\n-\n-```\n-use std::ops::Index;\n-\n-struct Foo { a: u8 }\n-\n-impl Index<u8> for Foo {\n-    type Output = u8;\n-\n-    fn index<'a>(&'a self, idx: u8) -> &'a u8 { &self.a }\n-}\n-\n-const a: Foo = Foo { a: 0u8 };\n-const b: u8 = a[0]; // Index trait is defined by the user, bad!\n-```\n-\n-Only operators on builtin types are allowed.\n-\n-Example:\n-\n-```\n-const a: &'static [i32] = &[1, 2, 3];\n-const b: i32 = a[0]; // Good!\n-```\n-\"##,\n-\n-E0013: r##\"\n-Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable. For example, `Y` cannot refer to `X`\n-here:\n-\n-```\n-static X: i32 = 42;\n-const Y: i32 = X;\n-```\n-\n-To fix this, the value can be extracted as a const and then used:\n-\n-```\n-const A: i32 = 42;\n-static X: i32 = A;\n-const Y: i32 = A;\n-```\n-\"##,\n-\n-E0014: r##\"\n-Constants can only be initialized by a constant value or, in a future\n-version of Rust, a call to a const function. This error indicates the use\n-of a path (like a::b, or x) denoting something other than one of these\n-allowed items. Example:\n-\n-```\n-const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!\n-```\n-\n-To avoid it, you have to replace the non-constant value:\n-\n-```\n-const FOO: i32 = { const X : i32 = 0; X };\n-// or even:\n-const FOO: i32 = { 0 }; // but brackets are useless here\n-```\n-\"##,\n-\n-// FIXME(#24111) Change the language here when const fn stabilizes\n-E0015: r##\"\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n-\n-```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n-```\n-\n-See [RFC 911] for more details on the design of `const fn`s.\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0017: r##\"\n-References in statics and constants may only refer to immutable values. Example:\n-\n-```\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &'static mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`.\n-\"##,\n-\n-E0018: r##\"\n-The value of static and const variables must be known at compile time. You\n-can't cast a pointer as an integer because we can't know what value the\n-address will take.\n-\n-However, pointers to other constants' addresses are allowed in constants,\n-example:\n-\n-```\n-const X: u32 = 50;\n-const Y: *const u32 = &X;\n-```\n-\n-Therefore, casting one of these non-constant pointers to an integer results\n-in a non-constant integer which lead to this error. Example:\n-\n-```\n-const X: u32 = 1;\n-const Y: usize = &X as *const u32 as usize;\n-println!(\"{}\", Y);\n-```\n-\"##,\n-\n-E0019: r##\"\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time. Example of\n-erroneous code:\n-\n-```\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn test(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    const A: i32 = FOO.test(); // You can't call Test::func() here !\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```\n-\"##,\n-\n E0020: r##\"\n This error indicates that an attempt was made to divide by zero (or take the\n remainder of a zero divisor) in a static or constant expression. Erroneous\n@@ -407,24 +226,6 @@ const X: i32 = 42 / 0;\n ```\n \"##,\n \n-E0030: r##\"\n-When matching against a range, the compiler verifies that the range is\n-non-empty.  Range patterns include both end-points, so this is equivalent to\n-requiring the start of the range to be less than or equal to the end of the\n-range.\n-\n-For example:\n-\n-```\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 ... 1 => ...\n-    // This range is empty, and the compiler can tell.\n-    1000 ... 5 => ...\n-}\n-```\n-\"##,\n-\n E0038: r####\"\n Trait objects like `Box<Trait>` can only be constructed when certain\n requirements are satisfied by the trait in question.\n@@ -902,14 +703,6 @@ match Some(42) {\n ```\n \"##,\n \n-E0161: r##\"\n-In Rust, you can only move a value when its size is known at compile time.\n-\n-To work around this restriction, consider \"hiding\" the value behind a reference:\n-either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n-it around as usual.\n-\"##,\n-\n E0162: r##\"\n An if-let pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n@@ -1101,67 +894,6 @@ extern \"C\" {\n ```\n \"##,\n \n-E0265: r##\"\n-This error indicates that a static or constant references itself.\n-All statics and constants need to resolve to a value in an acyclic manner.\n-\n-For example, neither of the following can be sensibly compiled:\n-\n-```\n-const X: u32 = X;\n-```\n-\n-```\n-const X: u32 = Y;\n-const Y: u32 = X;\n-```\n-\"##,\n-\n-E0267: r##\"\n-This error indicates the use of a loop keyword (`break` or `continue`) inside a\n-closure but outside of any loop. Erroneous code example:\n-\n-```\n-let w = || { break; }; // error: `break` inside of a closure\n-```\n-\n-`break` and `continue` keywords can be used as normal inside closures as long as\n-they are also contained within a loop. To halt the execution of a closure you\n-should instead use a return statement. Example:\n-\n-```\n-let w = || {\n-    for _ in 0..10 {\n-        break;\n-    }\n-};\n-\n-w();\n-```\n-\"##,\n-\n-E0268: r##\"\n-This error indicates the use of a loop keyword (`break` or `continue`) outside\n-of a loop. Without a loop to break out of or continue in, no sensible action can\n-be taken. Erroneous code example:\n-\n-```\n-fn some_func() {\n-    break; // error: `break` outside of loop\n-}\n-```\n-\n-Please verify that you are using `break` and `continue` only in loops. Example:\n-\n-```\n-fn some_func() {\n-    for _ in 0..10 {\n-        break; // ok!\n-    }\n-}\n-```\n-\"##,\n-\n E0269: r##\"\n Functions must eventually return a value of their return type. For example, in\n the following function\n@@ -1892,104 +1624,6 @@ struct Foo<T: 'static> {\n ```\n \"##,\n \n-E0378: r##\"\n-Method calls that aren't calls to inherent `const` methods are disallowed\n-in statics, constants, and constant functions.\n-\n-For example:\n-\n-```\n-const BAZ: i32 = Foo(25).bar(); // error, `bar` isn't `const`\n-\n-struct Foo(i32);\n-\n-impl Foo {\n-    const fn foo(&self) -> i32 {\n-        self.bar() // error, `bar` isn't `const`\n-    }\n-\n-    fn bar(&self) -> i32 { self.0 }\n-}\n-```\n-\n-For more information about `const fn`'s, see [RFC 911].\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0394: r##\"\n-From [RFC 246]:\n-\n- > It is invalid for a static to reference another static by value. It is\n- > required that all references be borrowed.\n-\n-[RFC 246]: https://github.com/rust-lang/rfcs/pull/246\n-\"##,\n-\n-E0395: r##\"\n-The value assigned to a constant expression must be known at compile time,\n-which is not the case when comparing raw pointers. Erroneous code example:\n-\n-```\n-static foo: i32 = 42;\n-static bar: i32 = 43;\n-\n-static baz: bool = { (&foo as *const i32) == (&bar as *const i32) };\n-// error: raw pointers cannot be compared in statics!\n-```\n-\n-Please check that the result of the comparison can be determined at compile time\n-or isn't assigned to a constant expression. Example:\n-\n-```\n-static foo: i32 = 42;\n-static bar: i32 = 43;\n-\n-let baz: bool = { (&foo as *const i32) == (&bar as *const i32) };\n-// baz isn't a constant expression so it's ok\n-```\n-\"##,\n-\n-E0396: r##\"\n-The value assigned to a constant expression must be known at compile time,\n-which is not the case when dereferencing raw pointers. Erroneous code\n-example:\n-\n-```\n-const foo: i32 = 42;\n-const baz: *const i32 = (&foo as *const i32);\n-\n-const deref: i32 = *baz;\n-// error: raw pointers cannot be dereferenced in constants\n-```\n-\n-To fix this error, please do not assign this value to a constant expression.\n-Example:\n-\n-```\n-const foo: i32 = 42;\n-const baz: *const i32 = (&foo as *const i32);\n-\n-unsafe { let deref: i32 = *baz; }\n-// baz isn't a constant expression so it's ok\n-```\n-\n-You'll also note that this assignment must be done in an unsafe block!\n-\"##,\n-\n-E0397: r##\"\n-It is not allowed for a mutable static to allocate or have destructors. For\n-example:\n-\n-```\n-// error: mutable statics are not allowed to have boxes\n-static mut FOO: Option<Box<usize>> = None;\n-\n-// error: mutable statics are not allowed to have destructors\n-static mut BAR: Option<Vec<i32>> = None;\n-```\n-\"##,\n-\n E0398: r##\"\n In Rust 1.3, the default object lifetime bounds are expected to\n change, as described in RFC #1156 [1]. You are getting a warning\n@@ -2026,50 +1660,6 @@ contain references (with a maximum lifetime of `'a`).\n [1]: https://github.com/rust-lang/rfcs/pull/1156\n \"##,\n \n-E0400: r##\"\n-A user-defined dereference was attempted in an invalid context. Erroneous\n-code example:\n-\n-```\n-use std::ops::Deref;\n-\n-struct A;\n-\n-impl Deref for A {\n-    type Target = str;\n-\n-    fn deref(&self)-> &str { \"foo\" }\n-}\n-\n-const S: &'static str = &A;\n-// error: user-defined dereference operators are not allowed in constants\n-\n-fn main() {\n-    let foo = S;\n-}\n-```\n-\n-You cannot directly use a dereference operation whilst initializing a constant\n-or a static. To fix this error, restructure your code to avoid this dereference,\n-perhaps moving it inline:\n-\n-```\n-use std::ops::Deref;\n-\n-struct A;\n-\n-impl Deref for A {\n-    type Target = str;\n-\n-    fn deref(&self)-> &str { \"foo\" }\n-}\n-\n-fn main() {\n-    let foo : &str = &A;\n-}\n-```\n-\"##,\n-\n E0452: r##\"\n An invalid lint attribute has been given. Erroneous code example:\n \n@@ -2087,136 +1677,6 @@ lint name). Ensure the attribute is of this form:\n ```\n \"##,\n \n-E0492: r##\"\n-A borrow of a constant containing interior mutability was attempted. Erroneous\n-code example:\n-\n-```\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n-\n-const A: AtomicUsize = ATOMIC_USIZE_INIT;\n-static B: &'static AtomicUsize = &A;\n-// error: cannot borrow a constant which contains interior mutability, create a\n-//        static instead\n-```\n-\n-A `const` represents a constant value that should never change. If one takes\n-a `&` reference to the constant, then one is taking a pointer to some memory\n-location containing the value. Normally this is perfectly fine: most values\n-can't be changed via a shared `&` pointer, but interior mutability would allow\n-it. That is, a constant value could be mutated. On the other hand, a `static` is\n-explicitly a single memory location, which can be mutated at will.\n-\n-So, in order to solve this error, either use statics which are `Sync`:\n-\n-```\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n-\n-static A: AtomicUsize = ATOMIC_USIZE_INIT;\n-static B: &'static AtomicUsize = &A; // ok!\n-```\n-\n-You can also have this error while using a cell type:\n-\n-```\n-#![feature(const_fn)]\n-\n-use std::cell::Cell;\n-\n-const A: Cell<usize> = Cell::new(1);\n-const B: &'static Cell<usize> = &A;\n-// error: cannot borrow a constant which contains interior mutability, create\n-//        a static instead\n-\n-// or:\n-struct C { a: Cell<usize> }\n-\n-const D: C = C { a: Cell::new(1) };\n-const E: &'static Cell<usize> = &D.a; // error\n-\n-// or:\n-const F: &'static C = &D; // error\n-```\n-\n-This is because cell types do operations that are not thread-safe. Due to this,\n-they don't implement Sync and thus can't be placed in statics. In this\n-case, `StaticMutex` would work just fine, but it isn't stable yet:\n-https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html\n-\n-However, if you still wish to use these types, you can achieve this by an unsafe\n-wrapper:\n-\n-```\n-#![feature(const_fn)]\n-\n-use std::cell::Cell;\n-use std::marker::Sync;\n-\n-struct NotThreadSafe<T> {\n-    value: Cell<T>,\n-}\n-\n-unsafe impl<T> Sync for NotThreadSafe<T> {}\n-\n-static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n-static B: &'static NotThreadSafe<usize> = &A; // ok!\n-```\n-\n-Remember this solution is unsafe! You will have to ensure that accesses to the\n-cell are synchronized.\n-\"##,\n-\n-E0493: r##\"\n-A type with a destructor was assigned to an invalid type of variable. Erroneous\n-code example:\n-\n-```\n-struct Foo {\n-    a: u32\n-}\n-\n-impl Drop for Foo {\n-    fn drop(&mut self) {}\n-}\n-\n-const F : Foo = Foo { a : 0 };\n-// error: constants are not allowed to have destructors\n-static S : Foo = Foo { a : 0 };\n-// error: statics are not allowed to have destructors\n-```\n-\n-To solve this issue, please use a type which does allow the usage of type with\n-destructors.\n-\"##,\n-\n-E0494: r##\"\n-A reference of an interior static was assigned to another const/static.\n-Erroneous code example:\n-\n-```\n-struct Foo {\n-    a: u32\n-}\n-\n-static S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a;\n-// error: cannot refer to the interior of another static, use a\n-//        constant instead\n-```\n-\n-The \"base\" variable has to be a const if you want another static/const variable\n-to refer to one of its fields. Example:\n-\n-```\n-struct Foo {\n-    a: u32\n-}\n-\n-const S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a; // ok!\n-```\n-\"##,\n-\n E0496: r##\"\n A lifetime name is shadowing another lifetime name. Erroneous code example:\n "}, {"sha": "4d772de7835941b1c65cd1564908624739f1db19", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -94,12 +94,9 @@ pub mod middle {\n     pub mod astconv_util;\n     pub mod expr_use_visitor; // STAGE0: increase glitch immunity\n     pub mod cfg;\n-    pub mod check_const;\n-    pub mod check_static_recursion;\n-    pub mod check_loop;\n     pub mod check_match;\n-    pub mod check_rvalues;\n     pub mod const_eval;\n+    pub mod const_qualif;\n     pub mod cstore;\n     pub mod dataflow;\n     pub mod dead;"}, {"sha": "ec98637922ee385d20bbc0f67277bb4ea3bd40f7", "filename": "src/librustc/middle/const_qualif.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Const qualification, from partial to completely promotable.\n+bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable)]\n+    flags ConstQualif: u8 {\n+        // Inner mutability (can not be placed behind a reference) or behind\n+        // &mut in a non-global expression. Can be copied from static memory.\n+        const MUTABLE_MEM        = 1 << 0,\n+        // Constant value with a type that implements Drop. Can be copied\n+        // from static memory, similar to MUTABLE_MEM.\n+        const NEEDS_DROP         = 1 << 1,\n+        // Even if the value can be placed in static memory, copying it from\n+        // there is more expensive than in-place instantiation, and/or it may\n+        // be too large. This applies to [T; N] and everything containing it.\n+        // N.B.: references need to clear this flag to not end up on the stack.\n+        const PREFER_IN_PLACE    = 1 << 2,\n+        // May use more than 0 bytes of memory, doesn't impact the constness\n+        // directly, but is not allowed to be borrowed mutably in a constant.\n+        const NON_ZERO_SIZED     = 1 << 3,\n+        // Actually borrowed, has to always be in static memory. Does not\n+        // propagate, and requires the expression to behave like a 'static\n+        // lvalue. The set of expressions with this flag is the minimum\n+        // that have to be promoted.\n+        const HAS_STATIC_BORROWS = 1 << 4,\n+        // Invalid const for miscellaneous reasons (e.g. not implemented).\n+        const NOT_CONST          = 1 << 5,\n+\n+        // Borrowing the expression won't produce &'static T if any of these\n+        // bits are set, though the value could be copied from static memory\n+        // if `NOT_CONST` isn't set.\n+        const NON_STATIC_BORROWS = ConstQualif::MUTABLE_MEM.bits |\n+                                   ConstQualif::NEEDS_DROP.bits |\n+                                   ConstQualif::NOT_CONST.bits\n+    }\n+}"}, {"sha": "affd963fb79172fc2dc055ed58493e3f1fd3315f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -74,7 +74,7 @@ use self::Aliasability::*;\n use middle::def_id::DefId;\n use front::map as ast_map;\n use middle::infer;\n-use middle::check_const;\n+use middle::const_qualif::ConstQualif;\n use middle::def::Def;\n use middle::ty::adjustment;\n use middle::ty::{self, Ty};\n@@ -795,19 +795,19 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n         let qualif = self.tcx().const_qualif_map.borrow().get(&id).cloned()\n-                               .unwrap_or(check_const::ConstQualif::NOT_CONST);\n+                               .unwrap_or(ConstQualif::NOT_CONST);\n \n         // Only promote `[T; 0]` before an RFC for rvalue promotions\n         // is accepted.\n         let qualif = match expr_ty.sty {\n             ty::TyArray(_, 0) => qualif,\n-            _ => check_const::ConstQualif::NOT_CONST\n+            _ => ConstQualif::NOT_CONST\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n-        let re = if qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS) {\n+        let re = if qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n             self.temporary_scope(id)\n         } else {\n             ty::ReStatic"}, {"sha": "6e56105dd0dae1b174d754f35f763dba967e9e4f", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -373,7 +373,7 @@ pub struct ctxt<'tcx> {\n     repr_hint_cache: RefCell<DepTrackingMap<maps::ReprHints<'tcx>>>,\n \n     /// Maps Expr NodeId's to their constant qualification.\n-    pub const_qualif_map: RefCell<NodeMap<middle::check_const::ConstQualif>>,\n+    pub const_qualif_map: RefCell<NodeMap<middle::const_qualif::ConstQualif>>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n     pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,"}, {"sha": "fd5f711c9d6399d189b979a5b13b08892ed154cb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -34,6 +34,7 @@ use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc_front::hir;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n+use rustc_passes::{no_asm, loops, consts, const_fn, rvalues, static_recursion};\n use super::Compilation;\n \n use serialize::json;\n@@ -632,7 +633,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     time(time_passes,\n          \"checking for inline asm in case the target doesn't support it\",\n-         || ::rustc_passes::no_asm::check_crate(sess, &krate));\n+         || no_asm::check_crate(sess, &krate));\n \n     // One final feature gating of the true AST that gets compiled\n     // later, to make sure we've got everything (e.g. configuration\n@@ -649,7 +650,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     time(time_passes,\n          \"const fn bodies and arguments\",\n-         || ::rustc_passes::const_fn::check_crate(sess, &krate));\n+         || const_fn::check_crate(sess, &krate));\n \n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n@@ -743,11 +744,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n          \"loop checking\",\n-         || middle::check_loop::check_crate(sess, krate));\n+         || loops::check_crate(sess, krate));\n \n     time(time_passes,\n          \"static item recursion checking\",\n-         || middle::check_static_recursion::check_crate(sess, krate, &def_map.borrow(), &hir_map));\n+         || static_recursion::check_crate(sess, krate, &def_map.borrow(), &hir_map));\n \n     ty::ctxt::create_and_enter(sess,\n                                arenas,\n@@ -764,7 +765,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n                                    time(time_passes,\n                                         \"const checking\",\n-                                        || middle::check_const::check_crate(tcx));\n+                                        || consts::check_crate(tcx));\n \n                                    let access_levels =\n                                        time(time_passes, \"privacy checking\", || {\n@@ -805,7 +806,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n                                    time(time_passes,\n                                         \"rvalue checking\",\n-                                        || middle::check_rvalues::check_crate(tcx));\n+                                        || rvalues::check_crate(tcx));\n \n                                    // Avoid overwhelming user with errors if type checking failed.\n                                    // I'm not sure how helpful this is, to be honest, but it avoids"}, {"sha": "e91c7e6ac450687f7584e92377619d60bf814e34", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -29,7 +29,7 @@ use tyencode;\n use middle::cstore::{InlinedItem, InlinedItemRef};\n use middle::ty::adjustment;\n use middle::ty::cast;\n-use middle::check_const::ConstQualif;\n+use middle::const_qualif::ConstQualif;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::privacy::{AllPublic, LastMod};"}, {"sha": "60cc658eeca8fb21e3cdf2f800da339d2b89cb81", "filename": "src/librustc_passes/consts.rs", "status": "renamed", "additions": 17, "deletions": 50, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -24,20 +24,22 @@\n // - It's not possible to take the address of a static item with unsafe interior. This is enforced\n // by borrowck::gather_loans\n \n-use dep_graph::DepNode;\n-use middle::ty::cast::{CastKind};\n-use middle::const_eval::{self, ConstEvalErr};\n-use middle::const_eval::ErrKind::IndexOpFeatureGated;\n-use middle::const_eval::EvalHint::ExprTypeChecked;\n-use middle::def::Def;\n-use middle::def_id::DefId;\n-use middle::expr_use_visitor as euv;\n-use middle::infer;\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::Categorization;\n-use middle::traits;\n-use middle::ty::{self, Ty};\n-use util::nodemap::NodeMap;\n+use rustc::dep_graph::DepNode;\n+use rustc::middle::ty::cast::{CastKind};\n+use rustc::middle::const_eval::{self, ConstEvalErr};\n+use rustc::middle::const_eval::ErrKind::IndexOpFeatureGated;\n+use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+use rustc::middle::def::Def;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::expr_use_visitor as euv;\n+use rustc::middle::infer;\n+use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n+use rustc::middle::traits;\n+use rustc::middle::ty::{self, Ty};\n+use rustc::util::nodemap::NodeMap;\n+use rustc::middle::const_qualif::ConstQualif;\n+use rustc::lint::builtin::CONST_ERR;\n \n use rustc_front::hir;\n use syntax::ast;\n@@ -48,41 +50,6 @@ use rustc_front::intravisit::{self, FnKind, Visitor};\n use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n \n-// Const qualification, from partial to completely promotable.\n-bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable)]\n-    flags ConstQualif: u8 {\n-        // Inner mutability (can not be placed behind a reference) or behind\n-        // &mut in a non-global expression. Can be copied from static memory.\n-        const MUTABLE_MEM        = 1 << 0,\n-        // Constant value with a type that implements Drop. Can be copied\n-        // from static memory, similar to MUTABLE_MEM.\n-        const NEEDS_DROP         = 1 << 1,\n-        // Even if the value can be placed in static memory, copying it from\n-        // there is more expensive than in-place instantiation, and/or it may\n-        // be too large. This applies to [T; N] and everything containing it.\n-        // N.B.: references need to clear this flag to not end up on the stack.\n-        const PREFER_IN_PLACE    = 1 << 2,\n-        // May use more than 0 bytes of memory, doesn't impact the constness\n-        // directly, but is not allowed to be borrowed mutably in a constant.\n-        const NON_ZERO_SIZED     = 1 << 3,\n-        // Actually borrowed, has to always be in static memory. Does not\n-        // propagate, and requires the expression to behave like a 'static\n-        // lvalue. The set of expressions with this flag is the minimum\n-        // that have to be promoted.\n-        const HAS_STATIC_BORROWS = 1 << 4,\n-        // Invalid const for miscellaneous reasons (e.g. not implemented).\n-        const NOT_CONST          = 1 << 5,\n-\n-        // Borrowing the expression won't produce &'static T if any of these\n-        // bits are set, though the value could be copied from static memory\n-        // if `NOT_CONST` isn't set.\n-        const NON_STATIC_BORROWS = ConstQualif::MUTABLE_MEM.bits |\n-                                   ConstQualif::NEEDS_DROP.bits |\n-                                   ConstQualif::NOT_CONST.bits\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n enum Mode {\n     Const,\n@@ -463,7 +430,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                                 Ok(_) => {}\n                                 Err(ConstEvalErr { kind: IndexOpFeatureGated, ..}) => {},\n                                 Err(msg) => {\n-                                    self.tcx.sess.add_lint(::lint::builtin::CONST_ERR, ex.id,\n+                                    self.tcx.sess.add_lint(CONST_ERR, ex.id,\n                                                            msg.span,\n                                                            msg.description().into_owned())\n                                 }", "previous_filename": "src/librustc/middle/check_const.rs"}, {"sha": "2c08cbd32338d47ae56713415d882a090e60055c", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 542, "deletions": 0, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -11,6 +11,108 @@\n #![allow(non_snake_case)]\n \n register_long_diagnostics! {\n+\n+E0010: r##\"\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time. Erroneous\n+code example:\n+\n+```\n+#![feature(box_syntax)]\n+\n+const CON : Box<i32> = box 0;\n+```\n+\"##,\n+\n+E0011: r##\"\n+Initializers for constants and statics are evaluated at compile time.\n+User-defined operators rely on user-defined functions, which cannot be evaluated\n+at compile time.\n+\n+Bad example:\n+\n+```\n+use std::ops::Index;\n+\n+struct Foo { a: u8 }\n+\n+impl Index<u8> for Foo {\n+    type Output = u8;\n+\n+    fn index<'a>(&'a self, idx: u8) -> &'a u8 { &self.a }\n+}\n+\n+const a: Foo = Foo { a: 0u8 };\n+const b: u8 = a[0]; // Index trait is defined by the user, bad!\n+```\n+\n+Only operators on builtin types are allowed.\n+\n+Example:\n+\n+```\n+const a: &'static [i32] = &[1, 2, 3];\n+const b: i32 = a[0]; // Good!\n+```\n+\"##,\n+\n+E0013: r##\"\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable. For example, `Y` cannot refer to `X`\n+here:\n+\n+```\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+To fix this, the value can be extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```\n+\"##,\n+\n+E0014: r##\"\n+Constants can only be initialized by a constant value or, in a future\n+version of Rust, a call to a const function. This error indicates the use\n+of a path (like a::b, or x) denoting something other than one of these\n+allowed items. Example:\n+\n+```\n+const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!\n+```\n+\n+To avoid it, you have to replace the non-constant value:\n+\n+```\n+const FOO: i32 = { const X : i32 = 0; X };\n+// or even:\n+const FOO: i32 = { 0 }; // but brackets are useless here\n+```\n+\"##,\n+\n+// FIXME(#24111) Change the language here when const fn stabilizes\n+E0015: r##\"\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors. `const` functions are only\n+available on a nightly compiler. Rust currently does not support more general\n+compile-time function execution.\n+\n+```\n+const FOO: Option<u8> = Some(1); // enum constructor\n+struct Bar {x: u8}\n+const BAR: Bar = Bar {x: 1}; // struct constructor\n+```\n+\n+See [RFC 911] for more details on the design of `const fn`s.\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n+\"##,\n+\n E0016: r##\"\n Blocks in constants may only contain items (such as constant, function\n definition, etc...) and a tail expression. Example:\n@@ -26,6 +128,86 @@ const FOO: i32 = { const X : i32 = 0; X };\n ```\n \"##,\n \n+E0017: r##\"\n+References in statics and constants may only refer to immutable values. Example:\n+\n+```\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &'static mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`.\n+\"##,\n+\n+E0018: r##\"\n+The value of static and const variables must be known at compile time. You\n+can't cast a pointer as an integer because we can't know what value the\n+address will take.\n+\n+However, pointers to other constants' addresses are allowed in constants,\n+example:\n+\n+```\n+const X: u32 = 50;\n+const Y: *const u32 = &X;\n+```\n+\n+Therefore, casting one of these non-constant pointers to an integer results\n+in a non-constant integer which lead to this error. Example:\n+\n+```\n+const X: u32 = 1;\n+const Y: usize = &X as *const u32 as usize;\n+println!(\"{}\", Y);\n+```\n+\"##,\n+\n+E0019: r##\"\n+A function call isn't allowed in the const's initialization expression\n+because the expression's value must be known at compile-time. Example of\n+erroneous code:\n+\n+```\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn test(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    const A: i32 = FOO.test(); // You can't call Test::func() here !\n+}\n+```\n+\n+Remember: you can't use a function call inside a const's initialization\n+expression! However, you can totally use it anywhere else:\n+\n+```\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    FOO.func(); // here is good\n+    let x = FOO.func(); // or even here!\n+}\n+```\n+\"##,\n+\n E0022: r##\"\n Constant functions are not allowed to mutate anything. Thus, binding to an\n argument with a mutable pattern is not allowed. For example,\n@@ -43,6 +225,366 @@ you need to mutate the argument, try lazily initializing a global variable\n instead of using a `const fn`, or refactoring the code to a functional style to\n avoid mutation if possible.\n \"##,\n+\n+E0030: r##\"\n+When matching against a range, the compiler verifies that the range is\n+non-empty.  Range patterns include both end-points, so this is equivalent to\n+requiring the start of the range to be less than or equal to the end of the\n+range.\n+\n+For example:\n+\n+```\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 ... 1 => ...\n+    // This range is empty, and the compiler can tell.\n+    1000 ... 5 => ...\n+}\n+```\n+\"##,\n+\n+E0161: r##\"\n+In Rust, you can only move a value when its size is known at compile time.\n+\n+To work around this restriction, consider \"hiding\" the value behind a reference:\n+either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n+it around as usual.\n+\"##,\n+\n+E0265: r##\"\n+This error indicates that a static or constant references itself.\n+All statics and constants need to resolve to a value in an acyclic manner.\n+\n+For example, neither of the following can be sensibly compiled:\n+\n+```\n+const X: u32 = X;\n+```\n+\n+```\n+const X: u32 = Y;\n+const Y: u32 = X;\n+```\n+\"##,\n+\n+E0267: r##\"\n+This error indicates the use of a loop keyword (`break` or `continue`) inside a\n+closure but outside of any loop. Erroneous code example:\n+\n+```\n+let w = || { break; }; // error: `break` inside of a closure\n+```\n+\n+`break` and `continue` keywords can be used as normal inside closures as long as\n+they are also contained within a loop. To halt the execution of a closure you\n+should instead use a return statement. Example:\n+\n+```\n+let w = || {\n+    for _ in 0..10 {\n+        break;\n+    }\n+};\n+\n+w();\n+```\n+\"##,\n+\n+E0268: r##\"\n+This error indicates the use of a loop keyword (`break` or `continue`) outside\n+of a loop. Without a loop to break out of or continue in, no sensible action can\n+be taken. Erroneous code example:\n+\n+```\n+fn some_func() {\n+    break; // error: `break` outside of loop\n+}\n+```\n+\n+Please verify that you are using `break` and `continue` only in loops. Example:\n+\n+```\n+fn some_func() {\n+    for _ in 0..10 {\n+        break; // ok!\n+    }\n+}\n+```\n+\"##,\n+\n+E0378: r##\"\n+Method calls that aren't calls to inherent `const` methods are disallowed\n+in statics, constants, and constant functions.\n+\n+For example:\n+\n+```\n+const BAZ: i32 = Foo(25).bar(); // error, `bar` isn't `const`\n+\n+struct Foo(i32);\n+\n+impl Foo {\n+    const fn foo(&self) -> i32 {\n+        self.bar() // error, `bar` isn't `const`\n+    }\n+\n+    fn bar(&self) -> i32 { self.0 }\n+}\n+```\n+\n+For more information about `const fn`'s, see [RFC 911].\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n+\"##,\n+\n+E0394: r##\"\n+From [RFC 246]:\n+\n+ > It is invalid for a static to reference another static by value. It is\n+ > required that all references be borrowed.\n+\n+[RFC 246]: https://github.com/rust-lang/rfcs/pull/246\n+\"##,\n+\n+E0395: r##\"\n+The value assigned to a constant expression must be known at compile time,\n+which is not the case when comparing raw pointers. Erroneous code example:\n+\n+```\n+static foo: i32 = 42;\n+static bar: i32 = 43;\n+\n+static baz: bool = { (&foo as *const i32) == (&bar as *const i32) };\n+// error: raw pointers cannot be compared in statics!\n+```\n+\n+Please check that the result of the comparison can be determined at compile time\n+or isn't assigned to a constant expression. Example:\n+\n+```\n+static foo: i32 = 42;\n+static bar: i32 = 43;\n+\n+let baz: bool = { (&foo as *const i32) == (&bar as *const i32) };\n+// baz isn't a constant expression so it's ok\n+```\n+\"##,\n+\n+E0396: r##\"\n+The value assigned to a constant expression must be known at compile time,\n+which is not the case when dereferencing raw pointers. Erroneous code\n+example:\n+\n+```\n+const foo: i32 = 42;\n+const baz: *const i32 = (&foo as *const i32);\n+\n+const deref: i32 = *baz;\n+// error: raw pointers cannot be dereferenced in constants\n+```\n+\n+To fix this error, please do not assign this value to a constant expression.\n+Example:\n+\n+```\n+const foo: i32 = 42;\n+const baz: *const i32 = (&foo as *const i32);\n+\n+unsafe { let deref: i32 = *baz; }\n+// baz isn't a constant expression so it's ok\n+```\n+\n+You'll also note that this assignment must be done in an unsafe block!\n+\"##,\n+\n+E0397: r##\"\n+It is not allowed for a mutable static to allocate or have destructors. For\n+example:\n+\n+```\n+// error: mutable statics are not allowed to have boxes\n+static mut FOO: Option<Box<usize>> = None;\n+\n+// error: mutable statics are not allowed to have destructors\n+static mut BAR: Option<Vec<i32>> = None;\n+```\n+\"##,\n+\n+E0400: r##\"\n+A user-defined dereference was attempted in an invalid context. Erroneous\n+code example:\n+\n+```\n+use std::ops::Deref;\n+\n+struct A;\n+\n+impl Deref for A {\n+    type Target = str;\n+\n+    fn deref(&self)-> &str { \"foo\" }\n+}\n+\n+const S: &'static str = &A;\n+// error: user-defined dereference operators are not allowed in constants\n+\n+fn main() {\n+    let foo = S;\n+}\n+```\n+\n+You cannot directly use a dereference operation whilst initializing a constant\n+or a static. To fix this error, restructure your code to avoid this dereference,\n+perhaps moving it inline:\n+\n+```\n+use std::ops::Deref;\n+\n+struct A;\n+\n+impl Deref for A {\n+    type Target = str;\n+\n+    fn deref(&self)-> &str { \"foo\" }\n+}\n+\n+fn main() {\n+    let foo : &str = &A;\n+}\n+```\n+\"##,\n+\n+E0492: r##\"\n+A borrow of a constant containing interior mutability was attempted. Erroneous\n+code example:\n+\n+```\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+\n+const A: AtomicUsize = ATOMIC_USIZE_INIT;\n+static B: &'static AtomicUsize = &A;\n+// error: cannot borrow a constant which contains interior mutability, create a\n+//        static instead\n+```\n+\n+A `const` represents a constant value that should never change. If one takes\n+a `&` reference to the constant, then one is taking a pointer to some memory\n+location containing the value. Normally this is perfectly fine: most values\n+can't be changed via a shared `&` pointer, but interior mutability would allow\n+it. That is, a constant value could be mutated. On the other hand, a `static` is\n+explicitly a single memory location, which can be mutated at will.\n+\n+So, in order to solve this error, either use statics which are `Sync`:\n+\n+```\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+\n+static A: AtomicUsize = ATOMIC_USIZE_INIT;\n+static B: &'static AtomicUsize = &A; // ok!\n+```\n+\n+You can also have this error while using a cell type:\n+\n+```\n+#![feature(const_fn)]\n+\n+use std::cell::Cell;\n+\n+const A: Cell<usize> = Cell::new(1);\n+const B: &'static Cell<usize> = &A;\n+// error: cannot borrow a constant which contains interior mutability, create\n+//        a static instead\n+\n+// or:\n+struct C { a: Cell<usize> }\n+\n+const D: C = C { a: Cell::new(1) };\n+const E: &'static Cell<usize> = &D.a; // error\n+\n+// or:\n+const F: &'static C = &D; // error\n+```\n+\n+This is because cell types do operations that are not thread-safe. Due to this,\n+they don't implement Sync and thus can't be placed in statics. In this\n+case, `StaticMutex` would work just fine, but it isn't stable yet:\n+https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html\n+\n+However, if you still wish to use these types, you can achieve this by an unsafe\n+wrapper:\n+\n+```\n+#![feature(const_fn)]\n+\n+use std::cell::Cell;\n+use std::marker::Sync;\n+\n+struct NotThreadSafe<T> {\n+    value: Cell<T>,\n+}\n+\n+unsafe impl<T> Sync for NotThreadSafe<T> {}\n+\n+static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n+static B: &'static NotThreadSafe<usize> = &A; // ok!\n+```\n+\n+Remember this solution is unsafe! You will have to ensure that accesses to the\n+cell are synchronized.\n+\"##,\n+\n+E0493: r##\"\n+A type with a destructor was assigned to an invalid type of variable. Erroneous\n+code example:\n+\n+```\n+struct Foo {\n+    a: u32\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+const F : Foo = Foo { a : 0 };\n+// error: constants are not allowed to have destructors\n+static S : Foo = Foo { a : 0 };\n+// error: statics are not allowed to have destructors\n+```\n+\n+To solve this issue, please use a type which does allow the usage of type with\n+destructors.\n+\"##,\n+\n+E0494: r##\"\n+A reference of an interior static was assigned to another const/static.\n+Erroneous code example:\n+\n+```\n+struct Foo {\n+    a: u32\n+}\n+\n+static S : Foo = Foo { a : 0 };\n+static A : &'static u32 = &S.a;\n+// error: cannot refer to the interior of another static, use a\n+//        constant instead\n+```\n+\n+The \"base\" variable has to be a const if you want another static/const variable\n+to refer to one of its fields. Example:\n+\n+```\n+struct Foo {\n+    a: u32\n+}\n+\n+const S : Foo = Foo { a : 0 };\n+static A : &'static u32 = &S.a; // ok!\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "fcdbd6384d543465653a66515c4b880a2184d477", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -28,9 +28,16 @@\n \n extern crate core;\n extern crate rustc;\n+extern crate rustc_front;\n \n+#[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n pub mod diagnostics;\n+\n pub mod const_fn;\n+pub mod consts;\n+pub mod loops;\n pub mod no_asm;\n+pub mod rvalues;\n+pub mod static_recursion;"}, {"sha": "eb2e445f9b09342d41677c468968d1061b19a903", "filename": "src/librustc_passes/loops.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n use self::Context::*;\n \n-use session::Session;\n+use rustc::session::Session;\n \n use syntax::codemap::Span;\n use rustc_front::intravisit::{self, Visitor};", "previous_filename": "src/librustc/middle/check_loop.rs"}, {"sha": "f5cc020932b6308087e21508fe43fde53f4ad095", "filename": "src/librustc_passes/rvalues.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -11,12 +11,11 @@\n // Checks that all rvalues in a crate have statically known size. check_crate\n // is the public starting point.\n \n-use dep_graph::DepNode;\n-use middle::expr_use_visitor as euv;\n-use middle::infer;\n-use middle::mem_categorization as mc;\n-use middle::ty::ParameterEnvironment;\n-use middle::ty;\n+use rustc::dep_graph::DepNode;\n+use rustc::middle::expr_use_visitor as euv;\n+use rustc::middle::infer;\n+use rustc::middle::mem_categorization as mc;\n+use rustc::middle::ty::{self, ParameterEnvironment};\n \n use rustc_front::hir;\n use rustc_front::intravisit;", "previous_filename": "src/librustc/middle/check_rvalues.rs"}, {"sha": "b49db16b4ceed957e249d34e95c04bd961a3dd90", "filename": "src/librustc_passes/static_recursion.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -11,10 +11,10 @@\n // This compiler pass detects constants that refer to themselves\n // recursively.\n \n-use front::map as ast_map;\n-use session::Session;\n-use middle::def::{Def, DefMap};\n-use util::nodemap::NodeMap;\n+use rustc::front::map as ast_map;\n+use rustc::session::Session;\n+use rustc::middle::def::{Def, DefMap};\n+use rustc::util::nodemap::NodeMap;\n \n use syntax::{ast};\n use syntax::codemap::Span;", "previous_filename": "src/librustc/middle/check_static_recursion.rs"}, {"sha": "0f5d8dbd94db01f2275e2a5ad6b2556bbfc4976e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n-use middle::check_const;\n+use middle::const_qualif::ConstQualif;\n use middle::cstore::LOCAL_CRATE;\n use middle::const_eval::{self, ConstVal, ConstEvalErr};\n use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n@@ -274,8 +274,7 @@ fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            -> Result<ValueRef, ConstEvalFailure> {\n     let expr = get_const_expr(ccx, def_id, ref_expr, param_substs);\n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-    match get_const_expr_as_global(ccx, expr, check_const::ConstQualif::empty(),\n-                                   empty_substs, TrueConst::Yes) {\n+    match get_const_expr_as_global(ccx, expr, ConstQualif::empty(), empty_substs, TrueConst::Yes) {\n         Err(Runtime(err)) => {\n             ccx.tcx().sess.span_err(expr.span, &err.description());\n             Err(Compiletime(err))\n@@ -286,7 +285,7 @@ fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           expr: &hir::Expr,\n-                                          qualif: check_const::ConstQualif,\n+                                          qualif: ConstQualif,\n                                           param_substs: &'tcx Substs<'tcx>,\n                                           trueconst: TrueConst)\n                                           -> Result<ValueRef, ConstEvalFailure> {\n@@ -315,7 +314,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n     let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n                                               &ccx.tcx().expr_ty(expr));\n-    let val = if qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS) {\n+    let val = if qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n         try!(const_expr_unadjusted(ccx, expr, ty, param_substs, None, trueconst))"}, {"sha": "ada37c5d8dfbecc4d8316447ca65759f55630f12", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340e7eb2a7330fd73e6ae745690fb7d92ddba4d4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=340e7eb2a7330fd73e6ae745690fb7d92ddba4d4", "patch": "@@ -53,7 +53,7 @@ use self::lazy_binop_ty::*;\n \n use back::abi;\n use llvm::{self, ValueRef, TypeKind};\n-use middle::check_const;\n+use middle::const_qualif::ConstQualif;\n use middle::def::Def;\n use middle::lang_items::CoerceUnsizedTraitLangItem;\n use middle::subst::{Substs, VecPerParamSpace};\n@@ -128,11 +128,8 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    if !qualif.intersects(\n-        check_const::ConstQualif::NOT_CONST |\n-        check_const::ConstQualif::NEEDS_DROP\n-    ) {\n-        if !qualif.intersects(check_const::ConstQualif::PREFER_IN_PLACE) {\n+    if !qualif.intersects(ConstQualif::NOT_CONST | ConstQualif::NEEDS_DROP) {\n+        if !qualif.intersects(ConstQualif::PREFER_IN_PLACE) {\n             if let SaveIn(lldest) = dest {\n                 match consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n                                                        bcx.fcx.param_substs,\n@@ -231,16 +228,13 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n     let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    let adjusted_global = !qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS);\n-    let global = if !qualif.intersects(\n-        check_const::ConstQualif::NOT_CONST |\n-        check_const::ConstQualif::NEEDS_DROP\n-    ) {\n+    let adjusted_global = !qualif.intersects(ConstQualif::NON_STATIC_BORROWS);\n+    let global = if !qualif.intersects(ConstQualif::NOT_CONST | ConstQualif::NEEDS_DROP) {\n         match consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n                                                             bcx.fcx.param_substs,\n                                                             consts::TrueConst::No) {\n             Ok(global) => {\n-                if qualif.intersects(check_const::ConstQualif::HAS_STATIC_BORROWS) {\n+                if qualif.intersects(ConstQualif::HAS_STATIC_BORROWS) {\n                     // Is borrowed as 'static, must return lvalue.\n \n                     // Cast pointer to global, because constants have different types."}]}