{"sha": "b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "node_id": "C_kwDOAAsO6NoAKGI4ZGM2YWE2NzMzMTdjZjcyYThhYmI5YzQyMWY1NzNmMmIzNGI0N2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-11T15:55:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-11T15:55:22Z"}, "message": "Auto merge of #91792 - matthiaskrgr:rollup-2epg7jq, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #91617 (Improve the readability of `List<T>`.)\n - #91640 (Simplify collection of in-band lifetimes)\n - #91682 (rustdoc: Show type layout for type aliases)\n - #91711 (Improve `std::iter::zip` example)\n - #91717 (Add deprecation warning for --passes)\n - #91718 (give more help in the unaligned_references lint)\n - #91782 (Correct since attribute for `is_symlink` feature)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0251c3bc0171c35b1286e9f3de7a152fdb783154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0251c3bc0171c35b1286e9f3de7a152fdb783154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "html_url": "https://github.com/rust-lang/rust/commit/b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9a37ad0d995c71518629b032f8e816e1efa8bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9a37ad0d995c71518629b032f8e816e1efa8bca", "html_url": "https://github.com/rust-lang/rust/commit/b9a37ad0d995c71518629b032f8e816e1efa8bca"}, {"sha": "bb23d82e6f8548a173dd574fca7f7131a51f534f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb23d82e6f8548a173dd574fca7f7131a51f534f", "html_url": "https://github.com/rust-lang/rust/commit/bb23d82e6f8548a173dd574fca7f7131a51f534f"}], "stats": {"total": 676, "additions": 405, "deletions": 271}, "files": [{"sha": "ca7a64e254e14795cee5daa01c8a05b84a4e5b12", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -247,12 +247,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, idty| {\n                             let ret_id = asyncness.opt_return_id();\n-                            this.lower_fn_decl(\n-                                &decl,\n-                                Some((fn_def_id.to_def_id(), idty)),\n-                                true,\n-                                ret_id,\n-                            )\n+                            this.lower_fn_decl(&decl, Some((fn_def_id, idty)), true, ret_id)\n                         },\n                     );\n                     let sig = hir::FnSig {\n@@ -1264,7 +1259,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             |this, idty| {\n                 this.lower_fn_decl(\n                     &sig.decl,\n-                    Some((fn_def_id.to_def_id(), idty)),\n+                    Some((fn_def_id, idty)),\n                     impl_trait_return_allow,\n                     is_async,\n                 )"}, {"sha": "c04b0471cb72fe62ac3239d82ffde547d9227c02", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 87, "deletions": 105, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -228,7 +228,7 @@ enum ImplTraitContext<'b, 'a> {\n     ReturnPositionOpaqueTy {\n         /// `DefId` for the parent function, used to look up necessary\n         /// information later.\n-        fn_def_id: DefId,\n+        fn_def_id: LocalDefId,\n         /// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,\n         origin: hir::OpaqueTyOrigin,\n     },\n@@ -646,31 +646,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T>(\n         &mut self,\n-        parent_def_id: LocalDefId,\n-        anonymous_lifetime_mode: AnonymousLifetimeMode,\n-        f: impl FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n-    ) -> (Vec<hir::GenericParam<'hir>>, T) {\n-        assert!(!self.is_collecting_in_band_lifetimes);\n-        assert!(self.lifetimes_to_define.is_empty());\n-        let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n-\n-        self.anonymous_lifetime_mode = anonymous_lifetime_mode;\n-        self.is_collecting_in_band_lifetimes = true;\n-\n-        let (in_band_ty_params, res) = f(self);\n-\n-        self.is_collecting_in_band_lifetimes = false;\n-        self.anonymous_lifetime_mode = old_anonymous_lifetime_mode;\n-\n-        let lifetimes_to_define = self.lifetimes_to_define.split_off(0);\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> (Vec<(Span, ParamName)>, T) {\n+        let was_collecting = std::mem::replace(&mut self.is_collecting_in_band_lifetimes, true);\n+        let len = self.lifetimes_to_define.len();\n \n-        let params = lifetimes_to_define\n-            .into_iter()\n-            .map(|(span, hir_name)| self.lifetime_to_generic_param(span, hir_name, parent_def_id))\n-            .chain(in_band_ty_params.into_iter())\n-            .collect();\n+        let res = f(self);\n \n-        (params, res)\n+        let lifetimes_to_define = self.lifetimes_to_define.split_off(len);\n+        self.is_collecting_in_band_lifetimes = was_collecting;\n+        (lifetimes_to_define, res)\n     }\n \n     /// Converts a lifetime into a new generic parameter.\n@@ -785,27 +770,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     ) -> (hir::Generics<'hir>, T) {\n-        let (in_band_defs, (mut lowered_generics, res)) =\n-            self.with_in_scope_lifetime_defs(&generics.params, |this| {\n-                this.collect_in_band_defs(parent_def_id, anonymous_lifetime_mode, |this| {\n-                    let mut params = Vec::new();\n-                    // Note: it is necessary to lower generics *before* calling `f`.\n-                    // When lowering `async fn`, there's a final step when lowering\n-                    // the return type that assumes that all in-scope lifetimes have\n-                    // already been added to either `in_scope_lifetimes` or\n-                    // `lifetimes_to_define`. If we swapped the order of these two,\n-                    // in-band-lifetimes introduced by generics or where-clauses\n-                    // wouldn't have been added yet.\n-                    let generics = this.lower_generics_mut(\n-                        generics,\n-                        ImplTraitContext::Universal(&mut params, this.current_hir_id_owner),\n-                    );\n-                    let res = f(this, &mut params);\n-                    (params, (generics, res))\n+        let (lifetimes_to_define, (mut lowered_generics, impl_trait_defs, res)) = self\n+            .collect_in_band_defs(|this| {\n+                this.with_anonymous_lifetime_mode(anonymous_lifetime_mode, |this| {\n+                    this.with_in_scope_lifetime_defs(&generics.params, |this| {\n+                        let mut impl_trait_defs = Vec::new();\n+                        // Note: it is necessary to lower generics *before* calling `f`.\n+                        // When lowering `async fn`, there's a final step when lowering\n+                        // the return type that assumes that all in-scope lifetimes have\n+                        // already been added to either `in_scope_lifetimes` or\n+                        // `lifetimes_to_define`. If we swapped the order of these two,\n+                        // in-band-lifetimes introduced by generics or where-clauses\n+                        // wouldn't have been added yet.\n+                        let generics = this.lower_generics_mut(\n+                            generics,\n+                            ImplTraitContext::Universal(\n+                                &mut impl_trait_defs,\n+                                this.current_hir_id_owner,\n+                            ),\n+                        );\n+                        let res = f(this, &mut impl_trait_defs);\n+                        (generics, impl_trait_defs, res)\n+                    })\n                 })\n             });\n \n-        lowered_generics.params.extend(in_band_defs);\n+        lowered_generics.params.extend(\n+            lifetimes_to_define\n+                .into_iter()\n+                .map(|(span, hir_name)| {\n+                    self.lifetime_to_generic_param(span, hir_name, parent_def_id)\n+                })\n+                .chain(impl_trait_defs),\n+        );\n \n         let lowered_generics = lowered_generics.into_generics(self.arena);\n         (lowered_generics, res)\n@@ -1380,7 +1377,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_opaque_impl_trait(\n         &mut self,\n         span: Span,\n-        fn_def_id: Option<DefId>,\n+        fn_def_id: Option<LocalDefId>,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n         capturable_lifetimes: Option<&FxHashSet<hir::LifetimeName>>,\n@@ -1452,7 +1449,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     span: lctx.lower_span(span),\n                 },\n                 bounds: hir_bounds,\n-                impl_trait_fn: fn_def_id,\n                 origin,\n             };\n \n@@ -1522,7 +1518,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        mut in_band_ty_params: Option<(DefId, &mut Vec<hir::GenericParam<'hir>>)>,\n+        mut in_band_ty_params: Option<(LocalDefId, &mut Vec<hir::GenericParam<'hir>>)>,\n         impl_trait_return_allow: bool,\n         make_ret_async: Option<NodeId>,\n     ) -> &'hir hir::FnDecl<'hir> {\n@@ -1580,7 +1576,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         Some((def_id, _)) if impl_trait_return_allow => {\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 fn_def_id: def_id,\n-                                origin: hir::OpaqueTyOrigin::FnReturn,\n+                                origin: hir::OpaqueTyOrigin::FnReturn(def_id),\n                             }\n                         }\n                         _ => ImplTraitContext::disallowed(),\n@@ -1635,7 +1631,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_async_fn_ret_ty(\n         &mut self,\n         output: &FnRetTy,\n-        fn_def_id: DefId,\n+        fn_def_id: LocalDefId,\n         opaque_ty_node_id: NodeId,\n     ) -> hir::FnRetTy<'hir> {\n         debug!(\n@@ -1689,18 +1685,29 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // this is because the elided lifetimes from the return type\n         // should be figured out using the ordinary elision rules, and\n         // this desugaring achieves that.\n+\n+        debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", self.in_scope_lifetimes);\n+        debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", self.lifetimes_to_define);\n+\n+        // Calculate all the lifetimes that should be captured\n+        // by the opaque type. This should include all in-scope\n+        // lifetime parameters, including those defined in-band.\n         //\n-        // The variable `input_lifetimes_count` tracks the number of\n-        // lifetime parameters to the opaque type *not counting* those\n-        // lifetimes elided in the return type. This includes those\n-        // that are explicitly declared (`in_scope_lifetimes`) and\n-        // those elided lifetimes we found in the arguments (current\n-        // content of `lifetimes_to_define`). Next, we will process\n-        // the return type, which will cause `lifetimes_to_define` to\n-        // grow.\n-        let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n-\n-        let mut lifetime_params = Vec::new();\n+        // `lifetime_params` is a vector of tuple (span, parameter name, lifetime name).\n+\n+        // Input lifetime like `'a` or `'1`:\n+        let mut lifetime_params: Vec<_> = self\n+            .in_scope_lifetimes\n+            .iter()\n+            .cloned()\n+            .map(|name| (name.ident().span, name, hir::LifetimeName::Param(name)))\n+            .chain(\n+                self.lifetimes_to_define\n+                    .iter()\n+                    .map(|&(span, name)| (span, name, hir::LifetimeName::Param(name))),\n+            )\n+            .collect();\n+\n         self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n@@ -1710,34 +1717,26 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             //\n             // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n             // hence the elision takes place at the fn site.\n-            let future_bound = this\n-                .with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n-                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n+            let (lifetimes_to_define, future_bound) =\n+                this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n+                    this.collect_in_band_defs(|this| {\n+                        this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n+                    })\n                 });\n-\n             debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n+            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", lifetimes_to_define);\n \n-            // Calculate all the lifetimes that should be captured\n-            // by the opaque type. This should include all in-scope\n-            // lifetime parameters, including those defined in-band.\n-            //\n-            // Note: this must be done after lowering the output type,\n-            // as the output type may introduce new in-band lifetimes.\n-            lifetime_params = this\n-                .in_scope_lifetimes\n-                .iter()\n-                .cloned()\n-                .map(|name| (name.ident().span, name))\n-                .chain(this.lifetimes_to_define.iter().cloned())\n-                .collect();\n-\n-            debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", this.in_scope_lifetimes);\n-            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n+            lifetime_params.extend(\n+                // Output lifetime like `'_`:\n+                lifetimes_to_define\n+                    .into_iter()\n+                    .map(|(span, name)| (span, name, hir::LifetimeName::Implicit(false))),\n+            );\n             debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n \n             let generic_params =\n-                this.arena.alloc_from_iter(lifetime_params.iter().map(|(span, hir_name)| {\n-                    this.lifetime_to_generic_param(*span, *hir_name, opaque_ty_def_id)\n+                this.arena.alloc_from_iter(lifetime_params.iter().map(|&(span, hir_name, _)| {\n+                    this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_id)\n                 }));\n \n             let opaque_ty_item = hir::OpaqueTy {\n@@ -1747,8 +1746,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     span: this.lower_span(span),\n                 },\n                 bounds: arena_vec![this; future_bound],\n-                impl_trait_fn: Some(fn_def_id),\n-                origin: hir::OpaqueTyOrigin::AsyncFn,\n+                origin: hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n             };\n \n             trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n@@ -1771,25 +1769,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n-        let mut generic_args = Vec::with_capacity(lifetime_params.len());\n-        generic_args.extend(lifetime_params[..input_lifetimes_count].iter().map(\n-            |&(span, hir_name)| {\n-                // Input lifetime like `'a` or `'1`:\n+        let generic_args =\n+            self.arena.alloc_from_iter(lifetime_params.into_iter().map(|(span, _, name)| {\n                 GenericArg::Lifetime(hir::Lifetime {\n                     hir_id: self.next_id(),\n                     span: self.lower_span(span),\n-                    name: hir::LifetimeName::Param(hir_name),\n+                    name,\n                 })\n-            },\n-        ));\n-        generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)|\n-            // Output lifetime like `'_`.\n-            GenericArg::Lifetime(hir::Lifetime {\n-                hir_id: self.next_id(),\n-                span: self.lower_span(span),\n-                name: hir::LifetimeName::Implicit(false),\n-            })));\n-        let generic_args = self.arena.alloc_from_iter(generic_args);\n+            }));\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n@@ -1805,7 +1792,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n         output: &FnRetTy,\n-        fn_def_id: DefId,\n+        fn_def_id: LocalDefId,\n         span: Span,\n     ) -> hir::GenericBound<'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n@@ -1816,7 +1803,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // generates.\n                 let context = ImplTraitContext::ReturnPositionOpaqueTy {\n                     fn_def_id,\n-                    origin: hir::OpaqueTyOrigin::FnReturn,\n+                    origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                 };\n                 self.lower_ty(ty, context)\n             }\n@@ -2453,17 +2440,12 @@ impl<'hir> GenericArgsCtor<'hir> {\n     }\n }\n \n+#[tracing::instrument(level = \"debug\")]\n fn lifetimes_from_impl_trait_bounds(\n     opaque_ty_id: NodeId,\n     bounds: hir::GenericBounds<'_>,\n     lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n ) -> Vec<(hir::LifetimeName, Span)> {\n-    debug!(\n-        \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n-             bounds={:#?})\",\n-        opaque_ty_id, bounds,\n-    );\n-\n     // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n     // appear in the bounds, excluding lifetimes that are created within the bounds.\n     // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`."}, {"sha": "76b3be7976c61e9b8def72466f0d6a39f95f8cfb", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -173,7 +173,7 @@ fn check_opaque_type_parameter_valid(\n         // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n         //\n         // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn | OpaqueTyOrigin::AsyncFn => return true,\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }"}, {"sha": "d393ea6893849b953f49be38c509656d6cc7a457", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -2248,17 +2248,16 @@ pub struct BareFnTy<'hir> {\n pub struct OpaqueTy<'hir> {\n     pub generics: Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n-    pub impl_trait_fn: Option<DefId>,\n     pub origin: OpaqueTyOrigin,\n }\n \n /// From whence the opaque type came.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n     /// `-> impl Trait`\n-    FnReturn,\n+    FnReturn(LocalDefId),\n     /// `async fn`\n-    AsyncFn,\n+    AsyncFn(LocalDefId),\n     /// type aliases: `type Foo = impl Trait;`\n     TyAlias,\n }\n@@ -2809,7 +2808,9 @@ impl ItemKind<'_> {\n         Some(match *self {\n             ItemKind::Fn(_, ref generics, _)\n             | ItemKind::TyAlias(_, ref generics)\n-            | ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. })\n+            | ItemKind::OpaqueTy(OpaqueTy {\n+                ref generics, origin: OpaqueTyOrigin::TyAlias, ..\n+            })\n             | ItemKind::Enum(_, ref generics)\n             | ItemKind::Struct(_, ref generics)\n             | ItemKind::Union(_, ref generics)"}, {"sha": "04eceecc5f072a6e4faf48fdde71178f03a78a52", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                         kind:\n                             hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                 bounds,\n-                                origin: hir::OpaqueTyOrigin::AsyncFn,\n+                                origin: hir::OpaqueTyOrigin::AsyncFn(..),\n                                 ..\n                             }),\n                         .."}, {"sha": "c2ef0b41e27bf182761eef46e02d64d33f6b86d9", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(?concrete_ty);\n \n         let first_own_region = match opaque_defn.origin {\n-            hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n+            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n                 // We lower\n                 //\n                 // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n@@ -461,35 +461,29 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     if let Some(def_id) = def_id.as_local() {\n                         let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                         let parent_def_id = self.infcx.defining_use_anchor;\n-                        let (in_definition_scope, origin) = match tcx.hir().expect_item(def_id).kind\n-                        {\n+                        let item_kind = &tcx.hir().expect_item(def_id).kind;\n+                        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n+                            span_bug!(\n+                                self.value_span,\n+                                \"weird opaque type: {:#?}, {:#?}\",\n+                                ty.kind(),\n+                                item_kind\n+                            )\n+                        };\n+                        let in_definition_scope = match *origin {\n+                            // Async `impl Trait`\n+                            hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n                             // Anonymous `impl Trait`\n-                            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                impl_trait_fn: Some(parent),\n-                                origin,\n-                                ..\n-                            }) => (parent == parent_def_id.to_def_id(), origin),\n+                            hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n                             // Named `type Foo = impl Bar;`\n-                            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                impl_trait_fn: None,\n-                                origin,\n-                                ..\n-                            }) => {\n-                                (may_define_opaque_type(tcx, parent_def_id, opaque_hir_id), origin)\n-                            }\n-                            ref itemkind => {\n-                                span_bug!(\n-                                    self.value_span,\n-                                    \"weird opaque type: {:#?}, {:#?}\",\n-                                    ty.kind(),\n-                                    itemkind\n-                                )\n+                            hir::OpaqueTyOrigin::TyAlias => {\n+                                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n                             }\n                         };\n                         if in_definition_scope {\n                             let opaque_type_key =\n                                 OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+                            return self.fold_opaque_ty(ty, opaque_type_key, *origin);\n                         }\n \n                         debug!("}, {"sha": "adba7d131592ec81b11a1b4096499445edd57824", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 89, "deletions": 51, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -1,7 +1,5 @@\n use crate::arena::Arena;\n-\n use rustc_serialize::{Encodable, Encoder};\n-\n use std::alloc::Layout;\n use std::cmp::Ordering;\n use std::fmt;\n@@ -12,49 +10,69 @@ use std::ops::Deref;\n use std::ptr;\n use std::slice;\n \n-extern \"C\" {\n-    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n-    /// pointers.\n-    type OpaqueListContents;\n-}\n-\n-/// A wrapper for slices with the additional invariant\n-/// that the slice is interned and no other slice with\n-/// the same contents can exist in the same context.\n-/// This means we can use pointer for both\n-/// equality comparisons and hashing.\n-///\n-/// Unlike slices, the types contained in `List` are expected to be `Copy`\n-/// and iterating over a `List` returns `T` instead of a reference.\n-///\n-/// Note: `Slice` was already taken by the `Ty`.\n+/// `List<T>` is a bit like `&[T]`, but with some critical differences.\n+/// - IMPORTANT: Every `List<T>` is *required* to have unique contents. The\n+///   type's correctness relies on this, *but it does not enforce it*.\n+///   Therefore, any code that creates a `List<T>` must ensure uniqueness\n+///   itself. In practice this is achieved by interning.\n+/// - The length is stored within the `List<T>`, so `&List<Ty>` is a thin\n+///   pointer.\n+/// - Because of this, you cannot get a `List<T>` that is a sub-list of another\n+///   `List<T>`. You can get a sub-slice `&[T]`, however.\n+/// - `List<T>` can be used with `CopyTaggedPtr`, which is useful within\n+///   structs whose size must be minimized.\n+/// - Because of the uniqueness assumption, we can use the address of a\n+///   `List<T>` for faster equality comparisons and hashing.\n+/// - `T` must be `Copy`. This lets `List<T>` be stored in a dropless arena and\n+///   iterators return a `T` rather than a `&T`.\n+/// - `T` must not be zero-sized.\n #[repr(C)]\n pub struct List<T> {\n     len: usize,\n+\n+    /// Although this claims to be a zero-length array, in practice `len`\n+    /// elements are actually present.\n     data: [T; 0],\n+\n     opaque: OpaqueListContents,\n }\n \n-unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n-    const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n-    #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *const List<T> as usize\n-    }\n-    #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &*(ptr as *const List<T>)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        // Self: Copy so this is fine\n-        let ptr = Self::from_usize(ptr);\n-        f(&ptr)\n-    }\n+extern \"C\" {\n+    /// A dummy type used to force `List` to be unsized while not requiring\n+    /// references to it be wide pointers.\n+    type OpaqueListContents;\n }\n \n-unsafe impl<T: Sync> Sync for List<T> {}\n+impl<T> List<T> {\n+    /// Returns a reference to the (unique, static) empty list.\n+    #[inline(always)]\n+    pub fn empty<'a>() -> &'a List<T> {\n+        #[repr(align(64))]\n+        struct MaxAlign;\n+\n+        assert!(mem::align_of::<T>() <= mem::align_of::<MaxAlign>());\n+\n+        #[repr(C)]\n+        struct InOrder<T, U>(T, U);\n+\n+        // The empty slice is static and contains a single `0` usize (for the\n+        // length) that is 64-byte aligned, thus featuring the necessary\n+        // trailing padding for elements with up to 64-byte alignment.\n+        static EMPTY_SLICE: InOrder<usize, MaxAlign> = InOrder(0, MaxAlign);\n+        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+    }\n+}\n \n impl<T: Copy> List<T> {\n+    /// Allocates a list from `arena` and copies the contents of `slice` into it.\n+    ///\n+    /// WARNING: the contents *must be unique*, such that no list with these\n+    /// contents has been previously created. If not, operations such as `eq`\n+    /// and `hash` might give incorrect results.\n+    ///\n+    /// Panics if `T` is `Drop`, or `T` is zero-sized, or the slice is empty\n+    /// (because the empty list exists statically, and is available via\n+    /// `empty()`).\n     #[inline]\n     pub(super) fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n         assert!(!mem::needs_drop::<T>());\n@@ -73,7 +91,7 @@ impl<T: Copy> List<T> {\n                 .cast::<T>()\n                 .copy_from_nonoverlapping(slice.as_ptr(), slice.len());\n \n-            &mut *mem\n+            &*mem\n         }\n     }\n \n@@ -107,11 +125,24 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for &List<T> {\n     }\n }\n \n+impl<T: PartialEq> PartialEq for List<T> {\n+    #[inline]\n+    fn eq(&self, other: &List<T>) -> bool {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption).\n+        ptr::eq(self, other)\n+    }\n+}\n+\n+impl<T: Eq> Eq for List<T> {}\n+\n impl<T> Ord for List<T>\n where\n     T: Ord,\n {\n     fn cmp(&self, other: &List<T>) -> Ordering {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption), but the contents must be compared otherwise.\n         if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n     }\n }\n@@ -121,6 +152,8 @@ where\n     T: PartialOrd,\n {\n     fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption), but the contents must be compared otherwise.\n         if self == other {\n             Some(Ordering::Equal)\n         } else {\n@@ -129,17 +162,11 @@ where\n     }\n }\n \n-impl<T: PartialEq> PartialEq for List<T> {\n-    #[inline]\n-    fn eq(&self, other: &List<T>) -> bool {\n-        ptr::eq(self, other)\n-    }\n-}\n-impl<T: Eq> Eq for List<T> {}\n-\n impl<T> Hash for List<T> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n+        // Pointer hashing is sufficient (due to the unique contents\n+        // assumption).\n         (self as *const List<T>).hash(s)\n     }\n }\n@@ -168,13 +195,24 @@ impl<'a, T: Copy> IntoIterator for &'a List<T> {\n     }\n }\n \n-impl<T> List<T> {\n-    #[inline(always)]\n-    pub fn empty<'a>() -> &'a List<T> {\n-        #[repr(align(64), C)]\n-        struct EmptySlice([u8; 64]);\n-        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n-        assert!(mem::align_of::<T>() <= 64);\n-        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+unsafe impl<T: Sync> Sync for List<T> {}\n+\n+unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n+    const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n+\n+    #[inline]\n+    fn into_usize(self) -> usize {\n+        self as *const List<T> as usize\n+    }\n+\n+    #[inline]\n+    unsafe fn from_usize(ptr: usize) -> &'a List<T> {\n+        &*(ptr as *const List<T>)\n+    }\n+\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        // `Self` is `&'a List<T>` which impls `Copy`, so this is fine.\n+        let ptr = Self::from_usize(ptr);\n+        f(&ptr)\n     }\n }"}, {"sha": "fd1409949f0a707ef225525cc481565796ae045a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -2055,13 +2055,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-/// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n-pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    if let Some(def_id) = def_id.as_local() {\n-        if let Node::Item(item) = tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n-            if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n-                return opaque_ty.impl_trait_fn;\n-            }\n+/// Yields the parent function's `LocalDefId` if `def_id` is an `impl Trait` definition.\n+pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<LocalDefId> {\n+    let def_id = def_id.as_local()?;\n+    if let Node::Item(item) = tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n+        if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n+            return match opaque_ty.origin {\n+                hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent) => {\n+                    Some(parent)\n+                }\n+                hir::OpaqueTyOrigin::TyAlias => None,\n+            };\n         }\n     }\n     None"}, {"sha": "23d59c8007135c0b91ba9031a28c19d87e7f190a", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -105,6 +105,11 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n                                     a misaligned reference is undefined behavior (even if that \\\n                                     reference is never dereferenced)\",\n                                 )\n+                                .help(\n+                                    \"copy the field contents to a local variable, or replace the \\\n+                                    reference with a raw pointer and use `read_unaligned`/`write_unaligned` \\\n+                                    (loads and stores via `*p` must be properly aligned even when using raw pointers)\"\n+                                )\n                                 .emit()\n                         },\n                     );"}, {"sha": "c94c56df75b7821a435fbe3150cee9bc9f7f65be", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -968,7 +968,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let (generics, bounds) = match opaque_ty.kind {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: None, .. }) => {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                        origin: hir::OpaqueTyOrigin::TyAlias,\n+                        ..\n+                    }) => {\n                         intravisit::walk_ty(self, ty);\n \n                         // Elided lifetimes are not allowed in non-return\n@@ -985,7 +988,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                     // RPIT (return position impl trait)\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                        impl_trait_fn: Some(_),\n+                        origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n                         ref generics,\n                         bounds,\n                         ..\n@@ -1695,7 +1698,11 @@ fn compute_object_lifetime_defaults(\n         hir::ItemKind::Struct(_, ref generics)\n         | hir::ItemKind::Union(_, ref generics)\n         | hir::ItemKind::Enum(_, ref generics)\n-        | hir::ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, impl_trait_fn: None, .. })\n+        | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+            ref generics,\n+            origin: hir::OpaqueTyOrigin::TyAlias,\n+            ..\n+        })\n         | hir::ItemKind::TyAlias(_, ref generics)\n         | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n             let result = object_lifetime_defaults_for_item(tcx, generics);\n@@ -2067,7 +2074,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     ..\n                                 }) = self.tcx.hir().get(parent_hir_id)\n                                 {\n-                                    if opaque.origin != hir::OpaqueTyOrigin::AsyncFn {\n+                                    if !matches!(opaque.origin, hir::OpaqueTyOrigin::AsyncFn(..)) {\n                                         continue 'lifetimes;\n                                     }\n                                     // We want to do this only if the liftime identifier is already defined"}, {"sha": "74a015d4c348e68445df79ee8e236f017679dfe8", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -248,7 +248,7 @@ fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // The param_env of an impl Trait type is its defining function's param_env\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n-        return param_env(tcx, parent);\n+        return param_env(tcx, parent.to_def_id());\n     }\n     // Compute the bounds on Self and the type parameters.\n \n@@ -313,7 +313,7 @@ fn well_formed_types_in_env<'tcx>(\n \n     // The environment of an impl Trait type is its defining function's environment.\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n-        return well_formed_types_in_env(tcx, parent);\n+        return well_formed_types_in_env(tcx, parent.to_def_id());\n     }\n \n     // Compute the bounds on `Self` and the type parameters."}, {"sha": "dc52c49499a5805c76ddf2871de0223501ae269a", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -2336,9 +2336,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let def_id = item_id.def_id.to_def_id();\n \n                 match opaque_ty.kind {\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n-                        self.impl_trait_ty_to_ty(def_id, lifetimes, impl_trait_fn.is_some())\n-                    }\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => self\n+                        .impl_trait_ty_to_ty(\n+                            def_id,\n+                            lifetimes,\n+                            matches!(\n+                                origin,\n+                                hir::OpaqueTyOrigin::FnReturn(..)\n+                                    | hir::OpaqueTyOrigin::AsyncFn(..)\n+                            ),\n+                        ),\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 }\n             }"}, {"sha": "a6b16e7f0d4d8128811e0742c3cffcbe0439c108", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -541,7 +541,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n     }\n \n     if let ItemKind::OpaqueTy(hir::OpaqueTy {\n-        origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n+        origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n         ..\n     }) = item.kind\n     {\n@@ -567,7 +567,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n             visitor.visit_item(&item);\n             let is_async = match item.kind {\n                 ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n-                    matches!(origin, hir::OpaqueTyOrigin::AsyncFn)\n+                    matches!(origin, hir::OpaqueTyOrigin::AsyncFn(..))\n                 }\n                 _ => unreachable!(),\n             };\n@@ -604,7 +604,7 @@ pub(super) fn check_opaque_for_cycles<'tcx>(\n ) -> Result<(), ErrorReported> {\n     if tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs).is_err() {\n         match origin {\n-            hir::OpaqueTyOrigin::AsyncFn => async_opaque_type_cycle_error(tcx, span),\n+            hir::OpaqueTyOrigin::AsyncFn(..) => async_opaque_type_cycle_error(tcx, span),\n             _ => opaque_type_cycle_error(tcx, def_id, span),\n         }\n         Err(ErrorReported)\n@@ -635,7 +635,7 @@ fn check_opaque_meets_bounds<'tcx>(\n ) {\n     match origin {\n         // Checked when type checking the function containing them.\n-        hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => return,\n+        hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => return,\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {}\n     }"}, {"sha": "1334328f4e2ae111f9e3f76e1f238b0e4a6ab863", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -594,7 +594,11 @@ fn type_param_predicates(\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(hir::Impl { ref generics, .. })\n                 | ItemKind::TyAlias(_, ref generics)\n-                | ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. })\n+                | ItemKind::OpaqueTy(OpaqueTy {\n+                    ref generics,\n+                    origin: hir::OpaqueTyOrigin::TyAlias,\n+                    ..\n+                })\n                 | ItemKind::Enum(_, ref generics)\n                 | ItemKind::Struct(_, ref generics)\n                 | ItemKind::Union(_, ref generics) => generics,\n@@ -793,7 +797,10 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         }\n \n         // Desugared from `impl Trait`, so visited by the function's return type.\n-        hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) => {}\n+        hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+            origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n+            ..\n+        }) => {}\n \n         // Don't call `type_of` on opaque types, since that depends on type\n         // checking function bodies. `check_item_type` ensures that it's called\n@@ -1488,15 +1495,18 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             Some(tcx.typeck_root_def_id(def_id))\n         }\n         Node::Item(item) => match item.kind {\n-            ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n-                impl_trait_fn.or_else(|| {\n-                    let parent_id = tcx.hir().get_parent_item(hir_id);\n-                    assert!(parent_id != hir_id && parent_id != CRATE_HIR_ID);\n-                    debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n-                    // Opaque types are always nested within another item, and\n-                    // inherit the generics of the item.\n-                    Some(tcx.hir().local_def_id(parent_id).to_def_id())\n-                })\n+            ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin:\n+                    hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n+                ..\n+            }) => Some(fn_def_id.to_def_id()),\n+            ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n+                let parent_id = tcx.hir().get_parent_item(hir_id);\n+                assert!(parent_id != hir_id && parent_id != CRATE_HIR_ID);\n+                debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n+                // Opaque types are always nested within another item, and\n+                // inherit the generics of the item.\n+                Some(tcx.hir().local_def_id(parent_id).to_def_id())\n             }\n             _ => None,\n         },\n@@ -2051,31 +2061,32 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     generics\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy {\n-                    bounds: _,\n-                    impl_trait_fn,\n+                    origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n+                    ..\n+                }) => {\n+                    // return-position impl trait\n+                    //\n+                    // We don't inherit predicates from the parent here:\n+                    // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n+                    // then the return type is `f::<'static, T>::{{opaque}}`.\n+                    //\n+                    // If we inherited the predicates of `f` then we would\n+                    // require that `T: 'static` to show that the return\n+                    // type is well-formed.\n+                    //\n+                    // The only way to have something with this opaque type\n+                    // is from the return type of the containing function,\n+                    // which will ensure that the function's predicates\n+                    // hold.\n+                    return ty::GenericPredicates { parent: None, predicates: &[] };\n+                }\n+                ItemKind::OpaqueTy(OpaqueTy {\n                     ref generics,\n-                    origin: _,\n+                    origin: hir::OpaqueTyOrigin::TyAlias,\n+                    ..\n                 }) => {\n-                    if impl_trait_fn.is_some() {\n-                        // return-position impl trait\n-                        //\n-                        // We don't inherit predicates from the parent here:\n-                        // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n-                        // then the return type is `f::<'static, T>::{{opaque}}`.\n-                        //\n-                        // If we inherited the predicates of `f` then we would\n-                        // require that `T: 'static` to show that the return\n-                        // type is well-formed.\n-                        //\n-                        // The only way to have something with this opaque type\n-                        // is from the return type of the containing function,\n-                        // which will ensure that the function's predicates\n-                        // hold.\n-                        return ty::GenericPredicates { parent: None, predicates: &[] };\n-                    } else {\n-                        // type-alias impl trait\n-                        generics\n-                    }\n+                    // type-alias impl trait\n+                    generics\n                 }\n \n                 _ => NO_GENERICS,"}, {"sha": "af199ca99460f292a1236e55966669ba6859e70c", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -394,13 +394,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                     tcx.mk_adt(def, substs)\n                 }\n-                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n+                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n                     find_opaque_ty_constraints(tcx, def_id)\n                 }\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n+                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn(owner) | hir::OpaqueTyOrigin::AsyncFn(owner), .. }) => {\n                     let concrete_ty = tcx\n-                        .mir_borrowck(owner.expect_local())\n+                        .mir_borrowck(owner)\n                         .concrete_opaque_types\n                         .get_value_matching(|(key, _)| key.def_id == def_id.to_def_id())\n                         .copied()\n@@ -413,7 +413,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 ),\n                             );\n                             if let Some(ErrorReported) =\n-                                tcx.typeck(owner.expect_local()).tainted_by_errors\n+                                tcx.typeck(owner).tainted_by_errors\n                             {\n                                 // Some error in the\n                                 // owner fn prevented us from populating"}, {"sha": "920fa59c8ad6e472df948a27d0a9d2df39ce843f", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -45,15 +45,23 @@ impl<A: Iterator, B: Iterator> Zip<A, B> {\n ///\n /// let xs = [1, 2, 3];\n /// let ys = [4, 5, 6];\n-/// for (x, y) in zip(&xs, &ys) {\n-///     println!(\"x:{}, y:{}\", x, y);\n-/// }\n+///\n+/// let mut iter = zip(xs, ys);\n+///\n+/// assert_eq!(iter.next().unwrap(), (1, 4));\n+/// assert_eq!(iter.next().unwrap(), (2, 5));\n+/// assert_eq!(iter.next().unwrap(), (3, 6));\n+/// assert!(iter.next().is_none());\n ///\n /// // Nested zips are also possible:\n /// let zs = [7, 8, 9];\n-/// for ((x, y), z) in zip(zip(&xs, &ys), &zs) {\n-///     println!(\"x:{}, y:{}, z:{}\", x, y, z);\n-/// }\n+///\n+/// let mut iter = zip(zip(xs, ys), zs);\n+///\n+/// assert_eq!(iter.next().unwrap(), ((1, 4), 7));\n+/// assert_eq!(iter.next().unwrap(), ((2, 5), 8));\n+/// assert_eq!(iter.next().unwrap(), ((3, 6), 9));\n+/// assert!(iter.next().is_none());\n /// ```\n #[unstable(feature = \"iter_zip\", issue = \"83574\")]\n pub fn zip<A, B>(a: A, b: B) -> Zip<A::IntoIter, B::IntoIter>"}, {"sha": "dae85027b6c2926d97de5179f08047107dae2494", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -1058,7 +1058,7 @@ impl Metadata {\n     /// }\n     /// ```\n     #[must_use]\n-    #[stable(feature = \"is_symlink\", since = \"1.57.0\")]\n+    #[stable(feature = \"is_symlink\", since = \"1.58.0\")]\n     pub fn is_symlink(&self) -> bool {\n         self.file_type().is_symlink()\n     }"}, {"sha": "7d401cff591c19d83e9a8c0b4eb5e8e0ff5c70f2", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -2817,7 +2817,7 @@ impl Path {\n     /// check errors, call [`fs::symlink_metadata`] and handle its [`Result`]. Then call\n     /// [`fs::Metadata::is_symlink`] if it was [`Ok`].\n     #[must_use]\n-    #[stable(feature = \"is_symlink\", since = \"1.57.0\")]\n+    #[stable(feature = \"is_symlink\", since = \"1.58.0\")]\n     pub fn is_symlink(&self) -> bool {\n         fs::symlink_metadata(self).map(|m| m.is_symlink()).unwrap_or(false)\n     }"}, {"sha": "35df5fa1b7470a9307cf9927dd2fe426a5705e78", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -327,6 +327,19 @@ impl Options {\n             return Err(0);\n         }\n \n+        let color = config::parse_color(matches);\n+        let config::JsonConfig { json_rendered, json_unused_externs, .. } =\n+            config::parse_json(matches);\n+        let error_format = config::parse_error_format(matches, color, json_rendered);\n+\n+        let codegen_options = CodegenOptions::build(matches, error_format);\n+        let debugging_opts = DebuggingOptions::build(matches, error_format);\n+\n+        let diag = new_handler(error_format, None, &debugging_opts);\n+\n+        // check for deprecated options\n+        check_deprecated_options(matches, &diag);\n+\n         if matches.opt_strs(\"passes\") == [\"list\"] {\n             println!(\"Available passes for running rustdoc:\");\n             for pass in passes::PASSES {\n@@ -359,19 +372,6 @@ impl Options {\n             return Err(0);\n         }\n \n-        let color = config::parse_color(matches);\n-        let config::JsonConfig { json_rendered, json_unused_externs, .. } =\n-            config::parse_json(matches);\n-        let error_format = config::parse_error_format(matches, color, json_rendered);\n-\n-        let codegen_options = CodegenOptions::build(matches, error_format);\n-        let debugging_opts = DebuggingOptions::build(matches, error_format);\n-\n-        let diag = new_handler(error_format, None, &debugging_opts);\n-\n-        // check for deprecated options\n-        check_deprecated_options(matches, &diag);\n-\n         let mut emit = Vec::new();\n         for list in matches.opt_strs(\"emit\") {\n             for kind in list.split(',') {"}, {"sha": "9943e23b9281c1b07d54b485cc890391e0a4064e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -976,6 +976,7 @@ fn item_typedef(\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n+    document_type_layout(w, cx, def_id);\n }\n \n fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {"}, {"sha": "b7057d868c27565e2de0992638041e9f29999c36", "filename": "src/test/rustdoc-ui/issue-91713.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Frustdoc-ui%2Fissue-91713.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Frustdoc-ui%2Fissue-91713.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-91713.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -0,0 +1,3 @@\n+// check-pass\n+// compile-flags: --passes list\n+// error-pattern: the `passes` flag is deprecated"}, {"sha": "70c22b3c01e9e4ab17f516e65333c1bac6472528", "filename": "src/test/rustdoc-ui/issue-91713.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stderr?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -0,0 +1,4 @@\n+warning: the `passes` flag is deprecated\n+   |\n+   = note: see issue #44136 <https://github.com/rust-lang/rust/issues/44136> for more information\n+"}, {"sha": "d0372d4945f3a4598043fea06c2565c2f5ae8373", "filename": "src/test/rustdoc-ui/issue-91713.stdout", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -0,0 +1,31 @@\n+Available passes for running rustdoc:\n+check_doc_test_visibility - run various visibility-related lints on doctests\n+        strip-hidden - strips all `#[doc(hidden)]` items from the output\n+   unindent-comments - removes excess indentation on comments in order for markdown to like it\n+       strip-private - strips all private items from a crate which cannot be seen externally, implies strip-priv-imports\n+  strip-priv-imports - strips all private import statements (`use`, `extern crate`) from a crate\n+   propagate-doc-cfg - propagates `#[doc(cfg(...))]` to child items\n+collect-intra-doc-links - resolves intra-doc links\n+check-code-block-syntax - validates syntax inside Rust code blocks\n+ collect-trait-impls - retrieves trait impls for items in the crate\n+calculate-doc-coverage - counts the number of items with and without documentation\n+check-invalid-html-tags - detects invalid HTML tags in doc comments\n+     check-bare-urls - detects URLs that are not hyperlinks\n+\n+Default passes for rustdoc:\n+ collect-trait-impls\n+   unindent-comments\n+check_doc_test_visibility\n+        strip-hidden  (when not --document-hidden-items)\n+       strip-private  (when not --document-private-items)\n+  strip-priv-imports  (when --document-private-items)\n+collect-intra-doc-links\n+check-code-block-syntax\n+check-invalid-html-tags\n+   propagate-doc-cfg\n+     check-bare-urls\n+\n+Passes run with `--show-coverage`:\n+        strip-hidden  (when not --document-hidden-items)\n+       strip-private  (when not --document-private-items)\n+calculate-doc-coverage"}, {"sha": "4eea9809ac58f66e19e5bab3f29307c6a6c19d6d", "filename": "src/test/rustdoc/type-layout.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Frustdoc%2Ftype-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Frustdoc%2Ftype-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftype-layout.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -50,6 +50,18 @@ pub struct GenericLifetimes<'a>(&'a str);\n // @has - '(unsized)'\n pub struct Unsized([u8]);\n \n+// @has type_layout/type.TypeAlias.html 'Size: '\n+// @has - ' bytes'\n+pub type TypeAlias = X;\n+\n+// @has type_layout/type.GenericTypeAlias.html 'Size: '\n+// @has - '8 bytes'\n+pub type GenericTypeAlias = (Generic<(u32, ())>, Generic<u32>);\n+\n+// Regression test for the rustdoc equivalent of #85103.\n+// @has type_layout/type.Edges.html 'Encountered an error during type layout; the type failed to be normalized.'\n+pub type Edges<'a, E> = std::borrow::Cow<'a, [E]>;\n+\n // @!has type_layout/trait.MyTrait.html 'Size: '\n pub trait MyTrait {}\n "}, {"sha": "90ab0c01f5450f086ad569fdb911eecaf721284c", "filename": "src/test/ui/async-await/generics-and-bounds.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -2,6 +2,8 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n+#![feature(in_band_lifetimes)]\n+\n use std::future::Future;\n \n pub async fn simple_generic<T>() {}\n@@ -71,6 +73,10 @@ pub fn call_with_ref_block<'a>(f: &'a (impl Foo + 'a)) -> impl Future<Output = (\n     async move { f.foo() }\n }\n \n+pub fn call_with_ref_block_in_band(f: &'a (impl Foo + 'a)) -> impl Future<Output = ()> + 'a {\n+    async move { f.foo() }\n+}\n+\n pub fn async_block_with_same_generic_params_unifies() {\n     let mut a = call_generic_bound_block(FooType);\n     a = call_generic_bound_block(FooType);\n@@ -85,4 +91,9 @@ pub fn async_block_with_same_generic_params_unifies() {\n     let f_two = FooType;\n     let mut d = call_with_ref_block(&f_one);\n     d = call_with_ref_block(&f_two);\n+\n+    let f_one = FooType;\n+    let f_two = FooType;\n+    let mut d = call_with_ref_block_in_band(&f_one);\n+    d = call_with_ref_block_in_band(&f_two);\n }"}, {"sha": "84cdb1453f82d4d0c7e2f6a3b904726efb2ff7a1", "filename": "src/test/ui/binding/issue-53114-safety-checks.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -8,6 +8,7 @@ LL |     let _ = &p.b;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n warning: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:29:17\n@@ -18,6 +19,7 @@ LL |     let (_,) = (&p.b,);\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n warning: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:39:11\n@@ -28,6 +30,7 @@ LL |     match &p.b  { _ => { } }\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n warning: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:45:12\n@@ -38,6 +41,7 @@ LL |     match (&p.b,)  { (_,) => { } }\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:26:13"}, {"sha": "fc0179d2cb4ca45779bc5e7619d7c673238145f7", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -8,6 +8,7 @@ LL |         println!(\"{}\", foo.x);\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n    = note: this warning originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: 1 warning emitted"}, {"sha": "53c9380fb7efbda5d3b9ddd464208b2c39407984", "filename": "src/test/ui/lint/unaligned_references.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -12,6 +12,7 @@ LL | #![deny(unaligned_references)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/unaligned_references.rs:24:17\n@@ -22,6 +23,7 @@ LL |         let _ = &good.data;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/unaligned_references.rs:27:17\n@@ -32,6 +34,7 @@ LL |         let _ = &good.data as *const _;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/unaligned_references.rs:29:27\n@@ -42,6 +45,7 @@ LL |         let _: *const _ = &good.data;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/unaligned_references.rs:32:17\n@@ -52,6 +56,7 @@ LL |         let _ = good.data.clone();\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/unaligned_references.rs:35:17\n@@ -62,6 +67,7 @@ LL |         let _ = &good.data2[0];\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/unaligned_references.rs:45:17\n@@ -72,6 +78,7 @@ LL |         let _ = &packed2.x;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: aborting due to 7 previous errors\n "}, {"sha": "01e2395049df43a1353c637509448cd04c6c09f3", "filename": "src/test/ui/lint/unaligned_references_external_macro.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -24,6 +24,7 @@ LL | | }\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n    = note: this error originates in the macro `unaligned_references_external_crate::mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "bba056d59f831a246422d6f59662b2598dc9c589", "filename": "src/test/ui/packed/issue-27060.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fissue-27060.stderr?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -12,6 +12,7 @@ LL | #[deny(unaligned_references)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/issue-27060.rs:18:13\n@@ -22,6 +23,7 @@ LL |     let _ = &good.data2[0];\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/issue-27060.rs:21:13\n@@ -32,6 +34,7 @@ LL |     let _ = &good.data;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: reference to packed field is unaligned\n   --> $DIR/issue-27060.rs:23:13\n@@ -42,6 +45,7 @@ LL |     let _ = &good.data2[0];\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "04585b499862be41d06877ff91a1607ad788753d", "filename": "src/test/ui/packed/packed-struct-borrow-element-64bit.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element-64bit.stderr?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -8,6 +8,7 @@ LL |     let brw = &foo.baz;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n warning: 1 warning emitted\n "}, {"sha": "a50b130200151ef1dc543db30803b837a9396441", "filename": "src/test/ui/packed/packed-struct-borrow-element.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc6aa673317cf72a8abb9c421f573f2b34b47a/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr?ref=b8dc6aa673317cf72a8abb9c421f573f2b34b47a", "patch": "@@ -8,6 +8,7 @@ LL |     let brw = &foo.baz;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n warning: reference to packed field is unaligned\n   --> $DIR/packed-struct-borrow-element.rs:30:15\n@@ -18,6 +19,7 @@ LL |     let brw = &foo.baz;\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n \n warning: 2 warnings emitted\n "}]}