{"sha": "8805a768d442b07d7f0152a5f6a8dd1ce2b21350", "node_id": "C_kwDOAAsO6NoAKDg4MDVhNzY4ZDQ0MmIwN2Q3ZjAxNTJhNWY2YThkZDFjZTJiMjEzNTA", "commit": {"author": {"name": "Hongxu Xu", "email": "xuhongxu96@hotmail.com", "date": "2022-06-14T23:47:06Z"}, "committer": {"name": "Hongxu Xu", "email": "xuhongxu96@hotmail.com", "date": "2022-06-14T23:47:06Z"}, "message": "check if the container is trait and inherit the visibility", "tree": {"sha": "f356462f0c750aa9e1b6e14c4d0a5bb1ab7f5010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f356462f0c750aa9e1b6e14c4d0a5bb1ab7f5010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8805a768d442b07d7f0152a5f6a8dd1ce2b21350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8805a768d442b07d7f0152a5f6a8dd1ce2b21350", "html_url": "https://github.com/rust-lang/rust/commit/8805a768d442b07d7f0152a5f6a8dd1ce2b21350", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8805a768d442b07d7f0152a5f6a8dd1ce2b21350/comments", "author": {"login": "xuhongxu96", "id": 2201482, "node_id": "MDQ6VXNlcjIyMDE0ODI=", "avatar_url": "https://avatars.githubusercontent.com/u/2201482?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xuhongxu96", "html_url": "https://github.com/xuhongxu96", "followers_url": "https://api.github.com/users/xuhongxu96/followers", "following_url": "https://api.github.com/users/xuhongxu96/following{/other_user}", "gists_url": "https://api.github.com/users/xuhongxu96/gists{/gist_id}", "starred_url": "https://api.github.com/users/xuhongxu96/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xuhongxu96/subscriptions", "organizations_url": "https://api.github.com/users/xuhongxu96/orgs", "repos_url": "https://api.github.com/users/xuhongxu96/repos", "events_url": "https://api.github.com/users/xuhongxu96/events{/privacy}", "received_events_url": "https://api.github.com/users/xuhongxu96/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xuhongxu96", "id": 2201482, "node_id": "MDQ6VXNlcjIyMDE0ODI=", "avatar_url": "https://avatars.githubusercontent.com/u/2201482?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xuhongxu96", "html_url": "https://github.com/xuhongxu96", "followers_url": "https://api.github.com/users/xuhongxu96/followers", "following_url": "https://api.github.com/users/xuhongxu96/following{/other_user}", "gists_url": "https://api.github.com/users/xuhongxu96/gists{/gist_id}", "starred_url": "https://api.github.com/users/xuhongxu96/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xuhongxu96/subscriptions", "organizations_url": "https://api.github.com/users/xuhongxu96/orgs", "repos_url": "https://api.github.com/users/xuhongxu96/repos", "events_url": "https://api.github.com/users/xuhongxu96/events{/privacy}", "received_events_url": "https://api.github.com/users/xuhongxu96/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "070456838da319ec73768edeff5df2a828abb869", "url": "https://api.github.com/repos/rust-lang/rust/commits/070456838da319ec73768edeff5df2a828abb869", "html_url": "https://github.com/rust-lang/rust/commit/070456838da319ec73768edeff5df2a828abb869"}], "stats": {"total": 103, "additions": 33, "deletions": 70}, "files": [{"sha": "7436f0100bddd086f267f29c475290db179285f7", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8805a768d442b07d7f0152a5f6a8dd1ce2b21350/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8805a768d442b07d7f0152a5f6a8dd1ce2b21350/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=8805a768d442b07d7f0152a5f6a8dd1ce2b21350", "patch": "@@ -15,8 +15,8 @@ use crate::{\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n-    InheritedVisibilityLoc, Intern, ItemContainerId, Lookup, Macro2Id, MacroRulesId, ModuleId,\n-    ProcMacroId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    Intern, ItemContainerId, Lookup, Macro2Id, MacroRulesId, ModuleId, ProcMacroId, StaticId,\n+    TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -40,9 +40,8 @@ impl FunctionData {\n         let cfg_options = &crate_graph[krate].cfg_options;\n         let item_tree = loc.id.item_tree(db);\n         let func = &item_tree[loc.id.value];\n-\n-        let visibility = if let Some(inherited_vis) = loc.inherited_visibility {\n-            inherited_vis.tree_id.item_tree(db)[inherited_vis.raw_visibility_id].clone()\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n         } else {\n             item_tree[func.visibility].clone()\n         };\n@@ -177,8 +176,8 @@ impl TypeAliasData {\n         let loc = typ.lookup(db);\n         let item_tree = loc.id.item_tree(db);\n         let typ = &item_tree[loc.id.value];\n-        let visibility = if let Some(inherited_vis) = loc.inherited_visibility {\n-            inherited_vis.tree_id.item_tree(db)[inherited_vis.raw_visibility_id].clone()\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n         } else {\n             item_tree[typ.visibility].clone()\n         };\n@@ -232,7 +231,6 @@ impl TraitData {\n             module_id,\n             tr_loc.id.file_id(),\n             ItemContainerId::TraitId(tr),\n-            Some(InheritedVisibilityLoc::new(tr_def.visibility, tr_loc.id.tree_id())),\n         );\n         collector.collect(tr_loc.id.tree_id(), &tr_def.items);\n \n@@ -300,7 +298,6 @@ impl ImplData {\n             module_id,\n             impl_loc.id.file_id(),\n             ItemContainerId::ImplId(id),\n-            None,\n         );\n         collector.collect(impl_loc.id.tree_id(), &impl_def.items);\n \n@@ -398,8 +395,8 @@ impl ConstData {\n         let loc = konst.lookup(db);\n         let item_tree = loc.id.item_tree(db);\n         let konst = &item_tree[loc.id.value];\n-        let visibility = if let Some(inherited_vis) = loc.inherited_visibility {\n-            inherited_vis.tree_id.item_tree(db)[inherited_vis.raw_visibility_id].clone()\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n         } else {\n             item_tree[konst.visibility].clone()\n         };\n@@ -446,8 +443,6 @@ struct AssocItemCollector<'a> {\n \n     items: Vec<(Name, AssocItemId)>,\n     attr_calls: Vec<(AstId<ast::Item>, MacroCallId)>,\n-\n-    inherited_visibility: Option<InheritedVisibilityLoc>,\n }\n \n impl<'a> AssocItemCollector<'a> {\n@@ -456,7 +451,6 @@ impl<'a> AssocItemCollector<'a> {\n         module_id: ModuleId,\n         file_id: HirFileId,\n         container: ItemContainerId,\n-        inherited_visibility: Option<InheritedVisibilityLoc>,\n     ) -> Self {\n         Self {\n             db,\n@@ -467,8 +461,6 @@ impl<'a> AssocItemCollector<'a> {\n \n             items: Vec::new(),\n             attr_calls: Vec::new(),\n-\n-            inherited_visibility,\n         }\n     }\n \n@@ -511,12 +503,9 @@ impl<'a> AssocItemCollector<'a> {\n             match item {\n                 AssocItem::Function(id) => {\n                     let item = &item_tree[id];\n-                    let def = FunctionLoc {\n-                        container: self.container,\n-                        id: ItemTreeId::new(tree_id, id),\n-                        inherited_visibility: self.inherited_visibility,\n-                    }\n-                    .intern(self.db);\n+                    let def =\n+                        FunctionLoc { container: self.container, id: ItemTreeId::new(tree_id, id) }\n+                            .intern(self.db);\n                     self.items.push((item.name.clone(), def.into()));\n                 }\n                 AssocItem::Const(id) => {\n@@ -525,20 +514,16 @@ impl<'a> AssocItemCollector<'a> {\n                         Some(name) => name,\n                         None => continue,\n                     };\n-                    let def = ConstLoc {\n-                        container: self.container,\n-                        id: ItemTreeId::new(tree_id, id),\n-                        inherited_visibility: self.inherited_visibility,\n-                    }\n-                    .intern(self.db);\n+                    let def =\n+                        ConstLoc { container: self.container, id: ItemTreeId::new(tree_id, id) }\n+                            .intern(self.db);\n                     self.items.push((name, def.into()));\n                 }\n                 AssocItem::TypeAlias(id) => {\n                     let item = &item_tree[id];\n                     let def = TypeAliasLoc {\n                         container: self.container,\n                         id: ItemTreeId::new(tree_id, id),\n-                        inherited_visibility: self.inherited_visibility,\n                     }\n                     .intern(self.db);\n                     self.items.push((item.name.clone(), def.into()));"}, {"sha": "071cf7be6051d9bc26489612715d6a17dcd5bad2", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8805a768d442b07d7f0152a5f6a8dd1ce2b21350/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8805a768d442b07d7f0152a5f6a8dd1ce2b21350/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=8805a768d442b07d7f0152a5f6a8dd1ce2b21350", "patch": "@@ -70,7 +70,7 @@ use hir_expand::{\n     AstId, ExpandError, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,\n     MacroDefKind, UnresolvedMacro,\n };\n-use item_tree::{ExternBlock, RawVisibilityId, TreeId};\n+use item_tree::ExternBlock;\n use la_arena::Idx;\n use nameres::DefMap;\n use stdx::impl_from;\n@@ -156,25 +156,19 @@ impl<N: ItemTreeNode> Hash for ItemLoc<N> {\n     }\n }\n \n-#[derive(Debug, Clone, Copy)]\n-pub struct InheritedVisibilityLoc {\n-    pub raw_visibility_id: RawVisibilityId,\n-    pub tree_id: TreeId,\n-}\n-\n-impl InheritedVisibilityLoc {\n-    pub fn new(visibility_id: RawVisibilityId, tree_id: TreeId) -> Self {\n-        Self { raw_visibility_id: visibility_id, tree_id }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug)]\n pub struct AssocItemLoc<N: ItemTreeNode> {\n     pub container: ItemContainerId,\n     pub id: ItemTreeId<N>,\n-    pub inherited_visibility: Option<InheritedVisibilityLoc>,\n }\n \n+impl<N: ItemTreeNode> Clone for AssocItemLoc<N> {\n+    fn clone(&self) -> Self {\n+        Self { container: self.container, id: self.id }\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Copy for AssocItemLoc<N> {}\n impl<N: ItemTreeNode> PartialEq for AssocItemLoc<N> {\n     fn eq(&self, other: &Self) -> bool {\n         self.container == other.container && self.id == other.id"}, {"sha": "7fea46bee3ca8f8cf6da77e8dc48ff85cef2c05a", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8805a768d442b07d7f0152a5f6a8dd1ce2b21350/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8805a768d442b07d7f0152a5f6a8dd1ce2b21350/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=8805a768d442b07d7f0152a5f6a8dd1ce2b21350", "patch": "@@ -1549,12 +1549,8 @@ impl ModCollector<'_, '_> {\n                 }\n                 ModItem::Function(id) => {\n                     let it = &self.item_tree[id];\n-                    let fn_id = FunctionLoc {\n-                        container,\n-                        id: ItemTreeId::new(self.tree_id, id),\n-                        inherited_visibility: None,\n-                    }\n-                    .intern(db);\n+                    let fn_id =\n+                        FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     if self.def_collector.is_proc_macro {\n@@ -1617,12 +1613,8 @@ impl ModCollector<'_, '_> {\n                 }\n                 ModItem::Const(id) => {\n                     let it = &self.item_tree[id];\n-                    let const_id = ConstLoc {\n-                        container,\n-                        id: ItemTreeId::new(self.tree_id, id),\n-                        inherited_visibility: None,\n-                    }\n-                    .intern(db);\n+                    let const_id =\n+                        ConstLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n                     match &it.name {\n                         Some(name) => {\n@@ -1643,13 +1635,9 @@ impl ModCollector<'_, '_> {\n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n-                        StaticLoc {\n-                            container,\n-                            id: ItemTreeId::new(self.tree_id, id),\n-                            inherited_visibility: None,\n-                        }\n-                        .intern(db)\n-                        .into(),\n+                        StaticLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n+                            .into(),\n                         &it.name,\n                         vis,\n                         false,\n@@ -1675,13 +1663,9 @@ impl ModCollector<'_, '_> {\n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n-                        TypeAliasLoc {\n-                            container,\n-                            id: ItemTreeId::new(self.tree_id, id),\n-                            inherited_visibility: None,\n-                        }\n-                        .intern(db)\n-                        .into(),\n+                        TypeAliasLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n+                            .into(),\n                         &it.name,\n                         vis,\n                         false,"}]}