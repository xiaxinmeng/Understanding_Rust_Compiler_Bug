{"sha": "2d5ca0ea4f896201325f9d165498118b320810a7", "node_id": "C_kwDOAAsO6NoAKDJkNWNhMGVhNGY4OTYyMDEzMjVmOWQxNjU0OTgxMThiMzIwODEwYTc", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-04-30T15:31:36Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-04-30T18:17:40Z"}, "message": "Bail out of MIR construction if `check_match` fails", "tree": {"sha": "88125b229adfa66caec15b4a4c003a099a9678a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88125b229adfa66caec15b4a4c003a099a9678a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d5ca0ea4f896201325f9d165498118b320810a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5ca0ea4f896201325f9d165498118b320810a7", "html_url": "https://github.com/rust-lang/rust/commit/2d5ca0ea4f896201325f9d165498118b320810a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d5ca0ea4f896201325f9d165498118b320810a7/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1bb0e09116c725766f5fa6b4a7ddfef28ef7e96", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1bb0e09116c725766f5fa6b4a7ddfef28ef7e96", "html_url": "https://github.com/rust-lang/rust/commit/c1bb0e09116c725766f5fa6b4a7ddfef28ef7e96"}], "stats": {"total": 167, "additions": 154, "deletions": 13}, "files": [{"sha": "ded5c6aa3b3889357e545d4b5929b602349deaca", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ca0ea4f896201325f9d165498118b320810a7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ca0ea4f896201325f9d165498118b320810a7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2d5ca0ea4f896201325f9d165498118b320810a7", "patch": "@@ -1022,7 +1022,7 @@ rustc_queries! {\n         desc { \"converting literal to mir constant\" }\n     }\n \n-    query check_match(key: LocalDefId) {\n+    query check_match(key: LocalDefId) -> Result<(), rustc_errors::ErrorGuaranteed> {\n         desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { true }\n     }"}, {"sha": "20d381eddb1fc0b8fa6f6f4dd0ba7ba864422d48", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ca0ea4f896201325f9d165498118b320810a7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ca0ea4f896201325f9d165498118b320810a7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=2d5ca0ea4f896201325f9d165498118b320810a7", "patch": "@@ -42,7 +42,9 @@ fn mir_build(tcx: TyCtxt<'_>, def: LocalDefId) -> Body<'_> {\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n     tcx.ensure_with_value().thir_check_unsafety(def);\n     tcx.ensure_with_value().thir_abstract_const(def);\n-    tcx.ensure_with_value().check_match(def);\n+    if let Err(e) = tcx.check_match(def) {\n+        return construct_error(tcx, def, e);\n+    }\n \n     let body = match tcx.thir_body(def) {\n         Err(error_reported) => construct_error(tcx, def, error_reported),"}, {"sha": "c3517912cf9cbaf694370349798b0295b1a776cc", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ca0ea4f896201325f9d165498118b320810a7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ca0ea4f896201325f9d165498118b320810a7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=2d5ca0ea4f896201325f9d165498118b320810a7", "patch": "@@ -26,8 +26,8 @@ use rustc_session::Session;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n \n-pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let Ok((thir, expr)) = tcx.thir_body(def_id) else { return };\n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGuaranteed> {\n+    let (thir, expr) = tcx.thir_body(def_id)?;\n     let thir = thir.borrow();\n     let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {\n@@ -37,13 +37,16 @@ pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         lint_level: tcx.hir().local_def_id_to_hir_id(def_id),\n         let_source: LetSource::None,\n         pattern_arena: &pattern_arena,\n+        error: Ok(()),\n     };\n     visitor.visit_expr(&thir[expr]);\n+\n     for param in thir.params.iter() {\n         if let Some(box ref pattern) = param.pat {\n             visitor.check_irrefutable(pattern, \"function argument\", None);\n         }\n     }\n+    visitor.error\n }\n \n fn create_e0004(\n@@ -77,6 +80,7 @@ struct MatchVisitor<'a, 'p, 'tcx> {\n     lint_level: HirId,\n     let_source: LetSource,\n     pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    error: Result<(), ErrorGuaranteed>,\n }\n \n impl<'a, 'tcx> Visitor<'a, 'tcx> for MatchVisitor<'a, '_, 'tcx> {\n@@ -276,9 +280,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                 let [pat_field] = &subpatterns[..] else { bug!() };\n                 self.check_irrefutable(&pat_field.pattern, \"`for` loop binding\", None);\n             } else {\n-                non_exhaustive_match(\n+                self.error = Err(non_exhaustive_match(\n                     &cx, self.thir, scrut_ty, scrut.span, witnesses, arms, expr_span,\n-                );\n+                ));\n             }\n         }\n     }\n@@ -409,7 +413,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n-    fn check_irrefutable(&self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n+    fn check_irrefutable(&mut self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(self.lint_level, false);\n \n         let pattern = self.lower_pattern(&mut cx, pat);\n@@ -478,7 +482,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             AdtDefinedHere { adt_def_span, ty, variants }\n         };\n \n-        self.tcx.sess.emit_err(PatternNotCovered {\n+        self.error = Err(self.tcx.sess.emit_err(PatternNotCovered {\n             span: pat.span,\n             origin,\n             uncovered: Uncovered::new(pat.span, &cx, witnesses),\n@@ -489,7 +493,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             let_suggestion,\n             misc_suggestion,\n             adt_defined_here,\n-        });\n+        }));\n     }\n }\n \n@@ -631,7 +635,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n     arms: &[ArmId],\n     expr_span: Span,\n-) {\n+) -> ErrorGuaranteed {\n     let is_empty_match = arms.is_empty();\n     let non_empty_enum = match scrut_ty.kind() {\n         ty::Adt(def, _) => def.is_enum() && !def.variants().is_empty(),\n@@ -643,13 +647,12 @@ fn non_exhaustive_match<'p, 'tcx>(\n     let pattern;\n     let patterns_len;\n     if is_empty_match && !non_empty_enum {\n-        cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n+        return cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n             cx,\n             expr_span,\n             span: sp,\n             ty: scrut_ty,\n         });\n-        return;\n     } else {\n         // FIXME: migration of this diagnostic will require list support\n         let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n@@ -800,7 +803,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     } else {\n         err.help(&msg);\n     }\n-    err.emit();\n+    err.emit()\n }\n \n pub(crate) fn joined_uncovered_patterns<'p, 'tcx>("}, {"sha": "a7bf9b67d453ef2da607c74630b19f5c6679d765", "filename": "tests/ui/closures/2229_closure_analysis/bad-pattern.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ca0ea4f896201325f9d165498118b320810a7/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ca0ea4f896201325f9d165498118b320810a7/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs?ref=2d5ca0ea4f896201325f9d165498118b320810a7", "patch": "@@ -0,0 +1,23 @@\n+// regression test for #108683\n+// edition:2021\n+\n+enum Refutable {\n+    A,\n+    B,\n+}\n+\n+fn example(v1: u32, v2: [u32; 4], v3: Refutable) {\n+    const PAT: u32 = 0;\n+    let v4 = &v2[..];\n+    || {\n+        let 0 = v1; //~ ERROR refutable pattern in local binding\n+        let (0 | 1) = v1; //~ ERROR refutable pattern in local binding\n+        let 1.. = v1; //~ ERROR refutable pattern in local binding\n+        let [0, 0, 0, 0] = v2; //~ ERROR refutable pattern in local binding\n+        let [0] = v4; //~ ERROR refutable pattern in local binding\n+        let Refutable::A = v3; //~ ERROR refutable pattern in local binding\n+        let PAT = v1; //~ ERROR refutable pattern in local binding\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "ca8c2a16d323f9fcbca2c72d7c4a8377438e9ae1", "filename": "tests/ui/closures/2229_closure_analysis/bad-pattern.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ca0ea4f896201325f9d165498118b320810a7/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ca0ea4f896201325f9d165498118b320810a7/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr?ref=2d5ca0ea4f896201325f9d165498118b320810a7", "patch": "@@ -0,0 +1,113 @@\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:13:13\n+   |\n+LL |         let 0 = v1;\n+   |             ^ pattern `1_u32..=u32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let 0 = v1 { todo!() };\n+   |         ++            +++++++++++\n+help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n+   |\n+LL |         let _0 = v1;\n+   |             +\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:14:14\n+   |\n+LL |         let (0 | 1) = v1;\n+   |              ^^^^^ pattern `2_u32..=u32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let (0 | 1) = v1 { todo!() };\n+   |         ++                  +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:15:13\n+   |\n+LL |         let 1.. = v1;\n+   |             ^^^ pattern `0_u32` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let 1.. = v1 { todo!() };\n+   |         ++              +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:16:13\n+   |\n+LL |         let [0, 0, 0, 0] = v2;\n+   |             ^^^^^^^^^^^^ pattern `[1_u32..=u32::MAX, _, _, _]` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `[u32; 4]`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let [0, 0, 0, 0] = v2 { todo!() };\n+   |         ++                       +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:17:13\n+   |\n+LL |         let [0] = v4;\n+   |             ^^^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `&[u32]`\n+help: you might want to use `if let` to ignore the variants that aren't matched\n+   |\n+LL |         if let [0] = v4 { todo!() };\n+   |         ++              +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:18:13\n+   |\n+LL |         let Refutable::A = v3;\n+   |             ^^^^^^^^^^^^ pattern `Refutable::B` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Refutable` defined here\n+  --> $DIR/bad-pattern.rs:4:6\n+   |\n+LL | enum Refutable {\n+   |      ^^^^^^^^^\n+LL |     A,\n+LL |     B,\n+   |     - not covered\n+   = note: the matched value is of type `Refutable`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let Refutable::A = v3 { todo!() };\n+   |         ++                       +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:19:13\n+   |\n+LL |         let PAT = v1;\n+   |             ^^^\n+   |             |\n+   |             pattern `1_u32..=u32::MAX` not covered\n+   |             missing patterns are not covered because `PAT` is interpreted as a constant pattern, not a new variable\n+   |             help: introduce a variable instead: `PAT_var`\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0005`."}]}