{"sha": "d6b7ca041a68a9056b2295a3901800c727ccee03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YjdjYTA0MWE2OGE5MDU2YjIyOTVhMzkwMTgwMGM3MjdjY2VlMDM=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-06-06T18:10:23Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-06-09T14:02:00Z"}, "message": "Made ref pattern bindings correctly pick Deref or DerefMut\n\nAdded LvaluePreference::from_mutbl\n\nCloses #15609", "tree": {"sha": "681f974ad74391a5cb8d689b6e9335ce2ad48eb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/681f974ad74391a5cb8d689b6e9335ce2ad48eb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6b7ca041a68a9056b2295a3901800c727ccee03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b7ca041a68a9056b2295a3901800c727ccee03", "html_url": "https://github.com/rust-lang/rust/commit/d6b7ca041a68a9056b2295a3901800c727ccee03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6b7ca041a68a9056b2295a3901800c727ccee03/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c21fd9a34f763c532ded7bf141b90a01cef76c43", "url": "https://api.github.com/repos/rust-lang/rust/commits/c21fd9a34f763c532ded7bf141b90a01cef76c43", "html_url": "https://github.com/rust-lang/rust/commit/c21fd9a34f763c532ded7bf141b90a01cef76c43"}], "stats": {"total": 217, "additions": 192, "deletions": 25}, "files": [{"sha": "bb4c702f3733b15f58755662d88e06649b998803", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=d6b7ca041a68a9056b2295a3901800c727ccee03", "patch": "@@ -135,22 +135,34 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n     contains_bindings\n }\n \n-/// Checks if the pattern contains any `ref` or `ref mut` bindings.\n-pub fn pat_contains_ref_binding(dm: &DefMap, pat: &ast::Pat) -> bool {\n-    let mut result = false;\n+/// Checks if the pattern contains any `ref` or `ref mut` bindings,\n+/// and if yes wether its containing mutable ones or just immutables ones.\n+pub fn pat_contains_ref_binding(dm: &DefMap, pat: &ast::Pat) -> Option<ast::Mutability> {\n+    let mut result = None;\n     pat_bindings(dm, pat, |mode, _, _, _| {\n         match mode {\n-            ast::BindingMode::BindByRef(_) => { result = true; }\n+            ast::BindingMode::BindByRef(m) => {\n+                // Pick Mutable as maximum\n+                match result {\n+                    None | Some(ast::MutImmutable) => result = Some(m),\n+                    _ => (),\n+                }\n+            }\n             ast::BindingMode::BindByValue(_) => { }\n         }\n     });\n     result\n }\n \n /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n-/// bindings.\n-pub fn arm_contains_ref_binding(dm: &DefMap, arm: &ast::Arm) -> bool {\n-    arm.pats.iter().any(|pat| pat_contains_ref_binding(dm, pat))\n+/// bindings, and if yes wether its containing mutable ones or just immutables ones.\n+pub fn arm_contains_ref_binding(dm: &DefMap, arm: &ast::Arm) -> Option<ast::Mutability> {\n+    arm.pats.iter()\n+            .filter_map(|pat| pat_contains_ref_binding(dm, pat))\n+            .max_by(|m| match *m {\n+                ast::MutMutable => 1,\n+                ast::MutImmutable => 0,\n+            })\n }\n \n /// Checks if the pattern contains any patterns that bind something to"}, {"sha": "ee2189c769aa0eae80c8e43aeb402d38e15b468e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d6b7ca041a68a9056b2295a3901800c727ccee03", "patch": "@@ -2846,11 +2846,11 @@ impl<'tcx> ctxt<'tcx> {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn pat_contains_ref_binding(&self, pat: &ast::Pat) -> bool {\n+    pub fn pat_contains_ref_binding(&self, pat: &ast::Pat) -> Option<ast::Mutability> {\n         pat_util::pat_contains_ref_binding(&self.def_map, pat)\n     }\n \n-    pub fn arm_contains_ref_binding(&self, arm: &ast::Arm) -> bool {\n+    pub fn arm_contains_ref_binding(&self, arm: &ast::Arm) -> Option<ast::Mutability> {\n         pat_util::arm_contains_ref_binding(&self.def_map, arm)\n     }\n }"}, {"sha": "daf48d8ee6f26f067f6d1a3800abc748902a2594", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d6b7ca041a68a9056b2295a3901800c727ccee03", "patch": "@@ -18,6 +18,7 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n+use check::{check_expr_with_lvalue_pref, LvaluePreference};\n use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n@@ -438,10 +439,15 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Not entirely obvious: if matches may create ref bindings, we\n     // want to use the *precise* type of the discriminant, *not* some\n     // supertype, as the \"discriminant type\" (issue #23116).\n-    let contains_ref_bindings = arms.iter().any(|a| tcx.arm_contains_ref_binding(a));\n+    let contains_ref_bindings = arms.iter()\n+                                    .filter_map(|a| tcx.arm_contains_ref_binding(a))\n+                                    .max_by(|m| match *m {\n+                                        ast::MutMutable => 1,\n+                                        ast::MutImmutable => 0,\n+                                    });\n     let discrim_ty;\n-    if contains_ref_bindings {\n-        check_expr(fcx, discrim);\n+    if let Some(m) = contains_ref_bindings {\n+        check_expr_with_lvalue_pref(fcx, discrim, LvaluePreference::from_mutbl(m));\n         discrim_ty = fcx.expr_ty(discrim);\n     } else {\n         // ...but otherwise we want to use any supertype of the"}, {"sha": "002bfd94a9860bb6906c6073f58cca3a27d37949", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d6b7ca041a68a9056b2295a3901800c727ccee03", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n+use check::{autoderef, FnCtxt, LvaluePreference, UnresolvedTypeAction};\n \n use middle::infer::{self, Coercion};\n use middle::traits::{self, ObligationCause};\n@@ -188,10 +188,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let r_borrow = self.tcx().mk_region(r_borrow);\n         let autoref = Some(ty::AutoPtr(r_borrow, mutbl_b));\n \n-        let lvalue_pref = match mutbl_b {\n-            ast::MutMutable => PreferMutLvalue,\n-            ast::MutImmutable => NoPreference\n-        };\n+        let lvalue_pref = LvaluePreference::from_mutbl(mutbl_b);\n         let mut first_error = None;\n         let (_, autoderefs, success) = autoderef(self.fcx,\n                                                  expr_a.span,"}, {"sha": "33737f40e46f09504ff206f7eae83aa1f2d91c7f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d6b7ca041a68a9056b2295a3901800c727ccee03", "patch": "@@ -1908,6 +1908,15 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n+impl LvaluePreference {\n+    pub fn from_mutbl(m: ast::Mutability) -> Self {\n+        match m {\n+            ast::MutMutable => PreferMutLvalue,\n+            ast::MutImmutable => NoPreference,\n+        }\n+    }\n+}\n+\n /// Whether `autoderef` requires types to resolve.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum UnresolvedTypeAction {\n@@ -3224,10 +3233,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 _ => NoExpectation\n             }\n         });\n-        let lvalue_pref = match mutbl {\n-            ast::MutMutable => PreferMutLvalue,\n-            ast::MutImmutable => NoPreference\n-        };\n+        let lvalue_pref = LvaluePreference::from_mutbl(mutbl);\n         check_expr_with_expectation_and_lvalue_pref(fcx,\n                                                     &**oprnd,\n                                                     hint,\n@@ -3925,9 +3931,7 @@ pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let ref_bindings = fcx.tcx().pat_contains_ref_binding(&local.pat);\n \n     let local_ty = fcx.local_ty(init.span, local.id);\n-    if !ref_bindings {\n-        check_expr_coercable_to_type(fcx, init, local_ty)\n-    } else {\n+    if let Some(m) = ref_bindings {\n         // Somewhat subtle: if we have a `ref` binding in the pattern,\n         // we want to avoid introducing coercions for the RHS. This is\n         // both because it helps preserve sanity and, in the case of\n@@ -3936,9 +3940,11 @@ pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         // referent for the reference that results is *equal to* the\n         // type of the lvalue it is referencing, and not some\n         // supertype thereof.\n-        check_expr(fcx, init);\n+        check_expr_with_lvalue_pref(fcx, init, LvaluePreference::from_mutbl(m));\n         let init_ty = fcx.expr_ty(init);\n         demand::eqtype(fcx, init.span, init_ty, local_ty);\n+    } else {\n+        check_expr_coercable_to_type(fcx, init, local_ty)\n     };\n }\n "}, {"sha": "f72d49642513893d809d24630bcc53c342c9870b", "filename": "src/test/run-pass/overloaded_deref_with_ref_pattern.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Ftest%2Frun-pass%2Foverloaded_deref_with_ref_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Ftest%2Frun-pass%2Foverloaded_deref_with_ref_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded_deref_with_ref_pattern.rs?ref=d6b7ca041a68a9056b2295a3901800c727ccee03", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we choose Deref or DerefMut appropriately based on mutability of ref bindings (#15609).\n+\n+use std::ops::{Deref, DerefMut};\n+\n+struct DerefOk<T>(T);\n+struct DerefMutOk<T>(T);\n+\n+impl<T> Deref for DerefOk<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<T> DerefMut for DerefOk<T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        panic!()\n+    }\n+}\n+\n+impl<T> Deref for DerefMutOk<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+impl<T> DerefMut for DerefMutOk<T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+fn main() {\n+    // Check that mutable ref binding in match picks DerefMut\n+    let mut b = DerefMutOk(0);\n+    match *b {\n+        ref mut n => n,\n+    };\n+\n+    // Check that mutable ref binding in let picks DerefMut\n+    let mut y = DerefMutOk(1);\n+    let ref mut z = *y;\n+\n+    // Check that immutable ref binding in match picks Deref\n+    let mut b = DerefOk(2);\n+    match *b {\n+        ref n => n,\n+    };\n+\n+    // Check that immutable ref binding in let picks Deref\n+    let mut y = DerefOk(3);\n+    let ref z = *y;\n+\n+    // Check that mixed mutable/immutable ref binding in match picks DerefMut\n+    let mut b = DerefMutOk((0, 9));\n+    match *b {\n+        (ref mut n, ref m) => (n, m),\n+    };\n+\n+    let mut b = DerefMutOk((0, 9));\n+    match *b {\n+        (ref n, ref mut m) => (n, m),\n+    };\n+\n+    // Check that mixed mutable/immutable ref binding in let picks DerefMut\n+    let mut y = DerefMutOk((1, 8));\n+    let (ref mut z, ref a) = *y;\n+\n+    let mut y = DerefMutOk((1, 8));\n+    let (ref z, ref mut a) = *y;\n+\n+    // Check that multiple immutable ref bindings in match picks Deref\n+    let mut b = DerefOk((2, 7));\n+    match *b {\n+        (ref n, ref m) => (n, m),\n+    };\n+\n+    // Check that multiple immutable ref bindings in let picks Deref\n+    let mut y = DerefOk((3, 6));\n+    let (ref z, ref a) = *y;\n+\n+    // Check that multiple mutable ref bindings in match picks DerefMut\n+    let mut b = DerefMutOk((4, 5));\n+    match *b {\n+        (ref mut n, ref mut m) => (n, m),\n+    };\n+\n+    // Check that multiple mutable ref bindings in let picks DerefMut\n+    let mut y = DerefMutOk((5, 4));\n+    let (ref mut z, ref mut a) = *y;\n+}"}, {"sha": "e5eb6ab8f610d44a4deb1eca67910324ff08ad79", "filename": "src/test/run-pass/overloaded_deref_with_ref_pattern_issue15609.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Ftest%2Frun-pass%2Foverloaded_deref_with_ref_pattern_issue15609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7ca041a68a9056b2295a3901800c727ccee03/src%2Ftest%2Frun-pass%2Foverloaded_deref_with_ref_pattern_issue15609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded_deref_with_ref_pattern_issue15609.rs?ref=d6b7ca041a68a9056b2295a3901800c727ccee03", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we choose Deref or DerefMut appropriately based on mutability of ref bindings (#15609).\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    struct S {\n+        node: E,\n+    }\n+\n+    enum E {\n+        Foo(u32),\n+        Bar,\n+    }\n+\n+    // Check match\n+    let x = RefCell::new(S { node: E::Foo(0) });\n+\n+    let mut b = x.borrow_mut();\n+    match b.node {\n+        E::Foo(ref mut n) => *n += 1,\n+        _ => (),\n+    }\n+\n+    // Check let\n+    let x = RefCell::new(0);\n+    let mut y = x.borrow_mut();\n+    let ref mut z = *y;\n+\n+    fn foo(a: &mut RefCell<Option<String>>) {\n+        if let Some(ref mut s) = *a.borrow_mut() {\n+            s.push('a')\n+        }\n+    }\n+}"}]}