{"sha": "0d59e86d808b4f01bf4a004941408529b91f7166", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNTllODZkODA4YjRmMDFiZjRhMDA0OTQxNDA4NTI5YjkxZjcxNjY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-12T23:38:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-13T03:15:18Z"}, "message": "core: Remove some uses of 'move'", "tree": {"sha": "4c7727809b434b98391af27b0b849f74db012ae0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c7727809b434b98391af27b0b849f74db012ae0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d59e86d808b4f01bf4a004941408529b91f7166", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d59e86d808b4f01bf4a004941408529b91f7166", "html_url": "https://github.com/rust-lang/rust/commit/0d59e86d808b4f01bf4a004941408529b91f7166", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d59e86d808b4f01bf4a004941408529b91f7166/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "948754b572efd8c1b94875cee4210bd8770c95fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/948754b572efd8c1b94875cee4210bd8770c95fb", "html_url": "https://github.com/rust-lang/rust/commit/948754b572efd8c1b94875cee4210bd8770c95fb"}], "stats": {"total": 224, "additions": 112, "deletions": 112}, "files": [{"sha": "dc5faf49ea4c78d7e32bb2a108c7b4cea60f0e5c", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=0d59e86d808b4f01bf4a004941408529b91f7166", "patch": "@@ -61,7 +61,7 @@ pub pure fn build_sized<A>(size: uint,\n                            builder: &fn(push: pure fn(v: A))) -> @[A] {\n     let mut vec: @[const A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n-    builder(|+x| unsafe { raw::push(&mut vec, move x) });\n+    builder(|+x| unsafe { raw::push(&mut vec, x) });\n     return unsafe { transmute(vec) };\n }\n \n@@ -178,10 +178,10 @@ pub mod raw {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n-            push_fast(v, move initval);\n+            push_fast(v, initval);\n         }\n         else {\n-            push_slow(v, move initval);\n+            push_slow(v, initval);\n         }\n     }\n "}, {"sha": "f16268c34583fb63cd46b6f06d91d4e0c739b5a7", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=0d59e86d808b4f01bf4a004941408529b91f7166", "patch": "@@ -149,7 +149,7 @@ pub pure fn escape_unicode(c: char) -> ~str {\n             { str::push_str(&mut out, ~\"0\"); }\n         str::push_str(&mut out, s);\n     }\n-    move out\n+    out\n }\n \n /**"}, {"sha": "9fd0a50a99c5ef1b23b9f9d3040828c158ee3c99", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=0d59e86d808b4f01bf4a004941408529b91f7166", "patch": "@@ -152,7 +152,7 @@ pub unsafe fn annihilate() {\n         assert (*box).header.prev == null();\n \n         debug!(\"freeing box: %x\", box as uint);\n-        rt_free(transmute(move box));\n+        rt_free(transmute(box));\n     }\n }\n "}, {"sha": "1154a86f96ca8ab46fda42b5149d2bce24945f45", "filename": "src/libcore/str.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=0d59e86d808b4f01bf4a004941408529b91f7166", "patch": "@@ -133,7 +133,7 @@ pub fn push_char(s: &mut ~str, ch: char) {\n pub pure fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n     unsafe { push_char(&mut buf, ch); }\n-    move buf\n+    buf\n }\n \n /// Convert a vector of chars to a string\n@@ -145,7 +145,7 @@ pub pure fn from_chars(chs: &[char]) -> ~str {\n             push_char(&mut buf, *ch);\n         }\n     }\n-    move buf\n+    buf\n }\n \n /// Appends a string slice to the back of a string, without overallocating\n@@ -186,11 +186,11 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n /// Concatenate two strings together\n #[inline(always)]\n pub pure fn append(lhs: ~str, rhs: &str) -> ~str {\n-    let mut v = move lhs;\n+    let mut v = lhs;\n     unsafe {\n         push_str_no_overallocate(&mut v, rhs);\n     }\n-    move v\n+    v\n }\n \n \n@@ -200,7 +200,7 @@ pub pure fn concat(v: &[~str]) -> ~str {\n     for vec::each(v) |ss| {\n         unsafe { push_str(&mut s, *ss) };\n     }\n-    move s\n+    s\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n@@ -210,14 +210,14 @@ pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n         if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n         unsafe { push_str(&mut s, *ss) };\n     }\n-    move s\n+    s\n }\n \n /// Given a string, make a new string with repeated copies of it\n pub fn repeat(ss: &str, nn: uint) -> ~str {\n     let mut acc = ~\"\";\n     for nn.times { acc += ss; }\n-    move acc\n+    acc\n }\n \n /*\n@@ -359,7 +359,7 @@ Section: Transforming strings\n pub pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n     let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n     vec::raw::set_len(&mut v, len(s));\n-    move v\n+    v\n }\n \n /// Work with the string as a byte slice, not including trailing null.\n@@ -379,7 +379,7 @@ pub pure fn chars(s: &str) -> ~[char] {\n         unsafe { buf.push(ch); }\n         i = next;\n     }\n-    move buf\n+    buf\n }\n \n /**\n@@ -455,7 +455,7 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n         if allow_empty || start < l {\n             unsafe { result.push(raw::slice_bytes(s, start, l) ) };\n         }\n-        move result\n+        result\n     } else {\n         splitn(s, |cur| cur == sep, count)\n     }\n@@ -498,7 +498,7 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n     if allow_empty || start < l unsafe {\n         result.push(unsafe { raw::slice_bytes(s, start, l) });\n     }\n-    move result\n+    result\n }\n \n // See Issue #1932 for why this is a naive search\n@@ -552,7 +552,7 @@ pub pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n     do iter_between_matches(s, sep) |from, to| {\n         unsafe { result.push(raw::slice_bytes(s, from, to)); }\n     }\n-    move result\n+    result\n }\n \n pub pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n@@ -562,7 +562,7 @@ pub pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n             unsafe { result.push(raw::slice_bytes(s, from, to)); }\n         }\n     }\n-    move result\n+    result\n }\n \n /**\n@@ -581,7 +581,7 @@ pub pure fn lines_any(s: &str) -> ~[~str] {\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n             unsafe { raw::set_len(&mut cp, l - 1u); }\n         }\n-        move cp\n+        cp\n     })\n }\n \n@@ -609,17 +609,17 @@ pub fn split_within(ss: &str, lim: uint) -> ~[~str] {\n         // then start a new row\n         if row.len() + word.len() + 1 > lim {\n             rows.push(copy row); // save previous row\n-            row = move word;    // start a new one\n+            row = word;    // start a new one\n         } else {\n             if row.len() > 0 { row += ~\" \" } // separate words\n             row += word;  // append to this row\n         }\n     }\n \n     // save the last row\n-    if row != ~\"\" { rows.push(move row); }\n+    if row != ~\"\" { rows.push(row); }\n \n-    move rows\n+    rows\n }\n \n \n@@ -661,7 +661,7 @@ pub pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n         }\n         unsafe { push_str(&mut result, raw::slice_bytes(s, start, end)); }\n     }\n-    move result\n+    result\n }\n \n /*\n@@ -840,7 +840,7 @@ pub pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n             str::push_char(&mut result, ff(cc));\n         }\n     }\n-    move result\n+    result\n }\n \n /// Iterate over the bytes in a string\n@@ -1493,7 +1493,7 @@ pub pure fn to_utf16(s: &str) -> ~[u16] {\n             u.push_all(~[w1, w2])\n         }\n     }\n-    move u\n+    u\n }\n \n pub pure fn utf16_chars(v: &[u16], f: fn(char)) {\n@@ -1527,13 +1527,13 @@ pub pure fn from_utf16(v: &[u16]) -> ~str {\n         reserve(&mut buf, vec::len(v));\n         utf16_chars(v, |ch| push_char(&mut buf, ch));\n     }\n-    move buf\n+    buf\n }\n \n pub pure fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n     unsafe { reserve(&mut buf, capacity); }\n-    move buf\n+    buf\n }\n \n /**\n@@ -1921,7 +1921,7 @@ pub pure fn escape_default(s: &str) -> ~str {\n             push_str(&mut out, char::escape_default(c));\n         }\n     }\n-    move out\n+    out\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n@@ -1933,7 +1933,7 @@ pub pure fn escape_unicode(s: &str) -> ~str {\n             push_str(&mut out, char::escape_unicode(c));\n         }\n     }\n-    move out\n+    out\n }\n \n /// Unsafe operations\n@@ -1959,7 +1959,7 @@ pub mod raw {\n         v.push(0u8);\n \n         assert is_utf8(v);\n-        return ::cast::transmute(move v);\n+        return ::cast::transmute(v);\n     }\n \n     /// Create a Rust string from a null-terminated C string\n@@ -1987,7 +1987,7 @@ pub mod raw {\n                               f: fn(v: &str) -> T) -> T {\n         let v = (buf, len + 1);\n         assert is_utf8(::cast::reinterpret_cast(&v));\n-        f(::cast::transmute(move v))\n+        f(::cast::transmute(v))\n     }\n \n     /**\n@@ -2014,7 +2014,7 @@ pub mod raw {\n                 }\n                 vec::raw::set_len(&mut v, end - begin);\n                 v.push(0u8);\n-                ::cast::transmute(move v)\n+                ::cast::transmute(v)\n             }\n         }\n     }\n@@ -2667,13 +2667,13 @@ mod tests {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n                 while i < 100000 { push_str(&mut rs, ~\"aaaaaaaaaa\"); i += 1; }\n-                move rs\n+                rs\n             }\n             fn half_a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n                 while i < 100000 { push_str(&mut rs, ~\"aaaaa\"); i += 1; }\n-                move rs\n+                rs\n             }\n             assert half_a_million_letter_a() ==\n                 raw::slice_bytes(a_million_letter_a(), 0u, 500000);\n@@ -2780,13 +2780,13 @@ mod tests {\n                 push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n-            move rs\n+            rs\n         }\n         fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 { push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n-            move rs\n+            rs\n         }\n         assert half_a_million_letter_X() ==\n             slice(a_million_letter_X(), 0u, 3u * 500000u);"}, {"sha": "c0910ab86127c3d1e9d8ae84970415e87f99d5ac", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d59e86d808b4f01bf4a004941408529b91f7166/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0d59e86d808b4f01bf4a004941408529b91f7166", "patch": "@@ -120,7 +120,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n             }\n         }\n         raw::set_len(&mut v, n_elts);\n-        return move v;\n+        return v;\n     }\n }\n \n@@ -142,7 +142,7 @@ pub pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n     unsafe { reserve(&mut vec, capacity); }\n-    return move vec;\n+    return vec;\n }\n \n /**\n@@ -161,8 +161,8 @@ pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n pub pure fn build_sized<A>(size: uint,\n                        builder: fn(push: pure fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n-    builder(|x| unsafe { vec.push(move x) });\n-    move vec\n+    builder(|x| unsafe { vec.push(x) });\n+    vec\n }\n \n /**\n@@ -200,12 +200,12 @@ pub pure fn build_sized_opt<A>(size: Option<uint>,\n \n /// Produces a mut vector from an immutable vector.\n pub pure fn to_mut<T>(v: ~[T]) -> ~[mut T] {\n-    unsafe { ::cast::transmute(move v) }\n+    unsafe { ::cast::transmute(v) }\n }\n \n /// Produces an immutable vector from a mut vector.\n pub pure fn from_mut<T>(v: ~[mut T]) -> ~[T] {\n-    unsafe { ::cast::transmute(move v) }\n+    unsafe { ::cast::transmute(v) }\n }\n \n // Accessors\n@@ -255,7 +255,7 @@ pub pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     unsafe {\n         for uint::range(start, end) |i| { result.push(v[i]) }\n     }\n-    move result\n+    result\n }\n \n /// Return a slice that points into another slice.\n@@ -315,7 +315,7 @@ pub fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n         }\n     }\n     result.push(slice(v, start, ln));\n-    move result\n+    result\n }\n \n /**\n@@ -341,7 +341,7 @@ pub fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n         }\n     }\n     result.push(slice(v, start, ln));\n-    move result\n+    result\n }\n \n /**\n@@ -365,7 +365,7 @@ pub fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     }\n     result.push(slice(v, 0u, end));\n     reverse(result);\n-    return move result;\n+    return result;\n }\n \n /**\n@@ -392,7 +392,7 @@ pub fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     }\n     result.push(slice(v, 0u, end));\n     reverse(result);\n-    move result\n+    result\n }\n \n // Mutators\n@@ -413,20 +413,20 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n \n             for uint::range(1, ln) |i| {\n                 let r = move *ptr::offset(vv, i);\n-                v.push(move r);\n+                v.push(r);\n             }\n         }\n         raw::set_len(&mut vv, 0);\n \n-        move rr\n+        rr\n     }\n }\n \n /// Prepend an element to the vector\n pub fn unshift<T>(v: &mut ~[T], x: T) {\n-    let mut vv = ~[move x];\n+    let mut vv = ~[x];\n     *v <-> vv;\n-    v.push_all_move(move vv);\n+    v.push_all_move(vv);\n }\n \n /// Insert an element at position i within v, shifting all\n@@ -435,7 +435,7 @@ pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n     let len = v.len();\n     assert i <= len;\n \n-    v.push(move x);\n+    v.push(x);\n     let mut j = len;\n     while j > i {\n         v[j] <-> v[j - 1];\n@@ -454,24 +454,24 @@ pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n         v[j] <-> v[j + 1];\n         j += 1;\n     }\n-    move v.pop()\n+    v.pop()\n }\n \n pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) unsafe {\n-    let mut v = move v; // FIXME(#3488)\n+    let mut v = v; // FIXME(#3488)\n \n     do as_imm_buf(v) |p, ln| {\n         for uint::range(0, ln) |i| {\n             let x = move *ptr::offset(p, i);\n-            f(i, move x);\n+            f(i, x);\n         }\n     }\n \n     raw::set_len(&mut v, 0);\n }\n \n pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n-    consume(vec::from_mut(move v), f)\n+    consume(vec::from_mut(v), f)\n }\n \n /// Remove the last element from a vector and return it\n@@ -484,7 +484,7 @@ pub fn pop<T>(v: &mut ~[T]) -> T {\n     unsafe {\n         let val = move *valptr;\n         raw::set_len(v, ln - 1u);\n-        move val\n+        val\n     }\n }\n \n@@ -512,10 +512,10 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n         let repr: **raw::VecRepr = ::cast::transmute(copy v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n-            push_fast(v, move initval);\n+            push_fast(v, initval);\n         }\n         else {\n-            push_slow(v, move initval);\n+            push_slow(v, initval);\n         }\n     }\n }\n@@ -534,7 +534,7 @@ unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n #[inline(never)]\n fn push_slow<T>(v: &mut ~[T], initval: T) {\n     reserve_at_least(v, v.len() + 1u);\n-    unsafe { push_fast(v, move initval) }\n+    unsafe { push_fast(v, initval) }\n }\n \n #[inline(always)]\n@@ -548,13 +548,13 @@ pub fn push_all<T: Copy>(v: &mut ~[T], rhs: &[const T]) {\n \n #[inline(always)]\n pub fn push_all_move<T>(v: &mut ~[T], rhs: ~[T]) {\n-    let mut rhs = move rhs; // FIXME(#3488)\n+    let mut rhs = rhs; // FIXME(#3488)\n     reserve(v, v.len() + rhs.len());\n     unsafe {\n         do as_imm_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n                 let x = move *ptr::offset(p, i);\n-                push(v, move x);\n+                push(v, x);\n             }\n         }\n         raw::set_len(&mut rhs, 0);\n@@ -613,23 +613,23 @@ pub fn dedup<T: Eq>(v: &mut ~[T]) unsafe {\n // Appending\n #[inline(always)]\n pub pure fn append<T: Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n-    let mut v = move lhs;\n+    let mut v = lhs;\n     unsafe {\n         v.push_all(rhs);\n     }\n-    move v\n+    v\n }\n \n #[inline(always)]\n pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n-    let mut v = move lhs;\n-    unsafe { v.push(move x); }\n-    move v\n+    let mut v = lhs;\n+    unsafe { v.push(x); }\n+    v\n }\n \n #[inline(always)]\n pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n-    to_mut(append(from_mut(move lhs), rhs))\n+    to_mut(append(from_mut(lhs), rhs))\n }\n \n /**\n@@ -684,7 +684,7 @@ pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n pub fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n     let l = v.len();\n     if index >= l { grow(v, index - l + 1u, initval); }\n-    v[index] = move val;\n+    v[index] = val;\n }\n \n // Functional utilities\n@@ -697,15 +697,15 @@ pub pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n             result.push(f(elem));\n         }\n     }\n-    move result\n+    result\n }\n \n pub fn map_consume<T, U>(v: ~[T], f: fn(v: T) -> U) -> ~[U] {\n     let mut result = ~[];\n-    do consume(move v) |_i, x| {\n-        result.push(f(move x));\n+    do consume(v) |_i, x| {\n+        result.push(f(x));\n     }\n-    move result\n+    result\n }\n \n /// Apply a function to each element of a vector and return the results\n@@ -724,7 +724,7 @@ pub pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n pub pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n-    move result\n+    result\n }\n \n /// Apply a function to each pair of elements and return the results\n@@ -738,7 +738,7 @@ pub pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n         unsafe { u.push(f(&v0[i], &v1[i])) };\n         i += 1u;\n     }\n-    move u\n+    u\n }\n \n /**\n@@ -753,10 +753,10 @@ pub pure fn filter_map<T, U: Copy>(v: &[T], f: fn(t: &T) -> Option<U>)\n     for each(v) |elem| {\n         match f(elem) {\n           None => {/* no-op */ }\n-          Some(move result_elem) => unsafe { result.push(result_elem); }\n+          Some(result_elem) => unsafe { result.push(result_elem); }\n         }\n     }\n-    move result\n+    result\n }\n \n /**\n@@ -771,7 +771,7 @@ pub pure fn filter<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n     for each(v) |elem| {\n         if f(elem) { unsafe { result.push(*elem); } }\n     }\n-    move result\n+    result\n }\n \n /**\n@@ -803,7 +803,7 @@ pub fn retain<T>(v: &mut ~[T], f: pure fn(t: &T) -> bool) {\n pub pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { r.push_all(*inner); } }\n-    move r\n+    r\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n@@ -814,21 +814,21 @@ pub pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n         if first { first = false; } else { unsafe { r.push(*sep); } }\n         unsafe { r.push_all(*inner) };\n     }\n-    move r\n+    r\n }\n \n /// Reduce a vector from left to right\n pub pure fn foldl<T, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n-    let mut accum = move z;\n+    let mut accum = z;\n     let mut i = 0;\n     let l = v.len();\n     while i < l {\n         // Use a while loop so that liveness analysis can handle moving\n         // the accumulator.\n-        accum = p(move accum, &v[i]);\n+        accum = p(accum, &v[i]);\n         i += 1;\n     }\n-    return move accum;\n+    return accum;\n }\n \n /// Reduce a vector from right to left\n@@ -1044,7 +1044,7 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n             us.push(u);\n         }\n     }\n-    return (move ts, move us);\n+    return (ts, us);\n }\n \n /**\n@@ -1058,13 +1058,13 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n pub pure fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     unsafe {\n-        do consume(move v) |_i, p| {\n-            let (t, u) = move p;\n-            ts.push(move t);\n-            us.push(move u);\n+        do consume(v) |_i, p| {\n+            let (t, u) = p;\n+            ts.push(t);\n+            us.push(u);\n         }\n     }\n-    (move ts, move us)\n+    (ts, us)\n }\n \n /**\n@@ -1077,7 +1077,7 @@ pub pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n     let mut i = 0u;\n     assert sz == len(u);\n     while i < sz unsafe { zipped.push((v[i], u[i])); i += 1u; }\n-    move zipped\n+    zipped\n }\n \n /**\n@@ -1087,7 +1087,7 @@ pub pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n  * i-th elements from each of the input vectors.\n  */\n pub pure fn zip<T, U>(v: ~[T], u: ~[U]) -> ~[(T, U)] {\n-    let mut v = move v, u = move u; // FIXME(#3488)\n+    let mut v = v, u = u; // FIXME(#3488)\n     let mut i = len(v);\n     assert i == len(u);\n     let mut w = with_capacity(i);\n@@ -1096,7 +1096,7 @@ pub pure fn zip<T, U>(v: ~[T], u: ~[U]) -> ~[(T, U)] {\n         i -= 1;\n     }\n     unsafe { reverse(w); }\n-    move w\n+    w\n }\n \n /**\n@@ -1123,12 +1123,12 @@ pub fn reverse<T>(v: &[mut T]) {\n pub pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n-    if i == 0 { return (move rs); } else { i -= 1; }\n+    if i == 0 { return (rs); } else { i -= 1; }\n     unsafe {\n         while i != 0 { rs.push(v[i]); i -= 1; }\n         rs.push(v[0]);\n     }\n-    move rs\n+    rs\n }\n \n /**\n@@ -1286,7 +1286,7 @@ pub pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n             ww.push(vec::slice(xx, ii, ii+nn));\n         }\n     }\n-    move ww\n+    ww\n }\n \n /**\n@@ -1548,7 +1548,7 @@ impl<T> &[T]: ImmutableVector<T> {\n             r.push(f(&self[i]));\n             i += 1;\n         }\n-        move r\n+        r\n     }\n \n     /**\n@@ -1674,11 +1674,11 @@ trait MutableEqVector<T: Eq> {\n \n impl<T> ~[T]: MutableVector<T> {\n     fn push(&mut self, t: T) {\n-        push(self, move t);\n+        push(self, t);\n     }\n \n     fn push_all_move(&mut self, rhs: ~[T]) {\n-        push_all_move(self, move rhs);\n+        push_all_move(self, rhs);\n     }\n \n     fn pop(&mut self) -> T {\n@@ -1690,11 +1690,11 @@ impl<T> ~[T]: MutableVector<T> {\n     }\n \n     fn unshift(&mut self, x: T) {\n-        unshift(self, move x)\n+        unshift(self, x)\n     }\n \n     fn insert(&mut self, i: uint, x:T) {\n-        insert(self, i, move x)\n+        insert(self, i, x)\n     }\n \n     fn remove(&mut self, i: uint) -> T {\n@@ -1844,12 +1844,12 @@ mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn init_elem<T>(v: &[mut T], i: uint, val: T) {\n-        let mut box = Some(move val);\n+        let mut box = Some(val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n             box2 <-> box;\n             rusti::move_val_init(&mut(*ptr::mut_offset(p, i)),\n-                                 option::unwrap(move box2));\n+                                 option::unwrap(box2));\n         }\n     }\n \n@@ -1867,7 +1867,7 @@ mod raw {\n         let mut dst = with_capacity(elts);\n         set_len(&mut dst, elts);\n         as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n-        move dst\n+        dst\n     }\n \n     /**\n@@ -1993,7 +1993,7 @@ impl<A> &[A]: iter::ExtendedIter<A> {\n     pub pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n     pub pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n     pub pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n-        iter::foldl(&self, move b0, blk)\n+        iter::foldl(&self, b0, blk)\n     }\n     pub pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n         iter::position(&self, f)\n@@ -2320,7 +2320,7 @@ mod tests {\n     #[test]\n     fn test_dedup() {\n         fn case(a: ~[uint], b: ~[uint]) {\n-            let mut v = move a;\n+            let mut v = a;\n             v.dedup();\n             assert(v == b);\n         }\n@@ -2576,13 +2576,13 @@ mod tests {\n         let v1 = ~[1, 2, 3];\n         let v2 = ~[4, 5, 6];\n \n-        let z1 = zip(move v1, move v2);\n+        let z1 = zip(v1, v2);\n \n         assert ((1, 4) == z1[0]);\n         assert ((2, 5) == z1[1]);\n         assert ((3, 6) == z1[2]);\n \n-        let (left, right) = unzip(move z1);\n+        let (left, right) = unzip(z1);\n \n         assert ((1, 4) == (left[0], right[0]));\n         assert ((2, 5) == (left[1], right[1]));\n@@ -2880,7 +2880,7 @@ mod tests {\n         unsafe {\n             let x = ~[1, 2, 3];\n             let addr = raw::to_ptr(x);\n-            let x_mut = to_mut(move x);\n+            let x_mut = to_mut(x);\n             let addr_mut = raw::to_ptr(x_mut);\n             assert addr == addr_mut;\n         }\n@@ -2891,7 +2891,7 @@ mod tests {\n         unsafe {\n             let x = ~[mut 1, 2, 3];\n             let addr = raw::to_ptr(x);\n-            let x_imm = from_mut(move x);\n+            let x_imm = from_mut(x);\n             let addr_imm = raw::to_ptr(x_imm);\n             assert addr == addr_imm;\n         }\n@@ -3139,7 +3139,7 @@ mod tests {\n     fn test_consume_fail() {\n         let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do consume(move v) |_i, _elt| {\n+        do consume(v) |_i, _elt| {\n             if i == 2 {\n                 fail\n             }\n@@ -3153,7 +3153,7 @@ mod tests {\n     fn test_consume_mut_fail() {\n         let v = ~[mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do consume_mut(move v) |_i, _elt| {\n+        do consume_mut(v) |_i, _elt| {\n             if i == 2 {\n                 fail\n             }\n@@ -3196,7 +3196,7 @@ mod tests {\n     fn test_map_consume_fail() {\n         let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do map_consume(move v) |_elt| {\n+        do map_consume(v) |_elt| {\n             if i == 2 {\n                 fail\n             }"}]}