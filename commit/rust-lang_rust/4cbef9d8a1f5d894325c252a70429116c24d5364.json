{"sha": "4cbef9d8a1f5d894325c252a70429116c24d5364", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYmVmOWQ4YTFmNWQ4OTQzMjVjMjUyYTcwNDI5MTE2YzI0ZDUzNjQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-14T21:04:01Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-14T21:04:01Z"}, "message": "Remove outptr from module-internal calls; use standard ABI returns.", "tree": {"sha": "38c7533119f7a728ffcdc2f3341fb49353307d9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38c7533119f7a728ffcdc2f3341fb49353307d9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cbef9d8a1f5d894325c252a70429116c24d5364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbef9d8a1f5d894325c252a70429116c24d5364", "html_url": "https://github.com/rust-lang/rust/commit/4cbef9d8a1f5d894325c252a70429116c24d5364", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cbef9d8a1f5d894325c252a70429116c24d5364/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "640d1670372942531db4902ac85a87400dc6bcca", "url": "https://api.github.com/repos/rust-lang/rust/commits/640d1670372942531db4902ac85a87400dc6bcca", "html_url": "https://github.com/rust-lang/rust/commit/640d1670372942531db4902ac85a87400dc6bcca"}], "stats": {"total": 79, "additions": 33, "deletions": 46}, "files": [{"sha": "961624f3600609eef279361622bdcc8bd6ae239d", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4cbef9d8a1f5d894325c252a70429116c24d5364/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbef9d8a1f5d894325c252a70429116c24d5364/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=4cbef9d8a1f5d894325c252a70429116c24d5364", "patch": "@@ -26,23 +26,23 @@ fn restore_callee_saves() -> vec[str] {\n }\n \n fn load_esp_from_rust_sp() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi.task_field_rust_sp) + \"(%edx), %esp\");\n+    ret vec(\"movl  \" + wstr(abi.task_field_rust_sp) + \"(%ecx), %esp\");\n }\n \n fn load_esp_from_runtime_sp() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi.task_field_runtime_sp) + \"(%edx), %esp\");\n+    ret vec(\"movl  \" + wstr(abi.task_field_runtime_sp) + \"(%ecx), %esp\");\n }\n \n fn store_esp_to_rust_sp() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi.task_field_rust_sp) + \"(%edx)\");\n+    ret vec(\"movl  %esp, \" + wstr(abi.task_field_rust_sp) + \"(%ecx)\");\n }\n \n fn store_esp_to_runtime_sp() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi.task_field_runtime_sp) + \"(%edx)\");\n+    ret vec(\"movl  %esp, \" + wstr(abi.task_field_runtime_sp) + \"(%ecx)\");\n }\n \n fn rust_activate_glue() -> vec[str] {\n-    ret vec(\"movl  4(%esp), %edx    # edx = rust_task\")\n+    ret vec(\"movl  4(%esp), %ecx    # ecx = rust_task\")\n         + save_callee_saves()\n         + store_esp_to_runtime_sp()\n         + load_esp_from_rust_sp()\n@@ -56,7 +56,7 @@ fn rust_activate_glue() -> vec[str] {\n }\n \n fn rust_yield_glue() -> vec[str] {\n-    ret vec(\"movl  0(%esp), %edx    # edx = rust_task\")\n+    ret vec(\"movl  0(%esp), %ecx    # ecx = rust_task\")\n         + load_esp_from_rust_sp()\n         + save_callee_saves()\n         + store_esp_to_rust_sp()\n@@ -89,20 +89,20 @@ fn upcall_glue(int n_args) -> vec[str] {\n         save_callee_saves()\n \n         + vec(\"movl  %esp, %ebp     # ebp = rust_sp\",\n-              \"movl  20(%esp), %edx # edx = rust_task\")\n+              \"movl  20(%esp), %ecx # ecx = rust_task\")\n \n         + store_esp_to_rust_sp()\n         + load_esp_from_runtime_sp()\n \n         + vec(\"subl  $\" + wstr(n_args + 1) + \", %esp   # esp -= args\",\n               \"andl  $~0xf, %esp    # align esp down\",\n-              \"movl  %edx, (%esp)   # arg[0] = rust_task \")\n+              \"movl  %ecx, (%esp)   # arg[0] = rust_task \")\n \n         + _vec.init_fn[str](carg, n_args as uint)\n \n         +  vec(\"movl  24(%ebp), %edx # edx = callee\",\n                \"call  *%edx          # call *%edx\",\n-               \"movl  20(%ebp), %edx # edx = rust_task\")\n+               \"movl  20(%ebp), %ecx # edx = rust_task\")\n \n         + load_esp_from_rust_sp()\n         + restore_callee_saves()"}, {"sha": "7308168725eebc8fd76d377799cf6f47a737334e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4cbef9d8a1f5d894325c252a70429116c24d5364/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbef9d8a1f5d894325c252a70429116c24d5364/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4cbef9d8a1f5d894325c252a70429116c24d5364", "patch": "@@ -51,7 +51,6 @@ state type trans_ctxt = rec(session.session sess,\n                             str path);\n \n state type fn_ctxt = rec(ValueRef llfn,\n-                         ValueRef lloutptr,\n                          ValueRef lltaskptr,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n@@ -939,28 +938,13 @@ impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n         case (ast.expr_call(?f, ?args, _)) {\n             auto f_res = trans_lval(cx, *f);\n             check (! f_res._1);\n-\n-            // FIXME: Revolting hack to get the type of the outptr. Can get a\n-            // variety of other ways; will wait until we have a typechecker\n-            // perhaps to pick a more tasteful one.\n-            auto outptr = cx.fcx.lloutptr;\n-            alt (cx.fcx.tcx.items.get(f_res._2).node) {\n-                case (ast.item_fn(_, ?ff, _, _)) {\n-                    outptr = cx.build.Alloca(type_of(cx.fcx.tcx, ff.output));\n-                }\n-                case (_) {\n-                    cx.fcx.tcx.sess.unimpl(\"call to non-item\");\n-                }\n-            }\n             auto args_res = trans_exprs(f_res._0.bcx, args);\n-            auto llargs = vec(outptr,\n-                              cx.fcx.lltaskptr);\n+            auto llargs = vec(cx.fcx.lltaskptr);\n             llargs += args_res._1;\n             auto call_val = args_res._0.build.Call(f_res._0.val, llargs);\n             llvm.LLVMSetInstructionCallConv(call_val,\n                                             lib.llvm.LLVMFastCallConv);\n-            ret res(args_res._0,\n-                    args_res._0.build.Load(outptr));\n+            ret res(args_res._0, call_val);\n         }\n \n     }\n@@ -1021,7 +1005,6 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n     alt (e) {\n         case (some[@ast.expr](?x)) {\n             r = trans_expr(cx, *x);\n-            r.bcx.build.Store(r.val, cx.fcx.lloutptr);\n         }\n     }\n \n@@ -1040,7 +1023,16 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n         }\n     }\n \n-    r.val = r.bcx.build.RetVoid();\n+    alt (e) {\n+        case (some[@ast.expr](_)) {\n+            r.val = r.bcx.build.Ret(r.val);\n+            ret r;\n+        }\n+    }\n+\n+    // FIXME: until LLVM has a unit type, we are moving around\n+    // C_nil values rather than their void type.\n+    r.val = r.bcx.build.Ret(C_nil());\n     ret r;\n }\n \n@@ -1188,20 +1180,20 @@ fn new_fn_ctxt(@trans_ctxt cx,\n     let ValueRef llfn = cx.fn_ids.get(fid);\n     cx.fn_names.insert(cx.path, llfn);\n \n-    let ValueRef lloutptr = llvm.LLVMGetParam(llfn, 0u);\n-    let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 1u);\n+    let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n+    let uint arg_n = 1u;\n \n     let hashmap[ast.def_id, ValueRef] lllocals = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] llargs = new_def_hash[ValueRef]();\n \n-    let uint arg_n = 2u;\n     for (ast.arg arg in f.inputs) {\n-        llargs.insert(arg.id, llvm.LLVMGetParam(llfn, arg_n));\n+        auto llarg = llvm.LLVMGetParam(llfn, arg_n);\n+        check (llarg as int != 0);\n+        llargs.insert(arg.id, llarg);\n         arg_n += 1u;\n     }\n \n     ret @rec(llfn=llfn,\n-             lloutptr=lloutptr,\n              lltaskptr=lltaskptr,\n              llargs=llargs,\n              lllocals=lllocals,\n@@ -1219,7 +1211,9 @@ impure fn trans_fn(@trans_ctxt cx, &ast._fn f, ast.def_id fid) {\n     auto bcx = new_top_block_ctxt(fcx);\n     auto res = trans_block(bcx, f.body);\n     if (!is_terminated(res.bcx)) {\n-        res.bcx.build.RetVoid();\n+        // FIXME: until LLVM has a unit type, we are moving around\n+        // C_nil values rather than their void type.\n+        res.bcx.build.Ret(C_nil());\n     }\n }\n \n@@ -1247,18 +1241,13 @@ fn collect_item(&@trans_ctxt cx, @ast.item i) -> @trans_ctxt {\n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, ?fid, _)) {\n             cx.items.insert(fid, i);\n-            let vec[TypeRef] args =\n-                vec(T_ptr(type_of(cx, f.output)), // outptr.\n-                    T_taskptr()   // taskptr\n-                                        );\n-            let vec[TypeRef] T_explicit_args = vec();\n+            let TypeRef out = type_of(cx, f.output);\n+            auto args = vec(T_taskptr());\n             for (ast.arg arg in f.inputs) {\n-                T_explicit_args += type_of(cx, arg.ty);\n+                args += type_of(cx, arg.ty);\n             }\n-            args += T_explicit_args;\n-\n             let str s = cx.names.next(\"_rust_fn\") + \".\" + name;\n-            let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, args, T_void());\n+            let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, args, out);\n             cx.fn_ids.insert(fid, llfn);\n         }\n \n@@ -1290,10 +1279,8 @@ fn trans_exit_task_glue(@trans_ctxt cx) {\n     let vec[ValueRef] V_args = vec();\n \n     auto llfn = cx.glues.exit_task_glue;\n-    let ValueRef lloutptr = C_null(T_int());\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n     auto fcx = @rec(llfn=llfn,\n-                    lloutptr=lloutptr,\n                     lltaskptr=lltaskptr,\n                     llargs=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),"}]}