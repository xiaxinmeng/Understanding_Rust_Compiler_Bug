{"sha": "f777562eabdb676fafe738b4a652d33866292d7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3Nzc1NjJlYWJkYjY3NmZhZmU3MzhiNGE2NTJkMzM4NjYyOTJkN2E=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-06-18T21:57:40Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-06-20T16:58:47Z"}, "message": "Pass fat pointers in two immediate arguments\n\nThis has a number of advantages compared to creating a copy in memory\nand passing a pointer. The obvious one is that we don't have to put the\ndata into memory but can keep it in registers. Since we're currently\npassing a pointer anyway (instead of using e.g. a known offset on the\nstack, which is what the `byval` attribute would achieve), we only use a\nsingle additional register for each fat pointer, but save at least two\npointers worth of stack in exchange (sometimes more because more than\none copy gets eliminated). On archs that pass arguments on the stack, we\nsave a pointer worth of stack even without considering the omitted\ncopies.\n\nAdditionally, LLVM can optimize the code a lot better, to a large degree\ndue to the fact that lots of copies are gone or can be optimized away.\nAdditionally, we can now emit attributes like nonnull on the data and/or\nvtable pointers contained in the fat pointer, potentially allowing for\neven more optimizations.\n\nThis results in LLVM passes being about 3-7% faster (depending on the\ncrate), and the resulting code is also a few percent smaller, for\nexample:\n\n   text    data  filename\n5671479 3941461  before/librustc-d8ace771.so\n5447663 3905745  after/librustc-d8ace771.so\n\n1944425 2394024  before/libstd-d8ace771.so\n1896769 2387610  after/libstd-d8ace771.so\n\nI had to remove a call in the backtrace-debuginfo test, because LLVM can\nnow merge the tails of some blocks when optimizations are turned on,\nwhich can't correctly preserve line info.\n\nFixes #22924\n\nCc #22891 (at least for fat pointers the code is good now)", "tree": {"sha": "91f47406d7a017917c637d5012371ecda955d6e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91f47406d7a017917c637d5012371ecda955d6e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f777562eabdb676fafe738b4a652d33866292d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f777562eabdb676fafe738b4a652d33866292d7a", "html_url": "https://github.com/rust-lang/rust/commit/f777562eabdb676fafe738b4a652d33866292d7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f777562eabdb676fafe738b4a652d33866292d7a/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02d74a4852f9138dbabdfeab8ac31298226620fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/02d74a4852f9138dbabdfeab8ac31298226620fd", "html_url": "https://github.com/rust-lang/rust/commit/02d74a4852f9138dbabdfeab8ac31298226620fd"}], "stats": {"total": 350, "additions": 230, "deletions": 120}, "files": [{"sha": "4df10ee3d098e82efcb7b789c71944e9c811df6a", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -828,19 +828,11 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            None,\n                            &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);\n-        let t = ty::mk_str_slice(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ast::MutImmutable);\n-        // The comparison function gets the slices by value, so we have to make copies here. Even\n-        // if the function doesn't write through the pointer, things like lifetime intrinsics\n-        // require that we do this properly\n-        let lhs_arg = alloc_ty(cx, t, \"lhs\");\n-        let rhs_arg = alloc_ty(cx, t, \"rhs\");\n-        memcpy_ty(cx, lhs_arg, lhs, t);\n-        memcpy_ty(cx, rhs_arg, rhs, t);\n-        let res = callee::trans_lang_call(cx, did, &[lhs_arg, rhs_arg], None, debug_loc);\n-        call_lifetime_end(res.bcx, lhs_arg);\n-        call_lifetime_end(res.bcx, rhs_arg);\n-\n-        res\n+        let lhs_data = Load(cx, expr::get_dataptr(cx, lhs));\n+        let lhs_len = Load(cx, expr::get_len(cx, lhs));\n+        let rhs_data = Load(cx, expr::get_dataptr(cx, rhs));\n+        let rhs_len = Load(cx, expr::get_len(cx, rhs));\n+        callee::trans_lang_call(cx, did, &[lhs_data, lhs_len, rhs_data, rhs_len], None, debug_loc)\n     }\n \n     let _icx = push_ctxt(\"compare_values\");"}, {"sha": "39e5670c975e0e040813b5ad4b8bfa46a1730a9b", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -188,7 +188,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     };\n \n     // Index 0 is the return value of the llvm func, so we start at 1\n-    let mut first_arg_offset = 1;\n+    let mut idx = 1;\n     if let ty::FnConverging(ret_ty) = ret_ty {\n         // A function pointer is called without the declaration\n         // available, so we have to apply any attributes with ABI\n@@ -206,7 +206,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                  .arg(1, llvm::DereferenceableAttribute(llret_sz));\n \n             // Add one more since there's an outptr\n-            first_arg_offset += 1;\n+            idx += 1;\n         } else {\n             // The `noalias` attribute on the return value is useful to a\n             // function ptr caller.\n@@ -236,10 +236,9 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n         }\n     }\n \n-    for (idx, &t) in input_tys.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n+    for &t in input_tys.iter() {\n         match t.sty {\n-            // this needs to be first to prevent fat pointers from falling through\n-            _ if !common::type_is_immediate(ccx, t) => {\n+            _ if type_of::arg_is_indirect(ccx, t) => {\n                 let llarg_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, t));\n \n                 // For non-immediate arguments the callee gets its own copy of\n@@ -256,10 +255,17 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n \n             // `Box` pointer parameters never alias because ownership is transferred\n             ty::TyBox(inner) => {\n-                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-\n-                attrs.arg(idx, llvm::Attribute::NoAlias)\n-                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+                attrs.arg(idx, llvm::Attribute::NoAlias);\n+\n+                if common::type_is_sized(ccx.tcx(), inner) {\n+                    let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+                    attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n+                } else {\n+                    attrs.arg(idx, llvm::NonNullAttribute);\n+                    if ty::type_is_trait(inner) {\n+                        attrs.arg(idx + 1, llvm::NonNullAttribute);\n+                    }\n+                }\n             }\n \n             ty::TyRef(b, mt) => {\n@@ -278,10 +284,17 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                     attrs.arg(idx, llvm::Attribute::ReadOnly);\n                 }\n \n-                // & pointer parameters are also never null and we know exactly\n-                // how many bytes we can dereference\n-                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n+                // & pointer parameters are also never null and for sized types we also know\n+                // exactly how many bytes we can dereference\n+                if common::type_is_sized(ccx.tcx(), mt.ty) {\n+                    let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                    attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n+                } else {\n+                    attrs.arg(idx, llvm::NonNullAttribute);\n+                    if ty::type_is_trait(mt.ty) {\n+                        attrs.arg(idx + 1, llvm::NonNullAttribute);\n+                    }\n+                }\n \n                 // When a reference in an argument has no named lifetime, it's\n                 // impossible for that reference to escape this function\n@@ -293,6 +306,12 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n \n             _ => ()\n         }\n+\n+        if common::type_is_fat_ptr(ccx.tcx(), t) {\n+            idx += 2;\n+        } else {\n+            idx += 1;\n+        }\n     }\n \n     attrs"}, {"sha": "461739a362d30e20f4413f23ff9af377ef79e130", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -1297,16 +1297,28 @@ pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n // create_datums_for_fn_args: creates rvalue datums for each of the\n // incoming function arguments. These will later be stored into\n // appropriate lvalue datums.\n-pub fn create_datums_for_fn_args<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+pub fn create_datums_for_fn_args<'a, 'tcx>(bcx: Block<'a, 'tcx>,\n                                            arg_tys: &[Ty<'tcx>])\n                                            -> Vec<RvalueDatum<'tcx>> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n+    let fcx = bcx.fcx;\n \n     // Return an array wrapping the ValueRefs that we get from `get_param` for\n     // each argument into datums.\n-    arg_tys.iter().enumerate().map(|(i, &arg_ty)| {\n-        let llarg = get_param(fcx.llfn, fcx.arg_pos(i) as c_uint);\n-        datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty))\n+    let mut i = fcx.arg_offset() as c_uint;\n+    arg_tys.iter().map(|&arg_ty| {\n+        if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+            let llty = type_of::type_of(bcx.ccx(), arg_ty);\n+            let data = get_param(fcx.llfn, i);\n+            let extra = get_param(fcx.llfn, i + 1);\n+            let fat_ptr = expr::make_fat_ptr(bcx, llty, data, extra);\n+            i += 2;\n+            datum::Datum::new(fat_ptr, arg_ty, datum::Rvalue { mode: datum::ByValue })\n+        } else {\n+            let llarg = get_param(fcx.llfn, i);\n+            i += 1;\n+            datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty))\n+        }\n     }).collect()\n }\n \n@@ -1321,12 +1333,23 @@ fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n         arg_tys: &[Ty<'tcx>])\n         -> Vec<RvalueDatum<'tcx>> {\n     let mut result = Vec::new();\n+    let mut idx = bcx.fcx.arg_offset() as c_uint;\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n         if i < arg_tys.len() - 1 {\n             // Regular argument.\n-            let llarg = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(i) as c_uint);\n-            result.push(datum::Datum::new(llarg, arg_ty, arg_kind(bcx.fcx,\n-                                                                  arg_ty)));\n+            result.push(if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+                let llty = type_of::type_of(bcx.ccx(), arg_ty);\n+                let data = get_param(bcx.fcx.llfn, idx);\n+                let extra = get_param(bcx.fcx.llfn, idx + 1);\n+                idx += 2;\n+                let fat_ptr = expr::make_fat_ptr(bcx, llty, data, extra);\n+                datum::Datum::new(fat_ptr, arg_ty, datum::Rvalue { mode: datum::ByValue })\n+            } else {\n+                let val = get_param(bcx.fcx.llfn, idx);\n+                idx += 1;\n+                datum::Datum::new(val, arg_ty, arg_kind(bcx.fcx, arg_ty))\n+            });\n+\n             continue\n         }\n \n@@ -1346,15 +1369,21 @@ fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n                                                                llval| {\n                         for (j, &tupled_arg_ty) in\n                                     tupled_arg_tys.iter().enumerate() {\n-                            let llarg =\n-                                get_param(bcx.fcx.llfn,\n-                                          bcx.fcx.arg_pos(i + j) as c_uint);\n                             let lldest = GEPi(bcx, llval, &[0, j]);\n-                            let datum = datum::Datum::new(\n-                                llarg,\n-                                tupled_arg_ty,\n-                                arg_kind(bcx.fcx, tupled_arg_ty));\n-                            bcx = datum.store_to(bcx, lldest);\n+                            if common::type_is_fat_ptr(bcx.tcx(), tupled_arg_ty) {\n+                                let data = get_param(bcx.fcx.llfn, idx);\n+                                let extra = get_param(bcx.fcx.llfn, idx + 1);\n+                                Store(bcx, data, expr::get_dataptr(bcx, lldest));\n+                                Store(bcx, extra, expr::get_len(bcx, lldest));\n+                                idx += 2;\n+                            } else {\n+                                let datum = datum::Datum::new(\n+                                    get_param(bcx.fcx.llfn, idx),\n+                                    tupled_arg_ty,\n+                                    arg_kind(bcx.fcx, tupled_arg_ty));\n+                                idx += 1;\n+                                bcx = datum.store_to(bcx, lldest);\n+                            };\n                         }\n                         bcx\n                     }));\n@@ -1566,7 +1595,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             let arg_tys = untuple_arguments_if_necessary(ccx, &monomorphized_arg_types, abi);\n-            create_datums_for_fn_args(&fcx, &arg_tys)\n+            create_datums_for_fn_args(bcx, &arg_tys)\n         }\n     };\n \n@@ -1773,7 +1802,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         ty::erase_late_bound_regions(\n             ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, &arg_tys[..]);\n+    let arg_datums = create_datums_for_fn_args(bcx, &arg_tys[..]);\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");"}, {"sha": "093b824701fa4c9ec50b45bec5fc65aeecd9305d", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -343,11 +343,12 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     let llargs = get_params(fcx.llfn);\n \n+    let self_idx = fcx.arg_offset();\n     // the first argument (`self`) will be ptr to the the fn pointer\n     let llfnpointer = if is_by_ref {\n-        Load(bcx, llargs[fcx.arg_pos(0)])\n+        Load(bcx, llargs[self_idx])\n     } else {\n-        llargs[fcx.arg_pos(0)]\n+        llargs[self_idx]\n     };\n \n     assert!(!fcx.needs_ret_allocas);\n@@ -360,7 +361,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            DebugLoc::None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(&llargs[fcx.arg_pos(1)..]),\n+                           ArgVals(&llargs[(self_idx + 1)..]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n@@ -1129,6 +1130,10 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_id));\n             val = arg_datum.val;\n         }\n+        DontAutorefArg if common::type_is_fat_ptr(bcx.tcx(), arg_datum_ty) &&\n+                !bcx.fcx.type_needs_drop(arg_datum_ty) => {\n+            val = arg_datum.val\n+        }\n         DontAutorefArg => {\n             // Make this an rvalue, since we are going to be\n             // passing ownership.\n@@ -1147,7 +1152,7 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    if formal_arg_ty != arg_datum_ty {\n+    if type_of::arg_is_indirect(ccx, formal_arg_ty) && formal_arg_ty != arg_datum_ty {\n         // this could happen due to e.g. subtyping\n         let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n         debug!(\"casting actual type ({}) to match formal ({})\",\n@@ -1159,7 +1164,12 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_string(val));\n \n-    llargs.push(val);\n+    if common::type_is_fat_ptr(bcx.tcx(), formal_arg_ty) {\n+        llargs.push(Load(bcx, expr::get_dataptr(bcx, val)));\n+        llargs.push(Load(bcx, expr::get_len(bcx, val)));\n+    } else {\n+        llargs.push(val);\n+    }\n \n     bcx\n }"}, {"sha": "61351847a830cf4f22c5524ced07b29702d1266a", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -411,7 +411,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let self_scope = fcx.push_custom_cleanup_scope();\n     let self_scope_id = CustomScope(self_scope);\n     let rvalue_mode = datum::appropriate_rvalue_mode(ccx, closure_ty);\n-    let llself = llargs[fcx.arg_pos(0)];\n+    let self_idx = fcx.arg_offset();\n+    let llself = llargs[self_idx];\n     let env_datum = Datum::new(llself, closure_ty, Rvalue::new(rvalue_mode));\n     let env_datum = unpack_datum!(bcx,\n                                   env_datum.to_lvalue_datum_in_scope(bcx, \"self\",\n@@ -431,7 +432,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                                    DebugLoc::None,\n                                    llref_fn_ty,\n                                    |bcx, _| Callee { bcx: bcx, data: callee_data },\n-                                   ArgVals(&llargs[fcx.arg_pos(1)..]),\n+                                   ArgVals(&llargs[(self_idx + 1)..]),\n                                    dest).bcx;\n \n     fcx.pop_custom_cleanup_scope(self_scope);"}, {"sha": "403755c536d7539bfcd03df337c4866d83dc46b3", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -421,13 +421,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn arg_pos(&self, arg: usize) -> usize {\n-        let arg = self.env_arg_pos() + arg;\n-        if self.llenv.is_some() {\n-            arg + 1\n-        } else {\n-            arg\n-        }\n+    pub fn arg_offset(&self) -> usize {\n+        self.env_arg_pos() + if self.llenv.is_some() { 1 } else { 0 }\n     }\n \n     pub fn env_arg_pos(&self) -> usize {"}, {"sha": "aff91e295c9bf0aeb468e1aa3a5ba98c9a44e1cc", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -293,6 +293,9 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, &[0, abi::FAT_PTR_ADDR])\n }\n \n+pub fn make_fat_ptr(bcx: Block, ty: Type, data: ValueRef, extra: ValueRef) -> ValueRef {\n+    InsertValue(bcx, InsertValue(bcx, C_undef(ty), data, 0), extra, 1)\n+}\n pub fn copy_fat_ptr(bcx: Block, src_ptr: ValueRef, dst_ptr: ValueRef) {\n     Store(bcx, Load(bcx, get_dataptr(bcx, src_ptr)), get_dataptr(bcx, dst_ptr));\n     Store(bcx, Load(bcx, get_len(bcx, src_ptr)), get_len(bcx, dst_ptr));"}, {"sha": "4f3f13e4bed2424438561bd3c1687a6cfffa39b1", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use back::link;\n+use back::{abi, link};\n use llvm::{ValueRef, CallConv, get_param};\n use llvm;\n use middle::weak_lang_items;\n@@ -22,6 +22,7 @@ use trans::cabi;\n use trans::common::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n+use trans::expr;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -272,10 +273,11 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    for (i, &llarg_rust) in llargs_rust.iter().enumerate() {\n-        let mut llarg_rust = llarg_rust;\n+    let mut offset = 0;\n+    for (i, arg_ty) in arg_tys.iter().enumerate() {\n+        let mut llarg_rust = llargs_rust[i + offset];\n \n-        if arg_tys[i].is_ignore() {\n+        if arg_ty.is_ignore() {\n             continue;\n         }\n \n@@ -286,7 +288,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                i,\n                ccx.tn().val_to_string(llarg_rust),\n                rust_indirect,\n-               ccx.tn().type_to_string(arg_tys[i].ty));\n+               ccx.tn().type_to_string(arg_ty.ty));\n \n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n@@ -295,15 +297,21 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 base::alloca(bcx,\n                              type_of::type_of(ccx, passed_arg_tys[i]),\n                              \"__arg\");\n-            base::store_ty(bcx, llarg_rust, scratch, passed_arg_tys[i]);\n+            if type_is_fat_ptr(ccx.tcx(), passed_arg_tys[i]) {\n+                Store(bcx, llargs_rust[i + offset], expr::get_dataptr(bcx, scratch));\n+                Store(bcx, llargs_rust[i + offset + 1], expr::get_len(bcx, scratch));\n+                offset += 1;\n+            } else {\n+                base::store_ty(bcx, llarg_rust, scratch, passed_arg_tys[i]);\n+            }\n             llarg_rust = scratch;\n         }\n \n         debug!(\"llarg_rust={} (after indirection)\",\n                ccx.tn().val_to_string(llarg_rust));\n \n         // Check whether we need to do any casting\n-        match arg_tys[i].cast {\n+        match arg_ty.cast {\n             Some(ty) => llarg_rust = BitCast(bcx, llarg_rust, ty.ptr_to()),\n             None => ()\n         }\n@@ -312,7 +320,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                ccx.tn().val_to_string(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n-        let foreign_indirect = arg_tys[i].is_indirect();\n+        let foreign_indirect = arg_ty.is_indirect();\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n         } else {\n@@ -328,7 +336,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                i, ccx.tn().val_to_string(llarg_foreign));\n \n         // fill padding with undef value\n-        match arg_tys[i].pad {\n+        match arg_ty.pad {\n             Some(ty) => llargs_foreign.push(C_undef(ty)),\n             None => ()\n         }\n@@ -783,12 +791,12 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // If the types in the ABI and the Rust types don't match,\n             // bitcast the llforeign_arg pointer so it matches the types\n             // Rust expects.\n-            if llforeign_arg_ty.cast.is_some() {\n+            if llforeign_arg_ty.cast.is_some() && !type_is_fat_ptr(ccx.tcx(), rust_ty){\n                 assert!(!foreign_indirect);\n                 llforeign_arg = builder.bitcast(llforeign_arg, llrust_ty.ptr_to());\n             }\n \n-            let llrust_arg = if rust_indirect {\n+            let llrust_arg = if rust_indirect || type_is_fat_ptr(ccx.tcx(), rust_ty) {\n                 llforeign_arg\n             } else {\n                 if ty::type_is_bool(rust_ty) {\n@@ -810,7 +818,15 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             debug!(\"llrust_arg {}{}: {}\", \"#\",\n                    i, ccx.tn().val_to_string(llrust_arg));\n-            llrust_args.push(llrust_arg);\n+            if type_is_fat_ptr(ccx.tcx(), rust_ty) {\n+                let next_llrust_ty = rust_param_tys.next().expect(\"Not enough parameter types!\");\n+                llrust_args.push(builder.load(builder.bitcast(builder.gepi(\n+                                llrust_arg, &[0, abi::FAT_PTR_ADDR]), llrust_ty.ptr_to())));\n+                llrust_args.push(builder.load(builder.bitcast(builder.gepi(\n+                                llrust_arg, &[0, abi::FAT_PTR_EXTRA]), next_llrust_ty.ptr_to())));\n+            } else {\n+                llrust_args.push(llrust_arg);\n+            }\n         }\n \n         // Perform the call itself"}, {"sha": "b84475d915a4f40ee114f82babf88a058f2adab7", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -259,7 +259,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n+    let llrawptr0 = get_param(llfn, fcx.arg_offset() as c_uint);\n     let bcx = make_drop_glue(bcx, llrawptr0, g);\n     finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n "}, {"sha": "dd97265e428edecc43c3e162c1641dcd1a546cc7", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -275,17 +275,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             } else {\n                 (&exprs[0], &exprs[1])\n             };\n-            let arg_tys = ty::erase_late_bound_regions(bcx.tcx(), &ty::ty_fn_args(callee_ty));\n \n             // evaluate destination address\n-            let lldest_addr = unpack_result!(bcx, {\n-                let dest_datum = unpack_datum!(bcx, expr::trans(bcx, dest_expr));\n-                callee::trans_arg_datum(bcx,\n-                                        arg_tys[0],\n-                                        dest_datum,\n-                                        cleanup::CustomScope(cleanup_scope),\n-                                        callee::DontAutorefArg)\n-            });\n+            let dest_datum = unpack_datum!(bcx, expr::trans(bcx, dest_expr));\n+            let dest_datum = unpack_datum!(\n+                bcx, dest_datum.to_rvalue_datum(bcx, \"arg\"));\n+            let dest_datum = unpack_datum!(\n+                bcx, dest_datum.to_appropriate_datum(bcx));\n \n             // `expr::trans_into(bcx, expr, dest)` is equiv to\n             //\n@@ -294,7 +290,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             // which for `dest == expr::SaveIn(addr)`, is equivalent to:\n             //\n             //    `trans(bcx, expr).store_to(bcx, addr)`.\n-            let lldest = expr::Dest::SaveIn(lldest_addr);\n+            let lldest = expr::Dest::SaveIn(dest_datum.val);\n             bcx = expr::trans_into(bcx, source_expr, lldest);\n \n             let llresult = C_nil(ccx);\n@@ -370,8 +366,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"size_of_val\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !type_is_sized(tcx, tp_ty) {\n-                let info = Load(bcx, expr::get_len(bcx, llargs[0]));\n-                let (llsize, _) = glue::size_and_align_of_dst(bcx, tp_ty, info);\n+                let (llsize, _) = glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llsize\n             } else {\n                 let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -385,8 +380,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"min_align_of_val\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !type_is_sized(tcx, tp_ty) {\n-                let info = Load(bcx, expr::get_len(bcx, llargs[0]));\n-                let (_, llalign) = glue::size_and_align_of_dst(bcx, tp_ty, info);\n+                let (_, llalign) = glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n             } else {\n                 C_uint(ccx, type_of::align_of(ccx, tp_ty))\n@@ -399,7 +393,16 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"drop_in_place\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            glue::drop_ty(bcx, llargs[0], tp_ty, call_debug_location);\n+            let ptr = if type_is_sized(tcx, tp_ty) {\n+                llargs[0]\n+            } else {\n+                let scratch = rvalue_scratch_datum(bcx, tp_ty, \"tmp\");\n+                Store(bcx, llargs[0], expr::get_dataptr(bcx, scratch.val));\n+                Store(bcx, llargs[1], expr::get_len(bcx, scratch.val));\n+                fcx.schedule_lifetime_end(cleanup::CustomScope(cleanup_scope), scratch.val);\n+                scratch.val\n+            };\n+            glue::drop_ty(bcx, ptr, tp_ty, call_debug_location);\n             C_nil(ccx)\n         }\n         (_, \"type_name\") => {\n@@ -980,7 +983,7 @@ fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n     let ret = InsertValue(bcx, ret, result, 0);\n     let ret = InsertValue(bcx, ret, overflow, 1);\n-    if type_is_immediate(bcx.ccx(), t) {\n+    if !arg_is_indirect(bcx.ccx(), t) {\n         let tmp = alloc_ty(bcx, t, \"tmp\");\n         Store(bcx, ret, tmp);\n         load_ty(bcx, tmp, t)"}, {"sha": "e61770768db22e5d6bcc786e55c0f098df10a0db", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -468,27 +468,28 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         self_datum.val\n     };\n \n-    trans_trait_callee_from_llval(bcx, method_ty, vtable_index, llval)\n+    let llself = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_ADDR]));\n+    let llvtable = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_EXTRA]));\n+    trans_trait_callee_from_llval(bcx, method_ty, vtable_index, llself, llvtable)\n }\n \n /// Same as `trans_trait_callee()` above, except that it is given a by-ref pointer to the object\n /// pair.\n pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  callee_ty: Ty<'tcx>,\n                                                  vtable_index: usize,\n-                                                 llpair: ValueRef)\n+                                                 llself: ValueRef,\n+                                                 llvtable: ValueRef)\n                                                  -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llpair={})\",\n+    debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llself={}, llvtable={})\",\n            callee_ty,\n            vtable_index,\n-           bcx.val_to_string(llpair));\n-    let llboxptr = GEPi(bcx, llpair, &[0, abi::FAT_PTR_ADDR]);\n-    let llbox = Load(bcx, llboxptr);\n-    let llself = PointerCast(bcx, llbox, Type::i8p(ccx));\n+           bcx.val_to_string(llself),\n+           bcx.val_to_string(llvtable));\n \n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n@@ -505,19 +506,13 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n         }\n     };\n-    let llvtable = Load(bcx,\n-                        PointerCast(bcx,\n-                                    GEPi(bcx, llpair,\n-                                         &[0, abi::FAT_PTR_EXTRA]),\n-                                    Type::vtable(ccx).ptr_to().ptr_to()));\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0, vtable_index + VTABLE_OFFSET]));\n-    let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]));\n \n     return Callee {\n         bcx: bcx,\n         data: TraitItem(MethodData {\n-            llfn: mptr,\n-            llself: llself,\n+            llfn: PointerCast(bcx, mptr, llcallee_ty.ptr_to()),\n+            llself: PointerCast(bcx, llself, Type::i8p(ccx)),\n         })\n     };\n }\n@@ -613,11 +608,12 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     let llargs = get_params(fcx.llfn);\n \n-    // the first argument (`self`) will be a trait object\n-    let llobject = llargs[fcx.arg_pos(0)];\n+    let self_idx = fcx.arg_offset();\n+    let llself = llargs[self_idx];\n+    let llvtable = llargs[self_idx + 1];\n \n-    debug!(\"trans_object_shim: llobject={}\",\n-           bcx.val_to_string(llobject));\n+    debug!(\"trans_object_shim: llself={}, llvtable={}\",\n+           bcx.val_to_string(llself), bcx.val_to_string(llvtable));\n \n     assert!(!fcx.needs_ret_allocas);\n \n@@ -639,8 +635,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n                            |bcx, _| trans_trait_callee_from_llval(bcx,\n                                                                   method_bare_fn_ty,\n                                                                   method_offset_in_vtable,\n-                                                                  llobject),\n-                           ArgVals(&llargs[fcx.arg_pos(1)..]),\n+                                                                  llself, llvtable),\n+                           ArgVals(&llargs[(self_idx + 2)..]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);"}, {"sha": "b80b2b8266a2cfe43c71165f8e2bf43d7423d0ee", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -171,10 +171,6 @@ impl Type {\n         Type::struct_(ccx, &[], false)\n     }\n \n-    pub fn vtable(ccx: &CrateContext) -> Type {\n-        Type::array(&Type::i8p(ccx).ptr_to(), 1)\n-    }\n-\n     pub fn glue_fn(ccx: &CrateContext, t: Type) -> Type {\n         Type::func(&[t], &Type::void(ccx))\n     }"}, {"sha": "49601ac6fe94dd85e5f713beecc42aa9f07303d4", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -36,12 +36,12 @@ fn ensure_array_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn arg_is_indirect<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  arg_ty: Ty<'tcx>) -> bool {\n-    !type_is_immediate(ccx, arg_ty)\n+    !type_is_immediate(ccx, arg_ty) && !type_is_fat_ptr(ccx.tcx(), arg_ty)\n }\n \n pub fn return_uses_outptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     ty: Ty<'tcx>) -> bool {\n-    !type_is_immediate(ccx, ty)\n+    arg_is_indirect(ccx, ty)\n }\n \n pub fn type_of_explicit_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -136,8 +136,15 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     // ... then explicit args.\n-    let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n-    atys.extend(input_tys);\n+    for input in &inputs {\n+        let arg_ty = type_of_explicit_arg(cx, input);\n+\n+        if type_is_fat_ptr(cx.tcx(), input) {\n+            atys.extend(arg_ty.field_types());\n+        } else {\n+            atys.push(arg_ty);\n+        }\n+    }\n \n     Type::func(&atys[..], &lloutputtype)\n }"}, {"sha": "7706c97380b166192b8543ab6075c261342ab1b8", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -87,6 +87,53 @@ pub fn struct_return() -> S {\n   }\n }\n \n+// Hack to get the correct size for the length part in slices\n+// CHECK: @helper([[USIZE:i[0-9]+]])\n+#[no_mangle]\n+fn helper(_: usize) {\n+}\n+\n+// CHECK: @slice(i8* noalias nonnull readonly, [[USIZE]])\n+// FIXME #25759 This should also have `nocapture`\n+#[no_mangle]\n+fn slice(_: &[u8]) {\n+}\n+\n+// CHECK: @mutable_slice(i8* noalias nonnull, [[USIZE]])\n+// FIXME #25759 This should also have `nocapture`\n+#[no_mangle]\n+fn mutable_slice(_: &mut [u8]) {\n+}\n+\n+// CHECK: @unsafe_slice(%UnsafeInner* nonnull, [[USIZE]])\n+// unsafe interior means this isn't actually readonly and there may be aliases ...\n+#[no_mangle]\n+pub fn unsafe_slice(_: &[UnsafeInner]) {\n+}\n+\n+// CHECK: @str(i8* noalias nonnull readonly, [[USIZE]])\n+// FIXME #25759 This should also have `nocapture`\n+#[no_mangle]\n+fn str(_: &[u8]) {\n+}\n+\n+// CHECK: @trait_borrow(i8* nonnull, void (i8*)** nonnull)\n+// FIXME #25759 This should also have `nocapture`\n+#[no_mangle]\n+fn trait_borrow(_: &Drop) {\n+}\n+\n+// CHECK: @trait_box(i8* noalias nonnull, void (i8*)** nonnull)\n+#[no_mangle]\n+fn trait_box(_: Box<Drop>) {\n+}\n+\n+// CHECK: { i16*, [[USIZE]] } @return_slice(i16* noalias nonnull readonly, [[USIZE]])\n+#[no_mangle]\n+fn return_slice(x: &[u16]) -> &[u16] {\n+  x\n+}\n+\n // CHECK: noalias i8* @allocator()\n #[no_mangle]\n #[allocator]"}, {"sha": "8f41c68b0473fb4759d818e8a1460702f80a088b", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f777562eabdb676fafe738b4a652d33866292d7a/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f777562eabdb676fafe738b4a652d33866292d7a/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=f777562eabdb676fafe738b4a652d33866292d7a", "patch": "@@ -97,10 +97,6 @@ fn inner_inlined(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n     let inner_pos = pos!(); aux::callback_inlined(|aux_pos| {\n         check!(counter; main_pos, outer_pos, inner_pos, aux_pos);\n     });\n-\n-    // this tests a distinction between two independent calls to the inlined function.\n-    // (un)fortunately, LLVM somehow merges two consecutive such calls into one node.\n-    inner_further_inlined(counter, main_pos, outer_pos, pos!());\n }\n \n #[inline(never)]"}]}