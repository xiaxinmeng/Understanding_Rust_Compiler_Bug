{"sha": "1e6151a77067d3fcb9a101cb5ee66e7252571845", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNjE1MWE3NzA2N2QzZmNiOWExMDFjYjVlZTY2ZTcyNTI1NzE4NDU=", "commit": {"author": {"name": "Bruno de Oliveira Abinader", "email": "bruno.d@partner.samsung.com", "date": "2014-02-14T18:59:13Z"}, "committer": {"name": "Bruno de Oliveira Abinader", "email": "bruno.d@partner.samsung.com", "date": "2014-02-27T12:35:16Z"}, "message": "Renamed variables", "tree": {"sha": "c4ee78a0deaf34751defd37dd9b5d77bd1a071f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4ee78a0deaf34751defd37dd9b5d77bd1a071f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e6151a77067d3fcb9a101cb5ee66e7252571845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6151a77067d3fcb9a101cb5ee66e7252571845", "html_url": "https://github.com/rust-lang/rust/commit/1e6151a77067d3fcb9a101cb5ee66e7252571845", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e6151a77067d3fcb9a101cb5ee66e7252571845/comments", "author": {"login": "brunoabinader", "id": 76133, "node_id": "MDQ6VXNlcjc2MTMz", "avatar_url": "https://avatars.githubusercontent.com/u/76133?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunoabinader", "html_url": "https://github.com/brunoabinader", "followers_url": "https://api.github.com/users/brunoabinader/followers", "following_url": "https://api.github.com/users/brunoabinader/following{/other_user}", "gists_url": "https://api.github.com/users/brunoabinader/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunoabinader/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunoabinader/subscriptions", "organizations_url": "https://api.github.com/users/brunoabinader/orgs", "repos_url": "https://api.github.com/users/brunoabinader/repos", "events_url": "https://api.github.com/users/brunoabinader/events{/privacy}", "received_events_url": "https://api.github.com/users/brunoabinader/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brunoabinader", "id": 76133, "node_id": "MDQ6VXNlcjc2MTMz", "avatar_url": "https://avatars.githubusercontent.com/u/76133?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunoabinader", "html_url": "https://github.com/brunoabinader", "followers_url": "https://api.github.com/users/brunoabinader/followers", "following_url": "https://api.github.com/users/brunoabinader/following{/other_user}", "gists_url": "https://api.github.com/users/brunoabinader/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunoabinader/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunoabinader/subscriptions", "organizations_url": "https://api.github.com/users/brunoabinader/orgs", "repos_url": "https://api.github.com/users/brunoabinader/repos", "events_url": "https://api.github.com/users/brunoabinader/events{/privacy}", "received_events_url": "https://api.github.com/users/brunoabinader/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c553af0f80c5693d832f43ce7021abba15c4535", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c553af0f80c5693d832f43ce7021abba15c4535", "html_url": "https://github.com/rust-lang/rust/commit/4c553af0f80c5693d832f43ce7021abba15c4535"}], "stats": {"total": 132, "additions": 65, "deletions": 67}, "files": [{"sha": "8174d12cce70b5271333af3f00781375ca207554", "filename": "src/libcollections/list.rs", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/1e6151a77067d3fcb9a101cb5ee66e7252571845/src%2Flibcollections%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6151a77067d3fcb9a101cb5ee66e7252571845/src%2Flibcollections%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flist.rs?ref=1e6151a77067d3fcb9a101cb5ee66e7252571845", "patch": "@@ -10,8 +10,6 @@\n \n //! A standard, garbage-collected linked list.\n \n-\n-\n #[deriving(Clone, Eq)]\n #[allow(missing_doc)]\n pub enum List<T> {\n@@ -33,30 +31,30 @@ pub fn from_vec<T:Clone + 'static>(v: &[T]) -> @List<T> {\n  *\n  * # Arguments\n  *\n- * * ls - The list to fold\n+ * * list - The list to fold\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: |&T, &U| -> T) -> T {\n+pub fn foldl<T:Clone,U>(z: T, list: @List<U>, f: |&T, &U| -> T) -> T {\n     let mut accum: T = z;\n-    iter(ls, |elt| accum = f(&accum, elt));\n+    iter(list, |element| accum = f(&accum, element));\n     accum\n }\n \n /**\n  * Search for an element that matches a given predicate\n  *\n- * Apply function `f` to each element of `ls`, starting from the first.\n+ * Apply function `f` to each element of `list`, starting from the first.\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub fn find<T:Clone>(ls: @List<T>, f: |&T| -> bool) -> Option<T> {\n-    let mut ls = ls;\n+pub fn find<T:Clone>(list: @List<T>, f: |&T| -> bool) -> Option<T> {\n+    let mut list = list;\n     loop {\n-        ls = match *ls {\n-          Cons(ref hd, tl) => {\n-            if f(hd) { return Some((*hd).clone()); }\n-            tl\n+        list = match *list {\n+          Cons(ref head, tail) => {\n+            if f(head) { return Some((*head).clone()); }\n+            tail\n           }\n           Nil => return None\n         }\n@@ -66,71 +64,71 @@ pub fn find<T:Clone>(ls: @List<T>, f: |&T| -> bool) -> Option<T> {\n /**\n  * Returns true if a list contains an element that matches a given predicate\n  *\n- * Apply function `f` to each element of `ls`, starting from the first.\n+ * Apply function `f` to each element of `list`, starting from the first.\n  * When function `f` returns true then it also returns true. If `f` matches no\n  * elements then false is returned.\n  */\n-pub fn any<T>(ls: @List<T>, f: |&T| -> bool) -> bool {\n-    let mut ls = ls;\n+pub fn any<T>(list: @List<T>, f: |&T| -> bool) -> bool {\n+    let mut list = list;\n     loop {\n-        ls = match *ls {\n-            Cons(ref hd, tl) => {\n-                if f(hd) { return true; }\n-                tl\n+        list = match *list {\n+            Cons(ref head, tail) => {\n+                if f(head) { return true; }\n+                tail\n             }\n             Nil => return false\n         }\n     };\n }\n \n /// Returns true if a list contains an element with the given value\n-pub fn has<T:Eq>(ls: @List<T>, elt: T) -> bool {\n+pub fn has<T:Eq>(list: @List<T>, element: T) -> bool {\n     let mut found = false;\n-    each(ls, |e| {\n-        if *e == elt { found = true; false } else { true }\n+    each(list, |e| {\n+        if *e == element { found = true; false } else { true }\n     });\n     return found;\n }\n \n /// Returns true if the list is empty\n-pub fn is_empty<T>(ls: @List<T>) -> bool {\n-    match *ls {\n+pub fn is_empty<T>(list: @List<T>) -> bool {\n+    match *list {\n         Nil => true,\n         _ => false\n     }\n }\n \n /// Returns the length of a list\n-pub fn len<T>(ls: @List<T>) -> uint {\n+pub fn len<T>(list: @List<T>) -> uint {\n     let mut count = 0u;\n-    iter(ls, |_e| count += 1u);\n+    iter(list, |_e| count += 1u);\n     count\n }\n \n /// Returns all but the first element of a list\n-pub fn tail<T>(ls: @List<T>) -> @List<T> {\n-    match *ls {\n-        Cons(_, tl) => return tl,\n+pub fn tail<T>(list: @List<T>) -> @List<T> {\n+    match *list {\n+        Cons(_, tail) => return tail,\n         Nil => fail!(\"list empty\")\n     }\n }\n \n /// Returns the first element of a list\n-pub fn head<T:Clone>(ls: @List<T>) -> T {\n-    match *ls {\n-      Cons(ref hd, _) => (*hd).clone(),\n+pub fn head<T:Clone>(list: @List<T>) -> T {\n+    match *list {\n+      Cons(ref head, _) => (*head).clone(),\n       // makes me sad\n       _ => fail!(\"head invoked on empty list\")\n     }\n }\n \n /// Appends one list to another\n-pub fn append<T:Clone + 'static>(l: @List<T>, m: @List<T>) -> @List<T> {\n-    match *l {\n-      Nil => return m,\n-      Cons(ref x, xs) => {\n-        let rest = append(xs, m);\n-        return @Cons((*x).clone(), rest);\n+pub fn append<T:Clone + 'static>(list: @List<T>, other: @List<T>) -> @List<T> {\n+    match *list {\n+      Nil => return other,\n+      Cons(ref head, tail) => {\n+        let rest = append(tail, other);\n+        return @Cons((*head).clone(), rest);\n       }\n     }\n }\n@@ -144,27 +142,27 @@ fn push<T:Clone>(ll: &mut @list<T>, vv: T) {\n */\n \n /// Iterate over a list\n-pub fn iter<T>(l: @List<T>, f: |&T|) {\n-    let mut cur = l;\n+pub fn iter<T>(list: @List<T>, f: |&T|) {\n+    let mut cur = list;\n     loop {\n         cur = match *cur {\n-          Cons(ref hd, tl) => {\n-            f(hd);\n-            tl\n+          Cons(ref head, tail) => {\n+            f(head);\n+            tail\n           }\n           Nil => break\n         }\n     }\n }\n \n /// Iterate over a list\n-pub fn each<T>(l: @List<T>, f: |&T| -> bool) -> bool {\n-    let mut cur = l;\n+pub fn each<T>(list: @List<T>, f: |&T| -> bool) -> bool {\n+    let mut cur = list;\n     loop {\n         cur = match *cur {\n-          Cons(ref hd, tl) => {\n-            if !f(hd) { return false; }\n-            tl\n+          Cons(ref head, tail) => {\n+            if !f(head) { return false; }\n+            tail\n           }\n           Nil => { return true; }\n         }\n@@ -191,11 +189,11 @@ mod tests {\n \n     #[test]\n     fn test_from_vec() {\n-        let l = from_vec([0, 1, 2]);\n+        let list = from_vec([0, 1, 2]);\n \n-        assert_eq!(head(l), 0);\n+        assert_eq!(head(list), 0);\n \n-        let tail_l = tail(l);\n+        let tail_l = tail(list);\n         assert_eq!(head(tail_l), 1);\n \n         let tail_tail_l = tail(tail_l);\n@@ -211,9 +209,9 @@ mod tests {\n     #[test]\n     fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n-        let l = from_vec([0, 1, 2, 3, 4]);\n+        let list = from_vec([0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n-        assert_eq!(list::foldl(0u, l, add), 10u);\n+        assert_eq!(list::foldl(0u, list, add), 10u);\n         assert_eq!(list::foldl(0u, empty, add), 0u);\n     }\n \n@@ -222,50 +220,50 @@ mod tests {\n         fn sub(a: &int, b: &int) -> int {\n             *a - *b\n         }\n-        let l = from_vec([1, 2, 3, 4]);\n-        assert_eq!(list::foldl(0, l, sub), -10);\n+        let list = from_vec([1, 2, 3, 4]);\n+        assert_eq!(list::foldl(0, list, sub), -10);\n     }\n \n     #[test]\n     fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n-        let l = from_vec([0, 1, 2]);\n-        assert_eq!(list::find(l, match_), option::Some(2));\n+        let list = from_vec([0, 1, 2]);\n+        assert_eq!(list::find(list, match_), option::Some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n-        let l = from_vec([0, 1, 2]);\n+        let list = from_vec([0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert_eq!(list::find(l, match_), option::None::<int>);\n+        assert_eq!(list::find(list, match_), option::None::<int>);\n         assert_eq!(list::find(empty, match_), option::None::<int>);\n     }\n \n     #[test]\n     fn test_any() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n-        let l = from_vec([0, 1, 2]);\n+        let list = from_vec([0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert_eq!(list::any(l, match_), true);\n+        assert_eq!(list::any(list, match_), true);\n         assert_eq!(list::any(empty, match_), false);\n     }\n \n     #[test]\n     fn test_has() {\n-        let l = from_vec([5, 8, 6]);\n+        let list = from_vec([5, 8, 6]);\n         let empty = @list::Nil::<int>;\n-        assert!((list::has(l, 5)));\n-        assert!((!list::has(l, 7)));\n-        assert!((list::has(l, 8)));\n+        assert!((list::has(list, 5)));\n+        assert!((!list::has(list, 7)));\n+        assert!((list::has(list, 8)));\n         assert!((!list::has(empty, 5)));\n     }\n \n     #[test]\n     fn test_len() {\n-        let l = from_vec([0, 1, 2]);\n+        let list = from_vec([0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert_eq!(list::len(l), 3u);\n+        assert_eq!(list::len(list), 3u);\n         assert_eq!(list::len(empty), 0u);\n     }\n "}]}