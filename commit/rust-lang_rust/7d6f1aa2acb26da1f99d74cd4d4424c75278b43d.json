{"sha": "7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNmYxYWEyYWNiMjZkYTFmOTlkNzRjZDRkNDQyNGM3NTI3OGI0M2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-05-12T21:12:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-05-12T21:46:26Z"}, "message": "Factor out foldable better to reduce code duplication.  There is now a \"double\ndispatch\" pattern that lets you easily write new folders and then apply them to\nvarious structures, reusing the \"folding\" effort.", "tree": {"sha": "a918ca359de37a2a0932acc9edc81582040bb45c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a918ca359de37a2a0932acc9edc81582040bb45c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "html_url": "https://github.com/rust-lang/rust/commit/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0550b79f73996b69e7f3540fc365b7e49455ca75", "url": "https://api.github.com/repos/rust-lang/rust/commits/0550b79f73996b69e7f3540fc365b7e49455ca75", "html_url": "https://github.com/rust-lang/rust/commit/0550b79f73996b69e7f3540fc365b7e49455ca75"}], "stats": {"total": 670, "additions": 330, "deletions": 340}, "files": [{"sha": "96d2670134226d4521a8550debc7bef6fb78ce93", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 56, "deletions": 212, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "patch": "@@ -12,56 +12,48 @@\n \n use middle::ty;\n use middle::ty_fold;\n-use middle::ty_fold::TypeFolder;\n+use middle::ty_fold::{TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n-use std::rc::Rc;\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //\n // Just call `foo.subst(tcx, substs)` to perform a substitution across\n-// `foo`.\n-// Or use `foo.subst_spanned(tcx, substs, Some(span))` when there is more\n-// information available (for better errors).\n+// `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n+// there is more information available (for better errors).\n \n pub trait Subst {\n     fn subst(&self, tcx: &ty::ctxt, substs: &ty::substs) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n+\n     fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n-                     span: Option<Span>) -> Self;\n+                     span: Option<Span>)\n+                     -> Self;\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Substitution over types\n-//\n-// Because this is so common, we make a special optimization to avoid\n-// doing anything if `substs` is a no-op.  I tried to generalize these\n-// to all subst methods but ran into trouble due to the limitations of\n-// our current method/trait matching algorithm. - Niko\n-\n-impl Subst for ty::t {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n+impl<T:TypeFoldable> Subst for T {\n+    fn subst_spanned(&self,\n+                     tcx: &ty::ctxt,\n                      substs: &ty::substs,\n-                     span: Option<Span>) -> ty::t {\n-        if ty::substs_is_noop(substs) && !ty::type_has_params(*self) {\n-            *self\n-        } else {\n-            let mut folder = SubstFolder {\n-                tcx: tcx,\n-                substs: substs,\n-                span: span,\n-                root_ty: Some(*self)\n-            };\n-            folder.fold_ty(*self)\n-        }\n+                     span: Option<Span>)\n+                     -> T\n+    {\n+        let mut folder = SubstFolder { tcx: tcx,\n+                                       substs: substs,\n+                                       span: span,\n+                                       root_ty: None,\n+                                       ty_stack_depth: 0 };\n+        (*self).fold_with(&mut folder)\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// The actual substitution engine itself is a type folder.\n+\n struct SubstFolder<'a> {\n     tcx: &'a ty::ctxt,\n     substs: &'a ty::substs,\n@@ -70,23 +62,50 @@ struct SubstFolder<'a> {\n     span: Option<Span>,\n \n     // The root type that is being substituted, if available.\n-    root_ty: Option<ty::t>\n+    root_ty: Option<ty::t>,\n+\n+    // Depth of type stack\n+    ty_stack_depth: uint,\n }\n \n impl<'a> TypeFolder for SubstFolder<'a> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        r.subst(self.tcx, self.substs)\n+        // Note: This routine only handles regions that are bound on\n+        // type declarations and other outer declarations, not those\n+        // bound in *fn types*. Region substitution of the bound\n+        // regions that appear in a function signature is done using\n+        // the specialized routine\n+        // `middle::typeck::check::regionmanip::replace_late_regions_in_fn_sig()`.\n+        match r {\n+            ty::ReEarlyBound(_, i, _) => {\n+                match self.substs.regions {\n+                    ty::ErasedRegions => ty::ReStatic,\n+                    ty::NonerasedRegions(ref regions) => *regions.get(i),\n+                }\n+            }\n+            _ => r\n+        }\n     }\n \n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         if !ty::type_needs_subst(t) {\n             return t;\n         }\n \n-        match ty::get(t).sty {\n+        // track the root type we were asked to substitute\n+        let depth = self.ty_stack_depth;\n+        if depth == 0 {\n+            self.root_ty = Some(t);\n+        }\n+        self.ty_stack_depth += 1;\n+\n+        let t1 = match ty::get(t).sty {\n             ty::ty_param(p) => {\n+                // FIXME -- This...really shouldn't happen. We should\n+                // never be substituting without knowing what's in\n+                // scope and knowing that the indices will line up!\n                 if p.idx < self.substs.tps.len() {\n                     *self.substs.tps.get(p.idx)\n                 } else {\n@@ -124,189 +143,14 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                 }\n             }\n             _ => ty_fold::super_fold_ty(self, t)\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Other types\n-\n-impl<T:Subst> Subst for Vec<T> {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> Vec<T> {\n-        self.iter().map(|t| t.subst_spanned(tcx, substs, span)).collect()\n-    }\n-}\n-impl<T:Subst> Subst for Rc<T> {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> Rc<T> {\n-        Rc::new((**self).subst_spanned(tcx, substs, span))\n-    }\n-}\n-\n-impl<T:Subst> Subst for OwnedSlice<T> {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> OwnedSlice<T> {\n-        self.map(|t| t.subst_spanned(tcx, substs, span))\n-    }\n-}\n-\n-impl<T:Subst + 'static> Subst for @T {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> @T {\n-        match self {\n-            t => @(**t).subst_spanned(tcx, substs, span)\n-        }\n-    }\n-}\n-\n-impl<T:Subst> Subst for Option<T> {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> Option<T> {\n-        self.as_ref().map(|t| t.subst_spanned(tcx, substs, span))\n-    }\n-}\n-\n-impl Subst for ty::TraitRef {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> ty::TraitRef {\n-        ty::TraitRef {\n-            def_id: self.def_id,\n-            substs: self.substs.subst_spanned(tcx, substs, span)\n-        }\n-    }\n-}\n-\n-impl Subst for ty::substs {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> ty::substs {\n-        ty::substs {\n-            regions: self.regions.subst_spanned(tcx, substs, span),\n-            self_ty: self.self_ty.map(|typ| typ.subst_spanned(tcx, substs, span)),\n-            tps: self.tps.iter().map(|typ| typ.subst_spanned(tcx, substs, span)).collect()\n-        }\n-    }\n-}\n-\n-impl Subst for ty::ItemSubsts {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>)\n-                     -> ty::ItemSubsts {\n-        ty::ItemSubsts {\n-            substs: self.substs.subst_spanned(tcx, substs, span)\n-        }\n-    }\n-}\n-\n-impl Subst for ty::RegionSubsts {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> ty::RegionSubsts {\n-        match *self {\n-            ty::ErasedRegions => {\n-                ty::ErasedRegions\n-            }\n-            ty::NonerasedRegions(ref regions) => {\n-                ty::NonerasedRegions(regions.subst_spanned(tcx, substs, span))\n-            }\n-        }\n-    }\n-}\n-\n-impl Subst for ty::BareFnTy {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> ty::BareFnTy {\n-        let mut folder = SubstFolder {\n-            tcx: tcx,\n-            substs: substs,\n-            span: span,\n-            root_ty: None\n         };\n-        folder.fold_bare_fn_ty(self)\n-    }\n-}\n \n-impl Subst for ty::ParamBounds {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> ty::ParamBounds {\n-        ty::ParamBounds {\n-            builtin_bounds: self.builtin_bounds,\n-            trait_bounds: self.trait_bounds.subst_spanned(tcx, substs, span)\n+        assert_eq!(depth + 1, self.ty_stack_depth);\n+        self.ty_stack_depth -= 1;\n+        if depth == 0 {\n+            self.root_ty = None;\n         }\n-    }\n-}\n \n-impl Subst for ty::TypeParameterDef {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> ty::TypeParameterDef {\n-        ty::TypeParameterDef {\n-            ident: self.ident,\n-            def_id: self.def_id,\n-            bounds: self.bounds.subst_spanned(tcx, substs, span),\n-            default: self.default.map(|x| x.subst_spanned(tcx, substs, span))\n-        }\n-    }\n-}\n-\n-impl Subst for ty::Generics {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> ty::Generics {\n-        ty::Generics {\n-            type_param_defs: self.type_param_defs.subst_spanned(tcx, substs, span),\n-            region_param_defs: self.region_param_defs.subst_spanned(tcx, substs, span),\n-        }\n-    }\n-}\n-\n-impl Subst for ty::RegionParameterDef {\n-    fn subst_spanned(&self, _: &ty::ctxt,\n-                     _: &ty::substs,\n-                     _: Option<Span>) -> ty::RegionParameterDef {\n-        *self\n-    }\n-}\n-\n-impl Subst for ty::Region {\n-    fn subst_spanned(&self, _tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     _: Option<Span>) -> ty::Region {\n-        // Note: This routine only handles regions that are bound on\n-        // type declarations and other outer declarations, not those\n-        // bound in *fn types*. Region substitution of the bound\n-        // regions that appear in a function signature is done using\n-        // the specialized routine\n-        // `middle::typeck::check::regionmanip::replace_late_regions_in_fn_sig()`.\n-        match self {\n-            &ty::ReEarlyBound(_, i, _) => {\n-                match substs.regions {\n-                    ty::ErasedRegions => ty::ReStatic,\n-                    ty::NonerasedRegions(ref regions) => *regions.get(i),\n-                }\n-            }\n-            _ => *self\n-        }\n-    }\n-}\n-\n-impl Subst for ty::ty_param_bounds_and_ty {\n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n-                     span: Option<Span>) -> ty::ty_param_bounds_and_ty {\n-        ty::ty_param_bounds_and_ty {\n-            generics: self.generics.subst_spanned(tcx, substs, span),\n-            ty: self.ty.subst_spanned(tcx, substs, span)\n-        }\n+        t1\n     }\n }"}, {"sha": "7ef61a2361d3968b544c9a321dd4c3f3b9e61f6a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "patch": "@@ -26,7 +26,7 @@ use middle::subst::Subst;\n use middle::typeck;\n use middle::typeck::MethodCall;\n use middle::ty_fold;\n-use middle::ty_fold::TypeFolder;\n+use middle::ty_fold::{TypeFoldable,TypeFolder};\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str};\n@@ -1034,7 +1034,7 @@ pub struct ParameterEnvironment {\n     pub self_param_bound: Option<Rc<TraitRef>>,\n \n     /// Bounds on each numbered type parameter\n-    pub type_param_bounds: Vec<ParamBounds> ,\n+    pub type_param_bounds: Vec<ParamBounds>,\n }\n \n /// A polytype.\n@@ -1519,7 +1519,9 @@ pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n \n impl ItemSubsts {\n     pub fn empty() -> ItemSubsts {\n-        ItemSubsts { substs: substs::empty() }\n+        ItemSubsts {\n+            substs: substs::empty(),\n+        }\n     }\n \n     pub fn is_noop(&self) -> bool {\n@@ -4102,8 +4104,8 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n                        substs: &substs)\n                        -> substs {\n             substs { regions: ErasedRegions,\n-                     self_ty: ty_fold::fold_opt_ty(self, substs.self_ty),\n-                     tps: ty_fold::fold_ty_vec(self, substs.tps.as_slice()) }\n+                     self_ty: substs.self_ty.fold_with(self),\n+                     tps: substs.tps.fold_with(self) }\n         }\n \n         fn fold_sig(&mut self,\n@@ -4113,8 +4115,8 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n             // are erased at trans time.\n             ty::FnSig {\n                 binder_id: ast::DUMMY_NODE_ID,\n-                inputs: ty_fold::fold_ty_vec(self, sig.inputs.as_slice()),\n-                output: self.fold_ty(sig.output),\n+                inputs: sig.inputs.fold_with(self),\n+                output: sig.output.fold_with(self),\n                 variadic: sig.variadic,\n             }\n         }"}, {"sha": "27a02ea47cb9144b576bc5785bf82cf153868935", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 256, "deletions": 45, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "patch": "@@ -11,8 +11,25 @@\n // Generalized type folding mechanism.\n \n use middle::ty;\n+use middle::typeck;\n+use std::rc::Rc;\n+use syntax::owned_slice::OwnedSlice;\n use util::ppaux::Repr;\n \n+///////////////////////////////////////////////////////////////////////////\n+// Two generic traits\n+\n+/// The TypeFoldable trait is implemented for every type that can be folded.\n+/// Basically, every type that has a corresponding method in TypeFolder.\n+pub trait TypeFoldable {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Self;\n+}\n+\n+/// The TypeFolder trait defines the actual *folding*. There is a\n+/// method defined for every foldable type. Each of these has a\n+/// default implementation that does an \"identity\" fold. Within each\n+/// identity fold, it should invoke `foo.fold_with(self)` to fold each\n+/// sub-item.\n pub trait TypeFolder {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n \n@@ -46,22 +63,15 @@ pub trait TypeFolder {\n \n     fn fold_bare_fn_ty(&mut self,\n                        fty: &ty::BareFnTy)\n-                       -> ty::BareFnTy {\n-        ty::BareFnTy { sig: self.fold_sig(&fty.sig),\n-                       abi: fty.abi,\n-                       fn_style: fty.fn_style }\n+                       -> ty::BareFnTy\n+    {\n+        super_fold_bare_fn_ty(self, fty)\n     }\n \n     fn fold_closure_ty(&mut self,\n                        fty: &ty::ClosureTy)\n                        -> ty::ClosureTy {\n-        ty::ClosureTy {\n-            store: self.fold_trait_store(fty.store),\n-            sig: self.fold_sig(&fty.sig),\n-            fn_style: fty.fn_style,\n-            onceness: fty.onceness,\n-            bounds: fty.bounds,\n-        }\n+        super_fold_closure_ty(self, fty)\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n@@ -75,22 +85,195 @@ pub trait TypeFolder {\n     fn fold_autoref(&mut self, ar: &ty::AutoRef) -> ty::AutoRef {\n         super_fold_autoref(self, ar)\n     }\n+\n+    fn fold_item_substs(&mut self, i: ty::ItemSubsts) -> ty::ItemSubsts {\n+        super_fold_item_substs(self, i)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// TypeFoldable implementations.\n+//\n+// Ideally, each type should invoke `folder.fold_foo(self)` and\n+// nothing else. In some cases, though, we haven't gotten around to\n+// adding methods on the `folder` yet, and thus the folding is\n+// hard-coded here. This is less-flexible, because folders cannot\n+// override the behavior, but there are a lot of random types and one\n+// can easily refactor the folding into the TypeFolder trait as\n+// needed.\n+\n+impl<T:TypeFoldable> TypeFoldable for Option<T> {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Option<T> {\n+        self.as_ref().map(|t| t.fold_with(folder))\n+    }\n+}\n+\n+impl<T:TypeFoldable> TypeFoldable for Rc<T> {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Rc<T> {\n+        Rc::new((**self).fold_with(folder))\n+    }\n+}\n+\n+impl<T:TypeFoldable> TypeFoldable for Vec<T> {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Vec<T> {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> OwnedSlice<T> {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl TypeFoldable for ty::TraitStore {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TraitStore {\n+        folder.fold_trait_store(*self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::t {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::t {\n+        folder.fold_ty(*self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::BareFnTy {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::BareFnTy {\n+        folder.fold_bare_fn_ty(self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::ClosureTy {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ClosureTy {\n+        folder.fold_closure_ty(self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::mt {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::mt {\n+        folder.fold_mt(self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::FnSig {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::FnSig {\n+        folder.fold_sig(self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::sty {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::sty {\n+        folder.fold_sty(self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::TraitRef {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TraitRef {\n+        folder.fold_trait_ref(self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::Region {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::Region {\n+        folder.fold_region(*self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::substs {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::substs {\n+        folder.fold_substs(self)\n+    }\n+}\n+\n+impl TypeFoldable for ty::ItemSubsts {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ItemSubsts {\n+        ty::ItemSubsts {\n+            substs: self.substs.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl TypeFoldable for ty::AutoRef {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::AutoRef {\n+        folder.fold_autoref(self)\n+    }\n+}\n+\n+impl TypeFoldable for typeck::vtable_origin {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> typeck::vtable_origin {\n+        match *self {\n+            typeck::vtable_static(def_id, ref substs, ref origins) => {\n+                let r_substs = substs.fold_with(folder);\n+                let r_origins = origins.fold_with(folder);\n+                typeck::vtable_static(def_id, r_substs, r_origins)\n+            }\n+            typeck::vtable_param(n, b) => {\n+                typeck::vtable_param(n, b)\n+            }\n+        }\n+    }\n+}\n+\n+impl TypeFoldable for typeck::impl_res {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> typeck::impl_res {\n+        typeck::impl_res {\n+            trait_vtables: self.trait_vtables.fold_with(folder),\n+            self_vtables: self.self_vtables.fold_with(folder),\n+        }\n+    }\n }\n \n-pub fn fold_opt_ty<T:TypeFolder>(this: &mut T,\n-                                 t: Option<ty::t>)\n-                                 -> Option<ty::t> {\n-    t.map(|t| this.fold_ty(t))\n+impl TypeFoldable for ty::BuiltinBounds {\n+    fn fold_with<F:TypeFolder>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n+        *self\n+    }\n }\n \n-pub fn fold_ty_vec<T:TypeFolder>(this: &mut T, tys: &[ty::t]) -> Vec<ty::t> {\n-    tys.iter().map(|t| this.fold_ty(*t)).collect()\n+impl TypeFoldable for ty::ParamBounds {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ParamBounds {\n+        ty::ParamBounds {\n+            builtin_bounds: self.builtin_bounds.fold_with(folder),\n+            trait_bounds: self.trait_bounds.fold_with(folder),\n+        }\n+    }\n }\n \n+impl TypeFoldable for ty::TypeParameterDef {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TypeParameterDef {\n+        ty::TypeParameterDef {\n+            ident: self.ident,\n+            def_id: self.def_id,\n+            bounds: self.bounds.fold_with(folder),\n+            default: self.default.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl TypeFoldable for ty::RegionParameterDef {\n+    fn fold_with<F:TypeFolder>(&self, _folder: &mut F) -> ty::RegionParameterDef {\n+        *self\n+    }\n+}\n+\n+impl TypeFoldable for ty::Generics {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::Generics {\n+        ty::Generics {\n+            type_param_defs: self.type_param_defs.fold_with(folder),\n+            region_param_defs: self.region_param_defs.fold_with(folder)\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// \"super\" routines: these are the default implementations for TypeFolder.\n+//\n+// They should invoke `foo.fold_with()` to do recursive folding.\n+\n pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n                                    t: ty::t)\n                                    -> ty::t {\n-    let sty = this.fold_sty(&ty::get(t).sty);\n+    let sty = ty::get(t).sty.fold_with(this);\n     ty::mk_t(this.tcx(), sty)\n }\n \n@@ -102,56 +285,78 @@ pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n             ty::ErasedRegions\n         }\n         ty::NonerasedRegions(ref regions) => {\n-            ty::NonerasedRegions(regions.map(|r| this.fold_region(*r)))\n+            ty::NonerasedRegions(regions.fold_with(this))\n         }\n     };\n \n     ty::substs { regions: regions,\n-                 self_ty: fold_opt_ty(this, substs.self_ty),\n-                 tps: fold_ty_vec(this, substs.tps.as_slice()), }\n+                 self_ty: substs.self_ty.fold_with(this),\n+                 tps: substs.tps.fold_with(this) }\n }\n \n pub fn super_fold_sig<T:TypeFolder>(this: &mut T,\n                                     sig: &ty::FnSig)\n                                     -> ty::FnSig {\n     ty::FnSig { binder_id: sig.binder_id,\n-                inputs: fold_ty_vec(this, sig.inputs.as_slice()),\n-                output: this.fold_ty(sig.output),\n+                inputs: sig.inputs.fold_with(this),\n+                output: sig.output.fold_with(this),\n                 variadic: sig.variadic }\n }\n \n+pub fn super_fold_bare_fn_ty<T:TypeFolder>(this: &mut T,\n+                                           fty: &ty::BareFnTy)\n+                                           -> ty::BareFnTy\n+{\n+    ty::BareFnTy { sig: fty.sig.fold_with(this),\n+                   abi: fty.abi,\n+                   fn_style: fty.fn_style }\n+}\n+\n+pub fn super_fold_closure_ty<T:TypeFolder>(this: &mut T,\n+                                           fty: &ty::ClosureTy)\n+                                           -> ty::ClosureTy\n+{\n+    ty::ClosureTy {\n+        store: fty.store.fold_with(this),\n+        sig: fty.sig.fold_with(this),\n+        fn_style: fty.fn_style,\n+        onceness: fty.onceness,\n+        bounds: fty.bounds,\n+    }\n+}\n+\n pub fn super_fold_trait_ref<T:TypeFolder>(this: &mut T,\n                                           t: &ty::TraitRef)\n                                           -> ty::TraitRef {\n     ty::TraitRef {\n         def_id: t.def_id,\n-        substs: this.fold_substs(&t.substs)\n+        substs: t.substs.fold_with(this),\n     }\n }\n \n pub fn super_fold_mt<T:TypeFolder>(this: &mut T,\n                                    mt: &ty::mt) -> ty::mt {\n-    ty::mt {ty: this.fold_ty(mt.ty),\n+    ty::mt {ty: mt.ty.fold_with(this),\n             mutbl: mt.mutbl}\n }\n \n pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n                                     sty: &ty::sty) -> ty::sty {\n     match *sty {\n         ty::ty_box(typ) => {\n-            ty::ty_box(this.fold_ty(typ))\n+            ty::ty_box(typ.fold_with(this))\n         }\n         ty::ty_uniq(typ) => {\n-            ty::ty_uniq(this.fold_ty(typ))\n+            ty::ty_uniq(typ.fold_with(this))\n         }\n         ty::ty_ptr(ref tm) => {\n-            ty::ty_ptr(this.fold_mt(tm))\n+            ty::ty_ptr(tm.fold_with(this))\n         }\n         ty::ty_vec(ref tm, sz) => {\n-            ty::ty_vec(this.fold_mt(tm), sz)\n+            ty::ty_vec(tm.fold_with(this), sz)\n         }\n         ty::ty_enum(tid, ref substs) => {\n-            ty::ty_enum(tid, this.fold_substs(substs))\n+            ty::ty_enum(tid, substs.fold_with(this))\n         }\n         ty::ty_trait(box ty::TyTrait {\n                 def_id,\n@@ -161,28 +366,25 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n             }) => {\n             ty::ty_trait(box ty::TyTrait {\n                 def_id: def_id,\n-                substs: this.fold_substs(substs),\n-                store: this.fold_trait_store(store),\n+                substs: substs.fold_with(this),\n+                store: store.fold_with(this),\n                 bounds: bounds\n             })\n         }\n         ty::ty_tup(ref ts) => {\n-            ty::ty_tup(fold_ty_vec(this, ts.as_slice()))\n+            ty::ty_tup(ts.fold_with(this))\n         }\n         ty::ty_bare_fn(ref f) => {\n-            ty::ty_bare_fn(this.fold_bare_fn_ty(f))\n+            ty::ty_bare_fn(f.fold_with(this))\n         }\n         ty::ty_closure(ref f) => {\n-            ty::ty_closure(box this.fold_closure_ty(*f))\n+            ty::ty_closure(box f.fold_with(this))\n         }\n         ty::ty_rptr(r, ref tm) => {\n-            ty::ty_rptr(this.fold_region(r),\n-                        ty::mt {ty: this.fold_ty(tm.ty),\n-                                mutbl: tm.mutbl})\n+            ty::ty_rptr(r.fold_with(this), tm.fold_with(this))\n         }\n         ty::ty_struct(did, ref substs) => {\n-            ty::ty_struct(did,\n-                          this.fold_substs(substs))\n+            ty::ty_struct(did, substs.fold_with(this))\n         }\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n@@ -199,7 +401,7 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n     match trait_store {\n         ty::UniqTraitStore => ty::UniqTraitStore,\n         ty::RegionTraitStore(r, m) => {\n-            ty::RegionTraitStore(this.fold_region(r), m)\n+            ty::RegionTraitStore(r.fold_with(this), m)\n         }\n     }\n }\n@@ -209,11 +411,20 @@ pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n                                         -> ty::AutoRef\n {\n     match *autoref {\n-        ty::AutoPtr(r, m) => ty::AutoPtr(this.fold_region(r), m),\n-        ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(this.fold_region(r), m),\n-        ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(this.fold_region(r), m),\n+        ty::AutoPtr(r, m) => ty::AutoPtr(r.fold_with(this), m),\n+        ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(r.fold_with(this), m),\n+        ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(r.fold_with(this), m),\n         ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n-        ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(this.fold_region(r), m),\n+        ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(r.fold_with(this), m),\n+    }\n+}\n+\n+pub fn super_fold_item_substs<T:TypeFolder>(this: &mut T,\n+                                            substs: ty::ItemSubsts)\n+                                            -> ty::ItemSubsts\n+{\n+    ty::ItemSubsts {\n+        substs: substs.substs.fold_with(this),\n     }\n }\n "}, {"sha": "22a8168ecaad112b79d9244590ac4f3573044475", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "patch": "@@ -3963,10 +3963,12 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         (tps, regions)\n     };\n \n+    let substs = substs { regions: regions,\n+                          self_ty: None,\n+                          tps: tps };\n+\n     fcx.write_ty_substs(node_id, tpt.ty, ty::ItemSubsts {\n-        substs: substs { regions: regions,\n-                         self_ty: None,\n-                         tps: tps }\n+        substs: substs,\n     });\n \n     debug!(\"<<<\");"}, {"sha": "993a678bd267e35a8425b537f687099df3f30816", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 73, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f1aa2acb26da1f99d74cd4d4424c75278b43d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=7d6f1aa2acb26da1f99d74cd4d4424c75278b43d", "patch": "@@ -15,15 +15,14 @@\n \n use middle::pat_util;\n use middle::ty;\n-use middle::ty_fold::TypeFolder;\n+use middle::ty_fold::{TypeFolder,TypeFoldable};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::impl_res;\n use middle::typeck::{MethodCall, MethodCallee};\n-use middle::typeck::{vtable_origin, vtable_static, vtable_param};\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n use util::ppaux::Repr;\n@@ -355,77 +354,9 @@ trait ResolveIn {\n     fn resolve_in(&self, resolver: &mut Resolver) -> Self;\n }\n \n-impl<T:ResolveIn> ResolveIn for Option<T> {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> Option<T> {\n-        self.as_ref().map(|t| t.resolve_in(resolver))\n-    }\n-}\n-\n-impl<T:ResolveIn> ResolveIn for Vec<T> {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> Vec<T> {\n-        self.iter().map(|t| t.resolve_in(resolver)).collect()\n-    }\n-}\n-\n-impl ResolveIn for ty::TraitStore {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> ty::TraitStore {\n-        resolver.fold_trait_store(*self)\n-    }\n-}\n-\n-impl ResolveIn for ty::t {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> ty::t {\n-        resolver.fold_ty(*self)\n-    }\n-}\n-\n-impl ResolveIn for ty::Region {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> ty::Region {\n-        resolver.fold_region(*self)\n-    }\n-}\n-\n-impl ResolveIn for ty::substs {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> ty::substs {\n-        resolver.fold_substs(self)\n-    }\n-}\n-\n-impl ResolveIn for ty::ItemSubsts {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> ty::ItemSubsts {\n-        ty::ItemSubsts {\n-            substs: self.substs.resolve_in(resolver)\n-        }\n-    }\n-}\n-\n-impl ResolveIn for ty::AutoRef {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> ty::AutoRef {\n-        resolver.fold_autoref(self)\n-    }\n-}\n-\n-impl ResolveIn for vtable_origin {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> vtable_origin {\n-        match *self {\n-            vtable_static(def_id, ref substs, ref origins) => {\n-                let r_substs = substs.resolve_in(resolver);\n-                let r_origins = origins.resolve_in(resolver);\n-                vtable_static(def_id, r_substs, r_origins)\n-            }\n-            vtable_param(n, b) => {\n-                vtable_param(n, b)\n-            }\n-        }\n-    }\n-}\n-\n-impl ResolveIn for impl_res {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> impl_res {\n-        impl_res {\n-            trait_vtables: self.trait_vtables.resolve_in(resolver),\n-            self_vtables: self.self_vtables.resolve_in(resolver),\n-        }\n+impl<T:TypeFoldable> ResolveIn for T {\n+    fn resolve_in(&self, resolver: &mut Resolver) -> T {\n+        self.fold_with(resolver)\n     }\n }\n "}]}