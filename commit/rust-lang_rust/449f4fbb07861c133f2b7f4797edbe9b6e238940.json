{"sha": "449f4fbb07861c133f2b7f4797edbe9b6e238940", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0OWY0ZmJiMDc4NjFjMTMzZjJiN2Y0Nzk3ZWRiZTliNmUyMzg5NDA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-02T23:03:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-05T21:38:45Z"}, "message": "rustc: Implement deriving involving generic bounded traits. r=brson", "tree": {"sha": "f3966788a584af6432871f30a3b023e23310be12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3966788a584af6432871f30a3b023e23310be12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/449f4fbb07861c133f2b7f4797edbe9b6e238940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/449f4fbb07861c133f2b7f4797edbe9b6e238940", "html_url": "https://github.com/rust-lang/rust/commit/449f4fbb07861c133f2b7f4797edbe9b6e238940", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/449f4fbb07861c133f2b7f4797edbe9b6e238940/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be93b29d304b310ec56630f5313ccddf3ae470ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/be93b29d304b310ec56630f5313ccddf3ae470ea", "html_url": "https://github.com/rust-lang/rust/commit/be93b29d304b310ec56630f5313ccddf3ae470ea"}], "stats": {"total": 216, "additions": 180, "deletions": 36}, "files": [{"sha": "796b42635356535616bdf0033a2fb99d02c1f429", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=449f4fbb07861c133f2b7f4797edbe9b6e238940", "patch": "@@ -153,7 +153,7 @@ fn trans_fn_ref_with_vtables_to_callee(bcx: block,\n fn trans_fn_ref_with_vtables(\n     bcx: block,            //\n     def_id: ast::def_id,   // def id of fn\n-    ref_id: ast::node_id,  // node id of use of fn\n+    ref_id: ast::node_id,  // node id of use of fn; may be zero if N/A\n     type_params: ~[ty::t], // values for fn's ty params\n     vtables: Option<typeck::vtable_res>)\n     -> FnData"}, {"sha": "bc398bf753df37bf8ad2ec48f669caf8aafa8143", "filename": "src/rustc/middle/trans/deriving.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=449f4fbb07861c133f2b7f4797edbe9b6e238940", "patch": "@@ -13,7 +13,8 @@ use middle::trans::common;\n use middle::trans::common::{C_bool, C_int, T_ptr, block, crate_ctxt};\n use middle::trans::expr::SaveIn;\n use middle::trans::type_of::type_of;\n-use middle::typeck::{method_origin, method_static};\n+use middle::ty::DerivedFieldInfo;\n+use middle::typeck::method_static;\n use syntax::ast;\n use syntax::ast::{def_id, ident, node_id, ty_param};\n use syntax::ast_map::path;\n@@ -229,23 +230,37 @@ fn trans_deriving_enum_method(ccx: @crate_ctxt, llfn: ValueRef,\n }\n \n fn call_substructure_method(bcx: block,\n-                            derived_method_info: &method_origin,\n+                            derived_field_info: &DerivedFieldInfo,\n                             self_ty: ty::t,\n                             llselfval: ValueRef,\n                             llotherval: ValueRef) -> block {\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n     let target_method_def_id;\n-    match *derived_method_info {\n+    match derived_field_info.method_origin {\n         method_static(did) => target_method_def_id = did,\n         _ => fail ~\"derived method didn't resolve to a static method\"\n     }\n \n-    let fn_expr_ty = ty::lookup_item_type(ccx.tcx, target_method_def_id).ty;\n+    let fn_expr_tpbt = ty::lookup_item_type(ccx.tcx, target_method_def_id);\n+    debug!(\"(calling substructure method) substructure method has %u \\\n+            parameter(s), vtable result is %?\",\n+           fn_expr_tpbt.bounds.len(),\n+           derived_field_info.vtable_result);\n+\n+    // Get the substructure method we need to call. This may involve\n+    // code generation in the case of generics, default methods, or cross-\n+    // crate inlining.\n+    let fn_data = callee::trans_fn_ref_with_vtables(bcx,\n+                                                    target_method_def_id,\n+                                                    0,     // ref id\n+                                                    *derived_field_info.\n+                                                 type_parameter_substitutions,\n+                                                    derived_field_info.\n+                                                        vtable_result);\n+    let llfn = fn_data.llfn;\n \n-    // XXX: Cross-crate won't work!\n-    let llfn = get_item_val(ccx, target_method_def_id.node);\n     let cb: &fn(block) -> Callee = |block| {\n         Callee {\n             bcx: block,\n@@ -260,7 +275,7 @@ fn call_substructure_method(bcx: block,\n \n     callee::trans_call_inner(bcx,\n                              None,\n-                             fn_expr_ty,\n+                             fn_expr_tpbt.ty,\n                              ty::mk_bool(ccx.tcx),\n                              cb,\n                              ArgVals(~[llotherval]),"}, {"sha": "69b4d985f6f6a7fb3f5d4b98b5bd5ee9220664bf", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=449f4fbb07861c133f2b7f4797edbe9b6e238940", "patch": "@@ -203,6 +203,7 @@ export trait_supertraits;\n export AutoAdjustment;\n export AutoRef, AutoRefKind, AutoSlice, AutoPtr;\n export DerivedMethodInfo;\n+export DerivedFieldInfo;\n \n // Data types\n \n@@ -341,6 +342,12 @@ struct DerivedMethodInfo {\n     containing_impl: ast::def_id\n }\n \n+struct DerivedFieldInfo {\n+    method_origin: typeck::method_origin,\n+    type_parameter_substitutions: @~[ty::t],\n+    vtable_result: Option<typeck::vtable_res>\n+}\n+\n type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: HashMap<intern_key, t_box>,\n@@ -386,13 +393,11 @@ type ctxt =\n       legacy_boxed_traits: HashMap<node_id, ()>,\n       provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>,\n       supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n-      deriving_struct_methods: HashMap<ast::def_id,\n-                                       @~[typeck::method_origin]>,\n+      deriving_struct_methods: HashMap<ast::def_id, @~[DerivedFieldInfo]>,\n \n       // The outer vector here describes each enum variant, while the inner\n       // nested vector describes each enum variant argument.\n-      deriving_enum_methods: HashMap<ast::def_id,\n-                                     @~[@~[typeck::method_origin]]>,\n+      deriving_enum_methods: HashMap<ast::def_id, @~[@~[DerivedFieldInfo]]>,\n \n       // A mapping from the def ID of a method that was automatically derived\n       // to information about it."}, {"sha": "7fa44491a872e7b00e78ad4d31f939f69809ed05", "filename": "src/rustc/middle/typeck/deriving.rs", "status": "modified", "additions": 115, "deletions": 24, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Frustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Frustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fderiving.rs?ref=449f4fbb07861c133f2b7f4797edbe9b6e238940", "patch": "@@ -11,47 +11,112 @@ use syntax::ast::item_impl;\n use syntax::ast::node_id;\n use syntax::ast::self_ty_;\n use syntax::ast::trait_ref;\n-use syntax::ast_util::def_id_of_def;\n+use syntax::ast_util::{def_id_of_def, dummy_sp};\n use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, visit_crate};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty;\n-use middle::ty::{substs, ty_class, ty_enum, ty_param_bounds_and_ty};\n+use middle::ty::{DerivedFieldInfo, substs, ty_class, ty_enum};\n+use middle::ty::{ty_param_bounds_and_ty};\n use /*middle::typeck::*/check::method;\n+use /*middle::typeck::*/check::vtable;\n use /*middle::typeck::*/infer::infer_ctxt;\n+use /*middle::typeck::*/vtable::{LocationInfo, VtableContext};\n+use util::ppaux;\n+\n+struct MethodMatch {\n+    method_def_id: def_id,\n+    type_parameter_substitutions: @~[ty::t],\n+    vtable_result: Option<vtable_res>\n+}\n \n struct DerivingChecker {\n-    crate_context: @crate_ctxt,\n-    inference_context: infer_ctxt\n+    crate_context: @crate_ctxt\n }\n \n fn DerivingChecker_new(crate_context: @crate_ctxt) -> DerivingChecker {\n     DerivingChecker {\n         crate_context: crate_context,\n-        inference_context: infer::new_infer_ctxt(crate_context.tcx)\n     }\n }\n \n+struct TyParamSubstsAndVtableResult {\n+    type_parameter_substitutions: @~[ty::t],\n+    vtable_result: Option<vtable_res>\n+}\n+\n impl DerivingChecker {\n     /// Matches one substructure type against an implementation.\n     fn match_impl_method(impl_info: @Impl,\n                          substructure_type: ty::t,\n-                         method_info: @MethodInfo) -> bool {\n-        // XXX: Generics and regions are not handled properly.\n+                         method_info: @MethodInfo,\n+                         span: span) ->\n+                         Option<TyParamSubstsAndVtableResult> {\n         let tcx = self.crate_context.tcx;\n-        let impl_self_ty = ty::lookup_item_type(tcx, impl_info.did).ty;\n+\n+        let impl_self_tpbt = ty::lookup_item_type(tcx, impl_info.did);\n         let transformed_type = method::transform_self_type_for_method(\n-            tcx, None, impl_self_ty, method_info.self_type);\n-        return infer::can_mk_subty(self.inference_context,\n-                                   substructure_type,\n-                                   transformed_type).is_ok();\n+            tcx, None, impl_self_tpbt.ty, method_info.self_type);\n+\n+        let inference_context = infer::new_infer_ctxt(self.crate_context.tcx);\n+        let substs = {\n+            self_r: None,\n+            self_ty: None,\n+            tps: inference_context.next_ty_vars(impl_self_tpbt.bounds.len())\n+        };\n+        let transformed_type = ty::subst(\n+            self.crate_context.tcx, &substs, transformed_type);\n+\n+        debug!(\"(matching impl method) substructure type %s, transformed \\\n+                type %s, subst tps %u\",\n+               ppaux::ty_to_str(self.crate_context.tcx, substructure_type),\n+               ppaux::ty_to_str(self.crate_context.tcx, transformed_type),\n+               substs.tps.len());\n+\n+        if !infer::mk_subty(inference_context,\n+                            true,\n+                            ast_util::dummy_sp(),\n+                            substructure_type,\n+                            transformed_type).is_ok() {\n+            return None;\n+        }\n+\n+        // Get the vtables.\n+        let vtable_result;\n+        if substs.tps.len() == 0 {\n+            vtable_result = None;\n+        } else {\n+            let vcx = VtableContext {\n+                ccx: self.crate_context,\n+                infcx: inference_context\n+            };\n+            let location_info = LocationInfo {\n+                span: span,\n+                id: impl_info.did.node\n+            };\n+            vtable_result = Some(vtable::lookup_vtables(&vcx,\n+                                                        &location_info,\n+                                                        impl_self_tpbt.bounds,\n+                                                        &substs,\n+                                                        false,\n+                                                        false));\n+        }\n+\n+        // Extract the type parameter substitutions.\n+        let type_parameter_substitutions = @substs.tps.map(|ty_var|\n+            inference_context.resolve_type_vars_if_possible(*ty_var));\n+\n+        Some(TyParamSubstsAndVtableResult {\n+            type_parameter_substitutions: type_parameter_substitutions,\n+            vtable_result: vtable_result\n+        })\n     }\n \n     fn check_deriving_for_substructure_type(substructure_type: ty::t,\n                                             trait_ref: @trait_ref,\n                                             impl_span: span) ->\n-                                            Option<def_id> {\n+                                            Option<MethodMatch> {\n         let tcx = self.crate_context.tcx;\n         let sess = tcx.sess;\n         let coherence_info = self.crate_context.coherence_info;\n@@ -64,12 +129,25 @@ impl DerivingChecker {\n             Some(impls) => {\n                 // Try to unify each of these impls with the substructure\n                 // type.\n-                for impls.each |impl_info| {\n-                    for impl_info.methods.each |method_info| {\n-                        if self.match_impl_method(*impl_info,\n-                                                  substructure_type,\n-                                                  *method_info) {\n-                            return Some(method_info.did);\n+                //\n+                // NB: Using range to avoid a recursive-use-of-dvec error.\n+                for uint::range(0, impls.len()) |i| {\n+                    let impl_info = impls[i];\n+                    for uint::range(0, impl_info.methods.len()) |j| {\n+                        let method_info = impl_info.methods[j];\n+                        match self.match_impl_method(impl_info,\n+                                                     substructure_type,\n+                                                     method_info,\n+                                                     trait_ref.path.span) {\n+                            Some(move result) => {\n+                                return Some(MethodMatch {\n+                                    method_def_id: method_info.did,\n+                                    type_parameter_substitutions:\n+                                        result.type_parameter_substitutions,\n+                                    vtable_result: result.vtable_result\n+                                });\n+                            }\n+                            None => {}  // Continue.\n                         }\n                     }\n                 }\n@@ -91,8 +169,15 @@ impl DerivingChecker {\n             match self.check_deriving_for_substructure_type(field_type,\n                                                             trait_ref,\n                                                             impl_span) {\n-                Some(method_target_def_id) => {\n-                    field_info.push(method_static(method_target_def_id));\n+                Some(method_match) => {\n+                    field_info.push(DerivedFieldInfo {\n+                        method_origin:\n+                            method_static(method_match.method_def_id),\n+                        type_parameter_substitutions:\n+                            method_match.type_parameter_substitutions,\n+                        vtable_result:\n+                            method_match.vtable_result\n+                    });\n                 }\n                 None => {\n                     let trait_str = pprust::path_to_str(\n@@ -127,9 +212,15 @@ impl DerivingChecker {\n             for enum_variant_info.args.eachi |i, variant_arg_type| {\n                 match self.check_deriving_for_substructure_type(\n                         *variant_arg_type, trait_ref, impl_span) {\n-                    Some(method_target_def_id) => {\n-                        variant_methods.push(method_static(\n-                            method_target_def_id));\n+                    Some(method_match) => {\n+                        variant_methods.push(DerivedFieldInfo {\n+                            method_origin:\n+                                method_static(method_match.method_def_id),\n+                            type_parameter_substitutions:\n+                                method_match.type_parameter_substitutions,\n+                            vtable_result:\n+                                method_match.vtable_result\n+                        });\n                     }\n                     None => {\n                         let trait_str = pprust::path_to_str("}, {"sha": "94ecb476584d44a6fc2d24f0842afd427ac33749", "filename": "src/test/run-pass/deriving-generic-bounded.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/449f4fbb07861c133f2b7f4797edbe9b6e238940/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-generic-bounded.rs?ref=449f4fbb07861c133f2b7f4797edbe9b6e238940", "patch": "@@ -0,0 +1,33 @@\n+trait MyEq {\n+    pure fn eq(other: &self) -> bool;\n+}\n+\n+impl int : MyEq {\n+    pure fn eq(other: &int) -> bool {\n+        self == *other\n+    }\n+}\n+\n+impl<T:MyEq> @T : MyEq {\n+    pure fn eq(other: &@T) -> bool {\n+        unsafe {\n+            io::println(\"@T\");\n+        }\n+        (*self).eq(&**other)\n+    }\n+}\n+\n+struct A {\n+    x: @int,\n+    y: @int\n+}\n+\n+impl A : MyEq;\n+\n+fn main() {\n+    let a = A { x: @3, y: @5 };\n+    let b = A { x: @10, y: @20 };\n+    assert a.eq(&a);\n+    assert !a.eq(&b);\n+}\n+"}]}