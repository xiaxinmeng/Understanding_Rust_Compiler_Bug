{"sha": "d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5YzdjMDBiOWEzZDgwZmM4MWZiYmI3N2E5ZjIxZTVmNzFhMWQyMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-04T21:33:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-04T21:33:07Z"}, "message": "auto merge of #18980 : erickt/rust/reader, r=erickt\n\nThis continues the work @thestinger started in #18885 (which hasn't landed yet, so wait for that to land before landing this one). Instead of adding more methods to `BufReader`, this just allows a `&[u8]` to be used directly as a `Reader`. It also adds an impl of `Writer` for `&mut [u8]`.", "tree": {"sha": "df2148f08e426cc9f26fe74fa2409cfbbcb10f3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df2148f08e426cc9f26fe74fa2409cfbbcb10f3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "html_url": "https://github.com/rust-lang/rust/commit/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4053e82acb125e04a11f7328de7c86d314b70a9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4053e82acb125e04a11f7328de7c86d314b70a9f", "html_url": "https://github.com/rust-lang/rust/commit/4053e82acb125e04a11f7328de7c86d314b70a9f"}, {"sha": "298b525951ea4ce7a78364e835f45a549b7f865e", "url": "https://api.github.com/repos/rust-lang/rust/commits/298b525951ea4ce7a78364e835f45a549b7f865e", "html_url": "https://github.com/rust-lang/rust/commit/298b525951ea4ce7a78364e835f45a549b7f865e"}], "stats": {"total": 110, "additions": 89, "deletions": 21}, "files": [{"sha": "7c88106c9ecedf0693a324d7d9f4040fc8e98d6a", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "patch": "@@ -444,15 +444,14 @@ impl<T, E> Result<T, E> {\n     /// ignoring I/O and parse errors:\n     ///\n     /// ```\n-    /// use std::io::{BufReader, IoResult};\n+    /// use std::io::IoResult;\n     ///\n-    /// let buffer = \"1\\n2\\n3\\n4\\n\";\n-    /// let mut reader = BufReader::new(buffer.as_bytes());\n+    /// let mut buffer = &mut b\"1\\n2\\n3\\n4\\n\";\n     ///\n     /// let mut sum = 0;\n     ///\n-    /// while !reader.eof() {\n-    ///     let line: IoResult<String> = reader.read_line();\n+    /// while !buffer.is_empty() {\n+    ///     let line: IoResult<String> = buffer.read_line();\n     ///     // Convert the string line to a number using `map` and `from_str`\n     ///     let val: IoResult<int> = line.map(|line| {\n     ///         from_str::<int>(line.as_slice().trim_right()).unwrap_or(0)"}, {"sha": "0a5081d07be0072df405b343b1706eaa940a8d97", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "patch": "@@ -547,7 +547,7 @@ mod tests {\n     use self::NodeLabels::*;\n     use super::{Id, LabelText, LabelStr, EscStr, Labeller};\n     use super::{Nodes, Edges, GraphWalk, render};\n-    use std::io::{BufReader, IoResult};\n+    use std::io::IoResult;\n     use std::str;\n \n     /// each node is an index in a vector in the graph.\n@@ -698,8 +698,7 @@ mod tests {\n     fn test_input(g: LabelledGraph) -> IoResult<String> {\n         let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n-        let mut r = BufReader::new(writer[]);\n-        r.read_to_string()\n+        (&mut writer.as_slice()).read_to_string()\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,\n@@ -811,8 +810,7 @@ r#\"digraph hasse_diagram {\n                  edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n-        let mut r = BufReader::new(writer[]);\n-        let r = r.read_to_string();\n+        let r = (&mut writer.as_slice()).read_to_string();\n \n         assert_eq!(r.unwrap().as_slice(),\n r#\"digraph syntax_tree {"}, {"sha": "fba9e4f2e25e1445baea71efd37619d28202752e", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "patch": "@@ -406,7 +406,7 @@ mod test {\n     use prelude::*;\n     use super::*;\n     use super::super::{IoResult, EndOfFile};\n-    use super::super::mem::{MemReader, BufReader};\n+    use super::super::mem::MemReader;\n     use self::test::Bencher;\n     use str::StrPrelude;\n \n@@ -626,14 +626,14 @@ mod test {\n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n-        let mut reader = BufferedReader::with_capacity(1, BufReader::new(&buf));\n+        let mut reader = BufferedReader::with_capacity(1, buf[]);\n         assert_eq!(reader.read_char(), Ok('\u00df'));\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195u8, 159u8, b'a'];\n-        let mut reader = BufferedReader::with_capacity(1, BufReader::new(&buf));\n+        let mut reader = BufferedReader::with_capacity(1, buf[]);\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));\n         assert_eq!(it.next(), Some(Ok('a')));"}, {"sha": "6a9b10d2a7bd03a4f6d0e6af2cbed2038a6ae1c1", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "patch": "@@ -206,6 +206,41 @@ impl Buffer for MemReader {\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n+impl<'a> Reader for &'a [u8] {\n+    #[inline]\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        if self.is_empty() { return Err(io::standard_error(io::EndOfFile)); }\n+\n+        let write_len = min(buf.len(), self.len());\n+        {\n+            let input = self[..write_len];\n+            let output = buf[mut ..write_len];\n+            slice::bytes::copy_memory(output, input);\n+        }\n+\n+        *self = self.slice_from(write_len);\n+\n+        Ok(write_len)\n+    }\n+}\n+\n+impl<'a> Buffer for &'a [u8] {\n+    #[inline]\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+        if self.is_empty() {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else {\n+            Ok(*self)\n+        }\n+    }\n+\n+    #[inline]\n+    fn consume(&mut self, amt: uint) {\n+        *self = self[amt..];\n+    }\n+}\n+\n+\n /// Writes to a fixed-size byte slice\n ///\n /// If a write will not fit in the buffer, it returns an error and does not\n@@ -362,6 +397,16 @@ mod test {\n     use self::test::Bencher;\n     use str::StrPrelude;\n \n+    #[test]\n+    fn test_vec_writer() {\n+        let mut writer = Vec::new();\n+        writer.write(&[0]).unwrap();\n+        writer.write(&[1, 2, 3]).unwrap();\n+        writer.write(&[4, 5, 6, 7]).unwrap();\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.as_slice(), b);\n+    }\n+\n     #[test]\n     fn test_mem_writer() {\n         let mut writer = MemWriter::new();\n@@ -385,6 +430,8 @@ mod test {\n             assert_eq!(writer.tell(), Ok(8));\n             writer.write(&[]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n+\n+            assert!(writer.write(&[1]).is_err());\n         }\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         assert_eq!(buf.as_slice(), b);\n@@ -457,6 +504,32 @@ mod test {\n         assert!(reader.read(&mut buf).is_err());\n     }\n \n+    #[test]\n+    fn test_slice_reader() {\n+        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n+        let mut reader = &mut in_buf.as_slice();\n+        let mut buf = [];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        let mut buf = [0];\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.len(), 7);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf.as_slice(), b);\n+        let mut buf = [0, ..4];\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.len(), 3);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(buf[0..3], b);\n+        assert!(reader.read(&mut buf).is_err());\n+        let mut reader = &mut in_buf.as_slice();\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n+        assert!(reader.read(&mut buf).is_err());\n+    }\n+\n     #[test]\n     fn test_buf_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];"}, {"sha": "e78bd1dd33f32c57a2ca662d7bb9236bdf1587b1", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "patch": "@@ -273,7 +273,7 @@ impl<T: Iterator<u8>> Reader for IterReader<T> {\n \n #[cfg(test)]\n mod test {\n-    use io::{MemReader, BufReader, ByRefReader};\n+    use io::{MemReader, ByRefReader};\n     use io;\n     use boxed::Box;\n     use super::*;\n@@ -395,8 +395,7 @@ mod test {\n \n     #[test]\n     fn limit_reader_buffer() {\n-        let data = \"0123456789\\n0123456789\\n\";\n-        let mut r = BufReader::new(data.as_bytes());\n+        let r = &mut b\"0123456789\\n0123456789\\n\";\n         {\n             let mut r = LimitReader::new(r.by_ref(), 3);\n             assert_eq!(r.read_line(), Ok(\"012\".to_string()));"}, {"sha": "a77a6276a8b4ecc7122d4c196dc8040a6964ecdb", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=d9c7c00b9a3d80fc81fbbb77a9f21e5f71a1d213", "patch": "@@ -32,7 +32,6 @@ use self::Fmt::*;\n \n use std::fmt::Show;\n use std::fmt;\n-use std::io::BufReader;\n use std::num::SignedInt;\n use std::string::String;\n use std::time::Duration;\n@@ -1187,7 +1186,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n         }\n     }\n \n-    let mut rdr = BufReader::new(format.as_bytes());\n+    let mut rdr: &[u8] = format.as_bytes();\n     let mut tm = Tm {\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n@@ -1211,13 +1210,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n         let next = range.next;\n \n         let mut buf = [0];\n-        let c = match rdr.read(&mut buf) {\n+        let c = match (&mut rdr).read(&mut buf) {\n             Ok(..) => buf[0] as char,\n             Err(..) => break\n         };\n         match c {\n             '%' => {\n-                let ch = match rdr.read(&mut buf) {\n+                let ch = match (&mut rdr).read(&mut buf) {\n                     Ok(..) => buf[0] as char,\n                     Err(..) => break\n                 };\n@@ -1233,7 +1232,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n         }\n     }\n \n-    if pos == len && rdr.tell().unwrap() == format.len() as u64 {\n+    if pos == len && (&mut rdr).is_empty() {\n         Ok(Tm {\n             tm_sec: tm.tm_sec,\n             tm_min: tm.tm_min,"}]}