{"sha": "b5ba9c3e3ae25b6add36c670de75967a7b38bb53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YmE5YzNlM2FlMjViNmFkZDM2YzY3MGRlNzU5NjdhN2IzOGJiNTM=", "commit": {"author": {"name": "Steffen Lyngbaek", "email": "steffenlyngbaek@gmail.com", "date": "2020-03-17T23:02:39Z"}, "committer": {"name": "Steffen Lyngbaek", "email": "steffenlyngbaek@gmail.com", "date": "2020-03-19T18:49:01Z"}, "message": "Address nits and suggestions.\n\nSimplify the logic a lot by removing the check for a placeholder pat.\nThis means the auto-fill no longer returns a compile-able value.", "tree": {"sha": "adc02bf428b818d271c5a6a7246a36ce8d4960b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adc02bf428b818d271c5a6a7246a36ce8d4960b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5ba9c3e3ae25b6add36c670de75967a7b38bb53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ba9c3e3ae25b6add36c670de75967a7b38bb53", "html_url": "https://github.com/rust-lang/rust/commit/b5ba9c3e3ae25b6add36c670de75967a7b38bb53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5ba9c3e3ae25b6add36c670de75967a7b38bb53/comments", "author": {"login": "slyngbaek", "id": 1216902, "node_id": "MDQ6VXNlcjEyMTY5MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1216902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/slyngbaek", "html_url": "https://github.com/slyngbaek", "followers_url": "https://api.github.com/users/slyngbaek/followers", "following_url": "https://api.github.com/users/slyngbaek/following{/other_user}", "gists_url": "https://api.github.com/users/slyngbaek/gists{/gist_id}", "starred_url": "https://api.github.com/users/slyngbaek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/slyngbaek/subscriptions", "organizations_url": "https://api.github.com/users/slyngbaek/orgs", "repos_url": "https://api.github.com/users/slyngbaek/repos", "events_url": "https://api.github.com/users/slyngbaek/events{/privacy}", "received_events_url": "https://api.github.com/users/slyngbaek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "slyngbaek", "id": 1216902, "node_id": "MDQ6VXNlcjEyMTY5MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1216902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/slyngbaek", "html_url": "https://github.com/slyngbaek", "followers_url": "https://api.github.com/users/slyngbaek/followers", "following_url": "https://api.github.com/users/slyngbaek/following{/other_user}", "gists_url": "https://api.github.com/users/slyngbaek/gists{/gist_id}", "starred_url": "https://api.github.com/users/slyngbaek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/slyngbaek/subscriptions", "organizations_url": "https://api.github.com/users/slyngbaek/orgs", "repos_url": "https://api.github.com/users/slyngbaek/repos", "events_url": "https://api.github.com/users/slyngbaek/events{/privacy}", "received_events_url": "https://api.github.com/users/slyngbaek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f8f8a38a251197c8b07e349d9782c3ec5fde383", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f8f8a38a251197c8b07e349d9782c3ec5fde383", "html_url": "https://github.com/rust-lang/rust/commit/5f8f8a38a251197c8b07e349d9782c3ec5fde383"}], "stats": {"total": 172, "additions": 32, "deletions": 140}, "files": [{"sha": "fbd6a3ec36c02ba82e3934c1fe57b34193bd15e8", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 32, "deletions": 140, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b5ba9c3e3ae25b6add36c670de75967a7b38bb53/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ba9c3e3ae25b6add36c670de75967a7b38bb53/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=b5ba9c3e3ae25b6add36c670de75967a7b38bb53", "patch": "@@ -1,17 +1,14 @@\n //! FIXME: write short doc here\n \n-use std::{collections::LinkedList, iter};\n+use std::iter;\n \n use hir::{Adt, HasSource, Semantics};\n use ra_ide_db::RootDatabase;\n \n use crate::{Assist, AssistCtx, AssistId};\n-use ra_syntax::{\n-    ast::{self, edit::IndentLevel, make, AstNode, NameOwner},\n-    SyntaxKind, SyntaxNode,\n-};\n+use ra_syntax::ast::{self, edit::IndentLevel, make, AstNode, NameOwner};\n \n-use ast::{MatchArm, MatchGuard, Pat};\n+use ast::{MatchArm, Pat};\n \n // Assist: fill_match_arms\n //\n@@ -57,48 +54,20 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         }\n     }\n \n-    let mut has_partial_match = false;\n     let db = ctx.db;\n     let missing_arms: Vec<MatchArm> = variants\n         .into_iter()\n         .filter_map(|variant| build_pat(db, module, variant))\n-        .filter(|variant_pat| {\n-            !arms.iter().filter_map(|arm| arm.pat().map(|_| arm)).any(|arm| {\n-                let pat = arm.pat().unwrap();\n-\n-                // Special casee OrPat as separate top-level pats\n-                let pats: Vec<Pat> = match Pat::from(pat.clone()) {\n-                    Pat::OrPat(pats) => pats.pats().collect::<Vec<_>>(),\n-                    _ => vec![pat],\n-                };\n-\n-                pats.iter().any(|pat| {\n-                    match does_arm_pat_match_variant(pat, arm.guard(), variant_pat) {\n-                        ArmMatch::Yes => true,\n-                        ArmMatch::No => false,\n-                        ArmMatch::Partial => {\n-                            has_partial_match = true;\n-                            true\n-                        }\n-                    }\n-                })\n-            })\n-        })\n+        .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n         .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n         .collect();\n \n-    if missing_arms.is_empty() && !has_partial_match {\n+    if missing_arms.is_empty() {\n         return None;\n     }\n \n     ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", |edit| {\n         arms.extend(missing_arms);\n-        if has_partial_match {\n-            arms.push(make::match_arm(\n-                iter::once(make::placeholder_pat().into()),\n-                make::expr_unit(),\n-            ));\n-        }\n \n         let indent_level = IndentLevel::from_node(match_arm_list.syntax());\n         let new_arm_list = indent_level.increase_indent(make::match_arm_list(arms));\n@@ -109,59 +78,23 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     })\n }\n \n-enum ArmMatch {\n-    Yes,\n-    No,\n-    Partial,\n-}\n-\n-fn does_arm_pat_match_variant(arm: &Pat, arm_guard: Option<MatchGuard>, var: &Pat) -> ArmMatch {\n-    let arm = flatten_pats(arm.clone());\n-    let var = flatten_pats(var.clone());\n-    let mut arm = arm.iter();\n-    let mut var = var.iter();\n-\n-    // If the first part of the Pat don't match, there's no match\n-    match (arm.next(), var.next()) {\n-        (Some(arm), Some(var)) if arm.text() == var.text() => {}\n-        _ => return ArmMatch::No,\n-    }\n-\n-    // If we have a guard we automatically know we have a partial match\n-    if arm_guard.is_some() {\n-        return ArmMatch::Partial;\n-    }\n+fn is_variant_missing(existing_arms: &mut Vec<MatchArm>, var: &Pat) -> bool {\n+    existing_arms.iter().filter_map(|arm| arm.pat()).all(|pat| {\n+        // Special casee OrPat as separate top-level pats\n+        let top_level_pats: Vec<Pat> = match pat {\n+            Pat::OrPat(pats) => pats.pats().collect::<Vec<_>>(),\n+            _ => vec![pat],\n+        };\n \n-    if arm.clone().count() != var.clone().count() {\n-        return ArmMatch::Partial;\n-    }\n-\n-    let direct_match = arm.zip(var).all(|(arm, var)| {\n-        if arm.text() == var.text() {\n-            return true;\n-        }\n-        match (arm.kind(), var.kind()) {\n-            (SyntaxKind::PLACEHOLDER_PAT, SyntaxKind::PLACEHOLDER_PAT) => true,\n-            (SyntaxKind::DOT_DOT_PAT, SyntaxKind::PLACEHOLDER_PAT) => true,\n-            (SyntaxKind::BIND_PAT, SyntaxKind::PLACEHOLDER_PAT) => true,\n-            _ => false,\n-        }\n-    });\n-\n-    match direct_match {\n-        true => ArmMatch::Yes,\n-        false => ArmMatch::Partial,\n-    }\n+        !top_level_pats.iter().any(|pat| does_pat_match_variant(pat, var))\n+    })\n }\n \n-fn flatten_pats(pat: Pat) -> Vec<SyntaxNode> {\n-    let mut pats: LinkedList<SyntaxNode> = pat.syntax().children().collect();\n-    let mut out: Vec<SyntaxNode> = vec![];\n-    while let Some(p) = pats.pop_front() {\n-        pats.extend(p.children());\n-        out.push(p);\n-    }\n-    out\n+fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n+    let pat_head = pat.syntax().first_child().map(|node| node.text());\n+    let var_head = var.syntax().first_child().map(|node| node.text());\n+\n+    pat_head == var_head\n }\n \n fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<hir::Enum> {\n@@ -193,66 +126,59 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::EnumVariant) -> O\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_target};\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::fill_match_arms;\n \n     #[test]\n-    fn partial_fill_multi() {\n-        check_assist(\n+    fn all_match_arms_provided() {\n+        check_assist_not_applicable(\n             fill_match_arms,\n             r#\"\n             enum A {\n                 As,\n-                Bs(i32, Option<i32>)\n+                Bs{x:i32, y:Option<i32>},\n+                Cs(i32, Option<i32>),\n             }\n             fn main() {\n                 match A::As<|> {\n-                    A::Bs(_, Some(_)) => (),\n-                }\n-            }\n-            \"#,\n-            r#\"\n-            enum A {\n-                As,\n-                Bs(i32, Option<i32>)\n-            }\n-            fn main() {\n-                match <|>A::As {\n-                    A::Bs(_, Some(_)) => (),\n-                    A::As => (),\n-                    _ => (),\n+                    A::As,\n+                    A::Bs{x,y:Some(_)} => (),\n+                    A::Cs(_, Some(_)) => (),\n                 }\n             }\n             \"#,\n         );\n     }\n \n     #[test]\n-    fn partial_fill_record() {\n+    fn partial_fill_record_tuple() {\n         check_assist(\n             fill_match_arms,\n             r#\"\n             enum A {\n                 As,\n                 Bs{x:i32, y:Option<i32>},\n+                Cs(i32, Option<i32>),\n             }\n             fn main() {\n                 match A::As<|> {\n                     A::Bs{x,y:Some(_)} => (),\n+                    A::Cs(_, Some(_)) => (),\n                 }\n             }\n             \"#,\n             r#\"\n             enum A {\n                 As,\n                 Bs{x:i32, y:Option<i32>},\n+                Cs(i32, Option<i32>),\n             }\n             fn main() {\n                 match <|>A::As {\n                     A::Bs{x,y:Some(_)} => (),\n+                    A::Cs(_, Some(_)) => (),\n                     A::As => (),\n-                    _ => (),\n                 }\n             }\n             \"#,\n@@ -291,39 +217,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn partial_fill_or_pat2() {\n-        check_assist(\n-            fill_match_arms,\n-            r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs(Option<i32>),\n-            }\n-            fn main() {\n-                match A::As<|> {\n-                    A::Cs(Some(_)) | A::Bs => (),\n-                }\n-            }\n-            \"#,\n-            r#\"\n-            enum A {\n-                As,\n-                Bs,\n-                Cs(Option<i32>),\n-            }\n-            fn main() {\n-                match <|>A::As {\n-                    A::Cs(Some(_)) | A::Bs => (),\n-                    A::As => (),\n-                    _ => (),\n-                }\n-            }\n-            \"#,\n-        );\n-    }\n-\n     #[test]\n     fn partial_fill() {\n         check_assist(\n@@ -367,7 +260,6 @@ mod tests {\n                     A::Es(B::Xs) => (),\n                     A::As => (),\n                     A::Cs => (),\n-                    _ => (),\n                 }\n             }\n             \"#,"}]}