{"sha": "fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMzBkZDcwY2VmOGY5YTc1YzA0MmE2OWQ4ZWViZWQ2ZWM2M2Y5ZTI=", "commit": {"author": {"name": "Jeremy Sorensen", "email": "jeremy.a.sorensen@gmail.com", "date": "2017-08-28T15:43:35Z"}, "committer": {"name": "Jeremy Sorensen", "email": "jeremy.a.sorensen@gmail.com", "date": "2017-08-28T15:43:35Z"}, "message": "getting rid of all changes due to this PR thus far, starting from a clean slate", "tree": {"sha": "d31d1b6a7100d303fc8ddd89dc8b015abde400bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d31d1b6a7100d303fc8ddd89dc8b015abde400bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "html_url": "https://github.com/rust-lang/rust/commit/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/comments", "author": {"login": "JeremySorensen", "id": 8931818, "node_id": "MDQ6VXNlcjg5MzE4MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/8931818?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeremySorensen", "html_url": "https://github.com/JeremySorensen", "followers_url": "https://api.github.com/users/JeremySorensen/followers", "following_url": "https://api.github.com/users/JeremySorensen/following{/other_user}", "gists_url": "https://api.github.com/users/JeremySorensen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeremySorensen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeremySorensen/subscriptions", "organizations_url": "https://api.github.com/users/JeremySorensen/orgs", "repos_url": "https://api.github.com/users/JeremySorensen/repos", "events_url": "https://api.github.com/users/JeremySorensen/events{/privacy}", "received_events_url": "https://api.github.com/users/JeremySorensen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JeremySorensen", "id": 8931818, "node_id": "MDQ6VXNlcjg5MzE4MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/8931818?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeremySorensen", "html_url": "https://github.com/JeremySorensen", "followers_url": "https://api.github.com/users/JeremySorensen/followers", "following_url": "https://api.github.com/users/JeremySorensen/following{/other_user}", "gists_url": "https://api.github.com/users/JeremySorensen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeremySorensen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeremySorensen/subscriptions", "organizations_url": "https://api.github.com/users/JeremySorensen/orgs", "repos_url": "https://api.github.com/users/JeremySorensen/repos", "events_url": "https://api.github.com/users/JeremySorensen/events{/privacy}", "received_events_url": "https://api.github.com/users/JeremySorensen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdb7901ec9e5784942b62a682de2e2f1a2c58e79", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdb7901ec9e5784942b62a682de2e2f1a2c58e79", "html_url": "https://github.com/rust-lang/rust/commit/bdb7901ec9e5784942b62a682de2e2f1a2c58e79"}, {"sha": "5caca6fa0213cadca1584db43dd71fb5f82b41b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5caca6fa0213cadca1584db43dd71fb5f82b41b9", "html_url": "https://github.com/rust-lang/rust/commit/5caca6fa0213cadca1584db43dd71fb5f82b41b9"}], "stats": {"total": 19691, "additions": 11855, "deletions": 7836}, "files": [{"sha": "c424ca7ab009e147204c599a94cae2ba1b9da97e", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -415,4 +415,4 @@ are:\n [tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n [ro]: http://www.rustaceans.org/\n [rctd]: ./src/test/COMPILER_TESTS.md\n-[cheatsheet]: https://buildbot.rust-lang.org/homu/\n+[cheatsheet]: https://buildbot2.rust-lang.org/homu/"}, {"sha": "78a9f509bbcb4c79b37608963b241f748b8aa64b", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -135,7 +135,7 @@ Windows build triples are:\n     - `i686-pc-windows-msvc`\n     - `x86_64-pc-windows-msvc`\n \n-The build triple can be specified by either specifying `--build=ABI` when\n+The build triple can be specified by either specifying `--build=<triple>` when\n invoking `x.py` commands, or by copying the `config.toml` file (as described\n in Building From Source), and modifying the `build` option under the `[build]`\n section."}, {"sha": "c3a7367a2ee54d1795f46c78e32afcf06f87a8e5", "filename": "RELEASES.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -92,7 +92,7 @@ Stabilized APIs\n Cargo\n -----\n - [Cargo API token location moved from `~/.cargo/config` to\n-  `~/cargo/credentials`.][cargo/3978]\n+  `~/.cargo/credentials`.][cargo/3978]\n - [Cargo will now build `main.rs` binaries that are in sub-directories of\n   `src/bin`.][cargo/4214] ie. Having `src/bin/server/main.rs` and\n   `src/bin/client/main.rs` generates `target/debug/server` and `target/debug/client`\n@@ -172,7 +172,6 @@ Compatibility Notes\n [`slice::sort_unstable`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable\n [`ste::from_boxed_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_boxed_utf8_unchecked.html\n [`str::as_bytes_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes_mut\n-[`str::as_bytes_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes_mut\n [`str::from_utf8_mut`]: https://doc.rust-lang.org/std/str/fn.from_utf8_mut.html\n [`str::from_utf8_unchecked_mut`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked_mut.html\n [`str::get_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.get_mut\n@@ -898,6 +897,9 @@ Compatibility Notes\n * [Ctrl-Z returns from `Stdin.read()` when reading from the console on\n   Windows][38274]\n * [Clean up semantics of `self` in an import list][38313]\n+* Reimplemented lifetime elision. This change was almost entirely compatible\n+  with existing code, but it did close a number of small bugs and loopholes,\n+  as well as being more accepting in some other [cases][41105].\n \n [37057]: https://github.com/rust-lang/rust/pull/37057\n [37761]: https://github.com/rust-lang/rust/pull/37761\n@@ -932,6 +934,7 @@ Compatibility Notes\n [39048]: https://github.com/rust-lang/rust/pull/39048\n [39282]: https://github.com/rust-lang/rust/pull/39282\n [39379]: https://github.com/rust-lang/rust/pull/39379\n+[41105]: https://github.com/rust-lang/rust/issues/41105\n [`<*const T>::wrapping_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset\n [`<*mut T>::wrapping_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset\n [`Duration::checked_add`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.checked_add"}, {"sha": "f548d6694c80f88137e76a42b52c83ddfe27b8e2", "filename": "appveyor.yml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -16,7 +16,7 @@ environment:\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n     SCRIPT: python x.py test\n   - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc --target=i586-pc-windows-msvc\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc --target=i686-pc-windows-msvc\n     SCRIPT: python x.py test --host i686-pc-windows-msvc --target i686-pc-windows-msvc\n \n   # MSVC aux tests\n@@ -145,7 +145,8 @@ install:\n   # - set PATH=%PATH%;%CD% -- this already happens above for sccache\n \n   # Install InnoSetup to get `iscc` used to produce installers\n-  - appveyor-retry choco install -y InnoSetup\n+  - appveyor-retry appveyor DownloadFile https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-08-22-is.exe\n+  - 2017-08-22-is.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n   - set PATH=\"C:\\Program Files (x86)\\Inno Setup 5\";%PATH%\n \n   # Help debug some handle issues on AppVeyor"}, {"sha": "3f5101ebf342f59a8faf00e1b50011519a3a91a8", "filename": "config.toml.example", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -73,6 +73,10 @@\n # controlled by rustbuild's -j parameter.\n #link-jobs = 0\n \n+# When invoking `llvm-config` this configures whether the `--shared` argument is\n+# passed to prefer linking to shared libraries.\n+#link-shared = false\n+\n # =============================================================================\n # General build configuration options\n # =============================================================================\n@@ -166,6 +170,15 @@\n # to +10 on Unix platforms, and by using a \"low priority\" job object on Windows.\n #low-priority = false\n \n+# Arguments passed to the `./configure` script, used during distcheck. You\n+# probably won't fill this in but rather it's filled in by the `./configure`\n+# script.\n+#configure-args = []\n+\n+# Indicates that a local rebuild is ocurring instead of a full bootstrap,\n+# essentially skipping stage0 as the local compiler is recompiling itself again.\n+#local-rebuild = false\n+\n # =============================================================================\n # General install configuration options\n # =============================================================================\n@@ -195,6 +208,13 @@\n # =============================================================================\n [rust]\n \n+# Indicates that the build should be optimized for debugging Rust. Note that\n+# this is typically not what you want as it takes an incredibly large amount of\n+# time to have a debug-mode rustc compile any code (notably libstd). If this\n+# value is set to `true` it will affect a number of configuration options below\n+# as well, if unconfigured.\n+#debug = false\n+\n # Whether or not to optimize the compiler and standard library\n # Note: the slowness of the non optimized compiler compiling itself usually\n #       outweighs the time gains in not doing optimizations, therefore a\n@@ -249,6 +269,10 @@\n # desired in distributions, for example.\n #rpath = true\n \n+# Suppresses extraneous output from tests to ensure the output of the test\n+# harness is relatively clean.\n+#quiet-tests = false\n+\n # Flag indicating whether tests are compiled with optimizations (the -O flag) or\n # with debuginfo (the -g flag)\n #optimize-tests = true\n@@ -264,6 +288,9 @@\n # will default to true if channel = \"dev\", but will default to false otherwise.\n #ignore-git = true\n \n+# When creating source tarballs whether or not to create a source tarball.\n+#dist-src = false\n+\n # =============================================================================\n # Options for specific targets\n #\n@@ -295,12 +322,22 @@\n # build native code.\n #android-ndk = \"/path/to/ndk\"\n \n+# Force static or dynamic linkage of the standard library for this target. If\n+# this target is a host for rustc, this will also affect the linkage of the\n+# compiler itself. This is useful for building rustc on targets that normally\n+# only use static libraries. If unset, the target's default linkage is used.\n+#crt-static = false\n+\n # The root location of the MUSL installation directory. The library directory\n # will also need to contain libunwind.a for an unwinding implementation. Note\n # that this option only makes sense for MUSL targets that produce statically\n # linked binaries\n #musl-root = \"...\"\n \n+# Used in testing for configuring where the QEMU images are located, you\n+# probably don't want to use this.\n+#qemu-rootfs = \"...\"\n+\n # =============================================================================\n # Distribution options\n #"}, {"sha": "eeb8d081d34549f5ca2b19f703bbb4e547264e46", "filename": "configure", "status": "modified", "additions": 10, "deletions": 772, "changes": 782, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/configure", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1,779 +1,17 @@\n #!/bin/sh\n \n-# /bin/sh on Solaris is not a POSIX compatible shell, but /usr/bin/bash is.\n-if [ `uname -s` = 'SunOS' -a \"${POSIX_SHELL}\" != \"true\" ]; then\n-    POSIX_SHELL=\"true\"\n-    export POSIX_SHELL\n-    exec /usr/bin/env bash $0 \"$@\"\n-fi\n-unset POSIX_SHELL # clear it so if we invoke other scripts, they run as bash as well\n+script=\"$(dirname $0)\"/src/bootstrap/configure.py\n \n-msg() {\n-    echo \"configure: $*\"\n-}\n-\n-step_msg() {\n-    msg\n-    msg \"$1\"\n-    msg\n-}\n-\n-warn() {\n-    echo \"configure: WARNING: $1\"\n-}\n-\n-err() {\n-    echo \"configure: error: $1\"\n-    exit 1\n-}\n-\n-run() {\n-    msg \"$@\"\n-    \"$@\"\n-}\n-\n-need_ok() {\n-    if [ $? -ne 0 ]\n-    then\n-        err \"$1\"\n-    fi\n-}\n-\n-need_cmd() {\n-    if command -v $1 >/dev/null 2>&1\n-    then msg \"found program '$1'\"\n-    else err \"program '$1' is missing, please install it\"\n-    fi\n-}\n-\n-make_dir() {\n-    if [ ! -d $1 ]\n-    then\n-        run mkdir -p $1\n-    fi\n-}\n-\n-copy_if_changed() {\n-    if cmp -s $1 $2\n-    then\n-        msg \"leaving $2 unchanged\"\n-    else\n-        run cp -f $1 $2\n-        chmod u-w $2 # make copied artifact read-only\n-    fi\n-}\n-\n-move_if_changed() {\n-    if cmp -s $1 $2\n-    then\n-        msg \"leaving $2 unchanged\"\n-    else\n-        run mv -f $1 $2\n-        chmod u-w $2 # make moved artifact read-only\n-    fi\n-}\n-\n-putvar() {\n-    local T\n-    eval T=\\$$1\n-    eval TLEN=\\${#$1}\n-    if [ $TLEN -gt 35 ]\n-    then\n-        printf \"configure: %-20s := %.35s ...\\n\" $1 \"$T\"\n-    else\n-        printf \"configure: %-20s := %s %s\\n\" $1 \"$T\" \"$2\"\n-    fi\n-    printf \"%-20s := %s\\n\" $1 \"$T\" >>config.tmp\n-}\n-\n-putpathvar() {\n-    local T\n-    eval T=\\$$1\n-    eval TLEN=\\${#$1}\n-    if [ $TLEN -gt 35 ]\n-    then\n-        printf \"configure: %-20s := %.35s ...\\n\" $1 \"$T\"\n-    else\n-        printf \"configure: %-20s := %s %s\\n\" $1 \"$T\" \"$2\"\n-    fi\n-    if [ -z \"$T\" ]\n-    then\n-        printf \"%-20s := \\n\" $1 >>config.tmp\n-    else\n-        printf \"%-20s := \\\"%s\\\"\\n\" $1 \"$T\" >>config.tmp\n-    fi\n-}\n-\n-probe() {\n-    local V=$1\n+try() {\n+    cmd=$1\n     shift\n-    local P\n-    local T\n-    for P\n-    do\n-        T=$(command -v $P 2>&1)\n-        if [ $? -eq 0 ]\n-        then\n-            VER0=$($P --version 2>/dev/null \\\n-                |  grep -o '[vV]\\?[0-9][0-9.][a-z0-9.-]*' | head -1 )\n-            if [ $? -eq 0 -a \"x${VER0}\" != \"x\" ]\n-            then\n-              VER=\"($VER0)\"\n-            else\n-              VER=\"\"\n-            fi\n-            break\n-        else\n-            VER=\"\"\n-            T=\"\"\n-        fi\n-    done\n-    eval $V=\\$T\n-    putpathvar $V \"$VER\"\n-}\n-\n-probe_need() {\n-    probe $*\n-    local V=$1\n-    shift\n-    eval VV=\\$$V\n-    if [ -z \"$VV\" ]\n-    then\n-        err \"$V needed, but unable to find any of: $*\"\n-    fi\n-}\n-\n-validate_opt () {\n-    for arg in $CFG_CONFIGURE_ARGS\n-    do\n-        isArgValid=0\n-        for option in $BOOL_OPTIONS\n-        do\n-            if test --disable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-            if test --enable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        for option in $VAL_OPTIONS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$option=\"\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        if [ \"$arg\" = \"--help\" ]\n-        then\n-            echo\n-            echo \"No more help available for Configure options,\"\n-            echo \"check the Wiki or join our IRC channel\"\n-            break\n-        else\n-            if test $isArgValid -eq 0\n-            then\n-                err \"Option '$arg' is not recognized\"\n-            fi\n-        fi\n-    done\n-}\n-\n-# `valopt OPTION_NAME DEFAULT DOC` extracts a string-valued option\n-# from command line, using provided default value for the option if\n-# not present, and saves it to the generated config.mk.\n-#\n-# `valopt_nosave` is much the same, except that it does not save the\n-# result to config.mk (instead the script should use `putvar` itself\n-# later on to save it).  `valopt_core` is the core upon which the\n-# other two are built.\n-\n-valopt_core() {\n-    VAL_OPTIONS=\"$VAL_OPTIONS $2\"\n-\n-    local SAVE=$1\n-    local OP=$2\n-    local DEFAULT=$3\n-    shift\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    if [ $HELP -eq 0 ]\n-    then\n-        local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\\-' '\\_')\n-        local V=\"CFG_${UOP}\"\n-        local V_PROVIDED=\"${V}_PROVIDED\"\n-        eval $V=\"$DEFAULT\"\n-        for arg in $CFG_CONFIGURE_ARGS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$OP=\"\n-            then\n-                val=$(echo \"$arg\" | cut -f2 -d=)\n-                eval $V=$val\n-                eval $V_PROVIDED=1\n-            fi\n-        done\n-        if [ \"$SAVE\" = \"save\" ]\n-        then\n-            putvar $V\n-        fi\n-    else\n-        if [ -z \"$DEFAULT\" ]\n-        then\n-            DEFAULT=\"<none>\"\n-        fi\n-        OP=\"${OP}=[${DEFAULT}]\"\n-        printf \"    --%-30s %s\\n\" \"$OP\" \"$DOC\"\n-    fi\n-}\n-\n-valopt_nosave() {\n-    valopt_core nosave \"$@\"\n-}\n-\n-valopt() {\n-    valopt_core save \"$@\"\n-}\n-\n-# `opt OPTION_NAME DEFAULT DOC` extracts a boolean-valued option from\n-# command line, using the provided default value (0/1) for the option\n-# if not present, and saves it to the generated config.mk.\n-#\n-# `opt_nosave` is much the same, except that it does not save the\n-# result to config.mk (instead the script should use `putvar` itself\n-# later on to save it).  `opt_core` is the core upon which the other\n-# two are built.\n-\n-opt_core() {\n-    BOOL_OPTIONS=\"$BOOL_OPTIONS $2\"\n-\n-    local SAVE=$1\n-    local OP=$2\n-    local DEFAULT=$3\n-    shift\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    local FLAG=\"\"\n-\n-    if [ $DEFAULT -eq 0 ]\n-    then\n-        FLAG=\"enable\"\n-        DEFAULT_FLAG=\"disable\"\n-    else\n-        FLAG=\"disable\"\n-        DEFAULT_FLAG=\"enable\"\n-        DOC=\"don't $DOC\"\n-    fi\n-\n-    if [ $HELP -eq 0 ]\n-    then\n-        for arg in $CFG_CONFIGURE_ARGS\n-        do\n-            if [ \"$arg\" = \"--${FLAG}-${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                FLAG=$(echo $FLAG | tr 'a-z' 'A-Z')\n-                local V=\"CFG_${FLAG}_${OP}\"\n-                local V_PROVIDED=\"CFG_${FLAG}_${OP}_PROVIDED\"\n-                eval $V=1\n-                eval $V_PROVIDED=1\n-                if [ \"$SAVE\" = \"save\" ]\n-                then\n-                   putvar $V\n-                fi\n-            elif [ \"$arg\" = \"--${DEFAULT_FLAG}-${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                DEFAULT_FLAG=$(echo $DEFAULT_FLAG | tr 'a-z' 'A-Z')\n-                local V_PROVIDED=\"CFG_${DEFAULT_FLAG}_${OP}_PROVIDED\"\n-                eval $V_PROVIDED=1\n-            fi\n-        done\n-    else\n-        if [ -n \"$META\" ]\n-        then\n-            OP=\"$OP=<$META>\"\n-        fi\n-        printf \"    --%-30s %s\\n\" \"$FLAG-$OP\" \"$DOC\"\n-     fi\n-}\n-\n-opt_nosave() {\n-    opt_core nosave \"$@\"\n-}\n-\n-opt() {\n-    opt_core save \"$@\"\n-}\n-\n-envopt() {\n-    local NAME=$1\n-    local V=\"CFG_${NAME}\"\n-    eval VV=\\$$V\n-\n-    # If configure didn't set a value already, then check environment.\n-    #\n-    # (It is recommended that the configure script always check the\n-    # environment before setting any values to envopt variables; see\n-    # e.g.  how CFG_CC is handled, where it first checks `-z \"$CC\"`,\n-    # and issues msg if it ends up employing that provided value.)\n-    if [ -z \"$VV\" ]\n-    then\n-        eval $V=\\$$NAME\n-        eval VV=\\$$V\n-    fi\n-\n-    # If script or environment provided a value, save it.\n-    if [ -n \"$VV\" ]\n-    then\n-        putvar $V\n-    fi\n-}\n-\n-enable_if_not_disabled() {\n-    local OP=$1\n-    local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\\-' '\\_')\n-    local ENAB_V=\"CFG_ENABLE_$UOP\"\n-    local EXPLICITLY_DISABLED=\"CFG_DISABLE_${UOP}_PROVIDED\"\n-    eval VV=\\$$EXPLICITLY_DISABLED\n-    if [ -z \"$VV\" ]; then\n-        eval $ENAB_V=1\n+    T=$($cmd --version 2>/dev/null)\n+    if [ $? -eq 0 ]; then\n+        exec $cmd \"$script\" \"$@\"\n     fi\n }\n \n-to_gnu_triple() {\n-    case $1 in\n-        i686-pc-windows-gnu) echo i686-w64-mingw32 ;;\n-        x86_64-pc-windows-gnu) echo x86_64-w64-mingw32 ;;\n-        *) echo $1 ;;\n-    esac\n-}\n-\n-# Prints the absolute path of a directory to stdout\n-abs_path() {\n-    local _path=\"$1\"\n-    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n-    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n-    # for good measure.\n-    (unset CDPATH && cd \"$_path\" > /dev/null && pwd)\n-}\n-\n-HELP=0\n-for arg; do\n-    case \"$arg\" in\n-        --help) HELP=1;;\n-    esac\n-done\n-\n-msg \"looking for configure programs\"\n-need_cmd cmp\n-need_cmd mkdir\n-need_cmd printf\n-need_cmd cut\n-need_cmd head\n-need_cmd grep\n-need_cmd xargs\n-need_cmd cp\n-need_cmd find\n-need_cmd uname\n-need_cmd date\n-need_cmd tr\n-need_cmd sed\n-need_cmd file\n-need_cmd make\n-\n-CFG_SRC_DIR=\"$(abs_path $(dirname $0))/\"\n-CFG_SRC_DIR_RELATIVE=\"$(dirname $0)/\"\n-CFG_BUILD_DIR=\"$(pwd)/\"\n-CFG_SELF=\"$0\"\n-CFG_CONFIGURE_ARGS=\"$@\"\n-\n-\n-case \"${CFG_SRC_DIR}\" in\n-    *\\ * )\n-        err \"The path to the rust source directory contains spaces, which is not supported\"\n-        ;;\n-    *)\n-        ;;\n-esac\n-\n-\n-OPTIONS=\"\"\n-if [ \"$HELP\" -eq 1 ]\n-then\n-    echo\n-    echo \"Usage: $CFG_SELF [options]\"\n-    echo\n-    echo \"Options:\"\n-    echo\n-else\n-    msg \"recreating config.tmp\"\n-    echo '' >config.tmp\n-\n-    step_msg \"processing $CFG_SELF args\"\n-fi\n-\n-BOOL_OPTIONS=\"\"\n-VAL_OPTIONS=\"\"\n-\n-opt debug 0 \"debug mode; disables optimization unless \\`--enable-optimize\\` given\"\n-opt valgrind 0 \"run tests with valgrind (memcheck by default)\"\n-opt helgrind 0 \"run tests with helgrind instead of memcheck\"\n-opt valgrind-rpass 1 \"run rpass-valgrind tests with valgrind\"\n-opt docs     1 \"build standard library documentation\"\n-opt compiler-docs     0 \"build compiler documentation\"\n-opt optimize-tests 1 \"build tests with optimizations\"\n-opt debuginfo-tests 0 \"build tests with debugger metadata\"\n-opt quiet-tests 0 \"enable quieter output when running tests\"\n-opt libcpp 1 \"build llvm with libc++ instead of libstdc++ when using clang\"\n-opt llvm-assertions 0 \"build LLVM with assertions\"\n-opt debug-assertions 0 \"build with debugging assertions\"\n-opt fast-make 0 \"use .gitmodules as timestamp for submodule deps\"\n-opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n-opt sccache 0 \"invoke gcc/clang via sccache to reuse object files between builds\"\n-opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n-opt local-rebuild 0 \"assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version\"\n-opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n-opt llvm-link-shared 0 \"prefer shared linking to LLVM (llvm-config --link-shared)\"\n-opt rpath 1 \"build rpaths into rustc itself\"\n-opt stage0-landing-pads 1 \"enable landing pads during bootstrap with stage0\"\n-# This is used by the automation to produce single-target nightlies\n-opt dist-host-only 0 \"only install bins for the host architecture\"\n-opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n-opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n-opt codegen-tests 1 \"run the src/test/codegen tests\"\n-opt option-checking 1 \"complain about unrecognized options in this configure script\"\n-opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n-opt locked-deps 0 \"force Cargo.lock to be up to date\"\n-opt vendor 0 \"enable usage of vendored Rust crates\"\n-opt sanitizers 0 \"build the sanitizer runtimes (asan, lsan, msan, tsan)\"\n-opt dist-src 1 \"when building tarballs enables building a source tarball\"\n-opt cargo-openssl-static 0 \"static openssl in cargo\"\n-opt profiler 0 \"build the profiler runtime\"\n-\n-# Optimization and debugging options. These may be overridden by the release channel, etc.\n-opt_nosave optimize 1 \"build optimized rust code\"\n-opt_nosave optimize-cxx 1 \"build optimized C++ code\"\n-opt_nosave optimize-llvm 1 \"build optimized LLVM\"\n-opt_nosave llvm-assertions 0 \"build LLVM with assertions\"\n-opt_nosave debug-assertions 0 \"build with debugging assertions\"\n-opt_nosave llvm-release-debuginfo 0 \"build LLVM with debugger metadata\"\n-opt_nosave debuginfo 0 \"build with debugger metadata\"\n-opt_nosave debuginfo-lines 0 \"build with line number debugger metadata\"\n-opt_nosave debuginfo-only-std 0 \"build only libstd with debugging information\"\n-opt_nosave debug-jemalloc 0 \"build jemalloc with --enable-debug --enable-fill\"\n-\n-valopt localstatedir \"/var/lib\" \"local state directory\"\n-valopt sysconfdir \"/etc\" \"install system configuration files\"\n-\n-valopt datadir \"${CFG_PREFIX}/share\" \"install data\"\n-valopt infodir \"${CFG_PREFIX}/share/info\" \"install additional info\"\n-valopt llvm-root \"\" \"set LLVM root\"\n-valopt python \"\" \"set path to python\"\n-valopt jemalloc-root \"\" \"set directory where libjemalloc_pic.a is located\"\n-valopt build \"\" \"GNUs ./configure syntax LLVM build triple\"\n-valopt android-cross-path \"\" \"Android NDK standalone path (deprecated)\"\n-valopt i686-linux-android-ndk \"\" \"i686-linux-android NDK standalone path\"\n-valopt arm-linux-androideabi-ndk \"\" \"arm-linux-androideabi NDK standalone path\"\n-valopt armv7-linux-androideabi-ndk \"\" \"armv7-linux-androideabi NDK standalone path\"\n-valopt aarch64-linux-android-ndk \"\" \"aarch64-linux-android NDK standalone path\"\n-valopt x86_64-linux-android-ndk \"\" \"x86_64-linux-android NDK standalone path\"\n-valopt nacl-cross-path  \"\" \"NaCl SDK path (Pepper Canary is recommended). Must be absolute!\"\n-valopt musl-root \"/usr/local\" \"MUSL root installation directory (deprecated)\"\n-valopt musl-root-x86_64 \"\" \"x86_64-unknown-linux-musl install directory\"\n-valopt musl-root-i686 \"\" \"i686-unknown-linux-musl install directory\"\n-valopt musl-root-arm \"\" \"arm-unknown-linux-musleabi install directory\"\n-valopt musl-root-armhf \"\" \"arm-unknown-linux-musleabihf install directory\"\n-valopt musl-root-armv7 \"\" \"armv7-unknown-linux-musleabihf install directory\"\n-valopt extra-filename \"\" \"Additional data that is hashed and passed to the -C extra-filename flag\"\n-valopt qemu-armhf-rootfs \"\" \"rootfs in qemu testing, you probably don't want to use this\"\n-valopt qemu-aarch64-rootfs \"\" \"rootfs in qemu testing, you probably don't want to use this\"\n-valopt experimental-targets \"\" \"experimental LLVM targets to build\"\n-\n-if [ -e ${CFG_SRC_DIR}.git ]\n-then\n-    valopt release-channel \"dev\" \"the name of the release channel to build\"\n-else\n-    # If we have no git directory then we are probably a tarball distribution\n-    # and should default to stable channel - Issue 28322\n-    probe CFG_GIT          git\n-    msg \"git: no git directory. Changing default release channel to stable\"\n-    valopt release-channel \"stable\" \"the name of the release channel to build\"\n-fi\n-\n-# Used on systems where \"cc\" and \"ar\" are unavailable\n-valopt default-linker \"cc\" \"the default linker\"\n-valopt default-ar     \"ar\" \"the default ar\"\n-\n-# Many of these are saved below during the \"writing configuration\" step\n-# (others are conditionally saved).\n-opt_nosave manage-submodules 1 \"let the build manage the git submodules\"\n-opt_nosave clang 0 \"prefer clang to gcc for building the runtime\"\n-opt_nosave jemalloc 1 \"build liballoc with jemalloc\"\n-opt full-bootstrap 0 \"build three compilers instead of two\"\n-opt extended 0 \"build an extended rust tool set\"\n-\n-valopt_nosave prefix \"/usr/local\" \"set installation prefix\"\n-valopt_nosave local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n-valopt_nosave host \"${CFG_BUILD}\" \"GNUs ./configure syntax LLVM host triples\"\n-valopt_nosave target \"${CFG_HOST}\" \"GNUs ./configure syntax LLVM target triples\"\n-valopt_nosave mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n-valopt_nosave docdir \"${CFG_PREFIX}/share/doc/rust\" \"install documentation in PATH\"\n-valopt_nosave bindir \"${CFG_PREFIX}/bin\" \"install binaries\"\n-\n-# On Windows this determines root of the subtree for target libraries.\n-# Host runtime libs always go to 'bin'.\n-valopt libdir \"${CFG_PREFIX}/lib\" \"install libraries\"\n-\n-case \"$CFG_LIBDIR\" in\n-    \"$CFG_PREFIX\"/*) CAT_INC=2;;\n-    \"$CFG_PREFIX\"*)  CAT_INC=1;;\n-    *)\n-        err \"libdir must begin with the prefix. Use --prefix to set it accordingly.\";;\n-esac\n-\n-CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n-\n-if [ $HELP -eq 1 ]\n-then\n-    echo\n-    exit 0\n-fi\n-\n-# Validate Options\n-if [ -z \"$CFG_DISABLE_OPTION_CHECKING\" ]\n-then\n-    step_msg \"validating $CFG_SELF args\"\n-    validate_opt\n-fi\n-\n-# Validate the release channel, and configure options\n-case \"$CFG_RELEASE_CHANNEL\" in\n-    nightly )\n-\tmsg \"overriding settings for $CFG_RELEASE_CHANNEL\"\n-        enable_if_not_disabled llvm-assertions\n-        # FIXME(stage0) re-enable this on the next stage0 now that #35566 is\n-        # fixed\n-        case \"$CFG_BUILD\" in\n-          *-pc-windows-gnu)\n-            ;;\n-          *)\n-            enable_if_not_disabled debuginfo-lines\n-            enable_if_not_disabled debuginfo-only-std\n-            ;;\n-        esac\n-\n-\t;;\n-    beta | stable)\n-\tmsg \"overriding settings for $CFG_RELEASE_CHANNEL\"\n-        case \"$CFG_BUILD\" in\n-          *-pc-windows-gnu)\n-            ;;\n-          *)\n-            enable_if_not_disabled debuginfo-lines\n-            enable_if_not_disabled debuginfo-only-std\n-            ;;\n-        esac\n-\t;;\n-    dev)\n-\t;;\n-    *)\n-        err \"release channel must be 'dev', 'nightly', 'beta' or 'stable'\"\n-        ;;\n-esac\n-\n-# Adjust perf and debug options for debug mode\n-if [ -n \"$CFG_ENABLE_DEBUG\" ]; then\n-    msg \"debug mode enabled, setting performance options\"\n-    if [ -z \"$CFG_ENABLE_OPTIMIZE_PROVIDED\" ]; then\n-        msg \"optimization not explicitly enabled, disabling optimization\"\n-        CFG_DISABLE_OPTIMIZE=1\n-        CFG_DISABLE_OPTIMIZE_CXX=1\n-    fi\n-\n-    # Set following variables to 1 unless setting already provided\n-    enable_if_not_disabled debug-assertions\n-    enable_if_not_disabled debug-jemalloc\n-    enable_if_not_disabled debuginfo\n-    enable_if_not_disabled llvm-assertions\n-fi\n-\n-# OK, now write the debugging options\n-if [ -n \"$CFG_DISABLE_OPTIMIZE\" ]; then putvar CFG_DISABLE_OPTIMIZE; fi\n-if [ -n \"$CFG_DISABLE_OPTIMIZE_CXX\" ]; then putvar CFG_DISABLE_OPTIMIZE_CXX; fi\n-if [ -n \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]; then putvar CFG_DISABLE_OPTIMIZE_LLVM; fi\n-if [ -n \"$CFG_ENABLE_LLVM_ASSERTIONS\" ]; then putvar CFG_ENABLE_LLVM_ASSERTIONS; fi\n-if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTIONS; fi\n-if [ -n \"$CFG_ENABLE_LLVM_RELEASE_DEBUGINFO\" ]; then putvar CFG_ENABLE_LLVM_RELEASE_DEBUGINFO; fi\n-if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n-if [ -n \"$CFG_ENABLE_DEBUGINFO_LINES\" ]; then putvar CFG_ENABLE_DEBUGINFO_LINES; fi\n-if [ -n \"$CFG_ENABLE_DEBUGINFO_ONLY_STD\" ]; then putvar CFG_ENABLE_DEBUGINFO_ONLY_STD; fi\n-if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n-\n-step_msg \"looking for build programs\"\n-\n-probe_need CFG_CURL curl\n-if [ -z \"$CFG_PYTHON_PROVIDED\" ]; then\n-    probe_need CFG_PYTHON      python2.7 python2 python\n-fi\n-\n-python_version=$($CFG_PYTHON -V 2>&1)\n-if [ $(echo $python_version | grep -c '^Python 2\\.7') -ne 1 ]; then\n-    err \"Found $python_version, but Python 2.7 is required\"\n-fi\n-\n-# the valgrind rpass tests will fail if you don't have a valgrind, but they're\n-# only disabled if you opt out.\n-if [ -z \"$CFG_VALGRIND\" ]\n-then\n-    # If the user has explicitly asked for valgrind tests, then fail\n-    if [ -n \"$CFG_ENABLE_VALGRIND\" ] && [ -n \"$CFG_ENABLE_VALGRIND_PROVIDED\" ]\n-    then\n-        err \"No valgrind present, but valgrind tests explicitly requested\"\n-    else\n-        CFG_DISABLE_VALGRIND_RPASS=1\n-        putvar CFG_DISABLE_VALGRIND_RPASS\n-    fi\n-fi\n-\n-# Do some sanity checks if running on buildbot\n-# (these env vars are set by rust-buildbot)\n-if [ -n \"$RUST_DIST_SERVER\" -a -n \"$ALLOW_NONZERO_RLIMIT_CORE\" ]; then\n-   # Frequently the llvm submodule directory is broken by the build\n-   # being killed\n-   llvm_lock=\"${CFG_SRC_DIR}/.git/modules/src/llvm/index.lock\"\n-   if [ -e \"$llvm_lock\" ]; then\n-       step_msg \"removing $llvm_lock\"\n-       rm -f \"$llvm_lock\"\n-   fi\n-fi\n-\n-BIN_SUF=\n-if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ]\n-then\n-    BIN_SUF=.exe\n-fi\n-\n-# --enable-local-rebuild implies --enable-local-rust too\n-if [ -n \"$CFG_ENABLE_LOCAL_REBUILD\" ]\n-then\n-    if [ -z \"$CFG_ENABLE_LOCAL_RUST\" ]\n-    then\n-        CFG_ENABLE_LOCAL_RUST=1\n-        putvar CFG_ENABLE_LOCAL_RUST\n-    fi\n-fi\n-\n-if [ -n \"$CFG_ENABLE_LOCAL_RUST\" ]\n-then\n-    system_rustc=$(which rustc)\n-    if [ -f ${CFG_LOCAL_RUST_ROOT}/bin/rustc${BIN_SUF} ]\n-    then\n-        : # everything already configured\n-    elif [ -n \"$system_rustc\" ]\n-    then\n-        # we assume that rustc is in a /bin directory\n-        CFG_LOCAL_RUST_ROOT=${system_rustc%/bin/rustc}\n-    else\n-        err \"no local rust to use\"\n-    fi\n-\n-    CMD=\"${CFG_LOCAL_RUST_ROOT}/bin/rustc${BIN_SUF}\"\n-    LRV=`LD_LIBRARY_PATH=${CFG_LOCAL_RUST_ROOT}/lib $CMD --version`\n-    if [ $? -ne 0 ]\n-    then\n-        step_msg \"failure while running $CMD --version\"\n-        exit 1\n-    fi\n-    step_msg \"using rustc at: ${CFG_LOCAL_RUST_ROOT} with version: $LRV\"\n-    putvar CFG_LOCAL_RUST_ROOT\n-fi\n-\n-# Same with jemalloc.  save the setting here.\n-if [ -n \"$CFG_DISABLE_JEMALLOC\" ]\n-then\n-    putvar CFG_DISABLE_JEMALLOC\n-fi\n-\n-# All safeguards based on $CFG_ENABLE_CLANG should occur before this\n-# point in the script; after this point, script logic should inspect\n-# $CFG_USING_CLANG rather than $CFG_ENABLE_CLANG.\n-\n-# Set CFG_{CC,CXX,CPP,CFLAGS,CXXFLAGS,LDFLAGS}\n-envopt CC\n-envopt CXX\n-envopt CPP\n-envopt CFLAGS\n-envopt CXXFLAGS\n-envopt LDFLAGS\n-\n-# a little post-processing of various config values\n-CFG_PREFIX=${CFG_PREFIX%/}\n-CFG_MANDIR=${CFG_MANDIR%/}\n-CFG_DOCDIR=${CFG_DOCDIR%/}\n-CFG_BINDIR=${CFG_BINDIR%/}\n-CFG_HOST=\"$(echo $CFG_HOST | tr ',' ' ')\"\n-CFG_TARGET=\"$(echo $CFG_TARGET | tr ',' ' ')\"\n-\n-# copy build-triples to host-triples so that builds are a subset of hosts\n-V_TEMP=\"\"\n-for i in $CFG_BUILD $CFG_HOST;\n-do\n-   echo \"$V_TEMP\" | grep -qF $i || V_TEMP=\"$V_TEMP${V_TEMP:+ }$i\"\n-done\n-CFG_HOST=$V_TEMP\n-\n-# copy host-triples to target-triples so that hosts are a subset of targets\n-V_TEMP=\"\"\n-for i in $CFG_HOST $CFG_TARGET;\n-do\n-   echo \"$V_TEMP\" | grep -qF $i || V_TEMP=\"$V_TEMP${V_TEMP:+ }$i\"\n-done\n-CFG_TARGET=$V_TEMP\n-\n-step_msg \"writing configuration\"\n-\n-putvar CFG_SRC_DIR\n-putvar CFG_SRC_DIR_RELATIVE\n-putvar CFG_BUILD_DIR\n-putvar CFG_OSTYPE\n-putvar CFG_CPUTYPE\n-putvar CFG_CONFIGURE_ARGS\n-putvar CFG_PREFIX\n-putvar CFG_HOST\n-putvar CFG_TARGET\n-putvar CFG_LIBDIR_RELATIVE\n-putvar CFG_DISABLE_MANAGE_SUBMODULES\n-putvar CFG_AARCH64_LINUX_ANDROID_NDK\n-putvar CFG_ARM_LINUX_ANDROIDEABI_NDK\n-putvar CFG_ARMV7_LINUX_ANDROIDEABI_NDK\n-putvar CFG_I686_LINUX_ANDROID_NDK\n-putvar CFG_X86_64_LINUX_ANDROID_NDK\n-putvar CFG_NACL_CROSS_PATH\n-putvar CFG_MANDIR\n-putvar CFG_DOCDIR\n-putvar CFG_BINDIR\n-putvar CFG_USING_LIBCPP\n-\n-msg\n-copy_if_changed ${CFG_SRC_DIR}src/bootstrap/mk/Makefile.in ./Makefile\n-move_if_changed config.tmp config.mk\n-rm -f config.tmp\n-touch config.stamp\n-\n-if [ -z \"$CFG_ENABLE_DEBUG\" ]; then\n-    step_msg \"configured in release mode. for development consider --enable-debug\"\n-else\n-    step_msg \"complete\"\n-fi\n-\n-if [ \"$CFG_SRC_DIR\" = `pwd` ]; then\n-    X_PY=x.py\n-else\n-    X_PY=${CFG_SRC_DIR_RELATIVE}x.py\n-fi\n-\n-msg \"run \\`python ${X_PY} --help\\`\"\n-msg\n+try python2.7 \"$@\"\n+try python27 \"$@\"\n+try python2 \"$@\"\n+exec python $script \"$@\""}, {"sha": "123c884585c19f276c7acc2d31968900eb55f6e4", "filename": "src/Cargo.lock", "status": "modified", "additions": 136, "deletions": 103, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -94,7 +94,7 @@ dependencies = [\n  \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -142,10 +142,10 @@ dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -161,9 +161,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -176,7 +176,7 @@ dependencies = [\n [[package]]\n name = \"cargo\"\n version = \"0.22.0\"\n-source = \"git+https://github.com/rust-lang/cargo#88aa6423a164774d09abc78a24e74e8e665f651b\"\n+source = \"git+https://github.com/rust-lang/cargo#bcf3997b1fa177afc5b6c632a6fbbf6cc75df427\"\n replace = \"cargo 0.22.0\"\n \n [[package]]\n@@ -187,6 +187,7 @@ dependencies = [\n  \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargotest 0.1.0\",\n+ \"core-foundation 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crates-io 0.11.0\",\n  \"crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -210,19 +211,20 @@ dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_ignored 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -231,22 +233,16 @@ dependencies = [\n name = \"cargotest\"\n version = \"0.1.0\"\n dependencies = [\n- \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo 0.22.0\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -260,16 +256,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"clap\"\n-version = \"2.25.1\"\n+version = \"2.26.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"textwrap 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"textwrap 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vec_map 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"yaml-rust 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -323,14 +319,31 @@ dependencies = [\n  \"rand 0.0.0\",\n ]\n \n+[[package]]\n+name = \"core-foundation\"\n+version = \"0.4.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"core-foundation-sys 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"core-foundation-sys\"\n+version = \"0.4.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"crates-io\"\n version = \"0.11.0\"\n dependencies = [\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.11.0-rc.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -348,8 +361,8 @@ dependencies = [\n  \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"socket2 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"socket2 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -361,7 +374,7 @@ dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -397,8 +410,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -472,6 +485,10 @@ version = \"0.1.0\"\n name = \"find_all_refs_no_cfg_test\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"find_impls\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"flate2\"\n version = \"0.2.19\"\n@@ -529,7 +546,7 @@ dependencies = [\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -588,7 +605,7 @@ dependencies = [\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -642,11 +659,23 @@ dependencies = [\n  \"walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"infer_bin\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"infer_custom_bin\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"infer_lib\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"installer\"\n version = \"0.0.0\"\n dependencies = [\n- \"clap 2.25.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -673,13 +702,13 @@ dependencies = [\n \n [[package]]\n name = \"jsonrpc-core\"\n-version = \"7.0.1\"\n+version = \"7.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"futures 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -698,8 +727,8 @@ version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -733,7 +762,7 @@ dependencies = [\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -745,7 +774,7 @@ dependencies = [\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -771,7 +800,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"lzma-sys\"\n-version = \"0.1.7\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -789,16 +818,16 @@ name = \"mdbook\"\n version = \"0.0.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.25.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"handlebars 0.26.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -832,7 +861,7 @@ version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"net2 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"net2 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -843,7 +872,7 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"net2\"\n-version = \"0.2.30\"\n+version = \"0.2.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -859,7 +888,7 @@ version = \"0.1.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"num-bigint 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-complex 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-complex 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-integer 0.1.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-iter 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-rational 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -879,7 +908,7 @@ dependencies = [\n \n [[package]]\n name = \"num-complex\"\n-version = \"0.1.39\"\n+version = \"0.1.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -927,21 +956,25 @@ dependencies = [\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"omit_init_build\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"open\"\n version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"openssl\"\n-version = \"0.9.15\"\n+version = \"0.9.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -951,12 +984,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.15\"\n+version = \"0.9.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1051,14 +1085,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"racer\"\n-version = \"2.0.9\"\n+version = \"2.0.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.25.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_syntax 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1140,20 +1172,20 @@ version = \"0.1.0\"\n dependencies = [\n  \"cargo 0.22.0 (git+https://github.com/rust-lang/cargo)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"jsonrpc-core 7.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jsonrpc-core 7.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"racer 2.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-analysis 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-nightly 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-nightly 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1177,8 +1209,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1187,24 +1219,24 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-vfs\"\n version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"racer 2.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.25.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mdbook 0.0.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1231,7 +1263,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.4\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1295,7 +1327,6 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1432,7 +1463,6 @@ dependencies = [\n  \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -1452,6 +1482,7 @@ dependencies = [\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -1543,7 +1574,7 @@ dependencies = [\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n@@ -1572,6 +1603,7 @@ dependencies = [\n name = \"rustc_tsan\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1615,7 +1647,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1625,13 +1657,13 @@ dependencies = [\n  \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1660,7 +1692,7 @@ version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1670,12 +1702,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.10\"\n+version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.10\"\n+version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1697,7 +1729,7 @@ name = \"serde_ignored\"\n version = \"0.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1708,7 +1740,7 @@ dependencies = [\n  \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1722,7 +1754,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"socket2\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1826,7 +1858,6 @@ name = \"syntax_ext\"\n version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros 0.0.0\",\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1936,7 +1967,7 @@ dependencies = [\n \n [[package]]\n name = \"textwrap\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1983,10 +2014,10 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.4.2\"\n+version = \"0.4.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2009,7 +2040,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.1.0\"\n+version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -2057,7 +2088,7 @@ name = \"url_serde\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2146,7 +2177,7 @@ name = \"xz2\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lzma-sys 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lzma-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2169,8 +2200,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n \"checksum cargo 0.22.0 (git+https://github.com/rust-lang/cargo)\" = \"<none>\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n-\"checksum clap 2.25.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7f1aabf260a8f3fefa8871f16b531038c98dd9eab1cfa2c575e78c459abfa3a0\"\n+\"checksum clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2267a8fdd4dce6956ba6649e130f62fb279026e5e84b92aa939ac8f85ce3f9f0\"\n \"checksum cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8ebbb35d3dc9cd09497168f33de1acb79b265d350ab0ac34133b98f8509af1f\"\n+\"checksum core-foundation 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5909502e547762013619f4c4e01cc7393c20fe2d52d7fa471c1210adb2320dc7\"\n+\"checksum core-foundation-sys 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc9fb3d6cb663e6fd7cf1c63f9b144ee2b1e4a78595a0451dd34bff85b9a3387\"\n \"checksum crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c5ea215664ca264da8a9d9c3be80d2eaf30923c259d03e870388eb927508f97\"\n \"checksum curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7034c534a1d7d22f7971d6088aa9d281d219ef724026c3428092500f41ae9c2c\"\n \"checksum curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d5481162dc4f424d088581db2f979fa7d4c238fe9794595de61d8d7522e277de\"\n@@ -2204,7 +2237,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3fcaf2365eb14b28ec7603c98c06cc531f19de9eb283d89a3dff8417c8c99f5\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n \"checksum jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"443ae8bc0af6c106e6e8b77e04684faecc1a5ce94e058f4c2b0a037b0ea1b133\"\n-\"checksum jsonrpc-core 7.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"da622868a84d3f4fd897f6408ba6714aabf663302802358564b384157c1a5bfa\"\n+\"checksum jsonrpc-core 7.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"903e5eee845f3d83c1436d12848d97b1247cf850ff06a8e1db2f1ce3543af2cf\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum languageserver-types 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d52e477b23bf52cd3ca0f9fc6c5d14be954eec97e3b9cdfbd962d911bd533caf\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n@@ -2213,26 +2246,26 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0db4ec23611747ef772db1c4d650f8bd762f07b461727ec998f953c614024b75\"\n \"checksum libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fdd64ef8ee652185674455c1d450b83cbc8ad895625d543b5324d923f82e4d8\"\n \"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n-\"checksum lzma-sys 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"013fa6506eb7d26040c46dab9ecb7ccb4e2896b5bf24a9d65932501ea9f67af8\"\n+\"checksum lzma-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"66b2e318eb97ab84f05725471f90c52a09c964053a5899a13fd0165acc26d00b\"\n \"checksum matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"100aabe6b8ff4e4a7e32c1c13523379802df0772b82466207ac25b013f193376\"\n \"checksum mdbook 0.0.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"22911d86cde6f80fa9f0fb2a68bbbde85d97af4fe0ce267141c83a4187d28700\"\n \"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n \"checksum miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28eaee17666671fa872e567547e8428e83308ebe5808cdf6a0e28397dbe2c726\"\n \"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n-\"checksum net2 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94101fd932816f97eb9a5116f6c1a11511a1fed7db21c5ccd823b2dc11abf566\"\n+\"checksum net2 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a80f842784ef6c9a958b68b7516bc7e35883c614004dd94959a4dca1b716c09\"\n \"checksum num 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a311b77ebdc5dd4cf6449d81e4135d9f0e3b153839ac90e648a8ef538f923525\"\n \"checksum num-bigint 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8fd0f8dbb4c0960998958a796281d88c16fbe68d87b1baa6f31e2979e81fd0bd\"\n-\"checksum num-complex 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb24db7f1904e67a5dfe5f7f62b82f5c963e0f777b23f98cde9c5094fc4fa179\"\n+\"checksum num-complex 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"503e668405c5492d67cf662a81e05be40efe2e6bcf10f7794a07bd9865e704e6\"\n \"checksum num-integer 0.1.35 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d1452e8b06e448a07f0e6ebb0bb1d92b8890eea63288c0b627331d53514d0fba\"\n \"checksum num-iter 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7485fcc84f85b4ecd0ea527b14189281cf27d60e583ae65ebc9c088b13dffe01\"\n \"checksum num-rational 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"288629c76fac4b33556f4b7ab57ba21ae202da65ba8b77466e6d598e31990790\"\n \"checksum num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99843c856d68d8b4313b03a17e33c4bb42ae8f6610ea81b28abe076ac721b9b0\"\n \"checksum num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aec53c34f2d0247c5ca5d32cca1478762f301740468ee9ee6dcb7a0dd7a0c584\"\n \"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n-\"checksum openssl 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f776f1d8af832fd2c637ee182c801e8f7ea8895718a2be9914cca001f6e2c40a\"\n+\"checksum openssl 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"085aaedcc89a2fac1eb2bc19cd66f29d4ea99fec60f82a5f3a88a6be7dbd90b5\"\n \"checksum openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d98df0270d404ccd3c050a41d579c52d1db15375168bb3471e04ec0f5f378daf\"\n-\"checksum openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad95f8160d1c150c4f44d4c4959732e048ac046c37f597fe362f8bf57561ffb4\"\n+\"checksum openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e3a9845a4c9fdb321931868aae5549e96bb7b979bf9af7de03603d74691b5f3\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum percent-encoding 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"de154f638187706bde41d9b4738748933d64e6b37bdbffc0b47a97d16a6ae356\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n@@ -2242,7 +2275,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c36987d4978eb1be2e422b1e0423a557923a5c3e7e6f31d5699e9aafaefa469\"\n \"checksum quote 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c5cf478fe1006dbcc72567121d23dbdae5f1632386068c5c86ff4f645628504\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n-\"checksum racer 2.0.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9079a128fdb6f0c8850010e1478b215d4c00134654bf995bfda41824951ce9bd\"\n+\"checksum racer 2.0.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f120c7510ef7aff254aeb06067fb6fac573ec96a1660e194787cf9dced412bf0\"\n \"checksum rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"022e0636ec2519ddae48154b028864bdce4eaf7d35226ab8e65c611be97b189d\"\n \"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n@@ -2252,21 +2285,21 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11d339f1888e33e74d8032de0f83c40b2bdaaaf04a8cfc03b32186c3481fb534\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffd34691a510938bb67fe0444fb363103c73ffb31c121d1e16bc92d8945ea8ff\"\n-\"checksum rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3058a43ada2c2d0b92b3ae38007a2d0fa5e9db971be260e0171408a4ff471c95\"\n+\"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum rustfmt-nightly 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa1ffc66e1e1786355f22e8a958a57bd67fbf9564f522f87f31de9586715f8f6\"\n+\"checksum rustfmt-nightly 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6eea0d0590ae793fc4d281df56e01dc7531575c8ed9a72fadf5fdc7305a0d32f\"\n \"checksum same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d931a44fdaa43b8637009e7632a02adc4f2b2e0733c08caa4cf00e8da4a117a7\"\n \"checksum scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f417c22df063e9450888a7561788e9bd46d3bb3c1466435b4eccb903807f147d\"\n \"checksum scopeguard 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"59a076157c1e2dc561d8de585151ee6965d910dd4dcb5dabb7ae3e83981a6c57\"\n \"checksum semver 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fdd61b85a0fa777f7fb7c454b9189b2941b110d1385ce84d7f76efdf1606a85\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\"checksum serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"433d7d9f8530d5a939ad5e0e72a6243d2e42a24804f70bf592c679363dcacb2f\"\n-\"checksum serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7b707cf0d4cab852084f573058def08879bb467fda89d99052485e7d00edd624\"\n+\"checksum serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7726f29ddf9731b17ff113c461e362c381d9d69433f79de4f3dd572488823e9\"\n+\"checksum serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf823e706be268e73e7747b147aa31c8f633ab4ba31f115efb57e5047c3a76dd\"\n \"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n \"checksum serde_ignored 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c10e798e4405d7dcec3658989e35ee6706f730a9ed7c1184d5ebd84317e82f46\"\n \"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n \"checksum shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd5cc96481d54583947bfe88bf30c23d53f883c6cd0145368b69989d97b84ef8\"\n-\"checksum socket2 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"12cdbddbaa27bf94cc194b8e37f5811db6fe83cea96cf99cf1f8e92b65a41371\"\n+\"checksum socket2 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4daf80fcf54186fac4fe049e0b39d36a5cfde69a11a06413e61e77f553cccf9a\"\n \"checksum stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15132e0e364248108c5e2c02e3ab539be8d6f5d52a01ca9bbf27ed657316f02b\"\n \"checksum strings 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"da75d8bf2c4d210d63dd09581a041b036001f9f6e03d9b151dbff810fb7ba26a\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n@@ -2281,16 +2314,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1\"\n \"checksum term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2b6b55df3198cc93372e85dd2ed817f0e38ce8cc0f22eb32391bfad9c4bf209\"\n \"checksum termcolor 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a5193a56b8d82014662c4b933dea6bec851daf018a2b01722e007daaf5f9dca\"\n-\"checksum textwrap 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f86300c3e7416ee233abd7cda890c492007a3980f941f79185c753a701257167\"\n+\"checksum textwrap 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f728584ea33b0ad19318e20557cb0a39097751dbb07171419673502f848c7af6\"\n \"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n \"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n \"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\"\n \"checksum toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"736b60249cb25337bc196faa43ee12c705e426f3d55c214d73a4e7be06f92cb4\"\n-\"checksum toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0601da6c97135c8d330c7a13a013ca6cd4143221b01de2f8d4edc50a9e551c7\"\n+\"checksum toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7540f4ffc193e0d3c94121edb19b055670d369f77d5804db11ae053a45b6e7e\"\n \"checksum typed-arena 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5934776c3ac1bea4a9d56620d6bf2d483b20d394e49581db40f187e1118ff667\"\n \"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5\"\n \"checksum unicode-normalization 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51ccda9ef9efa3f7ef5d91e8f9b83bbe6955f9bf86aec89d5cce2c874625920f\"\n-\"checksum unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18127285758f0e2c6cf325bb3f3d138a12fee27de4f23e146cd6a179f26c2cf3\"\n+\"checksum unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a8083c594e02b8ae1654ae26f0ade5158b119bd88ad0e8227a5d8fcd72407946\"\n \"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f\"\n \"checksum unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36dff09cafb4ec7c8cf0023eb0b686cb6ce65499116a12201c9e11840ca01beb\"\n \"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\""}, {"sha": "ffec3eb075500fb89cf19177f7fda1d6958f1b1a", "filename": "src/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -32,6 +32,11 @@ members = [\n   \"tools/rls/test_data/multiple_bins\",\n   \"tools/rls/test_data/bin_lib\",\n   \"tools/rls/test_data/reformat_with_range\",\n+  \"tools/rls/test_data/find_impls\",\n+  \"tools/rls/test_data/infer_bin\",\n+  \"tools/rls/test_data/infer_custom_bin\",\n+  \"tools/rls/test_data/infer_lib\",\n+  \"tools/rls/test_data/omit_init_build\",\n ]\n \n # Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit"}, {"sha": "e543b8c070bcc8cca9c783b27a1dd2c3ad94a7c6", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -73,16 +73,18 @@ The script accepts commands, flags, and arguments to determine what to do:\n \n ## Configuring rustbuild\n \n-There are currently two primary methods for configuring the rustbuild build\n-system. First, the `./configure` options serialized in `config.mk` will be\n-parsed and read. That is, if any `./configure` options are passed, they'll be\n-handled naturally.\n+There are currently two methods for configuring the rustbuild build system.\n+\n+First, rustbuild offers a TOML-based configuration system with a `config.toml`\n+file. An example of this configuration can be found at `config.toml.example`,\n+and the configuration file can also be passed as `--config path/to/config.toml`\n+if the build system is being invoked manually (via the python script).\n \n-Next, rustbuild offers a TOML-based configuration system with a `config.toml`\n-file in the same location as `config.mk`. An example of this configuration can\n-be found at `config.toml.example`, and the configuration file\n-can also be passed as `--config path/to/config.toml` if the build system is\n-being invoked manually (via the python script).\n+Next, the `./configure` options serialized in `config.mk` will be\n+parsed and read. That is, if any `./configure` options are passed, they'll be\n+handled naturally. `./configure` should almost never be used for local\n+installations, and is primarily useful for CI. Prefer to customize behavior\n+using `config.toml`.\n \n Finally, rustbuild makes use of the [gcc-rs crate] which has [its own\n method][env-vars] of configuring C compilers and C flags via environment\n@@ -310,17 +312,18 @@ After that, each module in rustbuild should have enough documentation to keep\n you up and running. Some general areas that you may be interested in modifying\n are:\n \n-* Adding a new build tool? Take a look at `bootstrap/step.rs` for examples of\n+* Adding a new build tool? Take a look at `bootstrap/tool.rs` for examples of\n   other tools.\n * Adding a new compiler crate? Look no further! Adding crates can be done by\n   adding a new directory with `Cargo.toml` followed by configuring all\n   `Cargo.toml` files accordingly.\n-* Adding a new dependency from crates.io? We're still working on that, so hold\n-  off on that for now.\n-* Adding a new configuration option? Take a look at `bootstrap/config.rs` or\n-  perhaps `bootstrap/flags.rs` and then modify the build elsewhere to read that\n-  option.\n+* Adding a new dependency from crates.io? This should just work inside the\n+  compiler artifacts stage (everything other than libtest and libstd).\n+* Adding a new configuration option? You'll want to modify `bootstrap/flags.rs`\n+  for command line flags and then `bootstrap/config.rs` to copy the flags to the\n+  `Config` struct.\n * Adding a sanity check? Take a look at `bootstrap/sanity.rs`.\n \n-If you have any questions feel free to reach out on `#rust-internals` on IRC or\n-open an issue in the bug tracker!\n+If you have any questions feel free to reach out on `#rust-infra` on IRC or ask on\n+internals.rust-lang.org. When you encounter bugs, please file issues on the\n+rust-lang/rust issue tracker."}, {"sha": "0baca9e58f4fe2e753b0f7907647a1cdf91ab968", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -237,9 +237,13 @@ fn main() {\n             }\n         }\n \n-        if target.contains(\"pc-windows-msvc\") {\n-            cmd.arg(\"-Z\").arg(\"unstable-options\");\n-            cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n+        if let Ok(s) = env::var(\"RUSTC_CRT_STATIC\") {\n+            if s == \"true\" {\n+                cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n+            }\n+            if s == \"false\" {\n+                cmd.arg(\"-C\").arg(\"target-feature=-crt-static\");\n+            }\n         }\n \n         // Force all crates compiled by this compiler to (a) be unstable and (b)"}, {"sha": "4c1bd7bdca9e085cf3157b4bbb6e7674036de9a7", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 149, "deletions": 187, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -167,6 +167,141 @@ def format_build_time(duration):\n     return str(datetime.timedelta(seconds=int(duration)))\n \n \n+def default_build_triple():\n+    \"\"\"Build triple as in LLVM\"\"\"\n+    default_encoding = sys.getdefaultencoding()\n+    try:\n+        ostype = subprocess.check_output(\n+            ['uname', '-s']).strip().decode(default_encoding)\n+        cputype = subprocess.check_output(\n+            ['uname', '-m']).strip().decode(default_encoding)\n+    except (subprocess.CalledProcessError, OSError):\n+        if sys.platform == 'win32':\n+            return 'x86_64-pc-windows-msvc'\n+        err = \"uname not found\"\n+        sys.exit(err)\n+\n+    # The goal here is to come up with the same triple as LLVM would,\n+    # at least for the subset of platforms we're willing to target.\n+    ostype_mapper = {\n+        'Bitrig': 'unknown-bitrig',\n+        'Darwin': 'apple-darwin',\n+        'DragonFly': 'unknown-dragonfly',\n+        'FreeBSD': 'unknown-freebsd',\n+        'Haiku': 'unknown-haiku',\n+        'NetBSD': 'unknown-netbsd',\n+        'OpenBSD': 'unknown-openbsd'\n+    }\n+\n+    # Consider the direct transformation first and then the special cases\n+    if ostype in ostype_mapper:\n+        ostype = ostype_mapper[ostype]\n+    elif ostype == 'Linux':\n+        os_from_sp = subprocess.check_output(\n+            ['uname', '-o']).strip().decode(default_encoding)\n+        if os_from_sp == 'Android':\n+            ostype = 'linux-android'\n+        else:\n+            ostype = 'unknown-linux-gnu'\n+    elif ostype == 'SunOS':\n+        ostype = 'sun-solaris'\n+        # On Solaris, uname -m will return a machine classification instead\n+        # of a cpu type, so uname -p is recommended instead.  However, the\n+        # output from that option is too generic for our purposes (it will\n+        # always emit 'i386' on x86/amd64 systems).  As such, isainfo -k\n+        # must be used instead.\n+        try:\n+            cputype = subprocess.check_output(\n+                ['isainfo', '-k']).strip().decode(default_encoding)\n+        except (subprocess.CalledProcessError, OSError):\n+            err = \"isainfo not found\"\n+            sys.exit(err)\n+    elif ostype.startswith('MINGW'):\n+        # msys' `uname` does not print gcc configuration, but prints msys\n+        # configuration. so we cannot believe `uname -m`:\n+        # msys1 is always i686 and msys2 is always x86_64.\n+        # instead, msys defines $MSYSTEM which is MINGW32 on i686 and\n+        # MINGW64 on x86_64.\n+        ostype = 'pc-windows-gnu'\n+        cputype = 'i686'\n+        if os.environ.get('MSYSTEM') == 'MINGW64':\n+            cputype = 'x86_64'\n+    elif ostype.startswith('MSYS'):\n+        ostype = 'pc-windows-gnu'\n+    elif ostype.startswith('CYGWIN_NT'):\n+        cputype = 'i686'\n+        if ostype.endswith('WOW64'):\n+            cputype = 'x86_64'\n+        ostype = 'pc-windows-gnu'\n+    else:\n+        err = \"unknown OS type: {}\".format(ostype)\n+        sys.exit(err)\n+\n+    cputype_mapper = {\n+        'BePC': 'i686',\n+        'aarch64': 'aarch64',\n+        'amd64': 'x86_64',\n+        'arm64': 'aarch64',\n+        'i386': 'i686',\n+        'i486': 'i686',\n+        'i686': 'i686',\n+        'i786': 'i686',\n+        'powerpc': 'powerpc',\n+        'powerpc64': 'powerpc64',\n+        'powerpc64le': 'powerpc64le',\n+        'ppc': 'powerpc',\n+        'ppc64': 'powerpc64',\n+        'ppc64le': 'powerpc64le',\n+        's390x': 's390x',\n+        'x64': 'x86_64',\n+        'x86': 'i686',\n+        'x86-64': 'x86_64',\n+        'x86_64': 'x86_64'\n+    }\n+\n+    # Consider the direct transformation first and then the special cases\n+    if cputype in cputype_mapper:\n+        cputype = cputype_mapper[cputype]\n+    elif cputype in {'xscale', 'arm'}:\n+        cputype = 'arm'\n+        if ostype == 'linux-android':\n+            ostype = 'linux-androideabi'\n+    elif cputype == 'armv6l':\n+        cputype = 'arm'\n+        if ostype == 'linux-android':\n+            ostype = 'linux-androideabi'\n+        else:\n+            ostype += 'eabihf'\n+    elif cputype in {'armv7l', 'armv8l'}:\n+        cputype = 'armv7'\n+        if ostype == 'linux-android':\n+            ostype = 'linux-androideabi'\n+        else:\n+            ostype += 'eabihf'\n+    elif cputype == 'mips':\n+        if sys.byteorder == 'big':\n+            cputype = 'mips'\n+        elif sys.byteorder == 'little':\n+            cputype = 'mipsel'\n+        else:\n+            raise ValueError(\"unknown byteorder: {}\".format(sys.byteorder))\n+    elif cputype == 'mips64':\n+        if sys.byteorder == 'big':\n+            cputype = 'mips64'\n+        elif sys.byteorder == 'little':\n+            cputype = 'mips64el'\n+        else:\n+            raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n+        # only the n64 ABI is supported, indicate it\n+        ostype += 'abi64'\n+    elif cputype == 'sparcv9':\n+        pass\n+    else:\n+        err = \"unknown cpu type: {}\".format(cputype)\n+        sys.exit(err)\n+\n+    return \"{}-{}\".format(cputype, ostype)\n+\n class RustBuild(object):\n     \"\"\"Provide all the methods required to build Rust\"\"\"\n     def __init__(self):\n@@ -177,7 +312,6 @@ def __init__(self):\n         self.build = ''\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n         self.clean = False\n-        self.config_mk = ''\n         self.config_toml = ''\n         self.printed = False\n         self.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n@@ -374,26 +508,6 @@ def get_toml(self, key):\n                 return self.get_string(value) or value.strip()\n         return None\n \n-    def get_mk(self, key):\n-        \"\"\"Returns the value of the given key in config.mk, otherwise returns None\n-\n-        >>> rb = RustBuild()\n-        >>> rb.config_mk = 'key := value\\\\n'\n-        >>> rb.get_mk('key')\n-        'value'\n-\n-        If the key does not exists, the result is None:\n-\n-        >>> rb.get_mk('does_not_exists') == None\n-        True\n-        \"\"\"\n-        for line in iter(self.config_mk.splitlines()):\n-            if line.startswith(key + ' '):\n-                var = line[line.find(':=') + 2:].strip()\n-                if var != '':\n-                    return var\n-        return None\n-\n     def cargo(self):\n         \"\"\"Return config path for cargo\"\"\"\n         return self.program_config('cargo')\n@@ -407,15 +521,13 @@ def program_config(self, program):\n \n         >>> rb = RustBuild()\n         >>> rb.config_toml = 'rustc = \"rustc\"\\\\n'\n-        >>> rb.config_mk = 'CFG_LOCAL_RUST_ROOT := /tmp/rust\\\\n'\n         >>> rb.program_config('rustc')\n         'rustc'\n         >>> cargo_path = rb.program_config('cargo')\n         >>> cargo_path.rstrip(\".exe\") == os.path.join(\"/tmp/rust\",\n         ... \"bin\", \"cargo\")\n         True\n         >>> rb.config_toml = ''\n-        >>> rb.config_mk = ''\n         >>> cargo_path = rb.program_config('cargo')\n         >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(),\n         ... \"bin\", \"cargo\")\n@@ -424,10 +536,6 @@ def program_config(self, program):\n         config = self.get_toml(program)\n         if config:\n             return config\n-        config = self.get_mk('CFG_LOCAL_RUST_ROOT')\n-        if config:\n-            return os.path.join(config, \"bin\", \"{}{}\".format(\n-                program, self.exe_suffix()))\n         return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n             program, self.exe_suffix()))\n \n@@ -439,10 +547,14 @@ def get_string(line):\n         'devel'\n         \"\"\"\n         start = line.find('\"')\n-        if start == -1:\n-            return None\n-        end = start + 1 + line[start + 1:].find('\"')\n-        return line[start + 1:end]\n+        if start != -1:\n+            end = start + 1 + line[start + 1:].find('\"')\n+            return line[start + 1:end]\n+        start = line.find('\\'')\n+        if start != -1:\n+            end = start + 1 + line[start + 1:].find('\\'')\n+            return line[start + 1:end]\n+        return None\n \n     @staticmethod\n     def exe_suffix():\n@@ -521,154 +633,12 @@ def build_triple(self):\n         config = self.get_toml('build')\n         if config:\n             return config\n-        config = self.get_mk('CFG_BUILD')\n-        if config:\n-            return config\n-        try:\n-            ostype = subprocess.check_output(\n-                ['uname', '-s']).strip().decode(default_encoding)\n-            cputype = subprocess.check_output(\n-                ['uname', '-m']).strip().decode(default_encoding)\n-        except (subprocess.CalledProcessError, OSError):\n-            if sys.platform == 'win32':\n-                return 'x86_64-pc-windows-msvc'\n-            err = \"uname not found\"\n-            if self.verbose:\n-                raise Exception(err)\n-            sys.exit(err)\n-\n-        # The goal here is to come up with the same triple as LLVM would,\n-        # at least for the subset of platforms we're willing to target.\n-        ostype_mapper = {\n-            'Bitrig': 'unknown-bitrig',\n-            'Darwin': 'apple-darwin',\n-            'DragonFly': 'unknown-dragonfly',\n-            'FreeBSD': 'unknown-freebsd',\n-            'Haiku': 'unknown-haiku',\n-            'NetBSD': 'unknown-netbsd',\n-            'OpenBSD': 'unknown-openbsd'\n-        }\n-\n-        # Consider the direct transformation first and then the special cases\n-        if ostype in ostype_mapper:\n-            ostype = ostype_mapper[ostype]\n-        elif ostype == 'Linux':\n-            os_from_sp = subprocess.check_output(\n-                ['uname', '-o']).strip().decode(default_encoding)\n-            if os_from_sp == 'Android':\n-                ostype = 'linux-android'\n-            else:\n-                ostype = 'unknown-linux-gnu'\n-        elif ostype == 'SunOS':\n-            ostype = 'sun-solaris'\n-            # On Solaris, uname -m will return a machine classification instead\n-            # of a cpu type, so uname -p is recommended instead.  However, the\n-            # output from that option is too generic for our purposes (it will\n-            # always emit 'i386' on x86/amd64 systems).  As such, isainfo -k\n-            # must be used instead.\n-            try:\n-                cputype = subprocess.check_output(\n-                    ['isainfo', '-k']).strip().decode(default_encoding)\n-            except (subprocess.CalledProcessError, OSError):\n-                err = \"isainfo not found\"\n-                if self.verbose:\n-                    raise Exception(err)\n-                sys.exit(err)\n-        elif ostype.startswith('MINGW'):\n-            # msys' `uname` does not print gcc configuration, but prints msys\n-            # configuration. so we cannot believe `uname -m`:\n-            # msys1 is always i686 and msys2 is always x86_64.\n-            # instead, msys defines $MSYSTEM which is MINGW32 on i686 and\n-            # MINGW64 on x86_64.\n-            ostype = 'pc-windows-gnu'\n-            cputype = 'i686'\n-            if os.environ.get('MSYSTEM') == 'MINGW64':\n-                cputype = 'x86_64'\n-        elif ostype.startswith('MSYS'):\n-            ostype = 'pc-windows-gnu'\n-        elif ostype.startswith('CYGWIN_NT'):\n-            cputype = 'i686'\n-            if ostype.endswith('WOW64'):\n-                cputype = 'x86_64'\n-            ostype = 'pc-windows-gnu'\n-        else:\n-            err = \"unknown OS type: {}\".format(ostype)\n-            if self.verbose:\n-                raise ValueError(err)\n-            sys.exit(err)\n-\n-        cputype_mapper = {\n-            'BePC': 'i686',\n-            'aarch64': 'aarch64',\n-            'amd64': 'x86_64',\n-            'arm64': 'aarch64',\n-            'i386': 'i686',\n-            'i486': 'i686',\n-            'i686': 'i686',\n-            'i786': 'i686',\n-            'powerpc': 'powerpc',\n-            'powerpc64': 'powerpc64',\n-            'powerpc64le': 'powerpc64le',\n-            'ppc': 'powerpc',\n-            'ppc64': 'powerpc64',\n-            'ppc64le': 'powerpc64le',\n-            's390x': 's390x',\n-            'x64': 'x86_64',\n-            'x86': 'i686',\n-            'x86-64': 'x86_64',\n-            'x86_64': 'x86_64'\n-        }\n-\n-        # Consider the direct transformation first and then the special cases\n-        if cputype in cputype_mapper:\n-            cputype = cputype_mapper[cputype]\n-        elif cputype in {'xscale', 'arm'}:\n-            cputype = 'arm'\n-            if ostype == 'linux-android':\n-                ostype = 'linux-androideabi'\n-        elif cputype == 'armv6l':\n-            cputype = 'arm'\n-            if ostype == 'linux-android':\n-                ostype = 'linux-androideabi'\n-            else:\n-                ostype += 'eabihf'\n-        elif cputype in {'armv7l', 'armv8l'}:\n-            cputype = 'armv7'\n-            if ostype == 'linux-android':\n-                ostype = 'linux-androideabi'\n-            else:\n-                ostype += 'eabihf'\n-        elif cputype == 'mips':\n-            if sys.byteorder == 'big':\n-                cputype = 'mips'\n-            elif sys.byteorder == 'little':\n-                cputype = 'mipsel'\n-            else:\n-                raise ValueError(\"unknown byteorder: {}\".format(sys.byteorder))\n-        elif cputype == 'mips64':\n-            if sys.byteorder == 'big':\n-                cputype = 'mips64'\n-            elif sys.byteorder == 'little':\n-                cputype = 'mips64el'\n-            else:\n-                raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n-            # only the n64 ABI is supported, indicate it\n-            ostype += 'abi64'\n-        elif cputype == 'sparcv9':\n-            pass\n-        else:\n-            err = \"unknown cpu type: {}\".format(cputype)\n-            if self.verbose:\n-                raise ValueError(err)\n-            sys.exit(err)\n-\n-        return \"{}-{}\".format(cputype, ostype)\n+        return default_build_triple()\n \n     def update_submodules(self):\n         \"\"\"Update submodules\"\"\"\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n-                self.get_toml('submodules') == \"false\" or \\\n-                self.get_mk('CFG_DISABLE_MANAGE_SUBMODULES') == \"1\":\n+                self.get_toml('submodules') == \"false\":\n             return\n         print('Updating submodules')\n         default_encoding = sys.getdefaultencoding()\n@@ -680,11 +650,9 @@ def update_submodules(self):\n         ).decode(default_encoding).splitlines()]\n         submodules = [module for module in submodules\n                       if not ((module.endswith(\"llvm\") and\n-                               (self.get_toml('llvm-config') or\n-                                self.get_mk('CFG_LLVM_ROOT'))) or\n+                               self.get_toml('llvm-config')) or\n                               (module.endswith(\"jemalloc\") and\n-                               (self.get_toml('jemalloc') or\n-                                self.get_mk('CFG_JEMALLOC_ROOT'))))]\n+                               self.get_toml('jemalloc')))]\n         run([\"git\", \"submodule\", \"update\",\n              \"--init\", \"--recursive\"] + submodules,\n             cwd=self.rust_root, verbose=self.verbose)\n@@ -721,21 +689,15 @@ def bootstrap():\n             build.config_toml = config.read()\n     except:\n         pass\n-    try:\n-        build.config_mk = open('config.mk').read()\n-    except:\n-        pass\n \n     if '\\nverbose = 2' in build.config_toml:\n         build.verbose = 2\n     elif '\\nverbose = 1' in build.config_toml:\n         build.verbose = 1\n \n-    build.use_vendored_sources = '\\nvendor = true' in build.config_toml or \\\n-                                 'CFG_ENABLE_VENDOR' in build.config_mk\n+    build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n \n-    build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml or \\\n-                            'CFG_ENABLE_LOCKED_DEPS' in build.config_mk\n+    build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml\n \n     if 'SUDO_USER' in os.environ and not build.use_vendored_sources:\n         if os.environ.get('USER') != os.environ['SUDO_USER']:"}, {"sha": "298f6a004a20aefd1c6da6c892bf62b6c9450bd1", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -193,7 +193,7 @@ pub struct ShouldRun<'a> {\n impl<'a> ShouldRun<'a> {\n     fn new(builder: &'a Builder) -> ShouldRun<'a> {\n         ShouldRun {\n-            builder: builder,\n+            builder,\n             paths: BTreeSet::new(),\n             is_really_default: true, // by default no additional conditions\n         }\n@@ -257,7 +257,7 @@ impl<'a> Builder<'a> {\n             Kind::Bench => describe!(check::Crate, check::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n-                doc::Reference, doc::Rustdoc),\n+                doc::Reference, doc::Rustdoc, doc::CargoBook),\n             Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n                 dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n                 dist::Rls, dist::Extended, dist::HashSign),\n@@ -278,9 +278,9 @@ impl<'a> Builder<'a> {\n         };\n \n         let builder = Builder {\n-            build: build,\n+            build,\n             top_stage: build.config.stage.unwrap_or(2),\n-            kind: kind,\n+            kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n         };\n@@ -309,9 +309,9 @@ impl<'a> Builder<'a> {\n         };\n \n         let builder = Builder {\n-            build: build,\n+            build,\n             top_stage: build.config.stage.unwrap_or(2),\n-            kind: kind,\n+            kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n         };\n@@ -503,6 +503,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_METADATA_SUFFIX\", \"rustc\");\n         }\n \n+        if let Some(x) = self.crt_static(target) {\n+            cargo.env(\"RUSTC_CRT_STATIC\", x.to_string());\n+        }\n+\n         // Enable usage of unstable features\n         cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         self.add_rust_test_threads(&mut cargo);"}, {"sha": "92fb2105b7c5d57133c6425069cc09ae853ae5a8", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -872,7 +872,7 @@ impl Step for CrateLibrustc {\n             builder.ensure(CrateLibrustc {\n                 compiler,\n                 target: run.target,\n-                test_kind: test_kind,\n+                test_kind,\n                 krate: name,\n             });\n         };\n@@ -934,8 +934,8 @@ impl Step for Crate {\n             builder.ensure(Crate {\n                 compiler,\n                 target: run.target,\n-                mode: mode,\n-                test_kind: test_kind,\n+                mode,\n+                test_kind,\n                 krate: name,\n             });\n         };"}, {"sha": "335e1690a2ea0252a97860079309257a5aa0e0d4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -74,13 +74,21 @@ impl Step for Std {\n             let from = builder.compiler(1, build.build);\n             builder.ensure(Std {\n                 compiler: from,\n-                target: target,\n+                target,\n             });\n             println!(\"Uplifting stage1 std ({} -> {})\", from.host, target);\n+\n+            // Even if we're not building std this stage, the new sysroot must\n+            // still contain the musl startup objects.\n+            if target.contains(\"musl\") && !target.contains(\"mips\") {\n+                let libdir = builder.sysroot_libdir(compiler, target);\n+                copy_musl_third_party_objects(build, target, &libdir);\n+            }\n+\n             builder.ensure(StdLink {\n                 compiler: from,\n                 target_compiler: compiler,\n-                target: target,\n+                target,\n             });\n             return;\n         }\n@@ -89,6 +97,11 @@ impl Step for Std {\n         println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target);\n \n+        if target.contains(\"musl\") && !target.contains(\"mips\") {\n+            let libdir = builder.sysroot_libdir(compiler, target);\n+            copy_musl_third_party_objects(build, target, &libdir);\n+        }\n+\n         let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n@@ -100,11 +113,25 @@ impl Step for Std {\n         builder.ensure(StdLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n             target_compiler: compiler,\n-            target: target,\n+            target,\n         });\n     }\n }\n \n+/// Copies the crt(1,i,n).o startup objects\n+///\n+/// Since musl supports fully static linking, we can cross link for it even\n+/// with a glibc-targeting toolchain, given we have the appropriate startup\n+/// files. As those shipped with glibc won't work, copy the ones provided by\n+/// musl so we have them on linux-gnu hosts.\n+fn copy_musl_third_party_objects(build: &Build,\n+                                 target: Interned<String>,\n+                                 into: &Path) {\n+    for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n+        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n+    }\n+}\n+\n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n pub fn std_cargo(build: &Build,\n@@ -189,10 +216,6 @@ impl Step for StdLink {\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n         add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n \n-        if target.contains(\"musl\") && !target.contains(\"mips\") {\n-            copy_musl_third_party_objects(build, target, &libdir);\n-        }\n-\n         if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n             // be missing in stage0 and causes panic. See the `std()` function above\n@@ -202,21 +225,12 @@ impl Step for StdLink {\n \n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n-            target: target,\n+            target,\n             mode: Mode::Libstd,\n         });\n     }\n }\n \n-/// Copies the crt(1,i,n).o startup objects\n-///\n-/// Only required for musl targets that statically link to libc\n-fn copy_musl_third_party_objects(build: &Build, target: Interned<String>, into: &Path) {\n-    for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n-    }\n-}\n-\n fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n@@ -326,13 +340,13 @@ impl Step for Test {\n         if build.force_use_stage1(compiler, target) {\n             builder.ensure(Test {\n                 compiler: builder.compiler(1, build.build),\n-                target: target,\n+                target,\n             });\n             println!(\"Uplifting stage1 test ({} -> {})\", &build.build, target);\n             builder.ensure(TestLink {\n                 compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n-                target: target,\n+                target,\n             });\n             return;\n         }\n@@ -351,7 +365,7 @@ impl Step for Test {\n         builder.ensure(TestLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n             target_compiler: compiler,\n-            target: target,\n+            target,\n         });\n     }\n }\n@@ -398,7 +412,7 @@ impl Step for TestLink {\n                     &libtest_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n-            target: target,\n+            target,\n             mode: Mode::Libtest,\n         });\n     }\n@@ -445,7 +459,7 @@ impl Step for Rustc {\n         if build.force_use_stage1(compiler, target) {\n             builder.ensure(Rustc {\n                 compiler: builder.compiler(1, build.build),\n-                target: target,\n+                target,\n             });\n             println!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target);\n             builder.ensure(RustcLink {\n@@ -581,7 +595,7 @@ impl Step for RustcLink {\n                        &librustc_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n-            target: target,\n+            target,\n             mode: Mode::Librustc,\n         });\n     }"}, {"sha": "2c25f374e12a4f32f82a7b8e97d96c591768fec6", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 54, "deletions": 257, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -10,20 +10,20 @@\n \n //! Serialized configuration of a build.\n //!\n-//! This module implements parsing `config.mk` and `config.toml` configuration\n-//! files to tweak how the build runs.\n+//! This module implements parsing `config.toml` configuration files to tweak\n+//! how the build runs.\n \n use std::collections::HashMap;\n use std::env;\n-use std::fs::{self, File};\n+use std::fs::File;\n use std::io::prelude::*;\n use std::path::PathBuf;\n use std::process;\n use std::cmp;\n \n use num_cpus;\n use toml;\n-use util::{exe, push_exe_path};\n+use util::exe;\n use cache::{INTERNER, Interned};\n use flags::Flags;\n pub use flags::Subcommand;\n@@ -124,14 +124,12 @@ pub struct Config {\n     pub nodejs: Option<PathBuf>,\n     pub gdb: Option<PathBuf>,\n     pub python: Option<PathBuf>,\n-    pub configure_args: Vec<String>,\n     pub openssl_static: bool,\n-\n+    pub configure_args: Vec<String>,\n \n     // These are either the stage0 downloaded binaries or the locally installed ones.\n     pub initial_cargo: PathBuf,\n     pub initial_rustc: PathBuf,\n-\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -143,6 +141,7 @@ pub struct Target {\n     pub cc: Option<PathBuf>,\n     pub cxx: Option<PathBuf>,\n     pub ndk: Option<PathBuf>,\n+    pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n     pub qemu_rootfs: Option<PathBuf>,\n }\n@@ -189,6 +188,8 @@ struct Build {\n     sanitizers: Option<bool>,\n     profiler: Option<bool>,\n     openssl_static: Option<bool>,\n+    configure_args: Option<Vec<String>>,\n+    local_rebuild: Option<bool>,\n }\n \n /// TOML representation of various global install decisions.\n@@ -218,6 +219,7 @@ struct Llvm {\n     targets: Option<String>,\n     experimental_targets: Option<String>,\n     link_jobs: Option<u32>,\n+    link_shared: Option<bool>,\n }\n \n #[derive(Deserialize, Default, Clone)]\n@@ -264,6 +266,9 @@ struct Rust {\n     debuginfo_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n     ignore_git: Option<bool>,\n+    debug: Option<bool>,\n+    dist_src: Option<bool>,\n+    quiet_tests: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -275,6 +280,7 @@ struct TomlTarget {\n     cc: Option<String>,\n     cxx: Option<String>,\n     android_ndk: Option<String>,\n+    crt_static: Option<bool>,\n     musl_root: Option<String>,\n     qemu_rootfs: Option<String>,\n }\n@@ -372,6 +378,8 @@ impl Config {\n         set(&mut config.sanitizers, build.sanitizers);\n         set(&mut config.profiler, build.profiler);\n         set(&mut config.openssl_static, build.openssl_static);\n+        set(&mut config.configure_args, build.configure_args);\n+        set(&mut config.local_rebuild, build.local_rebuild);\n         config.verbose = cmp::max(config.verbose, flags.verbose);\n \n         if let Some(ref install) = toml.install {\n@@ -383,6 +391,17 @@ impl Config {\n             config.mandir = install.mandir.clone().map(PathBuf::from);\n         }\n \n+        // Store off these values as options because if they're not provided\n+        // we'll infer default values for them later\n+        let mut llvm_assertions = None;\n+        let mut debuginfo_lines = None;\n+        let mut debuginfo_only_std = None;\n+        let mut debug = None;\n+        let mut debug_jemalloc = None;\n+        let mut debuginfo = None;\n+        let mut debug_assertions = None;\n+        let mut optimize = None;\n+\n         if let Some(ref llvm) = toml.llvm {\n             match llvm.ccache {\n                 Some(StringOrBool::String(ref s)) => {\n@@ -395,36 +414,35 @@ impl Config {\n             }\n             set(&mut config.ninja, llvm.ninja);\n             set(&mut config.llvm_enabled, llvm.enabled);\n-            set(&mut config.llvm_assertions, llvm.assertions);\n+            llvm_assertions = llvm.assertions;\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n+            set(&mut config.llvm_link_shared, llvm.link_shared);\n             config.llvm_targets = llvm.targets.clone();\n             config.llvm_experimental_targets = llvm.experimental_targets.clone();\n             config.llvm_link_jobs = llvm.link_jobs;\n         }\n \n         if let Some(ref rust) = toml.rust {\n-            set(&mut config.rust_debug_assertions, rust.debug_assertions);\n-            set(&mut config.rust_debuginfo, rust.debuginfo);\n-            set(&mut config.rust_debuginfo_lines, rust.debuginfo_lines);\n-            set(&mut config.rust_debuginfo_only_std, rust.debuginfo_only_std);\n-            set(&mut config.rust_optimize, rust.optimize);\n+            debug = rust.debug;\n+            debug_assertions = rust.debug_assertions;\n+            debuginfo = rust.debuginfo;\n+            debuginfo_lines = rust.debuginfo_lines;\n+            debuginfo_only_std = rust.debuginfo_only_std;\n+            optimize = rust.optimize;\n+            debug_jemalloc = rust.debug_jemalloc;\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n             set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n             set(&mut config.codegen_tests, rust.codegen_tests);\n             set(&mut config.rust_rpath, rust.rpath);\n-            set(&mut config.debug_jemalloc, rust.debug_jemalloc);\n             set(&mut config.use_jemalloc, rust.use_jemalloc);\n             set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel.clone());\n-\n-            // on the dev channel, ignore_git should be true by default\n-            // on other channels it should be false by default\n-            config.ignore_git = config.channel == \"dev\";\n             set(&mut config.ignore_git, rust.ignore_git);\n-\n+            set(&mut config.rust_dist_src, rust.dist_src);\n+            set(&mut config.quiet_tests, rust.quiet_tests);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.rustc_default_ar = rust.default_ar.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n@@ -451,6 +469,7 @@ impl Config {\n                 }\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n+                target.crt_static = cfg.crt_static.clone();\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);\n \n@@ -478,224 +497,26 @@ impl Config {\n             None => stage0_root.join(exe(\"cargo\", &config.build)),\n         };\n \n-        // compat with `./configure` while we're still using that\n-        if fs::metadata(\"config.mk\").is_ok() {\n-            config.update_with_config_mk();\n-        }\n-\n-        config\n-    }\n+        // Now that we've reached the end of our configuration, infer the\n+        // default values for all options that we haven't otherwise stored yet.\n \n-    /// \"Temporary\" routine to parse `config.mk` into this configuration.\n-    ///\n-    /// While we still have `./configure` this implements the ability to decode\n-    /// that configuration into this. This isn't exactly a full-blown makefile\n-    /// parser, but hey it gets the job done!\n-    fn update_with_config_mk(&mut self) {\n-        let mut config = String::new();\n-        File::open(\"config.mk\").unwrap().read_to_string(&mut config).unwrap();\n-        for line in config.lines() {\n-            let mut parts = line.splitn(2, \":=\").map(|s| s.trim());\n-            let key = parts.next().unwrap();\n-            let value = match parts.next() {\n-                Some(n) if n.starts_with('\\\"') => &n[1..n.len() - 1],\n-                Some(n) => n,\n-                None => continue\n-            };\n-\n-            macro_rules! check {\n-                ($(($name:expr, $val:expr),)*) => {\n-                    if value == \"1\" {\n-                        $(\n-                            if key == concat!(\"CFG_ENABLE_\", $name) {\n-                                $val = true;\n-                                continue\n-                            }\n-                            if key == concat!(\"CFG_DISABLE_\", $name) {\n-                                $val = false;\n-                                continue\n-                            }\n-                        )*\n-                    }\n-                }\n-            }\n+        let default = config.channel == \"nightly\";\n+        config.llvm_assertions = llvm_assertions.unwrap_or(default);\n \n-            check! {\n-                (\"MANAGE_SUBMODULES\", self.submodules),\n-                (\"COMPILER_DOCS\", self.compiler_docs),\n-                (\"DOCS\", self.docs),\n-                (\"LLVM_ASSERTIONS\", self.llvm_assertions),\n-                (\"LLVM_RELEASE_DEBUGINFO\", self.llvm_release_debuginfo),\n-                (\"OPTIMIZE_LLVM\", self.llvm_optimize),\n-                (\"LLVM_VERSION_CHECK\", self.llvm_version_check),\n-                (\"LLVM_STATIC_STDCPP\", self.llvm_static_stdcpp),\n-                (\"LLVM_LINK_SHARED\", self.llvm_link_shared),\n-                (\"OPTIMIZE\", self.rust_optimize),\n-                (\"DEBUG_ASSERTIONS\", self.rust_debug_assertions),\n-                (\"DEBUGINFO\", self.rust_debuginfo),\n-                (\"DEBUGINFO_LINES\", self.rust_debuginfo_lines),\n-                (\"DEBUGINFO_ONLY_STD\", self.rust_debuginfo_only_std),\n-                (\"JEMALLOC\", self.use_jemalloc),\n-                (\"DEBUG_JEMALLOC\", self.debug_jemalloc),\n-                (\"RPATH\", self.rust_rpath),\n-                (\"OPTIMIZE_TESTS\", self.rust_optimize_tests),\n-                (\"DEBUGINFO_TESTS\", self.rust_debuginfo_tests),\n-                (\"QUIET_TESTS\", self.quiet_tests),\n-                (\"LOCAL_REBUILD\", self.local_rebuild),\n-                (\"NINJA\", self.ninja),\n-                (\"CODEGEN_TESTS\", self.codegen_tests),\n-                (\"LOCKED_DEPS\", self.locked_deps),\n-                (\"VENDOR\", self.vendor),\n-                (\"FULL_BOOTSTRAP\", self.full_bootstrap),\n-                (\"EXTENDED\", self.extended),\n-                (\"SANITIZERS\", self.sanitizers),\n-                (\"PROFILER\", self.profiler),\n-                (\"DIST_SRC\", self.rust_dist_src),\n-                (\"CARGO_OPENSSL_STATIC\", self.openssl_static),\n-            }\n+        let default = match &config.channel[..] {\n+            \"stable\" | \"beta\" | \"nightly\" => true,\n+            _ => false,\n+        };\n+        config.rust_debuginfo_lines = debuginfo_lines.unwrap_or(default);\n+        config.rust_debuginfo_only_std = debuginfo_only_std.unwrap_or(default);\n \n-            match key {\n-                \"CFG_BUILD\" if value.len() > 0 => self.build = INTERNER.intern_str(value),\n-                \"CFG_HOST\" if value.len() > 0 => {\n-                    self.hosts.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n+        let default = debug == Some(true);\n+        config.debug_jemalloc = debug_jemalloc.unwrap_or(default);\n+        config.rust_debuginfo = debuginfo.unwrap_or(default);\n+        config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n+        config.rust_optimize = optimize.unwrap_or(!default);\n \n-                }\n-                \"CFG_TARGET\" if value.len() > 0 => {\n-                    self.targets.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n-                }\n-                \"CFG_EXPERIMENTAL_TARGETS\" if value.len() > 0 => {\n-                    self.llvm_experimental_targets = Some(value.to_string());\n-                }\n-                \"CFG_MUSL_ROOT\" if value.len() > 0 => {\n-                    self.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_X86_64\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"x86_64-unknown-linux-musl\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_I686\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"i686-unknown-linux-musl\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_ARM\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"arm-unknown-linux-musleabi\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_ARMHF\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"arm-unknown-linux-musleabihf\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_ARMV7\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"armv7-unknown-linux-musleabihf\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_DEFAULT_AR\" if value.len() > 0 => {\n-                    self.rustc_default_ar = Some(value.to_string());\n-                }\n-                \"CFG_DEFAULT_LINKER\" if value.len() > 0 => {\n-                    self.rustc_default_linker = Some(value.to_string());\n-                }\n-                \"CFG_GDB\" if value.len() > 0 => {\n-                    self.gdb = Some(parse_configure_path(value));\n-                }\n-                \"CFG_RELEASE_CHANNEL\" => {\n-                    self.channel = value.to_string();\n-                }\n-                \"CFG_PREFIX\" => {\n-                    self.prefix = Some(PathBuf::from(value));\n-                }\n-                \"CFG_SYSCONFDIR\" => {\n-                    self.sysconfdir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_DOCDIR\" => {\n-                    self.docdir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_BINDIR\" => {\n-                    self.bindir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_LIBDIR\" => {\n-                    self.libdir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_LIBDIR_RELATIVE\" => {\n-                    self.libdir_relative = Some(PathBuf::from(value));\n-                }\n-                \"CFG_MANDIR\" => {\n-                    self.mandir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_LLVM_ROOT\" if value.len() > 0 => {\n-                    let target = self.target_config.entry(self.build.clone())\n-                                     .or_insert(Target::default());\n-                    let root = parse_configure_path(value);\n-                    target.llvm_config = Some(push_exe_path(root, &[\"bin\", \"llvm-config\"]));\n-                }\n-                \"CFG_JEMALLOC_ROOT\" if value.len() > 0 => {\n-                    let target = self.target_config.entry(self.build.clone())\n-                                     .or_insert(Target::default());\n-                    target.jemalloc = Some(parse_configure_path(value).join(\"libjemalloc_pic.a\"));\n-                }\n-                \"CFG_ARM_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"arm-linux-androideabi\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_ARMV7_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"armv7-linux-androideabi\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_I686_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"i686-linux-android\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_AARCH64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"aarch64-linux-android\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_X86_64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"x86_64-linux-android\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_LOCAL_RUST_ROOT\" if value.len() > 0 => {\n-                    let path = parse_configure_path(value);\n-                    self.initial_rustc = push_exe_path(path.clone(), &[\"bin\", \"rustc\"]);\n-                    self.initial_cargo = push_exe_path(path, &[\"bin\", \"cargo\"]);\n-                }\n-                \"CFG_PYTHON\" if value.len() > 0 => {\n-                    let path = parse_configure_path(value);\n-                    self.python = Some(path);\n-                }\n-                \"CFG_ENABLE_CCACHE\" if value == \"1\" => {\n-                    self.ccache = Some(exe(\"ccache\", &self.build));\n-                }\n-                \"CFG_ENABLE_SCCACHE\" if value == \"1\" => {\n-                    self.ccache = Some(exe(\"sccache\", &self.build));\n-                }\n-                \"CFG_CONFIGURE_ARGS\" if value.len() > 0 => {\n-                    self.configure_args = value.split_whitespace()\n-                                               .map(|s| s.to_string())\n-                                               .collect();\n-                }\n-                \"CFG_QEMU_ARMHF_ROOTFS\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"arm-unknown-linux-gnueabihf\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.qemu_rootfs = Some(parse_configure_path(value));\n-                }\n-                \"CFG_QEMU_AARCH64_ROOTFS\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"aarch64-unknown-linux-gnu\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.qemu_rootfs = Some(parse_configure_path(value));\n-                }\n-                _ => {}\n-            }\n-        }\n+        config\n     }\n \n     pub fn verbose(&self) -> bool {\n@@ -707,30 +528,6 @@ impl Config {\n     }\n }\n \n-#[cfg(not(windows))]\n-fn parse_configure_path(path: &str) -> PathBuf {\n-    path.into()\n-}\n-\n-#[cfg(windows)]\n-fn parse_configure_path(path: &str) -> PathBuf {\n-    // on windows, configure produces unix style paths e.g. /c/some/path but we\n-    // only want real windows paths\n-\n-    use std::process::Command;\n-    use build_helper;\n-\n-    // '/' is invalid in windows paths, so we can detect unix paths by the presence of it\n-    if !path.contains('/') {\n-        return path.into();\n-    }\n-\n-    let win_path = build_helper::output(Command::new(\"cygpath\").arg(\"-w\").arg(path));\n-    let win_path = win_path.trim();\n-\n-    win_path.into()\n-}\n-\n fn set<T>(field: &mut T, val: Option<T>) {\n     if let Some(v) = val {\n         *field = v;"}, {"sha": "0e11635c3a0b1e89b49049d35969c34897b176d6", "filename": "src/bootstrap/configure.py", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -0,0 +1,408 @@\n+#!/usr/bin/env python\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# ignore-tidy-linelength\n+\n+import sys\n+import os\n+rust_dir = os.path.dirname(os.path.abspath(__file__))\n+rust_dir = os.path.dirname(rust_dir)\n+rust_dir = os.path.dirname(rust_dir)\n+sys.path.append(os.path.join(rust_dir, \"src\", \"bootstrap\"))\n+import bootstrap\n+\n+class Option:\n+    def __init__(self, name, rustbuild, desc, value):\n+        self.name = name\n+        self.rustbuild = rustbuild\n+        self.desc = desc\n+        self.value = value\n+\n+options = []\n+\n+def o(*args):\n+    options.append(Option(*args, value=False))\n+\n+def v(*args):\n+    options.append(Option(*args, value=True))\n+\n+o(\"debug\", \"rust.debug\", \"debug mode; disables optimization unless `--enable-optimize` given\")\n+o(\"docs\", \"build.docs\", \"build standard library documentation\")\n+o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n+o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n+o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n+o(\"quiet-tests\", \"rust.quiet-tests\", \"enable quieter output when running tests\")\n+o(\"ccache\", \"llvm.ccache\", \"invoke gcc/clang via ccache to reuse object files between builds\")\n+o(\"sccache\", None, \"invoke gcc/clang via sccache to reuse object files between builds\")\n+o(\"local-rust\", None, \"use an installed rustc rather than downloading a snapshot\")\n+v(\"local-rust-root\", None, \"set prefix for local rust binary\")\n+o(\"local-rebuild\", \"build.local-rebuild\", \"assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version\")\n+o(\"llvm-static-stdcpp\", \"llvm.static-libstdcpp\", \"statically link to libstdc++ for LLVM\")\n+o(\"llvm-link-shared\", \"llvm.link-shared\", \"prefer shared linking to LLVM (llvm-config --link-shared)\")\n+o(\"rpath\", \"rust.rpath\", \"build rpaths into rustc itself\")\n+o(\"llvm-version-check\", \"llvm.version-check\", \"check if the LLVM version is supported, build anyway\")\n+o(\"codegen-tests\", \"rust.codegen-tests\", \"run the src/test/codegen tests\")\n+o(\"option-checking\", None, \"complain about unrecognized options in this configure script\")\n+o(\"ninja\", \"llvm.ninja\", \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\")\n+o(\"locked-deps\", \"build.locked-deps\", \"force Cargo.lock to be up to date\")\n+o(\"vendor\", \"build.vendor\", \"enable usage of vendored Rust crates\")\n+o(\"sanitizers\", \"build.sanitizers\", \"build the sanitizer runtimes (asan, lsan, msan, tsan)\")\n+o(\"dist-src\", \"rust.dist-src\", \"when building tarballs enables building a source tarball\")\n+o(\"cargo-openssl-static\", \"build.openssl-static\", \"static openssl in cargo\")\n+o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n+\n+# Optimization and debugging options. These may be overridden by the release\n+# channel, etc.\n+o(\"optimize\", \"rust.optimize\", \"build optimized rust code\")\n+o(\"optimize-llvm\", \"llvm.optimize\", \"build optimized LLVM\")\n+o(\"llvm-assertions\", \"llvm.assertions\", \"build LLVM with assertions\")\n+o(\"debug-assertions\", \"rust.debug-assertions\", \"build with debugging assertions\")\n+o(\"llvm-release-debuginfo\", \"llvm.release-debuginfo\", \"build LLVM with debugger metadata\")\n+o(\"debuginfo\", \"rust.debuginfo\", \"build with debugger metadata\")\n+o(\"debuginfo-lines\", \"rust.debuginfo-lines\", \"build with line number debugger metadata\")\n+o(\"debuginfo-only-std\", \"rust.debuginfo-only-std\", \"build only libstd with debugging information\")\n+o(\"debug-jemalloc\", \"rust.debug-jemalloc\", \"build jemalloc with --enable-debug --enable-fill\")\n+\n+v(\"prefix\", \"install.prefix\", \"set installation prefix\")\n+v(\"localstatedir\", \"install.localstatedir\", \"local state directory\")\n+v(\"datadir\", \"install.datadir\", \"install data\")\n+v(\"sysconfdir\", \"install.sysconfdir\", \"install system configuration files\")\n+v(\"infodir\", \"install.infodir\", \"install additional info\")\n+v(\"libdir\", \"install.libdir\", \"install libraries\")\n+v(\"mandir\", \"install.mandir\", \"install man pages in PATH\")\n+v(\"docdir\", \"install.docdir\", \"install documentation in PATH\")\n+v(\"bindir\", \"install.bindir\", \"install binaries\")\n+\n+v(\"llvm-root\", None, \"set LLVM root\")\n+v(\"python\", \"build.python\", \"set path to python\")\n+v(\"jemalloc-root\", None, \"set directory where libjemalloc_pic.a is located\")\n+v(\"android-cross-path\", \"target.arm-linux-androideabi.android-ndk\",\n+  \"Android NDK standalone path (deprecated)\")\n+v(\"i686-linux-android-ndk\", \"target.i686-linux-android.android-ndk\",\n+  \"i686-linux-android NDK standalone path\")\n+v(\"arm-linux-androideabi-ndk\", \"target.arm-linux-androideabi.android-ndk\",\n+  \"arm-linux-androideabi NDK standalone path\")\n+v(\"armv7-linux-androideabi-ndk\", \"target.armv7-linux-androideabi.android-ndk\",\n+  \"armv7-linux-androideabi NDK standalone path\")\n+v(\"aarch64-linux-android-ndk\", \"target.aarch64-linux-android.android-ndk\",\n+  \"aarch64-linux-android NDK standalone path\")\n+v(\"x86_64-linux-android-ndk\", \"target.x86_64-linux-android.android-ndk\",\n+  \"x86_64-linux-android NDK standalone path\")\n+v(\"musl-root\", \"target.x86_64-unknown-linux-musl.musl-root\",\n+  \"MUSL root installation directory (deprecated)\")\n+v(\"musl-root-x86_64\", \"target.x86_64-unknown-linux-musl.musl-root\",\n+  \"x86_64-unknown-linux-musl install directory\")\n+v(\"musl-root-i686\", \"target.i686-unknown-linux-musl.musl-root\",\n+  \"i686-unknown-linux-musl install directory\")\n+v(\"musl-root-arm\", \"target.arm-unknown-linux-musleabi.musl-root\",\n+  \"arm-unknown-linux-musleabi install directory\")\n+v(\"musl-root-armhf\", \"target.arm-unknown-linux-musleabihf.musl-root\",\n+  \"arm-unknown-linux-musleabihf install directory\")\n+v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n+  \"armv7-unknown-linux-musleabihf install directory\")\n+v(\"qemu-armhf-rootfs\", \"target.arm-unknown-linux-gnueabihf.qemu-rootfs\",\n+  \"rootfs in qemu testing, you probably don't want to use this\")\n+v(\"qemu-aarch64-rootfs\", \"target.aarch64-unknown-linux-gnu.qemu-rootfs\",\n+  \"rootfs in qemu testing, you probably don't want to use this\")\n+v(\"experimental-targets\", \"llvm.experimental-targets\",\n+  \"experimental LLVM targets to build\")\n+v(\"release-channel\", \"rust.channel\", \"the name of the release channel to build\")\n+\n+# Used on systems where \"cc\" and \"ar\" are unavailable\n+v(\"default-linker\", \"rust.default-linker\", \"the default linker\")\n+v(\"default-ar\", \"rust.default-ar\", \"the default ar\")\n+\n+# Many of these are saved below during the \"writing configuration\" step\n+# (others are conditionally saved).\n+o(\"manage-submodules\", \"build.submodules\", \"let the build manage the git submodules\")\n+o(\"jemalloc\", \"rust.use-jemalloc\", \"build liballoc with jemalloc\")\n+o(\"full-bootstrap\", \"build.full-bootstrap\", \"build three compilers instead of two\")\n+o(\"extended\", \"build.extended\", \"build an extended rust tool set\")\n+\n+v(\"build\", \"build.build\", \"GNUs ./configure syntax LLVM build triple\")\n+v(\"host\", None, \"GNUs ./configure syntax LLVM host triples\")\n+v(\"target\", None, \"GNUs ./configure syntax LLVM target triples\")\n+\n+v(\"set\", None, \"set arbitrary key/value pairs in TOML configuration\")\n+\n+def p(msg):\n+    print(\"configure: \" + msg)\n+\n+def err(msg):\n+    print(\"configure: error: \" + msg)\n+    sys.exit(1)\n+\n+if '--help' in sys.argv or '-h' in sys.argv:\n+    print('Usage: ./configure [options]')\n+    print('')\n+    print('Options')\n+    for option in options:\n+        if 'android' in option.name:\n+            # no one needs to know about these obscure options\n+            continue\n+        if option.value:\n+            print('\\t{:30} {}'.format('--{}=VAL'.format(option.name), option.desc))\n+        else:\n+            print('\\t{:30} {}'.format('--enable-{}'.format(option.name), option.desc))\n+    print('')\n+    print('This configure script is a thin configuration shim over the true')\n+    print('configuration system, `config.toml`. You can explore the comments')\n+    print('in `config.toml.example` next to this configure script to see')\n+    print('more information about what each option is. Additionally you can')\n+    print('pass `--set` as an argument to set arbitrary key/value pairs')\n+    print('in the TOML configuration if desired')\n+    print('')\n+    print('Also note that all options which take `--enable` can similarly')\n+    print('be passed with `--disable-foo` to forcibly disable the option')\n+    sys.exit(0)\n+\n+# Parse all command line arguments into one of these three lists, handling\n+# boolean and value-based options separately\n+unknown_args = []\n+need_value_args = []\n+known_args = {}\n+\n+p(\"processing command line\")\n+i = 1\n+while i < len(sys.argv):\n+    arg = sys.argv[i]\n+    i += 1\n+    if not arg.startswith('--'):\n+        unknown_args.append(arg)\n+        continue\n+\n+    found = False\n+    for option in options:\n+        value = None\n+        if option.value:\n+            keyval = arg[2:].split('=', 1)\n+            key = keyval[0]\n+            if option.name != key:\n+                continue\n+\n+            if len(keyval) > 1:\n+                value = keyval[1]\n+            elif i < len(sys.argv):\n+                value = sys.argv[i]\n+                i += 1\n+            else:\n+                need_value_args.append(arg)\n+                continue\n+        else:\n+            if arg[2:] == 'enable-' + option.name:\n+                value = True\n+            elif arg[2:] == 'disable-' + option.name:\n+                value = False\n+            else:\n+                continue\n+\n+        found = True\n+        if not option.name in known_args:\n+            known_args[option.name] = []\n+        known_args[option.name].append((option, value))\n+        break\n+\n+    if not found:\n+        unknown_args.append(arg)\n+p(\"\")\n+\n+if 'option-checking' not in known_args or known_args['option-checking'][1]:\n+    if len(unknown_args) > 0:\n+        err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n+    if len(need_value_args) > 0:\n+        err(\"Option '{0}' needs a value ({0}=val)\".format(need_value_args[0]))\n+\n+# Parse all known arguments into a configuration structure that reflects the\n+# TOML we're going to write out\n+config = {}\n+\n+def build():\n+    if 'build' in known_args:\n+        return known_args['build'][0][1]\n+    return bootstrap.default_build_triple()\n+\n+def set(key, value):\n+      s = \"{:20} := {}\".format(key, value)\n+      if len(s) < 70:\n+          p(s)\n+      else:\n+          p(s[:70] + \" ...\")\n+\n+      arr = config\n+      parts = key.split('.')\n+      for i, part in enumerate(parts):\n+          if i == len(parts) - 1:\n+              arr[part] = value\n+          else:\n+              if not part in arr:\n+                  arr[part] = {}\n+              arr = arr[part]\n+\n+for key in known_args:\n+    # The `set` option is special and an be passed a bunch of times\n+    if key == 'set':\n+        for option, value in known_args[key]:\n+            keyval = value.split('=', 1)\n+            set(keyval[0], True if len(keyval) == 1 else keyval[1])\n+        continue\n+\n+    # Ensure each option is only passed once\n+    arr = known_args[key]\n+    if len(arr) > 1:\n+        err(\"Option '{}' provided more than once\".format(key))\n+    option, value = arr[0]\n+\n+    # If we have a clear avenue to set our value in rustbuild, do so\n+    if option.rustbuild is not None:\n+        set(option.rustbuild, value)\n+        continue\n+\n+    # Otherwise we're a \"special\" option and need some extra handling, so do\n+    # that here.\n+    if option.name == 'sccache':\n+        set('llvm.ccache', 'sccache')\n+    elif option.name == 'local-rust':\n+        for path in os.environ['PATH'].split(os.pathsep):\n+            if os.path.exists(path + '/rustc'):\n+                set('build.rustc', path + '/rustc')\n+                break\n+        for path in os.environ['PATH'].split(os.pathsep):\n+            if os.path.exists(path + '/cargo'):\n+                set('build.cargo', path + '/cargo')\n+                break\n+    elif option.name == 'local-rust-root':\n+        set('build.rustc', value + '/bin/rustc')\n+        set('build.cargo', value + '/bin/cargo')\n+    elif option.name == 'llvm-root':\n+        set('target.{}.llvm-config'.format(build()), value + '/bin/llvm-config')\n+    elif option.name == 'jemalloc-root':\n+        set('target.{}.jemalloc'.format(build()), value + '/libjemalloc_pic.a')\n+    elif option.name == 'host':\n+        set('build.host', value.split(','))\n+    elif option.name == 'target':\n+        set('build.target', value.split(','))\n+    elif option.name == 'option-checking':\n+        # this was handled above\n+        pass\n+    else:\n+        raise RuntimeError(\"unhandled option {}\".format(option.name))\n+\n+set('build.configure-args', sys.argv[1:])\n+\n+# \"Parse\" the `config.toml.example` file into the various sections, and we'll\n+# use this as a template of a `config.toml` to write out which preserves\n+# all the various comments and whatnot.\n+#\n+# Note that the `target` section is handled separately as we'll duplicate it\n+# per configure dtarget, so there's a bit of special handling for that here.\n+sections = {}\n+cur_section = None\n+sections[None] = []\n+section_order = [None]\n+targets = {}\n+\n+for line in open(rust_dir + '/config.toml.example').read().split(\"\\n\"):\n+    if line.startswith('['):\n+        cur_section = line[1:-1]\n+        if cur_section.startswith('target'):\n+            cur_section = 'target'\n+        elif '.' in cur_section:\n+            raise RuntimeError(\"don't know how to deal with section: {}\".format(cur_section))\n+        sections[cur_section] = [line]\n+        section_order.append(cur_section)\n+    else:\n+        sections[cur_section].append(line)\n+\n+# Fill out the `targets` array by giving all configured targets a copy of the\n+# `target` section we just loaded from the example config\n+configured_targets = [build()]\n+if 'build' in config:\n+    if 'host' in config['build']:\n+        configured_targets += config['build']['host']\n+    if 'target' in config['build']:\n+        configured_targets += config['build']['target']\n+if 'target' in config:\n+    for target in config['target']:\n+        configured_targets.append(target)\n+for target in configured_targets:\n+    targets[target] = sections['target'][:]\n+    targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", target)\n+\n+# Here we walk through the constructed configuration we have from the parsed\n+# command line arguemnts. We then apply each piece of configuration by\n+# basically just doing a `sed` to change the various configuration line to what\n+# we've got configure.\n+def to_toml(value):\n+    if isinstance(value, bool):\n+        if value:\n+            return \"true\"\n+        else:\n+            return \"false\"\n+    elif isinstance(value, list):\n+        return '[' + ', '.join(map(to_toml, value)) + ']'\n+    elif isinstance(value, str):\n+        return \"'\" + value + \"'\"\n+    else:\n+        raise 'no toml'\n+\n+def configure_section(lines, config):\n+    for key in config:\n+        value = config[key]\n+        found = False\n+        for i, line in enumerate(lines):\n+            if not line.startswith('#' + key + ' = '):\n+                continue\n+            found = True\n+            lines[i] = \"{} = {}\".format(key, to_toml(value))\n+            break\n+        if not found:\n+            raise RuntimeError(\"failed to find config line for {}\".format(key))\n+\n+for section_key in config:\n+    section_config = config[section_key]\n+    if not section_key in sections:\n+        raise RuntimeError(\"config key {} not in sections\".format(key))\n+\n+    if section_key == 'target':\n+        for target in section_config:\n+            configure_section(targets[target], section_config[target])\n+    else:\n+        configure_section(sections[section_key], section_config)\n+\n+# Now that we've built up our `config.toml`, write it all out in the same\n+# order that we read it in.\n+p(\"\")\n+p(\"writing `config.toml` in current directory\")\n+with open('config.toml', 'w') as f:\n+    for section in section_order:\n+        if section == 'target':\n+            for target in targets:\n+                for line in targets[target]:\n+                    f.write(line + \"\\n\")\n+        else:\n+            for line in sections[section]:\n+                f.write(line + \"\\n\")\n+\n+with open('Makefile', 'w') as f:\n+    contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n+    contents = open(contents).read()\n+    contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')\n+    contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n+    f.write(contents)\n+\n+# Finally, clean up with a bit of a help message\n+relpath = os.path.dirname(__file__)\n+if relpath == '':\n+    relpath = '.'\n+\n+p(\"\")\n+p(\"run `python {}/x.py --help`\".format(relpath))\n+p(\"\")"}, {"sha": "153ffe509f3086d531739161e1918fc871e8a6d3", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -822,6 +822,7 @@ impl Step for PlainSourceTarball {\n             \"RELEASES.md\",\n             \"configure\",\n             \"x.py\",\n+            \"config.toml.example\",\n         ];\n         let src_dirs = [\n             \"man\","}, {"sha": "86f5346bea1fb1558afd3a07306d563462b5c0a1", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -213,13 +213,13 @@ impl Step for TheBook {\n         let name = self.name;\n         // build book first edition\n         builder.ensure(Rustbook {\n-            target: target,\n+            target,\n             name: INTERNER.intern_string(format!(\"{}/first-edition\", name)),\n         });\n \n         // build book second edition\n         builder.ensure(Rustbook {\n-            target: target,\n+            target,\n             name: INTERNER.intern_string(format!(\"{}/second-edition\", name)),\n         });\n \n@@ -240,6 +240,51 @@ impl Step for TheBook {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct CargoBook {\n+    target: Interned<String>,\n+}\n+\n+impl Step for CargoBook {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.path(\"src/doc/cargo\").default_condition(builder.build.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(CargoBook {\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Create a placeholder for the cargo documentation so that doc.rust-lang.org/cargo will\n+    /// redirect to doc.crates.io. We want to publish doc.rust-lang.org/cargo in the paper\n+    /// version of the book, but we don't want to rush the process of switching cargo's docs\n+    /// over to mdbook and deploying them. When the cargo book is ready, this implementation\n+    /// should build the mdbook instead of this redirect page.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let out = build.doc_out(self.target);\n+\n+        let cargo_dir = out.join(\"cargo\");\n+        t!(fs::create_dir_all(&cargo_dir));\n+\n+        let index = cargo_dir.join(\"index.html\");\n+        let redirect_html = r#\"\n+            <html>\n+                <head>\n+                    <meta http-equiv=\"refresh\" content=\"0; URL='http://doc.crates.io'\" />\n+                </head>\n+            </html>\"#;\n+\n+        println!(\"Creating cargo book redirect page\");\n+        t!(t!(File::create(&index)).write_all(redirect_html.as_bytes()));\n+    }\n+}\n+\n fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String>, markdown: &str) {\n     let build = builder.build;\n     let out = build.doc_out(target);"}, {"sha": "a84d43d3deedef29b70483cfcfc7e29d36e9d702", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -274,14 +274,14 @@ Arguments:\n             }\n             \"test\" => {\n                 Subcommand::Test {\n-                    paths: paths,\n+                    paths,\n                     test_args: matches.opt_strs(\"test-args\"),\n                     fail_fast: !matches.opt_present(\"no-fail-fast\"),\n                 }\n             }\n             \"bench\" => {\n                 Subcommand::Bench {\n-                    paths: paths,\n+                    paths,\n                     test_args: matches.opt_strs(\"test-args\"),\n                 }\n             }\n@@ -297,12 +297,12 @@ Arguments:\n             }\n             \"dist\" => {\n                 Subcommand::Dist {\n-                    paths: paths,\n+                    paths,\n                 }\n             }\n             \"install\" => {\n                 Subcommand::Install {\n-                    paths: paths,\n+                    paths,\n                 }\n             }\n             _ => {\n@@ -324,7 +324,7 @@ Arguments:\n \n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n-            stage: stage,\n+            stage,\n             on_fail: matches.opt_str(\"on-fail\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n             build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n@@ -333,9 +333,9 @@ Arguments:\n             target: split(matches.opt_strs(\"target\"))\n                 .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             config: cfg_file,\n-            src: src,\n+            src,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n-            cmd: cmd,\n+            cmd,\n             incremental: matches.opt_present(\"incremental\"),\n         }\n     }"}, {"sha": "55358f2ffcb7334deda2c7e4ecde1180cdd9c7d6", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -314,19 +314,19 @@ impl Build {\n             hosts: config.hosts.clone(),\n             targets: config.targets.clone(),\n \n-            config: config,\n-            src: src,\n-            out: out,\n+            config,\n+            src,\n+            out,\n \n-            rust_info: rust_info,\n-            cargo_info: cargo_info,\n-            rls_info: rls_info,\n+            rust_info,\n+            cargo_info,\n+            rls_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n-            is_sudo: is_sudo,\n+            is_sudo,\n             ci_env: CiEnv::current(),\n             delayed_failures: Cell::new(0),\n         }\n@@ -444,7 +444,7 @@ impl Build {\n     }\n \n     /// Returns the root output directory for all Cargo output in a given stage,\n-    /// running a particular compiler, wehther or not we're building the\n+    /// running a particular compiler, whether or not we're building the\n     /// standard library, and targeting the specified architecture.\n     fn cargo_out(&self,\n                  compiler: Compiler,\n@@ -656,6 +656,16 @@ impl Build {\n         base\n     }\n \n+    /// Returns if this target should statically link the C runtime, if specified\n+    fn crt_static(&self, target: Interned<String>) -> Option<bool> {\n+        if target.contains(\"pc-windows-msvc\") {\n+            Some(true)\n+        } else {\n+            self.config.target_config.get(&target)\n+                .and_then(|t| t.crt_static)\n+        }\n+    }\n+\n     /// Returns the \"musl root\" for this `target`, if defined\n     fn musl_root(&self, target: Interned<String>) -> Option<&Path> {\n         self.config.target_config.get(&target)"}, {"sha": "5f1df1d26e27382516e6d0afc94254ae20d7076b", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -75,10 +75,10 @@ fn build_krate(build: &mut Build, krate: &str) {\n                 doc_step: format!(\"doc-crate-{}\", name),\n                 test_step: format!(\"test-crate-{}\", name),\n                 bench_step: format!(\"bench-crate-{}\", name),\n-                name: name,\n+                name,\n                 version: package.version,\n                 deps: Vec::new(),\n-                path: path,\n+                path,\n             });\n         }\n     }"}, {"sha": "67495b891f80d9bdf31c4332cc3e9bd3746014f7", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,8 +8,6 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-include config.mk\n-\n ifdef VERBOSE\n Q :=\n BOOTSTRAP_ARGS := -v"}, {"sha": "0a307e72bf61d1a2e391949eaec721eb5f77230a", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -11,7 +11,7 @@\n //! Compilation of native dependencies like LLVM.\n //!\n //! Native projects like LLVM unfortunately aren't suited just yet for\n-//! compilation in build scripts that Cargo has. This is because thie\n+//! compilation in build scripts that Cargo has. This is because the\n //! compilation takes a *very* long time but also because we don't want to\n //! compile LLVM 3 times as part of a normal bootstrap (we want it cached).\n //!"}, {"sha": "54208d8bb57a623cfada3ec171e9ed4515fb5df0", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -93,10 +93,27 @@ pub fn check(build: &mut Build) {\n     }\n \n     // Ninja is currently only used for LLVM itself.\n-    // Some Linux distros rename `ninja` to `ninja-build`.\n-    // CMake can work with either binary name.\n-    if building_llvm && build.config.ninja && cmd_finder.maybe_have(\"ninja-build\").is_none() {\n-        cmd_finder.must_have(\"ninja\");\n+    if building_llvm {\n+        if build.config.ninja {\n+            // Some Linux distros rename `ninja` to `ninja-build`.\n+            // CMake can work with either binary name.\n+            if cmd_finder.maybe_have(\"ninja-build\").is_none() {\n+                cmd_finder.must_have(\"ninja\");\n+            }\n+        }\n+\n+        // If ninja isn't enabled but we're building for MSVC then we try\n+        // doubly hard to enable it. It was realized in #43767 that the msbuild\n+        // CMake generator for MSVC doesn't respect configuration options like\n+        // disabling LLVM assertions, which can often be quite important!\n+        //\n+        // In these cases we automatically enable Ninja if we find it in the\n+        // environment.\n+        if !build.config.ninja && build.config.build.contains(\"msvc\") {\n+            if cmd_finder.maybe_have(\"ninja\").is_some() {\n+                build.config.ninja = true;\n+            }\n+        }\n     }\n \n     build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n@@ -151,8 +168,15 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n-        // Make sure musl-root is valid if specified\n+        // Make sure musl-root is valid\n         if target.contains(\"musl\") && !target.contains(\"mips\") {\n+            // If this is a native target (host is also musl) and no musl-root is given,\n+            // fall back to the system toolchain in /usr before giving up\n+            if build.musl_root(*target).is_none() && build.config.build == *target {\n+                let target = build.config.target_config.entry(target.clone())\n+                                 .or_insert(Default::default());\n+                target.musl_root = Some(\"/usr\".into());\n+            }\n             match build.musl_root(*target) {\n                 Some(root) => {\n                     if fs::metadata(root.join(\"lib/libc.a\")).is_err() {"}, {"sha": "49d07d28d3c8e17431529b02271fa4d5534c0252", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,9 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/android-base-apt-get.sh /scripts/\n RUN sh /scripts/android-base-apt-get.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n     download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip arm 9\n@@ -38,4 +35,4 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n COPY scripts/android-start-emulator.sh /scripts/\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\", \"/scripts/android-start-emulator.sh\"]\n+ENTRYPOINT [\"/scripts/android-start-emulator.sh\"]"}, {"sha": "191f8e3a2895d738e3147206ae7db9173ad26cfe", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -73,14 +73,9 @@ RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n # TODO: What is this?!\n RUN curl -O http://ftp.nl.debian.org/debian/dists/jessie/main/installer-armhf/current/images/device-tree/vexpress-v2p-ca15-tc1.dtb\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS \\\n       --target=arm-unknown-linux-gnueabihf \\\n       --qemu-armhf-rootfs=/tmp/rootfs"}, {"sha": "28caf1fb57a487acef872c34f999765814f31a7a", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,9 +13,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/emscripten.sh /scripts/\n RUN bash /scripts/emscripten.sh\n \n@@ -35,5 +32,3 @@ ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "a83bbe9c60e8df278101259ac280cf76939a243c", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -21,9 +21,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   pkg-config\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n WORKDIR /tmp\n \n COPY cross/build-rumprun.sh /tmp/\n@@ -38,6 +35,9 @@ RUN ./install-mips-musl.sh\n COPY cross/install-mipsel-musl.sh /tmp/\n RUN ./install-mipsel-musl.sh\n \n+COPY cross/install-x86_64-redox.sh /tmp/\n+RUN ./install-x86_64-redox.sh\n+\n ENV TARGETS=asmjs-unknown-emscripten\n ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n@@ -47,10 +47,12 @@ ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n+ENV TARGETS=$TARGETS,x86_64-unknown-redox\n \n ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n-    CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc\n+    CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n+    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc\n \n # Suppress some warnings in the openwrt toolchains we downloaded\n ENV STAGING_DIR=/tmp\n@@ -66,5 +68,3 @@ ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n # sccache\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "8e052c4acd28a2e8955837e8270d782231b03007", "filename": "src/ci/docker/cross/install-x86_64-redox.sh", "status": "renamed", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fcross%2Finstall-x86_64-redox.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fcross%2Finstall-x86_64-redox.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2Finstall-x86_64-redox.sh?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1,3 +1,4 @@\n+#!/bin/bash\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n@@ -8,8 +9,15 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n+# ignore-tidy-linelength\n+\n set -ex\n \n-curl -fOL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb\n-dpkg -i dumb-init_*.deb\n-rm dumb-init_*.deb\n+apt-get update\n+apt-get install -y --no-install-recommends software-properties-common apt-transport-https\n+\n+apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys AA12E97F0881517F\n+add-apt-repository -y 'deb https://static.redox-os.org/toolchain/apt /'\n+\n+apt-get update\n+apt-get install -y x86-64-unknown-redox-gcc", "previous_filename": "src/ci/docker/scripts/dumb-init.sh"}, {"sha": "9a0e45312235e6d7c737db65619acc183e6eb8ce", "filename": "src/ci/docker/disabled/aarch64-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -70,14 +70,9 @@ RUN chmod +x rootfs/etc/init.d/rcS\n COPY scripts/qemu-bare-bones-addentropy.c /tmp/addentropy.c\n RUN aarch64-linux-gnu-gcc addentropy.c -o rootfs/addentropy -static\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS \\\n       --target=aarch64-unknown-linux-gnu \\\n       --qemu-aarch64-rootfs=/tmp/rootfs"}, {"sha": "20d823a3d7338d031803b4022a6e6ed25d156c39", "filename": "src/ci/docker/disabled/dist-aarch64-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,9 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/android-base-apt-get.sh /scripts/\n RUN sh /scripts/android-base-apt-get.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n     download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip arm64 21\n@@ -28,5 +25,3 @@ ENV SCRIPT python2.7 ../x.py dist --target $HOSTS --host $HOSTS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "3435d641a13c58d4348e8582f08795d1395391a6", "filename": "src/ci/docker/disabled/dist-armv7-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,9 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/android-base-apt-get.sh /scripts/\n RUN sh /scripts/android-base-apt-get.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n     download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n@@ -46,5 +43,3 @@ ENV SCRIPT \\\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "4bb7053760f9c3ec7f8f349a6a752cded0fd1cf2", "filename": "src/ci/docker/disabled/dist-i686-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,9 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/android-base-apt-get.sh /scripts/\n RUN sh /scripts/android-base-apt-get.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n     download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n@@ -46,5 +43,3 @@ ENV SCRIPT \\\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "525b218417b67dcbb0559e9a2a4f63797e2b12d8", "filename": "src/ci/docker/disabled/dist-x86_64-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,9 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/android-base-apt-get.sh /scripts/\n RUN sh /scripts/android-base-apt-get.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n     download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip x86_64 21\n@@ -28,5 +25,3 @@ ENV SCRIPT python2.7 ../x.py dist --target $HOSTS --host $HOSTS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "ed19939545f69b6290e64844ba14cccfc9f015b9", "filename": "src/ci/docker/disabled/dist-x86_64-redox/Dockerfile", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -0,0 +1,22 @@\n+FROM ubuntu:16.04\n+\n+COPY scripts/cross-apt-packages.sh /scripts/\n+RUN sh /scripts/cross-apt-packages.sh\n+\n+COPY scripts/crosstool-ng.sh /scripts/\n+RUN sh /scripts/crosstool-ng.sh\n+\n+WORKDIR /tmp\n+COPY cross/install-x86_64-redox.sh /tmp/\n+RUN ./install-x86_64-redox.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV \\\n+    AR_x86_64_unknown_redox=x86_64-unknown-redox-ar \\\n+    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n+    CXX_x86_64_unknown_redox=x86_64-unknown-redox-g++\n+\n+ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-redox --enable-extended\n+ENV SCRIPT python2.7 ../x.py dist --target x86_64-unknown-redox"}, {"sha": "6323369421bb44fb2b527ec46d30efe7eb959795", "filename": "src/ci/docker/disabled/wasm32-exp/Dockerfile", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -15,10 +15,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   jq \\\n   bzip2\n \n-# dumb-init\n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n # emscripten\n COPY scripts/emscripten-wasm.sh /scripts/\n COPY disabled/wasm32-exp/node.sh /usr/local/bin/node\n@@ -37,6 +33,3 @@ ENV TARGETS=wasm32-experimental-emscripten\n ENV RUST_CONFIGURE_ARGS --target=$TARGETS --experimental-targets=WebAssembly\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n-\n-# init\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "7f6f8ae08827d8f88f80f1d087ccbedb34aa10a5", "filename": "src/ci/docker/disabled/wasm32/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,9 +13,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n # emscripten\n COPY scripts/emscripten.sh /scripts/\n RUN bash /scripts/emscripten.sh\n@@ -36,5 +33,3 @@ ENV TARGETS=wasm32-unknown-emscripten\n ENV RUST_CONFIGURE_ARGS --target=$TARGETS\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "841d3012125f6895ef11aab20110599f2d989833", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,11 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3\n COPY scripts/make3.sh /scripts/"}, {"sha": "a36f7fc1ac5288b6c329af7e1fceea197ac35a98", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,9 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/android-base-apt-get.sh /scripts/\n RUN sh /scripts/android-base-apt-get.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n # ndk\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n@@ -36,5 +33,3 @@ ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "ecd5090ea05fc96bed2c7587f03b0a4855fa9e48", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,11 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3\n COPY scripts/make3.sh /scripts/"}, {"sha": "5bbd17bd41420ff5552de135ea2a46b0764d81ae", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,11 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3\n COPY scripts/make3.sh /scripts/"}, {"sha": "ea9034d7178853509150f250ef0ed3a6560ad35a", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,11 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3\n COPY scripts/make3.sh /scripts/"}, {"sha": "e18cb453baf6f3282b54eb613b9be551fbc1a950", "filename": "src/ci/docker/dist-fuchsia/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -24,11 +24,6 @@ WORKDIR /tmp\n COPY dist-fuchsia/shared.sh dist-fuchsia/build-toolchain.sh dist-fuchsia/compiler-rt-dso-handle.patch /tmp/\n RUN /tmp/build-toolchain.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n "}, {"sha": "efde3ff52962c55e709c3d878e2c07b77c6f39b3", "filename": "src/ci/docker/dist-i586-gnu-i686-musl/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -20,11 +20,6 @@ WORKDIR /build/\n COPY dist-i586-gnu-i686-musl/musl-libunwind-patch.patch dist-i586-gnu-i686-musl/build-musl.sh /build/\n RUN sh /build/build-musl.sh && rm -rf /build\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n "}, {"sha": "b82d227b3ef2e8e682d02d13164240646942a11d", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -19,11 +19,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY dist-i686-freebsd/build-toolchain.sh /tmp/\n RUN /tmp/build-toolchain.sh i686\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n "}, {"sha": "a5d776af19dafce1a5c48d287c209792757c0aca", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -76,11 +76,6 @@ RUN ./build-cmake.sh\n COPY dist-i686-linux/build-headers.sh /tmp/\n RUN ./build-headers.sh\n \n-RUN curl -Lo /rustroot/dumb-init \\\n-      https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64 && \\\n-      chmod +x /rustroot/dumb-init\n-ENTRYPOINT [\"/rustroot/dumb-init\", \"--\"]\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n "}, {"sha": "94a3cf8a38201c5d4cc70821d433ae95b65d014e", "filename": "src/ci/docker/dist-mips-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -17,14 +17,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config\n \n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV HOSTS=mips-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended"}, {"sha": "0b0dfff1fe362092e2dc05389d74d2b458fadddb", "filename": "src/ci/docker/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -16,14 +16,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   pkg-config\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV HOSTS=mips64-unknown-linux-gnuabi64\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended"}, {"sha": "1810b1cdc5ab762994c7161de94dcc2314e59bba", "filename": "src/ci/docker/dist-mips64el-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -17,14 +17,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config\n \n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV HOSTS=mips64el-unknown-linux-gnuabi64\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended"}, {"sha": "f5be074847586f6ffb9ca4ed337250f96740d6c6", "filename": "src/ci/docker/dist-mipsel-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -16,14 +16,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   pkg-config\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV HOSTS=mipsel-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended"}, {"sha": "14ce3654fce7fc5011f1612984e111f13d726207", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,11 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3\n COPY scripts/make3.sh /scripts/"}, {"sha": "1f6e83e2f49e59fd2746fd04dd6f39197bad00f5", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,10 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3"}, {"sha": "d4677e180609cfcc3a1a71d8e6a3ffa641f2f0a0", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,11 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3\n COPY scripts/make3.sh /scripts/"}, {"sha": "39478e92f7c9ff097cffff8ee3ecfb1bef0750fa", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,11 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3\n COPY scripts/make3.sh /scripts/"}, {"sha": "b7c00df4db2420f1f1cfe7acf20ac1b89aad3b35", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -19,11 +19,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY dist-x86_64-freebsd/build-toolchain.sh /tmp/\n RUN /tmp/build-toolchain.sh x86_64\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n "}, {"sha": "a954fd86a2440657b6dc24121f0f5c74acf7ba3e", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -76,11 +76,6 @@ RUN ./build-cmake.sh\n COPY dist-x86_64-linux/build-headers.sh /tmp/\n RUN ./build-headers.sh\n \n-RUN curl -Lo /rustroot/dumb-init \\\n-      https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64 && \\\n-      chmod +x /rustroot/dumb-init\n-ENTRYPOINT [\"/rustroot/dumb-init\", \"--\"]\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n "}, {"sha": "91ed6bfe1f63d3300392fde5bdec6e187c5d4217", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -20,11 +20,6 @@ WORKDIR /build/\n COPY dist-x86_64-musl/build-musl.sh /build/\n RUN sh /build/build-musl.sh && rm -rf /build\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n "}, {"sha": "4fd2503c31bb6f9d07200dd379658530217de572", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -3,11 +3,6 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n # Ubuntu 16.04 (this container) ships with make 4, but something in the\n # toolchains we build below chokes on that, so go back to make 3\n COPY scripts/make3.sh /scripts/"}, {"sha": "5a83bd318c4d9f1787e662fab142c62884b21770", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,13 +14,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check"}, {"sha": "daa24e0e8186df775cb6ec56393fb50affa2652b", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,13 +14,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils\n \n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n ENV SCRIPT python2.7 ../x.py test"}, {"sha": "5eba81ff60a22a935777712d32d43305a69d6454", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -89,6 +89,7 @@ exec docker \\\n   --env TRAVIS_BRANCH \\\n   --volume \"$HOME/.cargo:/cargo\" \\\n   --volume \"$HOME/rustsrc:$HOME/rustsrc\" \\\n+  --init \\\n   --rm \\\n   rust-ci \\\n   /checkout/src/ci/run.sh"}, {"sha": "35a387221c644b3b9e6f165fa7cf7350a431ae00", "filename": "src/ci/docker/x86_64-gnu-aux/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,13 +14,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   xz-utils \\\n   pkg-config\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check-aux"}, {"sha": "95d41028595f83979f5d5f5475c9241ff92a44d4", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,14 +13,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\"}, {"sha": "786f59eb9f761640c92bea520a6d0c5ff547957e", "filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -15,14 +15,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   pkg-config\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV SCRIPT python2.7 ../x.py test distcheck\n ENV DIST_SRC 1"}, {"sha": "70390c2ac1df18a52390b0196068d054a43561f3", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,14 +13,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-full-bootstrap"}, {"sha": "d323677698cce0d0e5e85226a5b3611cd42b09b2", "filename": "src/ci/docker/x86_64-gnu-incremental/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,14 +13,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUSTFLAGS -Zincremental=/tmp/rust-incr-cache\n ENV RUST_CHECK_TARGET check"}, {"sha": "e832a2445ba146b55cc1ae7d0128f4a589a7dc31", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -16,14 +16,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   zlib1g-dev \\\n   xz-utils\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --llvm-root=/usr/lib/llvm-3.7"}, {"sha": "d2b0dd13dc2df985d46bd6d7c776e981f6b45aea", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,13 +13,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check"}, {"sha": "7570bca5906d10843e8e488de1a51487a99c7b8d", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,13 +13,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   xz-utils\n \n-COPY scripts/dumb-init.sh /scripts/\n-RUN sh /scripts/dumb-init.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n-\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-sanitizers --enable-profiler\n ENV SCRIPT python2.7 ../x.py test"}, {"sha": "d09c9e8144ed32170b7596abb145ade8b097acaf", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1 +1 @@\n-Subproject commit 6f1a03dae6bcea44976918186f2d554186b3499c\n+Subproject commit d09c9e8144ed32170b7596abb145ade8b097acaf"}, {"sha": "a4322ccb289a43cc238d4536982f184a3eec9ba7", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1 +1 @@\n-Subproject commit f570bcb681771d691aa4fdb8dfcfad1939844bf5\n+Subproject commit a4322ccb289a43cc238d4536982f184a3eec9ba7"}, {"sha": "266d429a48468371d2d90669f6a30dd659bb4bdb", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1 +1 @@\n-Subproject commit 1abfbaa70313fdf527cf799ffd9b9a096a62105c\n+Subproject commit 266d429a48468371d2d90669f6a30dd659bb4bdb"}, {"sha": "2583d350ebe11d4f6df184e238a471c27334a8b4", "filename": "src/doc/unstable-book/src/language-features/rvalue-static-promotion.md", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frvalue-static-promotion.md", "raw_url": "https://github.com/rust-lang/rust/raw/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frvalue-static-promotion.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frvalue-static-promotion.md?ref=bdb7901ec9e5784942b62a682de2e2f1a2c58e79", "patch": "@@ -1,23 +0,0 @@\n-# `rvalue_static_promotion`\n-\n-The tracking issue for this feature is: [#38865]\n-\n-[#38865]: https://github.com/rust-lang/rust/issues/38865\n-\n-------------------------\n-\n-The `rvalue_static_promotion` feature allows directly creating `'static` references to\n-constant `rvalue`s, which in particular allowing for more concise code in the common case\n-in which a `'static` reference is all that's needed.\n-\n-\n-## Examples\n-\n-```rust\n-#![feature(rvalue_static_promotion)]\n-\n-fn main() {\n-    let DEFAULT_VALUE: &'static u32 = &42;\n-    assert_eq!(*DEFAULT_VALUE, 42);\n-}\n-```"}, {"sha": "049444aa49bdd2ef90d7316c2e6d6d41bdf16f80", "filename": "src/doc/unstable-book/src/library-features/string-retain.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -0,0 +1,23 @@\n+# `string_retain`\n+\n+The tracking issue for this feature is: [#43874]\n+\n+[#43874]: https://github.com/rust-lang/rust/issues/43874\n+\n+------------------------\n+\n+Retains only the characters specified by the predicate.\n+\n+In other words, remove all characters `c` such that `f(c)` returns `false`.\n+This method operates in place and preserves the order of the retained\n+characters.\n+\n+```rust\n+#![feature(string_retain)]\n+\n+let mut s = String::from(\"f_o_ob_ar\");\n+\n+s.retain(|c| c != '_');\n+\n+assert_eq!(s, \"foobar\");\n+```"}, {"sha": "7e8fde2034640d4b033e8746590fb9d04a3ace11", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -29,7 +29,7 @@\n \n In order to avoid one-off dependencies for this task, this script uses\n a reasonably working HTML parser and the existing XPath implementation\n-from Python 2's standard library. Hopefully we won't render\n+from Python's standard library. Hopefully we won't render\n non-well-formed HTML.\n \n # Commands\n@@ -110,11 +110,17 @@\n import re\n import shlex\n from collections import namedtuple\n-from HTMLParser import HTMLParser\n+try:\n+    from html.parser import HTMLParser\n+except ImportError:\n+    from HTMLParser import HTMLParser\n from xml.etree import cElementTree as ET\n \n # &larrb;/&rarrb; are not in HTML 4 but are in HTML 5\n-from htmlentitydefs import entitydefs\n+try:\n+    from html.entities import entitydefs\n+except ImportError:\n+    from htmlentitydefs import entitydefs\n entitydefs['larrb'] = u'\\u21e4'\n entitydefs['rarrb'] = u'\\u21e5'\n entitydefs['nbsp'] = ' '\n@@ -123,6 +129,11 @@\n VOID_ELEMENTS = set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n                      'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'])\n \n+# Python 2 -> 3 compatibility\n+try:\n+    unichr\n+except NameError:\n+    unichr = chr\n \n class CustomHTMLParser(HTMLParser):\n     \"\"\"simplified HTML parser.\n@@ -184,12 +195,8 @@ def concat_multi_lines(f):\n \n         # strip the common prefix from the current line if needed\n         if lastline is not None:\n-            maxprefix = 0\n-            for i in xrange(min(len(line), len(lastline))):\n-                if line[i] != lastline[i]:\n-                    break\n-                maxprefix += 1\n-            line = line[maxprefix:].lstrip()\n+            common_prefix = os.path.commonprefix([line, lastline])\n+            line = line[len(common_prefix):].lstrip()\n \n         firstlineno = firstlineno or lineno\n         if line.endswith('\\\\'):\n@@ -213,7 +220,7 @@ def concat_multi_lines(f):\n \n \n def get_commands(template):\n-    with open(template, 'rUb') as f:\n+    with open(template, 'rU') as f:\n         for lineno, line in concat_multi_lines(f):\n             m = LINE_PATTERN.search(line)\n             if not m:\n@@ -372,7 +379,7 @@ def check_command(c, cache):\n                     cache.get_file(c.args[0])\n                     ret = True\n                 except FailedCheck as err:\n-                    cerr = err.message\n+                    cerr = str(err)\n                     ret = False\n             elif len(c.args) == 2: # @has/matches <path> <pat> = string test\n                 cerr = \"`PATTERN` did not match\"\n@@ -413,9 +420,9 @@ def check_command(c, cache):\n \n     except FailedCheck as err:\n         message = '@{}{} check failed'.format('!' if c.negated else '', c.cmd)\n-        print_err(c.lineno, c.context, err.message, message)\n+        print_err(c.lineno, c.context, str(err), message)\n     except InvalidCheck as err:\n-        print_err(c.lineno, c.context, err.message)\n+        print_err(c.lineno, c.context, str(err))\n \n def check(target, commands):\n     cache = CachedFiles(target)"}, {"sha": "d615037b632d7e3c258c3b1c5593b37f87490561", "filename": "src/etc/platform-intrinsics/powerpc.json", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -121,6 +121,41 @@\n             \"llvm\": \"vavg{0.kind}{0.data_type_short}\",\n             \"ret\": \"i(8-32)\",\n             \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"packs{0.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vpk{0.kind}{1.data_type_short}{0.kind}s\",\n+            \"ret\": \"i(8-16)\",\n+            \"args\": [\"0W\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"packsu{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vpk{1.kind}{1.data_type_short}{0.kind}s\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0Ws\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"packpx\",\n+            \"width\": [128],\n+            \"llvm\": \"vpkpx\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"s32\", \"s32\"]\n+        },\n+        {\n+            \"intrinsic\": \"unpackl{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vupkl{1.kind}{1.data_type_short}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0N\"]\n+        },\n+        {\n+            \"intrinsic\": \"unpackh{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vupkh{1.kind}{1.data_type_short}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0N\"]\n         }\n     ]\n }"}, {"sha": "1f5a28755e301ac581e2048011e4e0ff3da482ef", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1 +1 @@\n-Subproject commit 11bfb0dcf85f7aa92abd30524bb1e42e18d108c6\n+Subproject commit 1f5a28755e301ac581e2048011e4e0ff3da482ef"}, {"sha": "f14f27023249e3423cbba1cdab383d6b65a7a71c", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -110,7 +110,7 @@ impl Layout {\n \n     /// Creates a layout, bypassing all checks.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe as it does not verify that `align` is\n     /// a power-of-two that is also less than or equal to 2^31, nor\n@@ -293,7 +293,7 @@ impl Layout {\n     /// Creates a layout describing the record for `self` followed by\n     /// `next` with no additional padding between the two. Since no\n     /// padding is inserted, the alignment of `next` is irrelevant,\n-    /// and is not incoporated *at all* into the resulting layout.\n+    /// and is not incorporated *at all* into the resulting layout.\n     ///\n     /// Returns `(k, offset)`, where `k` is layout of the concatenated\n     /// record and `offset` is the relative location, in bytes, of the\n@@ -485,7 +485,7 @@ pub unsafe trait Alloc {\n     /// behavior, e.g. to ensure initialization to particular sets of\n     /// bit patterns.)\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure that `layout` has non-zero size.\n@@ -513,7 +513,7 @@ pub unsafe trait Alloc {\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure all of the following:\n@@ -528,7 +528,7 @@ pub unsafe trait Alloc {\n     ///   to allocate that block of memory.\n     unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n \n-    /// Allocator-specific method for signalling an out-of-memory\n+    /// Allocator-specific method for signaling an out-of-memory\n     /// condition.\n     ///\n     /// `oom` aborts the thread or process, optionally performing\n@@ -539,7 +539,7 @@ pub unsafe trait Alloc {\n     /// unsatisfied allocation request (signaled by an error such as\n     /// `AllocErr::Exhausted`), and wish to abandon computation rather\n     /// than attempt to recover locally. Such clients should pass the\n-    /// signalling error value back into `oom`, where the allocator\n+    /// signaling error value back into `oom`, where the allocator\n     /// may incorporate that error value into its diagnostic report\n     /// before aborting.\n     ///\n@@ -617,7 +617,7 @@ pub unsafe trait Alloc {\n     /// behavior is well-defined (though underspecified) when this\n     /// constraint is violated; further discussion below.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure all of the following:\n@@ -688,7 +688,7 @@ pub unsafe trait Alloc {\n     /// Behaves like `alloc`, but also ensures that the contents\n     /// are set to zero before being returned.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe for the same reasons that `alloc` is.\n     ///\n@@ -714,7 +714,7 @@ pub unsafe trait Alloc {\n     /// the returned block. For some `layout` inputs, like arrays, this\n     /// may include extra storage usable for additional data.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe for the same reasons that `alloc` is.\n     ///\n@@ -736,7 +736,7 @@ pub unsafe trait Alloc {\n     /// the returned block. For some `layout` inputs, like arrays, this\n     /// may include extra storage usable for additional data.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe for the same reasons that `realloc` is.\n     ///\n@@ -770,7 +770,7 @@ pub unsafe trait Alloc {\n     /// memory block referenced by `ptr` has not been transferred, and\n     /// the contents of the memory block are unaltered.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure all of the following:\n@@ -827,7 +827,7 @@ pub unsafe trait Alloc {\n     /// the memory block has not been transferred, and the contents of\n     /// the memory block are unaltered.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure all of the following:\n@@ -920,7 +920,7 @@ pub unsafe trait Alloc {\n     ///\n     /// Captures a common usage pattern for allocators.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure both:\n@@ -993,7 +993,7 @@ pub unsafe trait Alloc {\n     /// The returned block is suitable for passing to the\n     /// `alloc`/`realloc` methods of this allocator.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure all of the following:\n@@ -1037,7 +1037,7 @@ pub unsafe trait Alloc {\n     ///\n     /// Captures a common usage pattern for allocators.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure both:"}, {"sha": "d734ae6a2cf61b2184bba55d315bff8024a7ea3a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 296, "deletions": 6, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -16,16 +16,13 @@\n //!\n //! [arc]: struct.Arc.html\n \n-use boxed::Box;\n-\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n use core::intrinsics::abort;\n-use core::mem;\n-use core::mem::uninitialized;\n+use core::mem::{self, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n@@ -34,7 +31,10 @@ use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n \n-use heap::{Heap, Alloc, Layout};\n+use heap::{Heap, Alloc, Layout, box_free};\n+use boxed::Box;\n+use string::String;\n+use vec::Vec;\n \n /// A soft limit on the amount of references that may be made to an `Arc`.\n ///\n@@ -278,7 +278,7 @@ impl<T> Arc<T> {\n         let x: Box<_> = box ArcInner {\n             strong: atomic::AtomicUsize::new(1),\n             weak: atomic::AtomicUsize::new(1),\n-            data: data,\n+            data,\n         };\n         Arc { ptr: Shared::from(Box::into_unique(x)) }\n     }\n@@ -532,6 +532,141 @@ impl<T: ?Sized> Arc<T> {\n     }\n }\n \n+impl<T: ?Sized> Arc<T> {\n+    // Allocates an `ArcInner<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n+        // Create a fake ArcInner to find allocation size and alignment\n+        let fake_ptr = ptr as *mut ArcInner<T>;\n+\n+        let layout = Layout::for_value(&*fake_ptr);\n+\n+        let mem = Heap.alloc(layout)\n+            .unwrap_or_else(|e| Heap.oom(e));\n+\n+        // Initialize the real ArcInner\n+        let inner = set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>;\n+\n+        ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n+        ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+\n+        inner\n+    }\n+\n+    fn from_box(v: Box<T>) -> Arc<T> {\n+        unsafe {\n+            let bptr = Box::into_raw(v);\n+\n+            let value_size = size_of_val(&*bptr);\n+            let ptr = Self::allocate_for_ptr(bptr);\n+\n+            // Copy value as bytes\n+            ptr::copy_nonoverlapping(\n+                bptr as *const T as *const u8,\n+                &mut (*ptr).data as *mut _ as *mut u8,\n+                value_size);\n+\n+            // Free the allocation without dropping its contents\n+            box_free(bptr);\n+\n+            Arc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+// Sets the data pointer of a `?Sized` raw pointer.\n+//\n+// For a slice/trait object, this sets the `data` field and leaves the rest\n+// unchanged. For a sized raw pointer, this simply sets the pointer.\n+unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n+    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    ptr\n+}\n+\n+impl<T> Arc<[T]> {\n+    // Copy elements from slice into newly allocated Arc<[T]>\n+    //\n+    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n+        let v_ptr = v as *const [T];\n+        let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+        ptr::copy_nonoverlapping(\n+            v.as_ptr(),\n+            &mut (*ptr).data as *mut [T] as *mut T,\n+            v.len());\n+\n+        Arc { ptr: Shared::new_unchecked(ptr) }\n+    }\n+}\n+\n+// Specialization trait used for From<&[T]>\n+trait ArcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        // Panic guard while cloning T elements.\n+        // In the event of a panic, elements that have been written\n+        // into the new ArcInner will be dropped, then the memory freed.\n+        struct Guard<T> {\n+            mem: *mut u8,\n+            elems: *mut T,\n+            layout: Layout,\n+            n_elems: usize,\n+        }\n+\n+        impl<T> Drop for Guard<T> {\n+            fn drop(&mut self) {\n+                use core::slice::from_raw_parts_mut;\n+\n+                unsafe {\n+                    let slice = from_raw_parts_mut(self.elems, self.n_elems);\n+                    ptr::drop_in_place(slice);\n+\n+                    Heap.dealloc(self.mem, self.layout.clone());\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            let v_ptr = v as *const [T];\n+            let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n+\n+            // Pointer to first element\n+            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n+\n+            let mut guard = Guard{\n+                mem: mem,\n+                elems: elems,\n+                layout: layout,\n+                n_elems: 0,\n+            };\n+\n+            for (i, item) in v.iter().enumerate() {\n+                ptr::write(elems.offset(i as isize), item.clone());\n+                guard.n_elems += 1;\n+            }\n+\n+            // All clear. Forget the guard so it doesn't free the new ArcInner.\n+            mem::forget(guard);\n+\n+            Arc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    fn from_slice(v: &[T]) -> Self {\n+        unsafe { Arc::copy_from_slice(v) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc` pointer.\n@@ -1216,8 +1351,56 @@ impl<T> From<T> for Arc<T> {\n     }\n }\n \n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Arc<[T]> {\n+    #[inline]\n+    fn from(v: &[T]) -> Arc<[T]> {\n+        <Self as ArcFromSlice<T>>::from_slice(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a> From<&'a str> for Arc<str> {\n+    #[inline]\n+    fn from(v: &str) -> Arc<str> {\n+        unsafe { mem::transmute(<Arc<[u8]>>::from(v.as_bytes())) }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl From<String> for Arc<str> {\n+    #[inline]\n+    fn from(v: String) -> Arc<str> {\n+        Arc::from(&v[..])\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T: ?Sized> From<Box<T>> for Arc<T> {\n+    #[inline]\n+    fn from(v: Box<T>) -> Arc<T> {\n+        Arc::from_box(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T> From<Vec<T>> for Arc<[T]> {\n+    #[inline]\n+    fn from(mut v: Vec<T>) -> Arc<[T]> {\n+        unsafe {\n+            let arc = Arc::copy_from_slice(&v);\n+\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+\n+            arc\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n+    use std::boxed::Box;\n     use std::clone::Clone;\n     use std::sync::mpsc::channel;\n     use std::mem::drop;\n@@ -1520,6 +1703,113 @@ mod tests {\n         }\n         t.join().unwrap();\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        let r: Arc<str> = Arc::from(\"foo\");\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_copy_from_slice() {\n+        let s: &[u32] = &[1, 2, 3];\n+        let r: Arc<[u32]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_clone_from_slice() {\n+        #[derive(Clone, Debug, Eq, PartialEq)]\n+        struct X(u32);\n+\n+        let s: &[X] = &[X(1), X(2), X(3)];\n+        let r: Arc<[X]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], s);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_clone_from_slice_panic() {\n+        use std::string::{String, ToString};\n+\n+        struct Fail(u32, String);\n+\n+        impl Clone for Fail {\n+            fn clone(&self) -> Fail {\n+                if self.0 == 2 {\n+                    panic!();\n+                }\n+                Fail(self.0, self.1.clone())\n+            }\n+        }\n+\n+        let s: &[Fail] = &[\n+            Fail(0, \"foo\".to_string()),\n+            Fail(1, \"bar\".to_string()),\n+            Fail(2, \"baz\".to_string()),\n+        ];\n+\n+        // Should panic, but not cause memory corruption\n+        let _r: Arc<[Fail]> = Arc::from(s);\n+    }\n+\n+    #[test]\n+    fn test_from_box() {\n+        let b: Box<u32> = box 123;\n+        let r: Arc<u32> = Arc::from(b);\n+\n+        assert_eq!(*r, 123);\n+    }\n+\n+    #[test]\n+    fn test_from_box_str() {\n+        use std::string::String;\n+\n+        let s = String::from(\"foo\").into_boxed_str();\n+        let r: Arc<str> = Arc::from(s);\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_slice() {\n+        let s = vec![1, 2, 3].into_boxed_slice();\n+        let r: Arc<[u32]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let b: Box<Display> = box 123;\n+        let r: Arc<Display> = Arc::from(b);\n+\n+        assert_eq!(r.to_string(), \"123\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait_zero_sized() {\n+        use std::fmt::Debug;\n+\n+        let b: Box<Debug> = box ();\n+        let r: Arc<Debug> = Arc::from(b);\n+\n+        assert_eq!(format!(\"{:?}\", r), \"()\");\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let v = vec![1, 2, 3];\n+        let r: Arc<[u32]> = Arc::from(v);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "57640af816a57a3308e0e4a4d136d5f8a9b6ad6d", "filename": "src/liballoc/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -853,9 +853,9 @@ impl<'a, T> Hole<'a, T> {\n         debug_assert!(pos < data.len());\n         let elt = ptr::read(&data[pos]);\n         Hole {\n-            data: data,\n+            data,\n             elt: Some(elt),\n-            pos: pos,\n+            pos,\n         }\n     }\n \n@@ -1203,7 +1203,7 @@ where T: Clone + Ord {\n         let place = Placer::make_place(self.data.place_back());\n         BinaryHeapPlace {\n             heap: ptr,\n-            place: place,\n+            place,\n         }\n     }\n }"}, {"sha": "82aac4dbf63346fa2897e215df8b329faf34a7ee", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -169,7 +169,7 @@ fn make_place<T>() -> IntermediateBox<T> {\n \n     IntermediateBox {\n         ptr: p,\n-        layout: layout,\n+        layout,\n         marker: marker::PhantomData,\n     }\n }\n@@ -633,7 +633,7 @@ impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n /// that `FnBox` may be deprecated in the future if `Box<FnOnce()>`\n /// closures become directly usable.)\n ///\n-/// ### Example\n+/// # Examples\n ///\n /// Here is a snippet of code which creates a hashmap full of boxed\n /// once closures and then removes them one by one, calling each"}, {"sha": "f733c3332e282e402f17fce6bafa6d1adf856919", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -234,7 +234,7 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => {\n                 Some(OccupiedEntry {\n-                         handle: handle,\n+                         handle,\n                          length: &mut self.length,\n                          _marker: PhantomData,\n                      }\n@@ -250,8 +250,8 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry {\n-                    key: key,\n-                    handle: handle,\n+                    key,\n+                    handle,\n                     length: &mut self.length,\n                     _marker: PhantomData,\n                 }\n@@ -695,7 +695,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => {\n                 Some(OccupiedEntry {\n-                         handle: handle,\n+                         handle,\n                          length: &mut self.length,\n                          _marker: PhantomData,\n                      }\n@@ -866,15 +866,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         match search::search_tree(self.root.as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry {\n-                    handle: handle,\n+                    handle,\n                     length: &mut self.length,\n                     _marker: PhantomData,\n                 })\n             }\n             GoDown(handle) => {\n                 Vacant(VacantEntry {\n-                    key: key,\n-                    handle: handle,\n+                    key,\n+                    handle,\n                     length: &mut self.length,\n                     _marker: PhantomData,\n                 })"}, {"sha": "c1618043ce66fca8f1ffc0ee9f93287b538fb708", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -763,7 +763,7 @@ impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n }\n \n impl<Node, Type> Handle<Node, Type> {\n-    /// Retrieves the node that contains the edge of key/value pair this handle pointes to.\n+    /// Retrieves the node that contains the edge of key/value pair this handle points to.\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n@@ -776,8 +776,8 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n         debug_assert!(idx < node.len());\n \n         Handle {\n-            node: node,\n-            idx: idx,\n+            node,\n+            idx,\n             _marker: PhantomData\n         }\n     }\n@@ -850,8 +850,8 @@ impl<BorrowType, K, V, NodeType>\n         debug_assert!(idx <= node.len());\n \n         Handle {\n-            node: node,\n-            idx: idx,\n+            node,\n+            idx,\n             _marker: PhantomData\n         }\n     }\n@@ -1149,7 +1149,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             let mut new_root = Root {\n                 node: BoxedNode::from_internal(new_node),\n-                height: height\n+                height,\n             };\n \n             for i in 0..(new_len+1) {\n@@ -1449,12 +1449,12 @@ impl<BorrowType, K, V, HandleType>\n     > {\n         match self.node.force() {\n             ForceResult::Leaf(node) => ForceResult::Leaf(Handle {\n-                node: node,\n+                node,\n                 idx: self.idx,\n                 _marker: PhantomData\n             }),\n             ForceResult::Internal(node) => ForceResult::Internal(Handle {\n-                node: node,\n+                node,\n                 idx: self.idx,\n                 _marker: PhantomData\n             })"}, {"sha": "578d90c5ba9bbb413d982bc5e5ce3204d376998c", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -211,7 +211,7 @@\n //!\n //! - [`fmt::Display`][`Display`] implementations assert that the type can be faithfully\n //!   represented as a UTF-8 string at all times. It is **not** expected that\n-//!   all types implement the `Display` trait.\n+//!   all types implement the [`Display`] trait.\n //! - [`fmt::Debug`][`Debug`] implementations should be implemented for **all** public types.\n //!   Output will typically represent the internal state as faithfully as possible.\n //!   The purpose of the [`Debug`] trait is to facilitate debugging Rust code. In"}, {"sha": "2d41ed648102b2159f2341bfb2312fdc2a6fb223", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -60,8 +60,6 @@\n //! The [`heap`](heap/index.html) module defines the low-level interface to the\n //! default global allocator. It is not compatible with the libc allocator API.\n \n-#![crate_name = \"alloc\"]\n-#![crate_type = \"rlib\"]\n #![allow(unused_attributes)]\n #![unstable(feature = \"alloc\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n@@ -121,7 +119,7 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n \n-#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol))]\n+#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice))]\n #![cfg_attr(test, feature(test, box_heap))]\n \n // Allow testing this library"}, {"sha": "f9512cbe977a41f942031f7fc9ee7051f3157273", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -140,7 +140,7 @@ impl<T> Node<T> {\n         Node {\n             next: None,\n             prev: None,\n-            element: element,\n+            element,\n         }\n     }\n \n@@ -924,7 +924,7 @@ impl<'a, T> IterMut<'a, T> {\n                 let node = Some(Shared::from(Box::into_unique(box Node {\n                     next: Some(head),\n                     prev: Some(prev),\n-                    element: element,\n+                    element,\n                 })));\n \n                 prev.as_mut().next = node;"}, {"sha": "841f9dc64142e3528f01c2cd6b29c6dd5cb6b899", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -60,8 +60,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n         // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n         RawVec {\n             ptr: Unique::empty(),\n-            cap: cap,\n-            a: a,\n+            cap,\n+            a,\n         }\n     }\n \n@@ -104,8 +104,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             RawVec {\n                 ptr: Unique::new_unchecked(ptr as *mut _),\n-                cap: cap,\n-                a: a,\n+                cap,\n+                a,\n             }\n         }\n     }\n@@ -159,8 +159,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, cap: usize, a: A) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n-            cap: cap,\n-            a: a,\n+            cap,\n+            a,\n         }\n     }\n }\n@@ -176,7 +176,7 @@ impl<T> RawVec<T, Heap> {\n     pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n-            cap: cap,\n+            cap,\n             a: Heap,\n         }\n     }\n@@ -544,12 +544,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n-    /// space to get amortized `O(1)` behaviour. Will limit this behaviour\n+    /// space to get amortized `O(1)` behavior. Will limit this behaviour\n     /// if it would needlessly cause itself to panic.\n     ///\n     /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behaviour of this function may break.\n+    /// code *you* write that relies on the behavior of this function may break.\n     ///\n     /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n     ///"}, {"sha": "47f537caf31c45bddb197416b706b5c177cdd8dc", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 292, "deletions": 61, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -252,14 +252,15 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n-use core::mem::{self, forget, size_of, size_of_val, uninitialized};\n+use core::mem::{self, forget, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n use core::convert::From;\n \n use heap::{Heap, Alloc, Layout, box_free};\n-use raw_vec::RawVec;\n+use string::String;\n+use vec::Vec;\n \n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n@@ -311,7 +312,7 @@ impl<T> Rc<T> {\n             ptr: Shared::from(Box::into_unique(box RcBox {\n                 strong: Cell::new(1),\n                 weak: Cell::new(1),\n-                value: value,\n+                value,\n             })),\n         }\n     }\n@@ -421,64 +422,6 @@ impl<T> Rc<T> {\n     }\n }\n \n-impl Rc<str> {\n-    /// Constructs a new `Rc<str>` from a string slice.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"rustc_private\",\n-               reason = \"for internal use in rustc\",\n-               issue = \"27812\")]\n-    pub fn __from_str(value: &str) -> Rc<str> {\n-        unsafe {\n-            // Allocate enough space for `RcBox<str>`.\n-            let aligned_len = 2 + (value.len() + size_of::<usize>() - 1) / size_of::<usize>();\n-            let vec = RawVec::<usize>::with_capacity(aligned_len);\n-            let ptr = vec.ptr();\n-            forget(vec);\n-            // Initialize fields of `RcBox<str>`.\n-            *ptr.offset(0) = 1; // strong: Cell::new(1)\n-            *ptr.offset(1) = 1; // weak: Cell::new(1)\n-            ptr::copy_nonoverlapping(value.as_ptr(), ptr.offset(2) as *mut u8, value.len());\n-            // Combine the allocation address and the string length into a fat pointer to `RcBox`.\n-            let rcbox_ptr: *mut RcBox<str> = mem::transmute([ptr as usize, value.len()]);\n-            assert!(aligned_len * size_of::<usize>() == size_of_val(&*rcbox_ptr));\n-            Rc { ptr: Shared::new_unchecked(rcbox_ptr) }\n-        }\n-    }\n-}\n-\n-impl<T> Rc<[T]> {\n-    /// Constructs a new `Rc<[T]>` from a `Box<[T]>`.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"rustc_private\",\n-               reason = \"for internal use in rustc\",\n-               issue = \"27812\")]\n-    pub fn __from_array(value: Box<[T]>) -> Rc<[T]> {\n-        unsafe {\n-            let ptr: *mut RcBox<[T]> =\n-                mem::transmute([mem::align_of::<RcBox<[T; 1]>>(), value.len()]);\n-            // FIXME(custom-DST): creating this invalid &[T] is dubiously defined,\n-            // we should have a better way of getting the size/align\n-            // of a DST from its unsized part.\n-            let ptr = Heap.alloc(Layout::for_value(&*ptr))\n-                .unwrap_or_else(|e| Heap.oom(e));\n-            let ptr: *mut RcBox<[T]> = mem::transmute([ptr as usize, value.len()]);\n-\n-            // Initialize the new RcBox.\n-            ptr::write(&mut (*ptr).strong, Cell::new(1));\n-            ptr::write(&mut (*ptr).weak, Cell::new(1));\n-            ptr::copy_nonoverlapping(\n-                value.as_ptr(),\n-                &mut (*ptr).value as *mut [T] as *mut T,\n-                value.len());\n-\n-            // Free the original allocation without freeing its (moved) contents.\n-            box_free(Box::into_raw(value));\n-\n-            Rc { ptr: Shared::new_unchecked(ptr as *mut _) }\n-        }\n-    }\n-}\n-\n impl<T: ?Sized> Rc<T> {\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///\n@@ -665,6 +608,140 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n+impl<T: ?Sized> Rc<T> {\n+    // Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n+        // Create a fake RcBox to find allocation size and alignment\n+        let fake_ptr = ptr as *mut RcBox<T>;\n+\n+        let layout = Layout::for_value(&*fake_ptr);\n+\n+        let mem = Heap.alloc(layout)\n+            .unwrap_or_else(|e| Heap.oom(e));\n+\n+        // Initialize the real RcBox\n+        let inner = set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>;\n+\n+        ptr::write(&mut (*inner).strong, Cell::new(1));\n+        ptr::write(&mut (*inner).weak, Cell::new(1));\n+\n+        inner\n+    }\n+\n+    fn from_box(v: Box<T>) -> Rc<T> {\n+        unsafe {\n+            let bptr = Box::into_raw(v);\n+\n+            let value_size = size_of_val(&*bptr);\n+            let ptr = Self::allocate_for_ptr(bptr);\n+\n+            // Copy value as bytes\n+            ptr::copy_nonoverlapping(\n+                bptr as *const T as *const u8,\n+                &mut (*ptr).value as *mut _ as *mut u8,\n+                value_size);\n+\n+            // Free the allocation without dropping its contents\n+            box_free(bptr);\n+\n+            Rc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+// Sets the data pointer of a `?Sized` raw pointer.\n+//\n+// For a slice/trait object, this sets the `data` field and leaves the rest\n+// unchanged. For a sized raw pointer, this simply sets the pointer.\n+unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n+    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    ptr\n+}\n+\n+impl<T> Rc<[T]> {\n+    // Copy elements from slice into newly allocated Rc<[T]>\n+    //\n+    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n+        let v_ptr = v as *const [T];\n+        let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+        ptr::copy_nonoverlapping(\n+            v.as_ptr(),\n+            &mut (*ptr).value as *mut [T] as *mut T,\n+            v.len());\n+\n+        Rc { ptr: Shared::new_unchecked(ptr) }\n+    }\n+}\n+\n+trait RcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        // Panic guard while cloning T elements.\n+        // In the event of a panic, elements that have been written\n+        // into the new RcBox will be dropped, then the memory freed.\n+        struct Guard<T> {\n+            mem: *mut u8,\n+            elems: *mut T,\n+            layout: Layout,\n+            n_elems: usize,\n+        }\n+\n+        impl<T> Drop for Guard<T> {\n+            fn drop(&mut self) {\n+                use core::slice::from_raw_parts_mut;\n+\n+                unsafe {\n+                    let slice = from_raw_parts_mut(self.elems, self.n_elems);\n+                    ptr::drop_in_place(slice);\n+\n+                    Heap.dealloc(self.mem, self.layout.clone());\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            let v_ptr = v as *const [T];\n+            let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n+\n+            // Pointer to first element\n+            let elems = &mut (*ptr).value as *mut [T] as *mut T;\n+\n+            let mut guard = Guard{\n+                mem: mem,\n+                elems: elems,\n+                layout: layout,\n+                n_elems: 0,\n+            };\n+\n+            for (i, item) in v.iter().enumerate() {\n+                ptr::write(elems.offset(i as isize), item.clone());\n+                guard.n_elems += 1;\n+            }\n+\n+            // All clear. Forget the guard so it doesn't free the new RcBox.\n+            forget(guard);\n+\n+            Rc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+impl<T: Copy> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    fn from_slice(v: &[T]) -> Self {\n+        unsafe { Rc::copy_from_slice(v) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Rc<T> {\n     type Target = T;\n@@ -959,6 +1036,53 @@ impl<T> From<T> for Rc<T> {\n     }\n }\n \n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Rc<[T]> {\n+    #[inline]\n+    fn from(v: &[T]) -> Rc<[T]> {\n+        <Self as RcFromSlice<T>>::from_slice(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a> From<&'a str> for Rc<str> {\n+    #[inline]\n+    fn from(v: &str) -> Rc<str> {\n+        unsafe { mem::transmute(<Rc<[u8]>>::from(v.as_bytes())) }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl From<String> for Rc<str> {\n+    #[inline]\n+    fn from(v: String) -> Rc<str> {\n+        Rc::from(&v[..])\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T: ?Sized> From<Box<T>> for Rc<T> {\n+    #[inline]\n+    fn from(v: Box<T>) -> Rc<T> {\n+        Rc::from_box(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T> From<Vec<T>> for Rc<[T]> {\n+    #[inline]\n+    fn from(mut v: Vec<T>) -> Rc<[T]> {\n+        unsafe {\n+            let rc = Rc::copy_from_slice(&v);\n+\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+\n+            rc\n+        }\n+    }\n+}\n+\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n@@ -1465,6 +1589,113 @@ mod tests {\n         assert!(Rc::ptr_eq(&five, &same_five));\n         assert!(!Rc::ptr_eq(&five, &other_five));\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        let r: Rc<str> = Rc::from(\"foo\");\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_copy_from_slice() {\n+        let s: &[u32] = &[1, 2, 3];\n+        let r: Rc<[u32]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_clone_from_slice() {\n+        #[derive(Clone, Debug, Eq, PartialEq)]\n+        struct X(u32);\n+\n+        let s: &[X] = &[X(1), X(2), X(3)];\n+        let r: Rc<[X]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], s);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_clone_from_slice_panic() {\n+        use std::string::{String, ToString};\n+\n+        struct Fail(u32, String);\n+\n+        impl Clone for Fail {\n+            fn clone(&self) -> Fail {\n+                if self.0 == 2 {\n+                    panic!();\n+                }\n+                Fail(self.0, self.1.clone())\n+            }\n+        }\n+\n+        let s: &[Fail] = &[\n+            Fail(0, \"foo\".to_string()),\n+            Fail(1, \"bar\".to_string()),\n+            Fail(2, \"baz\".to_string()),\n+        ];\n+\n+        // Should panic, but not cause memory corruption\n+        let _r: Rc<[Fail]> = Rc::from(s);\n+    }\n+\n+    #[test]\n+    fn test_from_box() {\n+        let b: Box<u32> = box 123;\n+        let r: Rc<u32> = Rc::from(b);\n+\n+        assert_eq!(*r, 123);\n+    }\n+\n+    #[test]\n+    fn test_from_box_str() {\n+        use std::string::String;\n+\n+        let s = String::from(\"foo\").into_boxed_str();\n+        let r: Rc<str> = Rc::from(s);\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_slice() {\n+        let s = vec![1, 2, 3].into_boxed_slice();\n+        let r: Rc<[u32]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let b: Box<Display> = box 123;\n+        let r: Rc<Display> = Rc::from(b);\n+\n+        assert_eq!(r.to_string(), \"123\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait_zero_sized() {\n+        use std::fmt::Debug;\n+\n+        let b: Box<Debug> = box ();\n+        let r: Rc<Debug> = Rc::from(b);\n+\n+        assert_eq!(format!(\"{:?}\", r), \"()\");\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let v = vec![1, 2, 3];\n+        let r: Rc<[u32]> = Rc::from(v);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "7787ace944119861181c671b805688ae763174be", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -171,7 +171,7 @@ mod hack {\n impl<T> [T] {\n     /// Returns the number of elements in the slice.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let a = [1, 2, 3];\n@@ -185,7 +185,7 @@ impl<T> [T] {\n \n     /// Returns `true` if the slice has a length of 0.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let a = [1, 2, 3];\n@@ -523,7 +523,7 @@ impl<T> [T] {\n \n     /// Reverses the order of elements in the slice, in place.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut v = [1, 2, 3];\n@@ -580,7 +580,7 @@ impl<T> [T] {\n     ///\n     /// Panics if `size` is 0.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let slice = ['r', 'u', 's', 't'];\n@@ -613,7 +613,7 @@ impl<T> [T] {\n     ///\n     /// Panics if `size` is 0.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let slice = ['l', 'o', 'r', 'e', 'm'];\n@@ -1040,7 +1040,7 @@ impl<T> [T] {\n     /// `Err` is returned, containing the index where a matching\n     /// element could be inserted while maintaining sorted order.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// Looks up a series of four elements. The first is found, with a\n     /// uniquely determined position; the second and third are not\n@@ -1074,7 +1074,7 @@ impl<T> [T] {\n     /// `Err` is returned, containing the index where a matching\n     /// element could be inserted while maintaining sorted order.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// Looks up a series of four elements. The first is found, with a\n     /// uniquely determined position; the second and third are not\n@@ -1419,7 +1419,7 @@ impl<T> [T] {\n     ///\n     /// This function will panic if the two slices have different lengths.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut dst = [0, 0, 0];\n@@ -1445,7 +1445,7 @@ impl<T> [T] {\n     ///\n     /// This function will panic if the two slices have different lengths.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// let mut dst = [0, 0, 0];\n@@ -1461,6 +1461,31 @@ impl<T> [T] {\n         core_slice::SliceExt::copy_from_slice(self, src)\n     }\n \n+    /// Swaps all elements in `self` with those in `src`.\n+    ///\n+    /// The length of `src` must be the same as `self`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(swap_with_slice)]\n+    ///\n+    /// let mut src = [1, 2, 3];\n+    /// let mut dst = [7, 8, 9];\n+    ///\n+    /// src.swap_with_slice(&mut dst);\n+    /// assert_eq!(src, [7, 8, 9]);\n+    /// assert_eq!(dst, [1, 2, 3]);\n+    /// ```\n+    #[unstable(feature = \"swap_with_slice\", issue = \"44030\")]\n+    pub fn swap_with_slice(&mut self, src: &mut [T]) {\n+        core_slice::SliceExt::swap_with_slice(self, src)\n+    }\n+\n     /// Copies `self` into a new `Vec`.\n     ///\n     /// # Examples\n@@ -1886,7 +1911,7 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n \n         // Push this run onto the stack.\n         runs.push(Run {\n-            start: start,\n+            start,\n             len: end - start,\n         });\n         end = start;"}, {"sha": "79b2bbce2af7cf13e59ad095572ce3a4e6b2d54a", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1714,7 +1714,7 @@ impl str {\n     ///\n     /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// Basic usage\n     ///"}, {"sha": "b1919c7c968c9bdda239c74ce22a2c64fd69aebe", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 99, "deletions": 38, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -38,7 +38,7 @@\n //! let message = s + \" world!\";\n //! ```\n //!\n-//! If you have a vector of valid UTF-8 bytes, you can make a `String` out of\n+//! If you have a vector of valid UTF-8 bytes, you can make a [`String`] out of\n //! it. You can do the reverse too.\n //!\n //! ```\n@@ -82,7 +82,7 @@ use boxed::Box;\n ///\n /// # Examples\n ///\n-/// You can create a `String` from a literal string with `String::from`:\n+/// You can create a `String` from a literal string with [`String::from`]:\n ///\n /// ```\n /// let hello = String::from(\"Hello, world!\");\n@@ -98,6 +98,7 @@ use boxed::Box;\n /// hello.push_str(\"orld!\");\n /// ```\n ///\n+/// [`String::from`]: #method.from\n /// [`char`]: ../../std/primitive.char.html\n /// [`push`]: #method.push\n /// [`push_str`]: #method.push_str\n@@ -155,17 +156,14 @@ use boxed::Box;\n /// takes_str(&s);\n /// ```\n ///\n-/// [`&str`]: ../../std/primitive.str.html\n-/// [`Deref`]: ../../std/ops/trait.Deref.html\n-///\n /// This will create a [`&str`] from the `String` and pass it in. This\n /// conversion is very inexpensive, and so generally, functions will accept\n /// [`&str`]s as arguments unless they need a `String` for some specific\n /// reason.\n ///\n /// In certain cases Rust doesn't have enough information to make this\n-/// conversion, known as `Deref` coercion. In the following example a string\n-/// slice `&'a str` implements the trait `TraitExample`, and the function\n+/// conversion, known as [`Deref`] coercion. In the following example a string\n+/// slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function\n /// `example_func` takes anything that implements the trait. In this case Rust\n /// would need to make two implicit conversions, which Rust doesn't have the\n /// means to do. For that reason, the following example will not compile.\n@@ -185,13 +183,13 @@ use boxed::Box;\n ///\n /// There are two options that would work instead. The first would be to\n /// change the line `example_func(&example_string);` to\n-/// `example_func(example_string.as_str());`, using the method `as_str()`\n+/// `example_func(example_string.as_str());`, using the method [`as_str()`]\n /// to explicitly extract the string slice containing the string. The second\n /// way changes `example_func(&example_string);` to\n /// `example_func(&*example_string);`. In this case we are dereferencing a\n-/// `String` to a `str`, then referencing the `str` back to `&str`. The\n-/// second way is more idiomatic, however both work to do the conversion\n-/// explicitly rather than relying on the implicit conversion.\n+/// `String` to a [`str`][`&str`], then referencing the [`str`][`&str`] back to\n+/// [`&str`]. The second way is more idiomatic, however both work to do the\n+/// conversion explicitly rather than relying on the implicit conversion.\n ///\n /// # Representation\n ///\n@@ -287,6 +285,10 @@ use boxed::Box;\n /// ```\n ///\n /// Here, there's no need to allocate more memory inside the loop.\n+///\n+/// [`&str`]: ../../std/primitive.str.html\n+/// [`Deref`]: ../../std/ops/trait.Deref.html\n+/// [`as_str()`]: struct.String.html#method.as_str\n #[derive(PartialOrd, Eq, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct String {\n@@ -443,32 +445,22 @@ impl String {\n     /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n     /// the bytes are valid UTF-8, and then does the conversion.\n     ///\n-    /// [`&str`]: ../../std/primitive.str.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n-    ///\n     /// If you are sure that the byte slice is valid UTF-8, and you don't want\n     /// to incur the overhead of the validity check, there is an unsafe version\n     /// of this function, [`from_utf8_unchecked`], which has the same behavior\n     /// but skips the check.\n     ///\n-    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n-    ///\n     /// This method will take care to not copy the vector, for efficiency's\n     /// sake.\n     ///\n-    /// If you need a `&str` instead of a `String`, consider\n+    /// If you need a [`&str`] instead of a `String`, consider\n     /// [`str::from_utf8`].\n     ///\n-    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n-    ///\n     /// The inverse of this method is [`as_bytes`].\n     ///\n-    /// [`as_bytes`]: #method.as_bytes\n-    ///\n     /// # Errors\n     ///\n-    /// Returns `Err` if the slice is not UTF-8 with a description as to why the\n+    /// Returns [`Err`] if the slice is not UTF-8 with a description as to why the\n     /// provided bytes are not UTF-8. The vector you moved in is also included.\n     ///\n     /// # Examples\n@@ -497,7 +489,14 @@ impl String {\n     /// See the docs for [`FromUtf8Error`] for more details on what you can do\n     /// with this error.\n     ///\n+    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n+    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`u8`]: ../../std/primitive.u8.html\n+    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n+    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n+    /// [`as_bytes`]: struct.String.html#method.as_bytes\n     /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n+    /// [`Err`]: ../../stdresult/enum.Result.html#variant.Err\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n@@ -594,9 +593,11 @@ impl String {\n         Cow::Owned(res)\n     }\n \n-    /// Decode a UTF-16 encoded vector `v` into a `String`, returning `Err`\n+    /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n     /// if `v` contains any invalid data.\n     ///\n+    /// [`Err`]: ../../std/result/enum.Result.htlm#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -618,7 +619,7 @@ impl String {\n         decode_utf16(v.iter().cloned()).collect::<Result<_, _>>().map_err(|_| FromUtf16Error(()))\n     }\n \n-    /// Decode a UTF-16 encoded vector `v` into a string, replacing\n+    /// Decode a UTF-16 encoded slice `v` into a `String`, replacing\n     /// invalid data with the replacement character (U+FFFD).\n     ///\n     /// # Examples\n@@ -800,11 +801,12 @@ impl String {\n     /// If you do not want this \"at least\" behavior, see the [`reserve_exact`]\n     /// method.\n     ///\n-    /// [`reserve_exact`]: #method.reserve_exact\n-    ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `usize`.\n+    /// Panics if the new capacity overflows [`usize`].\n+    ///\n+    /// [`reserve_exact`]: struct.String.html#method.reserve_exact\n+    /// [`usize`]: ../../std/primitive.usize.html\n     ///\n     /// # Examples\n     ///\n@@ -909,7 +911,9 @@ impl String {\n         self.vec.shrink_to_fit()\n     }\n \n-    /// Appends the given `char` to the end of this `String`.\n+    /// Appends the given [`char`] to the end of this `String`.\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n     ///\n     /// # Examples\n     ///\n@@ -990,7 +994,9 @@ impl String {\n \n     /// Removes the last character from the string buffer and returns it.\n     ///\n-    /// Returns `None` if this `String` is empty.\n+    /// Returns [`None`] if this `String` is empty.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1019,7 +1025,7 @@ impl String {\n         Some(ch)\n     }\n \n-    /// Removes a `char` from this `String` at a byte position and returns it.\n+    /// Removes a [`char`] from this `String` at a byte position and returns it.\n     ///\n     /// This is an `O(n)` operation, as it requires copying every element in the\n     /// buffer.\n@@ -1061,6 +1067,57 @@ impl String {\n         ch\n     }\n \n+    /// Retains only the characters specified by the predicate.\n+    ///\n+    /// In other words, remove all characters `c` such that `f(c)` returns `false`.\n+    /// This method operates in place and preserves the order of the retained\n+    /// characters.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(string_retain)]\n+    ///\n+    /// let mut s = String::from(\"f_o_ob_ar\");\n+    ///\n+    /// s.retain(|c| c != '_');\n+    ///\n+    /// assert_eq!(s, \"foobar\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"string_retain\", issue = \"43874\")]\n+    pub fn retain<F>(&mut self, mut f: F)\n+        where F: FnMut(char) -> bool\n+    {\n+        let len = self.len();\n+        let mut del_bytes = 0;\n+        let mut idx = 0;\n+\n+        while idx < len {\n+            let ch = unsafe {\n+                self.slice_unchecked(idx, len).chars().next().unwrap()\n+            };\n+            let ch_len = ch.len_utf8();\n+\n+            if !f(ch) {\n+                del_bytes += ch_len;\n+            } else if del_bytes > 0 {\n+                unsafe {\n+                    ptr::copy(self.vec.as_ptr().offset(idx as isize),\n+                              self.vec.as_mut_ptr().offset((idx - del_bytes) as isize),\n+                              ch_len);\n+                }\n+            }\n+\n+            // Point idx to the next char\n+            idx += ch_len;\n+        }\n+\n+        if del_bytes > 0 {\n+            unsafe { self.vec.set_len(len - del_bytes); }\n+        }\n+    }\n+\n     /// Inserts a character into this `String` at a byte position.\n     ///\n     /// This is an `O(n)` operation as it requires copying every element in the\n@@ -1327,8 +1384,8 @@ impl String {\n         let chars_iter = self[start..end].chars();\n \n         Drain {\n-            start: start,\n-            end: end,\n+            start,\n+            end,\n             iter: chars_iter,\n             string: self_ptr,\n         }\n@@ -1338,7 +1395,7 @@ impl String {\n     /// replaces with the given string, and yields the removed chars.\n     /// The given string doesn\u2019t need to be the same length as the range.\n     ///\n-    /// Note: The element range is removed when the `Splice` is dropped,\n+    /// Note: The element range is removed when the [`Splice`] is dropped,\n     /// even if the iterator is not consumed until the end.\n     ///\n     /// # Panics\n@@ -1347,6 +1404,7 @@ impl String {\n     /// boundary, or if they're out of bounds.\n     ///\n     /// [`char`]: ../../std/primitive.char.html\n+    /// [`Splice`]: ../../std/string/struct.Splice.html\n     ///\n     /// # Examples\n     ///\n@@ -1391,18 +1449,21 @@ impl String {\n         let chars_iter = self[start..end].chars();\n \n         Splice {\n-            start: start,\n-            end: end,\n+            start,\n+            end,\n             iter: chars_iter,\n             string: self_ptr,\n-            replace_with: replace_with\n+            replace_with,\n         }\n     }\n \n-    /// Converts this `String` into a `Box<str>`.\n+    /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n     ///\n     /// This will drop any excess capacity.\n     ///\n+    /// [`Box`]: ../../std/boxed/struct.Box.html\n+    /// [`str`]: ../../std/primitive.str.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "8f3e71ef794465fb8a5b3e1c23d28faf5ffaf32c", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -10,12 +10,12 @@\n \n #![deny(warnings)]\n \n-#![feature(alloc)]\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n #![feature(inclusive_range_syntax)]\n #![feature(collection_placement)]\n #![feature(const_fn)]\n+#![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(iterator_step_by)]\n #![feature(pattern)]\n@@ -25,14 +25,11 @@\n #![feature(slice_rotate)]\n #![feature(splice)]\n #![feature(str_escape)]\n-#![feature(test)]\n+#![feature(string_retain)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n \n-extern crate alloc;\n-extern crate test;\n extern crate std_unicode;\n-extern crate core;\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;"}, {"sha": "f5c124c6b4458b3a666273daec3b88f3d5a8851f", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -332,6 +332,26 @@ fn remove_bad() {\n     \"\u0e28\".to_string().remove(1);\n }\n \n+#[test]\n+fn test_retain() {\n+    let mut s = String::from(\"\u03b1_\u03b2_\u03b3\");\n+\n+    s.retain(|_| true);\n+    assert_eq!(s, \"\u03b1_\u03b2_\u03b3\");\n+\n+    s.retain(|c| c != '_');\n+    assert_eq!(s, \"\u03b1\u03b2\u03b3\");\n+\n+    s.retain(|c| c != '\u03b2');\n+    assert_eq!(s, \"\u03b1\u03b3\");\n+\n+    s.retain(|c| c == '\u03b1');\n+    assert_eq!(s, \"\u03b1\");\n+\n+    s.retain(|_| false);\n+    assert_eq!(s, \"\");\n+}\n+\n #[test]\n fn insert() {\n     let mut s = \"foobar\".to_string();"}, {"sha": "670ea8089fc26904b43e3fd855e1d4088c1f4097", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -801,3 +801,170 @@ fn overaligned_allocations() {\n         assert!(v.as_ptr() as usize & 0xff == 0);\n     }\n }\n+\n+#[test]\n+fn drain_filter_empty() {\n+    let mut vec: Vec<i32> = vec![];\n+\n+    {\n+        let mut iter = vec.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+    assert_eq!(vec.len(), 0);\n+    assert_eq!(vec, vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_zst() {\n+    let mut vec = vec![(), (), (), (), ()];\n+    let initial_len = vec.len();\n+    let mut count = 0;\n+    {\n+        let mut iter = vec.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(vec.len(), 0);\n+    assert_eq!(vec, vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_false() {\n+    let mut vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+    let initial_len = vec.len();\n+    let mut count = 0;\n+    {\n+        let mut iter = vec.drain_filter(|_| false);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        for _ in iter.by_ref() {\n+            count += 1;\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, 0);\n+    assert_eq!(vec.len(), initial_len);\n+    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}\n+\n+#[test]\n+fn drain_filter_true() {\n+    let mut vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+    let initial_len = vec.len();\n+    let mut count = 0;\n+    {\n+        let mut iter = vec.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(vec.len(), 0);\n+    assert_eq!(vec, vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_complex() {\n+\n+    {   //                [+xxx++++++xxxxx++++x+x++]\n+        let mut vec = vec![1,\n+                           2, 4, 6,\n+                           7, 9, 11, 13, 15, 17,\n+                           18, 20, 22, 24, 26,\n+                           27, 29, 31, 33,\n+                           34,\n+                           35,\n+                           36,\n+                           37, 39];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(vec.len(), 14);\n+        assert_eq!(vec, vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]);\n+    }\n+\n+    {   //                [xxx++++++xxxxx++++x+x++]\n+        let mut vec = vec![2, 4, 6,\n+                           7, 9, 11, 13, 15, 17,\n+                           18, 20, 22, 24, 26,\n+                           27, 29, 31, 33,\n+                           34,\n+                           35,\n+                           36,\n+                           37, 39];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(vec.len(), 13);\n+        assert_eq!(vec, vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]);\n+    }\n+\n+    {   //                [xxx++++++xxxxx++++x+x]\n+        let mut vec = vec![2, 4, 6,\n+                           7, 9, 11, 13, 15, 17,\n+                           18, 20, 22, 24, 26,\n+                           27, 29, 31, 33,\n+                           34,\n+                           35,\n+                           36];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(vec.len(), 11);\n+        assert_eq!(vec, vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]);\n+    }\n+\n+    {   //                [xxxxxxxxxx+++++++++++]\n+        let mut vec = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n+                           1, 3, 5, 7, 9, 11, 13, 15, 17, 19];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(vec.len(), 10);\n+        assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+\n+    {   //                [+++++++++++xxxxxxxxxx]\n+        let mut vec = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n+                           2, 4, 6, 8, 10, 12, 14, 16, 18, 20];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(vec.len(), 10);\n+        assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+}\n+\n+"}, {"sha": "8141851b8c9af9cbd22567a94cc40309a55bccfd", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 115, "deletions": 2, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1728,9 +1728,9 @@ impl<T> IntoIterator for Vec<T> {\n             mem::forget(self);\n             IntoIter {\n                 buf: Shared::new_unchecked(begin),\n-                cap: cap,\n+                cap,\n                 ptr: begin,\n-                end: end,\n+                end,\n             }\n         }\n     }\n@@ -1960,6 +1960,65 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, then the element is removed and yielded.\n+    /// If the closure returns false, it will try again, and call the closure\n+    /// on the next element, seeing if it passes the test.\n+    ///\n+    /// Using this method is equivalent to the following code:\n+    ///\n+    /// ```\n+    /// # let some_predicate = |x: &mut i32| { *x == 2 };\n+    /// # let mut vec = vec![1, 2, 3, 4, 5];\n+    /// let mut i = 0;\n+    /// while i != vec.len() {\n+    ///     if some_predicate(&mut vec[i]) {\n+    ///         let val = vec.remove(i);\n+    ///         // your code here\n+    ///     }\n+    ///     i += 1;\n+    /// }\n+    /// ```\n+    ///\n+    /// But `drain_filter` is easier to use. `drain_filter` is also more efficient,\n+    /// because it can backshift the elements of the array in bulk.\n+    ///\n+    /// Note that `drain_filter` also lets you mutate every element in the filter closure,\n+    /// regardless of whether you choose to keep or remove it.\n+    ///\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting an array into evens and odds, reusing the original allocation:\n+    ///\n+    /// ```\n+    /// #![feature(drain_filter)]\n+    /// let mut numbers = vec![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n+    ///\n+    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+    /// let odds = numbers;\n+    ///\n+    /// assert_eq!(evens, vec![2, 4, 6, 8, 14]);\n+    /// assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n+    /// ```\n+    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n+        where F: FnMut(&mut T) -> bool,\n+    {\n+        let old_len = self.len();\n+\n+        // Guard against us getting leaked (leak amplification)\n+        unsafe { self.set_len(0); }\n+\n+        DrainFilter {\n+            vec: self,\n+            idx: 0,\n+            del: 0,\n+            old_len,\n+            pred: filter,\n+        }\n+    }\n }\n \n /// Extend implementation that copies elements out of references before pushing them onto the Vec.\n@@ -2602,3 +2661,57 @@ impl<'a, T> Drain<'a, T> {\n         self.tail_start = new_tail_start;\n     }\n }\n+\n+/// An iterator produced by calling `drain_filter` on Vec.\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+#[derive(Debug)]\n+pub struct DrainFilter<'a, T: 'a, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    vec: &'a mut Vec<T>,\n+    idx: usize,\n+    del: usize,\n+    old_len: usize,\n+    pred: F,\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            while self.idx != self.old_len {\n+                let i = self.idx;\n+                self.idx += 1;\n+                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n+                if (self.pred)(&mut v[i]) {\n+                    self.del += 1;\n+                    return Some(ptr::read(&v[i]));\n+                } else if self.del > 0 {\n+                    v.swap(i - self.del, i);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        for _ in self.by_ref() { }\n+\n+        unsafe {\n+            self.vec.set_len(self.old_len - self.del);\n+        }\n+    }\n+}"}, {"sha": "00def2a1eac49d27c908146deb1439f27b77e643", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -459,10 +459,12 @@ impl<T> VecDeque<T> {\n     ///\n     /// `i` and `j` may be equal.\n     ///\n-    /// Fails if there is no element with either index.\n-    ///\n     /// Element at index 0 is the front of the queue.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if either index is out of bounds.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2442,7 +2444,7 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n             VecDeque {\n                 tail: 0,\n                 head: len,\n-                buf: buf,\n+                buf,\n             }\n         }\n     }"}, {"sha": "41193f6a41f89a434fb6f1537987739622851674", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -93,29 +93,7 @@ fn main() {\n        .env(\"AR\", &ar)\n        .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n \n-    if target.contains(\"windows\") {\n-        // A bit of history here, this used to be --enable-lazy-lock added in\n-        // #14006 which was filed with jemalloc in jemalloc/jemalloc#83 which\n-        // was also reported to MinGW:\n-        //\n-        //  http://sourceforge.net/p/mingw-w64/bugs/395/\n-        //\n-        // When updating jemalloc to 4.0, however, it was found that binaries\n-        // would exit with the status code STATUS_RESOURCE_NOT_OWNED indicating\n-        // that a thread was unlocking a mutex it never locked. Disabling this\n-        // \"lazy lock\" option seems to fix the issue, but it was enabled by\n-        // default for MinGW targets in 13473c7 for jemalloc.\n-        //\n-        // As a result of all that, force disabling lazy lock on Windows, and\n-        // after reading some code it at least *appears* that the initialization\n-        // of mutexes is otherwise ok in jemalloc, so shouldn't cause problems\n-        // hopefully...\n-        //\n-        // tl;dr: make windows behave like other platforms by disabling lazy\n-        //        locking, but requires passing an option due to a historical\n-        //        default with jemalloc.\n-        cmd.arg(\"--disable-lazy-lock\");\n-    } else if target.contains(\"ios\") {\n+    if target.contains(\"ios\") {\n         cmd.arg(\"--disable-tls\");\n     } else if target.contains(\"android\") {\n         // We force android to have prefixed symbols because apparently"}, {"sha": "efefabc974c7fb0c068a422e487de10318daf86d", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_name = \"alloc_jemalloc\"]\n-#![crate_type = \"rlib\"]\n #![no_std]\n #![unstable(feature = \"alloc_jemalloc\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n@@ -21,7 +19,7 @@\n #![feature(libc)]\n #![feature(linkage)]\n #![feature(staged_api)]\n-#![cfg_attr(dummy_jemalloc, allow(dead_code))]\n+#![cfg_attr(dummy_jemalloc, allow(dead_code, unused_extern_crates))]\n #![cfg_attr(not(dummy_jemalloc), feature(allocator_api))]\n \n extern crate alloc;"}, {"sha": "1defe308713a7772f64aa159f7c2d12b375155e7", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_name = \"alloc_system\"]\n-#![crate_type = \"rlib\"]\n #![no_std]\n #![deny(warnings)]\n #![unstable(feature = \"alloc_system\","}, {"sha": "96fcc81e8e6edfaabaa78e99e73ec23bbebd00a1", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -18,9 +18,6 @@\n //! This crate implements `TypedArena`, a simple arena that can only hold\n //! objects of a single type.\n \n-#![crate_name = \"arena\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\","}, {"sha": "40ea5dfe1152f0fc5160879bb71bfe1fae2595f6", "filename": "src/libbacktrace/config.sub", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibbacktrace%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibbacktrace%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.sub?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1,8 +1,8 @@\n #! /bin/sh\n # Configuration validation subroutine script.\n-#   Copyright 1992-2016 Free Software Foundation, Inc.\n+#   Copyright 1992-2017 Free Software Foundation, Inc.\n \n-timestamp='2016-01-01'\n+timestamp='2017-04-02'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -67,7 +67,7 @@ Report bugs and patches to <config-patches@gnu.org>.\"\n version=\"\\\n GNU config.sub ($timestamp)\n \n-Copyright 1992-2016 Free Software Foundation, Inc.\n+Copyright 1992-2017 Free Software Foundation, Inc.\n \n This is free software; see the source for copying conditions.  There is NO\n warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n@@ -117,7 +117,7 @@ case $maybe_os in\n   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \\\n   linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \\\n   knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \\\n-  kopensolaris*-gnu* | \\\n+  kopensolaris*-gnu* | cloudabi*-eabi* | \\\n   storm-chaos* | os2-emx* | rtmk-nova*)\n     os=-$maybe_os\n     basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`\n@@ -263,7 +263,7 @@ case $basic_machine in\n \t| fido | fr30 | frv | ft32 \\\n \t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n \t| hexagon \\\n-\t| i370 | i860 | i960 | ia64 \\\n+\t| i370 | i860 | i960 | ia16 | ia64 \\\n \t| ip2k | iq2000 \\\n \t| k1om \\\n \t| le32 | le64 \\\n@@ -301,6 +301,7 @@ case $basic_machine in\n \t| open8 | or1k | or1knd | or32 \\\n \t| pdp10 | pdp11 | pj | pjl \\\n \t| powerpc | powerpc64 | powerpc64le | powerpcle \\\n+\t| pru \\\n \t| pyramid \\\n \t| riscv32 | riscv64 \\\n \t| rl78 | rx \\\n@@ -314,6 +315,7 @@ case $basic_machine in\n \t| ubicom32 \\\n \t| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \\\n \t| visium \\\n+\t| wasm32 \\\n \t| we32k \\\n \t| x86 | xc16x | xstormy16 | xtensa \\\n \t| z8k | z80)\n@@ -387,7 +389,7 @@ case $basic_machine in\n \t| h8300-* | h8500-* \\\n \t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n \t| hexagon-* \\\n-\t| i*86-* | i860-* | i960-* | ia64-* \\\n+\t| i*86-* | i860-* | i960-* | ia16-* | ia64-* \\\n \t| ip2k-* | iq2000-* \\\n \t| k1om-* \\\n \t| le32-* | le64-* \\\n@@ -428,6 +430,7 @@ case $basic_machine in\n \t| orion-* \\\n \t| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \\\n \t| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \\\n+\t| pru-* \\\n \t| pyramid-* \\\n \t| riscv32-* | riscv64-* \\\n \t| rl78-* | romp-* | rs6000-* | rx-* \\\n@@ -444,6 +447,7 @@ case $basic_machine in\n \t| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \\\n \t| vax-* \\\n \t| visium-* \\\n+\t| wasm32-* \\\n \t| we32k-* \\\n \t| x86-* | x86_64-* | xc16x-* | xps100-* \\\n \t| xstormy16-* | xtensa*-* \\\n@@ -643,6 +647,14 @@ case $basic_machine in\n \t\tbasic_machine=m68k-bull\n \t\tos=-sysv3\n \t\t;;\n+\te500v[12])\n+\t\tbasic_machine=powerpc-unknown\n+\t\tos=$os\"spe\"\n+\t\t;;\n+\te500v[12]-*)\n+\t\tbasic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=$os\"spe\"\n+\t\t;;\n \tebmon29k)\n \t\tbasic_machine=a29k-amd\n \t\tos=-ebmon\n@@ -938,6 +950,9 @@ case $basic_machine in\n \tnsr-tandem)\n \t\tbasic_machine=nsr-tandem\n \t\t;;\n+\tnsx-tandem)\n+\t\tbasic_machine=nsx-tandem\n+\t\t;;\n \top50n-* | op60c-*)\n \t\tbasic_machine=hppa1.1-oki\n \t\tos=-proelf\n@@ -1022,7 +1037,7 @@ case $basic_machine in\n \tppc-* | ppcbe-*)\n \t\tbasic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n-\tppcle | powerpclittle | ppc-le | powerpc-little)\n+\tppcle | powerpclittle)\n \t\tbasic_machine=powerpcle-unknown\n \t\t;;\n \tppcle-* | powerpclittle-*)\n@@ -1032,7 +1047,7 @@ case $basic_machine in\n \t\t;;\n \tppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`\n \t\t;;\n-\tppc64le | powerpc64little | ppc64-le | powerpc64-little)\n+\tppc64le | powerpc64little)\n \t\tbasic_machine=powerpc64le-unknown\n \t\t;;\n \tppc64le-* | powerpc64little-*)\n@@ -1233,6 +1248,9 @@ case $basic_machine in\n \t\tbasic_machine=a29k-wrs\n \t\tos=-vxworks\n \t\t;;\n+\twasm32)\n+\t\tbasic_machine=wasm32-unknown\n+\t\t;;\n \tw65*)\n \t\tbasic_machine=w65-wdc\n \t\tos=-none\n@@ -1382,14 +1400,14 @@ case $os in\n \t      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \\\n \t      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \\\n \t      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \\\n-\t      | -bitrig* | -openbsd* | -solidbsd* \\\n+\t      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \\\n \t      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \\\n \t      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \\\n \t      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \\\n \t      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \\\n-\t      | -chorusos* | -chorusrdb* | -cegcc* \\\n+\t      | -chorusos* | -chorusrdb* | -cegcc* | -glidix* \\\n \t      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n-\t      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \\\n+\t      | -midipix* | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \\\n \t      | -linux-newlib* | -linux-musl* | -linux-uclibc* \\\n \t      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \\\n \t      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \\\n@@ -1399,7 +1417,7 @@ case $os in\n \t      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \\\n \t      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \\\n \t      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \\\n-\t      | -onefs* | -tirtos*)\n+\t      | -onefs* | -tirtos* | -phoenix* | -fuchsia* | -redox*)\n \t# Remember, each alternative MUST END IN *, to match a version number.\n \t\t;;\n \t-qnx*)\n@@ -1531,6 +1549,8 @@ case $os in\n \t\t;;\n \t-nacl*)\n \t\t;;\n+\t-ios)\n+\t\t;;\n \t-none)\n \t\t;;\n \t*)\n@@ -1626,6 +1646,9 @@ case $basic_machine in\n \tsparc-* | *-sun)\n \t\tos=-sunos4.1.1\n \t\t;;\n+\tpru-*)\n+\t\tos=-elf\n+\t\t;;\n \t*-be)\n \t\tos=-beos\n \t\t;;"}, {"sha": "55316db3d5a4358f6582328f9951fa489e227113", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_name = \"collections\"]\n-#![crate_type = \"rlib\"]\n #![allow(unused_attributes)]\n #![unstable(feature = \"collections\",\n             reason = \"this library is unlikely to be stabilized in its current \\"}, {"sha": "6b9281d2b2f0ebb94838814b1e8ace2de4b7035b", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1 +1 @@\n-Subproject commit 5e49856003f33aa5781a0edca148be21025e18e7\n+Subproject commit 6b9281d2b2f0ebb94838814b1e8ace2de4b7035b"}, {"sha": "4b7706bac300fe4b1a1ebd1316c01cbb7d75d7bc", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -89,7 +89,7 @@ macro_rules! __impl_slice_eq2 {\n     }\n }\n \n-// macro for implementing n-ary tuple functions and operations\n+// macro for implementing n-element array functions and operations\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n@@ -124,6 +124,7 @@ macro_rules! array_impls {\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {\n                     *self"}, {"sha": "e0a3b8d52f40efb5df9180a1b741928196675fed", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -809,7 +809,7 @@ impl<T: ?Sized> RefCell<T> {\n     /// [`borrow_mut`] method instead if `self` isn't mutable.\n     ///\n     /// Also, please be aware that this method is only for special circumstances and is usually\n-    /// not you want. In case of doubt, use [`borrow_mut`] instead.\n+    /// not what you want. In case of doubt, use [`borrow_mut`] instead.\n     ///\n     /// [`borrow_mut`]: #method.borrow_mut\n     ///\n@@ -998,7 +998,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// A method would interfere with methods of the same name on the contents\n     /// of a `RefCell` used through `Deref`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::cell::{RefCell, Ref};\n@@ -1040,7 +1040,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// `RefMut::map(...)`.  A method would interfere with methods of the same\n     /// name on the contents of a `RefCell` used through `Deref`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// use std::cell::{RefCell, RefMut};"}, {"sha": "2dc51718b97b23e0e0a7a491dd091f340585efbb", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -88,6 +88,7 @@\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(stage0), lang = \"clone\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n     ///\n@@ -131,6 +132,7 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<'a, T: ?Sized> Clone for &'a T {\n     /// Returns a shallow copy of the reference.\n     #[inline]\n@@ -140,6 +142,7 @@ impl<'a, T: ?Sized> Clone for &'a T {\n macro_rules! clone_impl {\n     ($t:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         impl Clone for $t {\n             /// Returns a deep copy of the value.\n             #[inline]"}, {"sha": "b594c886b64f5d35a80a9ccd79b3836954d0f63e", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -18,7 +18,7 @@ struct PadAdapter<'a, 'b: 'a> {\n impl<'a, 'b: 'a> PadAdapter<'a, 'b> {\n     fn new(fmt: &'a mut fmt::Formatter<'b>) -> PadAdapter<'a, 'b> {\n         PadAdapter {\n-            fmt: fmt,\n+            fmt,\n             on_newline: false,\n         }\n     }\n@@ -58,7 +58,7 @@ impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n /// [`Formatter::debug_struct`](struct.Formatter.html#method.debug_struct)\n /// method.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::fmt;\n@@ -94,8 +94,8 @@ pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n                                 -> DebugStruct<'a, 'b> {\n     let result = fmt.write_str(name);\n     DebugStruct {\n-        fmt: fmt,\n-        result: result,\n+        fmt,\n+        result,\n         has_fields: false,\n     }\n }\n@@ -153,7 +153,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n /// [`Formatter::debug_tuple`](struct.Formatter.html#method.debug_tuple)\n /// method.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::fmt;\n@@ -185,8 +185,8 @@ pub struct DebugTuple<'a, 'b: 'a> {\n pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> {\n     let result = fmt.write_str(name);\n     DebugTuple {\n-        fmt: fmt,\n-        result: result,\n+        fmt,\n+        result,\n         fields: 0,\n         empty_name: name.is_empty(),\n     }\n@@ -290,7 +290,7 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n /// [`Formatter::debug_set`](struct.Formatter.html#method.debug_set)\n /// method.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::fmt;\n@@ -317,8 +317,8 @@ pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b\n     let result = write!(fmt, \"{{\");\n     DebugSet {\n         inner: DebugInner {\n-            fmt: fmt,\n-            result: result,\n+            fmt,\n+            result,\n             has_fields: false,\n         },\n     }\n@@ -361,7 +361,7 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n /// [`Formatter::debug_list`](struct.Formatter.html#method.debug_list)\n /// method.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::fmt;\n@@ -388,8 +388,8 @@ pub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a,\n     let result = write!(fmt, \"[\");\n     DebugList {\n         inner: DebugInner {\n-            fmt: fmt,\n-            result: result,\n+            fmt,\n+            result,\n             has_fields: false,\n         },\n     }\n@@ -432,7 +432,7 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n /// [`Formatter::debug_map`](struct.Formatter.html#method.debug_map)\n /// method.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::fmt;\n@@ -460,8 +460,8 @@ pub struct DebugMap<'a, 'b: 'a> {\n pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n     let result = write!(fmt, \"{{\");\n     DebugMap {\n-        fmt: fmt,\n-        result: result,\n+        fmt,\n+        result,\n         has_fields: false,\n     }\n }"}, {"sha": "cf6262bda9748355deef2461e76e919e5561ad94", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -334,9 +334,9 @@ impl<'a> Arguments<'a> {\n     pub fn new_v1(pieces: &'a [&'a str],\n                   args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n         Arguments {\n-            pieces: pieces,\n+            pieces,\n             fmt: None,\n-            args: args\n+            args,\n         }\n     }\n \n@@ -353,9 +353,9 @@ impl<'a> Arguments<'a> {\n                             args: &'a [ArgumentV1<'a>],\n                             fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n         Arguments {\n-            pieces: pieces,\n+            pieces,\n             fmt: Some(fmt),\n-            args: args\n+            args,\n         }\n     }\n "}, {"sha": "a8b84203d6a6c61402d1ef4a26a586a4fd7df0c9", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -240,7 +240,12 @@ pub trait Hash {\n /// [`write_u8`]: #method.write_u8\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n-    /// Completes a round of hashing, producing the output hash generated.\n+    /// Returns the hash value for the values written so far.\n+    ///\n+    /// Despite its name, the method does not reset the hasher\u2019s internal\n+    /// state. Additional [`write`]s will continue from the current value.\n+    /// If you need to start a fresh hash value, you will have to create\n+    /// a new hasher.\n     ///\n     /// # Examples\n     ///\n@@ -253,6 +258,8 @@ pub trait Hasher {\n     ///\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n+    ///\n+    /// ['write']: #tymethod.write\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n "}, {"sha": "7c009114afefb969570137a2081e4cc688d2d432", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -605,7 +605,7 @@ pub trait Iterator {\n     /// closure returns [`None`], it will try again, and call the closure on the\n     /// next element, seeing if it will return [`Some`].\n     ///\n-    /// Why `filter_map` and not just [`filter`].[`map`]? The key is in this\n+    /// Why `filter_map` and not just [`filter`] and [`map`]? The key is in this\n     /// part:\n     ///\n     /// [`filter`]: #method.filter"}, {"sha": "ebedfe1d743bb37583c7ac4ccd70f670a19dc5ac", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -840,8 +840,8 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n     type Item = (A::Item, B::Item);\n     default fn new(a: A, b: B) -> Self {\n         Zip {\n-            a: a,\n-            b: b,\n+            a,\n+            b,\n             index: 0, // unused\n             len: 0, // unused\n         }\n@@ -903,10 +903,10 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n     fn new(a: A, b: B) -> Self {\n         let len = cmp::min(a.len(), b.len());\n         Zip {\n-            a: a,\n-            b: b,\n+            a,\n+            b,\n             index: 0,\n-            len: len,\n+            len,\n         }\n     }\n "}, {"sha": "2af129a67bddf94ef471a45538f090a46b68234a", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -744,7 +744,7 @@ impl<I, T, E> ResultShunt<I, E>\n \n     fn new(iter: I) -> Self {\n         ResultShunt {\n-            iter: iter,\n+            iter,\n             error: None,\n         }\n     }"}, {"sha": "c270c6ae0dbad23944db36f3d19ff8ecc2b885e2", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -51,9 +51,7 @@\n // Since libcore defines many fundamental lang items, all tests live in a\n // separate crate, libcoretest, to avoid bizarre issues.\n \n-#![crate_name = \"core\"]\n #![stable(feature = \"core\", since = \"1.6.0\")]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\","}, {"sha": "4b866cab1eae2f00b97e5d0af34240ec4fb21904", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -901,7 +901,7 @@ impl<T> ManuallyDrop<T> {\n \n     /// Manually drops the contained value.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This function runs the destructor of the contained value and thus the wrapped value\n     /// now represents uninitialized data. It is up to the user of this method to ensure the"}, {"sha": "12960fed04550cfba525cf42952039fb1b0bdcaf", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -102,10 +102,10 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n     /// The number of bits in the exponent.\n     const EXP_BITS: u8;\n \n-    /// The number of bits in the singificand, *including* the hidden bit.\n+    /// The number of bits in the significand, *including* the hidden bit.\n     const SIG_BITS: u8;\n \n-    /// The number of bits in the singificand, *excluding* the hidden bit.\n+    /// The number of bits in the significand, *excluding* the hidden bit.\n     const EXPLICIT_SIG_BITS: u8;\n \n     /// The maximum legal exponent in fractional representation.\n@@ -123,7 +123,7 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n     /// `MIN_EXP` for integral representation, i.e., with the shift applied.\n     const MIN_EXP_INT: i16;\n \n-    /// The maximum normalized singificand in integral representation.\n+    /// The maximum normalized significand in integral representation.\n     const MAX_SIG: u64;\n \n     /// The minimal normalized significand in integral representation."}, {"sha": "97bcba2f2ffbc8b9da881fe3bdcdb789b5c3ee8e", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -86,7 +86,7 @@ impl Fp {\n         assert_eq!(self.f << edelta >> edelta, self.f);\n         Fp {\n             f: self.f << edelta,\n-            e: e,\n+            e,\n         }\n     }\n }"}, {"sha": "beaa6e140a6993b978c6b60bf63f7eb775bb2199", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -442,7 +442,7 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n         }\n         FullDecoded::Finite(ref decoded) => {\n             let (len, exp) = format_shortest(decoded, buf);\n-            Formatted { sign: sign,\n+            Formatted { sign,\n                         parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n         }\n     }\n@@ -581,7 +581,7 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n \n             let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n             let (len, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n-            Formatted { sign: sign,\n+            Formatted { sign,\n                         parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n         }\n     }\n@@ -652,7 +652,7 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                     Formatted { sign: sign, parts: &parts[..1] }\n                 }\n             } else {\n-                Formatted { sign: sign,\n+                Formatted { sign,\n                             parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n             }\n         }"}, {"sha": "78326c3e6391a1b36b0ff2db9a1afbb8bd86539a", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// A trait for customizing the behaviour of the `?` operator.\n+/// A trait for customizing the behavior of the `?` operator.\n ///\n /// A type implementing `Try` is one that has a canonical way to view it\n /// in terms of a success/failure dichotomy.  This trait allows both"}, {"sha": "63e9373e936068cc2085e6f8750abfbdcf9159ec", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -876,6 +876,7 @@ pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<T: ?Sized> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n@@ -884,6 +885,7 @@ impl<T: ?Sized> Clone for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<T: ?Sized> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n@@ -895,6 +897,7 @@ impl<T: ?Sized> Clone for *mut T {\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         impl<Ret, $($Arg),*> Clone for $FnTy {\n             #[inline]\n             fn clone(&self) -> Self {"}, {"sha": "ea064ca5c39fe0539804ab0536e519e538000cc3", "filename": "src/libcore/result.rs", "status": "modified", "additions": 73, "deletions": 27, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -244,9 +244,12 @@ use fmt;\n use iter::{FromIterator, FusedIterator, TrustedLen};\n use ops;\n \n-/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n+/// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n+///\n+/// [`Ok`]: enum.Result.html#variant.Ok\n+/// [`Err`]: enum.Result.html#variant.Err\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -269,7 +272,9 @@ impl<T, E> Result<T, E> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `true` if the result is `Ok`.\n+    /// Returns `true` if the result is [`Ok`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n     ///\n     /// # Examples\n     ///\n@@ -291,7 +296,9 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Returns `true` if the result is `Err`.\n+    /// Returns `true` if the result is [`Err`].\n+    ///\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -433,10 +440,13 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n-    /// contained `Ok` value, leaving an `Err` value untouched.\n+    /// contained [`Ok`] value, leaving an [`Err`] value untouched.\n     ///\n     /// This function can be used to compose the results of two functions.\n     ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Print the numbers on each line of a string multiplied by two.\n@@ -461,11 +471,14 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n-    /// contained `Err` value, leaving an `Ok` value untouched.\n+    /// contained [`Err`] value, leaving an [`Ok`] value untouched.\n     ///\n     /// This function can be used to pass through a successful result while handling\n     /// an error.\n     ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -546,7 +559,10 @@ impl<T, E> Result<T, E> {\n     // Boolean operations on the values, eager and lazy\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -578,7 +594,10 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// This function can be used for control flow based on `Result` values.\n     ///\n@@ -604,7 +623,10 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+    /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -636,10 +658,13 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+    /// Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n     ///\n     /// This function can be used for control flow based on result values.\n     ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -662,9 +687,12 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Unwraps a result, yielding the content of an [`Ok`].\n     /// Else, it returns `optb`.\n     ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -686,8 +714,11 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Ok`.\n-    /// If the value is an `Err` then it calls `op` with its value.\n+    /// Unwraps a result, yielding the content of an [`Ok`].\n+    /// If the value is an [`Err`] then it calls `op` with its value.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -710,12 +741,15 @@ impl<T, E> Result<T, E> {\n }\n \n impl<T, E: fmt::Debug> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Unwraps a result, yielding the content of an [`Ok`].\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an `Err`, with a panic message provided by the\n-    /// `Err`'s value.\n+    /// Panics if the value is an [`Err`], with a panic message provided by the\n+    /// [`Err`]'s value.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -739,12 +773,15 @@ impl<T, E: fmt::Debug> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Unwraps a result, yielding the content of an [`Ok`].\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an `Err`, with a panic message including the\n-    /// passed message, and the content of the `Err`.\n+    /// Panics if the value is an [`Err`], with a panic message including the\n+    /// passed message, and the content of the [`Err`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -765,12 +802,16 @@ impl<T, E: fmt::Debug> Result<T, E> {\n }\n \n impl<T: fmt::Debug, E> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an `Err`.\n+    /// Unwraps a result, yielding the content of an [`Err`].\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an `Ok`, with a custom panic message provided\n-    /// by the `Ok`'s value.\n+    /// Panics if the value is an [`Ok`], with a custom panic message provided\n+    /// by the [`Ok`]'s value.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     ///\n     /// # Examples\n     ///\n@@ -792,12 +833,15 @@ impl<T: fmt::Debug, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Err`.\n+    /// Unwraps a result, yielding the content of an [`Err`].\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an `Ok`, with a panic message including the\n-    /// passed message, and the content of the `Ok`.\n+    /// Panics if the value is an [`Ok`], with a panic message including the\n+    /// passed message, and the content of the [`Ok`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -820,16 +864,16 @@ impl<T: fmt::Debug, E> Result<T, E> {\n impl<T: Default, E> Result<T, E> {\n     /// Returns the contained value or a default\n     ///\n-    /// Consumes the `self` argument then, if `Ok`, returns the contained\n-    /// value, otherwise if `Err`, returns the default value for that\n+    /// Consumes the `self` argument then, if [`Ok`], returns the contained\n+    /// value, otherwise if [`Err`], returns the default value for that\n     /// type.\n     ///\n     /// # Examples\n     ///\n     /// Convert a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning an\n-    /// `Err` on error.\n+    /// [`Err`] on error.\n     ///\n     /// ```\n     /// let good_year_from_input = \"1909\";\n@@ -843,6 +887,8 @@ impl<T: Default, E> Result<T, E> {\n     ///\n     /// [`parse`]: ../../std/primitive.str.html#method.parse\n     /// [`FromStr`]: ../../std/str/trait.FromStr.html\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     #[inline]\n     #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n     pub fn unwrap_or_default(self) -> T {"}, {"sha": "31d8266510a1ea652cb400e407829307f90938b5", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -212,6 +212,9 @@ pub trait SliceExt {\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;\n \n+    #[unstable(feature = \"swap_with_slice\", issue = \"44030\")]\n+    fn swap_with_slice(&mut self, src: &mut [Self::Item]);\n+\n     #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     fn sort_unstable(&mut self)\n         where Self::Item: Ord;\n@@ -300,7 +303,7 @@ impl<T> SliceExt for [T] {\n     {\n         Split {\n             v: self,\n-            pred: pred,\n+            pred,\n             finished: false\n         }\n     }\n@@ -673,6 +676,16 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    #[inline]\n+    fn swap_with_slice(&mut self, src: &mut [T]) {\n+        assert!(self.len() == src.len(),\n+                \"destination and source slices have different lengths\");\n+        unsafe {\n+            ptr::swap_nonoverlapping(\n+                self.as_mut_ptr(), src.as_mut_ptr(), self.len());\n+        }\n+    }\n+\n     #[inline]\n     fn binary_search_by_key<'a, B, F, Q: ?Sized>(&'a self, b: &Q, mut f: F) -> Result<usize, usize>\n         where F: FnMut(&'a Self::Item) -> B,"}, {"sha": "a5f6e49a53b4f7cff5238d4b2a85b8edce0c589c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -2233,7 +2233,7 @@ impl StrExt for str {\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n         SplitN(SplitNInternal {\n             iter: self.split(pat).0,\n-            count: count,\n+            count,\n         })\n     }\n "}, {"sha": "edb7bed4520fb0e1df9f5635cc96a6eebc1078ff", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -290,7 +290,7 @@ impl<'a, C: CharEq> Pattern<'a> for CharEqPattern<C> {\n     fn into_searcher(self, haystack: &'a str) -> CharEqSearcher<'a, C> {\n         CharEqSearcher {\n             ascii_only: self.0.only_ascii(),\n-            haystack: haystack,\n+            haystack,\n             char_eq: self.0,\n             char_indices: haystack.char_indices(),\n         }\n@@ -596,8 +596,8 @@ impl<'a, 'b> StrSearcher<'a, 'b> {\n     fn new(haystack: &'a str, needle: &'b str) -> StrSearcher<'a, 'b> {\n         if needle.is_empty() {\n             StrSearcher {\n-                haystack: haystack,\n-                needle: needle,\n+                haystack,\n+                needle,\n                 searcher: StrSearcherImpl::Empty(EmptyNeedle {\n                     position: 0,\n                     end: haystack.len(),\n@@ -607,8 +607,8 @@ impl<'a, 'b> StrSearcher<'a, 'b> {\n             }\n         } else {\n             StrSearcher {\n-                haystack: haystack,\n-                needle: needle,\n+                haystack,\n+                needle,\n                 searcher: StrSearcherImpl::TwoWay(\n                     TwoWaySearcher::new(needle.as_bytes(), haystack.len())\n                 ),\n@@ -899,13 +899,13 @@ impl TwoWaySearcher {\n                 TwoWaySearcher::reverse_maximal_suffix(needle, period, true));\n \n             TwoWaySearcher {\n-                crit_pos: crit_pos,\n-                crit_pos_back: crit_pos_back,\n-                period: period,\n+                crit_pos,\n+                crit_pos_back,\n+                period,\n                 byteset: Self::byteset_create(&needle[..period]),\n \n                 position: 0,\n-                end: end,\n+                end,\n                 memory: 0,\n                 memory_back: needle.len(),\n             }\n@@ -918,13 +918,13 @@ impl TwoWaySearcher {\n             // reverse search.\n \n             TwoWaySearcher {\n-                crit_pos: crit_pos,\n+                crit_pos,\n                 crit_pos_back: crit_pos,\n                 period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n                 byteset: Self::byteset_create(needle),\n \n                 position: 0,\n-                end: end,\n+                end,\n                 memory: usize::MAX, // Dummy value to signify that the period is long\n                 memory_back: usize::MAX,\n             }"}, {"sha": "510e01db0e965ed190343d11552ce3343ad52b0f", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1632,7 +1632,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n ///     pub fn lock(&self) {\n ///         while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n-///         // This fence syncronizes-with store in `unlock`.\n+///         // This fence synchronizes-with store in `unlock`.\n ///         fence(Ordering::Acquire);\n ///     }\n ///"}, {"sha": "ed6923929d6b0b15d0ac294c67fd159c5105af98", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -392,7 +392,7 @@ pub struct CycleIter<'a, T: 'a> {\n pub fn cycle<T>(data: &[T]) -> CycleIter<T> {\n     CycleIter {\n         index: 0,\n-        data: data,\n+        data,\n     }\n }\n "}, {"sha": "ab2022b1824ca3a2e5f5b682731d53c52abb5a14", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -26,7 +26,6 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![feature(iter_rfind)]\n-#![feature(libc)]\n #![feature(nonzero)]\n #![feature(ord_max_min)]\n #![feature(rand)]\n@@ -41,13 +40,10 @@\n #![feature(test)]\n #![feature(trusted_len)]\n #![feature(try_from)]\n-#![feature(unicode)]\n #![feature(unique)]\n \n extern crate core;\n extern crate test;\n-extern crate libc;\n-extern crate std_unicode;\n extern crate rand;\n \n mod any;"}, {"sha": "6bac55575fb1817d72abfe7f0522c1d551cf1da8", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -53,7 +53,7 @@ fn test_get_resource() {\n \n     fn r(i: Rc<RefCell<isize>>) -> R {\n         R {\n-            i: i\n+            i,\n         }\n     }\n "}, {"sha": "555843dba418ecaeebb88d3c36015865edfb46fd", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -22,6 +22,7 @@ macro_rules! tuple_impls {\n     )+) => {\n         $(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(self.$idx.clone(),)+)"}, {"sha": "24430b2e377f599529c02afdc1371349a73abf2d", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,9 +14,6 @@\n //! Parsing does not happen at runtime: structures of `std::fmt::rt` are\n //! generated instead.\n \n-#![crate_name = \"fmt_macros\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -284,7 +281,7 @@ impl<'a> Parser<'a> {\n \n         Argument {\n             position: pos,\n-            format: format,\n+            format,\n         }\n     }\n "}, {"sha": "a0eacc817ca817b516f578dd98bc69d2ce6668ac", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -77,9 +77,6 @@\n //! }\n //! ```\n \n-#![crate_name = \"getopts\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -250,28 +247,28 @@ impl OptGroup {\n             (0, _) => {\n                 Opt {\n                     name: Long((long_name)),\n-                    hasarg: hasarg,\n-                    occur: occur,\n+                    hasarg,\n+                    occur,\n                     aliases: Vec::new(),\n                 }\n             }\n             (1, 0) => {\n                 Opt {\n                     name: Short(short_name.chars().next().unwrap()),\n-                    hasarg: hasarg,\n-                    occur: occur,\n+                    hasarg,\n+                    occur,\n                     aliases: Vec::new(),\n                 }\n             }\n             (1, _) => {\n                 Opt {\n                     name: Long((long_name)),\n-                    hasarg: hasarg,\n-                    occur: occur,\n+                    hasarg,\n+                    occur,\n                     aliases: vec![Opt {\n                                       name: Short(short_name.chars().next().unwrap()),\n-                                      hasarg: hasarg,\n-                                      occur: occur,\n+                                      hasarg,\n+                                      occur,\n                                       aliases: Vec::new(),\n                                   }],\n                 }\n@@ -530,8 +527,8 @@ pub fn opt(short_name: &str,\n         long_name: long_name.to_owned(),\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n-        hasarg: hasarg,\n-        occur: occur,\n+        hasarg,\n+        occur,\n     }\n }\n \n@@ -681,9 +678,9 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         }\n     }\n     Ok(Matches {\n-        opts: opts,\n-        vals: vals,\n-        free: free,\n+        opts,\n+        vals,\n+        free,\n     })\n }\n "}, {"sha": "5b1cf2dee9a83db9abfe1ccabc6679754d9472e6", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -11,7 +11,7 @@\n //! Generate files suitable for use with [Graphviz](http://www.graphviz.org/)\n //!\n //! The `render` function generates output (e.g. an `output.dot` file) for\n-//! use with [Graphviz](http://www.graphviz.org/) by walking a labelled\n+//! use with [Graphviz](http://www.graphviz.org/) by walking a labeled\n //! graph. (Graphviz can then automatically lay out the nodes and edges\n //! of the graph, and also optionally render the graph as an image or\n //! other [output formats](\n@@ -150,7 +150,7 @@\n //!\n //! The output from this example renders four nodes that make up the\n //! Hasse-diagram for the subsets of the set `{x, y}`. Each edge is\n-//! labelled with the &sube; character (specified using the HTML character\n+//! labeled with the &sube; character (specified using the HTML character\n //! entity `&sube`).\n //!\n //! ```rust\n@@ -283,9 +283,6 @@\n //!\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n-#![crate_name = \"graphviz\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -781,15 +778,15 @@ mod tests {\n \n     fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n         Edge {\n-            from: from,\n-            to: to,\n-            label: label,\n-            style: style,\n+            from,\n+            to,\n+            label,\n+            style,\n         }\n     }\n \n     struct LabelledGraph {\n-        /// The name for this graph. Used for labelling generated `digraph`.\n+        /// The name for this graph. Used for labeling generated `digraph`.\n         name: &'static str,\n \n         /// Each node is an index into `node_labels`; these labels are\n@@ -848,9 +845,9 @@ mod tests {\n                -> LabelledGraph {\n             let count = node_labels.len();\n             LabelledGraph {\n-                name: name,\n+                name,\n                 node_labels: node_labels.to_opt_strs(),\n-                edges: edges,\n+                edges,\n                 node_styles: match node_styles {\n                     Some(nodes) => nodes,\n                     None => vec![Style::None; count],"}, {"sha": "8be6f6470231dcb8e30f0cd68ea7d8923efb7cbb", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,8 +14,6 @@\n //! simpler! That being said, it's not quite as versatile, but here goes!\n \n #![no_std]\n-#![crate_name = \"panic_abort\"]\n-#![crate_type = \"rlib\"]\n #![unstable(feature = \"panic_abort\", issue = \"32837\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\","}, {"sha": "63e44f71a3a8f3d7249b084cd79e97fcd159580f", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -74,7 +74,7 @@ pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n     let exception = Box::new(Exception {\n         _uwe: uw::_Unwind_Exception {\n             exception_class: rust_exception_class(),\n-            exception_cleanup: exception_cleanup,\n+            exception_cleanup,\n             private: [0; uw::unwinder_private_data_size],\n         },\n         cause: Some(data),"}, {"sha": "558286f4ec0707c1fb740cf499f65222afe6243c", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -23,8 +23,6 @@\n //! module.\n \n #![no_std]\n-#![crate_name = \"panic_unwind\"]\n-#![crate_type = \"rlib\"]\n #![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n@@ -36,7 +34,9 @@\n #![feature(core_intrinsics)]\n #![feature(lang_items)]\n #![feature(libc)]\n-#![feature(panic_unwind)]\n+#![cfg_attr(not(any(target_env = \"msvc\",\n+                    all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))),\n+            feature(panic_unwind))]\n #![feature(raw)]\n #![feature(staged_api)]\n #![feature(unwind_attributes)]\n@@ -47,6 +47,7 @@\n \n extern crate alloc;\n extern crate libc;\n+#[cfg(not(any(target_env = \"msvc\", all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))))]\n extern crate unwind;\n \n use core::intrinsics;"}, {"sha": "3f425c24a9143479b72c3ed62ec4adb80f917a75", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -23,10 +23,7 @@\n //!\n //! See [the book](../book/first-edition/procedural-macros.html) for more.\n \n-#![crate_name = \"proc_macro\"]\n #![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n #![deny(warnings)]\n #![deny(missing_docs)]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -241,14 +238,14 @@ pub enum TokenNode {\n }\n \n /// Describes how a sequence of token trees is delimited.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub enum Delimiter {\n     /// `( ... )`\n     Parenthesis,\n-    /// `[ ... ]`\n-    Brace,\n     /// `{ ... }`\n+    Brace,\n+    /// `[ ... ]`\n     Bracket,\n     /// An implicit delimiter, e.g. `$var`, where $var is  `...`.\n     None,\n@@ -274,7 +271,7 @@ impl Term {\n }\n \n /// Whether an `Op` is either followed immediately by another `Op` or followed by whitespace.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub enum Spacing {\n     /// e.g. `+` is `Alone` in `+ =`."}, {"sha": "6d0d6d115b7163528e3e0a54737ce114124ffe32", "filename": "src/libprofiler_builtins/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibprofiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibprofiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,7 +14,5 @@\n #![unstable(feature = \"profiler_runtime_lib\",\n             reason = \"internal implementation detail of rustc right now\",\n             issue = \"0\")]\n-#![crate_name = \"profiler_builtins\"]\n-#![crate_type = \"rlib\"]\n #![allow(unused_features)]\n #![feature(staged_api)]"}, {"sha": "e796197ab5bf24e16ae23416cd17c66b7fb9d758", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -127,9 +127,9 @@ impl GammaLargeShape {\n     fn new_raw(shape: f64, scale: f64) -> GammaLargeShape {\n         let d = shape - 1. / 3.;\n         GammaLargeShape {\n-            scale: scale,\n+            scale,\n             c: 1. / (9. * d).sqrt(),\n-            d: d,\n+            d,\n         }\n     }\n }\n@@ -254,7 +254,7 @@ impl IndependentSample<f64> for ChiSquared {\n \n /// The Fisher F distribution `F(m, n)`.\n ///\n-/// This distribution is equivalent to the ratio of two normalised\n+/// This distribution is equivalent to the ratio of two normalized\n /// chi-squared distributions, that is, `F(m,n) = (\u03c7\u00b2(m)/m) /\n /// (\u03c7\u00b2(n)/n)`.\n pub struct FisherF {"}, {"sha": "47967a719d397a8972d39bf4e90ac356721af550", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -149,7 +149,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n                 \"WeightedChoice::new called with a total weight of 0\");\n \n         WeightedChoice {\n-            items: items,\n+            items,\n             // we're likely to be generating numbers in this range\n             // relatively often, so might as well cache it\n             weight_range: Range::new(0, running_total),"}, {"sha": "e1518dab21c2b9bb3215f6fa805547d39d44d40f", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -103,8 +103,8 @@ impl Normal {\n     pub fn new(mean: f64, std_dev: f64) -> Normal {\n         assert!(std_dev >= 0.0, \"Normal::new called with `std_dev` < 0\");\n         Normal {\n-            mean: mean,\n-            std_dev: std_dev,\n+            mean,\n+            std_dev,\n         }\n     }\n }"}, {"sha": "f2f8132e5b47ba18fa6910bb06abc7bf972728cc", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -104,7 +104,7 @@ macro_rules! integer_impl {\n                 let zone = unsigned_max - unsigned_max % range;\n \n                 Range {\n-                    low: low,\n+                    low,\n                     range: range as $ty,\n                     accept_zone: zone as $ty\n                 }\n@@ -143,7 +143,7 @@ macro_rules! float_impl {\n         impl SampleRange for $ty {\n             fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n                 Range {\n-                    low: low,\n+                    low,\n                     range: high - low,\n                     accept_zone: 0.0 // unused\n                 }"}, {"sha": "96ce0905e384da72f72f008acd0f8be8dc71fad7", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -76,7 +76,7 @@ impl IsaacRng {\n         rng\n     }\n \n-    /// Initialises `self`. If `use_rsl` is true, then use the current value\n+    /// Initializes `self`. If `use_rsl` is true, then use the current value\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n     fn init(&mut self, use_rsl: bool) {\n@@ -367,7 +367,7 @@ impl Isaac64Rng {\n         rng\n     }\n \n-    /// Initialises `self`. If `use_rsl` is true, then use the current value\n+    /// Initializes `self`. If `use_rsl` is true, then use the current value\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n     fn init(&mut self, use_rsl: bool) {"}, {"sha": "90b3020fff9d1ebfa6a9bb2c1baef5220fd2db45", "filename": "src/librand/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -16,8 +16,6 @@\n //! is not recommended to use this library directly, but rather the official\n //! interface through `std::rand`.\n \n-#![crate_name = \"rand\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -180,7 +178,7 @@ pub trait Rng: Sized {\n     /// This method does *not* have a requirement to bear any fixed\n     /// relationship to the other methods, for example, it does *not*\n     /// have to result in the same output as progressively filling\n-    /// `dest` with `self.gen::<u8>()`, and any such behaviour should\n+    /// `dest` with `self.gen::<u8>()`, and any such behavior should\n     /// not be relied upon.\n     ///\n     /// This method should guarantee that `dest` is entirely filled\n@@ -418,10 +416,10 @@ impl Rand for XorShiftRng {\n         }\n         let (x, y, z, w) = tuple;\n         XorShiftRng {\n-            x: x,\n-            y: y,\n-            z: z,\n-            w: w,\n+            x,\n+            y,\n+            z,\n+            w,\n         }\n     }\n }"}, {"sha": "2821b7a8232df4622e4a12df47c49115c22aaff1", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -24,7 +24,7 @@ pub struct ReseedingRng<R, Rsdr> {\n     rng: R,\n     generation_threshold: usize,\n     bytes_generated: usize,\n-    /// Controls the behaviour when reseeding the RNG.\n+    /// Controls the behavior when reseeding the RNG.\n     pub reseeder: Rsdr,\n }\n \n@@ -38,10 +38,10 @@ impl<R: Rng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {\n     /// * `reseeder`: the reseeding object to use.\n     pub fn new(rng: R, generation_threshold: usize, reseeder: Rsdr) -> ReseedingRng<R, Rsdr> {\n         ReseedingRng {\n-            rng: rng,\n-            generation_threshold: generation_threshold,\n+            rng,\n+            generation_threshold,\n             bytes_generated: 0,\n-            reseeder: reseeder,\n+            reseeder,\n         }\n     }\n "}, {"sha": "01fff60528394366345e212528a0c04b4b43ed33", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -411,6 +411,8 @@ define_dep_nodes!( <'tcx>\n \n     [] BorrowCheckKrate,\n     [] BorrowCheck(DefId),\n+    [] MirBorrowCheck(DefId),\n+\n     [] RvalueCheck(DefId),\n     [] Reachability,\n     [] MirKeys,\n@@ -520,6 +522,8 @@ define_dep_nodes!( <'tcx>\n     [] DylibDepFormats(DefId),\n     [] IsAllocator(DefId),\n     [] IsPanicRuntime(DefId),\n+    [] IsCompilerBuiltins(DefId),\n+    [] HasGlobalAllocator(DefId),\n     [] ExternCrate(DefId),\n     [] LintLevels,\n );"}, {"sha": "809d1dfcf60a2ff479798bc722197e958a312b99", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -244,8 +244,8 @@ impl DepGraphEdges {\n         self.edges.insert((source, target));\n     }\n \n-    pub fn add_node(&mut self, node: DepNode) {\n-        self.get_or_create_node(node);\n+    pub fn add_node(&mut self, node: DepNode) -> DepNodeIndex {\n+        self.get_or_create_node(node)\n     }\n \n     #[inline]"}, {"sha": "c487fc963ca14a46ae9f0b01eb8e2ded237247b2", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n+use util::common::{ProfileQueriesMsg, profq_msg};\n \n use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n@@ -118,7 +119,13 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_task(key);\n+            if cfg!(debug_assertions) {\n+                profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n+            };\n             let result = task(cx, arg);\n+            if cfg!(debug_assertions) {\n+                profq_msg(ProfileQueriesMsg::TaskEnd)\n+            };\n             let dep_node_index = data.edges.borrow_mut().pop_task(key);\n             (result, dep_node_index)\n         } else {\n@@ -166,6 +173,14 @@ impl DepGraph {\n         self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n     }\n \n+    pub fn alloc_input_node(&self, node: DepNode) -> DepNodeIndex {\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().add_node(node)\n+        } else {\n+            DepNodeIndex::INVALID\n+        }\n+    }\n+\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory)."}, {"sha": "412759e11423e94ed22176988b06ba484b1833e7", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -362,6 +362,10 @@ Here are some simple examples of where you'll run into this error:\n struct Foo { x: &bool }        // error\n struct Foo<'a> { x: &'a bool } // correct\n \n+struct Bar { x: Foo }\n+               ^^^ expected lifetime parameter\n+struct Bar<'a> { x: Foo<'a> } // correct\n+\n enum Bar { A(u8), B(&bool), }        // error\n enum Bar<'a> { A(u8), B(&'a bool), } // correct\n \n@@ -683,6 +687,21 @@ attributes:\n See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n \"##,\n \n+E0214: r##\"\n+A generic type was described using parentheses rather than angle brackets. For\n+example:\n+\n+```compile_fail,E0214\n+fn main() {\n+    let v: Vec(&str) = vec![\"foo\"];\n+}\n+```\n+\n+This is not currently supported: `v` should be defined as `Vec<&str>`.\n+Parentheses are currently only used with generic types when defining parameters\n+for `Fn`-family traits.\n+\"##,\n+\n E0261: r##\"\n When using a lifetime like `'a` in a type, it must be declared before being\n used."}, {"sha": "d52cc26eaebc666afcc248d19048cde449e5cd40", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -617,17 +617,9 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                 _path_span: Span,\n                                                 path_parameters: &'v PathParameters) {\n-    match *path_parameters {\n-        AngleBracketedParameters(ref data) => {\n-            walk_list!(visitor, visit_ty, &data.types);\n-            walk_list!(visitor, visit_lifetime, &data.lifetimes);\n-            walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n-        }\n-        ParenthesizedParameters(ref data) => {\n-            walk_list!(visitor, visit_ty, &data.inputs);\n-            walk_list!(visitor, visit_ty, &data.output);\n-        }\n-    }\n+    walk_list!(visitor, visit_lifetime, &path_parameters.lifetimes);\n+    walk_list!(visitor, visit_ty, &path_parameters.types);\n+    walk_list!(visitor, visit_assoc_type_binding, &path_parameters.bindings);\n }\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -835,7 +827,16 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     // NB: Deliberately force a compilation error if/when new fields are added.\n-    let ImplItem { id: _, name, ref vis, ref defaultness, ref attrs, ref node, span } = *impl_item;\n+    let ImplItem {\n+        id: _,\n+        hir_id: _,\n+        name,\n+        ref vis,\n+        ref defaultness,\n+        ref attrs,\n+        ref node,\n+        span\n+    } = *impl_item;\n \n     visitor.visit_name(span, name);\n     visitor.visit_vis(vis);"}, {"sha": "ac26cbc833dea0b073028f493dec2fea43cc8195", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 107, "deletions": 38, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -45,21 +45,22 @@ use hir::map::{Definitions, DefKey, REGULAR_SPACE};\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX};\n use hir::def::{Def, PathResolution};\n+use lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n+use util::common::FN_OUTPUT_NAME;\n use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n use std::collections::BTreeMap;\n use std::fmt::Debug;\n use std::iter;\n use std::mem;\n-\n use syntax::attr;\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n-use syntax::codemap::{self, respan, Spanned};\n+use syntax::codemap::{self, respan, Spanned, CompilerDesugaringKind};\n use syntax::std_inject;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::small_vector::SmallVector;\n@@ -160,6 +161,12 @@ struct LoweredNodeId {\n     hir_id: hir::HirId,\n }\n \n+enum ParenthesizedGenericArgs {\n+    Ok,\n+    Warn,\n+    Err,\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -414,12 +421,14 @@ impl<'a> LoweringContext<'a> {\n         Symbol::gensym(s)\n     }\n \n-    fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n+    fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, mut span: Span)\n+        -> Span\n+    {\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n-                format: codemap::CompilerDesugaring(Symbol::intern(reason)),\n+                format: codemap::CompilerDesugaring(reason),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n                 allow_internal_unsafe: false,\n@@ -747,6 +756,21 @@ impl<'a> LoweringContext<'a> {\n                     Def::Trait(def_id) if i + 1 == proj_start => Some(def_id),\n                     _ => None\n                 };\n+                let parenthesized_generic_args = match resolution.base_def() {\n+                    // `a::b::Trait(Args)`\n+                    Def::Trait(..) if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n+                    // `a::b::Trait(Args)::TraitItem`\n+                    Def::Method(..) |\n+                    Def::AssociatedConst(..) |\n+                    Def::AssociatedTy(..) if i + 2 == proj_start => ParenthesizedGenericArgs::Ok,\n+                    // Avoid duplicated errors\n+                    Def::Err => ParenthesizedGenericArgs::Ok,\n+                    // An error\n+                    Def::Struct(..) | Def::Enum(..) | Def::Union(..) | Def::TyAlias(..) |\n+                    Def::Variant(..) if i + 1 == proj_start => ParenthesizedGenericArgs::Err,\n+                    // A warning for now, for compatibility reasons\n+                    _ => ParenthesizedGenericArgs::Warn,\n+                };\n \n                 let num_lifetimes = type_def_id.map_or(0, |def_id| {\n                     if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n@@ -757,7 +781,8 @@ impl<'a> LoweringContext<'a> {\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });\n-                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes)\n+                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes,\n+                                        parenthesized_generic_args)\n             }).collect(),\n             span: p.span,\n         });\n@@ -792,7 +817,8 @@ impl<'a> LoweringContext<'a> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0));\n+            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0,\n+                                                    ParenthesizedGenericArgs::Warn));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n             // It's finished, return the extension of the right node type.\n@@ -825,7 +851,8 @@ impl<'a> LoweringContext<'a> {\n         hir::Path {\n             def: self.expect_full_def(id),\n             segments: segments.map(|segment| {\n-                self.lower_path_segment(p.span, segment, param_mode, 0)\n+                self.lower_path_segment(p.span, segment, param_mode, 0,\n+                                        ParenthesizedGenericArgs::Err)\n             }).chain(name.map(|name| {\n                 hir::PathSegment {\n                     name,\n@@ -849,29 +876,37 @@ impl<'a> LoweringContext<'a> {\n                           path_span: Span,\n                           segment: &PathSegment,\n                           param_mode: ParamMode,\n-                          expected_lifetimes: usize)\n+                          expected_lifetimes: usize,\n+                          parenthesized_generic_args: ParenthesizedGenericArgs)\n                           -> hir::PathSegment {\n         let mut parameters = if let Some(ref parameters) = segment.parameters {\n+            let msg = \"parenthesized parameters may only be used with a trait\";\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n-                    let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n-                    hir::AngleBracketedParameters(data)\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode)\n                 }\n-                PathParameters::Parenthesized(ref data) => {\n-                    hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data))\n+                PathParameters::Parenthesized(ref data) => match parenthesized_generic_args {\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Warn => {\n+                        self.sess.buffer_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+                                              CRATE_NODE_ID, data.span, msg.into());\n+                        hir::PathParameters::none()\n+                    }\n+                    ParenthesizedGenericArgs::Err => {\n+                        struct_span_err!(self.sess, data.span, E0214, \"{}\", msg)\n+                            .span_label(data.span, \"only traits may use parentheses\").emit();\n+                        hir::PathParameters::none()\n+                    }\n                 }\n             }\n         } else {\n-            let data = self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode);\n-            hir::AngleBracketedParameters(data)\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode)\n         };\n \n-        if let hir::AngleBracketedParameters(ref mut data) = parameters {\n-            if data.lifetimes.is_empty() {\n-                data.lifetimes = (0..expected_lifetimes).map(|_| {\n-                    self.elided_lifetime(path_span)\n-                }).collect();\n-            }\n+        if !parameters.parenthesized && parameters.lifetimes.is_empty() {\n+            parameters.lifetimes = (0..expected_lifetimes).map(|_| {\n+                self.elided_lifetime(path_span)\n+            }).collect();\n         }\n \n         hir::PathSegment {\n@@ -883,24 +918,38 @@ impl<'a> LoweringContext<'a> {\n     fn lower_angle_bracketed_parameter_data(&mut self,\n                                             data: &AngleBracketedParameterData,\n                                             param_mode: ParamMode)\n-                                            -> hir::AngleBracketedParameterData {\n+                                            -> hir::PathParameters {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings, .. } = data;\n-        hir::AngleBracketedParameterData {\n+        hir::PathParameters {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n             infer_types: types.is_empty() && param_mode == ParamMode::Optional,\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n+            parenthesized: false,\n         }\n     }\n \n     fn lower_parenthesized_parameter_data(&mut self,\n                                           data: &ParenthesizedParameterData)\n-                                          -> hir::ParenthesizedParameterData {\n+                                          -> hir::PathParameters {\n         let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n-        hir::ParenthesizedParameterData {\n-            inputs: inputs.iter().map(|ty| self.lower_ty(ty)).collect(),\n-            output: output.as_ref().map(|ty| self.lower_ty(ty)),\n-            span,\n+        let inputs = inputs.iter().map(|ty| self.lower_ty(ty)).collect();\n+        let mk_tup = |this: &mut Self, tys, span| {\n+            P(hir::Ty { node: hir::TyTup(tys), id: this.next_id().node_id, span })\n+        };\n+\n+        hir::PathParameters {\n+            lifetimes: hir::HirVec::new(),\n+            types: hir_vec![mk_tup(self, inputs, span)],\n+            infer_types: false,\n+            bindings: hir_vec![hir::TypeBinding {\n+                id: self.next_id().node_id,\n+                name: Symbol::intern(FN_OUTPUT_NAME),\n+                ty: output.as_ref().map(|ty| self.lower_ty(&ty))\n+                                   .unwrap_or_else(|| mk_tup(self, hir::HirVec::new(), span)),\n+                span: output.as_ref().map_or(span, |ty| ty.span),\n+            }],\n+            parenthesized: true,\n         }\n     }\n \n@@ -1266,7 +1315,12 @@ impl<'a> LoweringContext<'a> {\n                             path.span = span;\n \n                             self.allocate_hir_id_counter(import.id, import);\n-                            self.with_hir_id_owner(import.id, |this| {\n+                            let LoweredNodeId {\n+                                node_id: import_node_id,\n+                                hir_id: import_hir_id,\n+                            } = self.lower_node_id(import.id);\n+\n+                            self.with_hir_id_owner(import_node_id, |this| {\n                                 let vis = match *vis {\n                                     hir::Visibility::Public => hir::Visibility::Public,\n                                     hir::Visibility::Crate => hir::Visibility::Crate,\n@@ -1280,8 +1334,9 @@ impl<'a> LoweringContext<'a> {\n                                     }\n                                 };\n \n-                                this.items.insert(import.id, hir::Item {\n-                                    id: import.id,\n+                                this.items.insert(import_node_id, hir::Item {\n+                                    id: import_node_id,\n+                                    hir_id: import_hir_id,\n                                     name: import.rename.unwrap_or(ident).name,\n                                     attrs: attrs.clone(),\n                                     node: hir::ItemUse(P(path), hir::UseKind::Single),\n@@ -1412,8 +1467,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n+            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+\n             hir::TraitItem {\n-                id: this.lower_node_id(i.id).node_id,\n+                id: node_id,\n+                hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1473,8 +1531,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n+            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+\n             hir::ImplItem {\n-                id: this.lower_node_id(i.id).node_id,\n+                id: node_id,\n+                hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis, None),\n@@ -1565,8 +1626,11 @@ impl<'a> LoweringContext<'a> {\n             this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+\n         Some(hir::Item {\n-            id: self.lower_node_id(i.id).node_id,\n+            id: node_id,\n+            hir_id,\n             name,\n             attrs,\n             node,\n@@ -1790,7 +1854,8 @@ impl<'a> LoweringContext<'a> {\n                 let move_val_init = [\"intrinsics\", \"move_val_init\"];\n                 let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n-                let unstable_span = self.allow_internal_unstable(\"<-\", e.span);\n+                let unstable_span =\n+                    self.allow_internal_unstable(CompilerDesugaringKind::BackArrow, e.span);\n                 let make_call = |this: &mut LoweringContext, p, args| {\n                     let path = P(this.expr_std_path(unstable_span, p, ThinVec::new()));\n                     P(this.expr_call(e.span, path, args))\n@@ -1874,7 +1939,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprCall(f, args.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0);\n+                let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0,\n+                                                      ParenthesizedGenericArgs::Err);\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprMethodCall(hir_seg, seg.span, args)\n             }\n@@ -2007,12 +2073,14 @@ impl<'a> LoweringContext<'a> {\n                     e1.iter().map(|e| (\"start\", e)).chain(e2.iter().map(|e| (\"end\", e)))\n                     .map(|(s, e)| {\n                         let expr = P(self.lower_expr(&e));\n-                        let unstable_span = self.allow_internal_unstable(\"...\", e.span);\n+                        let unstable_span =\n+                            self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n                         self.field(Symbol::intern(s), expr, unstable_span)\n                     }).collect::<P<[hir::Field]>>();\n \n                 let is_unit = fields.is_empty();\n-                let unstable_span = self.allow_internal_unstable(\"...\", e.span);\n+                let unstable_span =\n+                    self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n                 let struct_path =\n                     iter::once(\"ops\").chain(iter::once(path))\n                     .collect::<Vec<_>>();\n@@ -2353,7 +2421,8 @@ impl<'a> LoweringContext<'a> {\n                 //                 return Try::from_error(From::from(err)),\n                 // }\n \n-                let unstable_span = self.allow_internal_unstable(\"?\", e.span);\n+                let unstable_span =\n+                    self.allow_internal_unstable(CompilerDesugaringKind::QuestionMark, e.span);\n \n                 // Try::into_result(<expr>)\n                 let discr = {"}, {"sha": "a54068c648310ffbda503d9ba5f8c1925a0e6a7c", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 173, "deletions": 30, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -10,33 +10,55 @@\n \n use super::*;\n \n+use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n \n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n-pub struct NodeCollector<'hir> {\n+pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n-    pub krate: &'hir Crate,\n+    krate: &'hir Crate,\n     /// The node map\n-    pub(super) map: Vec<MapEntry<'hir>>,\n+    map: Vec<MapEntry<'hir>>,\n     /// The parent of this node\n-    pub parent_node: NodeId,\n+    parent_node: NodeId,\n+\n+    current_dep_node_owner: DefIndex,\n+    current_dep_node_index: DepNodeIndex,\n+\n+    dep_graph: &'a DepGraph,\n+    definitions: &'a definitions::Definitions,\n }\n \n-impl<'hir> NodeCollector<'hir> {\n-    pub fn root(krate: &'hir Crate) -> NodeCollector<'hir> {\n+impl<'a, 'hir> NodeCollector<'a, 'hir> {\n+    pub(super) fn root(krate: &'hir Crate,\n+                dep_graph: &'a DepGraph,\n+                definitions: &'a definitions::Definitions)\n+                -> NodeCollector<'a, 'hir> {\n+        let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n+        let root_mod_dep_node = root_mod_def_path_hash.to_dep_node(DepKind::Hir);\n+        let root_mod_dep_node_index = dep_graph.alloc_input_node(root_mod_dep_node);\n+\n         let mut collector = NodeCollector {\n             krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n+            current_dep_node_index: root_mod_dep_node_index,\n+            current_dep_node_owner: CRATE_DEF_INDEX,\n+            dep_graph,\n+            definitions,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_dep_node_index));\n \n         collector\n     }\n \n+    pub(super) fn into_map(self) -> Vec<MapEntry<'hir>> {\n+        self.map\n+    }\n+\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n@@ -47,8 +69,55 @@ impl<'hir> NodeCollector<'hir> {\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n-        let entry = MapEntry::from_node(self.parent_node, node);\n+        let parent = self.parent_node;\n+        let dep_node_index = self.current_dep_node_index;\n+\n+        let entry = match node {\n+            NodeItem(n) => EntryItem(parent, dep_node_index, n),\n+            NodeForeignItem(n) => EntryForeignItem(parent, dep_node_index, n),\n+            NodeTraitItem(n) => EntryTraitItem(parent, dep_node_index, n),\n+            NodeImplItem(n) => EntryImplItem(parent, dep_node_index, n),\n+            NodeVariant(n) => EntryVariant(parent, dep_node_index, n),\n+            NodeField(n) => EntryField(parent, dep_node_index, n),\n+            NodeExpr(n) => EntryExpr(parent, dep_node_index, n),\n+            NodeStmt(n) => EntryStmt(parent, dep_node_index, n),\n+            NodeTy(n) => EntryTy(parent, dep_node_index, n),\n+            NodeTraitRef(n) => EntryTraitRef(parent, dep_node_index, n),\n+            NodeBinding(n) => EntryBinding(parent, dep_node_index, n),\n+            NodePat(n) => EntryPat(parent, dep_node_index, n),\n+            NodeBlock(n) => EntryBlock(parent, dep_node_index, n),\n+            NodeStructCtor(n) => EntryStructCtor(parent, dep_node_index, n),\n+            NodeLifetime(n) => EntryLifetime(parent, dep_node_index, n),\n+            NodeTyParam(n) => EntryTyParam(parent, dep_node_index, n),\n+            NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n+            NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n+        };\n+\n+        // Make sure that the DepNode of some node coincides with the HirId\n+        // owner of that node.\n+        if cfg!(debug_assertions) {\n+            let hir_id_owner = self.definitions.node_to_hir_id(id).owner;\n+\n+            if hir_id_owner != self.current_dep_node_owner {\n+                let node_str = match self.definitions.opt_def_index(id) {\n+                    Some(def_index) => {\n+                        self.definitions.def_path(def_index).to_string_no_crate()\n+                    }\n+                    None => format!(\"{:?}\", node)\n+                };\n+\n+                bug!(\"inconsistent DepNode for `{}`: \\\n+                      current_dep_node_owner={}, hir_id.owner={}\",\n+                    node_str,\n+                    self.definitions\n+                        .def_path(self.current_dep_node_owner)\n+                        .to_string_no_crate(),\n+                    self.definitions.def_path(hir_id_owner).to_string_no_crate())\n+            }\n+        }\n+\n         self.insert_entry(id, entry);\n+\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_id: NodeId, f: F) {\n@@ -57,9 +126,27 @@ impl<'hir> NodeCollector<'hir> {\n         f(self);\n         self.parent_node = parent_node;\n     }\n+\n+    fn with_dep_node_owner<F: FnOnce(&mut Self)>(&mut self,\n+                                                 dep_node_owner: DefIndex,\n+                                                 f: F) {\n+        let prev_owner = self.current_dep_node_owner;\n+        let prev_index = self.current_dep_node_index;\n+\n+        // When we enter a new owner (item, impl item, or trait item), we always\n+        // start out again with DepKind::Hir.\n+        let new_dep_node = self.definitions\n+                               .def_path_hash(dep_node_owner)\n+                               .to_dep_node(DepKind::Hir);\n+        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        self.current_dep_node_owner = dep_node_owner;\n+        f(self);\n+        self.current_dep_node_index = prev_index;\n+        self.current_dep_node_owner = prev_owner;\n+    }\n }\n \n-impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n+impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n@@ -82,25 +169,37 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n+        // When we enter a body, we switch to DepKind::HirBody.\n+        // Note that current_dep_node_index might already be DepKind::HirBody,\n+        // e.g. when entering the body of a closure that is already part of a\n+        // surrounding body. That's expected and not a problem.\n+        let prev_index = self.current_dep_node_index;\n+        let new_dep_node = self.definitions\n+                               .def_path_hash(self.current_dep_node_owner)\n+                               .to_dep_node(DepKind::HirBody);\n+        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n         self.visit_body(self.krate.body(id));\n+        self.current_dep_node_index = prev_index;\n     }\n \n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n-\n-        self.insert(i.id, NodeItem(i));\n-\n-        self.with_parent(i.id, |this| {\n-            match i.node {\n-                ItemStruct(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+        debug_assert_eq!(i.hir_id.owner,\n+                         self.definitions.opt_def_index(i.id).unwrap());\n+        self.with_dep_node_owner(i.hir_id.owner, |this| {\n+            this.insert(i.id, NodeItem(i));\n+            this.with_parent(i.id, |this| {\n+                match i.node {\n+                    ItemStruct(ref struct_def, _) => {\n+                        // If this is a tuple-like struct, register the constructor.\n+                        if !struct_def.is_struct() {\n+                            this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                        }\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n-            }\n-            intravisit::walk_item(this, i);\n+                intravisit::walk_item(this, i);\n+            });\n         });\n     }\n \n@@ -121,24 +220,32 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n-        self.insert(ti.id, NodeTraitItem(ti));\n-\n-        self.with_parent(ti.id, |this| {\n-            intravisit::walk_trait_item(this, ti);\n+        debug_assert_eq!(ti.hir_id.owner,\n+                         self.definitions.opt_def_index(ti.id).unwrap());\n+        self.with_dep_node_owner(ti.hir_id.owner, |this| {\n+            this.insert(ti.id, NodeTraitItem(ti));\n+\n+            this.with_parent(ti.id, |this| {\n+                intravisit::walk_trait_item(this, ti);\n+            });\n         });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n-        self.insert(ii.id, NodeImplItem(ii));\n-\n-        self.with_parent(ii.id, |this| {\n-            intravisit::walk_impl_item(this, ii);\n+        debug_assert_eq!(ii.hir_id.owner,\n+                         self.definitions.opt_def_index(ii.id).unwrap());\n+        self.with_dep_node_owner(ii.hir_id.owner, |this| {\n+            this.insert(ii.id, NodeImplItem(ii));\n+\n+            this.with_parent(ii.id, |this| {\n+                intravisit::walk_impl_item(this, ii);\n+            });\n         });\n     }\n \n     fn visit_pat(&mut self, pat: &'hir Pat) {\n         let node = if let PatKind::Binding(..) = pat.node {\n-            NodeLocal(pat)\n+            NodeBinding(pat)\n         } else {\n             NodePat(pat)\n         };\n@@ -195,6 +302,13 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n         });\n     }\n \n+    fn visit_local(&mut self, l: &'hir Local) {\n+        self.insert(l.id, NodeLocal(l));\n+        self.with_parent(l.id, |this| {\n+            intravisit::walk_local(this, l)\n+        })\n+    }\n+\n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n@@ -231,4 +345,33 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n             intravisit::walk_struct_field(this, field);\n         });\n     }\n+\n+    fn visit_trait_item_ref(&mut self, ii: &'hir TraitItemRef) {\n+        // Do not visit the duplicate information in TraitItemRef. We want to\n+        // map the actual nodes, not the duplicate ones in the *Ref.\n+        let TraitItemRef {\n+            id,\n+            name: _,\n+            kind: _,\n+            span: _,\n+            defaultness: _,\n+        } = *ii;\n+\n+        self.visit_nested_trait_item(id);\n+    }\n+\n+    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef) {\n+        // Do not visit the duplicate information in ImplItemRef. We want to\n+        // map the actual nodes, not the duplicate ones in the *Ref.\n+        let ImplItemRef {\n+            id,\n+            name: _,\n+            kind: _,\n+            span: _,\n+            vis: _,\n+            defaultness: _,\n+        } = *ii;\n+\n+        self.visit_nested_impl_item(id);\n+    }\n }"}, {"sha": "63a5b70cb81a9f2ba60ad756d7987f00df16717d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 143, "deletions": 193, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -15,7 +15,7 @@ pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, DefPathHash};\n \n-use dep_graph::{DepGraph, DepNode, DepKind};\n+use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndexAddressSpace};\n \n@@ -53,9 +53,10 @@ pub enum Node<'hir> {\n     NodeStmt(&'hir Stmt),\n     NodeTy(&'hir Ty),\n     NodeTraitRef(&'hir TraitRef),\n-    NodeLocal(&'hir Pat),\n+    NodeBinding(&'hir Pat),\n     NodePat(&'hir Pat),\n     NodeBlock(&'hir Block),\n+    NodeLocal(&'hir Local),\n \n     /// NodeStructCtor represents a tuple struct.\n     NodeStructCtor(&'hir VariantData),\n@@ -73,26 +74,28 @@ enum MapEntry<'hir> {\n     NotPresent,\n \n     /// All the node types, with a parent ID.\n-    EntryItem(NodeId, &'hir Item),\n-    EntryForeignItem(NodeId, &'hir ForeignItem),\n-    EntryTraitItem(NodeId, &'hir TraitItem),\n-    EntryImplItem(NodeId, &'hir ImplItem),\n-    EntryVariant(NodeId, &'hir Variant),\n-    EntryField(NodeId, &'hir StructField),\n-    EntryExpr(NodeId, &'hir Expr),\n-    EntryStmt(NodeId, &'hir Stmt),\n-    EntryTy(NodeId, &'hir Ty),\n-    EntryTraitRef(NodeId, &'hir TraitRef),\n-    EntryLocal(NodeId, &'hir Pat),\n-    EntryPat(NodeId, &'hir Pat),\n-    EntryBlock(NodeId, &'hir Block),\n-    EntryStructCtor(NodeId, &'hir VariantData),\n-    EntryLifetime(NodeId, &'hir Lifetime),\n-    EntryTyParam(NodeId, &'hir TyParam),\n-    EntryVisibility(NodeId, &'hir Visibility),\n-\n-    /// Roots for node trees.\n-    RootCrate,\n+    EntryItem(NodeId, DepNodeIndex, &'hir Item),\n+    EntryForeignItem(NodeId, DepNodeIndex, &'hir ForeignItem),\n+    EntryTraitItem(NodeId, DepNodeIndex, &'hir TraitItem),\n+    EntryImplItem(NodeId, DepNodeIndex, &'hir ImplItem),\n+    EntryVariant(NodeId, DepNodeIndex, &'hir Variant),\n+    EntryField(NodeId, DepNodeIndex, &'hir StructField),\n+    EntryExpr(NodeId, DepNodeIndex, &'hir Expr),\n+    EntryStmt(NodeId, DepNodeIndex, &'hir Stmt),\n+    EntryTy(NodeId, DepNodeIndex, &'hir Ty),\n+    EntryTraitRef(NodeId, DepNodeIndex, &'hir TraitRef),\n+    EntryBinding(NodeId, DepNodeIndex, &'hir Pat),\n+    EntryPat(NodeId, DepNodeIndex, &'hir Pat),\n+    EntryBlock(NodeId, DepNodeIndex, &'hir Block),\n+    EntryStructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n+    EntryLifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n+    EntryTyParam(NodeId, DepNodeIndex, &'hir TyParam),\n+    EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n+    EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n+\n+    /// Roots for node trees. The DepNodeIndex is the dependency node of the\n+    /// crate's root module.\n+    RootCrate(DepNodeIndex),\n }\n \n impl<'hir> Clone for MapEntry<'hir> {\n@@ -102,79 +105,59 @@ impl<'hir> Clone for MapEntry<'hir> {\n }\n \n impl<'hir> MapEntry<'hir> {\n-    fn from_node(p: NodeId, node: Node<'hir>) -> MapEntry<'hir> {\n-        match node {\n-            NodeItem(n) => EntryItem(p, n),\n-            NodeForeignItem(n) => EntryForeignItem(p, n),\n-            NodeTraitItem(n) => EntryTraitItem(p, n),\n-            NodeImplItem(n) => EntryImplItem(p, n),\n-            NodeVariant(n) => EntryVariant(p, n),\n-            NodeField(n) => EntryField(p, n),\n-            NodeExpr(n) => EntryExpr(p, n),\n-            NodeStmt(n) => EntryStmt(p, n),\n-            NodeTy(n) => EntryTy(p, n),\n-            NodeTraitRef(n) => EntryTraitRef(p, n),\n-            NodeLocal(n) => EntryLocal(p, n),\n-            NodePat(n) => EntryPat(p, n),\n-            NodeBlock(n) => EntryBlock(p, n),\n-            NodeStructCtor(n) => EntryStructCtor(p, n),\n-            NodeLifetime(n) => EntryLifetime(p, n),\n-            NodeTyParam(n) => EntryTyParam(p, n),\n-            NodeVisibility(n) => EntryVisibility(p, n),\n-        }\n-    }\n-\n     fn parent_node(self) -> Option<NodeId> {\n         Some(match self {\n-            EntryItem(id, _) => id,\n-            EntryForeignItem(id, _) => id,\n-            EntryTraitItem(id, _) => id,\n-            EntryImplItem(id, _) => id,\n-            EntryVariant(id, _) => id,\n-            EntryField(id, _) => id,\n-            EntryExpr(id, _) => id,\n-            EntryStmt(id, _) => id,\n-            EntryTy(id, _) => id,\n-            EntryTraitRef(id, _) => id,\n-            EntryLocal(id, _) => id,\n-            EntryPat(id, _) => id,\n-            EntryBlock(id, _) => id,\n-            EntryStructCtor(id, _) => id,\n-            EntryLifetime(id, _) => id,\n-            EntryTyParam(id, _) => id,\n-            EntryVisibility(id, _) => id,\n+            EntryItem(id, _, _) => id,\n+            EntryForeignItem(id, _, _) => id,\n+            EntryTraitItem(id, _, _) => id,\n+            EntryImplItem(id, _, _) => id,\n+            EntryVariant(id, _, _) => id,\n+            EntryField(id, _, _) => id,\n+            EntryExpr(id, _, _) => id,\n+            EntryStmt(id, _, _) => id,\n+            EntryTy(id, _, _) => id,\n+            EntryTraitRef(id, _, _) => id,\n+            EntryBinding(id, _, _) => id,\n+            EntryPat(id, _, _) => id,\n+            EntryBlock(id, _, _) => id,\n+            EntryStructCtor(id, _, _) => id,\n+            EntryLifetime(id, _, _) => id,\n+            EntryTyParam(id, _, _) => id,\n+            EntryVisibility(id, _, _) => id,\n+            EntryLocal(id, _, _) => id,\n \n             NotPresent |\n-            RootCrate => return None,\n+            RootCrate(_) => return None,\n         })\n     }\n \n     fn to_node(self) -> Option<Node<'hir>> {\n         Some(match self {\n-            EntryItem(_, n) => NodeItem(n),\n-            EntryForeignItem(_, n) => NodeForeignItem(n),\n-            EntryTraitItem(_, n) => NodeTraitItem(n),\n-            EntryImplItem(_, n) => NodeImplItem(n),\n-            EntryVariant(_, n) => NodeVariant(n),\n-            EntryField(_, n) => NodeField(n),\n-            EntryExpr(_, n) => NodeExpr(n),\n-            EntryStmt(_, n) => NodeStmt(n),\n-            EntryTy(_, n) => NodeTy(n),\n-            EntryTraitRef(_, n) => NodeTraitRef(n),\n-            EntryLocal(_, n) => NodeLocal(n),\n-            EntryPat(_, n) => NodePat(n),\n-            EntryBlock(_, n) => NodeBlock(n),\n-            EntryStructCtor(_, n) => NodeStructCtor(n),\n-            EntryLifetime(_, n) => NodeLifetime(n),\n-            EntryTyParam(_, n) => NodeTyParam(n),\n-            EntryVisibility(_, n) => NodeVisibility(n),\n+            EntryItem(_, _, n) => NodeItem(n),\n+            EntryForeignItem(_, _, n) => NodeForeignItem(n),\n+            EntryTraitItem(_, _, n) => NodeTraitItem(n),\n+            EntryImplItem(_, _, n) => NodeImplItem(n),\n+            EntryVariant(_, _, n) => NodeVariant(n),\n+            EntryField(_, _, n) => NodeField(n),\n+            EntryExpr(_, _, n) => NodeExpr(n),\n+            EntryStmt(_, _, n) => NodeStmt(n),\n+            EntryTy(_, _, n) => NodeTy(n),\n+            EntryTraitRef(_, _, n) => NodeTraitRef(n),\n+            EntryBinding(_, _, n) => NodeBinding(n),\n+            EntryPat(_, _, n) => NodePat(n),\n+            EntryBlock(_, _, n) => NodeBlock(n),\n+            EntryStructCtor(_, _, n) => NodeStructCtor(n),\n+            EntryLifetime(_, _, n) => NodeLifetime(n),\n+            EntryTyParam(_, _, n) => NodeTyParam(n),\n+            EntryVisibility(_, _, n) => NodeVisibility(n),\n+            EntryLocal(_, _, n) => NodeLocal(n),\n             _ => return None\n         })\n     }\n \n     fn associated_body(self) -> Option<BodyId> {\n         match self {\n-            EntryItem(_, item) => {\n+            EntryItem(_, _, item) => {\n                 match item.node {\n                     ItemConst(_, body) |\n                     ItemStatic(.., body) |\n@@ -183,23 +166,23 @@ impl<'hir> MapEntry<'hir> {\n                 }\n             }\n \n-            EntryTraitItem(_, item) => {\n+            EntryTraitItem(_, _, item) => {\n                 match item.node {\n                     TraitItemKind::Const(_, Some(body)) |\n                     TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n                     _ => None\n                 }\n             }\n \n-            EntryImplItem(_, item) => {\n+            EntryImplItem(_, _, item) => {\n                 match item.node {\n                     ImplItemKind::Const(_, body) |\n                     ImplItemKind::Method(_, body) => Some(body),\n                     _ => None,\n                 }\n             }\n \n-            EntryExpr(_, expr) => {\n+            EntryExpr(_, _, expr) => {\n                 match expr.node {\n                     ExprClosure(.., body, _) => Some(body),\n                     _ => None,\n@@ -277,82 +260,40 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, id: NodeId) {\n-        self.dep_graph.read(self.dep_node(id));\n-    }\n-\n-    fn dep_node(&self, id0: NodeId) -> DepNode {\n-        let mut id = id0;\n-        let mut last_expr = None;\n-        loop {\n-            let entry = self.map[id.as_usize()];\n-            match entry {\n-                EntryItem(..) |\n-                EntryTraitItem(..) |\n-                EntryImplItem(..) => {\n-                    let def_index = self.definitions.opt_def_index(id).unwrap();\n+        let entry = self.map[id.as_usize()];\n+        match entry {\n+            EntryItem(_, dep_node_index, _) |\n+            EntryTraitItem(_, dep_node_index, _) |\n+            EntryImplItem(_, dep_node_index, _) |\n+            EntryVariant(_, dep_node_index, _) |\n+            EntryForeignItem(_, dep_node_index, _) |\n+            EntryField(_, dep_node_index, _) |\n+            EntryStmt(_, dep_node_index, _) |\n+            EntryTy(_, dep_node_index, _) |\n+            EntryTraitRef(_, dep_node_index, _) |\n+            EntryBinding(_, dep_node_index, _) |\n+            EntryPat(_, dep_node_index, _) |\n+            EntryBlock(_, dep_node_index, _) |\n+            EntryStructCtor(_, dep_node_index, _) |\n+            EntryLifetime(_, dep_node_index, _) |\n+            EntryTyParam(_, dep_node_index, _) |\n+            EntryVisibility(_, dep_node_index, _) |\n+            EntryExpr(_, dep_node_index, _) |\n+            EntryLocal(_, dep_node_index, _) |\n+            RootCrate(dep_node_index) => {\n+                self.dep_graph.read_index(dep_node_index);\n+            }\n+            NotPresent => {\n+                // Some nodes, notably macro definitions, are not\n+                // present in the map for whatever reason, but\n+                // they *do* have def-ids. So if we encounter an\n+                // empty hole, check for that case.\n+                if let Some(def_index) = self.definitions.opt_def_index(id) {\n                     let def_path_hash = self.definitions.def_path_hash(def_index);\n-\n-                    if let Some(last_id) = last_expr {\n-                        // The body may have a separate dep node\n-                        if entry.is_body_owner(last_id) {\n-                            return def_path_hash.to_dep_node(DepKind::HirBody);\n-                        }\n-                    }\n-                    return def_path_hash.to_dep_node(DepKind::Hir);\n-                }\n-\n-                EntryVariant(p, v) => {\n-                    id = p;\n-\n-                    if last_expr.is_some() {\n-                        if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n-                            // The enum parent holds both Hir and HirBody nodes.\n-                            let def_index = self.definitions.opt_def_index(id).unwrap();\n-                            let def_path_hash = self.definitions.def_path_hash(def_index);\n-                            return def_path_hash.to_dep_node(DepKind::HirBody);\n-                        }\n-                    }\n-                }\n-\n-                EntryForeignItem(p, _) |\n-                EntryField(p, _) |\n-                EntryStmt(p, _) |\n-                EntryTy(p, _) |\n-                EntryTraitRef(p, _) |\n-                EntryLocal(p, _) |\n-                EntryPat(p, _) |\n-                EntryBlock(p, _) |\n-                EntryStructCtor(p, _) |\n-                EntryLifetime(p, _) |\n-                EntryTyParam(p, _) |\n-                EntryVisibility(p, _) =>\n-                    id = p,\n-\n-                EntryExpr(p, _) => {\n-                    last_expr = Some(id);\n-                    id = p;\n-                }\n-\n-                RootCrate => {\n-                    let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n-                    return def_path_hash.to_dep_node(DepKind::Hir);\n+                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n+                } else {\n+                    bug!(\"called HirMap::read() with invalid NodeId\")\n                 }\n-\n-                NotPresent =>\n-                    // Some nodes, notably macro definitions, are not\n-                    // present in the map for whatever reason, but\n-                    // they *do* have def-ids. So if we encounter an\n-                    // empty hole, check for that case.\n-                    return self.definitions.opt_def_index(id)\n-                               .map(|def_index| {\n-                                    let def_path_hash = self.definitions.def_path_hash(def_index);\n-                                    def_path_hash.to_dep_node(DepKind::Hir)\n-                                })\n-                               .unwrap_or_else(|| {\n-                                   bug!(\"Walking parents from `{}` \\\n-                                         led to `NotPresent` at `{}`\",\n-                                        id0, id)\n-                               }),\n             }\n         }\n     }\n@@ -475,7 +416,7 @@ impl<'hir> Map<'hir> {\n                 Some(body_id)\n             } else {\n                 // For some expressions, the expression is its own body.\n-                if let EntryExpr(_, expr) = entry {\n+                if let EntryExpr(_, _, expr) = entry {\n                     Some(BodyId { node_id: expr.id })\n                 } else {\n                     None\n@@ -589,7 +530,7 @@ impl<'hir> Map<'hir> {\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: NodeId) -> bool {\n         match self.find(id) {\n-            Some(NodeLocal(_)) => (),\n+            Some(NodeBinding(_)) => (),\n             _ => return false,\n         }\n         match self.find(self.get_parent_node(id)) {\n@@ -731,7 +672,7 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME it is not clear to me that all items qualify as scopes - statics\n-    /// and associated types probably shouldn't, for example. Behaviour in this\n+    /// and associated types probably shouldn't, for example. Behavior in this\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n         match self.walk_parent_nodes(id, |node| match *node {\n@@ -754,7 +695,7 @@ impl<'hir> Map<'hir> {\n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n         let abi = match self.find_entry(parent) {\n-            Some(EntryItem(_, i)) => {\n+            Some(EntryItem(_, _, i)) => {\n                 match i.node {\n                     ItemForeignMod(ref nm) => Some(nm.abi),\n                     _ => None\n@@ -856,7 +797,7 @@ impl<'hir> Map<'hir> {\n             NodeField(f) => f.name,\n             NodeLifetime(lt) => lt.name,\n             NodeTyParam(tp) => tp.name,\n-            NodeLocal(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n+            NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n@@ -905,26 +846,27 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n         match self.find_entry(id) {\n-            Some(EntryItem(_, item)) => item.span,\n-            Some(EntryForeignItem(_, foreign_item)) => foreign_item.span,\n-            Some(EntryTraitItem(_, trait_method)) => trait_method.span,\n-            Some(EntryImplItem(_, impl_item)) => impl_item.span,\n-            Some(EntryVariant(_, variant)) => variant.span,\n-            Some(EntryField(_, field)) => field.span,\n-            Some(EntryExpr(_, expr)) => expr.span,\n-            Some(EntryStmt(_, stmt)) => stmt.span,\n-            Some(EntryTy(_, ty)) => ty.span,\n-            Some(EntryTraitRef(_, tr)) => tr.path.span,\n-            Some(EntryLocal(_, pat)) => pat.span,\n-            Some(EntryPat(_, pat)) => pat.span,\n-            Some(EntryBlock(_, block)) => block.span,\n-            Some(EntryStructCtor(_, _)) => self.expect_item(self.get_parent(id)).span,\n-            Some(EntryLifetime(_, lifetime)) => lifetime.span,\n-            Some(EntryTyParam(_, ty_param)) => ty_param.span,\n-            Some(EntryVisibility(_, &Visibility::Restricted { ref path, .. })) => path.span,\n-            Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n-\n-            Some(RootCrate) => self.forest.krate.span,\n+            Some(EntryItem(_, _, item)) => item.span,\n+            Some(EntryForeignItem(_, _, foreign_item)) => foreign_item.span,\n+            Some(EntryTraitItem(_, _, trait_method)) => trait_method.span,\n+            Some(EntryImplItem(_, _, impl_item)) => impl_item.span,\n+            Some(EntryVariant(_, _, variant)) => variant.span,\n+            Some(EntryField(_, _, field)) => field.span,\n+            Some(EntryExpr(_, _, expr)) => expr.span,\n+            Some(EntryStmt(_, _, stmt)) => stmt.span,\n+            Some(EntryTy(_, _, ty)) => ty.span,\n+            Some(EntryTraitRef(_, _, tr)) => tr.path.span,\n+            Some(EntryBinding(_, _, pat)) => pat.span,\n+            Some(EntryPat(_, _, pat)) => pat.span,\n+            Some(EntryBlock(_, _, block)) => block.span,\n+            Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n+            Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n+            Some(EntryTyParam(_, _, ty_param)) => ty_param.span,\n+            Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n+            Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n+            Some(EntryLocal(_, _, local)) => local.span,\n+\n+            Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n@@ -1022,12 +964,12 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx) {\n-                Some(EntryItem(_, n))       => n.name(),\n-                Some(EntryForeignItem(_, n))=> n.name(),\n-                Some(EntryTraitItem(_, n))  => n.name(),\n-                Some(EntryImplItem(_, n))   => n.name(),\n-                Some(EntryVariant(_, n))    => n.name(),\n-                Some(EntryField(_, n))      => n.name(),\n+                Some(EntryItem(_, _, n))       => n.name(),\n+                Some(EntryForeignItem(_, _, n))=> n.name(),\n+                Some(EntryTraitItem(_, _, n))  => n.name(),\n+                Some(EntryImplItem(_, _, n))   => n.name(),\n+                Some(EntryVariant(_, _, n))    => n.name(),\n+                Some(EntryField(_, _, n))      => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -1053,9 +995,13 @@ impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n pub fn map_crate<'hir>(forest: &'hir mut Forest,\n                        definitions: Definitions)\n                        -> Map<'hir> {\n-    let mut collector = NodeCollector::root(&forest.krate);\n-    intravisit::walk_crate(&mut collector, &forest.krate);\n-    let map = collector.map;\n+    let map = {\n+        let mut collector = NodeCollector::root(&forest.krate,\n+                                                &forest.dep_graph,\n+                                                &definitions);\n+        intravisit::walk_crate(&mut collector, &forest.krate);\n+        collector.into_map()\n+    };\n \n     if log_enabled!(::log::LogLevel::Debug) {\n         // This only makes sense for ordered stores; note the\n@@ -1112,7 +1058,7 @@ impl<'a> print::State<'a> {\n             NodeStmt(a)        => self.print_stmt(&a),\n             NodeTy(a)          => self.print_type(&a),\n             NodeTraitRef(a)    => self.print_trait_ref(&a),\n-            NodeLocal(a)       |\n+            NodeBinding(a)       |\n             NodePat(a)         => self.print_pat(&a),\n             NodeBlock(a)       => {\n                 use syntax::print::pprust::PrintState;\n@@ -1131,6 +1077,7 @@ impl<'a> print::State<'a> {\n             // hir_map to reconstruct their full structure for pretty\n             // printing.\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n+            NodeLocal(a)       => self.print_local_decl(&a),\n         }\n     }\n }\n@@ -1223,7 +1170,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeTraitRef(_)) => {\n             format!(\"trait_ref {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeLocal(_)) => {\n+        Some(NodeBinding(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n         Some(NodePat(_)) => {\n@@ -1232,6 +1179,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeBlock(_)) => {\n             format!(\"block {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n+        Some(NodeLocal(_)) => {\n+            format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n+        }\n         Some(NodeStructCtor(_)) => {\n             format!(\"struct_ctor {}{}\", path_str(), id_str)\n         }"}, {"sha": "df67f8416212c413deb77a94c14d7a25805cb6e9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 39, "deletions": 71, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -26,7 +26,6 @@ pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::Visibility::{Public, Inherited};\n-pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n@@ -42,6 +41,7 @@ use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n+use ty::AdtKind;\n \n use rustc_data_structures::indexed_vec;\n \n@@ -226,65 +226,7 @@ impl PathSegment {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum PathParameters {\n-    /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n-    AngleBracketedParameters(AngleBracketedParameterData),\n-    /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n-    ParenthesizedParameters(ParenthesizedParameterData),\n-}\n-\n-impl PathParameters {\n-    pub fn none() -> PathParameters {\n-        AngleBracketedParameters(AngleBracketedParameterData {\n-            lifetimes: HirVec::new(),\n-            types: HirVec::new(),\n-            infer_types: true,\n-            bindings: HirVec::new(),\n-        })\n-    }\n-\n-    /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n-    /// parameters in the parenthesized case.\n-    pub fn types(&self) -> HirVec<&P<Ty>> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.types.iter().collect()\n-            }\n-            ParenthesizedParameters(ref data) => {\n-                data.inputs\n-                    .iter()\n-                    .chain(data.output.iter())\n-                    .collect()\n-            }\n-        }\n-    }\n-\n-    pub fn lifetimes(&self) -> HirVec<&Lifetime> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.lifetimes.iter().collect()\n-            }\n-            ParenthesizedParameters(_) => {\n-                HirVec::new()\n-            }\n-        }\n-    }\n-\n-    pub fn bindings(&self) -> HirVec<&TypeBinding> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.bindings.iter().collect()\n-            }\n-            ParenthesizedParameters(_) => {\n-                HirVec::new()\n-            }\n-        }\n-    }\n-}\n-\n-/// A path like `Foo<'a, T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct AngleBracketedParameterData {\n+pub struct PathParameters {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n@@ -297,19 +239,33 @@ pub struct AngleBracketedParameterData {\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n+    /// Were parameters written in parenthesized form `Fn(T) -> U`?\n+    /// This is required mostly for pretty-printing and diagnostics,\n+    /// but also for changing lifetime elision rules to be \"function-like\".\n+    pub parenthesized: bool,\n }\n \n-/// A path like `Foo(A,B) -> C`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct ParenthesizedParameterData {\n-    /// Overall span\n-    pub span: Span,\n-\n-    /// `(A,B)`\n-    pub inputs: HirVec<P<Ty>>,\n+impl PathParameters {\n+    pub fn none() -> Self {\n+        Self {\n+            lifetimes: HirVec::new(),\n+            types: HirVec::new(),\n+            infer_types: true,\n+            bindings: HirVec::new(),\n+            parenthesized: false,\n+        }\n+    }\n \n-    /// `C`\n-    pub output: Option<P<Ty>>,\n+    pub fn inputs(&self) -> &[P<Ty>] {\n+        if self.parenthesized {\n+            if let Some(ref ty) = self.types.get(0) {\n+                if let TyTup(ref tys) = ty.node {\n+                    return tys;\n+                }\n+            }\n+        }\n+        bug!(\"PathParameters::inputs: not a `Fn(T) -> U`\");\n+    }\n }\n \n /// The AST represents all type param bounds as types.\n@@ -1264,6 +1220,7 @@ pub struct TraitItemId {\n pub struct TraitItem {\n     pub id: NodeId,\n     pub name: Name,\n+    pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n     pub node: TraitItemKind,\n     pub span: Span,\n@@ -1305,6 +1262,7 @@ pub struct ImplItemId {\n pub struct ImplItem {\n     pub id: NodeId,\n     pub name: Name,\n+    pub hir_id: HirId,\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n     pub attrs: HirVec<Attribute>,\n@@ -1711,8 +1669,9 @@ pub struct ItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub name: Name,\n-    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n+    pub attrs: HirVec<Attribute>,\n     pub node: Item_,\n     pub vis: Visibility,\n     pub span: Span,\n@@ -1789,6 +1748,15 @@ impl Item_ {\n             ItemDefaultImpl(..) => \"item\",\n         }\n     }\n+\n+    pub fn adt_kind(&self) -> Option<AdtKind> {\n+        match *self {\n+            ItemStruct(..) => Some(AdtKind::Struct),\n+            ItemUnion(..) => Some(AdtKind::Union),\n+            ItemEnum(..) => Some(AdtKind::Enum),\n+            _ => None,\n+        }\n+    }\n }\n \n /// A reference from an trait to one of its associated items. This"}, {"sha": "876875bce4a5e54cc550dfb35507482020f7b537", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1194,9 +1194,9 @@ impl<'a> State<'a> {\n         self.print_expr(&args[0])?;\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n-        if !segment.parameters.lifetimes().is_empty() ||\n-                !segment.parameters.types().is_empty() ||\n-                !segment.parameters.bindings().is_empty() {\n+        if !segment.parameters.lifetimes.is_empty() ||\n+                !segment.parameters.types.is_empty() ||\n+                !segment.parameters.bindings.is_empty() {\n             self.print_path_parameters(&segment.parameters, true)?;\n         }\n         self.print_call_post(base_args)\n@@ -1581,61 +1581,55 @@ impl<'a> State<'a> {\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n-        match *parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                let start = if colons_before_params { \"::<\" } else { \"<\" };\n-                let empty = Cell::new(true);\n-                let start_or_comma = |this: &mut Self| {\n-                    if empty.get() {\n-                        empty.set(false);\n-                        this.s.word(start)\n-                    } else {\n-                        this.word_space(\",\")\n-                    }\n-                };\n+        if parameters.parenthesized {\n+            self.s.word(\"(\")?;\n+            self.commasep(Inconsistent, parameters.inputs(), |s, ty| s.print_type(&ty))?;\n+            self.s.word(\")\")?;\n \n-                if !data.lifetimes.iter().all(|lt| lt.is_elided()) {\n-                    for lifetime in &data.lifetimes {\n-                        start_or_comma(self)?;\n-                        self.print_lifetime(lifetime)?;\n-                    }\n-                }\n-\n-                if !data.types.is_empty() {\n-                    start_or_comma(self)?;\n-                    self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&ty))?;\n+            self.space_if_not_bol()?;\n+            self.word_space(\"->\")?;\n+            self.print_type(&parameters.bindings[0].ty)?;\n+        } else {\n+            let start = if colons_before_params { \"::<\" } else { \"<\" };\n+            let empty = Cell::new(true);\n+            let start_or_comma = |this: &mut Self| {\n+                if empty.get() {\n+                    empty.set(false);\n+                    this.s.word(start)\n+                } else {\n+                    this.word_space(\",\")\n                 }\n+            };\n \n-                // FIXME(eddyb) This would leak into error messages, e.g.:\n-                // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n-                if data.infer_types && false {\n+            if !parameters.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                for lifetime in &parameters.lifetimes {\n                     start_or_comma(self)?;\n-                    self.s.word(\"..\")?;\n+                    self.print_lifetime(lifetime)?;\n                 }\n+            }\n \n-                for binding in data.bindings.iter() {\n-                    start_or_comma(self)?;\n-                    self.print_name(binding.name)?;\n-                    self.s.space()?;\n-                    self.word_space(\"=\")?;\n-                    self.print_type(&binding.ty)?;\n-                }\n+            if !parameters.types.is_empty() {\n+                start_or_comma(self)?;\n+                self.commasep(Inconsistent, &parameters.types, |s, ty| s.print_type(&ty))?;\n+            }\n \n-                if !empty.get() {\n-                    self.s.word(\">\")?\n-                }\n+            // FIXME(eddyb) This would leak into error messages, e.g.:\n+            // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n+            if parameters.infer_types && false {\n+                start_or_comma(self)?;\n+                self.s.word(\"..\")?;\n             }\n \n-            hir::ParenthesizedParameters(ref data) => {\n-                self.s.word(\"(\")?;\n-                self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&ty))?;\n-                self.s.word(\")\")?;\n+            for binding in parameters.bindings.iter() {\n+                start_or_comma(self)?;\n+                self.print_name(binding.name)?;\n+                self.s.space()?;\n+                self.word_space(\"=\")?;\n+                self.print_type(&binding.ty)?;\n+            }\n \n-                if let Some(ref ty) = data.output {\n-                    self.space_if_not_bol()?;\n-                    self.word_space(\"->\")?;\n-                    self.print_type(&ty)?;\n-                }\n+            if !empty.get() {\n+                self.s.word(\">\")?\n             }\n         }\n "}, {"sha": "a79133187895a861736d587050b91b86071302f6", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -133,22 +133,12 @@ impl_stable_hash_for!(struct hir::PathSegment {\n     parameters\n });\n \n-impl_stable_hash_for!(enum hir::PathParameters {\n-    AngleBracketedParameters(data),\n-    ParenthesizedParameters(data)\n-});\n-\n-impl_stable_hash_for!(struct hir::AngleBracketedParameterData {\n+impl_stable_hash_for!(struct hir::PathParameters {\n     lifetimes,\n     types,\n     infer_types,\n-    bindings\n-});\n-\n-impl_stable_hash_for!(struct hir::ParenthesizedParameterData {\n-    span,\n-    inputs,\n-    output\n+    bindings,\n+    parenthesized\n });\n \n impl_stable_hash_for!(enum hir::TyParamBound {\n@@ -741,6 +731,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::T\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id,\n+            hir_id: _,\n             name,\n             ref attrs,\n             ref node,\n@@ -774,6 +765,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id,\n+            hir_id: _,\n             name,\n             ref vis,\n             defaultness,\n@@ -930,6 +922,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n             name,\n             ref attrs,\n             id,\n+            hir_id: _,\n             ref node,\n             ref vis,\n             span"}, {"sha": "5f51579945e33ea5e7e44338720d83f241862b71", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -663,6 +663,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::In\n                 def_id.hash_stable(hcx, hasher);\n                 t.hash_stable(hcx, hasher);\n             }\n+            ty::InstanceDef::CloneShim(def_id, t) => {\n+                def_id.hash_stable(hcx, hasher);\n+                t.hash_stable(hcx, hasher);\n+            }\n         }\n     }\n }"}, {"sha": "c80ce3c96f1a98a3d44870719fd5edffcd028f4e", "filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs", "status": "modified", "additions": 171, "deletions": 69, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -27,65 +27,84 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     //    { x.push(y); }.\n     // The example gives\n     // fn foo(x: &mut Vec<&u8>, y: &u8) {\n-    //                    ---      --- these references must have the same lifetime\n+    //                    ---      --- these references are declared with different lifetimes...\n     //            x.push(y);\n-    //            ^ data from `y` flows into `x` here\n-    // It will later be extended to trait objects and structs.\n+    //            ^ ...but data from `y` flows into `x` here\n+    // It has been extended for the case of structs too.\n+    // Consider the example\n+    // struct Ref<'a> { x: &'a u32 }\n+    // fn foo(mut x: Vec<Ref>, y: Ref) {\n+    //                   ---      --- these structs are declared with different lifetimes...\n+    //               x.push(y);\n+    //               ^ ...but data from `y` flows into `x` here\n+    // }\n+    // It will later be extended to trait objects.\n     pub fn try_report_anon_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-\n         let (span, sub, sup) = match *error {\n             ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n             _ => return false, // inapplicable\n         };\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let (ty1, ty2) = if self.is_suitable_anonymous_region(sup).is_some() &&\n-                            self.is_suitable_anonymous_region(sub).is_some() {\n-            if let (Some(anon_reg1), Some(anon_reg2)) =\n-                (self.is_suitable_anonymous_region(sup), self.is_suitable_anonymous_region(sub)) {\n-                let ((_, br1), (_, br2)) = (anon_reg1, anon_reg2);\n-                if self.find_anon_type(sup, &br1).is_some() &&\n-                   self.find_anon_type(sub, &br2).is_some() {\n-                    (self.find_anon_type(sup, &br1).unwrap(),\n-                     self.find_anon_type(sub, &br2).unwrap())\n-                } else {\n-                    return false;\n-                }\n-            } else {\n-                return false;\n-            }\n-        } else {\n-            return false; // inapplicable\n-        };\n+        let anon_reg_sup = or_false!(self.is_suitable_anonymous_region(sup));\n \n-        if let (Some(sup_arg), Some(sub_arg)) =\n+        let anon_reg_sub = or_false!(self.is_suitable_anonymous_region(sub));\n+        let scope_def_id_sup = anon_reg_sup.def_id;\n+        let bregion_sup = anon_reg_sup.boundregion;\n+        let scope_def_id_sub = anon_reg_sub.def_id;\n+        let bregion_sub = anon_reg_sub.boundregion;\n+\n+        let ty_sup = or_false!(self.find_anon_type(sup, &bregion_sup));\n+\n+        let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n+\n+        let (main_label, label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n             (self.find_arg_with_anonymous_region(sup, sup),\n              self.find_arg_with_anonymous_region(sub, sub)) {\n-            let ((anon_arg1, _, _, _), (anon_arg2, _, _, _)) = (sup_arg, sub_arg);\n \n-            let span_label_var1 = if let Some(simple_name) = anon_arg1.pat.simple_name() {\n-                format!(\" from `{}` \", simple_name)\n-            } else {\n-                format!(\" \")\n-            };\n+            let (anon_arg_sup, is_first_sup, anon_arg_sub, is_first_sub) =\n+                (sup_arg.arg, sup_arg.is_first, sub_arg.arg, sub_arg.is_first);\n+            if self.is_self_anon(is_first_sup, scope_def_id_sup) ||\n+               self.is_self_anon(is_first_sub, scope_def_id_sub) {\n+                return false;\n+            }\n \n-            let span_label_var2 = if let Some(simple_name) = anon_arg2.pat.simple_name() {\n-                format!(\" into `{}` \", simple_name)\n+            if self.is_return_type_anon(scope_def_id_sup, bregion_sup) ||\n+               self.is_return_type_anon(scope_def_id_sub, bregion_sub) {\n+                return false;\n+            }\n+\n+            if anon_arg_sup == anon_arg_sub {\n+                (format!(\"this type was declared with multiple lifetimes...\"),\n+                 format!(\" with one lifetime\"),\n+                 format!(\" into the other\"))\n             } else {\n-                format!(\" \")\n-            };\n-\n-            struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-                .span_label(ty1.span,\n-                            format!(\"these references are not declared with the same lifetime...\"))\n-                .span_label(ty2.span, format!(\"\"))\n-                .span_label(span,\n-                            format!(\"...but data{}flows{}here\", span_label_var1, span_label_var2))\n-                .emit();\n+                let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n+                    format!(\" from `{}`\", simple_name)\n+                } else {\n+                    format!(\"\")\n+                };\n+\n+                let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n+                    format!(\" into `{}`\", simple_name)\n+                } else {\n+                    format!(\"\")\n+                };\n+\n+                let span_label =\n+                    format!(\"these two types are declared with different lifetimes...\",);\n+\n+                (span_label, span_label_var1, span_label_var2)\n+            }\n         } else {\n             return false;\n-        }\n+        };\n \n+        struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n+            .span_label(ty_sup.span, main_label)\n+            .span_label(ty_sub.span, format!(\"\"))\n+            .span_label(span, format!(\"...but data{} flows{} here\", label1, label2))\n+            .emit();\n         return true;\n     }\n \n@@ -94,7 +113,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// contains the anonymous type.\n     ///\n     /// # Arguments\n-    ///\n     /// region - the anonymous region corresponding to the anon_anon conflict\n     /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n     ///\n@@ -105,39 +123,56 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n-    fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n+    pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n         if let Some(anon_reg) = self.is_suitable_anonymous_region(region) {\n-            let (def_id, _) = anon_reg;\n+            let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let ret_ty = self.tcx.type_of(def_id);\n                 if let ty::TyFnDef(_, _) = ret_ty.sty {\n-                    if let hir_map::NodeItem(it) = self.tcx.hir.get(node_id) {\n-                        if let hir::ItemFn(ref fndecl, _, _, _, _, _) = it.node {\n-                            return fndecl\n-                                       .inputs\n-                                       .iter()\n-                                       .filter_map(|arg| {\n-                                let mut nested_visitor = FindNestedTypeVisitor {\n-                                    infcx: &self,\n-                                    hir_map: &self.tcx.hir,\n-                                    bound_region: *br,\n-                                    found_type: None,\n-                                };\n-                                nested_visitor.visit_ty(&**arg);\n-                                if nested_visitor.found_type.is_some() {\n-                                    nested_visitor.found_type\n-                                } else {\n-                                    None\n-                                }\n-                            })\n-                                       .next();\n-                        }\n-                    }\n+                    let inputs: &[_] =\n+                        match self.tcx.hir.get(node_id) {\n+                            hir_map::NodeItem(&hir::Item {\n+                                                  node: hir::ItemFn(ref fndecl, ..), ..\n+                                              }) => &fndecl.inputs,\n+                            hir_map::NodeTraitItem(&hir::TraitItem {\n+                                                   node: hir::TraitItemKind::Method(ref fndecl, ..),\n+                                                   ..\n+                                               }) => &fndecl.decl.inputs,\n+                            hir_map::NodeImplItem(&hir::ImplItem {\n+                                                  node: hir::ImplItemKind::Method(ref fndecl, ..),\n+                                                  ..\n+                                              }) => &fndecl.decl.inputs,\n+\n+                            _ => &[],\n+                        };\n+\n+                    return inputs\n+                               .iter()\n+                               .filter_map(|arg| {\n+                                               self.find_component_for_bound_region(&**arg, br)\n+                                           })\n+                               .next();\n                 }\n             }\n         }\n         None\n     }\n+\n+    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n+    // to the anonymous region.\n+    fn find_component_for_bound_region(&self,\n+                                       arg: &'gcx hir::Ty,\n+                                       br: &ty::BoundRegion)\n+                                       -> Option<(&'gcx hir::Ty)> {\n+        let mut nested_visitor = FindNestedTypeVisitor {\n+            infcx: &self,\n+            hir_map: &self.tcx.hir,\n+            bound_region: *br,\n+            found_type: None,\n+        };\n+        nested_visitor.visit_ty(arg);\n+        nested_visitor.found_type\n+    }\n }\n \n // The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the\n@@ -176,8 +211,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n             hir::TyRptr(ref lifetime, _) => {\n                 match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n                     // the lifetime of the TyRptr\n-                    Some(&rl::Region::LateBoundAnon(debuijn_index, anon_index)) => {\n-                        if debuijn_index.depth == 1 && anon_index == br_index {\n+                    Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+                        if debruijn_index.depth == 1 && anon_index == br_index {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n                         }\n@@ -191,10 +226,77 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n+            hir::TyPath(_) => {\n+                let subvisitor = &mut TyPathVisitor {\n+                                          infcx: self.infcx,\n+                                          found_it: false,\n+                                          bound_region: self.bound_region,\n+                                          hir_map: self.hir_map,\n+                                      };\n+                intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n+                // this will visit only outermost type\n+                if subvisitor.found_it {\n+                    self.found_type = Some(arg);\n+                }\n+            }\n             _ => {}\n         }\n         // walk the embedded contents: e.g., if we are visiting `Vec<&Foo>`,\n         // go on to visit `&Foo`\n         intravisit::walk_ty(self, arg);\n     }\n }\n+\n+// The visitor captures the corresponding `hir::Ty` of the anonymous region\n+// in the case of structs ie. `hir::TyPath`.\n+// This visitor would be invoked for each lifetime corresponding to a struct,\n+// and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n+// where that lifetime appears. This allows us to highlight the\n+// specific part of the type in the error message.\n+struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    hir_map: &'a hir::map::Map<'gcx>,\n+    found_it: bool,\n+    bound_region: ty::BoundRegion,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n+        let br_index = match self.bound_region {\n+            ty::BrAnon(index) => index,\n+            _ => return,\n+        };\n+\n+        match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n+            // the lifetime of the TyPath!\n+            Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+                if debruijn_index.depth == 1 && anon_index == br_index {\n+                    self.found_it = true;\n+                }\n+            }\n+            Some(&rl::Region::Static) |\n+            Some(&rl::Region::EarlyBound(_, _)) |\n+            Some(&rl::Region::LateBound(_, _)) |\n+            Some(&rl::Region::Free(_, _)) |\n+            None => {\n+                debug!(\"no arg found\");\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+        // ignore nested types\n+        //\n+        // If you have a type like `Foo<'a, &Ty>` we\n+        // are only interested in the immediate lifetimes ('a).\n+        //\n+        // Making `visit_ty` empty will ignore the `&Ty` embedded\n+        // inside, it will get reached by the outer visitor.\n+        debug!(\"`Ty` corresponding to a struct is {:?}\", arg);\n+    }\n+}"}, {"sha": "edf9ca89b3394e7bc11ffd2d1758d5c8ab69ee08", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -24,7 +24,7 @@\n //! a span, but also more information so that we can generate a meaningful\n //! error message.\n //!\n-//! Having a catalogue of all the different reasons an error can arise is\n+//! Having a catalog of all the different reasons an error can arise is\n //! also useful for other reasons, like cross-referencing FAQs etc, though\n //! we are not really taking advantage of this yet.\n //!\n@@ -75,8 +75,10 @@ use errors::{DiagnosticBuilder, DiagnosticStyledString};\n mod note;\n \n mod need_type_info;\n-mod util;\n+\n mod named_anon_conflict;\n+#[macro_use]\n+mod util;\n mod anon_anon_conflict;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -899,9 +901,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n                 format!(\" for lifetime parameter {}in generic type\", br_string(br))\n             }\n-            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(type_name)) => {\n+            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => {\n                 format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n-                        br_string(br), type_name)\n+                        br_string(br), self.tcx.associated_item(def_id).name)\n             }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\","}, {"sha": "0aae008396a00615b09cd7386ac0baec47506c90", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 28, "deletions": 41, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -11,7 +11,6 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n use infer::InferCtxt;\n-use ty;\n use infer::region_inference::RegionResolutionError::*;\n use infer::region_inference::RegionResolutionError;\n \n@@ -30,8 +29,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n-        // with the named one.\n-        let (named, (arg, new_ty, br, is_first), (scope_def_id, _)) =\n+        // with the named one.//scope_def_id\n+        let (named, anon_arg_info, region_info) =\n             if sub.is_named_region() && self.is_suitable_anonymous_region(sup).is_some() {\n                 (sub,\n                  self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n@@ -44,50 +43,38 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 return false; // inapplicable\n             };\n \n-        // Here, we check for the case where the anonymous region\n-        // is in the return type.\n-        // FIXME(#42703) - Need to handle certain cases here.\n-        let ret_ty = self.tcx.type_of(scope_def_id);\n-        match ret_ty.sty {\n-            ty::TyFnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(self.tcx);\n-                let late_bound_regions = self.tcx\n-                    .collect_referenced_late_bound_regions(&sig.output());\n-                if late_bound_regions.iter().any(|r| *r == br) {\n-                    return false;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        // Here we check for the case where anonymous region\n-        // corresponds to self and if yes, we display E0312.\n-        // FIXME(#42700) - Need to format self properly to\n-        // enable E0621 for it.\n-        if is_first &&\n-           self.tcx\n-               .opt_associated_item(scope_def_id)\n-               .map(|i| i.method_has_self_argument)\n-               .unwrap_or(false) {\n+        let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (anon_arg_info.arg,\n+                                                                       anon_arg_info.arg_ty,\n+                                                                       anon_arg_info.bound_region,\n+                                                                       anon_arg_info.is_first,\n+                                                                       region_info.def_id,\n+                                                                       region_info.is_impl_item);\n+        if is_impl_item {\n             return false;\n         }\n \n-        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n-            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n+        if self.is_return_type_anon(scope_def_id, br) || self.is_self_anon(is_first, scope_def_id) {\n+            return false;\n         } else {\n-            (\"parameter type\".to_owned(), \"type\".to_owned())\n-        };\n \n-        struct_span_err!(self.tcx.sess,\n-                         span,\n-                         E0621,\n-                         \"explicit lifetime required in {}\",\n-                         error_var)\n-                .span_label(arg.pat.span,\n-                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n-                .span_label(span, format!(\"lifetime `{}` required\", named))\n-                .emit();\n+            let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+                (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n+            } else {\n+                (\"parameter type\".to_owned(), \"type\".to_owned())\n+            };\n+\n+            struct_span_err!(self.tcx.sess,\n+                             span,\n+                             E0621,\n+                             \"explicit lifetime required in {}\",\n+                             error_var)\n+                    .span_label(arg.pat.span,\n+                                format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n+                    .span_label(span, format!(\"lifetime `{}` required\", named))\n+                    .emit();\n \n+\n+        }\n         return true;\n     }\n }"}, {"sha": "04153038da89faaede49e3cfdc849454a4337f67", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 116, "deletions": 40, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -16,6 +16,40 @@ use ty::{self, Region};\n use hir::def_id::DefId;\n use hir::map as hir_map;\n \n+macro_rules! or_false {\n+     ($v:expr) => {\n+          match $v {\n+               Some(v) => v,\n+               None => return false,\n+          }\n+     }\n+}\n+\n+// The struct contains the information about the anonymous region\n+// we are searching for.\n+pub struct AnonymousArgInfo<'tcx> {\n+    // the argument corresponding to the anonymous region\n+    pub arg: &'tcx hir::Arg,\n+    // the type corresponding to the anonymopus region argument\n+    pub arg_ty: ty::Ty<'tcx>,\n+    // the ty::BoundRegion corresponding to the anonymous region\n+    pub bound_region: ty::BoundRegion,\n+    // corresponds to id the argument is the first parameter\n+    // in the declaration\n+    pub is_first: bool,\n+}\n+\n+// This struct contains information regarding the\n+// Refree((FreeRegion) corresponding to lifetime conflict\n+pub struct FreeRegionInfo {\n+    // def id corresponding to FreeRegion\n+    pub def_id: DefId,\n+    // the bound region corresponding to FreeRegion\n+    pub boundregion: ty::BoundRegion,\n+    // checks if bound region is in Impl Item\n+    pub is_impl_item: bool,\n+}\n+\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method walks the Type of the function body arguments using\n     // `fold_regions()` function and returns the\n@@ -28,14 +62,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n     // the hir::Arg is the first argument in the function declaration.\n-    pub fn find_arg_with_anonymous_region\n-        (&self,\n-         anon_region: Region<'tcx>,\n-         replace_region: Region<'tcx>)\n-         -> Option<(&hir::Arg, ty::Ty<'tcx>, ty::BoundRegion, bool)> {\n+    pub fn find_arg_with_anonymous_region(&self,\n+                                          anon_region: Region<'tcx>,\n+                                          replace_region: Region<'tcx>)\n+                                          -> Option<AnonymousArgInfo> {\n \n         if let ty::ReFree(ref free_region) = *anon_region {\n-\n             let id = free_region.scope;\n             let hir = &self.tcx.hir;\n             if let Some(node_id) = hir.as_local_node_id(id) {\n@@ -57,7 +89,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                     });\n                                 if found_anon_region {\n                                     let is_first = index == 0;\n-                                    Some((arg, new_arg_ty, free_region.bound_region, is_first))\n+                                    Some(AnonymousArgInfo {\n+                                             arg: arg,\n+                                             arg_ty: new_arg_ty,\n+                                             bound_region: free_region.bound_region,\n+                                             is_first: is_first,\n+                                         })\n                                 } else {\n                                     None\n                                 }\n@@ -79,42 +116,81 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     // This method returns whether the given Region is Anonymous\n     // and returns the DefId and the BoundRegion corresponding to the given region.\n-    pub fn is_suitable_anonymous_region(&self,\n-                                        region: Region<'tcx>)\n-                                        -> Option<(DefId, ty::BoundRegion)> {\n+    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         if let ty::ReFree(ref free_region) = *region {\n-            if let ty::BrAnon(..) = free_region.bound_region{\n-                    let anonymous_region_binding_scope = free_region.scope;\n-                    let node_id = self.tcx\n-                        .hir\n-                        .as_local_node_id(anonymous_region_binding_scope)\n-                        .unwrap();\n-                    match self.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeItem(..)) |\n-                        Some(hir_map::NodeTraitItem(..)) => {\n-                            // Success -- proceed to return Some below\n-                        }\n-                        Some(hir_map::NodeImplItem(..)) => {\n-                            let container_id = self.tcx\n-                                .associated_item(anonymous_region_binding_scope)\n-                                .container\n-                                .id();\n-                            if self.tcx.impl_trait_ref(container_id).is_some() {\n-                                // For now, we do not try to target impls of traits. This is\n-                                // because this message is going to suggest that the user\n-                                // change the fn signature, but they may not be free to do so,\n-                                // since the signature must match the trait.\n-                                //\n-                                // FIXME(#42706) -- in some cases, we could do better here.\n-                                return None;\n-                            }\n-                        }\n-                        _ => return None, // inapplicable\n-                        // we target only top-level functions\n+            if let ty::BrAnon(..) = free_region.bound_region {\n+                let anonymous_region_binding_scope = free_region.scope;\n+                let node_id = self.tcx\n+                    .hir\n+                    .as_local_node_id(anonymous_region_binding_scope)\n+                    .unwrap();\n+                let mut is_impl_item = false;\n+                match self.tcx.hir.find(node_id) {\n+\n+                    Some(hir_map::NodeItem(..)) |\n+                    Some(hir_map::NodeTraitItem(..)) => {\n+                        // Success -- proceed to return Some below\n                     }\n-                    return Some((anonymous_region_binding_scope, free_region.bound_region));\n+                    Some(hir_map::NodeImplItem(..)) => {\n+                        is_impl_item =\n+                            self.is_bound_region_in_impl_item(anonymous_region_binding_scope);\n+                    }\n+                    _ => return None,\n                 }\n+                return Some(FreeRegionInfo {\n+                                def_id: anonymous_region_binding_scope,\n+                                boundregion: free_region.bound_region,\n+                                is_impl_item: is_impl_item,\n+                            });\n             }\n-            None\n         }\n+        None\n+    }\n+\n+    // Here, we check for the case where the anonymous region\n+    // is in the return type.\n+    // FIXME(#42703) - Need to handle certain cases here.\n+    pub fn is_return_type_anon(&self, scope_def_id: DefId, br: ty::BoundRegion) -> bool {\n+        let ret_ty = self.tcx.type_of(scope_def_id);\n+        match ret_ty.sty {\n+            ty::TyFnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(self.tcx);\n+                let late_bound_regions = self.tcx\n+                    .collect_referenced_late_bound_regions(&sig.output());\n+                if late_bound_regions.iter().any(|r| *r == br) {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+    // Here we check for the case where anonymous region\n+    // corresponds to self and if yes, we display E0312.\n+    // FIXME(#42700) - Need to format self properly to\n+    // enable E0621 for it.\n+    pub fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n+        is_first &&\n+        self.tcx\n+            .opt_associated_item(scope_def_id)\n+            .map(|i| i.method_has_self_argument) == Some(true)\n+    }\n+\n+    // Here we check if the bound region is in Impl Item.\n+    pub fn is_bound_region_in_impl_item(&self, anonymous_region_binding_scope: DefId) -> bool {\n+        let container_id = self.tcx\n+            .associated_item(anonymous_region_binding_scope)\n+            .container\n+            .id();\n+        if self.tcx.impl_trait_ref(container_id).is_some() {\n+            // For now, we do not try to target impls of traits. This is\n+            // because this message is going to suggest that the user\n+            // change the fn signature, but they may not be free to do so,\n+            // since the signature must match the trait.\n+            //\n+            // FIXME(#42706) -- in some cases, we could do better here.\n+            return true;\n+        }\n+        false\n+    }\n }"}, {"sha": "6c9b9d853f403c17c45fa1f171548d086e64f2ff", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -274,7 +274,7 @@ pub enum LateBoundRegionConversionTime {\n     HigherRankedType,\n \n     /// when projecting an associated type\n-    AssocTypeProjection(ast::Name), // FIXME(tschottdorf): should contain DefId, not Name\n+    AssocTypeProjection(DefId),\n }\n \n /// Reasons to create a region inference variable"}, {"sha": "639a330dc6e67dffdb4d7026154f3a8bd2556030", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'g\n }\n \n /// The opportunistic type and region resolver is similar to the\n-/// opportunistic type resolver, but also opportunistly resolves\n+/// opportunistic type resolver, but also opportunistically resolves\n /// regions. It is useful for canonicalization.\n pub struct OpportunisticTypeAndRegionResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "152b2e2aa5ebc104d80936b458b66de4db488cb8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,9 +14,6 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![crate_name = \"rustc\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -29,7 +26,7 @@\n #![feature(core_intrinsics)]\n #![feature(discriminant_value)]\n #![feature(i128_type)]\n-#![feature(libc)]\n+#![cfg_attr(windows, feature(libc))]\n #![feature(never_type)]\n #![feature(nonzero)]\n #![feature(quote)]\n@@ -48,6 +45,7 @@ extern crate core;\n extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n+#[cfg(windows)]\n extern crate libc;\n extern crate owning_ref;\n extern crate rustc_back;\n@@ -65,7 +63,9 @@ extern crate serialize as rustc_serialize; // used by deriving\n \n // Note that librustc doesn't actually depend on these crates, see the note in\n // `Cargo.toml` for this crate about why these are here.\n+#[allow(unused_extern_crates)]\n extern crate flate2;\n+#[allow(unused_extern_crates)]\n extern crate test;\n \n #[macro_use]"}, {"sha": "811bf9776101d4d5e0fd453d5e68c97a5e6e98b7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -30,7 +30,7 @@ declare_lint! {\n \n declare_lint! {\n     pub UNUSED_EXTERN_CRATES,\n-    Allow,\n+    Warn,\n     \"extern crates that are never used\"\n }\n "}, {"sha": "4d1374b69b85cdde7e26555543b7e03ae72a284a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -101,7 +101,7 @@ pub struct FutureIncompatibleInfo {\n     pub reference: &'static str // e.g., a URL for an issue/PR/RFC or error code\n }\n \n-/// The targed of the `by_name` map, which accounts for renaming/deprecation.\n+/// The target of the `by_name` map, which accounts for renaming/deprecation.\n enum TargetLint {\n     /// A direct lint target\n     Id(LintId),\n@@ -121,10 +121,10 @@ pub enum FindLintError {\n \n pub enum CheckLintNameResult<'a> {\n     Ok(&'a [LintId]),\n-    // Lint doesn't exist\n+    /// Lint doesn't exist\n     NoLint,\n-    // The lint is either renamed or removed. This is the warning\n-    // message.\n+    /// The lint is either renamed or removed. This is the warning\n+    /// message.\n     Warning(String),\n }\n \n@@ -253,7 +253,7 @@ impl LintStore {\n         }\n     }\n \n-    // Checks the validity of lint names derived from the command line\n+    /// Checks the validity of lint names derived from the command line\n     pub fn check_lint_name_cmdline(&self,\n                                    sess: &Session,\n                                    lint_name: &str,"}, {"sha": "ab086e5b8e90ea511866305548639e36f5c658eb", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -83,10 +83,13 @@ impl LintLevelSets {\n         });\n     }\n \n-    fn get_lint_level(&self, lint: &'static Lint, idx: u32)\n+    fn get_lint_level(&self,\n+                      lint: &'static Lint,\n+                      idx: u32,\n+                      aux: Option<&FxHashMap<LintId, (Level, LintSource)>>)\n         -> (Level, LintSource)\n     {\n-        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx);\n+        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n \n         // If `level` is none then we actually assume the default level for this\n         // lint.\n@@ -97,7 +100,9 @@ impl LintLevelSets {\n         // `allow(warnings)` in scope then we want to respect that instead.\n         if level == Level::Warn {\n             let (warnings_level, warnings_src) =\n-                self.get_lint_id_level(LintId::of(lint::builtin::WARNINGS), idx);\n+                self.get_lint_id_level(LintId::of(lint::builtin::WARNINGS),\n+                                       idx,\n+                                       aux);\n             if let Some(configured_warning_level) = warnings_level {\n                 if configured_warning_level != Level::Warn {\n                     level = configured_warning_level;\n@@ -112,9 +117,17 @@ impl LintLevelSets {\n         return (level, src)\n     }\n \n-    fn get_lint_id_level(&self, id: LintId, mut idx: u32)\n+    fn get_lint_id_level(&self,\n+                         id: LintId,\n+                         mut idx: u32,\n+                         aux: Option<&FxHashMap<LintId, (Level, LintSource)>>)\n         -> (Option<Level>, LintSource)\n     {\n+        if let Some(specs) = aux {\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src)\n+            }\n+        }\n         loop {\n             match self.list[idx as usize] {\n                 LintSet::CommandLine { ref specs } => {\n@@ -212,21 +225,35 @@ impl<'a> LintLevelsBuilder<'a> {\n                             specs.insert(*id, (level, src));\n                         }\n                     }\n+\n+                    _ if !self.warn_about_weird_lints => {}\n+\n                     CheckLintNameResult::Warning(ref msg) => {\n-                        if self.warn_about_weird_lints {\n-                            self.struct_lint(builtin::RENAMED_AND_REMOVED_LINTS,\n-                                             Some(li.span.into()),\n-                                             msg)\n-                                .emit();\n-                        }\n+                        let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n+                        let (level, src) = self.sets.get_lint_level(lint,\n+                                                                    self.cur,\n+                                                                    Some(&specs));\n+                        lint::struct_lint_level(self.sess,\n+                                                lint,\n+                                                level,\n+                                                src,\n+                                                Some(li.span.into()),\n+                                                msg)\n+                            .emit();\n                     }\n                     CheckLintNameResult::NoLint => {\n-                        if self.warn_about_weird_lints {\n-                            self.struct_lint(builtin::UNKNOWN_LINTS,\n-                                             Some(li.span.into()),\n-                                             &format!(\"unknown lint: `{}`\", name))\n-                                .emit();\n-                        }\n+                        let lint = builtin::UNKNOWN_LINTS;\n+                        let (level, src) = self.sets.get_lint_level(lint,\n+                                                                    self.cur,\n+                                                                    Some(&specs));\n+                        let msg = format!(\"unknown lint: `{}`\", name);\n+                        lint::struct_lint_level(self.sess,\n+                                                lint,\n+                                                level,\n+                                                src,\n+                                                Some(li.span.into()),\n+                                                &msg)\n+                            .emit();\n                     }\n                 }\n             }\n@@ -236,7 +263,7 @@ impl<'a> LintLevelsBuilder<'a> {\n             if level == Level::Forbid {\n                 continue\n             }\n-            let forbid_src = match self.sets.get_lint_id_level(*id, self.cur) {\n+            let forbid_src = match self.sets.get_lint_id_level(*id, self.cur, None) {\n                 (Some(Level::Forbid), src) => src,\n                 _ => continue,\n             };\n@@ -298,7 +325,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                        msg: &str)\n         -> DiagnosticBuilder<'a>\n     {\n-        let (level, src) = self.sets.get_lint_level(lint, self.cur);\n+        let (level, src) = self.sets.get_lint_level(lint, self.cur, None);\n         lint::struct_lint_level(self.sess, lint, level, src, span, msg)\n     }\n \n@@ -337,7 +364,7 @@ impl LintLevelMap {\n         -> Option<(Level, LintSource)>\n     {\n         self.id_to_set.get(&id).map(|idx| {\n-            self.sets.get_lint_level(lint, *idx)\n+            self.sets.get_lint_level(lint, *idx, None)\n         })\n     }\n }"}, {"sha": "b8624722692e9addab9d8d70763f57f171764ece", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -630,8 +630,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let krate = tcx.hir.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);\n     let mut visitor = DeadVisitor {\n-        tcx: tcx,\n-        live_symbols: live_symbols,\n+        tcx,\n+        live_symbols,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "9ba4252b52e570c4665f93bf84de25a469dafb4a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -274,6 +274,7 @@ language_item_table! {\n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n     UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;\n     CopyTraitLangItem,               \"copy\",                    copy_trait;\n+    CloneTraitLangItem,              \"clone\",                   clone_trait;\n     SyncTraitLangItem,               \"sync\",                    sync_trait;\n     FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n "}, {"sha": "8e5f748c78e293a738d5148e33d52872a79dbb43", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1482,12 +1482,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 };\n \n                 if is_assigned {\n-                    self.ir.tcx.lint_node(lint::builtin::UNUSED_VARIABLES, id, sp,\n+                    self.ir.tcx.lint_node_note(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         &format!(\"variable `{}` is assigned to, but never used\",\n+                                 name),\n+                        &format!(\"to disable this warning, consider using `_{}` instead\",\n                                  name));\n                 } else if name != \"self\" {\n-                    self.ir.tcx.lint_node(lint::builtin::UNUSED_VARIABLES, id, sp,\n-                        &format!(\"unused variable: `{}`\", name));\n+                    self.ir.tcx.lint_node_note(lint::builtin::UNUSED_VARIABLES, id, sp,\n+                        &format!(\"unused variable: `{}`\", name),\n+                        &format!(\"to disable this warning, consider using `_{}` instead\",\n+                                 name));\n                 }\n             }\n             true"}, {"sha": "8cd023b8e638b87a502aa4b0e6eb4cd0e9c92f0d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -332,7 +332,7 @@ impl MutabilityCategory {\n \n     fn from_local(tcx: TyCtxt, tables: &ty::TypeckTables, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n-            hir_map::NodeLocal(p) => match p.node {\n+            hir_map::NodeBinding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)\n@@ -873,10 +873,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let promotable = self.tcx.rvalue_promotable_to_static.borrow().get(&id).cloned()\n                                    .unwrap_or(false);\n \n-        // When the corresponding feature isn't toggled, only promote `[T; 0]`.\n+        // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n             ty::TyArray(_, 0) => true,\n-            _ => promotable && self.tcx.sess.features.borrow().rvalue_static_promotion,\n+            _ => promotable,\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if"}, {"sha": "45a3080ed91ff3e5e4389e76e2a83ab5dfc0b888", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -72,7 +72,7 @@ use mir::transform::MirSource;\n ///  (M1.): Misc extent of the whole `let a = ...;` statement.\n ///  (M2.): Misc extent of the `f()` expression.\n ///  (M3.): Misc extent of the `f().g(..)` expression.\n-///  (M4.): Misc extent of the block labelled `'b:`.\n+///  (M4.): Misc extent of the block labeled `'b:`.\n ///  (M5.): Misc extent of the `let x = d();` statement\n ///  (D6.): DestructionScope for temporaries created during M5.\n ///  (R7.): Remainder extent for block `'b:`, stmt 0 (let x = ...)."}, {"sha": "a8e98e53db394960de8abd5537dfdae7fafb763d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -915,18 +915,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 def: Def,\n                                 depth: usize,\n                                 params: &'tcx hir::PathParameters) {\n-        let data = match *params {\n-            hir::ParenthesizedParameters(ref data) => {\n-                self.visit_fn_like_elision(&data.inputs, data.output.as_ref());\n-                return;\n-            }\n-            hir::AngleBracketedParameters(ref data) => data\n-        };\n+        if params.parenthesized {\n+            self.visit_fn_like_elision(params.inputs(), Some(&params.bindings[0].ty));\n+            return;\n+        }\n \n-        if data.lifetimes.iter().all(|l| l.is_elided()) {\n-            self.resolve_elided_lifetimes(&data.lifetimes);\n+        if params.lifetimes.iter().all(|l| l.is_elided()) {\n+            self.resolve_elided_lifetimes(&params.lifetimes);\n         } else {\n-            for l in &data.lifetimes { self.visit_lifetime(l); }\n+            for l in &params.lifetimes { self.visit_lifetime(l); }\n         }\n \n         // Figure out if this is a type/trait segment,\n@@ -995,13 +992,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             Some(Region::Static)\n                         }\n                     }\n-                    Set1::One(r) => r.subst(&data.lifetimes, map),\n+                    Set1::One(r) => r.subst(&params.lifetimes, map),\n                     Set1::Many => None\n                 }\n             }).collect()\n         });\n \n-        for (i, ty) in data.types.iter().enumerate() {\n+        for (i, ty) in params.types.iter().enumerate() {\n             if let Some(&lt) = object_lifetime_defaults.get(i) {\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: lt,\n@@ -1013,7 +1010,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        for b in &data.bindings { self.visit_assoc_type_binding(b); }\n+        for b in &params.bindings { self.visit_assoc_type_binding(b); }\n     }\n \n     fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],\n@@ -1081,20 +1078,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Some(body)\n             }\n \n-            // `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n-\n-            // Foreign `fn` decls are terrible because we messed up,\n-            // and their return types get argument type elision.\n-            // And now too much code out there is abusing this rule.\n-            hir::map::NodeForeignItem(_) => {\n-                let arg_scope = Scope::Elision {\n-                    elide: arg_elide,\n-                    s: self.scope\n-                };\n-                self.with(arg_scope, |_, this| this.visit_ty(output));\n-                return;\n-            }\n+            // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n+            hir::map::NodeForeignItem(_) | hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n \n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types."}, {"sha": "d2ed29a3a0ff636c3d778b9ed9c26e81e62c85f6", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -123,7 +123,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Self)\n     {\n-        if self.index.staged_api[&LOCAL_CRATE] {\n+        if self.tcx.sess.features.borrow().staged_api {\n+            // This crate explicitly wants staged API.\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n             if let Some(..) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n                 self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n@@ -204,6 +205,15 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n             }\n \n+            // Propagate unstability.  This can happen even for non-staged-api crates in case\n+            // -Zforce-unstable-if-unmarked is set.\n+            if let Some(stab) = self.parent_stab {\n+                if stab.level.is_unstable() {\n+                    let def_id = self.tcx.hir.local_def_id(id);\n+                    self.index.stab_map.insert(def_id, Some(stab));\n+                }\n+            }\n+\n             if let Some(depr) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n                 if kind == AnnotationKind::Prohibited {\n                     self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");"}, {"sha": "74c3408c4c2f61837d9e3e7fb4841b7080ee0518", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n ///\n /// Reverse postorder is the reverse order of a postorder traversal.\n /// This is different to a preorder traversal and represents a natural\n-/// linearisation of control-flow.\n+/// linearization of control-flow.\n ///\n /// ```text\n ///"}, {"sha": "99fe8e60ae52b139d049d47e6fc9ef21296b8d19", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -918,6 +918,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n     identify_regions: bool = (false, parse_bool, [UNTRACKED],\n         \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n+    borrowck_mir: bool = (false, parse_bool, [UNTRACKED],\n+        \"implicitly treat functions as if they have `#[rustc_mir_borrowck]` attribute\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,\n@@ -993,6 +995,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"enable queries of the dependency graph for regression testing\"),\n+    profile_queries: bool = (false, parse_bool, [UNTRACKED],\n+          \"trace and profile the queries of the incremental compilation framework\"),\n+    profile_queries_and_keys: bool = (false, parse_bool, [UNTRACKED],\n+          \"trace and profile the queries and keys of the incremental compilation framework\"),\n     no_analysis: bool = (false, parse_bool, [UNTRACKED],\n           \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],"}, {"sha": "823a637c7e0d4272c70876efd577a26c0664efdd", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -389,6 +389,13 @@ impl Session {\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n+    pub fn profile_queries(&self) -> bool {\n+        self.opts.debugging_opts.profile_queries ||\n+            self.opts.debugging_opts.profile_queries_and_keys\n+    }\n+    pub fn profile_queries_and_keys(&self) -> bool {\n+        self.opts.debugging_opts.profile_queries_and_keys\n+    }\n     pub fn count_llvm_insns(&self) -> bool {\n         self.opts.debugging_opts.count_llvm_insns\n     }\n@@ -429,6 +436,31 @@ impl Session {\n             .unwrap_or(self.opts.debug_assertions)\n     }\n \n+    pub fn crt_static(&self) -> bool {\n+        // If the target does not opt in to crt-static support, use its default.\n+        if self.target.target.options.crt_static_respected {\n+            self.crt_static_feature()\n+        } else {\n+            self.target.target.options.crt_static_default\n+        }\n+    }\n+\n+    pub fn crt_static_feature(&self) -> bool {\n+        let requested_features = self.opts.cg.target_feature.split(',');\n+        let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n+        let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n+\n+        // If the target we're compiling for requests a static crt by default,\n+        // then see if the `-crt-static` feature was passed to disable that.\n+        // Otherwise if we don't have a static crt by default then see if the\n+        // `+crt-static` feature was passed.\n+        if self.target.target.options.crt_static_default {\n+            !found_negative\n+        } else {\n+            found_positive\n+        }\n+    }\n+\n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n         self.opts.debuginfo != DebugInfoLevel::NoDebugInfo ||\n         !self.target.target.options.eliminate_frame_pointer"}, {"sha": "3e64c8c7dea997ad668916246eb63f0b9bfc633e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1111,8 +1111,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::StructInitializerSized => {\n                 err.note(\"structs must have a statically known size to be initialized\");\n             }\n-            ObligationCauseCode::FieldSized => {\n-                err.note(\"only the last field of a struct may have a dynamically sized type\");\n+            ObligationCauseCode::FieldSized(ref item) => {\n+                match *item {\n+                    AdtKind::Struct => {\n+                        err.note(\"only the last field of a struct may have a dynamically \\\n+                                  sized type\");\n+                    }\n+                    AdtKind::Union => {\n+                        err.note(\"no field of a union may have a dynamically sized type\");\n+                    }\n+                    AdtKind::Enum => {\n+                        err.note(\"no field of an enum variant may have a dynamically sized type\");\n+                    }\n+                }\n             }\n             ObligationCauseCode::ConstSized => {\n                 err.note(\"constant expressions must have a statically known size\");\n@@ -1154,8 +1165,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder) {\n         let current_limit = self.tcx.sess.recursion_limit.get();\n         let suggested_limit = current_limit * 2;\n-        err.help(&format!(\n-                          \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+        err.help(&format!(\"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                           suggested_limit));\n     }\n }"}, {"sha": "78e47693caaf138a47d6baaeee3cf9dd95a0654b", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n /// errors, and which are still pending. At any point, users can call\n-/// `select_where_possible`, and the fulfilment context will try to do\n+/// `select_where_possible`, and the fulfillment context will try to do\n /// selection, retaining only those obligations that remain\n /// ambiguous. This may be helpful in pushing type inference\n /// along. Once all type inference constraints have been generated, the"}, {"sha": "5bae82c1a332fee87e53ac62087c34c4b70cfe85", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -20,7 +20,7 @@ use hir::def_id::DefId;\n use middle::region::RegionMaps;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n-use ty::{self, Ty, TyCtxt, TypeFoldable, ToPredicate};\n+use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use infer::{InferCtxt};\n \n@@ -133,7 +133,7 @@ pub enum ObligationCauseCode<'tcx> {\n     RepeatVec,\n \n     /// Types of fields (other than the last) in a struct must be sized.\n-    FieldSized,\n+    FieldSized(AdtKind),\n \n     /// Constant expressions must be sized.\n     ConstSized,"}, {"sha": "46bdb1344b2fe3fe920192e135b40e49370ec27d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1296,6 +1296,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n          } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n              self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n          } else {\n+            if self.tcx().lang_items.clone_trait() == Some(def_id) {\n+                // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n+                // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n+                // types have builtin support for `Clone`.\n+                let clone_conditions = self.copy_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n+            }\n+\n              self.assemble_closure_candidates(obligation, &mut candidates)?;\n              self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n              self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n@@ -2164,8 +2172,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match candidate {\n             BuiltinCandidate { has_nested } => {\n-                Ok(VtableBuiltin(\n-                    self.confirm_builtin_candidate(obligation, has_nested)))\n+                let data = self.confirm_builtin_candidate(obligation, has_nested);\n+                Ok(VtableBuiltin(data))\n             }\n \n             ParamCandidate(param) => {\n@@ -2271,6 +2279,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 _ if Some(trait_def) == self.tcx().lang_items.copy_trait() => {\n                     self.copy_conditions(obligation)\n                 }\n+                _ if Some(trait_def) == self.tcx().lang_items.clone_trait() => {\n+                    self.copy_conditions(obligation)\n+                }\n                 _ => bug!(\"unexpected builtin trait {:?}\", trait_def)\n             };\n             let nested = match conditions {\n@@ -2291,6 +2302,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         debug!(\"confirm_builtin_candidate: obligations={:?}\",\n                obligations);\n+\n         VtableBuiltinData { nested: obligations }\n     }\n \n@@ -2598,8 +2610,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn confirm_builtin_unsize_candidate(&mut self,\n                                         obligation: &TraitObligation<'tcx>,)\n-                                        -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n-                                                  SelectionError<'tcx>> {\n+        -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>>\n+    {\n         let tcx = self.tcx();\n \n         // assemble_candidates_for_unsizing should ensure there are no late bound"}, {"sha": "d913c76ec3c09c096cde8e9118692be242bbf6c3", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ReturnType(id) => Some(super::ReturnType(id)),\n             super::SizedReturnType => Some(super::SizedReturnType),\n             super::RepeatVec => Some(super::RepeatVec),\n-            super::FieldSized => Some(super::FieldSized),\n+            super::FieldSized(item) => Some(super::FieldSized(item)),\n             super::ConstSized => Some(super::ConstSized),\n             super::SharedStatic => Some(super::SharedStatic),\n             super::BuiltinDerivedObligation(ref cause) => {\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                 })\n             }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(d) => Some(traits::VtableBuiltin(d)),\n+            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n             traits::VtableObject(traits::VtableObjectData {\n                 upcast_trait_ref,\n                 vtable_base,\n@@ -484,7 +484,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::SizedReturnType |\n             super::ReturnNoExpression |\n             super::RepeatVec |\n-            super::FieldSized |\n+            super::FieldSized(_) |\n             super::ConstSized |\n             super::SharedStatic |\n             super::BlockTailExpression(_) |\n@@ -532,7 +532,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::SizedReturnType |\n             super::ReturnNoExpression |\n             super::RepeatVec |\n-            super::FieldSized |\n+            super::FieldSized(_) |\n             super::ConstSized |\n             super::SharedStatic |\n             super::BlockTailExpression(_) |"}, {"sha": "6ce2232eb3e5d38ad36c2ae8af266990584d15df", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -797,6 +797,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub maybe_unused_trait_imports: NodeSet,\n \n+    pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n+\n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n@@ -851,7 +853,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n-    /// error reporting, and so is lazily initialised and generally\n+    /// error reporting, and so is lazily initialized and generally\n     /// shouldn't taint the common path (hence the RefCell).\n     pub all_traits: RefCell<Option<Vec<DefId>>>,\n }\n@@ -1038,6 +1040,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             mir_passes,\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n+            maybe_unused_extern_crates: resolutions.maybe_unused_extern_crates,\n             rcache: RefCell::new(FxHashMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n@@ -1695,8 +1698,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                          substs: &'tcx Substs<'tcx>)\n         -> Ty<'tcx> {\n             self.mk_ty(TyProjection(ProjectionTy {\n-                item_def_id: item_def_id,\n-                substs: substs,\n+                item_def_id,\n+                substs,\n             }))\n         }\n \n@@ -1840,6 +1843,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.struct_span_lint_node(lint, id, span.into(), msg).emit()\n     }\n \n+    pub fn lint_node_note<S: Into<MultiSpan>>(self,\n+                                              lint: &'static Lint,\n+                                              id: NodeId,\n+                                              span: S,\n+                                              msg: &str,\n+                                              note: &str) {\n+        let mut err = self.struct_span_lint_node(lint, id, span.into(), msg);\n+        err.note(note);\n+        err.emit()\n+    }\n+\n     pub fn lint_level_at_node(self, lint: &'static Lint, mut id: NodeId)\n         -> (lint::Level, lint::LintSource)\n     {"}, {"sha": "3629709e6a48de19a1f0843f26d4b7f88099f353", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -26,7 +26,7 @@ pub struct DefIdForest {\n     /// The minimal set of DefIds required to represent the whole set.\n     /// If A and B are DefIds in the DefIdForest, and A is a descendant\n     /// of B, then only B will be in root_ids.\n-    /// We use a SmallVec here because (for its use for cacheing inhabitedness)\n+    /// We use a SmallVec here because (for its use for caching inhabitedness)\n     /// its rare that this will contain even two ids.\n     root_ids: SmallVec<[DefId; 1]>,\n }"}, {"sha": "7d543f689c24d179283eaa80904b2906b4070bab", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -24,15 +24,22 @@ pub struct Instance<'tcx> {\n pub enum InstanceDef<'tcx> {\n     Item(DefId),\n     Intrinsic(DefId),\n-    // <fn() as FnTrait>::call_*\n-    // def-id is FnTrait::call_*\n+\n+    /// <fn() as FnTrait>::call_*\n+    /// def-id is FnTrait::call_*\n     FnPtrShim(DefId, Ty<'tcx>),\n-    // <Trait as Trait>::fn\n+\n+    /// <Trait as Trait>::fn\n     Virtual(DefId, usize),\n-    // <[mut closure] as FnOnce>::call_once\n+\n+    /// <[mut closure] as FnOnce>::call_once\n     ClosureOnceShim { call_once: DefId },\n-    // drop_in_place::<T>; None for empty drop glue.\n+\n+    /// drop_in_place::<T>; None for empty drop glue.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n+\n+    /// Builtin method implementation, e.g. `Clone::clone`.\n+    CloneShim(DefId, Ty<'tcx>),\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n@@ -43,9 +50,9 @@ impl<'tcx> InstanceDef<'tcx> {\n             InstanceDef::FnPtrShim(def_id, _) |\n             InstanceDef::Virtual(def_id, _) |\n             InstanceDef::Intrinsic(def_id, ) |\n-            InstanceDef::ClosureOnceShim { call_once: def_id }\n-                => def_id,\n-            InstanceDef::DropGlue(def_id, _) => def_id\n+            InstanceDef::ClosureOnceShim { call_once: def_id } |\n+            InstanceDef::DropGlue(def_id, _) |\n+            InstanceDef::CloneShim(def_id, _) => def_id\n         }\n     }\n \n@@ -80,6 +87,9 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n             InstanceDef::DropGlue(_, ty) => {\n                 write!(f, \" - shim({:?})\", ty)\n             }\n+            InstanceDef::CloneShim(_, ty) => {\n+                write!(f, \" - shim({:?})\", ty)\n+            }\n         }\n     }\n }"}, {"sha": "5caf5139812802f2abf2429bc88d4cd5e43b0bfe", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,7 +13,6 @@ use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use syntax_pos::DUMMY_SP;\n \n use std::cell::Cell;\n \n@@ -222,11 +221,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let use_types = !self.is_default_impl(impl_def_id) && (!impl_def_id.is_local() || {\n             // Otherwise, use filename/line-number if forced.\n             let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n-            !force_no_types && {\n-                // Otherwise, use types if we can query them without inducing a cycle.\n-                ty::queries::impl_trait_ref::try_get(self, DUMMY_SP, impl_def_id).is_ok() &&\n-                    ty::queries::type_of::try_get(self, DUMMY_SP, impl_def_id).is_ok()\n-            }\n+            !force_no_types\n         });\n \n         if !use_types {"}, {"sha": "a73202ced61e627ef2dfc2cb24fae0ebb873b218", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 131, "deletions": 31, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n+use errors::{Diagnostic, DiagnosticBuilder};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n@@ -28,10 +29,11 @@ use ty::steal::Steal;\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, NodeSet};\n+use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n-use std::cell::{RefCell, RefMut};\n+use std::cell::{RefCell, RefMut, Cell};\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::marker::PhantomData;\n@@ -187,7 +189,18 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n \n struct QueryMap<D: QueryDescription> {\n     phantom: PhantomData<D>,\n-    map: FxHashMap<D::Key, (D::Value, DepNodeIndex)>,\n+    map: FxHashMap<D::Key, QueryValue<D::Value>>,\n+}\n+\n+struct QueryValue<T> {\n+    value: T,\n+    index: DepNodeIndex,\n+    diagnostics: Option<Box<QueryDiagnostics>>,\n+}\n+\n+struct QueryDiagnostics {\n+    diagnostics: Vec<Diagnostic>,\n+    emitted_diagnostics: Cell<bool>,\n }\n \n impl<M: QueryDescription> QueryMap<M> {\n@@ -199,13 +212,15 @@ impl<M: QueryDescription> QueryMap<M> {\n     }\n }\n \n-pub struct CycleError<'a, 'tcx: 'a> {\n+struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n     cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn report_cycle(self, CycleError { span, cycle }: CycleError) {\n+    fn report_cycle(self, CycleError { span, cycle }: CycleError)\n+        -> DiagnosticBuilder<'a>\n+    {\n         // Subtle: release the refcell lock before invoking `describe()`\n         // below by dropping `cycle`.\n         let stack = cycle.to_vec();\n@@ -234,8 +249,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n                               stack[0].1.describe(self)));\n \n-            err.emit();\n-        });\n+            return err\n+        })\n     }\n \n     fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n@@ -501,6 +516,18 @@ impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::is_compiler_builtins<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        \"checking if the crate is_compiler_builtins\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::has_global_allocator<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        \"checking if the crate has_global_allocator\".to_string()\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         \"getting crate's ExternCrateData\".to_string()\n@@ -513,6 +540,29 @@ impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n     }\n }\n \n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if  $tcx.sess.profile_queries() {\n+                profq_msg($msg)\n+            }\n+        }\n+    }\n+}\n+\n+// If enabled, format a key using its debug string, which can be\n+// expensive to compute (in terms of time).\n+macro_rules! profq_key {\n+    ($tcx:expr, $key:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries_and_keys() {\n+                Some(format!(\"{:?}\", $key))\n+            } else { None }\n+        } else { None }\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -539,6 +589,12 @@ macro_rules! define_maps {\n             $($(#[$attr])* $name($K)),*\n         }\n \n+        #[allow(bad_style)]\n+        #[derive(Clone, Debug, PartialEq, Eq)]\n+        pub enum QueryMsg {\n+            $($name(Option<String>)),*\n+        }\n+\n         impl<$tcx> Query<$tcx> {\n             pub fn describe(&self, tcx: TyCtxt) -> String {\n                 match *self {\n@@ -581,10 +637,30 @@ macro_rules! define_maps {\n                        key,\n                        span);\n \n-                if let Some(&(ref result, dep_node_index)) = tcx.maps.$name.borrow().map.get(&key) {\n-                    tcx.dep_graph.read_index(dep_node_index);\n-                    return Ok(f(result));\n+                profq_msg!(tcx,\n+                    ProfileQueriesMsg::QueryBegin(\n+                        span.clone(),\n+                        QueryMsg::$name(profq_key!(tcx, key))\n+                    )\n+                );\n+\n+                if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n+                    if let Some(ref d) = value.diagnostics {\n+                        if !d.emitted_diagnostics.get() {\n+                            d.emitted_diagnostics.set(true);\n+                            let handle = tcx.sess.diagnostic();\n+                            for diagnostic in d.diagnostics.iter() {\n+                                DiagnosticBuilder::new_diagnostic(handle, diagnostic.clone())\n+                                    .emit();\n+                            }\n+                        }\n+                    }\n+                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                    tcx.dep_graph.read_index(value.index);\n+                    return Ok(f(&value.value));\n                 }\n+                // else, we are going to run the provider:\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n \n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n@@ -593,40 +669,60 @@ macro_rules! define_maps {\n                     span = key.default_span(tcx)\n                 }\n \n-                let (result, dep_node_index) = tcx.cycle_check(span, Query::$name(key), || {\n+                let res = tcx.cycle_check(span, Query::$name(key), || {\n                     let dep_node = Self::to_dep_node(tcx, &key);\n \n-                    if dep_node.kind.is_anon() {\n-                        tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                            let provider = tcx.maps.providers[key.map_crate()].$name;\n-                            provider(tcx.global_tcx(), key)\n-                        })\n-                    } else {\n-                        fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n-                                                        key: $K)\n-                                                        -> $V {\n-                            let provider = tcx.maps.providers[key.map_crate()].$name;\n-                            provider(tcx.global_tcx(), key)\n+                    tcx.sess.diagnostic().track_diagnostics(|| {\n+                        if dep_node.kind.is_anon() {\n+                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                                provider(tcx.global_tcx(), key)\n+                            })\n+                        } else {\n+                            fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n+                                                            key: $K)\n+                                                            -> $V {\n+                                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                                provider(tcx.global_tcx(), key)\n+                            }\n+\n+                            tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n                         }\n-\n-                        tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n-                    }\n+                    })\n                 })?;\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n+                let ((result, dep_node_index), diagnostics) = res;\n \n                 tcx.dep_graph.read_index(dep_node_index);\n \n+                let value = QueryValue {\n+                    value: result,\n+                    index: dep_node_index,\n+                    diagnostics: if diagnostics.len() == 0 {\n+                        None\n+                    } else {\n+                        Some(Box::new(QueryDiagnostics {\n+                            diagnostics,\n+                            emitted_diagnostics: Cell::new(true),\n+                        }))\n+                    },\n+                };\n+\n                 Ok(f(&tcx.maps\n                          .$name\n                          .borrow_mut()\n                          .map\n                          .entry(key)\n-                         .or_insert((result, dep_node_index))\n-                         .0))\n+                         .or_insert(value)\n+                         .value))\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n-                           -> Result<$V, CycleError<'a, $tcx>> {\n-                Self::try_get_with(tcx, span, key, Clone::clone)\n+                           -> Result<$V, DiagnosticBuilder<'a>> {\n+                match Self::try_get_with(tcx, span, key, Clone::clone) {\n+                    Ok(e) => Ok(e),\n+                    Err(e) => Err(tcx.report_cycle(e)),\n+                }\n             }\n \n             pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n@@ -635,7 +731,7 @@ macro_rules! define_maps {\n \n                 match Self::try_get_with(tcx, span, key, |_| ()) {\n                     Ok(()) => {}\n-                    Err(e) => tcx.report_cycle(e)\n+                    Err(e) => tcx.report_cycle(e).emit(),\n                 }\n             }\n         })*\n@@ -672,8 +768,8 @@ macro_rules! define_maps {\n         impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n             $($(#[$attr])*\n             pub fn $name(self, key: $K) -> $V {\n-                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|e| {\n-                    self.report_cycle(e);\n+                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n+                    e.emit();\n                     Value::from_cycle_error(self.global_tcx())\n                 })\n             })*\n@@ -923,6 +1019,8 @@ define_maps! { <'tcx>\n     [] coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n     [] borrowck: BorrowCheck(DefId) -> (),\n+    // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n+    [] mir_borrowck: MirBorrowCheck(DefId) -> (),\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n@@ -993,6 +1091,8 @@ define_maps! { <'tcx>\n \n     [] is_allocator: IsAllocator(DefId) -> bool,\n     [] is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n+    [] is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n+    [] has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n \n     [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n "}, {"sha": "6597dccf25816d55da840a68d16034a11047d740", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -131,6 +131,7 @@ pub struct Resolutions {\n     pub freevars: FreevarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n+    pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n     pub export_map: ExportMap,\n }\n \n@@ -1684,12 +1685,15 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         match queries::adt_sized_constraint::try_get(tcx, DUMMY_SP, self.did) {\n             Ok(tys) => tys,\n-            Err(_) => {\n+            Err(mut bug) => {\n                 debug!(\"adt_sized_constraint: {:?} is recursive\", self);\n                 // This should be reported as an error by `check_representable`.\n                 //\n                 // Consider the type as Sized in the meanwhile to avoid\n-                // further errors.\n+                // further errors. Delay our `bug` diagnostic here to get\n+                // emitted later as well in case we accidentally otherwise don't\n+                // emit an error.\n+                bug.delay_as_bug();\n                 tcx.intern_type_list(&[tcx.types.err])\n             }\n         }\n@@ -1971,7 +1975,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn local_var_name_str(self, id: NodeId) -> InternedString {\n         match self.hir.find(id) {\n-            Some(hir_map::NodeLocal(pat)) => {\n+            Some(hir_map::NodeBinding(pat)) => {\n                 match pat.node {\n                     hir::PatKind::Binding(_, _, ref path1, _) => path1.node.as_str(),\n                     _ => {\n@@ -2232,7 +2236,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::InstanceDef::FnPtrShim(..) |\n             ty::InstanceDef::Virtual(..) |\n             ty::InstanceDef::ClosureOnceShim { .. } |\n-            ty::InstanceDef::DropGlue(..) => {\n+            ty::InstanceDef::DropGlue(..) |\n+            ty::InstanceDef::CloneShim(..) => {\n                 self.mir_shims(instance)\n             }\n         }"}, {"sha": "c035817d66db0336381e2177ec286f7bc8af319f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -253,7 +253,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n             let substs = relation.relate(&a.substs, &b.substs)?;\n             Ok(ty::ExistentialProjection {\n                 item_def_id: a.item_def_id,\n-                substs: substs,\n+                substs,\n                 ty,\n             })\n         }"}, {"sha": "e41eb079b3782dd9356af8ff4d87b02ac558aee8", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ProjectionTy {\n                 item_def_id: self.item_def_id,\n-                substs: substs,\n+                substs,\n             }\n         })\n     }"}, {"sha": "8d6b7b7ac9fddff6537358098bc78a1e4900b394", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -569,7 +569,7 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n     pub fn trait_ref(&self, tcx: TyCtxt) -> ty::TraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::TraitRef {\n-            def_id: def_id,\n+            def_id,\n             substs: self.substs,\n         }\n     }\n@@ -739,7 +739,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n ///\n /// The process of doing that is called \"skolemization\". The bound regions\n /// are replaced by skolemized markers, which don't satisfy any relation\n-/// not explicity provided.\n+/// not explicitly provided.\n ///\n /// There are 2 kinds of skolemized regions in rustc: `ReFree` and\n /// `ReSkolemized`. When checking an item's body, `ReFree` is supposed\n@@ -874,7 +874,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n     pub fn trait_ref(&self, tcx: TyCtxt) -> ty::ExistentialTraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::ExistentialTraitRef{\n-            def_id: def_id,\n+            def_id,\n             substs: self.substs,\n         }\n     }"}, {"sha": "bbbb8611f98a5f104b11b96b2d93954d3826bda3", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -1069,11 +1069,15 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let needs_drop = |ty: Ty<'tcx>| -> bool {\n         match ty::queries::needs_drop_raw::try_get(tcx, DUMMY_SP, param_env.and(ty)) {\n             Ok(v) => v,\n-            Err(_) => {\n+            Err(mut bug) => {\n                 // Cycles should be reported as an error by `check_representable`.\n                 //\n-                // Consider the type as not needing drop in the meanwhile to avoid\n-                // further errors.\n+                // Consider the type as not needing drop in the meanwhile to\n+                // avoid further errors.\n+                //\n+                // In case we forgot to emit a bug elsewhere, delay our\n+                // diagnostic to get emitted as a compiler bug.\n+                bug.delay_as_bug();\n                 false\n             }\n         }"}, {"sha": "6d9e648452fd345fb8732a4660892e70fc06c705", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -58,7 +58,7 @@ pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                          -> Vec<traits::PredicateObligation<'tcx>>\n {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n-    wf.compute_trait_ref(trait_ref);\n+    wf.compute_trait_ref(trait_ref, Elaborate::All);\n     wf.normalize()\n }\n \n@@ -74,7 +74,7 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n         ty::Predicate::Trait(ref t) => {\n-            wf.compute_trait_ref(&t.skip_binder().trait_ref); // (*)\n+            wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n         ty::Predicate::Equate(ref t) => {\n             wf.compute(t.skip_binder().0);\n@@ -114,6 +114,35 @@ struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     out: Vec<traits::PredicateObligation<'tcx>>,\n }\n \n+/// Controls whether we \"elaborate\" supertraits and so forth on the WF\n+/// predicates. This is a kind of hack to address #43784. The\n+/// underlying problem in that issue was a trait structure like:\n+///\n+/// ```\n+/// trait Foo: Copy { }\n+/// trait Bar: Foo { }\n+/// impl<T: Bar> Foo for T { }\n+/// impl<T> Bar for T { }\n+/// ```\n+///\n+/// Here, in the `Foo` impl, we will check that `T: Copy` holds -- but\n+/// we decide that this is true because `T: Bar` is in the\n+/// where-clauses (and we can elaborate that to include `T:\n+/// Copy`). This wouldn't be a problem, except that when we check the\n+/// `Bar` impl, we decide that `T: Foo` must hold because of the `Foo`\n+/// impl. And so nowhere did we check that `T: Copy` holds!\n+///\n+/// To resolve this, we elaborate the WF requirements that must be\n+/// proven when checking impls. This means that (e.g.) the `impl Bar\n+/// for T` will be forced to prove not only that `T: Foo` but also `T:\n+/// Copy` (which it won't be able to do, because there is no `Copy`\n+/// impl for `T`).\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum Elaborate {\n+    All,\n+    None,\n+}\n+\n impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n@@ -135,12 +164,25 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n     /// Pushes the obligations required for `trait_ref` to be WF into\n     /// `self.out`.\n-    fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n+    fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>, elaborate: Elaborate) {\n         let obligations = self.nominal_obligations(trait_ref.def_id, trait_ref.substs);\n-        self.out.extend(obligations);\n \n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n+\n+        if let Elaborate::All = elaborate {\n+            let predicates = obligations.iter()\n+                                        .map(|obligation| obligation.predicate.clone())\n+                                        .collect();\n+            let implied_obligations = traits::elaborate_predicates(self.infcx.tcx, predicates);\n+            let implied_obligations = implied_obligations.map(|pred| {\n+                traits::Obligation::new(cause.clone(), param_env, pred)\n+            });\n+            self.out.extend(implied_obligations);\n+        }\n+\n+        self.out.extend(obligations);\n+\n         self.out.extend(\n             trait_ref.substs.types()\n                             .filter(|ty| !ty.has_escaping_regions())\n@@ -156,7 +198,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         // WF and (b) the trait-ref holds.  (It may also be\n         // normalizable and be WF that way.)\n         let trait_ref = data.trait_ref(self.infcx.tcx);\n-        self.compute_trait_ref(&trait_ref);\n+        self.compute_trait_ref(&trait_ref, Elaborate::None);\n \n         if !data.has_escaping_regions() {\n             let predicate = trait_ref.to_predicate();"}, {"sha": "618a4ed331e766056cf1a207a86cd5dca747902e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -19,6 +19,11 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n+use std::sync::mpsc::{Sender};\n+use syntax_pos::{Span};\n+use ty::maps::{QueryMsg};\n+use dep_graph::{DepNode};\n+\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -29,6 +34,72 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n+/// Initialized for -Z profile-queries\n+thread_local!(static PROFQ_CHAN: RefCell<Option<Sender<ProfileQueriesMsg>>> = RefCell::new(None));\n+\n+/// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n+#[derive(Clone,Debug)]\n+pub struct ProfQDumpParams {\n+    /// A base path for the files we will dump\n+    pub path:String,\n+    /// To ensure that the compiler waits for us to finish our dumps\n+    pub ack:Sender<()>,\n+    /// toggle dumping a log file with every `ProfileQueriesMsg`\n+    pub dump_profq_msg_log:bool,\n+}\n+\n+/// A sequence of these messages induce a trace of query-based incremental compilation.\n+/// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n+#[derive(Clone,Debug)]\n+pub enum ProfileQueriesMsg {\n+    /// begin a timed pass\n+    TimeBegin(String),\n+    /// end a timed pass\n+    TimeEnd,\n+    /// begin a task (see dep_graph::graph::with_task)\n+    TaskBegin(DepNode),\n+    /// end a task\n+    TaskEnd,\n+    /// begin a new query\n+    QueryBegin(Span, QueryMsg),\n+    /// query is satisfied by using an already-known value for the given key\n+    CacheHit,\n+    /// query requires running a provider; providers may nest, permitting queries to nest.\n+    ProviderBegin,\n+    /// query is satisfied by a provider terminating with a value\n+    ProviderEnd,\n+    /// dump a record of the queries to the given path\n+    Dump(ProfQDumpParams),\n+    /// halt the profiling/monitoring background thread\n+    Halt\n+}\n+\n+/// If enabled, send a message to the profile-queries thread\n+pub fn profq_msg(msg: ProfileQueriesMsg) {\n+    PROFQ_CHAN.with(|sender|{\n+        if let Some(s) = sender.borrow().as_ref() {\n+            s.send(msg).unwrap()\n+        } else {\n+            // Do nothing.\n+            //\n+            // FIXME(matthewhammer): Multi-threaded translation phase triggers the panic below.\n+            // From backtrace: rustc_trans::back::write::spawn_work::{{closure}}.\n+            //\n+            // panic!(\"no channel on which to send profq_msg: {:?}\", msg)\n+        }\n+    })\n+}\n+\n+/// Set channel for profile queries channel\n+pub fn profq_set_chan(s: Sender<ProfileQueriesMsg>) -> bool {\n+    PROFQ_CHAN.with(|chan|{\n+        if chan.borrow().is_none() {\n+            *chan.borrow_mut() = Some(s);\n+            true\n+        } else { false }\n+    })\n+}\n+\n /// Read the current depth of `time()` calls. This is used to\n /// encourage indentation across threads.\n pub fn time_depth() -> usize {\n@@ -53,9 +124,15 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n         r\n     });\n \n+    if cfg!(debug_assertions) {\n+        profq_msg(ProfileQueriesMsg::TimeBegin(what.to_string()))\n+    };\n     let start = Instant::now();\n     let rv = f();\n     let dur = start.elapsed();\n+    if cfg!(debug_assertions) {\n+        profq_msg(ProfileQueriesMsg::TimeEnd)\n+    };\n \n     print_time_passes_entry_internal(what, dur);\n "}, {"sha": "f99c6a29ff00a9cd71033aa40781b7a68c2027b4", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -36,9 +36,9 @@ pub fn modify(sess: &ParseSess,\n               krate: Crate,\n               handler: &rustc_errors::Handler) -> ast::Crate {\n     ExpandAllocatorDirectives {\n-        handler: handler,\n-        sess: sess,\n-        resolver: resolver,\n+        handler,\n+        sess,\n+        resolver,\n         found: false,\n     }.fold_crate(krate)\n }\n@@ -88,7 +88,7 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n         };\n         let ecfg = ExpansionConfig::default(name.to_string());\n         let mut f = AllocFnFactory {\n-            span: span,\n+            span,\n             kind: AllocatorKind::Global,\n             global: item.ident,\n             alloc: Ident::from_str(\"alloc\"),"}, {"sha": "e17fce5a2ec0a276d5409af7ecea393a3edd257b", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(warnings)]\n+\n #![feature(rustc_private)]\n \n extern crate rustc;\n@@ -22,69 +24,58 @@ pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n         name: \"alloc\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"oom\",\n         inputs: &[AllocatorTy::AllocErr],\n         output: AllocatorTy::Bang,\n-        is_unsafe: false,\n     },\n     AllocatorMethod {\n         name: \"dealloc\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n         output: AllocatorTy::Unit,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"usable_size\",\n         inputs: &[AllocatorTy::LayoutRef],\n         output: AllocatorTy::UsizePair,\n-        is_unsafe: false,\n     },\n     AllocatorMethod {\n         name: \"realloc\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"alloc_zeroed\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"alloc_excess\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultExcess,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"realloc_excess\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultExcess,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"grow_in_place\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultUnit,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"shrink_in_place\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultUnit,\n-        is_unsafe: true,\n     },\n ];\n \n pub struct AllocatorMethod {\n     pub name: &'static str,\n     pub inputs: &'static [AllocatorTy],\n     pub output: AllocatorTy,\n-    pub is_unsafe: bool,\n }\n \n pub enum AllocatorTy {"}, {"sha": "124c840cc56d63cbf311a8676598e8bb7e8586e6", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 96, "deletions": 30, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -460,18 +460,15 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n             // rem <- sig % 10\n             // sig <- sig / 10\n             let mut rem = 0;\n-            for limb in sig.iter_mut().rev() {\n-                // We don't have an integer doubly wide than Limb,\n-                // so we have to split the divrem on two halves.\n-                const HALF_BITS: usize = LIMB_BITS / 2;\n-                let mut halves = [*limb & ((1 << HALF_BITS) - 1), *limb >> HALF_BITS];\n-                for half in halves.iter_mut().rev() {\n-                    *half |= rem << HALF_BITS;\n-                    rem = *half % 10;\n-                    *half /= 10;\n-                }\n-                *limb = halves[0] | (halves[1] << HALF_BITS);\n-            }\n+\n+            // Use 64-bit division and remainder, with 32-bit chunks from sig.\n+            sig::each_chunk(&mut sig, 32, |chunk| {\n+                let chunk = chunk as u32;\n+                let combined = ((rem as u64) << 32) | (chunk as u64);\n+                rem = (combined % 10) as u8;\n+                (combined / 10) as u32 as Limb\n+            });\n+\n             // Reduce the sigificand to avoid wasting time dividing 0's.\n             while sig.last() == Some(&0) {\n                 sig.pop();\n@@ -491,7 +488,7 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n                 exp += 1;\n             } else {\n                 in_trail = false;\n-                buffer.push(b'0' + digit as u8);\n+                buffer.push(b'0' + digit);\n             }\n         }\n \n@@ -2065,7 +2062,7 @@ impl<S: Semantics> IeeeFloat<S> {\n         };\n \n         // Attempt dec_sig * 10^dec_exp with increasing precision.\n-        let mut attempt = 1;\n+        let mut attempt = 0;\n         loop {\n             let calc_precision = (LIMB_BITS << attempt) - 1;\n             attempt += 1;\n@@ -2310,6 +2307,17 @@ mod sig {\n         limbs.iter().all(|&l| l == 0)\n     }\n \n+    /// One, not zero, based LSB. That is, returns 0 for a zeroed significand.\n+    pub(super) fn olsb(limbs: &[Limb]) -> usize {\n+        for i in 0..limbs.len() {\n+            if limbs[i] != 0 {\n+                return i * LIMB_BITS + limbs[i].trailing_zeros() as usize + 1;\n+            }\n+        }\n+\n+        0\n+    }\n+\n     /// One, not zero, based MSB. That is, returns 0 for a zeroed significand.\n     pub(super) fn omsb(limbs: &[Limb]) -> usize {\n         for i in (0..limbs.len()).rev() {\n@@ -2468,6 +2476,20 @@ mod sig {\n         }\n     }\n \n+    /// For every consecutive chunk of `bits` bits from `limbs`,\n+    /// going from most significant to the least significant bits,\n+    /// call `f` to transform those bits and store the result back.\n+    pub(super) fn each_chunk<F: FnMut(Limb) -> Limb>(limbs: &mut [Limb], bits: usize, mut f: F) {\n+        assert_eq!(LIMB_BITS % bits, 0);\n+        for limb in limbs.iter_mut().rev() {\n+            let mut r = 0;\n+            for i in (0..LIMB_BITS / bits).rev() {\n+                r |= f((*limb >> (i * bits)) & ((1 << bits) - 1)) << (i * bits);\n+            }\n+            *limb = r;\n+        }\n+    }\n+\n     /// Increment in-place, return the carry flag.\n     pub(super) fn increment(dst: &mut [Limb]) -> Limb {\n         for x in dst {\n@@ -2686,10 +2708,6 @@ mod sig {\n         divisor: &mut [Limb],\n         precision: usize,\n     ) -> Loss {\n-        // Zero the quotient before setting bits in it.\n-        for x in &mut quotient[..limbs_for_bits(precision)] {\n-            *x = 0;\n-        }\n \n         // Normalize the divisor.\n         let bits = precision - omsb(divisor);\n@@ -2700,6 +2718,13 @@ mod sig {\n         let bits = precision - omsb(dividend);\n         shift_left(dividend, exp, bits);\n \n+        // Division by 1.\n+        let olsb_divisor = olsb(divisor);\n+        if olsb_divisor == precision {\n+            quotient.copy_from_slice(dividend);\n+            return Loss::ExactlyZero;\n+        }\n+\n         // Ensure the dividend >= divisor initially for the loop below.\n         // Incidentally, this means that the division loop below is\n         // guaranteed to set the integer bit to one.\n@@ -2708,6 +2733,58 @@ mod sig {\n             assert_ne!(cmp(dividend, divisor), Ordering::Less)\n         }\n \n+        // Helper for figuring out the lost fraction.\n+        let lost_fraction = |dividend: &[Limb], divisor: &[Limb]| {\n+            match cmp(dividend, divisor) {\n+                Ordering::Greater => Loss::MoreThanHalf,\n+                Ordering::Equal => Loss::ExactlyHalf,\n+                Ordering::Less => {\n+                    if is_all_zeros(dividend) {\n+                        Loss::ExactlyZero\n+                    } else {\n+                        Loss::LessThanHalf\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Try to perform a (much faster) short division for small divisors.\n+        let divisor_bits = precision - (olsb_divisor - 1);\n+        macro_rules! try_short_div {\n+            ($W:ty, $H:ty, $half:expr) => {\n+                if divisor_bits * 2 <= $half {\n+                    // Extract the small divisor.\n+                    let _: Loss = shift_right(divisor, &mut 0, olsb_divisor - 1);\n+                    let divisor = divisor[0] as $H as $W;\n+\n+                    // Shift the dividend to produce a quotient with the unit bit set.\n+                    let top_limb = *dividend.last().unwrap();\n+                    let mut rem = (top_limb >> (LIMB_BITS - (divisor_bits - 1))) as $H;\n+                    shift_left(dividend, &mut 0, divisor_bits - 1);\n+\n+                    // Apply short division in place on $H (of $half bits) chunks.\n+                    each_chunk(dividend, $half, |chunk| {\n+                        let chunk = chunk as $H;\n+                        let combined = ((rem as $W) << $half) | (chunk as $W);\n+                        rem = (combined % divisor) as $H;\n+                        (combined / divisor) as $H as Limb\n+                    });\n+                    quotient.copy_from_slice(dividend);\n+\n+                    return lost_fraction(&[(rem as Limb) << 1], &[divisor as Limb]);\n+                }\n+            }\n+        }\n+\n+        try_short_div!(u32, u16, 16);\n+        try_short_div!(u64, u32, 32);\n+        try_short_div!(u128, u64, 64);\n+\n+        // Zero the quotient before setting bits in it.\n+        for x in &mut quotient[..limbs_for_bits(precision)] {\n+            *x = 0;\n+        }\n+\n         // Long division.\n         for bit in (0..precision).rev() {\n             if cmp(dividend, divisor) != Ordering::Less {\n@@ -2717,17 +2794,6 @@ mod sig {\n             shift_left(dividend, &mut 0, 1);\n         }\n \n-        // Figure out the lost fraction.\n-        match cmp(dividend, divisor) {\n-            Ordering::Greater => Loss::MoreThanHalf,\n-            Ordering::Equal => Loss::ExactlyHalf,\n-            Ordering::Less => {\n-                if is_all_zeros(dividend) {\n-                    Loss::ExactlyZero\n-                } else {\n-                    Loss::LessThanHalf\n-                }\n-            }\n-        }\n+        lost_fraction(dividend, divisor)\n     }\n }"}, {"sha": "d4a020657616a05c93cd023cc9a2708e3a0811f8", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -39,7 +39,6 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![crate_name = \"rustc_apfloat\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]"}, {"sha": "1b42fa03a4fb621e3957708aac4424e122c4c670", "filename": "src/librustc_back/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fdynamic_lib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -12,9 +12,8 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-use std::env;\n-use std::ffi::{CString, OsString};\n-use std::path::{Path, PathBuf};\n+use std::ffi::CString;\n+use std::path::Path;\n \n pub struct DynamicLibrary {\n     handle: *mut u8\n@@ -43,24 +42,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Prepends a path to this process's search path for dynamic libraries\n-    pub fn prepend_search_path(path: &Path) {\n-        let mut search_path = DynamicLibrary::search_path();\n-        search_path.insert(0, path.to_path_buf());\n-        env::set_var(DynamicLibrary::envvar(), &DynamicLibrary::create_path(&search_path));\n-    }\n-\n-    /// From a slice of paths, create a new vector which is suitable to be an\n-    /// environment variable for this platforms dylib search path.\n-    pub fn create_path(path: &[PathBuf]) -> OsString {\n-        let mut newvar = OsString::new();\n-        for (i, path) in path.iter().enumerate() {\n-            if i > 0 { newvar.push(DynamicLibrary::separator()); }\n-            newvar.push(path);\n-        }\n-        return newvar;\n-    }\n-\n     /// Returns the environment variable for this process's dynamic library\n     /// search path\n     pub fn envvar() -> &'static str {\n@@ -75,19 +56,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    fn separator() -> &'static str {\n-        if cfg!(windows) { \";\" } else { \":\" }\n-    }\n-\n-    /// Returns the current search path for dynamic libraries being used by this\n-    /// process\n-    pub fn search_path() -> Vec<PathBuf> {\n-        match env::var_os(DynamicLibrary::envvar()) {\n-            Some(var) => env::split_paths(&var).collect(),\n-            None => Vec::new(),\n-        }\n-    }\n-\n     /// Accesses the value at the symbol of the dynamic library.\n     pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n         // This function should have a lifetime constraint of 'a on"}, {"sha": "6a9833d3784a487c637661e9f98312b179aec187", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -21,9 +21,6 @@\n //! one that doesn't; the one that doesn't might get decent parallel\n //! build speedups.\n \n-#![crate_name = \"rustc_back\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]"}, {"sha": "4b02d0b60b8b59a43fc9baff50df77d7fc962b4c", "filename": "src/librustc_back/target/apple_ios_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -97,7 +97,7 @@ pub fn opts(arch: Arch) -> Result<TargetOptions, String> {\n         cpu: target_cpu(arch),\n         dynamic_linking: false,\n         executables: true,\n-        pre_link_args: pre_link_args,\n+        pre_link_args,\n         has_elf_tls: false,\n         .. super::apple_base::opts()\n     })"}, {"sha": "112f424f7a8bb46b64f56984bc2f9d108fae44f4", "filename": "src/librustc_back/target/haiku_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -20,7 +20,6 @@ pub fn opts() -> TargetOptions {\n         target_family: Some(\"unix\".to_string()),\n         relro_level: RelroLevel::Full,\n         linker_is_gnu: true,\n-        no_integrated_as: true,\n         .. Default::default()\n     }\n }"}, {"sha": "31d428d2668395e4830ae934ec12495617abd241", "filename": "src/librustc_back/target/l4re_base.rs", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -12,21 +12,71 @@ use PanicStrategy;\n use LinkerFlavor;\n use target::{LinkArgs, TargetOptions};\n use std::default::Default;\n+use std::env;\n+use std::process::Command;\n \n-pub fn opts() -> TargetOptions {\n+// Use GCC to locate code for crt* libraries from the host, not from L4Re. Note\n+// that a few files also come from L4Re, for these, the function shouldn't be\n+// used. This uses GCC for the location of the file, but GCC is required for L4Re anyway.\n+fn get_path_or(filename: &str) -> String {\n+    let child = Command::new(\"gcc\")\n+        .arg(format!(\"-print-file-name={}\", filename)).output()\n+        .expect(\"Failed to execute GCC\");\n+    String::from_utf8(child.stdout)\n+        .expect(\"Couldn't read path from GCC\").trim().into()\n+}\n+\n+pub fn opts() -> Result<TargetOptions, String> {\n+    let l4re_lib_path = env::var_os(\"L4RE_LIBDIR\").ok_or(\"Unable to find L4Re \\\n+        library directory: L4RE_LIBDIR not set.\")?.into_string().unwrap();\n     let mut pre_link_args = LinkArgs::new();\n     pre_link_args.insert(LinkerFlavor::Ld, vec![\n-            \"-nostdlib\".to_string(),\n+        format!(\"-T{}/main_stat.ld\", l4re_lib_path),\n+        \"--defsym=__executable_start=0x01000000\".to_string(),\n+        \"--defsym=__L4_KIP_ADDR__=0x6ffff000\".to_string(),\n+        format!(\"{}/crt1.o\", l4re_lib_path),\n+        format!(\"{}/crti.o\", l4re_lib_path),\n+        get_path_or(\"crtbeginT.o\"),\n+    ]);\n+    let mut post_link_args = LinkArgs::new();\n+    post_link_args.insert(LinkerFlavor::Ld, vec![\n+        format!(\"{}/l4f/libpthread.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_sig.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_sig_noop.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_socket_noop.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_fs_noop.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_sem_noop.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libl4re-vfs.o.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4re.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4re-util.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_support_misc.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libsupc++.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4shmc.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4re-c.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4re-c-util.a\", l4re_lib_path),\n+        get_path_or(\"libgcc_eh.a\"),\n+        format!(\"{}/l4f/libdl.a\", l4re_lib_path),\n+        \"--start-group\".to_string(),\n+        format!(\"{}/l4f/libl4util.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_l4re.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libuc_c.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_l4refile.a\", l4re_lib_path),\n+        \"--end-group\".to_string(),\n+        format!(\"{}/l4f/libl4sys.a\", l4re_lib_path),\n+        \"-gc-sections\".to_string(),\n+        get_path_or(\"crtend.o\"),\n+        format!(\"{}/crtn.o\", l4re_lib_path),\n     ]);\n \n-    TargetOptions {\n+    Ok(TargetOptions {\n         executables: true,\n         has_elf_tls: false,\n-        exe_allocation_crate: Some(\"alloc_system\".to_string()),\n+        exe_allocation_crate: None,\n         panic_strategy: PanicStrategy::Abort,\n         linker: \"ld\".to_string(),\n-        pre_link_args: pre_link_args,\n+        pre_link_args,\n+        post_link_args,\n         target_family: Some(\"unix\".to_string()),\n         .. Default::default()\n-    }\n+    })\n }"}, {"sha": "51eeae50e22ee17ece637332c51d82d5115f3342", "filename": "src/librustc_back/target/le32_unknown_nacl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -25,8 +25,8 @@ pub fn target() -> TargetResult {\n         linker: \"pnacl-clang\".to_string(),\n         ar: \"pnacl-ar\".to_string(),\n \n-        pre_link_args: pre_link_args,\n-        post_link_args: post_link_args,\n+        pre_link_args,\n+        post_link_args,\n         dynamic_linking: false,\n         executables: true,\n         exe_suffix: \".pexe\".to_string(),"}, {"sha": "6e5e139715cccadef9f458f483354a94c3441997", "filename": "src/librustc_back/target/linux_musl_base.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -60,15 +60,10 @@ pub fn opts() -> TargetOptions {\n     base.pre_link_objects_exe.push(\"crti.o\".to_string());\n     base.post_link_objects.push(\"crtn.o\".to_string());\n \n-    // MUSL support doesn't currently include dynamic linking, so there's no\n-    // need for dylibs or rpath business. Additionally `-pie` is incompatible\n-    // with `-static`, so we can't pass `-pie`.\n-    base.dynamic_linking = false;\n-    base.has_rpath = false;\n-    base.position_independent_executables = false;\n-\n     // These targets statically link libc by default\n     base.crt_static_default = true;\n+    // These targets allow the user to choose between static and dynamic linking.\n+    base.crt_static_respected = true;\n \n     base\n }"}, {"sha": "130e1b695dbd5b7bbcdab87d5bb3edc6fab29588", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -416,8 +416,12 @@ pub struct TargetOptions {\n     /// ABIs are considered to be supported on all platforms and cannot be blacklisted.\n     pub abi_blacklist: Vec<Abi>,\n \n+    /// Whether or not linking dylibs to a static CRT is allowed.\n+    pub crt_static_allows_dylibs: bool,\n     /// Whether or not the CRT is statically linked by default.\n     pub crt_static_default: bool,\n+    /// Whether or not crt-static is respected by the compiler (or is a no-op).\n+    pub crt_static_respected: bool,\n \n     /// Whether or not stack probes (__rust_probestack) are enabled\n     pub stack_probes: bool,\n@@ -478,7 +482,9 @@ impl Default for TargetOptions {\n             max_atomic_width: None,\n             panic_strategy: PanicStrategy::Unwind,\n             abi_blacklist: vec![],\n+            crt_static_allows_dylibs: false,\n             crt_static_default: false,\n+            crt_static_respected: false,\n             stack_probes: false,\n         }\n     }\n@@ -714,7 +720,9 @@ impl Target {\n         key!(max_atomic_width, Option<u64>);\n         key!(min_atomic_width, Option<u64>);\n         try!(key!(panic_strategy, PanicStrategy));\n+        key!(crt_static_allows_dylibs, bool);\n         key!(crt_static_default, bool);\n+        key!(crt_static_respected, bool);\n         key!(stack_probes, bool);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n@@ -902,7 +910,9 @@ impl ToJson for Target {\n         target_option_val!(min_atomic_width);\n         target_option_val!(max_atomic_width);\n         target_option_val!(panic_strategy);\n+        target_option_val!(crt_static_allows_dylibs);\n         target_option_val!(crt_static_default);\n+        target_option_val!(crt_static_respected);\n         target_option_val!(stack_probes);\n \n         if default.abi_blacklist != self.options.abi_blacklist {"}, {"sha": "c7915d4de72fe6d37607045f82b8a2a6f33de49e", "filename": "src/librustc_back/target/redox_base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {LinkerFlavor, PanicStrategy};\n+use LinkerFlavor;\n use target::{LinkArgs, TargetOptions};\n use std::default::Default;\n \n@@ -37,7 +37,6 @@ pub fn opts() -> TargetOptions {\n         target_family: None,\n         linker_is_gnu: true,\n         has_elf_tls: true,\n-        panic_strategy: PanicStrategy::Abort,\n         .. Default::default()\n     }\n }"}, {"sha": "42ab19404049eee0cee5aa14aa19fe97f568ea40", "filename": "src/librustc_back/target/wasm32_experimental_emscripten.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -38,7 +38,7 @@ pub fn target() -> Result<Target, String> {\n         obj_is_bitcode: true,\n         is_like_emscripten: true,\n         max_atomic_width: Some(32),\n-        post_link_args: post_link_args,\n+        post_link_args,\n         target_family: Some(\"unix\".to_string()),\n         .. Default::default()\n     };"}, {"sha": "a0a2699d8f951c0fe1e4e99e1344d7796d517e6d", "filename": "src/librustc_back/target/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -34,7 +34,7 @@ pub fn target() -> Result<Target, String> {\n         obj_is_bitcode: true,\n         is_like_emscripten: true,\n         max_atomic_width: Some(32),\n-        post_link_args: post_link_args,\n+        post_link_args,\n         target_family: Some(\"unix\".to_string()),\n         .. Default::default()\n     };"}, {"sha": "e6aa745d54e9d8c8d625a164437c67e84730c792", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -78,7 +78,7 @@ pub fn opts() -> TargetOptions {\n         target_family: Some(\"windows\".to_string()),\n         is_like_windows: true,\n         allows_weak_linkage: false,\n-        pre_link_args: pre_link_args,\n+        pre_link_args,\n         pre_link_objects_exe: vec![\n             \"crt2.o\".to_string(),    // mingw C runtime initialization for executables\n             \"rsbegin.o\".to_string(), // Rust compiler runtime initialization, see rsbegin.rs\n@@ -87,7 +87,7 @@ pub fn opts() -> TargetOptions {\n             \"dllcrt2.o\".to_string(), // mingw C runtime initialization for dlls\n             \"rsbegin.o\".to_string(),\n         ],\n-        late_link_args: late_link_args,\n+        late_link_args,\n         post_link_objects: vec![\n             \"rsend.o\".to_string()\n         ],"}, {"sha": "42a4e6f5f11885e873f933603830d884dad74180", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -63,6 +63,8 @@ pub fn opts() -> TargetOptions {\n         is_like_windows: true,\n         is_like_msvc: true,\n         pre_link_args: args,\n+        crt_static_allows_dylibs: true,\n+        crt_static_respected: true,\n \n         .. Default::default()\n     }"}, {"sha": "99d3171e1c0e0f9dc1eef6f7d616dc9e5c28f77c", "filename": "src/librustc_back/target/x86_64_unknown_l4re_uclibc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -12,7 +12,7 @@ use LinkerFlavor;\n use target::{Target, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let mut base = super::l4re_base::opts();\n+    let mut base = super::l4re_base::opts()?;\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n "}, {"sha": "8ffaddd7c29f2634cfd44c6a5fbbdc503b2409e6", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -95,15 +95,6 @@ impl TempDir {\n         self.path.as_ref().unwrap()\n     }\n \n-    /// Close and remove the temporary directory\n-    ///\n-    /// Although `TempDir` removes the directory on drop, in the destructor\n-    /// any errors are ignored. To detect errors cleaning up the temporary\n-    /// directory, call `close` instead.\n-    pub fn close(mut self) -> io::Result<()> {\n-        self.cleanup_dir()\n-    }\n-\n     fn cleanup_dir(&mut self) -> io::Result<()> {\n         match self.path {\n             Some(ref p) => fs::remove_dir_all(p),"}, {"sha": "eb47144d1f995f5431ad9d366776afdcd4767175", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n \n-#![crate_name = \"rustc_bitflags\"]\n-#![crate_type = \"rlib\"]\n #![no_std]\n #![deny(warnings)]\n "}, {"sha": "25f02537490fa8d694a52ff0a366692622c54d45", "filename": "src/librustc_borrowck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -15,6 +15,5 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n graphviz = { path = \"../libgraphviz\" }\n rustc = { path = \"../librustc\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "4058f3198afb4f52e8430c63fa07abf037324338", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 26, "deletions": 41, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -29,6 +29,7 @@ use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::rc::Rc;\n \n@@ -194,10 +195,10 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let def_id = bccx.tcx.hir.body_owner_def_id(body.id());\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut clcx = CheckLoanCtxt {\n-        bccx: bccx,\n-        dfcx_loans: dfcx_loans,\n-        move_data: move_data,\n-        all_loans: all_loans,\n+        bccx,\n+        dfcx_loans,\n+        move_data,\n+        all_loans,\n         param_env,\n     };\n     euv::ExprUseVisitor::new(&mut clcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n@@ -465,10 +466,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0499,\n-                                                      \"cannot borrow `{}`{} as mutable \\\n-                                                      more than once at a time\",\n-                                                      nl, new_loan_msg);\n+                    let mut err = self.bccx.cannot_mutably_borrow_multiply(\n+                        new_loan.span, &nl, &new_loan_msg, Origin::Ast);\n \n                     if new_loan.span == old_loan.span {\n                         // Both borrows are happening in the same place\n@@ -496,10 +495,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (ty::UniqueImmBorrow, ty::UniqueImmBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0524,\n-                                     \"two closures require unique access to `{}` \\\n-                                      at the same time\",\n-                                     nl);\n+                    let mut err = self.bccx.cannot_uniquely_borrow_by_two_closures(\n+                        new_loan.span, &nl, Origin::Ast);\n                     err.span_label(\n                             old_loan.span,\n                             \"first closure is constructed here\");\n@@ -513,10 +510,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0500,\n-                                                   \"closure requires unique access to `{}` \\\n-                                                   but {} is already borrowed{}\",\n-                                                   nl, ol_pronoun, old_loan_msg);\n+                    let mut err = self.bccx.cannot_uniquely_borrow_by_one_closure(\n+                        new_loan.span, &nl, &ol_pronoun, &old_loan_msg, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"closure construction occurs here{}\", new_loan_msg));\n@@ -530,10 +525,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0501,\n-                                                   \"cannot borrow `{}`{} as {} because \\\n-                                                   previous closure requires unique access\",\n-                                                   nl, new_loan_msg, new_loan.kind.to_user_str());\n+                    let new_loan_str = &new_loan.kind.to_user_str();\n+                    let mut err = self.bccx.cannot_reborrow_already_uniquely_borrowed(\n+                        new_loan.span, &nl, &new_loan_msg, new_loan_str, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"borrow occurs here{}\", new_loan_msg));\n@@ -547,15 +541,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (..) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0502,\n-                                                   \"cannot borrow `{}`{} as {} because \\\n-                                                   {} is also borrowed as {}{}\",\n-                                                   nl,\n-                                                   new_loan_msg,\n-                                                   new_loan.kind.to_user_str(),\n-                                                   ol_pronoun,\n-                                                   old_loan.kind.to_user_str(),\n-                                                   old_loan_msg);\n+                    let mut err = self.bccx.cannot_reborrow_already_borrowed(\n+                        new_loan.span,\n+                        &nl, &new_loan_msg, &new_loan.kind.to_user_str(),\n+                        &ol_pronoun, &old_loan.kind.to_user_str(), &old_loan_msg, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"{} borrow occurs here{}\",\n@@ -645,9 +634,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                struct_span_err!(self.bccx, span, E0503,\n-                                 \"cannot use `{}` because it was mutably borrowed\",\n-                                 &self.bccx.loan_path_to_string(copy_path))\n+                let desc = self.bccx.loan_path_to_string(copy_path);\n+                self.bccx.cannot_use_when_mutably_borrowed(span, &desc, Origin::Ast)\n                     .span_label(loan_span,\n                                format!(\"borrow of `{}` occurs here\",\n                                        &self.bccx.loan_path_to_string(&loan_path))\n@@ -673,9 +661,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             UseWhileBorrowed(loan_path, loan_span) => {\n                 let mut err = match move_kind {\n                     move_data::Captured => {\n-                        let mut err = struct_span_err!(self.bccx, span, E0504,\n-                                         \"cannot move `{}` into closure because it is borrowed\",\n-                                         &self.bccx.loan_path_to_string(move_path));\n+                        let mut err = self.bccx.cannot_move_into_closure(\n+                            span, &self.bccx.loan_path_to_string(move_path), Origin::Ast);\n                         err.span_label(\n                             loan_span,\n                             format!(\"borrow of `{}` occurs here\",\n@@ -690,9 +677,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat => {\n-                        let mut err = struct_span_err!(self.bccx, span, E0505,\n-                                         \"cannot move out of `{}` because it is borrowed\",\n-                                         &self.bccx.loan_path_to_string(move_path));\n+                        let desc = self.bccx.loan_path_to_string(move_path);\n+                        let mut err = self.bccx.cannot_move_when_borrowed(span, &desc, Origin::Ast);\n                         err.span_label(\n                             loan_span,\n                             format!(\"borrow of `{}` occurs here\",\n@@ -874,9 +860,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    loan_path: &LoanPath<'tcx>,\n                                    loan: &Loan) {\n-        struct_span_err!(self.bccx, span, E0506,\n-                         \"cannot assign to `{}` because it is borrowed\",\n-                         self.bccx.loan_path_to_string(loan_path))\n+        self.bccx.cannot_assign_to_borrowed(\n+            span, &self.bccx.loan_path_to_string(loan_path), Origin::Ast)\n             .span_label(loan.span,\n                        format!(\"borrow of `{}` occurs here\",\n                                self.bccx.loan_path_to_string(loan_path)))"}, {"sha": "7878762788905e4d055fe1f212fdefda3fde5a85", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 4, "deletions": 47, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -68,19 +68,7 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n                     });\n             PatternSource::MatchExpr(e)\n         }\n-        NodeStmt(ref s) => {\n-            // the enclosing statement must be a `let` or something else\n-            match s.node {\n-                StmtDecl(ref decl, _) => {\n-                    match decl.node {\n-                        DeclLocal(ref local) => PatternSource::LetDecl(local),\n-                        _ => return PatternSource::Other,\n-                    }\n-                }\n-                _ => return PatternSource::Other,\n-            }\n-        }\n-\n+        NodeLocal(local) => PatternSource::LetDecl(local),\n         _ => return PatternSource::Other,\n \n     }\n@@ -106,44 +94,13 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n     let move_info = GatherMoveInfo {\n         id: move_expr_id,\n-        kind: kind,\n-        cmt: cmt,\n+        kind,\n+        cmt,\n         span_path_opt: None,\n     };\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      move_data: &MoveData<'tcx>,\n-                                      _move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                      move_pat: &hir::Pat,\n-                                      cmt: mc::cmt<'tcx>,\n-                                      mode: euv::MatchMode) {\n-    let tcx = bccx.tcx;\n-    debug!(\"gather_match_variant(move_pat={}, cmt={:?}, mode={:?})\",\n-           move_pat.id, cmt, mode);\n-\n-    let opt_lp = opt_loan_path(&cmt);\n-    match opt_lp {\n-        Some(lp) => {\n-            match lp.kind {\n-                LpDowncast(ref base_lp, _) =>\n-                    move_data.add_variant_match(\n-                        tcx, lp.clone(), move_pat.id, base_lp.clone(), mode),\n-                _ => bug!(\"should only call gather_match_variant \\\n-                           for cat_downcast cmt\"),\n-            }\n-        }\n-        None => {\n-            // We get None when input to match is non-path (e.g.\n-            // temporary result like a function call). Since no\n-            // loan-path is being matched, no need to record a\n-            // downcast.\n-            return;\n-        }\n-    }\n-}\n-\n pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_data: &MoveData<'tcx>,\n                                       move_error_collector: &mut MoveErrorCollector<'tcx>,\n@@ -163,7 +120,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let move_info = GatherMoveInfo {\n         id: move_pat.id,\n         kind: MovePat,\n-        cmt: cmt,\n+        cmt,\n         span_path_opt: pat_span_path_opt,\n     };\n "}, {"sha": "22de3c759139d8bf3aac6e9c32cb553e445574f9", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -37,10 +37,10 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"guarantee_lifetime(cmt={:?}, loan_region={:?})\",\n            cmt, loan_region);\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n-                                         item_scope: item_scope,\n-                                         span: span,\n-                                         cause: cause,\n-                                         loan_region: loan_region,\n+                                         item_scope,\n+                                         span,\n+                                         cause,\n+                                         loan_region,\n                                          cmt_original: cmt.clone()};\n     ctxt.check(&cmt, None)\n }"}, {"sha": "00ebf5de44af8ad74b2b88e397ce0a2a8679b00b", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -41,7 +41,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let def_id = bccx.tcx.hir.body_owner_def_id(body);\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut glcx = GatherLoanCtxt {\n-        bccx: bccx,\n+        bccx,\n         all_loans: Vec::new(),\n         item_ub: region::CodeExtent::Misc(body.node_id),\n         move_data: MoveData::new(),\n@@ -94,12 +94,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                matched_pat,\n                cmt,\n                mode);\n-\n-        if let Categorization::Downcast(..) = cmt.cat {\n-            gather_moves::gather_match_variant(\n-                self.bccx, &self.move_data, &mut self.move_error_collector,\n-                matched_pat, cmt, mode);\n-        }\n     }\n \n     fn consume_pat(&mut self,\n@@ -230,8 +224,8 @@ fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             // Only mutable data can be lent as mutable.\n             if !cmt.mutbl.is_mutable() {\n                 Err(bccx.report(BckError { span: borrow_span,\n-                                           cause: cause,\n-                                           cmt: cmt,\n+                                           cause,\n+                                           cmt,\n                                            code: err_mutbl }))\n             } else {\n                 Ok(())\n@@ -389,13 +383,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n                 Loan {\n                     index: self.all_loans.len(),\n-                    loan_path: loan_path,\n+                    loan_path,\n                     kind: req_kind,\n-                    gen_scope: gen_scope,\n-                    kill_scope: kill_scope,\n+                    gen_scope,\n+                    kill_scope,\n                     span: borrow_span,\n-                    restricted_paths: restricted_paths,\n-                    cause: cause,\n+                    restricted_paths,\n+                    cause,\n                 }\n             }\n         };\n@@ -423,13 +417,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             //    let all_loans = &mut *self.all_loans; // FIXME(#5074)\n             //    Loan {\n             //        index: all_loans.len(),\n-            //        loan_path: loan_path,\n-            //        cmt: cmt,\n+            //        loan_path,\n+            //        cmt,\n             //        mutbl: ConstMutability,\n             //        gen_scope: borrow_id,\n-            //        kill_scope: kill_scope,\n+            //        kill_scope,\n             //        span: borrow_span,\n-            //        restrictions: restrictions\n+            //        restrictions,\n             //    }\n         // }\n     }"}, {"sha": "57b92eb8f8891aa0b39e126935b71d92fda1de93", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -49,8 +49,8 @@ impl<'tcx> MoveError<'tcx> {\n                           move_to: Option<MovePlace<'tcx>>)\n                           -> MoveError<'tcx> {\n         MoveError {\n-            move_from: move_from,\n-            move_to: move_to,\n+            move_from,\n+            move_to,\n         }\n     }\n }\n@@ -153,20 +153,19 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         }\n \n         Categorization::Interior(ref b, mc::InteriorElement(ik)) => {\n-            match (&b.ty.sty, ik) {\n-                (&ty::TySlice(..), _) |\n-                (_, Kind::Index) => {\n-                    let mut err = struct_span_err!(bccx, move_from.span, E0508,\n-                                                   \"cannot move out of type `{}`, \\\n-                                                    a non-copy array\",\n-                                                   b.ty);\n-                    err.span_label(move_from.span, \"cannot move out of here\");\n-                    err\n-                }\n-                (_, Kind::Pattern) => {\n+            let type_name = match (&b.ty.sty, ik) {\n+                (&ty::TyArray(_, _), Kind::Index) => \"array\",\n+                (&ty::TySlice(_), _) => \"slice\",\n+                _ => {\n                     span_bug!(move_from.span, \"this path should not cause illegal move\");\n-                }\n-            }\n+                },\n+            };\n+            let mut err = struct_span_err!(bccx, move_from.span, E0508,\n+                                           \"cannot move out of type `{}`, \\\n+                                            a non-copy {}\",\n+                                           b.ty, type_name);\n+            err.span_label(move_from.span, \"cannot move out of here\");\n+            err\n         }\n \n         Categorization::Downcast(ref b, _) |"}, {"sha": "bc01f22d3881ec6690c63732a5fc26365c63e8c2", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -34,10 +34,10 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       loan_region: ty::Region<'tcx>)\n                                       -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n-        bccx: bccx,\n-        span: span,\n-        cause: cause,\n-        loan_region: loan_region,\n+        bccx,\n+        span,\n+        cause,\n+        loan_region,\n     };\n \n     ctxt.restrict(cmt)"}, {"sha": "38336655f217af46383ffbff0a26472f961cf9e3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -37,6 +37,8 @@ use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n \n+use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n+\n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n@@ -180,7 +182,7 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n                                                       id_range,\n                                                       body);\n \n-    Some(AnalysisData { all_loans: all_loans,\n+    Some(AnalysisData { all_loans,\n                         loans: loan_dfcx,\n                         move_data:flowed_moves })\n }\n@@ -218,6 +220,25 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     owner_def_id: DefId,\n }\n \n+impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n+    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                         sp: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a>\n+    {\n+        self.tcx.sess.struct_span_err_with_code(sp, msg, code)\n+    }\n+\n+    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                               sp: S,\n+                                               msg: &str)\n+                                               -> DiagnosticBuilder<'a>\n+    {\n+        self.tcx.sess.struct_span_err(sp, msg)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n@@ -549,14 +570,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             move_data::Declared => {\n                 // If this is an uninitialized variable, just emit a simple warning\n                 // and return.\n-                struct_span_err!(\n-                    self.tcx.sess, use_span, E0381,\n-                    \"{} of possibly uninitialized variable: `{}`\",\n-                    verb,\n-                    self.loan_path_to_string(lp))\n-                .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n-                    self.loan_path_to_string(lp)))\n-                .emit();\n+                self.cannot_act_on_uninitialized_variable(use_span,\n+                                                          verb,\n+                                                          &self.loan_path_to_string(lp),\n+                                                          Origin::Ast)\n+                    .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n+                                                  self.loan_path_to_string(lp)))\n+                    .emit();\n                 return;\n             }\n             _ => {\n@@ -683,10 +703,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                 lp: &LoanPath<'tcx>,\n                                                 assign:\n                                                 &move_data::Assignment) {\n-        let mut err = struct_span_err!(\n-            self.tcx.sess, span, E0384,\n-            \"re-assignment of immutable variable `{}`\",\n-            self.loan_path_to_string(lp));\n+        let mut err = self.cannot_reassign_immutable(span,\n+                                                     &self.loan_path_to_string(lp),\n+                                                     Origin::Ast);\n         err.span_label(span, \"re-assignment of immutable variable\");\n         if span != assign.span {\n             err.span_label(assign.span, format!(\"first assignment to `{}`\",\n@@ -695,15 +714,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    pub fn span_err(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_err(s, m);\n-    }\n-\n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self, s: S, m: &str)\n-                                              -> DiagnosticBuilder<'a> {\n-        self.tcx.sess.struct_span_err(s, m)\n-    }\n-\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n                                                          s: S,\n                                                          msg: &str,\n@@ -712,10 +722,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.struct_span_err_with_code(s, msg, code)\n     }\n \n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, s: S, msg: &str, code: &str) {\n-        self.tcx.sess.span_err_with_code(s, msg, code);\n-    }\n-\n     fn bckerr_to_diag(&self, err: &BckError<'tcx>) -> DiagnosticBuilder<'a> {\n         let span = err.span.clone();\n \n@@ -897,7 +903,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n         let pat = match self.tcx.hir.get(node_id) {\n-            hir_map::Node::NodeLocal(pat) => pat,\n+            hir_map::Node::NodeBinding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n "}, {"sha": "217bd6e6ca1ca5294de0d21a7f1b16be99caaf02", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 9, "deletions": 54, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -53,10 +53,6 @@ pub struct MoveData<'tcx> {\n     /// kill move bits.\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n-    /// Enum variant matched within a pattern on some match arm, like\n-    /// `SomeStruct{ f: Variant1(x, y) } => ...`\n-    pub variant_matches: RefCell<Vec<VariantMatch>>,\n-\n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n     pub assignee_ids: RefCell<NodeSet>,\n }\n@@ -161,21 +157,6 @@ pub struct Assignment {\n     pub assignee_id: ast::NodeId,\n }\n \n-#[derive(Copy, Clone)]\n-pub struct VariantMatch {\n-    /// downcast to the variant.\n-    pub path: MovePathIndex,\n-\n-    /// path being downcast to the variant.\n-    pub base_path: MovePathIndex,\n-\n-    /// id where variant's pattern occurs\n-    pub id: ast::NodeId,\n-\n-    /// says if variant established by move (and why), by copy, or by borrow.\n-    pub mode: euv::MatchMode\n-}\n-\n #[derive(Clone, Copy)]\n pub struct MoveDataFlowOperator;\n \n@@ -215,7 +196,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),\n-            variant_matches: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(NodeSet()),\n         }\n     }\n@@ -310,7 +290,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                     parent: parent_index,\n                     first_move: InvalidMoveIndex,\n                     first_child: InvalidMovePathIndex,\n-                    next_sibling: next_sibling,\n+                    next_sibling,\n                 });\n \n                 index\n@@ -408,9 +388,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n         self.moves.borrow_mut().push(Move {\n             path: path_index,\n-            id: id,\n-            kind: kind,\n-            next_move: next_move\n+            id,\n+            kind,\n+            next_move,\n         });\n     }\n \n@@ -468,8 +448,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let assignment = Assignment {\n             path: path_index,\n             id: assign_id,\n-            span: span,\n-            assignee_id: assignee_id,\n+            span,\n+            assignee_id,\n         };\n \n         if self.is_var_path(path_index) {\n@@ -485,31 +465,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         }\n     }\n \n-    /// Adds a new record for a match of `base_lp`, downcast to\n-    /// variant `lp`, that occurs at location `pattern_id`.  (One\n-    /// should be able to recover the span info from the\n-    /// `pattern_id` and the hir_map, I think.)\n-    pub fn add_variant_match(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             lp: Rc<LoanPath<'tcx>>,\n-                             pattern_id: ast::NodeId,\n-                             base_lp: Rc<LoanPath<'tcx>>,\n-                             mode: euv::MatchMode) {\n-        debug!(\"add_variant_match(lp={:?}, pattern_id={})\",\n-               lp, pattern_id);\n-\n-        let path_index = self.move_path(tcx, lp.clone());\n-        let base_path_index = self.move_path(tcx, base_lp.clone());\n-\n-        let variant_match = VariantMatch {\n-            path: path_index,\n-            base_path: base_path_index,\n-            id: pattern_id,\n-            mode: mode,\n-        };\n-\n-        self.variant_matches.borrow_mut().push(variant_match);\n-    }\n-\n     /// Adds the gen/kills for the various moves and\n     /// assignments into the provided data flow contexts.\n     /// Moves are generated by moves and killed by assignments and\n@@ -680,9 +635,9 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         dfcx_assign.propagate(cfg, body);\n \n         FlowedMoveData {\n-            move_data: move_data,\n-            dfcx_moves: dfcx_moves,\n-            dfcx_assign: dfcx_assign,\n+            move_data,\n+            dfcx_moves,\n+            dfcx_assign,\n         }\n     }\n "}, {"sha": "1f1fc4cc65fbe8e3f3bdf04e9d8e0c9660c9d466", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 550, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -63,27 +63,6 @@ Now that the closure has its own copy of the data, there's no need to worry\n about safety.\n \"##,\n \n-E0381: r##\"\n-It is not allowed to use or capture an uninitialized variable. For example:\n-\n-```compile_fail,E0381\n-fn main() {\n-    let x: i32;\n-    let y = x; // error, use of possibly uninitialized variable\n-}\n-```\n-\n-To fix this, ensure that any declared variables are initialized before being\n-used. Example:\n-\n-```\n-fn main() {\n-    let x: i32 = 0;\n-    let y = x; // ok!\n-}\n-```\n-\"##,\n-\n E0382: r##\"\n This error occurs when an attempt is made to use a variable after its contents\n have been moved elsewhere. For example:\n@@ -182,28 +161,6 @@ x = Foo { a: 2 };\n ```\n \"##,\n \n-E0384: r##\"\n-This error occurs when an attempt is made to reassign an immutable variable.\n-For example:\n-\n-```compile_fail,E0384\n-fn main() {\n-    let x = 3;\n-    x = 5; // error, reassignment of immutable variable\n-}\n-```\n-\n-By default, variables in Rust are immutable. To fix this error, add the keyword\n-`mut` after the keyword `let` when declaring the variable. For example:\n-\n-```\n-fn main() {\n-    let mut x = 3;\n-    x = 5;\n-}\n-```\n-\"##,\n-\n /*E0386: r##\"\n This error occurs when an attempt is made to mutate the target of a mutable\n reference stored inside an immutable container.\n@@ -360,512 +317,6 @@ fn main() {\n ```\n \"##,\n \n-E0499: r##\"\n-A variable was borrowed as mutable more than once. Erroneous code example:\n-\n-```compile_fail,E0499\n-let mut i = 0;\n-let mut x = &mut i;\n-let mut a = &mut i;\n-// error: cannot borrow `i` as mutable more than once at a time\n-```\n-\n-Please note that in rust, you can either have many immutable references, or one\n-mutable reference. Take a look at\n-https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-for more information. Example:\n-\n-\n-```\n-let mut i = 0;\n-let mut x = &mut i; // ok!\n-\n-// or:\n-let mut i = 0;\n-let a = &i; // ok!\n-let b = &i; // still ok!\n-let c = &i; // still ok!\n-```\n-\"##,\n-\n-E0500: r##\"\n-A borrowed variable was used in another closure. Example of erroneous code:\n-\n-```compile_fail\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let nights_watch = || {\n-        *jon_snow = 2;\n-    };\n-    let starks = || {\n-        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n-                       //        but it is already borrowed\n-    };\n-}\n-```\n-\n-In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it\n-cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n-you can put the closure in its own scope:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    {\n-        let nights_watch = || {\n-            *jon_snow = 2;\n-        };\n-    } // At this point, `jon_snow` is free.\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-}\n-```\n-\n-Or, if the type implements the `Clone` trait, you can clone it between\n-closures:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let mut jon_copy = jon_snow.clone();\n-    let nights_watch = || {\n-        jon_copy = 2;\n-    };\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-}\n-```\n-\"##,\n-\n-E0501: r##\"\n-This error indicates that a mutable variable is being used while it is still\n-captured by a closure. Because the closure has borrowed the variable, it is not\n-available for use until the closure goes out of scope.\n-\n-Note that a capture will either move or borrow a variable, but in this\n-situation, the closure is borrowing the variable. Take a look at\n-http://rustbyexample.com/fn/closures/capture.html for more information about\n-capturing.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0501\n-fn inside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn outside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn foo(a: &mut i32) {\n-    let bar = || {\n-        inside_closure(a)\n-    };\n-    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n-                        //        closure requires unique access.\n-}\n-```\n-\n-To fix this error, you can place the closure in its own scope:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    {\n-        let bar = || {\n-            inside_closure(a)\n-        };\n-    } // borrow on `a` ends.\n-    outside_closure(a); // ok!\n-}\n-```\n-\n-Or you can pass the variable as a parameter to the closure:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    let bar = |s: &mut i32| {\n-        inside_closure(s)\n-    };\n-    outside_closure(a);\n-    bar(a);\n-}\n-```\n-\n-It may be possible to define the closure later:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    outside_closure(a);\n-    let bar = || {\n-        inside_closure(a)\n-    };\n-}\n-```\n-\"##,\n-\n-E0502: r##\"\n-This error indicates that you are trying to borrow a variable as mutable when it\n-has already been borrowed as immutable.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0502\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    let ref y = a; // a is borrowed as immutable.\n-    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n-            //        as immutable\n-}\n-```\n-\n-To fix this error, ensure that you don't have any other references to the\n-variable before trying to access it mutably:\n-\n-```\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    bar(a);\n-    let ref y = a; // ok!\n-}\n-```\n-\n-For more information on the rust ownership system, take a look at\n-https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html.\n-\"##,\n-\n-E0503: r##\"\n-A value was used after it was mutably borrowed.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0503\n-fn main() {\n-    let mut value = 3;\n-    // Create a mutable borrow of `value`. This borrow\n-    // lives until the end of this function.\n-    let _borrow = &mut value;\n-    let _sum = value + 1; // error: cannot use `value` because\n-                          //        it was mutably borrowed\n-}\n-```\n-\n-In this example, `value` is mutably borrowed by `borrow` and cannot be\n-used to calculate `sum`. This is not possible because this would violate\n-Rust's mutability rules.\n-\n-You can fix this error by limiting the scope of the borrow:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    // By creating a new block, you can limit the scope\n-    // of the reference.\n-    {\n-        let _borrow = &mut value; // Use `_borrow` inside this block.\n-    }\n-    // The block has ended and with it the borrow.\n-    // You can now use `value` again.\n-    let _sum = value + 1;\n-}\n-```\n-\n-Or by cloning `value` before borrowing it:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    // We clone `value`, creating a copy.\n-    let value_cloned = value.clone();\n-    // The mutable borrow is a reference to `value` and\n-    // not to `value_cloned`...\n-    let _borrow = &mut value;\n-    // ... which means we can still use `value_cloned`,\n-    let _sum = value_cloned + 1;\n-    // even though the borrow only ends here.\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-\"##,\n-\n-E0504: r##\"\n-This error occurs when an attempt is made to move a borrowed variable into a\n-closure.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0504\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        println!(\"child function: {}\", fancy_num.num);\n-        // error: cannot move `fancy_num` into closure because it is borrowed\n-    };\n-\n-    x();\n-    println!(\"main function: {}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n-the closure `x`. There is no way to move a value into a closure while it is\n-borrowed, as that would invalidate the borrow.\n-\n-If the closure can't outlive the value being moved, try using a reference\n-rather than moving:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        // fancy_ref is usable here because it doesn't move `fancy_num`\n-        println!(\"child function: {}\", fancy_ref.num);\n-    };\n-\n-    x();\n-\n-    println!(\"main function: {}\", fancy_num.num);\n-}\n-```\n-\n-If the value has to be borrowed and then moved, try limiting the lifetime of\n-the borrow using a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"main function: {}\", fancy_ref.num);\n-        // `fancy_ref` goes out of scope here\n-    }\n-\n-    let x = move || {\n-        // `fancy_num` can be moved now (no more references exist)\n-        println!(\"child function: {}\", fancy_num.num);\n-    };\n-\n-    x();\n-}\n-```\n-\n-If the lifetime of a reference isn't enough, such as in the case of threading,\n-consider using an `Arc` to create a reference-counted value:\n-\n-```\n-use std::sync::Arc;\n-use std::thread;\n-\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n-    let fancy_ref2 = fancy_ref1.clone();\n-\n-    let x = thread::spawn(move || {\n-        // `fancy_ref1` can be moved and has a `'static` lifetime\n-        println!(\"child thread: {}\", fancy_ref1.num);\n-    });\n-\n-    x.join().expect(\"child thread should finish\");\n-    println!(\"main thread: {}\", fancy_ref2.num);\n-}\n-```\n-\"##,\n-\n-E0505: r##\"\n-A value was moved out while it was still borrowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0505\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(x);\n-    }\n-}\n-```\n-\n-Here, the function `eat` takes the ownership of `x`. However,\n-`x` cannot be moved because it was borrowed to `_ref_to_val`.\n-To fix that you can do few different things:\n-\n-* Try to avoid moving the variable.\n-* Release borrow before move.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-struct Value {}\n-\n-fn eat(val: &Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(&x); // pass by reference, if it's possible\n-    }\n-}\n-```\n-\n-Or:\n-\n-```\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-    }\n-    eat(x); // release borrow and then move it.\n-}\n-```\n-\n-Or:\n-\n-```\n-#[derive(Clone, Copy)] // implement Copy trait\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(x); // it will be copied here.\n-    }\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-\"##,\n-\n-E0506: r##\"\n-This error occurs when an attempt is made to assign to a borrowed value.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0506\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-    // error: cannot assign to `fancy_num` because it is borrowed\n-\n-    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n-}\n-```\n-\n-Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n-be assigned to a new value as it would invalidate the reference.\n-\n-Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let moved_num = fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-\n-    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n-}\n-```\n-\n-If the value has to be borrowed, try limiting the lifetime of the borrow using\n-a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"Ref: {}\", fancy_ref.num);\n-    }\n-\n-    // Works because `fancy_ref` is no longer in scope\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-```\n-\n-Or by moving the reference into a function:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    print_fancy_ref(&fancy_num);\n-\n-    // Works because function borrow has ended\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-\n-fn print_fancy_ref(fancy_ref: &FancyNum){\n-    println!(\"Ref: {}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n E0507: r##\"\n You tried to move out of a value which was borrowed. Erroneous code example:\n \n@@ -1205,7 +656,6 @@ x.x = Some(&y);\n \n register_diagnostics! {\n //    E0385, // {} in an aliasable location\n-    E0524, // two closures require unique access to `..` at the same time\n     E0594, // cannot assign to {}\n     E0598, // lifetime of {} is too short to guarantee its contents can be...\n }"}, {"sha": "9bedbfed5db6d3039b3e3a61dfe926042cb28521", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_name = \"rustc_borrowck\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -31,17 +28,14 @@ extern crate rustc_errors as errors;\n extern crate graphviz as dot;\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_data_structures;\n extern crate rustc_mir;\n-extern crate core; // for NonZero\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n-pub use borrowck::{AnalysisData, BorrowckCtxt};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod borrowck;\n "}, {"sha": "bc9aa9665c103520c7d378073522d4de37aa4abf", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -166,8 +166,8 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         let pattern_arena = TypedArena::new();\n \n         f(MatchCheckCtxt {\n-            tcx: tcx,\n-            module: module,\n+            tcx,\n+            module,\n             pattern_arena: &pattern_arena,\n             byte_array_map: FxHashMap(),\n         })\n@@ -296,7 +296,7 @@ impl<'tcx> Witness<'tcx> {\n         let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n         self.0.extend(sub_pattern_tys.into_iter().map(|ty| {\n             Pattern {\n-                ty: ty,\n+                ty,\n                 span: DUMMY_SP,\n                 kind: box PatternKind::Wild,\n             }\n@@ -344,7 +344,7 @@ impl<'tcx> Witness<'tcx> {\n                         if adt.variants.len() > 1 {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n-                                substs: substs,\n+                                substs,\n                                 variant_index: ctor.variant_index_for_adt(adt),\n                                 subpatterns: pats\n                             }\n@@ -378,7 +378,7 @@ impl<'tcx> Witness<'tcx> {\n         };\n \n         self.0.push(Pattern {\n-            ty: ty,\n+            ty,\n             span: DUMMY_SP,\n             kind: Box::new(pat),\n         });\n@@ -673,7 +673,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n         Pattern {\n-            ty: ty,\n+            ty,\n             span: DUMMY_SP,\n             kind: box PatternKind::Wild,\n         }"}, {"sha": "2bed1950afc28000f1fae466f5a7ce7ab452b278", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -524,7 +524,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n     let mut checker = MutationChecker {\n-        cx: cx,\n+        cx,\n     };\n     ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_maps, cx.tables)\n         .walk_expr(guard);"}, {"sha": "c7def0b834cfd4f32674c0b2c49c576f2ce93272", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -379,7 +379,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             tcx,\n             param_env: cx.param_env,\n             tables: tcx.typeck_tables_of(def_id),\n-            substs: substs,\n+            substs,\n             fn_args: Some(call_args)\n           };\n           callee_cx.eval(&body.value)?"}, {"sha": "9fedee80d46a8e748804199cc2b621075ed8b787", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,9 +14,6 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![crate_name = \"rustc_const_eval\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -41,7 +38,7 @@ extern crate syntax_pos;\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod eval;\n mod _match;"}, {"sha": "ba79f775ef73d50c0576db3bf179ab7d885152d1", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -407,8 +407,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n \n                 PatternKind::Binding {\n-                    mutability: mutability,\n-                    mode: mode,\n+                    mutability,\n+                    mode,\n                     name: ident.node,\n                     var: id,\n                     ty: var_ty,\n@@ -470,7 +470,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n         Pattern {\n             span: pat.span,\n-            ty: ty,\n+            ty,\n             kind: Box::new(kind),\n         }\n     }\n@@ -569,10 +569,10 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n                     };\n                     PatternKind::Variant {\n-                        adt_def: adt_def,\n-                        substs: substs,\n+                        adt_def,\n+                        substs,\n                         variant_index: adt_def.variant_index_with_id(variant_id),\n-                        subpatterns: subpatterns,\n+                        subpatterns,\n                     }\n                 } else {\n                     PatternKind::Leaf { subpatterns: subpatterns }\n@@ -626,8 +626,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         };\n \n         Pattern {\n-            span: span,\n-            ty: ty,\n+            span,\n+            ty,\n             kind: Box::new(kind),\n         }\n     }\n@@ -762,7 +762,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         };\n \n         Pattern {\n-            span: span,\n+            span,\n             ty: pat_ty,\n             kind: Box::new(kind),\n         }"}, {"sha": "b67048939e43eb1592bc6c378aeeb02634b207a2", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -37,13 +37,6 @@ impl ConstFloat {\n         self.ty.ty_to_string()\n     }\n \n-    pub fn is_nan(&self) -> bool {\n-        match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).is_nan(),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).is_nan(),\n-        }\n-    }\n-\n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n         match (self.ty, rhs.ty) {"}, {"sha": "93b70ef8e4a5856a1e13a3f1529bd003373bae56", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,9 +14,6 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![crate_name = \"rustc_const_math\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]"}, {"sha": "52306de74cb8babac54713eacc81b271d7ea7b33", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,7 +13,7 @@\n //! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n //! used to store the values on the heap.\n //!\n-//! The N above is determined by Array's implementor, by way of an associatated constant.\n+//! The N above is determined by Array's implementor, by way of an associated constant.\n \n use std::ops::{Deref, DerefMut};\n use std::iter::{self, IntoIterator, FromIterator};"}, {"sha": "1e67461e0556dd7af0c22212832cb8296b01eba4", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -281,8 +281,8 @@ impl<A: Array> IntoIterator for ArrayVec<A> {\n         let indices = 0..self.count;\n         mem::forget(self);\n         Iter {\n-            indices: indices,\n-            store: store,\n+            indices,\n+            store,\n         }\n     }\n }"}, {"sha": "7331016c2d26c17f83b3f09f662c748395f68f10", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -151,7 +151,7 @@ impl BitMatrix {\n         // element. Round up to an even number of u64s.\n         let u64s_per_row = u64s(columns);\n         BitMatrix {\n-            columns: columns,\n+            columns,\n             vector: vec![0; rows * u64s_per_row],\n         }\n     }"}, {"sha": "6b8bf8df0d33f0832e24aeefc673c946c1276982", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -24,7 +24,7 @@ use std::mem;\n use std::slice;\n \n #[repr(C)]\n-pub struct Blake2bCtx {\n+struct Blake2bCtx {\n     b: [u8; 128],\n     h: [u64; 8],\n     t: [u64; 2],"}, {"sha": "90670517f5967e5b9d3d0e27a94b1c65e49e1c5f", "filename": "src/librustc_data_structures/control_flow_graph/dominators/mod.rs", "status": "modified", "additions": 4, "deletions": 79, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -71,8 +71,8 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(graph: &G,\n     }\n \n     Dominators {\n-        post_order_rank: post_order_rank,\n-        immediate_dominators: immediate_dominators,\n+        post_order_rank,\n+        immediate_dominators,\n     }\n }\n \n@@ -134,56 +134,10 @@ impl<Node: Idx> Dominators<Node> {\n         self.dominators(node).any(|n| n == dom)\n     }\n \n-    pub fn mutual_dominator_node(&self, node1: Node, node2: Node) -> Node {\n-        assert!(self.is_reachable(node1),\n-                \"node {:?} is not reachable\",\n-                node1);\n-        assert!(self.is_reachable(node2),\n-                \"node {:?} is not reachable\",\n-                node2);\n-        intersect::<Node>(&self.post_order_rank,\n-                          &self.immediate_dominators,\n-                          node1,\n-                          node2)\n-    }\n-\n-    pub fn mutual_dominator<I>(&self, iter: I) -> Option<Node>\n-        where I: IntoIterator<Item = Node>\n-    {\n-        let mut iter = iter.into_iter();\n-        iter.next()\n-            .map(|dom| iter.fold(dom, |dom, node| self.mutual_dominator_node(dom, node)))\n-    }\n-\n-    pub fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n+    #[cfg(test)]\n+    fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n         &self.immediate_dominators\n     }\n-\n-    pub fn dominator_tree(&self) -> DominatorTree<Node> {\n-        let elem: Vec<Node> = Vec::new();\n-        let mut children: IndexVec<Node, Vec<Node>> =\n-            IndexVec::from_elem_n(elem, self.immediate_dominators.len());\n-        let mut root = None;\n-        for (index, immed_dom) in self.immediate_dominators.iter().enumerate() {\n-            let node = Node::new(index);\n-            match *immed_dom {\n-                None => {\n-                    // node not reachable\n-                }\n-                Some(immed_dom) => {\n-                    if node == immed_dom {\n-                        root = Some(node);\n-                    } else {\n-                        children[immed_dom].push(node);\n-                    }\n-                }\n-            }\n-        }\n-        DominatorTree {\n-            root: root.unwrap(),\n-            children: children,\n-        }\n-    }\n }\n \n pub struct Iter<'dom, Node: Idx + 'dom> {\n@@ -215,38 +169,9 @@ pub struct DominatorTree<N: Idx> {\n }\n \n impl<Node: Idx> DominatorTree<Node> {\n-    pub fn root(&self) -> Node {\n-        self.root\n-    }\n-\n     pub fn children(&self, node: Node) -> &[Node] {\n         &self.children[node]\n     }\n-\n-    pub fn iter_children_of(&self, node: Node) -> IterChildrenOf<Node> {\n-        IterChildrenOf {\n-            tree: self,\n-            stack: vec![node],\n-        }\n-    }\n-}\n-\n-pub struct IterChildrenOf<'iter, Node: Idx + 'iter> {\n-    tree: &'iter DominatorTree<Node>,\n-    stack: Vec<Node>,\n-}\n-\n-impl<'iter, Node: Idx> Iterator for IterChildrenOf<'iter, Node> {\n-    type Item = Node;\n-\n-    fn next(&mut self) -> Option<Node> {\n-        if let Some(node) = self.stack.pop() {\n-            self.stack.extend(self.tree.children(node));\n-            Some(node)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n impl<Node: Idx> fmt::Debug for DominatorTree<Node> {"}, {"sha": "2d70b4063426d6f983707cc6e2a4cc092b5f7888", "filename": "src/librustc_data_structures/control_flow_graph/iterate/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -47,22 +47,6 @@ fn post_order_walk<G: ControlFlowGraph>(graph: &G,\n     result.push(node);\n }\n \n-pub fn pre_order_walk<G: ControlFlowGraph>(graph: &G,\n-                                           node: G::Node,\n-                                           result: &mut Vec<G::Node>,\n-                                           visited: &mut IndexVec<G::Node, bool>) {\n-    if visited[node] {\n-        return;\n-    }\n-    visited[node] = true;\n-\n-    result.push(node);\n-\n-    for successor in graph.successors(node) {\n-        pre_order_walk(graph, successor, result, visited);\n-    }\n-}\n-\n pub fn reverse_post_order<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n     let mut vec = post_order_from(graph, start_node);\n     vec.reverse();"}, {"sha": "100881ddfdd7706f25fc75a11af4fedcc5d09d4b", "filename": "src/librustc_data_structures/control_flow_graph/iterate/test.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::super::test::TestGraph;\n-use super::super::transpose::TransposedGraph;\n \n use super::*;\n \n@@ -20,22 +19,3 @@ fn diamond_post_order() {\n     let result = post_order_from(&graph, 0);\n     assert_eq!(result, vec![3, 1, 2, 0]);\n }\n-\n-\n-#[test]\n-fn rev_post_order_inner_loop() {\n-    // 0 -> 1 ->     2     -> 3 -> 5\n-    //      ^     ^    v      |\n-    //      |     6 <- 4      |\n-    //      +-----------------+\n-    let graph = TestGraph::new(0,\n-                               &[(0, 1), (1, 2), (2, 3), (3, 5), (3, 1), (2, 4), (4, 6), (6, 2)]);\n-\n-    let rev_graph = TransposedGraph::new(&graph);\n-\n-    let result = post_order_from_to(&rev_graph, 6, Some(2));\n-    assert_eq!(result, vec![4, 6]);\n-\n-    let result = post_order_from_to(&rev_graph, 3, Some(1));\n-    assert_eq!(result, vec![4, 6, 2, 3]);\n-}"}, {"sha": "7bf776675c6a0ad4f3482538b8457798e03a22d6", "filename": "src/librustc_data_structures/control_flow_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n use super::indexed_vec::Idx;\n-pub use std::slice::Iter;\n \n pub mod dominators;\n pub mod iterate;\n-pub mod reachable;\n mod reference;\n-pub mod transpose;\n \n #[cfg(test)]\n mod test;"}, {"sha": "24210ebb95d3d14f97724a1cf197014ee9c43244", "filename": "src/librustc_data_structures/control_flow_graph/reachable/mod.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs?ref=bdb7901ec9e5784942b62a682de2e2f1a2c58e79", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Compute reachability using a simple dataflow propagation.\n-//! Store end-result in a big NxN bit matrix.\n-\n-use super::ControlFlowGraph;\n-use super::super::bitvec::BitVector;\n-use super::iterate::reverse_post_order;\n-use super::super::indexed_vec::{IndexVec, Idx};\n-\n-#[cfg(test)]\n-mod test;\n-\n-pub fn reachable<G: ControlFlowGraph>(graph: &G) -> Reachability<G::Node> {\n-    let reverse_post_order = reverse_post_order(graph, graph.start_node());\n-    reachable_given_rpo(graph, &reverse_post_order)\n-}\n-\n-pub fn reachable_given_rpo<G: ControlFlowGraph>(graph: &G,\n-                                                reverse_post_order: &[G::Node])\n-                                                -> Reachability<G::Node> {\n-    let mut reachability = Reachability::new(graph);\n-    let mut changed = true;\n-    while changed {\n-        changed = false;\n-        for &node in reverse_post_order.iter().rev() {\n-            // every node can reach itself\n-            changed |= reachability.bits[node].insert(node.index());\n-\n-            // and every pred can reach everything node can reach\n-            for pred in graph.predecessors(node) {\n-                let nodes_bits = reachability.bits[node].clone();\n-                changed |= reachability.bits[pred].insert_all(&nodes_bits);\n-            }\n-        }\n-    }\n-    reachability\n-}\n-\n-pub struct Reachability<Node: Idx> {\n-    bits: IndexVec<Node, BitVector>,\n-}\n-\n-impl<Node: Idx> Reachability<Node> {\n-    fn new<G: ControlFlowGraph>(graph: &G) -> Self {\n-        let num_nodes = graph.num_nodes();\n-        Reachability { bits: IndexVec::from_elem_n(BitVector::new(num_nodes), num_nodes) }\n-    }\n-\n-    pub fn can_reach(&self, source: Node, target: Node) -> bool {\n-        let bit: usize = target.index();\n-        self.bits[source].contains(bit)\n-    }\n-}"}, {"sha": "ef45deeaafc78f30268c29af743f4509de58125a", "filename": "src/librustc_data_structures/control_flow_graph/reachable/test.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs?ref=bdb7901ec9e5784942b62a682de2e2f1a2c58e79", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::super::test::TestGraph;\n-\n-use super::*;\n-\n-#[test]\n-fn test1() {\n-    // 0 -> 1 -> 2 -> 3\n-    //      ^    v\n-    //      6 <- 4 -> 5\n-    let graph = TestGraph::new(0, &[(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (4, 6), (6, 1)]);\n-    let reachable = reachable(&graph);\n-    assert!((0..6).all(|i| reachable.can_reach(0, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(1, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(2, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(4, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(6, i)));\n-    assert!(reachable.can_reach(3, 3));\n-    assert!(!reachable.can_reach(3, 5));\n-    assert!(!reachable.can_reach(5, 3));\n-}\n-\n-/// use bigger indices to cross between words in the bit set\n-#[test]\n-fn test2() {\n-    // 30 -> 31 -> 32 -> 33\n-    //       ^      v\n-    //       36 <- 34 -> 35\n-    let graph = TestGraph::new(30,\n-                               &[(30, 31), (31, 32), (32, 33), (32, 34), (34, 35), (34, 36),\n-                                 (36, 31)]);\n-    let reachable = reachable(&graph);\n-    assert!((30..36).all(|i| reachable.can_reach(30, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(31, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(32, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(34, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(36, i)));\n-    assert!(reachable.can_reach(33, 33));\n-    assert!(!reachable.can_reach(33, 35));\n-    assert!(!reachable.can_reach(35, 33));\n-}"}, {"sha": "f04b536bc185ffab4d3d9fd607f9524e7072b197", "filename": "src/librustc_data_structures/control_flow_graph/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -26,7 +26,7 @@ impl TestGraph {\n     pub fn new(start_node: usize, edges: &[(usize, usize)]) -> Self {\n         let mut graph = TestGraph {\n             num_nodes: start_node + 1,\n-            start_node: start_node,\n+            start_node,\n             successors: HashMap::new(),\n             predecessors: HashMap::new(),\n         };"}, {"sha": "a1a117edb94fce9cd41e00d413b69c611275d1e2", "filename": "src/librustc_data_structures/control_flow_graph/transpose.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs?ref=bdb7901ec9e5784942b62a682de2e2f1a2c58e79", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::*;\n-\n-pub struct TransposedGraph<G: ControlFlowGraph> {\n-    base_graph: G,\n-    start_node: G::Node,\n-}\n-\n-impl<G: ControlFlowGraph> TransposedGraph<G> {\n-    pub fn new(base_graph: G) -> Self {\n-        let start_node = base_graph.start_node();\n-        Self::with_start(base_graph, start_node)\n-    }\n-\n-    pub fn with_start(base_graph: G, start_node: G::Node) -> Self {\n-        TransposedGraph {\n-            base_graph: base_graph,\n-            start_node: start_node,\n-        }\n-    }\n-}\n-\n-impl<G: ControlFlowGraph> ControlFlowGraph for TransposedGraph<G> {\n-    type Node = G::Node;\n-\n-    fn num_nodes(&self) -> usize {\n-        self.base_graph.num_nodes()\n-    }\n-\n-    fn start_node(&self) -> Self::Node {\n-        self.start_node\n-    }\n-\n-    fn predecessors<'graph>(&'graph self,\n-                            node: Self::Node)\n-                            -> <Self as GraphPredecessors<'graph>>::Iter {\n-        self.base_graph.successors(node)\n-    }\n-\n-    fn successors<'graph>(&'graph self,\n-                          node: Self::Node)\n-                          -> <Self as GraphSuccessors<'graph>>::Iter {\n-        self.base_graph.predecessors(node)\n-    }\n-}\n-\n-impl<'graph, G: ControlFlowGraph> GraphPredecessors<'graph> for TransposedGraph<G> {\n-    type Item = G::Node;\n-    type Iter = <G as GraphSuccessors<'graph>>::Iter;\n-}\n-\n-impl<'graph, G: ControlFlowGraph> GraphSuccessors<'graph> for TransposedGraph<G> {\n-    type Item = G::Node;\n-    type Iter = <G as GraphPredecessors<'graph>>::Iter;\n-}"}, {"sha": "50fd1d802b7ffe8e44ee6b8b148fb9d35f638e1c", "filename": "src/librustc_data_structures/fmt_wrap.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffmt_wrap.rs?ref=bdb7901ec9e5784942b62a682de2e2f1a2c58e79", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::fmt;\n-\n-// Provide some more formatting options for some data types (at the moment\n-// that's just `{:x}` for slices of u8).\n-\n-pub struct FmtWrap<T>(pub T);\n-\n-impl<'a> fmt::LowerHex for FmtWrap<&'a [u8]> {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        for byte in self.0.iter() {\n-            try!(write!(formatter, \"{:02x}\", byte));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_lower_hex() {\n-    let bytes: &[u8] = &[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n-    assert_eq!(\"0123456789abcdef\", &format!(\"{:x}\", FmtWrap(bytes)));\n-}"}, {"sha": "5bf25437763cc6162ff69d26a5df51e90b2a00e2", "filename": "src/librustc_data_structures/fx.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -107,9 +107,3 @@ impl Hasher for FxHasher {\n         self.hash as u64\n     }\n }\n-\n-pub fn hash<T: Hash>(v: &T) -> u64 {\n-    let mut state = FxHasher::default();\n-    v.hash(&mut state);\n-    state.finish()\n-}"}, {"sha": "a5f83ce05f5e5108e84ce29a08ee7668cb18601f", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 8, "deletions": 117, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -106,13 +106,6 @@ impl NodeIndex {\n     }\n }\n \n-impl EdgeIndex {\n-    /// Returns unique id (unique with respect to the graph holding associated edge).\n-    pub fn edge_id(&self) -> usize {\n-        self.0\n-    }\n-}\n-\n impl<N: Debug, E: Debug> Graph<N, E> {\n     pub fn new() -> Graph<N, E> {\n         Graph {\n@@ -153,7 +146,7 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         let idx = self.next_node_index();\n         self.nodes.push(Node {\n             first_edge: [INVALID_EDGE_INDEX, INVALID_EDGE_INDEX],\n-            data: data,\n+            data,\n         });\n         idx\n     }\n@@ -189,9 +182,9 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         // as the next pointers\n         self.edges.push(Edge {\n             next_edge: [source_first, target_first],\n-            source: source,\n-            target: target,\n-            data: data,\n+            source,\n+            target,\n+            data,\n         });\n \n         // adjust the firsts for each node target be the next object.\n@@ -201,34 +194,10 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         return idx;\n     }\n \n-    pub fn mut_edge_data(&mut self, idx: EdgeIndex) -> &mut E {\n-        &mut self.edges[idx.0].data\n-    }\n-\n-    pub fn edge_data(&self, idx: EdgeIndex) -> &E {\n-        &self.edges[idx.0].data\n-    }\n-\n     pub fn edge(&self, idx: EdgeIndex) -> &Edge<E> {\n         &self.edges[idx.0]\n     }\n \n-    pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n-        //! Accesses the index of the first edge adjacent to `node`.\n-        //! This is useful if you wish to modify the graph while walking\n-        //! the linked list of edges.\n-\n-        self.nodes[node.0].first_edge[dir.repr]\n-    }\n-\n-    pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n-        //! Accesses the next edge in a given direction.\n-        //! This is useful if you wish to modify the graph while walking\n-        //! the linked list of edges.\n-\n-        self.edges[edge.0].next_edge[dir.repr]\n-    }\n-\n     // # Iterating over nodes, edges\n \n     pub fn enumerated_nodes(&self) -> EnumeratedNodes<N> {\n@@ -269,7 +238,7 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         let first_edge = self.node(source).first_edge[direction.repr];\n         AdjacentEdges {\n             graph: self,\n-            direction: direction,\n+            direction,\n             next: first_edge,\n         }\n     }\n@@ -282,25 +251,6 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         self.incoming_edges(target).sources()\n     }\n \n-    /// A common use for graphs in our compiler is to perform\n-    /// fixed-point iteration. In this case, each edge represents a\n-    /// constraint, and the nodes themselves are associated with\n-    /// variables or other bitsets. This method facilitates such a\n-    /// computation.\n-    pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F)\n-        where F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool\n-    {\n-        let mut iteration = 0;\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            iteration += 1;\n-            for (edge_index, edge) in self.enumerated_edges() {\n-                changed |= op(iteration, edge_index, edge);\n-            }\n-        }\n-    }\n-\n     pub fn depth_traverse<'a>(&'a self,\n                               start: NodeIndex,\n                               direction: Direction)\n@@ -343,35 +293,6 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         assert_eq!(result.len(), self.len_nodes());\n         result\n     }\n-\n-    /// Whether or not a node can be reached from itself.\n-    pub fn is_node_cyclic(&self, starting_node_index: NodeIndex) -> bool {\n-        // This is similar to depth traversal below, but we\n-        // can't use that, because depth traversal doesn't show\n-        // the starting node a second time.\n-        let mut visited = BitVector::new(self.len_nodes());\n-        let mut stack = vec![starting_node_index];\n-\n-        while let Some(current_node_index) = stack.pop() {\n-            visited.insert(current_node_index.0);\n-\n-            // Directionality doesn't change the answer,\n-            // so just use outgoing edges.\n-            for (_, edge) in self.outgoing_edges(current_node_index) {\n-                let target_node_index = edge.target();\n-\n-                if target_node_index == starting_node_index {\n-                    return true;\n-                }\n-\n-                if !visited.contains(target_node_index.0) {\n-                    stack.push(target_node_index);\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n }\n \n // # Iterators\n@@ -479,37 +400,20 @@ pub struct DepthFirstTraversal<'g, N, E>\n }\n \n impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n-    pub fn new(graph: &'g Graph<N, E>, direction: Direction) -> Self {\n-        let visited = BitVector::new(graph.len_nodes());\n-        DepthFirstTraversal {\n-            graph: graph,\n-            stack: vec![],\n-            visited: visited,\n-            direction: direction,\n-        }\n-    }\n-\n     pub fn with_start_node(graph: &'g Graph<N, E>,\n                            start_node: NodeIndex,\n                            direction: Direction)\n                            -> Self {\n         let mut visited = BitVector::new(graph.len_nodes());\n         visited.insert(start_node.node_id());\n         DepthFirstTraversal {\n-            graph: graph,\n+            graph,\n             stack: vec![start_node],\n-            visited: visited,\n-            direction: direction,\n+            visited,\n+            direction,\n         }\n     }\n \n-    pub fn reset(&mut self, start_node: NodeIndex) {\n-        self.stack.truncate(0);\n-        self.stack.push(start_node);\n-        self.visited.clear();\n-        self.visited.insert(start_node.node_id());\n-    }\n-\n     fn visit(&mut self, node: NodeIndex) {\n         if self.visited.insert(node.node_id()) {\n             self.stack.push(node);\n@@ -532,19 +436,6 @@ impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     }\n }\n \n-pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F)\n-    where F: FnMut(EdgeIndex) -> bool\n-{\n-    let mut i = 0;\n-    let n = max_edge_index.0;\n-    while i < n {\n-        if !f(EdgeIndex(i)) {\n-            return;\n-        }\n-        i += 1;\n-    }\n-}\n-\n impl<E> Edge<E> {\n     pub fn source(&self) -> NodeIndex {\n         self.source"}, {"sha": "007704357af4fa8c1d6ec4452091f8f53d0bc155", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -43,29 +43,6 @@ fn create_graph() -> TestGraph {\n     return graph;\n }\n \n-fn create_graph_with_cycle() -> TestGraph {\n-    let mut graph = Graph::new();\n-\n-    // Create a graph with a cycle.\n-    //\n-    //    A --> B <-- +\n-    //          |     |\n-    //          v     |\n-    //          C --> D\n-\n-    let a = graph.add_node(\"A\");\n-    let b = graph.add_node(\"B\");\n-    let c = graph.add_node(\"C\");\n-    let d = graph.add_node(\"D\");\n-\n-    graph.add_edge(a, b, \"AB\");\n-    graph.add_edge(b, c, \"BC\");\n-    graph.add_edge(c, d, \"CD\");\n-    graph.add_edge(d, b, \"DB\");\n-\n-    return graph;\n-}\n-\n #[test]\n fn each_node() {\n     let graph = create_graph();\n@@ -82,7 +59,6 @@ fn each_edge() {\n     let graph = create_graph();\n     let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n     graph.each_edge(|idx, edge| {\n-        assert_eq!(&expected[idx.0], graph.edge_data(idx));\n         assert_eq!(expected[idx.0], edge.data);\n         true\n     });\n@@ -97,7 +73,6 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(graph: &Graph\n \n     let mut counter = 0;\n     for (edge_index, edge) in graph.incoming_edges(start_index) {\n-        assert!(graph.edge_data(edge_index) == &edge.data);\n         assert!(counter < expected_incoming.len());\n         debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                counter,\n@@ -117,7 +92,6 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(graph: &Graph\n \n     let mut counter = 0;\n     for (edge_index, edge) in graph.outgoing_edges(start_index) {\n-        assert!(graph.edge_data(edge_index) == &edge.data);\n         assert!(counter < expected_outgoing.len());\n         debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                counter,\n@@ -163,58 +137,3 @@ fn each_adjacent_from_d() {\n     let graph = create_graph();\n     test_adjacent_edges(&graph, NodeIndex(3), \"D\", &[(\"BD\", \"B\")], &[(\"DE\", \"E\")]);\n }\n-\n-#[test]\n-fn is_node_cyclic_a() {\n-    let graph = create_graph_with_cycle();\n-    assert!(!graph.is_node_cyclic(NodeIndex(0)));\n-}\n-\n-#[test]\n-fn is_node_cyclic_b() {\n-    let graph = create_graph_with_cycle();\n-    assert!(graph.is_node_cyclic(NodeIndex(1)));\n-}\n-\n-#[test]\n-fn nodes_in_postorder() {\n-    let expected = vec![\n-        (\"A\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"B\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"C\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"D\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"E\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"F\", vec![\"C\", \"E\", \"D\", \"B\", \"F\", \"A\"])\n-    ];\n-\n-    let graph = create_graph();\n-\n-    for ((idx, node), &(node_name, ref expected))\n-        in graph.enumerated_nodes().zip(&expected)\n-    {\n-        assert_eq!(node.data, node_name);\n-        assert_eq!(expected,\n-                   &graph.nodes_in_postorder(OUTGOING, idx)\n-                   .into_iter().map(|idx| *graph.node_data(idx))\n-                   .collect::<Vec<&str>>());\n-    }\n-\n-    let expected = vec![\n-        (\"A\", vec![\"D\", \"C\", \"B\", \"A\"]),\n-        (\"B\", vec![\"D\", \"C\", \"B\", \"A\"]),\n-        (\"C\", vec![\"B\", \"D\", \"C\", \"A\"]),\n-        (\"D\", vec![\"C\", \"B\", \"D\", \"A\"]),\n-    ];\n-\n-    let graph = create_graph_with_cycle();\n-\n-    for ((idx, node), &(node_name, ref expected))\n-        in graph.enumerated_nodes().zip(&expected)\n-    {\n-        assert_eq!(node.data, node_name);\n-        assert_eq!(expected,\n-                   &graph.nodes_in_postorder(OUTGOING, idx)\n-                   .into_iter().map(|idx| *graph.node_data(idx))\n-                   .collect::<Vec<&str>>());\n-    }\n-}"}, {"sha": "9cb6806e9ade5b831b605b9cdaa607a980d2ca71", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -153,4 +153,68 @@ impl<T: Idx> IdxSet<T> {\n     pub fn subtract(&mut self, other: &IdxSet<T>) -> bool {\n         bitwise(self.words_mut(), other.words(), &Subtract)\n     }\n+\n+    /// Calls `f` on each index value held in this set, up to the\n+    /// bound `max_bits` on the size of universe of indexes.\n+    pub fn each_bit<F>(&self, max_bits: usize, f: F) where F: FnMut(T) {\n+        each_bit(self, max_bits, f)\n+    }\n+\n+    /// Removes all elements from this set.\n+    pub fn reset_to_empty(&mut self) {\n+        for word in self.words_mut() { *word = 0; }\n+    }\n+\n+    pub fn elems(&self, universe_size: usize) -> Elems<T> {\n+        Elems { i: 0, set: self, universe_size: universe_size }\n+    }\n+}\n+\n+pub struct Elems<'a, T: Idx> { i: usize, set: &'a IdxSet<T>, universe_size: usize }\n+\n+impl<'a, T: Idx> Iterator for Elems<'a, T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> {\n+        if self.i >= self.universe_size { return None; }\n+        let mut i = self.i;\n+        loop {\n+            if i >= self.universe_size {\n+                self.i = i; // (mark iteration as complete.)\n+                return None;\n+            }\n+            if self.set.contains(&T::new(i)) {\n+                self.i = i + 1; // (next element to start at.)\n+                return Some(T::new(i));\n+            }\n+            i = i + 1;\n+        }\n+    }\n+}\n+\n+fn each_bit<T: Idx, F>(words: &IdxSet<T>, max_bits: usize, mut f: F) where F: FnMut(T) {\n+    let usize_bits: usize = mem::size_of::<usize>() * 8;\n+\n+    for (word_index, &word) in words.words().iter().enumerate() {\n+        if word != 0 {\n+            let base_index = word_index * usize_bits;\n+            for offset in 0..usize_bits {\n+                let bit = 1 << offset;\n+                if (word & bit) != 0 {\n+                    // NB: we round up the total number of bits\n+                    // that we store in any given bit set so that\n+                    // it is an even multiple of usize::BITS. This\n+                    // means that there may be some stray bits at\n+                    // the end that do not correspond to any\n+                    // actual value; that's why we first check\n+                    // that we are in range of bits_per_block.\n+                    let bit_index = base_index + offset as usize;\n+                    if bit_index >= max_bits {\n+                        return;\n+                    } else {\n+                        f(Idx::new(bit_index));\n+                    }\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "f842f4a41a118b36d9b7d4bc1162dc0d5afda1c5", "filename": "src/librustc_data_structures/ivar.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb7901ec9e5784942b62a682de2e2f1a2c58e79/src%2Flibrustc_data_structures%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fivar.rs?ref=bdb7901ec9e5784942b62a682de2e2f1a2c58e79", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::fmt;\n-use std::cell::Cell;\n-\n-/// A write-once variable. When constructed, it is empty, and\n-/// can only be set once.\n-///\n-/// Ivars ensure that data that can only be initialised once. A full\n-/// implementation is used for concurrency and blocks on a read of an\n-/// unfulfilled value. This implementation is more minimal and panics\n-/// if you attempt to read the value before it has been set. It is also\n-/// not `Sync`, but may be extended in the future to be usable as a true\n-/// concurrency type.\n-///\n-/// The `T: Copy` bound is not strictly needed, but it is required by\n-/// Cell (so removing it would require using UnsafeCell), and it\n-/// suffices for the current purposes.\n-#[derive(PartialEq)]\n-pub struct Ivar<T: Copy> {\n-    data: Cell<Option<T>>,\n-}\n-\n-impl<T: Copy> Ivar<T> {\n-    pub fn new() -> Ivar<T> {\n-        Ivar { data: Cell::new(None) }\n-    }\n-\n-    pub fn get(&self) -> Option<T> {\n-        self.data.get()\n-    }\n-\n-    pub fn fulfill(&self, value: T) {\n-        assert!(self.data.get().is_none(), \"Value already set!\");\n-        self.data.set(Some(value));\n-    }\n-\n-    pub fn is_fulfilled(&self) -> bool {\n-        self.data.get().is_some()\n-    }\n-\n-    pub fn unwrap(&self) -> T {\n-        self.get().unwrap()\n-    }\n-}\n-\n-impl<T: Copy + fmt::Debug> fmt::Debug for Ivar<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.get() {\n-            Some(val) => write!(f, \"Ivar({:?})\", val),\n-            None => f.write_str(\"Ivar(<unfulfilled>)\"),\n-        }\n-    }\n-}\n-\n-impl<T: Copy> Clone for Ivar<T> {\n-    fn clone(&self) -> Ivar<T> {\n-        match self.get() {\n-            Some(val) => Ivar { data: Cell::new(Some(val)) },\n-            None => Ivar::new(),\n-        }\n-    }\n-}"}, {"sha": "da00ebc4b9ee90a21b4dd3050a2907ceef226cfd", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -16,9 +16,6 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![crate_name = \"rustc_data_structures\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -52,11 +49,9 @@ pub mod accumulate_vec;\n pub mod small_vec;\n pub mod base_n;\n pub mod bitslice;\n-pub mod blake2b;\n pub mod bitvec;\n-pub mod fmt_wrap;\n+pub mod blake2b;\n pub mod graph;\n-pub mod ivar;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;"}, {"sha": "02cae52166ac3a4a009a48e72b2a4f586defa8d4", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 8, "deletions": 56, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -57,11 +57,6 @@ pub trait ObligationProcessor {\n         where I: Clone + Iterator<Item=&'c Self::Obligation>;\n }\n \n-struct SnapshotData {\n-    node_len: usize,\n-    cache_list_len: usize,\n-}\n-\n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n@@ -83,14 +78,9 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// A list of the obligations added in snapshots, to allow\n     /// for their removal.\n     cache_list: Vec<O::Predicate>,\n-    snapshots: Vec<SnapshotData>,\n     scratch: Option<Vec<usize>>,\n }\n \n-pub struct Snapshot {\n-    len: usize,\n-}\n-\n #[derive(Debug)]\n struct Node<O> {\n     obligation: O,\n@@ -166,7 +156,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n-            snapshots: vec![],\n             done_cache: FxHashSet(),\n             waiting_cache: FxHashMap(),\n             cache_list: vec![],\n@@ -180,39 +169,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.nodes.len()\n     }\n \n-    pub fn start_snapshot(&mut self) -> Snapshot {\n-        self.snapshots.push(SnapshotData {\n-            node_len: self.nodes.len(),\n-            cache_list_len: self.cache_list.len()\n-        });\n-        Snapshot { len: self.snapshots.len() }\n-    }\n-\n-    pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n-        assert_eq!(snapshot.len, self.snapshots.len());\n-        let info = self.snapshots.pop().unwrap();\n-        assert!(self.nodes.len() >= info.node_len);\n-        assert!(self.cache_list.len() >= info.cache_list_len);\n-    }\n-\n-    pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n-        // Check that we are obeying stack discipline.\n-        assert_eq!(snapshot.len, self.snapshots.len());\n-        let info = self.snapshots.pop().unwrap();\n-\n-        for entry in &self.cache_list[info.cache_list_len..] {\n-            self.done_cache.remove(entry);\n-            self.waiting_cache.remove(entry);\n-        }\n-\n-        self.nodes.truncate(info.node_len);\n-        self.cache_list.truncate(info.cache_list_len);\n-    }\n-\n-    pub fn in_snapshot(&self) -> bool {\n-        !self.snapshots.is_empty()\n-    }\n-\n     /// Registers an obligation\n     ///\n     /// This CAN be done in a snapshot\n@@ -262,14 +218,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n     ///\n     /// This cannot be done during a snapshot.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n-        assert!(!self.in_snapshot());\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n             if let NodeState::Pending = self.nodes[index].state.get() {\n                 let backtrace = self.error_at(index);\n                 errors.push(Error {\n                     error: error.clone(),\n-                    backtrace: backtrace,\n+                    backtrace,\n                 });\n             }\n         }\n@@ -297,7 +252,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n         where P: ObligationProcessor<Obligation=O>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n-        assert!(!self.in_snapshot()); // cannot unroll this action\n \n         let mut errors = vec![];\n         let mut stalled = true;\n@@ -346,7 +300,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     let backtrace = self.error_at(index);\n                     errors.push(Error {\n                         error: err,\n-                        backtrace: backtrace,\n+                        backtrace,\n                     });\n                 }\n             }\n@@ -357,8 +311,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // changed.\n             return Outcome {\n                 completed: vec![],\n-                errors: errors,\n-                stalled: stalled,\n+                errors,\n+                stalled,\n             };\n         }\n \n@@ -372,8 +326,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         Outcome {\n             completed: completed_obligations,\n-            errors: errors,\n-            stalled: stalled,\n+            errors,\n+            stalled,\n         }\n     }\n \n@@ -528,8 +482,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// on these nodes may be present. This is done by e.g. `process_cycles`.\n     #[inline(never)]\n     fn compress(&mut self) -> Vec<O> {\n-        assert!(!self.in_snapshot()); // didn't write code to unroll this action\n-\n         let nodes_len = self.nodes.len();\n         let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n         node_rewrites.extend(0..nodes_len);\n@@ -638,8 +590,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n impl<O> Node<O> {\n     fn new(parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n         Node {\n-            obligation: obligation,\n-            parent: parent,\n+            obligation,\n+            parent,\n             state: Cell::new(NodeState::Pending),\n             dependents: vec![],\n         }"}, {"sha": "74738e61b446775aebb84e80e6e974fffae5f609", "filename": "src/librustc_data_structures/small_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,7 +14,7 @@\n //! used to store the values on the heap. SmallVec is similar to AccumulateVec, but adds\n //! the ability to push elements.\n //!\n-//! The N above is determined by Array's implementor, by way of an associatated constant.\n+//! The N above is determined by Array's implementor, by way of an associated constant.\n \n use std::ops::{Deref, DerefMut};\n use std::iter::{IntoIterator, FromIterator};"}, {"sha": "7853bf9478ab8157e9a99ea679349ea171114751", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -87,8 +87,8 @@ impl<K: UnifyKey> VarValue<K> {\n     fn new(parent: K, value: K::Value, rank: u32) -> VarValue<K> {\n         VarValue {\n             parent: parent, // this is a root\n-            value: value,\n-            rank: rank,\n+            value,\n+            rank,\n         }\n     }\n \n@@ -98,8 +98,8 @@ impl<K: UnifyKey> VarValue<K> {\n \n     fn root(self, rank: u32, value: K::Value) -> VarValue<K> {\n         VarValue {\n-            rank: rank,\n-            value: value,\n+            rank,\n+            value,\n             ..self\n         }\n     }\n@@ -275,7 +275,8 @@ impl<'tcx, K: UnifyKey> UnificationTable<K>\n         self.get(id).value\n     }\n \n-    pub fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n+    #[cfg(test)]\n+    fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n         self.find(a_id) == self.find(b_id)\n     }\n }"}, {"sha": "96688c6ac9cdb07afd45f6f0bf0c514e7128028f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -64,6 +64,8 @@ use arena::DroplessArena;\n \n use derive_registrar;\n \n+use profile;\n+\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      input: &Input,\n@@ -105,6 +107,10 @@ pub fn compile_input(sess: &Session,\n         sess.abort_if_errors();\n     }\n \n+    if sess.profile_queries() {\n+        profile::begin();\n+    }\n+\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n@@ -306,7 +312,7 @@ pub fn source_name(input: &Input) -> String {\n     }\n }\n \n-/// CompileController is used to customise compilation, it allows compilation to\n+/// CompileController is used to customize compilation, it allows compilation to\n /// be stopped and/or to call arbitrary code at various points in compilation.\n /// It also allows for various flags to be set to influence what information gets\n /// collected during compilation.\n@@ -401,8 +407,8 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n              out_dir: &'a Option<PathBuf>)\n              -> Self {\n         CompileState {\n-            input: input,\n-            session: session,\n+            input,\n+            session,\n             out_dir: out_dir.as_ref().map(|s| &**s),\n             out_file: None,\n             arena: None,\n@@ -537,6 +543,10 @@ pub fn phase_1_parse_input<'a>(control: &CompileController,\n                                -> PResult<'a, ast::Crate> {\n     sess.diagnostic().set_continue_after_error(control.continue_parse_after_error);\n \n+    if sess.profile_queries() {\n+        profile::begin();\n+    }\n+\n     let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n@@ -833,10 +843,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         })\n     })?;\n \n-    time(time_passes,\n-         \"early lint checks\",\n-         || lint::check_ast_crate(sess, &krate));\n-\n     // Lower ast -> hir.\n     let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, &krate, &mut resolver);\n@@ -848,6 +854,10 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         hir_map::Forest::new(hir_crate, &sess.dep_graph)\n     });\n \n+    time(time_passes,\n+         \"early lint checks\",\n+         || lint::check_ast_crate(sess, &krate));\n+\n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !keep_hygiene_data(sess) {\n         syntax::ext::hygiene::clear_markings();\n@@ -867,8 +877,9 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n             export_map: resolver.export_map,\n             trait_map: resolver.trait_map,\n             maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n+            maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n         },\n-        hir_forest: hir_forest,\n+        hir_forest,\n     })\n }\n \n@@ -970,7 +981,12 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // We compute \"constant qualifications\" between MIR_CONST and MIR_VALIDATED.\n \n     // What we need to run borrowck etc.\n+\n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n+\n+    // FIXME: ariel points SimplifyBranches should run after\n+    // mir-borrowck; otherwise code within `if false { ... }` would\n+    // not be checked.\n     passes.push_pass(MIR_VALIDATED,\n                      mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n@@ -1066,6 +1082,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"borrow checking\",\n              || borrowck::check_crate(tcx));\n \n+        time(time_passes,\n+             \"MIR borrow checking\",\n+             || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id) });\n+\n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids\n         // a\n@@ -1111,6 +1131,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n              \"translation\",\n              move || trans::trans_crate(tcx, analysis, incremental_hashes_map, output_filenames));\n \n+    if tcx.sess.profile_queries() {\n+        profile::dump(\"profile_queries\".to_string())\n+    }\n+\n     translation\n }\n "}, {"sha": "1915a1c86484a6148239c3714882c42fe49a9ce8", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,16 +14,13 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![crate_name = \"rustc_driver\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n #![feature(box_syntax)]\n-#![feature(libc)]\n+#![cfg_attr(unix, feature(libc))]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(set_stdio)]\n@@ -32,6 +29,7 @@ extern crate arena;\n extern crate getopts;\n extern crate graphviz;\n extern crate env_logger;\n+#[cfg(unix)]\n extern crate libc;\n extern crate rustc;\n extern crate rustc_allocator;\n@@ -102,8 +100,9 @@ use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan};\n \n #[cfg(test)]\n-pub mod test;\n+mod test;\n \n+pub mod profile;\n pub mod driver;\n pub mod pretty;\n pub mod target_features;\n@@ -802,7 +801,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = Vec::new();\n                     for &(name, ref value) in sess.parse_sess.config.iter() {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            name: name,\n+                            name,\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });\n@@ -859,17 +858,17 @@ impl RustcDefaultCalls {\n }\n \n /// Returns a version string such as \"0.12.0-dev\".\n-pub fn release_str() -> Option<&'static str> {\n+fn release_str() -> Option<&'static str> {\n     option_env!(\"CFG_RELEASE\")\n }\n \n /// Returns the full SHA1 hash of HEAD of the Git repo from which rustc was built.\n-pub fn commit_hash_str() -> Option<&'static str> {\n+fn commit_hash_str() -> Option<&'static str> {\n     option_env!(\"CFG_VER_HASH\")\n }\n \n /// Returns the \"commit date\" of HEAD of the Git repo from which rustc was built as a static string.\n-pub fn commit_date_str() -> Option<&'static str> {\n+fn commit_date_str() -> Option<&'static str> {\n     option_env!(\"CFG_VER_DATE\")\n }\n "}, {"sha": "20f2a146b0b1584c1e83a7de8365eae64a5610c2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -174,22 +174,22 @@ impl PpSourceMode {\n         match *self {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n                 let annotation = NoAnn {\n-                    sess: sess,\n+                    sess,\n                     hir_map: hir_map.map(|m| m.clone()),\n                 };\n                 f(&annotation)\n             }\n \n             PpmIdentified | PpmExpandedIdentified => {\n                 let annotation = IdentifiedAnnotation {\n-                    sess: sess,\n+                    sess,\n                     hir_map: hir_map.map(|m| m.clone()),\n                 };\n                 f(&annotation)\n             }\n             PpmExpandedHygiene => {\n                 let annotation = HygieneAnnotation {\n-                    sess: sess,\n+                    sess,\n                 };\n                 f(&annotation)\n             }\n@@ -211,15 +211,15 @@ impl PpSourceMode {\n         match *self {\n             PpmNormal => {\n                 let annotation = NoAnn {\n-                    sess: sess,\n+                    sess,\n                     hir_map: Some(hir_map.clone()),\n                 };\n                 f(&annotation, hir_map.forest.krate())\n             }\n \n             PpmIdentified => {\n                 let annotation = IdentifiedAnnotation {\n-                    sess: sess,\n+                    sess,\n                     hir_map: Some(hir_map.clone()),\n                 };\n                 f(&annotation, hir_map.forest.krate())\n@@ -235,7 +235,7 @@ impl PpSourceMode {\n                                                                  |tcx, _, _, _| {\n                     let empty_tables = ty::TypeckTables::empty(None);\n                     let annotation = TypedAnnotation {\n-                        tcx: tcx,\n+                        tcx,\n                         tables: Cell::new(&empty_tables)\n                     };\n                     let _ignore = tcx.dep_graph.in_ignore();\n@@ -620,6 +620,15 @@ impl UserIdentifiedItem {\n }\n \n // Note: Also used by librustdoc, see PR #43348. Consider moving this struct elsewhere.\n+//\n+// FIXME: Currently the `everybody_loops` transformation is not applied to:\n+//  * `const fn`, due to issue #43636 that `loop` is not supported for const evaluation. We are\n+//    waiting for miri to fix that.\n+//  * `impl Trait`, due to issue #43869 that functions returning impl Trait cannot be diverging.\n+//    Solving this may require `!` to implement every trait, which relies on the an even more\n+//    ambitious form of the closed RFC #1637. See also [#34511].\n+//\n+// [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n pub struct ReplaceBodyWithLoop {\n     within_static_or_const: bool,\n }\n@@ -635,14 +644,34 @@ impl ReplaceBodyWithLoop {\n         self.within_static_or_const = old_const;\n         ret\n     }\n+\n+    fn should_ignore_fn(ret_ty: &ast::FnDecl) -> bool {\n+        if let ast::FunctionRetTy::Ty(ref ty) = ret_ty.output {\n+            fn involves_impl_trait(ty: &ast::Ty) -> bool {\n+                match ty.node {\n+                    ast::TyKind::ImplTrait(_) => true,\n+                    ast::TyKind::Slice(ref subty) |\n+                    ast::TyKind::Array(ref subty, _) |\n+                    ast::TyKind::Ptr(ast::MutTy { ty: ref subty, .. }) |\n+                    ast::TyKind::Rptr(_, ast::MutTy { ty: ref subty, .. }) |\n+                    ast::TyKind::Paren(ref subty) => involves_impl_trait(subty),\n+                    ast::TyKind::Tup(ref tys) => tys.iter().any(|subty| involves_impl_trait(subty)),\n+                    _ => false,\n+                }\n+            }\n+            involves_impl_trait(ty)\n+        } else {\n+            false\n+        }\n+    }\n }\n \n impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n         let is_const = match i {\n             ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n-            ast::ItemKind::Fn(_, _, ref constness, _, _, _) =>\n-                constness.node == ast::Constness::Const,\n+            ast::ItemKind::Fn(ref decl, _, ref constness, _, _, _) =>\n+                constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n         self.run(is_const, |s| fold::noop_fold_item_kind(i, s))\n@@ -651,8 +680,8 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n         let is_const = match i.node {\n             ast::TraitItemKind::Const(..) => true,\n-            ast::TraitItemKind::Method(ast::MethodSig { ref constness, .. }, _) =>\n-                constness.node == ast::Constness::Const,\n+            ast::TraitItemKind::Method(ast::MethodSig { ref decl, ref constness, .. }, _) =>\n+                constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n         self.run(is_const, |s| fold::noop_fold_trait_item(i, s))\n@@ -661,8 +690,8 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n         let is_const = match i.node {\n             ast::ImplItemKind::Const(..) => true,\n-            ast::ImplItemKind::Method(ast::MethodSig { ref constness, .. }, _) =>\n-                constness.node == ast::Constness::Const,\n+            ast::ImplItemKind::Method(ast::MethodSig { ref decl, ref constness, .. }, _) =>\n+                constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n         self.run(is_const, |s| fold::noop_fold_impl_item(i, s))\n@@ -680,7 +709,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n                     })\n                     .into_iter()\n                     .collect(),\n-                rules: rules,\n+                rules,\n                 id: ast::DUMMY_NODE_ID,\n                 span: syntax_pos::DUMMY_SP,\n             })\n@@ -739,7 +768,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n         hir_map: &tcx.hir,\n         cfg: &cfg,\n         name: format!(\"node_{}\", code.id()),\n-        labelled_edges: labelled_edges,\n+        labelled_edges,\n     };\n \n     match code {\n@@ -758,7 +787,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,\n-                variants: variants,\n+                variants,\n                 borrowck_ctxt: &bccx,\n                 analysis_data: &analysis_data,\n             };"}, {"sha": "061077d05a438560f820b3c45d83dbf74427434a", "filename": "src/librustc_driver/profile/mod.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -0,0 +1,316 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n+use std::sync::mpsc::{Receiver};\n+use std::io::{Write};\n+use rustc::dep_graph::{DepNode};\n+use std::time::{Duration, Instant};\n+\n+pub mod trace;\n+\n+/// begin a profile thread, if not already running\n+pub fn begin() {\n+    use std::thread;\n+    use std::sync::mpsc::{channel};\n+    let (tx, rx) = channel();\n+    if profq_set_chan(tx) {\n+        thread::spawn(move||profile_queries_thread(rx));\n+    }\n+}\n+\n+/// dump files with profiling information to the given base path, and\n+/// wait for this dump to complete.\n+///\n+/// wraps the RPC (send/recv channel logic) of requesting a dump.\n+pub fn dump(path:String) {\n+    use std::sync::mpsc::{channel};\n+    let (tx, rx) = channel();\n+    let params = ProfQDumpParams{\n+        path, ack:tx,\n+        // FIXME: Add another compiler flag to toggle whether this log\n+        // is written; false for now\n+        dump_profq_msg_log:true,\n+    };\n+    profq_msg(ProfileQueriesMsg::Dump(params));\n+    let _ = rx.recv().unwrap();\n+}\n+\n+// State for parsing recursive trace structure in separate thread, via messages\n+#[derive(Clone, Eq, PartialEq)]\n+enum ParseState {\n+    // No (local) parse state; may be parsing a tree, focused on a\n+    // sub-tree that could be anything.\n+    Clear,\n+    // Have Query information from the last message\n+    HaveQuery(trace::Query, Instant),\n+    // Have \"time-begin\" information from the last message (doit flag, and message)\n+    HaveTimeBegin(String, Instant),\n+    // Have \"task-begin\" information from the last message\n+    HaveTaskBegin(DepNode, Instant),\n+}\n+struct StackFrame {\n+    pub parse_st: ParseState,\n+    pub traces:   Vec<trace::Rec>,\n+}\n+\n+fn total_duration(traces: &Vec<trace::Rec>) -> Duration {\n+    let mut sum : Duration = Duration::new(0,0);\n+    for t in traces.iter() { sum += t.dur_total; }\n+    return sum\n+}\n+\n+// profiling thread; retains state (in local variables) and dump traces, upon request.\n+fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n+    use self::trace::*;\n+    use std::fs::File;\n+    use std::time::{Instant};\n+\n+    let mut profq_msgs : Vec<ProfileQueriesMsg> = vec![];\n+    let mut frame : StackFrame = StackFrame{ parse_st:ParseState::Clear, traces:vec![] };\n+    let mut stack : Vec<StackFrame> = vec![];\n+    loop {\n+        let msg = r.recv();\n+        if let Err(_recv_err) = msg {\n+            // FIXME: Perhaps do something smarter than simply quitting?\n+            break\n+        };\n+        let msg = msg.unwrap();\n+        debug!(\"profile_queries_thread: {:?}\", msg);\n+\n+        // Meta-level versus _actual_ queries messages\n+        match msg {\n+            ProfileQueriesMsg::Halt => return,\n+            ProfileQueriesMsg::Dump(params) => {\n+                assert!(stack.len() == 0);\n+                assert!(frame.parse_st == ParseState::Clear);\n+                {\n+                    // write log of all messages\n+                    if params.dump_profq_msg_log {\n+                        let mut log_file =\n+                            File::create(format!(\"{}.log.txt\", params.path)).unwrap();\n+                        for m in profq_msgs.iter() {\n+                            writeln!(&mut log_file, \"{:?}\", m).unwrap()\n+                        };\n+                    }\n+\n+                    // write HTML file, and counts file\n+                    let html_path = format!(\"{}.html\", params.path);\n+                    let mut html_file = File::create(&html_path).unwrap();\n+\n+                    let counts_path = format!(\"{}.counts.txt\", params.path);\n+                    let mut counts_file = File::create(&counts_path).unwrap();\n+\n+                    write!(html_file, \"<html>\\n\").unwrap();\n+                    write!(html_file,\n+                           \"<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\",\n+                           \"profile_queries.css\").unwrap();\n+                    write!(html_file, \"<style>\\n\").unwrap();\n+                    trace::write_style(&mut html_file);\n+                    write!(html_file, \"</style>\\n\").unwrap();\n+                    write!(html_file, \"</head>\\n\").unwrap();\n+                    write!(html_file, \"<body>\\n\").unwrap();\n+                    trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n+                    write!(html_file, \"</body>\\n</html>\\n\").unwrap();\n+\n+                    let ack_path = format!(\"{}.ack\", params.path);\n+                    let ack_file = File::create(&ack_path).unwrap();\n+                    drop(ack_file);\n+\n+                    // Tell main thread that we are done, e.g., so it can exit\n+                    params.ack.send(()).unwrap();\n+                }\n+                continue\n+            }\n+            // Actual query message:\n+            msg => {\n+                // Record msg in our log\n+                profq_msgs.push(msg.clone());\n+                // Respond to the message, knowing that we've already handled Halt and Dump, above.\n+                match (frame.parse_st.clone(), msg) {\n+                    (_,ProfileQueriesMsg::Halt) => unreachable!(),\n+                    (_,ProfileQueriesMsg::Dump(_)) => unreachable!(),\n+\n+                    // Parse State: Clear\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::QueryBegin(span,querymsg)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveQuery\n+                            (Query{span:span, msg:querymsg}, start)\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::CacheHit) => {\n+                        panic!(\"parse error: unexpected CacheHit; expected QueryBegin\")\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                        panic!(\"parse error: expected QueryBegin before beginning a provider\")\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::ProviderEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveQuery(q, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::QueryBegin(q, CacheCase::Miss),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_self: duration - dur_extent,\n+                                            dur_total: duration,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TimeBegin(msg)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveTimeBegin(msg, start);\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+                    (_, ProfileQueriesMsg::TimeBegin(_)) =>\n+                        panic!(\"parse error; did not expect time begin here\"),\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TimeEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveTimeBegin(msg, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::TimeBegin(msg),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_total: duration,\n+                                            dur_self: duration - dur_extent,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+                    (_, ProfileQueriesMsg::TimeEnd) => { panic!(\"parse error\") }\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TaskBegin(key)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveTaskBegin(key, start);\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+                    (_, ProfileQueriesMsg::TaskBegin(_)) =>\n+                        panic!(\"parse error; did not expect time begin here\"),\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TaskEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveTaskBegin(key, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::TaskBegin(key),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_total: duration,\n+                                            dur_self: duration - dur_extent,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+                    (_, ProfileQueriesMsg::TaskEnd) => { panic!(\"parse error\") }\n+\n+                    // Parse State: HaveQuery\n+                    (ParseState::HaveQuery(q,start),\n+                     ProfileQueriesMsg::CacheHit) => {\n+                        let duration = start.elapsed();\n+                        let trace : Rec = Rec{\n+                            effect: Effect::QueryBegin(q, CacheCase::Hit),\n+                            extent: Box::new(vec![]),\n+                            start: start,\n+                            dur_self: duration,\n+                            dur_total: duration,\n+                        };\n+                        frame.traces.push( trace );\n+                        frame.parse_st = ParseState::Clear;\n+                    },\n+                    (ParseState::HaveQuery(_,_),\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+\n+                    //\n+                    //\n+                    // Parse errors:\n+\n+                    (ParseState::HaveQuery(q,_),\n+                     ProfileQueriesMsg::ProviderEnd) => {\n+                        panic!(\"parse error: unexpected ProviderEnd; \\\n+                                expected something else to follow BeginQuery for {:?}\", q)\n+                    },\n+                    (ParseState::HaveQuery(q1,_),\n+                     ProfileQueriesMsg::QueryBegin(span2,querymsg2)) => {\n+                        panic!(\"parse error: unexpected QueryBegin; \\\n+                                earlier query is unfinished: {:?} and now {:?}\",\n+                               q1, Query{span:span2, msg:querymsg2})\n+                    },\n+\n+                    (ParseState::HaveTimeBegin(_, _), _) => {\n+                        unreachable!()\n+                    },\n+                    (ParseState::HaveTaskBegin(_, _), _) => {\n+                        unreachable!()\n+                    },\n+                }\n+\n+            }\n+        }\n+    }\n+}"}, {"sha": "f5079836c3ca40f6d248b42fd024bb5d23777cd3", "filename": "src/librustc_driver/profile/trace.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+use syntax_pos::Span;\n+use rustc::ty::maps::QueryMsg;\n+use std::fs::File;\n+use std::time::{Duration, Instant};\n+use std::collections::hash_map::HashMap;\n+use rustc::dep_graph::{DepNode};\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Query {\n+    pub span: Span,\n+    pub msg: QueryMsg,\n+}\n+pub enum Effect {\n+    QueryBegin(Query, CacheCase),\n+    TimeBegin(String),\n+    TaskBegin(DepNode),\n+}\n+pub enum CacheCase {\n+    Hit, Miss\n+}\n+/// Recursive trace structure\n+pub struct Rec {\n+    pub effect: Effect,\n+    pub start: Instant,\n+    pub dur_self: Duration,\n+    pub dur_total: Duration,\n+    pub extent: Box<Vec<Rec>>,\n+}\n+pub struct QueryMetric {\n+    pub count: usize,\n+    pub dur_self: Duration,\n+    pub dur_total: Duration,\n+}\n+\n+pub fn cons_of_query_msg(q: &trace::Query) -> String {\n+    let s = format!(\"{:?}\", q.msg);\n+    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n+    assert!(cons.len() > 0 && cons[0] != \"\");\n+    cons[0].to_string()\n+}\n+\n+pub fn cons_of_key(k: &DepNode) -> String {\n+    let s = format!(\"{:?}\", k);\n+    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n+    assert!(cons.len() > 0 && cons[0] != \"\");\n+    cons[0].to_string()\n+}\n+\n+// First return value is text; second return value is a CSS class\n+pub fn html_of_effect(eff: &Effect) -> (String, String) {\n+    match *eff {\n+        Effect::TimeBegin(ref msg) => {\n+            (msg.clone(),\n+             format!(\"time-begin\"))\n+        },\n+        Effect::TaskBegin(ref key) => {\n+            let cons = cons_of_key(key);\n+            (cons.clone(), format!(\"{} task-begin\", cons))\n+        },\n+        Effect::QueryBegin(ref qmsg, ref cc) => {\n+            let cons = cons_of_query_msg(qmsg);\n+            (cons.clone(),\n+             format!(\"{} {}\",\n+                     cons,\n+                     match *cc {\n+                         CacheCase::Hit => \"hit\",\n+                         CacheCase::Miss => \"miss\",\n+                     }))\n+        }\n+    }\n+}\n+\n+// First return value is text; second return value is a CSS class\n+fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n+    use rustc::util::common::duration_to_secs_str;\n+    (duration_to_secs_str(dur.clone()),\n+     \"\".to_string()\n+    )\n+}\n+\n+fn html_of_fraction(frac: f64) -> (String, String) {\n+    let css = {\n+        if       frac > 0.50  { format!(\"frac-50\") }\n+        else if  frac > 0.40  { format!(\"frac-40\") }\n+        else if  frac > 0.30  { format!(\"frac-30\") }\n+        else if  frac > 0.20  { format!(\"frac-20\") }\n+        else if  frac > 0.10  { format!(\"frac-10\") }\n+        else if  frac > 0.05  { format!(\"frac-05\") }\n+        else if  frac > 0.02  { format!(\"frac-02\") }\n+        else if  frac > 0.01  { format!(\"frac-01\") }\n+        else if  frac > 0.001 { format!(\"frac-001\") }\n+        else                  { format!(\"frac-0\") }\n+    };\n+    let percent = frac * 100.0;\n+    if percent > 0.1 { (format!(\"{:.1}%\", percent), css) }\n+    else { (format!(\"< 0.1%\", ), css) }\n+}\n+\n+fn total_duration(traces: &Vec<Rec>) -> Duration {\n+    let mut sum : Duration = Duration::new(0,0);\n+    for t in traces.iter() {\n+        sum += t.dur_total;\n+    }\n+    return sum\n+}\n+\n+fn duration_div(nom: Duration, den: Duration) -> f64 {\n+    fn to_nanos(d: Duration) -> u64 {\n+        d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64\n+    }\n+\n+    to_nanos(nom) as f64 / to_nanos(den) as f64\n+}\n+\n+fn write_traces_rec(file: &mut File, traces: &Vec<Rec>, total: Duration, depth: usize) {\n+    for t in traces {\n+        let (eff_text, eff_css_classes) = html_of_effect(&t.effect);\n+        let (dur_text, dur_css_classes) = html_of_duration(&t.start, &t.dur_total);\n+        let fraction = duration_div(t.dur_total, total);\n+        let percent = fraction * 100.0;\n+        let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n+        write!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\\n\",\n+               depth,\n+               t.extent.len(),\n+               /* Heuristic for 'important' CSS class: */\n+               if t.extent.len() > 5 || percent >= 1.0 {\n+                   \" important\" }\n+               else { \"\" },\n+               eff_css_classes,\n+               dur_css_classes,\n+               frc_css_classes,\n+        ).unwrap();\n+        write!(file, \"<div class=\\\"eff\\\">{}</div>\\n\", eff_text).unwrap();\n+        write!(file, \"<div class=\\\"dur\\\">{}</div>\\n\", dur_text).unwrap();\n+        write!(file, \"<div class=\\\"frc\\\">{}</div>\\n\", frc_text).unwrap();\n+        write_traces_rec(file, &t.extent, total, depth + 1);\n+        write!(file, \"</div>\\n\").unwrap();\n+    }\n+}\n+\n+fn compute_counts_rec(counts: &mut HashMap<String,QueryMetric>, traces: &Vec<Rec>) {\n+    for t in traces.iter() {\n+        match t.effect {\n+            Effect::TimeBegin(ref msg) => {\n+                let qm = match counts.get(msg) {\n+                    Some(_qm) => { panic!(\"TimeBegin with non-unique, repeat message\") }\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_self: t.dur_self,\n+                        dur_total: t.dur_total,\n+                    }};\n+                counts.insert(msg.clone(), qm);\n+            },\n+            Effect::TaskBegin(ref key) => {\n+                let cons = cons_of_key(key);\n+                let qm = match counts.get(&cons) {\n+                    Some(qm) =>\n+                        QueryMetric{\n+                            count: qm.count + 1,\n+                            dur_self: qm.dur_self + t.dur_self,\n+                            dur_total: qm.dur_total + t.dur_total,\n+                        },\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_self: t.dur_self,\n+                        dur_total: t.dur_total,\n+                    }};\n+                counts.insert(cons, qm);\n+            },\n+            Effect::QueryBegin(ref qmsg, ref _cc) => {\n+                let qcons = cons_of_query_msg(qmsg);\n+                let qm = match counts.get(&qcons) {\n+                    Some(qm) =>\n+                        QueryMetric{\n+                            count: qm.count + 1,\n+                            dur_total: qm.dur_total + t.dur_total,\n+                            dur_self: qm.dur_self + t.dur_self\n+                        },\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_total: t.dur_total,\n+                        dur_self: t.dur_self,\n+                    }\n+                };\n+                counts.insert(qcons, qm);\n+            }\n+        }\n+        compute_counts_rec(counts, &t.extent)\n+    }\n+}\n+\n+pub fn write_counts(count_file: &mut File, counts: &mut HashMap<String,QueryMetric>) {\n+    use rustc::util::common::duration_to_secs_str;\n+    use std::cmp::Ordering;\n+\n+    let mut data = vec![];\n+    for (ref cons, ref qm) in counts.iter() {\n+        data.push((cons.clone(), qm.count.clone(), qm.dur_total.clone(), qm.dur_self.clone()));\n+    };\n+    data.sort_by(|&(_,_,_,self1),&(_,_,_,self2)|\n+                 if self1 > self2 { Ordering::Less } else { Ordering::Greater } );\n+    for (cons, count, dur_total, dur_self) in data {\n+        write!(count_file, \"{}, {}, {}, {}\\n\",\n+               cons, count,\n+               duration_to_secs_str(dur_total),\n+               duration_to_secs_str(dur_self)\n+        ).unwrap();\n+    }\n+}\n+\n+pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &Vec<Rec>) {\n+    let mut counts : HashMap<String,QueryMetric> = HashMap::new();\n+    compute_counts_rec(&mut counts, traces);\n+    write_counts(counts_file, &mut counts);\n+\n+    let total : Duration = total_duration(traces);\n+    write_traces_rec(html_file, traces, total, 0)\n+}\n+\n+pub fn write_style(html_file: &mut File) {\n+    write!(html_file,\"{}\", \"\n+body {\n+    font-family: sans-serif;\n+    background: black;\n+}\n+.trace {\n+    color: black;\n+    display: inline-block;\n+    border-style: solid;\n+    border-color: red;\n+    border-width: 1px;\n+    border-radius: 5px;\n+    padding: 0px;\n+    margin: 1px;\n+    font-size: 0px;\n+}\n+.task-begin {\n+    border-width: 1px;\n+    color: white;\n+    border-color: #ff8;\n+    font-size: 0px;\n+}\n+.miss {\n+    border-color: red;\n+    border-width: 1px;\n+}\n+.extent-0 {\n+    padding: 2px;\n+}\n+.time-begin {\n+    border-width: 4px;\n+    font-size: 12px;\n+    color: white;\n+    border-color: #afa;\n+}\n+.important {\n+    border-width: 3px;\n+    font-size: 12px;\n+    color: white;\n+    border-color: #f77;\n+}\n+.hit {\n+    padding: 0px;\n+    border-color: blue;\n+    border-width: 3px;\n+}\n+.eff {\n+  color: #fff;\n+  display: inline-block;\n+}\n+.frc {\n+  color: #7f7;\n+  display: inline-block;\n+}\n+.dur {\n+  display: none\n+}\n+.frac-50 {\n+  padding: 10px;\n+  border-width: 10px;\n+  font-size: 32px;\n+}\n+.frac-40 {\n+  padding: 8px;\n+  border-width: 8px;\n+  font-size: 24px;\n+}\n+.frac-30 {\n+  padding: 6px;\n+  border-width: 6px;\n+  font-size: 18px;\n+}\n+.frac-20 {\n+  padding: 4px;\n+  border-width: 6px;\n+  font-size: 16px;\n+}\n+.frac-10 {\n+  padding: 2px;\n+  border-width: 6px;\n+  font-size: 14px;\n+}\n+\").unwrap();\n+}"}, {"sha": "96264472b5f8e53e0fe752afd6f5d174ef6ebcdf", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -25,21 +25,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n         cfg.insert((tf, Some(feat)));\n     }\n \n-    let requested_features = sess.opts.cg.target_feature.split(',');\n-    let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n-    let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n-\n-    // If the target we're compiling for requests a static crt by default,\n-    // then see if the `-crt-static` feature was passed to disable that.\n-    // Otherwise if we don't have a static crt by default then see if the\n-    // `+crt-static` feature was passed.\n-    let crt_static = if sess.target.target.options.crt_static_default {\n-        !found_negative\n-    } else {\n-        found_positive\n-    };\n-\n-    if crt_static {\n+    if sess.crt_static_feature() {\n         cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n     }\n }"}, {"sha": "0f063542383dce0eeaf9f9ed152b8e9b6b51b131", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -83,19 +83,19 @@ impl Diagnostic {\n \n     pub fn new_with_code(level: Level, code: Option<String>, message: &str) -> Self {\n         Diagnostic {\n-            level: level,\n+            level,\n             message: vec![(message.to_owned(), Style::NoStyle)],\n-            code: code,\n+            code,\n             span: MultiSpan::new(),\n             children: vec![],\n             suggestions: vec![],\n         }\n     }\n \n     /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n-    /// cancelled or it will panic when dropped).\n+    /// canceled or it will panic when dropped).\n     /// BEWARE: if this DiagnosticBuilder is an error, then creating it will\n-    /// bump the error count on the Handler and cancelling it won't undo that.\n+    /// bump the error count on the Handler and canceling it won't undo that.\n     /// If you want to decrement the error count you should use `Handler::cancel`.\n     pub fn cancel(&mut self) {\n         self.level = Level::Cancelled;\n@@ -105,10 +105,6 @@ impl Diagnostic {\n         self.level == Level::Cancelled\n     }\n \n-    pub fn is_fatal(&self) -> bool {\n-        self.level == Level::Fatal\n-    }\n-\n     /// Add a span/label to be included in the resulting snippet.\n     /// This is pushed onto the `MultiSpan` that was created when the\n     /// diagnostic was first built. If you don't call this function at\n@@ -278,18 +274,10 @@ impl Diagnostic {\n         self.message.iter().map(|i| i.0.to_owned()).collect::<String>()\n     }\n \n-    pub fn set_message(&mut self, message: &str) {\n-        self.message = vec![(message.to_owned(), Style::NoStyle)];\n-    }\n-\n     pub fn styled_message(&self) -> &Vec<(String, Style)> {\n         &self.message\n     }\n \n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n     /// Used by a lint. Copies over all details *but* the \"main\n     /// message\".\n     pub fn copy_details_not_message(&mut self, from: &Diagnostic) {\n@@ -306,10 +294,10 @@ impl Diagnostic {\n            span: MultiSpan,\n            render_span: Option<RenderSpan>) {\n         let sub = SubDiagnostic {\n-            level: level,\n+            level,\n             message: vec![(message.to_owned(), Style::NoStyle)],\n-            span: span,\n-            render_span: render_span,\n+            span,\n+            render_span,\n         };\n         self.children.push(sub);\n     }\n@@ -322,10 +310,10 @@ impl Diagnostic {\n                            span: MultiSpan,\n                            render_span: Option<RenderSpan>) {\n         let sub = SubDiagnostic {\n-            level: level,\n-            message: message,\n-            span: span,\n-            render_span: render_span,\n+            level,\n+            message,\n+            span,\n+            render_span,\n         };\n         self.children.push(sub);\n     }"}, {"sha": "2c8d8b4691f0a10356be35771859713d382eb267", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -98,7 +98,7 @@ impl<'a> DiagnosticBuilder<'a> {\n             }\n         };\n \n-        self.handler.emitter.borrow_mut().emit(&self);\n+        self.handler.emit_db(&self);\n         self.cancel();\n \n         if is_error {\n@@ -110,6 +110,22 @@ impl<'a> DiagnosticBuilder<'a> {\n         // }\n     }\n \n+    /// Delay emission of this diagnostic as a bug.\n+    ///\n+    /// This can be useful in contexts where an error indicates a bug but\n+    /// typically this only happens when other compilation errors have already\n+    /// happened. In those cases this can be used to defer emission of this\n+    /// diagnostic as a bug in the compiler only if no other errors have been\n+    /// emitted.\n+    ///\n+    /// In the meantime, though, callsites are required to deal with the \"bug\"\n+    /// locally in whichever way makes the most sense.\n+    pub fn delay_as_bug(&mut self) {\n+        self.level = Level::Bug;\n+        *self.handler.delayed_span_bug.borrow_mut() = Some(self.diagnostic.clone());\n+        self.cancel();\n+    }\n+\n     /// Add a span/label to be included in the resulting snippet.\n     /// This is pushed onto the `MultiSpan` that was created when the\n     /// diagnostic was first built. If you don't call this function at\n@@ -178,17 +194,15 @@ impl<'a> DiagnosticBuilder<'a> {\n                          code: Option<String>,\n                          message: &str)\n                          -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder {\n-            handler: handler,\n-            diagnostic: Diagnostic::new_with_code(level, code, message)\n-        }\n+        let diagnostic = Diagnostic::new_with_code(level, code, message);\n+        DiagnosticBuilder::new_diagnostic(handler, diagnostic)\n     }\n \n-    pub fn into_diagnostic(mut self) -> Diagnostic {\n-        // annoyingly, the Drop impl means we can't actually move\n-        let result = self.diagnostic.clone();\n-        self.cancel();\n-        result\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic)\n+                         -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder { handler, diagnostic }\n     }\n }\n \n@@ -198,7 +212,7 @@ impl<'a> Debug for DiagnosticBuilder<'a> {\n     }\n }\n \n-/// Destructor bomb - a `DiagnosticBuilder` must be either emitted or cancelled\n+/// Destructor bomb - a `DiagnosticBuilder` must be either emitted or canceled\n /// or we emit a bug.\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {"}, {"sha": "53d90531cc946a4c043d7c7983200f0f6ffc1228", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -120,7 +120,7 @@ impl EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n             EmitterWriter {\n-                dst: dst,\n+                dst,\n                 cm: code_map,\n             }\n         } else {\n@@ -156,7 +156,7 @@ impl EmitterWriter {\n                     }\n                     // We don't have a line yet, create one\n                     slot.lines.push(Line {\n-                        line_index: line_index,\n+                        line_index,\n                         annotations: vec![ann],\n                     });\n                     slot.lines.sort();\n@@ -165,9 +165,9 @@ impl EmitterWriter {\n             }\n             // This is the first time we're seeing the file\n             file_vec.push(FileWithAnnotatedLines {\n-                file: file,\n+                file,\n                 lines: vec![Line {\n-                                line_index: line_index,\n+                                line_index,\n                                 annotations: vec![ann],\n                             }],\n                 multiline_depth: 0,\n@@ -311,7 +311,9 @@ impl EmitterWriter {\n         if line.annotations.len() == 1 {\n             if let Some(ref ann) = line.annotations.get(0) {\n                 if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n-                    if source_string[0..ann.start_col].trim() == \"\" {\n+                    if source_string.chars()\n+                                    .take(ann.start_col)\n+                                    .all(|c| c.is_whitespace()) {\n                         let style = if ann.is_primary {\n                             Style::UnderlinePrimary\n                         } else {\n@@ -822,7 +824,7 @@ impl EmitterWriter {\n             .map(|_| \" \")\n             .collect::<String>();\n \n-        /// Return wether `style`, or the override if present and the style is `NoStyle`.\n+        /// Return whether `style`, or the override if present and the style is `NoStyle`.\n         fn style_or_override(style: Style, override_style: Option<Style>) -> Style {\n             if let Some(o) = override_style {\n                 if style == Style::NoStyle {"}, {"sha": "870bb01bb9ffb7963ff6a6b6057721a690e28c31", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_name = \"rustc_errors\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -19,10 +16,11 @@\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n #![feature(range_contains)]\n-#![feature(libc)]\n+#![cfg_attr(unix, feature(libc))]\n #![feature(conservative_impl_trait)]\n \n extern crate term;\n+#[cfg(unix)]\n extern crate libc;\n extern crate serialize as rustc_serialize;\n extern crate syntax_pos;\n@@ -35,11 +33,12 @@ use emitter::{Emitter, EmitterWriter};\n \n use std::borrow::Cow;\n use std::cell::{RefCell, Cell};\n-use std::{error, fmt};\n+use std::mem;\n use std::rc::Rc;\n+use std::{error, fmt};\n \n-pub mod diagnostic;\n-pub mod diagnostic_builder;\n+mod diagnostic;\n+mod diagnostic_builder;\n pub mod emitter;\n mod snippet;\n pub mod registry;\n@@ -111,7 +110,7 @@ impl CodeSuggestion {\n     }\n \n     /// Returns the number of substitutions\n-    pub fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n+    fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n         self.substitution_parts.iter().map(|sub| sub.span)\n     }\n \n@@ -155,8 +154,8 @@ impl CodeSuggestion {\n         let lo = primary_spans.iter().map(|sp| sp.0.lo).min().unwrap();\n         let hi = primary_spans.iter().map(|sp| sp.0.hi).min().unwrap();\n         let bounding_span = Span {\n-            lo: lo,\n-            hi: hi,\n+            lo,\n+            hi,\n             ctxt: NO_EXPANSION,\n         };\n         let lines = cm.span_to_lines(bounding_span).unwrap();\n@@ -217,8 +216,10 @@ impl CodeSuggestion {\n             if !buf.ends_with('\\n') {\n                 push_trailing(buf, prev_line.as_ref(), &prev_hi, None);\n             }\n-            // remove trailing newline\n-            buf.pop();\n+            // remove trailing newlines\n+            while buf.ends_with('\\n') {\n+                buf.pop();\n+            }\n         }\n         bufs\n     }\n@@ -260,7 +261,7 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n-pub use diagnostic::{Diagnostic, SubDiagnostic, DiagnosticStyledString, StringPart};\n+pub use diagnostic::{Diagnostic, SubDiagnostic, DiagnosticStyledString};\n pub use diagnostic_builder::DiagnosticBuilder;\n \n /// A handler deals with errors; certain errors\n@@ -272,7 +273,8 @@ pub struct Handler {\n     pub can_emit_warnings: bool,\n     treat_err_as_bug: bool,\n     continue_after_error: Cell<bool>,\n-    delayed_span_bug: RefCell<Option<(MultiSpan, String)>>,\n+    delayed_span_bug: RefCell<Option<Diagnostic>>,\n+    tracked_diagnostics: RefCell<Option<Vec<Diagnostic>>>,\n }\n \n impl Handler {\n@@ -292,10 +294,11 @@ impl Handler {\n         Handler {\n             err_count: Cell::new(0),\n             emitter: RefCell::new(e),\n-            can_emit_warnings: can_emit_warnings,\n-            treat_err_as_bug: treat_err_as_bug,\n+            can_emit_warnings,\n+            treat_err_as_bug,\n             continue_after_error: Cell::new(true),\n             delayed_span_bug: RefCell::new(None),\n+            tracked_diagnostics: RefCell::new(None),\n         }\n     }\n \n@@ -437,8 +440,9 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        let mut delayed = self.delayed_span_bug.borrow_mut();\n-        *delayed = Some((sp.into(), msg.to_string()));\n+        let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n+        diagnostic.set_span(sp.into());\n+        *self.delayed_span_bug.borrow_mut() = Some(diagnostic);\n     }\n     pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Bug);\n@@ -489,7 +493,7 @@ impl Handler {\n         self.bug(&format!(\"unimplemented {}\", msg));\n     }\n \n-    pub fn bump_err_count(&self) {\n+    fn bump_err_count(&self) {\n         self.panic_if_treat_err_as_bug();\n         self.err_count.set(self.err_count.get() + 1);\n     }\n@@ -505,14 +509,9 @@ impl Handler {\n         let s;\n         match self.err_count.get() {\n             0 => {\n-                let delayed_bug = self.delayed_span_bug.borrow();\n-                match *delayed_bug {\n-                    Some((ref span, ref errmsg)) => {\n-                        self.span_bug(span.clone(), errmsg);\n-                    }\n-                    _ => {}\n+                if let Some(bug) = self.delayed_span_bug.borrow_mut().take() {\n+                    DiagnosticBuilder::new_diagnostic(self, bug).emit();\n                 }\n-\n                 return;\n             }\n             1 => s = \"aborting due to previous error\".to_string(),\n@@ -545,6 +544,24 @@ impl Handler {\n             self.abort_if_errors();\n         }\n     }\n+\n+    pub fn track_diagnostics<F, R>(&self, f: F) -> (R, Vec<Diagnostic>)\n+        where F: FnOnce() -> R\n+    {\n+        let prev = mem::replace(&mut *self.tracked_diagnostics.borrow_mut(),\n+                                Some(Vec::new()));\n+        let ret = f();\n+        let diagnostics = mem::replace(&mut *self.tracked_diagnostics.borrow_mut(), prev)\n+            .unwrap();\n+        (ret, diagnostics)\n+    }\n+\n+    fn emit_db(&self, db: &DiagnosticBuilder) {\n+        if let Some(ref mut list) = *self.tracked_diagnostics.borrow_mut() {\n+            list.push((**db).clone());\n+        }\n+        self.emitter.borrow_mut().emit(db);\n+    }\n }\n \n \n@@ -569,7 +586,7 @@ impl fmt::Display for Level {\n }\n \n impl Level {\n-    pub fn color(self) -> term::color::Color {\n+    fn color(self) -> term::color::Color {\n         match self {\n             Bug | Fatal | PhaseFatal | Error => term::color::BRIGHT_RED,\n             Warning => {\n@@ -596,12 +613,3 @@ impl Level {\n         }\n     }\n }\n-\n-pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T\n-    where M: FnOnce() -> String\n-{\n-    match opt {\n-        Some(t) => t,\n-        None => diag.bug(&msg()),\n-    }\n-}"}, {"sha": "52e3fcc1b474c638de8d64c6b4672ba45ba9e01f", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -141,7 +141,7 @@ pub struct Annotation {\n }\n \n impl Annotation {\n-    /// Wether this annotation is a vertical line placeholder.\n+    /// Whether this annotation is a vertical line placeholder.\n     pub fn is_line(&self) -> bool {\n         if let AnnotationType::MultilineLine(_) = self.annotation_type {\n             true"}, {"sha": "1d58d17996090b7b11a49f78d123831d0cf8cec2", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -76,7 +76,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     // Find annotations supplied by user (if any).\n     let (if_this_changed, then_this_would_need) = {\n-        let mut visitor = IfThisChanged { tcx: tcx,\n+        let mut visitor = IfThisChanged { tcx,\n                                           if_this_changed: vec![],\n                                           then_this_would_need: vec![] };\n         visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir.krate().attrs);"}, {"sha": "94400890c56411449c999af58b676de2046b6846", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -62,10 +62,6 @@ impl IncrementalHashesMap {\n         }\n     }\n \n-    pub fn get(&self, k: &DepNode) -> Option<&Fingerprint> {\n-        self.hashes.get(k)\n-    }\n-\n     pub fn insert(&mut self, k: DepNode, v: Fingerprint) {\n         assert!(self.hashes.insert(k, v).is_none());\n     }"}, {"sha": "8870033095c9c2a1106ddd91d3d88ca049367cb3", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -10,9 +10,6 @@\n \n //! Support for serializing the dep-graph and reloading it.\n \n-#![crate_name = \"rustc_incremental\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -44,4 +41,3 @@ pub use persist::save_trans_partition;\n pub use persist::save_work_products;\n pub use persist::in_incr_comp_dir;\n pub use persist::finalize_session_directory;\n-pub use persist::delete_workproduct_files;"}, {"sha": "126057fd043f82cc787f91986aacb95d50a3f43e", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -83,15 +83,15 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.hir.krate();\n     let mut dirty_clean_visitor = DirtyCleanVisitor {\n-        tcx: tcx,\n+        tcx,\n         query: &query,\n-        dirty_inputs: dirty_inputs,\n+        dirty_inputs,\n         checked_attrs: FxHashSet(),\n     };\n     krate.visit_all_item_likes(&mut dirty_clean_visitor);\n \n     let mut all_attrs = FindAllAttrs {\n-        tcx: tcx,\n+        tcx,\n         attr_names: vec![ATTR_DIRTY, ATTR_CLEAN],\n         found_attrs: vec![],\n     };\n@@ -243,15 +243,15 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(\n     tcx.dep_graph.with_ignore(||{\n         let krate = tcx.hir.krate();\n         let mut dirty_clean_visitor = DirtyCleanMetadataVisitor {\n-            tcx: tcx,\n-            prev_metadata_hashes: prev_metadata_hashes,\n-            current_metadata_hashes: current_metadata_hashes,\n+            tcx,\n+            prev_metadata_hashes,\n+            current_metadata_hashes,\n             checked_attrs: FxHashSet(),\n         };\n         intravisit::walk_crate(&mut dirty_clean_visitor, krate);\n \n         let mut all_attrs = FindAllAttrs {\n-            tcx: tcx,\n+            tcx,\n             attr_names: vec![ATTR_DIRTY_METADATA, ATTR_CLEAN_METADATA],\n             found_attrs: vec![],\n         };"}, {"sha": "9d762a74bfe670510d2760b61626834d9fa0154c", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -38,8 +38,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                incremental_hashes_map: &'a IncrementalHashesMap)\n                -> Self {\n         HashContext {\n-            tcx: tcx,\n-            incremental_hashes_map: incremental_hashes_map,\n+            tcx,\n+            incremental_hashes_map,\n             metadata_hashes: FxHashMap(),\n             crate_hashes: FxHashMap(),\n         }"}, {"sha": "5c1582daa78fa07119caa53219831e699ed60e88", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -28,4 +28,3 @@ pub use self::load::load_dep_graph;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n pub use self::work_product::save_trans_partition;\n-pub use self::work_product::delete_workproduct_files;"}, {"sha": "aa29afd543c77f8f400ff256d3bf276f07334e53", "filename": "src/librustc_incremental/persist/preds/compress/classify/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'g, N, I, O> Classify<'a, 'g, N, I, O>\n {\n     pub(super) fn new(r: &'a mut GraphReduce<'g, N, I, O>) -> Self {\n         Classify {\n-            r: r,\n+            r,\n             colors: vec![Color::White; r.in_graph.len_nodes()],\n             stack: vec![],\n             dag: Dag {"}, {"sha": "0ad8d1789167df38a7cb9e0a882a64b42d7a2c65", "filename": "src/librustc_incremental/persist/preds/compress/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -14,7 +14,7 @@\n //! representation of the DAG):\n //!\n //! - SCCs, in the form of a union-find repr that can convert each node to\n-//!   its *cycle head* (an arbitrarly chosen representative from the cycle)\n+//!   its *cycle head* (an arbitrarily chosen representative from the cycle)\n //! - a vector of *leaf nodes*, just a convenience\n //! - a vector of *parents* for each node (in some cases, nodes have no parents,\n //!   or their parent is another member of same cycle; in that case, the vector"}, {"sha": "5483134523c47daa5515ad5c87f465f59d273aea", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -103,8 +103,8 @@ impl<'q> Predecessors<'q> {\n \n         Predecessors {\n             reduced_graph: graph,\n-            bootstrap_outputs: bootstrap_outputs,\n-            hashes: hashes,\n+            bootstrap_outputs,\n+            hashes,\n         }\n     }\n }"}, {"sha": "e20d7a006b0ddb0844ec0a88f54eba4624447c36", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -57,7 +57,7 @@ pub fn save_trans_partition(sess: &Session,\n     let work_product = WorkProduct {\n         cgu_name: cgu_name.to_string(),\n         input_hash: partition_hash,\n-        saved_files: saved_files,\n+        saved_files,\n     };\n \n     sess.dep_graph.insert_work_product(&work_product_id, work_product);"}, {"sha": "5ef277f02ace6b6cb59f4ec0855720c4b0e8aac2", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -19,9 +19,6 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![crate_name = \"rustc_lint\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -45,10 +42,10 @@ extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n-pub use rustc::lint;\n-pub use rustc::middle;\n-pub use rustc::session;\n-pub use rustc::util;\n+use rustc::lint;\n+use rustc::middle;\n+use rustc::session;\n+use rustc::util;\n \n use session::Session;\n use lint::LintId;"}, {"sha": "cbc4ebe90fd091070c9ec648f8b049d8905254df", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -160,21 +160,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         };\n \n         let mut fn_warned = false;\n-        let maybe_def = match expr.node {\n-            hir::ExprCall(ref callee, _) => {\n-                match callee.node {\n-                    hir::ExprPath(ref qpath) => Some(cx.tables.qpath_def(qpath, callee.hir_id)),\n-                    _ => None\n-                }\n-            },\n-            hir::ExprMethodCall(..) => {\n-                cx.tables.type_dependent_defs().get(expr.hir_id).cloned()\n-            },\n-            _ => { None }\n-        };\n-        if let Some(def) = maybe_def {\n-            let def_id = def.def_id();\n-            fn_warned = check_must_use(cx, def_id, s.span, \"return value of \");\n+        if cx.tcx.sess.features.borrow().fn_must_use {\n+            let maybe_def = match expr.node {\n+                hir::ExprCall(ref callee, _) => {\n+                    match callee.node {\n+                        hir::ExprPath(ref qpath) => {\n+                            Some(cx.tables.qpath_def(qpath, callee.hir_id))\n+                        },\n+                        _ => None\n+                    }\n+                },\n+                hir::ExprMethodCall(..) => {\n+                    cx.tables.type_dependent_defs().get(expr.hir_id).cloned()\n+                },\n+                _ => None\n+            };\n+            if let Some(def) = maybe_def {\n+                let def_id = def.def_id();\n+                fn_warned = check_must_use(cx, def_id, s.span, \"return value of \");\n+            }\n         }\n \n         if !(ty_warned || fn_warned) {"}, {"sha": "6c3626cd880b2f8cedd1d6c9ed05823a46f25a7c", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -94,7 +94,7 @@ impl<'a> Iterator for Iter<'a> {\n             ::last_error().map(Err)\n         } else {\n             Some(Ok(Child {\n-                ptr: ptr,\n+                ptr,\n                 _data: marker::PhantomData,\n             }))\n         }"}, {"sha": "c5cdf6566921c4c9d10acb7397da9435800ab0eb", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -82,12 +82,12 @@ impl OptimizationDiagnostic {\n         }\n \n         OptimizationDiagnostic {\n-            kind: kind,\n+            kind,\n             pass_name: pass_name.expect(\"got a non-UTF8 pass name from LLVM\"),\n-            function: function,\n-            line: line,\n-            column: column,\n-            filename: filename,\n+            function,\n+            line,\n+            column,\n+            filename,\n             message: message.expect(\"got a non-UTF8 OptimizationDiagnostic message from LLVM\")\n         }\n     }"}, {"sha": "3c3e627ee4b36e71e5912ab5d1d1388bc699de6a", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -13,9 +13,6 @@\n #![allow(non_snake_case)]\n #![allow(dead_code)]\n \n-#![crate_name = \"rustc_llvm\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -38,9 +35,7 @@ pub use self::TypeKind::*;\n pub use self::AtomicRmwBinOp::*;\n pub use self::MetadataType::*;\n pub use self::CodeGenOptSize::*;\n-pub use self::DiagnosticKind::*;\n pub use self::CallConv::*;\n-pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n \n use std::str::FromStr;\n@@ -51,7 +46,7 @@ use libc::{c_uint, c_char, size_t};\n \n pub mod archive_ro;\n pub mod diagnostic;\n-pub mod ffi;\n+mod ffi;\n \n pub use ffi::*;\n \n@@ -120,7 +115,7 @@ impl FromStr for ArchiveKind {\n \n #[allow(missing_copy_implementations)]\n pub enum RustString_opaque {}\n-pub type RustStringRef = *mut RustString_opaque;\n+type RustStringRef = *mut RustString_opaque;\n type RustStringRepr = *mut RefCell<Vec<u8>>;\n \n /// Appending to a Rust string -- used by RawRustStringOstream.\n@@ -199,8 +194,8 @@ impl Attribute {\n \n // Memory-managed interface to target data.\n \n-pub struct TargetData {\n-    pub lltd: TargetDataRef,\n+struct TargetData {\n+    lltd: TargetDataRef,\n }\n \n impl Drop for TargetData {\n@@ -211,7 +206,7 @@ impl Drop for TargetData {\n     }\n }\n \n-pub fn mk_target_data(string_rep: &str) -> TargetData {\n+fn mk_target_data(string_rep: &str) -> TargetData {\n     let string_rep = CString::new(string_rep).unwrap();\n     TargetData { lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) } }\n }\n@@ -272,7 +267,7 @@ pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n     }\n }\n \n-pub fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n+fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n     unsafe {\n         let num_params = LLVMCountParams(llfn);\n         let mut params = Vec::with_capacity(num_params as usize);"}, {"sha": "40b75be36fefb061c7fcabb5a71f02853b0d2874", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -15,7 +15,6 @@ owning_ref = \"0.3.3\"\n proc_macro = { path = \"../libproc_macro\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "b1b3e92347a213468421455ec178ffe7f74aef8c", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n             body: lazy_body,\n             tables: lazy_tables,\n             nested_bodies: lazy_nested_bodies,\n-            rvalue_promotable_to_static: rvalue_promotable_to_static\n+            rvalue_promotable_to_static,\n         })\n     }\n }"}, {"sha": "4c25d03b441eaba7a9961c9804e4484a7cb0714f", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -162,8 +162,8 @@ enum LoadResult {\n impl<'a> CrateLoader<'a> {\n     pub fn new(sess: &'a Session, cstore: &'a CStore, local_crate_name: &str) -> Self {\n         CrateLoader {\n-            sess: sess,\n-            cstore: cstore,\n+            sess,\n+            cstore,\n             next_crate_num: cstore.next_crate_num(),\n             local_crate_name: Symbol::intern(local_crate_name),\n         }\n@@ -184,7 +184,7 @@ impl<'a> CrateLoader<'a> {\n                 };\n                 Some(ExternCrateInfo {\n                     ident: i.ident.name,\n-                    name: name,\n+                    name,\n                     id: i.id,\n                     dep_kind: if attr::contains_name(&i.attrs, \"no_link\") {\n                         DepKind::UnexportedMacrosOnly\n@@ -325,25 +325,25 @@ impl<'a> CrateLoader<'a> {\n             });\n \n         let mut cmeta = cstore::CrateMetadata {\n-            name: name,\n+            name,\n             extern_crate: Cell::new(None),\n             def_path_table: Rc::new(def_path_table),\n-            exported_symbols: exported_symbols,\n-            trait_impls: trait_impls,\n+            exported_symbols,\n+            trait_impls,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n             }),\n             root: crate_root,\n             blob: metadata,\n             cnum_map: RefCell::new(cnum_map),\n-            cnum: cnum,\n+            cnum,\n             codemap_import_info: RefCell::new(vec![]),\n             attribute_cache: RefCell::new([Vec::new(), Vec::new()]),\n             dep_kind: Cell::new(dep_kind),\n             source: cstore::CrateSource {\n-                dylib: dylib,\n-                rlib: rlib,\n-                rmeta: rmeta,\n+                dylib,\n+                rlib,\n+                rmeta,\n             },\n             // Initialize this with an empty set. The field is populated below\n             // after we were able to deserialize its contents.\n@@ -388,14 +388,14 @@ impl<'a> CrateLoader<'a> {\n             info!(\"falling back to a load\");\n             let mut locate_ctxt = locator::Context {\n                 sess: self.sess,\n-                span: span,\n-                ident: ident,\n+                span,\n+                ident,\n                 crate_name: name,\n                 hash: hash.map(|a| &*a),\n                 filesearch: self.sess.target_filesearch(path_kind),\n                 target: &self.sess.target.target,\n                 triple: &self.sess.opts.target_triple,\n-                root: root,\n+                root,\n                 rejected_via_hash: vec![],\n                 rejected_via_triple: vec![],\n                 rejected_via_kind: vec![],\n@@ -547,7 +547,7 @@ impl<'a> CrateLoader<'a> {\n         let mut target_only = false;\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n-            span: span,\n+            span,\n             ident: info.ident,\n             crate_name: info.name,\n             hash: None,\n@@ -596,9 +596,9 @@ impl<'a> CrateLoader<'a> {\n         };\n \n         ExtensionCrate {\n-            metadata: metadata,\n+            metadata,\n             dylib: dylib.map(|p| p.0),\n-            target_only: target_only,\n+            target_only,\n         }\n     }\n \n@@ -1221,9 +1221,9 @@ impl<'a> CrateLoader<'a> {\n                 .collect();\n             let lib = NativeLibrary {\n                 name: n,\n-                kind: kind,\n-                cfg: cfg,\n-                foreign_items: foreign_items,\n+                kind,\n+                cfg,\n+                foreign_items,\n             };\n             register_native_lib(self.sess, self.cstore, Some(m.span), lib);\n         }"}, {"sha": "0ed8ab2bc55968f50abb8f0a24bebb210614391e", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -32,7 +32,7 @@ use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n pub use rustc::middle::cstore::NativeLibraryKind::*;\n-pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n+pub use rustc::middle::cstore::{CrateSource, LibSource};\n \n pub use cstore_impl::{provide, provide_local};\n \n@@ -114,7 +114,7 @@ impl CStore {\n             statically_included_foreign_items: RefCell::new(FxHashSet()),\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n-            metadata_loader: metadata_loader,\n+            metadata_loader,\n         }\n     }\n \n@@ -142,14 +142,6 @@ impl CStore {\n         }\n     }\n \n-    pub fn reset(&self) {\n-        self.metas.borrow_mut().clear();\n-        self.extern_mod_crate_map.borrow_mut().clear();\n-        self.used_libraries.borrow_mut().clear();\n-        self.used_link_args.borrow_mut().clear();\n-        self.statically_included_foreign_items.borrow_mut().clear();\n-    }\n-\n     pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);"}, {"sha": "ad320a7ff3d1e659f8ee6a52e96bb6b337e3ff62", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -137,6 +137,8 @@ provide! { <'tcx> tcx, def_id, cdata,\n \n     dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats(&tcx.dep_graph)) }\n     is_panic_runtime => { cdata.is_panic_runtime(&tcx.dep_graph) }\n+    is_compiler_builtins => { cdata.is_compiler_builtins(&tcx.dep_graph) }\n+    has_global_allocator => { cdata.has_global_allocator(&tcx.dep_graph) }\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n }\n \n@@ -282,15 +284,15 @@ impl CrateStore for cstore::CStore {\n     {\n         self.get_crate_data(cnum).root.plugin_registrar_fn.map(|index| DefId {\n             krate: cnum,\n-            index: index\n+            index,\n         })\n     }\n \n     fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n     {\n         self.get_crate_data(cnum).root.macro_derive_registrar.map(|index| DefId {\n             krate: cnum,\n-            index: index\n+            index,\n         })\n     }\n "}, {"sha": "73b2e972b93ca81a803b18e9a695705f16f9ff32", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -69,7 +69,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n             cdata: self.cdata(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n-            tcx: tcx,\n+            tcx,\n             last_filemap_index: 0,\n             lazy_state: LazyState::NoNode,\n         }\n@@ -468,7 +468,7 @@ impl<'a, 'tcx> CrateMetadata {\n     fn local_def_id(&self, index: DefIndex) -> DefId {\n         DefId {\n             krate: self.cnum,\n-            index: index,\n+            index,\n         }\n     }\n \n@@ -703,7 +703,7 @@ impl<'a, 'tcx> CrateMetadata {\n                         for child_index in child.children.decode((self, sess)) {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n-                                    def: def,\n+                                    def,\n                                     ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n                                 });\n@@ -835,8 +835,8 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         ty::AssociatedItem {\n-            name: name,\n-            kind: kind,\n+            name,\n+            kind,\n             vis: item.visibility.decode(self),\n             defaultness: container.defaultness(),\n             def_id: self.local_def_id(id),\n@@ -892,7 +892,7 @@ impl<'a, 'tcx> CrateMetadata {\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        let result = Rc::__from_array(self.get_attributes(&item).into_boxed_slice());\n+        let result: Rc<[ast::Attribute]> = Rc::from(self.get_attributes(&item));\n         let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n         if vec_.len() < node_index + 1 {\n             vec_.resize(node_index + 1, None);"}, {"sha": "1dc5d695348c17644b8d1569486f2bdd137be264", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -422,16 +422,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 None\n             },\n \n-            crate_deps: crate_deps,\n-            dylib_dependency_formats: dylib_dependency_formats,\n-            lang_items: lang_items,\n-            lang_items_missing: lang_items_missing,\n-            native_libraries: native_libraries,\n-            codemap: codemap,\n-            def_path_table: def_path_table,\n-            impls: impls,\n-            exported_symbols: exported_symbols,\n-            index: index,\n+            crate_deps,\n+            dylib_dependency_formats,\n+            lang_items,\n+            lang_items_missing,\n+            native_libraries,\n+            codemap,\n+            def_path_table,\n+            impls,\n+            exported_symbols,\n+            index,\n         });\n \n         let total_bytes = self.position();\n@@ -719,23 +719,23 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names: arg_names,\n+                        arg_names,\n                         sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n                 };\n                 EntryKind::Method(self.lazy(&MethodData {\n-                    fn_data: fn_data,\n-                    container: container,\n+                    fn_data,\n+                    container,\n                     has_self: trait_item.method_has_self_argument,\n                 }))\n             }\n             ty::AssociatedKind::Type => EntryKind::AssociatedType(container),\n         };\n \n         Entry {\n-            kind: kind,\n+            kind,\n             visibility: self.lazy(&trait_item.vis),\n             span: self.lazy(&ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n@@ -805,8 +805,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     bug!()\n                 };\n                 EntryKind::Method(self.lazy(&MethodData {\n-                    fn_data: fn_data,\n-                    container: container,\n+                    fn_data,\n+                    container,\n                     has_self: impl_item.method_has_self_argument,\n                 }))\n             }\n@@ -828,7 +828,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         };\n \n         Entry {\n-            kind: kind,\n+            kind,\n             visibility: self.lazy(&impl_item.vis),\n             span: self.lazy(&ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n@@ -915,7 +915,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             }\n             hir::ItemFn(_, _, constness, .., body) => {\n                 let data = FnData {\n-                    constness: constness,\n+                    constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n                     sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n@@ -946,7 +946,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    struct_ctor: struct_ctor,\n+                    struct_ctor,\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n@@ -998,10 +998,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     });\n \n                 let data = ImplData {\n-                    polarity: polarity,\n-                    defaultness: defaultness,\n+                    polarity,\n+                    defaultness,\n                     parent_impl: parent,\n-                    coerce_unsized_info: coerce_unsized_info,\n+                    coerce_unsized_info,\n                     trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n \n@@ -1023,7 +1023,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         };\n \n         Entry {\n-            kind: kind,\n+            kind,\n             visibility: self.lazy(&ty::Visibility::from_hir(&item.vis, item.id, tcx)),\n             span: self.lazy(&item.span),\n             attributes: self.encode_attributes(&item.attrs),\n@@ -1333,7 +1333,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_impls()\");\n         let tcx = self.tcx;\n         let mut visitor = ImplVisitor {\n-            tcx: tcx,\n+            tcx,\n             impls: FxHashMap(),\n         };\n         tcx.hir.krate().visit_all_item_likes(&mut visitor);\n@@ -1412,7 +1412,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         };\n \n         Entry {\n-            kind: kind,\n+            kind,\n             visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.id, tcx)),\n             span: self.lazy(&nitem.span),\n             attributes: self.encode_attributes(&nitem.attrs),\n@@ -1653,14 +1653,14 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (root, metadata_hashes) = {\n         let mut ecx = EncodeContext {\n             opaque: opaque::Encoder::new(&mut cursor),\n-            tcx: tcx,\n-            link_meta: link_meta,\n-            exported_symbols: exported_symbols,\n+            tcx,\n+            link_meta,\n+            exported_symbols,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n             metadata_hashes: EncodedMetadataHashes::new(),\n-            compute_ich: compute_ich,\n+            compute_ich,\n         };\n \n         // Encode the rustc version string in a predictable location."}, {"sha": "69fbc9354610d9aabc1d94334069ab86e5249abe", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -100,32 +100,6 @@ impl<'tcx> LazySeq<Index> {\n             Some(Lazy::with_position(position as usize))\n         }\n     }\n-\n-    pub fn iter_enumerated<'a>(&self,\n-                               bytes: &'a [u8])\n-                               -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n-        let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n-        let lo_count = u32::from_le(words[0].get()) as usize;\n-        let lo = &words[1 .. lo_count + 1];\n-        let hi = &words[1 + lo_count ..];\n-\n-        lo.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n-            if pos == u32::MAX {\n-                None\n-            } else {\n-                let pos = u32::from_le(pos) as usize;\n-                Some((DefIndex::new(index), Lazy::with_position(pos)))\n-            }\n-        }).chain(hi.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n-            if pos == u32::MAX {\n-                None\n-            } else {\n-                let pos = u32::from_le(pos) as usize;\n-                Some((DefIndex::new(index + DefIndexAddressSpace::High.start()),\n-                                    Lazy::with_position(pos)))\n-            }\n-        }))\n-    }\n }\n \n #[repr(packed)]"}, {"sha": "1d2b6cc33d46a0942f968d938049b3bfd758b60a", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n             items: Index::new(ecx.tcx.hir.definitions().def_index_counts_lo_hi()),\n-            ecx: ecx,\n+            ecx,\n         }\n     }\n \n@@ -137,7 +137,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         if let Some(hash) = fingerprint {\n             ecx.metadata_hashes.hashes.push(EncodedMetadataHash {\n                 def_index: id.index,\n-                hash: hash,\n+                hash,\n             });\n         }\n "}, {"sha": "b9ad9086c039a6b2835734f66ab35c5288901a92", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -32,8 +32,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let tcx = ecx.tcx;\n         let compute_ich = ecx.compute_ich;\n         IsolatedEncoder {\n-            tcx: tcx,\n-            ecx: ecx,\n+            tcx,\n+            ecx,\n             hcx: if compute_ich {\n                 // We are always hashing spans for things in metadata because\n                 // don't know if a downstream crate will use them or not."}, {"sha": "f79abecf9da4b3ea2154783762dd7e7cdbeaa0a2", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_name = \"rustc_metadata\"]\n-#![crate_type = \"dylib\"]\n-#![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -42,13 +39,10 @@ extern crate proc_macro;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_back;\n-extern crate rustc_const_math;\n extern crate rustc_data_structures;\n \n mod diagnostics;\n \n-pub use rustc::middle;\n-\n mod astencode;\n mod index_builder;\n mod index;"}, {"sha": "19f7cb0ee238a72b82e501a0fb7b7462479e3989", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -306,10 +306,6 @@ impl<'a> Context<'a> {\n         self.find_library_crate()\n     }\n \n-    pub fn load_library_crate(&mut self) -> Library {\n-        self.find_library_crate().unwrap_or_else(|| self.report_errs())\n-    }\n-\n     pub fn report_errs(&mut self) -> ! {\n         let add = match self.root {\n             &None => String::new(),\n@@ -518,9 +514,9 @@ impl<'a> Context<'a> {\n             if let Some((h, m)) = slot {\n                 libraries.insert(h,\n                                  Library {\n-                                     dylib: dylib,\n-                                     rlib: rlib,\n-                                     rmeta: rmeta,\n+                                     dylib,\n+                                     rlib,\n+                                     rmeta,\n                                      metadata: m,\n                                  });\n             }\n@@ -808,10 +804,10 @@ impl<'a> Context<'a> {\n         match slot {\n             Some((_, metadata)) => {\n                 Some(Library {\n-                    dylib: dylib,\n-                    rlib: rlib,\n-                    rmeta: rmeta,\n-                    metadata: metadata,\n+                    dylib,\n+                    rlib,\n+                    rmeta,\n+                    metadata,\n                 })\n             }\n             None => None,"}, {"sha": "b71f4d0d98cf9aba4d7e3950d17e7cf4c4677704", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -84,7 +84,7 @@ pub struct Lazy<T> {\n impl<T> Lazy<T> {\n     pub fn with_position(position: usize) -> Lazy<T> {\n         Lazy {\n-            position: position,\n+            position,\n             _marker: PhantomData,\n         }\n     }\n@@ -141,8 +141,8 @@ impl<T> LazySeq<T> {\n \n     pub fn with_position_and_length(position: usize, len: usize) -> LazySeq<T> {\n         LazySeq {\n-            len: len,\n-            position: position,\n+            len,\n+            position,\n             _marker: PhantomData,\n         }\n     }\n@@ -199,7 +199,7 @@ pub struct Tracked<T> {\n impl<T> Tracked<T> {\n     pub fn new(state: T) -> Tracked<T> {\n         Tracked {\n-            state: state,\n+            state,\n         }\n     }\n "}, {"sha": "49e626c540082869d2b45f330c3badb0227adb4a", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -15,6 +15,7 @@ rustc = { path = \"../librustc\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "eda2bacb11fdc133e2d2dd1a238b0cc08f173d1c", "filename": "src/librustc_mir/borrow_check.rs", "status": "added", "additions": 1258, "deletions": 0, "changes": 1258, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -0,0 +1,1258 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This query borrow-checks the MIR to (further) ensure it is not broken.\n+\n+use rustc::hir::def_id::{DefId};\n+use rustc::infer::{InferCtxt};\n+use rustc::ty::{self, TyCtxt, ParamEnv};\n+use rustc::ty::maps::Providers;\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue};\n+use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n+use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n+use rustc::mir::transform::{MirSource};\n+\n+use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::{Idx};\n+\n+use syntax::ast::{self};\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+use dataflow::{do_dataflow};\n+use dataflow::{MoveDataParamEnv};\n+use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n+use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{Borrows, BorrowData, BorrowIndex};\n+use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+use self::MutateMode::{JustWrite, WriteAndRead};\n+use self::ConsumeKind::{Consume};\n+\n+\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        mir_borrowck,\n+        ..*providers\n+    };\n+}\n+\n+fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    let mir = tcx.mir_validated(def_id);\n+    let src = MirSource::from_local_def_id(tcx, def_id);\n+    debug!(\"run query mir_borrowck: {}\", tcx.node_path_str(src.item_id()));\n+\n+    let mir: &Mir<'tcx> = &mir.borrow();\n+    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.opts.debugging_opts.borrowck_mir {\n+        return;\n+    }\n+\n+    let id = src.item_id();\n+    let attributes = tcx.get_attrs(def_id);\n+    let param_env = tcx.param_env(def_id);\n+    tcx.infer_ctxt().enter(|_infcx| {\n+\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+        let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                       Borrows::new(tcx, mir),\n+                                       |bd, i| bd.location(i));\n+        let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                     MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                                     |bd, i| &bd.move_data().move_paths[i]);\n+        let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                       MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                                       |bd, i| &bd.move_data().move_paths[i]);\n+\n+        let mut mbcx = MirBorrowckCtxt {\n+            tcx: tcx,\n+            mir: mir,\n+            node_id: id,\n+            move_data: &mdpe.move_data,\n+            param_env: param_env,\n+            fake_infer_ctxt: &_infcx,\n+        };\n+\n+        let mut state = InProgress::new(flow_borrows,\n+                                        flow_inits,\n+                                        flow_uninits);\n+\n+        mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+    });\n+\n+    debug!(\"mir_borrowck done\");\n+}\n+\n+#[allow(dead_code)]\n+pub struct MirBorrowckCtxt<'c, 'b, 'a: 'b+'c, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    mir: &'b Mir<'gcx>,\n+    node_id: ast::NodeId,\n+    move_data: &'b MoveData<'gcx>,\n+    param_env: ParamEnv<'tcx>,\n+    fake_infer_ctxt: &'c InferCtxt<'c, 'gcx, 'tcx>,\n+}\n+\n+// (forced to be `pub` due to its use as an associated type below.)\n+pub struct InProgress<'b, 'tcx: 'b> {\n+    borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n+    inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n+    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n+}\n+\n+struct FlowInProgress<BD> where BD: BitDenotation {\n+    base_results: DataflowResults<BD>,\n+    curr_state: IdxSetBuf<BD::Idx>,\n+    stmt_gen: IdxSetBuf<BD::Idx>,\n+    stmt_kill: IdxSetBuf<BD::Idx>,\n+}\n+\n+// Check that:\n+// 1. assignments are always made to mutable locations (FIXME: does that still really go here?)\n+// 2. loans made in overlapping scopes do not conflict\n+// 3. assignments do not affect things loaned out as immutable\n+// 4. moves do not affect things loaned out in any way\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n+    for MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n+{\n+    type FlowState = InProgress<'b, 'gcx>;\n+\n+    fn mir(&self) -> &'b Mir<'gcx> { self.mir }\n+\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n+                             |i| i.reset_to_entry_of(bb),\n+                             |u| u.reset_to_entry_of(bb));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self,\n+                                    location: Location,\n+                                    flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reconstruct_statement_effect(location),\n+                             |i| i.reconstruct_statement_effect(location),\n+                             |u| u.reconstruct_statement_effect(location));\n+    }\n+\n+    fn apply_local_effect(&mut self,\n+                          _location: Location,\n+                          flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.apply_local_effect(),\n+                             |i| i.apply_local_effect(),\n+                             |u| u.apply_local_effect());\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self,\n+                                     location: Location,\n+                                     flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reconstruct_terminator_effect(location),\n+                             |i| i.reconstruct_terminator_effect(location),\n+                             |u| u.reconstruct_terminator_effect(location));\n+    }\n+\n+    fn visit_block_entry(&mut self,\n+                         bb: BasicBlock,\n+                         flow_state: &Self::FlowState) {\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, summary);\n+    }\n+\n+    fn visit_statement_entry(&mut self,\n+                             location: Location,\n+                             stmt: &Statement<'gcx>,\n+                             flow_state: &Self::FlowState) {\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, summary);\n+        let span = stmt.source_info.span;\n+        match stmt.kind {\n+            StatementKind::Assign(ref lhs, ref rhs) => {\n+                self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n+                                   (lhs, span), JustWrite, flow_state);\n+                self.consume_rvalue(ContextKind::AssignRhs.new(location),\n+                                    (rhs, span), location, flow_state);\n+            }\n+            StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n+                self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n+                                   (lvalue, span), JustWrite, flow_state);\n+            }\n+            StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                for (o, output) in asm.outputs.iter().zip(outputs) {\n+                    if o.is_indirect {\n+                        self.consume_lvalue(ContextKind::InlineAsm.new(location),\n+                                            Consume,\n+                                            (output, span),\n+                                            flow_state);\n+                    } else {\n+                        self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n+                                           (output, span),\n+                                           if o.is_rw { WriteAndRead } else { JustWrite },\n+                                           flow_state);\n+                    }\n+                }\n+                for input in inputs {\n+                    self.consume_operand(ContextKind::InlineAsm.new(location),\n+                                         Consume,\n+                                         (input, span), flow_state);\n+                }\n+            }\n+            StatementKind::EndRegion(ref _rgn) => {\n+                // ignored when consuming results (update to\n+                // flow_state already handled).\n+            }\n+            StatementKind::Nop |\n+            StatementKind::Validate(..) |\n+            StatementKind::StorageLive(..) => {\n+                // ignored by borrowck\n+            }\n+\n+            StatementKind::StorageDead(ref lvalue) => {\n+                // causes non-drop values to be dropped.\n+                self.consume_lvalue(ContextKind::StorageDead.new(location),\n+                                    ConsumeKind::Consume,\n+                                    (lvalue, span),\n+                                    flow_state)\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator_entry(&mut self,\n+                              location: Location,\n+                              term: &Terminator<'gcx>,\n+                              flow_state: &Self::FlowState) {\n+        let loc = location;\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\", location, term, summary);\n+        let span = term.source_info.span;\n+        match term.kind {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n+                self.consume_operand(ContextKind::SwitchInt.new(loc),\n+                                     Consume,\n+                                     (discr, span), flow_state);\n+            }\n+            TerminatorKind::Drop { location: ref drop_lvalue, target: _, unwind: _ } => {\n+                self.consume_lvalue(ContextKind::Drop.new(loc),\n+                                    ConsumeKind::Drop,\n+                                    (drop_lvalue, span), flow_state);\n+            }\n+            TerminatorKind::DropAndReplace { location: ref drop_lvalue,\n+                                             value: ref new_value,\n+                                             target: _,\n+                                             unwind: _ } => {\n+                self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n+                                   (drop_lvalue, span), JustWrite, flow_state);\n+                self.consume_operand(ContextKind::DropAndReplace.new(loc),\n+                                     ConsumeKind::Drop,\n+                                     (new_value, span), flow_state);\n+            }\n+            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                self.consume_operand(ContextKind::CallOperator.new(loc),\n+                                     Consume,\n+                                     (func, span), flow_state);\n+                for arg in args {\n+                    self.consume_operand(ContextKind::CallOperand.new(loc),\n+                                         Consume,\n+                                         (arg, span), flow_state);\n+                }\n+                if let Some((ref dest, _/*bb*/)) = *destination {\n+                    self.mutate_lvalue(ContextKind::CallDest.new(loc),\n+                                       (dest, span), JustWrite, flow_state);\n+                }\n+            }\n+            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+                self.consume_operand(ContextKind::Assert.new(loc),\n+                                     Consume,\n+                                     (cond, span), flow_state);\n+                match *msg {\n+                    AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        self.consume_operand(ContextKind::Assert.new(loc),\n+                                             Consume,\n+                                             (len, span), flow_state);\n+                        self.consume_operand(ContextKind::Assert.new(loc),\n+                                             Consume,\n+                                             (index, span), flow_state);\n+                    }\n+                    AssertMessage::Math(_/*const_math_err*/) => {}\n+                }\n+            }\n+\n+            TerminatorKind::Goto { target: _ } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable => {\n+                // no data used, thus irrelevant to borrowck\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum MutateMode { JustWrite, WriteAndRead }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ConsumeKind { Drop, Consume }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Control { Continue, Break }\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn mutate_lvalue(&mut self,\n+                     context: Context,\n+                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     mode: MutateMode,\n+                     flow_state: &InProgress<'b, 'gcx>) {\n+        // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n+        match mode {\n+            MutateMode::WriteAndRead => {\n+                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+            MutateMode::JustWrite => {\n+                self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+        }\n+\n+        // check we don't invalidate any outstanding loans\n+        self.each_borrow_involving_path(context,\n+                                        lvalue_span.0, flow_state, |this, _index, _data| {\n+                                            this.report_illegal_mutation_of_borrowed(context,\n+                                                                                     lvalue_span);\n+                                            Control::Break\n+                                        });\n+\n+        // check for reassignments to immutable local variables\n+        self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n+    }\n+\n+    fn consume_rvalue(&mut self,\n+                      context: Context,\n+                      (rvalue, span): (&Rvalue<'gcx>, Span),\n+                      location: Location,\n+                      flow_state: &InProgress<'b, 'gcx>) {\n+        match *rvalue {\n+            Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n+                self.borrow(context, location, bk, (lvalue, span), flow_state)\n+            }\n+\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::UnaryOp(_/*un_op*/, ref operand) |\n+            Rvalue::Cast(_/*cast_kind*/, ref operand, _/*ty*/) => {\n+                self.consume_operand(context, Consume, (operand, span), flow_state)\n+            }\n+\n+            Rvalue::Len(ref lvalue) |\n+            Rvalue::Discriminant(ref lvalue) => {\n+                // len(_)/discriminant(_) merely read, not consume.\n+                self.check_if_path_is_moved(context, (lvalue, span), flow_state);\n+            }\n+\n+            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n+            Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n+                self.consume_operand(context, Consume, (operand1, span), flow_state);\n+                self.consume_operand(context, Consume, (operand2, span), flow_state);\n+            }\n+\n+            Rvalue::NullaryOp(_op, _ty) => {\n+                // nullary ops take no dynamic input; no borrowck effect.\n+                //\n+                // FIXME: is above actually true? Do we want to track\n+                // the fact that uninitialized data can be created via\n+                // `NullOp::Box`?\n+            }\n+\n+            Rvalue::Aggregate(ref _aggregate_kind, ref operands) => {\n+                for operand in operands {\n+                    self.consume_operand(context, Consume, (operand, span), flow_state);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn consume_operand(&mut self,\n+                       context: Context,\n+                       consume_via_drop: ConsumeKind,\n+                       (operand, span): (&Operand<'gcx>, Span),\n+                       flow_state: &InProgress<'b, 'gcx>) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) =>\n+                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state),\n+            Operand::Constant(_) => {}\n+        }\n+    }\n+\n+    fn consume_lvalue(&mut self,\n+                      context: Context,\n+                      consume_via_drop: ConsumeKind,\n+                      lvalue_span: (&Lvalue<'gcx>, Span),\n+                      flow_state: &InProgress<'b, 'gcx>) {\n+        let lvalue = lvalue_span.0;\n+        let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        let moves_by_default =\n+            self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n+        if moves_by_default {\n+            // move of lvalue: check if this is move of already borrowed path\n+            self.each_borrow_involving_path(\n+                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n+                    if !borrow.compatible_with(BorrowKind::Mut) {\n+                        this.report_move_out_while_borrowed(context, lvalue_span);\n+                        Control::Break\n+                    } else {\n+                        Control::Continue\n+                    }\n+                });\n+        } else {\n+            // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n+            self.each_borrow_involving_path(\n+                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n+                    if !borrow.compatible_with(BorrowKind::Shared) {\n+                        this.report_use_while_mutably_borrowed(context, lvalue_span);\n+                        Control::Break\n+                    } else {\n+                        Control::Continue\n+                    }\n+                });\n+        }\n+\n+        // Finally, check if path was already moved.\n+        match consume_via_drop {\n+            ConsumeKind::Drop => {\n+                // If path is merely being dropped, then we'll already\n+                // check the drop flag to see if it is moved (thus we\n+                // skip this check in that case).\n+            }\n+            ConsumeKind::Consume => {\n+                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+        }\n+    }\n+\n+    fn borrow(&mut self,\n+              context: Context,\n+              location: Location,\n+              bk: BorrowKind,\n+              lvalue_span: (&Lvalue<'gcx>, Span),\n+              flow_state: &InProgress<'b, 'gcx>) {\n+        debug!(\"borrow location: {:?} lvalue: {:?} span: {:?}\",\n+               location, lvalue_span.0, lvalue_span.1);\n+        self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+        self.check_for_conflicting_loans(context, location, bk, lvalue_span, flow_state);\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn check_if_reassignment_to_immutable_state(&mut self,\n+                                                context: Context,\n+                                                (lvalue, span): (&Lvalue<'gcx>, Span),\n+                                                flow_state: &InProgress<'b, 'gcx>) {\n+        let move_data = flow_state.inits.base_results.operator().move_data();\n+\n+        // determine if this path has a non-mut owner (and thus needs checking).\n+        let mut l = lvalue;\n+        loop {\n+            match *l {\n+                Lvalue::Projection(ref proj) => {\n+                    l = &proj.base;\n+                    continue;\n+                }\n+                Lvalue::Local(local) => {\n+                    match self.mir.local_decls[local].mutability {\n+                        Mutability::Not => break, // needs check\n+                        Mutability::Mut => return,\n+                    }\n+                }\n+                Lvalue::Static(_) => {\n+                    // mutation of non-mut static is always illegal,\n+                    // independent of dataflow.\n+                    self.report_assignment_to_static(context, (lvalue, span));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+            if flow_state.inits.curr_state.contains(&mpi) {\n+                // may already be assigned before reaching this statement;\n+                // report error.\n+                self.report_illegal_reassignment(context, (lvalue, span));\n+            }\n+        }\n+    }\n+\n+    fn check_if_path_is_moved(&mut self,\n+                              context: Context,\n+                              lvalue_span: (&Lvalue<'gcx>, Span),\n+                              flow_state: &InProgress<'b, 'gcx>) {\n+        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // its base_path ... but is that what we want here?\n+        let lvalue = self.base_path(lvalue_span.0);\n+\n+        let maybe_uninits = &flow_state.uninits;\n+        let move_data = maybe_uninits.base_results.operator().move_data();\n+        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+            if maybe_uninits.curr_state.contains(&mpi) {\n+                // find and report move(s) that could cause this to be uninitialized\n+                self.report_use_of_moved(context, lvalue_span);\n+            } else {\n+                // sanity check: initialized on *some* path, right?\n+                assert!(flow_state.inits.curr_state.contains(&mpi));\n+            }\n+        }\n+    }\n+\n+    fn move_path_for_lvalue(&mut self,\n+                            _context: Context,\n+                            move_data: &MoveData<'gcx>,\n+                            lvalue: &Lvalue<'gcx>)\n+                            -> Option<MovePathIndex>\n+    {\n+        // If returns None, then there is no move path corresponding\n+        // to a direct owner of `lvalue` (which means there is nothing\n+        // that borrowck tracks for its analysis).\n+\n+        match move_data.rev_lookup.find(lvalue) {\n+            LookupResult::Parent(_) => None,\n+            LookupResult::Exact(mpi) => Some(mpi),\n+        }\n+    }\n+\n+    fn check_if_assigned_path_is_moved(&mut self,\n+                                       context: Context,\n+                                       (lvalue, span): (&Lvalue<'gcx>, Span),\n+                                       flow_state: &InProgress<'b, 'gcx>) {\n+        // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n+        let mut lvalue = lvalue;\n+        loop {\n+            match *lvalue {\n+                Lvalue::Local(_) | Lvalue::Static(_) => {\n+                    // assigning to `x` does not require `x` be initialized.\n+                    break;\n+                }\n+                Lvalue::Projection(ref proj) => {\n+                    let Projection { ref base, ref elem } = **proj;\n+                    match *elem {\n+                        ProjectionElem::Deref |\n+                        // assigning to *P requires `P` initialized.\n+                        ProjectionElem::Index(_/*operand*/) |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        // assigning to P[i] requires `P` initialized.\n+                        ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n+                        // assigning to (P->variant) is okay if assigning to `P` is okay\n+                        //\n+                        // FIXME: is this true even if P is a adt with a dtor?\n+                        { }\n+\n+                        ProjectionElem::Subslice { .. } => {\n+                            panic!(\"we dont allow assignments to subslices, context: {:?}\",\n+                                   context);\n+                        }\n+\n+                        ProjectionElem::Field(..) => {\n+                            // if type of `P` has a dtor, then\n+                            // assigning to `P.f` requires `P` itself\n+                            // be already initialized\n+                            let tcx = self.tcx;\n+                            match base.ty(self.mir, tcx).to_ty(tcx).sty {\n+                                ty::TyAdt(def, _) if def.has_dtor(tcx) => {\n+\n+                                    // FIXME: analogous code in\n+                                    // check_loans.rs first maps\n+                                    // `base` to its base_path.\n+\n+                                    self.check_if_path_is_moved(context,\n+                                                                (base, span), flow_state);\n+\n+                                    // (base initialized; no need to\n+                                    // recur further)\n+                                    break;\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+\n+                    lvalue = base;\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_conflicting_loans(&mut self,\n+                                   context: Context,\n+                                   _location: Location,\n+                                   _bk: BorrowKind,\n+                                   lvalue_span: (&Lvalue<'gcx>, Span),\n+                                   flow_state: &InProgress<'b, 'gcx>) {\n+        // NOTE FIXME: The analogous code in old borrowck\n+        // check_loans.rs is careful to iterate over every *issued*\n+        // loan, as opposed to just the in scope ones.\n+        //\n+        // (Or if you prefer, all the *other* iterations over loans\n+        // only consider loans that are in scope of some given\n+        // CodeExtent)\n+        //\n+        // The (currently skeletal) code here does not encode such a\n+        // distinction, which means it is almost certainly over\n+        // looking something.\n+        //\n+        // (It is probably going to reject code that should be\n+        // accepted, I suspect, by treated issued-but-out-of-scope\n+        // loans as issued-and-in-scope, and thus causing them to\n+        // interfere with other loans.)\n+        //\n+        // However, I just want to get something running, especially\n+        // since I am trying to move into new territory with NLL, so\n+        // lets get this going first, and then address the issued vs\n+        // in-scope distinction later.\n+\n+        let state = &flow_state.borrows;\n+        let data = &state.base_results.operator().borrows();\n+\n+        debug!(\"check_for_conflicting_loans location: {:?}\", _location);\n+\n+        // does any loan generated here conflict with a previously issued loan?\n+        let mut loans_generated = 0;\n+        for (g, gen) in state.elems_generated().map(|g| (g, &data[g])) {\n+            loans_generated += 1;\n+            for (i, issued) in state.elems_incoming().map(|i| (i, &data[i])) {\n+                debug!(\"check_for_conflicting_loans gen: {:?} issued: {:?} conflicts: {}\",\n+                       (g, gen, self.base_path(&gen.lvalue),\n+                        self.restrictions(&gen.lvalue).collect::<Vec<_>>()),\n+                       (i, issued, self.base_path(&issued.lvalue),\n+                        self.restrictions(&issued.lvalue).collect::<Vec<_>>()),\n+                       self.conflicts_with(gen, issued));\n+                if self.conflicts_with(gen, issued) {\n+                    self.report_conflicting_borrow(context, lvalue_span, gen, issued);\n+                }\n+            }\n+        }\n+\n+        // MIR statically ensures each statement gens *at most one*\n+        // loan; mutual conflict (within a statement) can't arise.\n+        //\n+        // As safe-guard, assert that above property actually holds.\n+        assert!(loans_generated <= 1);\n+    } }\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn each_borrow_involving_path<F>(&mut self,\n+                                     _context: Context,\n+                                     lvalue: &Lvalue<'gcx>,\n+                                     flow_state: &InProgress<'b, 'gcx>,\n+                                     mut op: F)\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n+    {\n+        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // its base_path.\n+\n+        let domain = flow_state.borrows.base_results.operator();\n+        let data = domain.borrows();\n+\n+        // check for loan restricting path P being used. Accounts for\n+        // borrows of P, P.a.b, etc.\n+        for i in flow_state.borrows.elems_incoming() {\n+            // FIXME: check_loans.rs filtered this to \"in scope\"\n+            // loans; i.e. it took a scope S and checked that each\n+            // restriction's kill_scope was a superscope of S.\n+            let borrowed = &data[i];\n+            for restricted in self.restrictions(&borrowed.lvalue) {\n+                if restricted == lvalue {\n+                    let ctrl = op(self, i, borrowed);\n+                    if ctrl == Control::Break { return; }\n+                }\n+            }\n+        }\n+\n+        // check for loans (not restrictions) on any base path.\n+        // e.g. Rejects `{ let x = &mut a.b; let y = a.b.c; }`,\n+        // since that moves out of borrowed path `a.b`.\n+        //\n+        // Limiting to loans (not restrictions) keeps this one\n+        // working: `{ let x = &mut a.b; let y = a.c; }`\n+        let mut cursor = lvalue;\n+        loop {\n+            // FIXME: check_loans.rs invoked `op` *before* cursor\n+            // shift here.  Might just work (and even avoid redundant\n+            // errors?) given code above?  But for now, I want to try\n+            // doing what I think is more \"natural\" check.\n+            for i in flow_state.borrows.elems_incoming() {\n+                let borrowed = &data[i];\n+                if borrowed.lvalue == *cursor {\n+                    let ctrl = op(self, i, borrowed);\n+                    if ctrl == Control::Break { return; }\n+                }\n+            }\n+\n+            match *cursor {\n+                Lvalue::Local(_) | Lvalue::Static(_) => break,\n+                Lvalue::Projection(ref proj) => cursor = &proj.base,\n+            }\n+        }\n+    }\n+}\n+\n+mod restrictions {\n+    use super::MirBorrowckCtxt;\n+\n+    use rustc::hir;\n+    use rustc::ty::{self, TyCtxt};\n+    use rustc::mir::{Lvalue, Mir, Operand, ProjectionElem};\n+\n+    pub(super) struct Restrictions<'c, 'tcx: 'c> {\n+        mir: &'c Mir<'tcx>,\n+        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n+        lvalue_stack: Vec<&'c Lvalue<'tcx>>,\n+    }\n+\n+    impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        pub(super) fn restrictions<'d>(&self,\n+                                       lvalue: &'d Lvalue<'gcx>)\n+                                       -> Restrictions<'d, 'gcx> where 'b: 'd\n+        {\n+            let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n+            Restrictions { lvalue_stack: lvalue_stack, mir: self.mir, tcx: self.tcx }\n+        }\n+\n+        fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n+            let mut cursor = lvalue;\n+            loop {\n+                let proj = match *cursor {\n+                    Lvalue::Local(_) => return true,\n+                    Lvalue::Static(_) => return false,\n+                    Lvalue::Projection(ref proj) => proj,\n+                };\n+                match proj.elem {\n+                    ProjectionElem::Index(..) |\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Downcast(..) |\n+                    ProjectionElem::Subslice { .. } |\n+                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                        cursor = &proj.base;\n+                        continue;\n+                    }\n+                    ProjectionElem::Deref => {\n+                        let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        match ty.sty {\n+                            ty::TyRawPtr(_) => {\n+                                return false;\n+                            }\n+                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                                // FIXME: do I need to check validity of\n+                                // region here though? (I think the original\n+                                // check_loans code did, like readme says)\n+                                return false;\n+                            }\n+                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                                cursor = &proj.base;\n+                                continue;\n+                            }\n+                            ty::TyAdt(..) if ty.is_box() => {\n+                                cursor = &proj.base;\n+                                continue;\n+                            }\n+                            _ => {\n+                                panic!(\"unknown type fed to Projection Deref.\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<'c, 'tcx> Iterator for Restrictions<'c, 'tcx> {\n+        type Item = &'c Lvalue<'tcx>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            'pop: loop {\n+                let lvalue = match self.lvalue_stack.pop() {\n+                    None => return None,\n+                    Some(lvalue) => lvalue,\n+                };\n+\n+                // `lvalue` may not be a restriction itself, but may\n+                // hold one further down (e.g. we never return\n+                // downcasts here, but may return a base of a\n+                // downcast).\n+                //\n+                // Also, we need to enqueue any additional\n+                // subrestrictions that it implies, since we can only\n+                // return from from this call alone.\n+\n+                let mut cursor = lvalue;\n+                'cursor: loop {\n+                    let proj = match *cursor {\n+                        Lvalue::Local(_) => return Some(cursor), // search yielded this leaf\n+                        Lvalue::Static(_) => continue 'pop, // fruitless leaf; try next on stack\n+                        Lvalue::Projection(ref proj) => proj,\n+                    };\n+\n+                    match proj.elem {\n+                        ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                            // FIXME: add union handling\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor);\n+                        }\n+                        ProjectionElem::Downcast(..) |\n+                        ProjectionElem::Subslice { .. } |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        ProjectionElem::Index(Operand::Constant(..)) => {\n+                            cursor = &proj.base;\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Index(Operand::Consume(ref index)) => {\n+                            self.lvalue_stack.push(index); // FIXME: did old borrowck do this?\n+                            cursor = &proj.base;\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Deref => {\n+                            // (handled below)\n+                        }\n+                    }\n+\n+                    assert_eq!(proj.elem, ProjectionElem::Deref);\n+\n+                    let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    match ty.sty {\n+                        ty::TyRawPtr(_) => {\n+                            // borrowck ignores raw ptrs; treat analogous to imm borrow\n+                            continue 'pop;\n+                        }\n+                        // R-Deref-Imm-Borrowed\n+                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                            // immutably-borrowed referents do not\n+                            // have recursively-implied restrictions\n+                            // (because preventing actions on `*LV`\n+                            // does nothing about aliases like `*LV1`)\n+\n+                            // FIXME: do I need to check validity of\n+                            // `_r` here though? (I think the original\n+                            // check_loans code did, like the readme\n+                            // says)\n+\n+                            // (And do I *really* not have to\n+                            // recursively process the `base` as a\n+                            // further search here? Leaving this `if\n+                            // false` here as a hint to look at this\n+                            // again later.\n+                            //\n+                            // Ah, it might be because the\n+                            // restrictions are distinct from the path\n+                            // substructure. Note that there is a\n+                            // separate loop over the path\n+                            // substructure in fn\n+                            // each_borrow_involving_path, for better\n+                            // or for worse.\n+\n+                            if false {\n+                                cursor = &proj.base;\n+                                continue 'cursor;\n+                            } else {\n+                                continue 'pop;\n+                            }\n+                        }\n+\n+                        // R-Deref-Mut-Borrowed\n+                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                            // mutably-borrowed referents are\n+                            // themselves restricted.\n+\n+                            // FIXME: do I need to check validity of\n+                            // `_r` here though? (I think the original\n+                            // check_loans code did, like the readme\n+                            // says)\n+\n+                            // schedule base for future iteration.\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor); // search yielded interior node\n+                        }\n+\n+                        // R-Deref-Send-Pointer\n+                        ty::TyAdt(..) if ty.is_box() => {\n+                            // borrowing interior of a box implies that\n+                            // its base can no longer be mutated (o/w box\n+                            // storage would be freed)\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor); // search yielded interior node\n+                        }\n+\n+                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn report_use_of_moved(&mut self,\n+                           _context: Context,\n+                           (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n+            span, \"use\", &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span_label for use of uninitialized variable\n+        err.emit();\n+    }\n+\n+    fn report_move_out_while_borrowed(&mut self,\n+                                      _context: Context,\n+                                      (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_move_when_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n+        // FIXME 2: add span_label for \"move out of `{}` occurs here\"\n+        err.emit();\n+    }\n+\n+    fn report_use_while_mutably_borrowed(&mut self,\n+                                         _context: Context,\n+                                         (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n+        // FIXME 2: add span_label for \"use of `{}` occurs here\"\n+        err.emit();\n+    }\n+\n+    fn report_conflicting_borrow(&mut self,\n+                                 _context: Context,\n+                                 (lvalue, span): (&Lvalue, Span),\n+                                 loan1: &BorrowData,\n+                                 loan2: &BorrowData) {\n+        // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n+        assert_eq!(loan1.lvalue, loan2.lvalue);\n+\n+        // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let mut err = match (loan1.kind, \"immutable\", \"mutable\",\n+                             loan2.kind, \"immutable\", \"mutable\") {\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Mut, _, rgt) =>\n+                self.tcx.cannot_reborrow_already_borrowed(\n+                    span, &self.describe_lvalue(lvalue),\n+                    \"\", lft, \"it\", rgt, \"\", Origin::Mir),\n+\n+            _ =>  self.tcx.cannot_mutably_borrow_multiply(\n+                span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+            // FIXME: add span labels for first and second mutable borrows, as well as\n+            // end point for first.\n+        };\n+        err.emit();\n+    }\n+\n+    fn report_illegal_mutation_of_borrowed(&mut self, _: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_assign_to_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+\n+    fn report_illegal_reassignment(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_reassign_immutable(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+\n+    fn report_assignment_to_static(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_assign_static(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    // End-user visible description of `lvalue`\n+    fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n+        let mut buf = String::new();\n+        self.append_lvalue_to_string(lvalue, &mut buf);\n+        buf\n+    }\n+\n+    // Appends end-user visible description of `lvalue` to `buf`.\n+    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String) {\n+        match *lvalue {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                match local.name {\n+                    Some(name) => buf.push_str(&format!(\"{}\", name)),\n+                    None => buf.push_str(\"_\"),\n+                }\n+            }\n+            Lvalue::Static(ref static_) => {\n+                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                let (prefix, suffix, index_operand) = match proj.elem {\n+                    ProjectionElem::Deref =>\n+                        (\"(*\", format!(\")\"), None),\n+                    ProjectionElem::Downcast(..) =>\n+                        (\"\",   format!(\"\"), None), // (dont emit downcast info)\n+                    ProjectionElem::Field(field, _ty) =>\n+                        (\"\",   format!(\".{}\", field.index()), None),\n+                    ProjectionElem::Index(ref index) =>\n+                        (\"\",   format!(\"\"), Some(index)),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n+                        (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n+                        (\"\",   format!(\"[-{} of {}]\", offset, min_length), None),\n+                    ProjectionElem::Subslice { from, to: 0 } =>\n+                        (\"\",   format!(\"[{}:]\", from), None),\n+                    ProjectionElem::Subslice { from: 0, to } =>\n+                        (\"\",   format!(\"[:-{}]\", to), None),\n+                    ProjectionElem::Subslice { from, to } =>\n+                        (\"\",   format!(\"[{}:-{}]\", from, to), None),\n+                };\n+                buf.push_str(prefix);\n+                self.append_lvalue_to_string(&proj.base, buf);\n+                if let Some(index) = index_operand {\n+                    buf.push_str(\"[\");\n+                    self.append_operand_to_string(index, buf);\n+                    buf.push_str(\"]\");\n+                } else {\n+                    buf.push_str(&suffix);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    fn append_operand_to_string(&self, operand: &Operand, buf: &mut String) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) => {\n+                self.append_lvalue_to_string(lvalue, buf);\n+            }\n+            Operand::Constant(ref constant) => {\n+                buf.push_str(&format!(\"{:?}\", constant));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    // FIXME: needs to be able to express errors analogous to check_loans.rs\n+    fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n+        if loan1.compatible_with(loan2.kind) { return false; }\n+\n+        let loan2_base_path = self.base_path(&loan2.lvalue);\n+        for restricted in self.restrictions(&loan1.lvalue) {\n+            if restricted != loan2_base_path { continue; }\n+            return true;\n+        }\n+\n+        let loan1_base_path = self.base_path(&loan1.lvalue);\n+        for restricted in self.restrictions(&loan2.lvalue) {\n+            if restricted != loan1_base_path { continue; }\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    // FIXME (#16118): function intended to allow the borrow checker\n+    // to be less precise in its handling of Box while still allowing\n+    // moves out of a Box. They should be removed when/if we stop\n+    // treating Box specially (e.g. when/if DerefMove is added...)\n+\n+    fn base_path<'d>(&self, lvalue: &'d Lvalue<'gcx>) -> &'d Lvalue<'gcx> {\n+        //! Returns the base of the leftmost (deepest) dereference of an\n+        //! Box in `lvalue`. If there is no dereference of an Box\n+        //! in `lvalue`, then it just returns `lvalue` itself.\n+\n+        let mut cursor = lvalue;\n+        let mut deepest = lvalue;\n+        loop {\n+            let proj = match *cursor {\n+                Lvalue::Local(..) | Lvalue::Static(..) => return deepest,\n+                Lvalue::Projection(ref proj) => proj,\n+            };\n+            if proj.elem == ProjectionElem::Deref &&\n+                lvalue.ty(self.mir, self.tcx).to_ty(self.tcx).is_box()\n+            {\n+                deepest = &proj.base;\n+            }\n+            cursor = &proj.base;\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Context {\n+    kind: ContextKind,\n+    loc: Location,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ContextKind {\n+    AssignLhs,\n+    AssignRhs,\n+    SetDiscrim,\n+    InlineAsm,\n+    SwitchInt,\n+    Drop,\n+    DropAndReplace,\n+    CallOperator,\n+    CallOperand,\n+    CallDest,\n+    Assert,\n+    StorageDead,\n+}\n+\n+impl ContextKind {\n+    fn new(self, loc: Location) -> Context { Context { kind: self, loc: loc } }\n+}\n+\n+impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n+    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n+                      inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>)\n+                      -> Self {\n+        InProgress {\n+            borrows: FlowInProgress::new(borrows),\n+            inits: FlowInProgress::new(inits),\n+            uninits: FlowInProgress::new(uninits),\n+        }\n+    }\n+\n+    fn each_flow<XB, XI, XU>(&mut self,\n+                             mut xform_borrows: XB,\n+                             mut xform_inits: XI,\n+                             mut xform_uninits: XU) where\n+        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'tcx>>),\n+        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>),\n+        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>),\n+    {\n+        xform_borrows(&mut self.borrows);\n+        xform_inits(&mut self.inits);\n+        xform_uninits(&mut self.uninits);\n+    }\n+\n+    fn summary(&self) -> String {\n+        let mut s = String::new();\n+\n+        s.push_str(\"borrows in effect: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_state_bit(|borrow| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"borrows generated: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_gen_bit(|borrow| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"inits: [\");\n+        let mut saw_one = false;\n+        self.inits.each_state_bit(|mpi_init| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_path =\n+                &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"uninits: [\");\n+        let mut saw_one = false;\n+        self.uninits.each_state_bit(|mpi_uninit| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_path =\n+                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"]\");\n+\n+        return s;\n+    }\n+}\n+\n+impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n+    fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n+        self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn each_gen_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n+        self.stmt_gen.each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn new(results: DataflowResults<BD>) -> Self {\n+        let bits_per_block = results.sets().bits_per_block();\n+        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n+        FlowInProgress {\n+            base_results: results,\n+            curr_state: curr_state,\n+            stmt_gen: stmt_gen,\n+            stmt_kill: stmt_kill,\n+        }\n+    }\n+\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results.operator().statement_effect(&mut sets, loc);\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results.operator().terminator_effect(&mut sets, loc);\n+    }\n+\n+    fn apply_local_effect(&mut self) {\n+        self.curr_state.union(&self.stmt_gen);\n+        self.curr_state.subtract(&self.stmt_kill);\n+    }\n+\n+    fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.stmt_gen.elems(univ)\n+    }\n+\n+    fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.curr_state.elems(univ)\n+    }\n+}\n+\n+impl<'tcx> BorrowData<'tcx> {\n+    fn compatible_with(&self, bk: BorrowKind) -> bool {\n+        match (self.kind, bk) {\n+            (BorrowKind::Shared, BorrowKind::Shared) => true,\n+\n+            (BorrowKind::Mut, _) |\n+            (BorrowKind::Unique, _) |\n+            (_, BorrowKind::Mut) |\n+            (_, BorrowKind::Unique) => false,\n+        }\n+    }\n+}"}, {"sha": "b390e2888f26c2c177e8ce32224fe9c9e835c7c2", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> CFG<'tcx> {\n                            source_info: SourceInfo,\n                            extent: CodeExtent) {\n         self.push(block, Statement {\n-            source_info: source_info,\n+            source_info,\n             kind: StatementKind::EndRegion(extent),\n         });\n     }\n@@ -60,7 +60,7 @@ impl<'tcx> CFG<'tcx> {\n                        lvalue: &Lvalue<'tcx>,\n                        rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n-            source_info: source_info,\n+            source_info,\n             kind: StatementKind::Assign(lvalue.clone(), rvalue)\n         });\n     }\n@@ -93,8 +93,8 @@ impl<'tcx> CFG<'tcx> {\n                       block,\n                       self.block_data(block));\n         self.block_data_mut(block).terminator = Some(Terminator {\n-            source_info: source_info,\n-            kind: kind,\n+            source_info,\n+            kind,\n         });\n     }\n }"}, {"sha": "c74378bdadce52ccb9d63ec371896de007a9f091", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if let Some(scope) = scope {\n                     // schedule a shallow free of that memory, lest we unwind:\n                     this.cfg.push(block, Statement {\n-                        source_info: source_info,\n+                        source_info,\n                         kind: StatementKind::StorageLive(result.clone())\n                     });\n                     this.schedule_drop(expr_span, scope, &result, value.ty);"}, {"sha": "4f248ddb0e2cfde09771e0622510dafce7817d26", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         if !expr_ty.is_never() && temp_lifetime.is_some() {\n             this.cfg.push(block, Statement {\n-                source_info: source_info,\n+                source_info,\n                 kind: StatementKind::StorageLive(temp.clone())\n             });\n         }"}, {"sha": "576b1059e59972348cc6fc43b07c706a33cbbb0c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -240,8 +240,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let cleanup = this.diverge_cleanup();\n                     this.cfg.terminate(block, source_info, TerminatorKind::Call {\n                         func: fun,\n-                        args: args,\n-                        cleanup: cleanup,\n+                        args,\n+                        cleanup,\n                         destination: if diverges {\n                             None\n                         } else {"}, {"sha": "0da722f72a15a2a4770b9a0ccab1309da686f4a0", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -127,11 +127,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     unpack!(block = this.as_local_operand(block, input))\n                 }).collect();\n                 this.cfg.push(block, Statement {\n-                    source_info: source_info,\n+                    source_info,\n                     kind: StatementKind::InlineAsm {\n                         asm: box asm.clone(),\n-                        outputs: outputs,\n-                        inputs: inputs\n+                        outputs,\n+                        inputs,\n                     },\n                 });\n                 block.unit()"}, {"sha": "78805ba87ec22f017db686d50f5af7d54ac0b6e6", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -69,8 +69,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         span: pattern.span,\n                         match_pairs: vec![MatchPair::new(discriminant_lvalue.clone(), pattern)],\n                         bindings: vec![],\n-                        guard: guard,\n-                        arm_index: arm_index,\n+                        guard,\n+                        arm_index,\n                     }\n                 })\n                 .collect();\n@@ -179,7 +179,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 var_scope = Some(this.new_visibility_scope(scope_span));\n             }\n             let source_info = SourceInfo {\n-                span: span,\n+                span,\n                 scope: var_scope.unwrap()\n             };\n             this.declare_binding(source_info, mutability, name, var, ty);\n@@ -193,7 +193,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let local_id = self.var_indices[&var];\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement {\n-            source_info: source_info,\n+            source_info,\n             kind: StatementKind::StorageLive(Lvalue::Local(local_id))\n         });\n         Lvalue::Local(local_id)\n@@ -708,10 +708,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                var_id, name, var_ty, source_info);\n \n         let var = self.local_decls.push(LocalDecl::<'tcx> {\n-            mutability: mutability,\n+            mutability,\n             ty: var_ty.clone(),\n             name: Some(name),\n-            source_info: source_info,\n+            source_info,\n             is_user_variable: true,\n         });\n         self.var_indices.insert(var_id, var);"}, {"sha": "6e3eef5735233aaf8a0ecf589f28f64f3a10a75a", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=fb30dd70cef8f9a75c042a69d8eebed6ec63f9e2", "patch": "@@ -71,8 +71,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             PatternKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n                 candidate.bindings.push(Binding {\n-                    name: name,\n-                    mutability: mutability,\n+                    name,\n+                    mutability,\n                     span: match_pair.pattern.span,\n                     source: match_pair.lvalue.clone(),\n                     var_id: var,"}]}