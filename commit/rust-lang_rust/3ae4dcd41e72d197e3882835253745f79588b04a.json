{"sha": "3ae4dcd41e72d197e3882835253745f79588b04a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZTRkY2Q0MWU3MmQxOTdlMzg4MjgzNTI1Mzc0NWY3OTU4OGIwNGE=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-18T19:02:26Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-21T18:51:22Z"}, "message": "Lots of work on memory tracking and channels.\n\nWe're trying to get closer to doing correct move semantics for channel\noperations. This involves a lot of cleanup (such as removing the\nunused sched parameter from rust_vec constructor) and making\ncircular_buffer kernel_owned.\n\nAdded tagging for memory allocations. This means we give a string tag\nto everything we allocate. If we leak something and TRACK_ALLOCATIONS\nis enabled, then it's much easier now to tell exactly what is leaking.", "tree": {"sha": "38b0fa41afe156057c8913f779fda2e4ca0b08ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38b0fa41afe156057c8913f779fda2e4ca0b08ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ae4dcd41e72d197e3882835253745f79588b04a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae4dcd41e72d197e3882835253745f79588b04a", "html_url": "https://github.com/rust-lang/rust/commit/3ae4dcd41e72d197e3882835253745f79588b04a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ae4dcd41e72d197e3882835253745f79588b04a/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a44fb04d57400f70ad58c1e35fc9dd9a7c43de07", "url": "https://api.github.com/repos/rust-lang/rust/commits/a44fb04d57400f70ad58c1e35fc9dd9a7c43de07", "html_url": "https://github.com/rust-lang/rust/commit/a44fb04d57400f70ad58c1e35fc9dd9a7c43de07"}], "stats": {"total": 553, "additions": 313, "deletions": 240}, "files": [{"sha": "0237037b55ed0e008b40e158abf35f0c720c7018", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -38,6 +38,7 @@ type upcalls =\n         ValueRef flush_chan,\n         ValueRef del_chan,\n         ValueRef clone_chan,\n+        ValueRef chan_target_task,\n         ValueRef _yield,\n         ValueRef sleep,\n         ValueRef send,\n@@ -95,6 +96,9 @@ fn declare_upcalls(type_names tn, TypeRef tydesc_type, TypeRef taskptr_type,\n              del_chan=dv(\"del_chan\", ~[T_opaque_chan_ptr()]),\n              clone_chan=d(\"clone_chan\", ~[taskptr_type, T_opaque_chan_ptr()],\n                           T_opaque_chan_ptr()),\n+             chan_target_task=d(\"chan_target_task\",\n+                                ~[T_opaque_chan_ptr()],\n+                                taskptr_type),\n              _yield=dv(\"yield\", empty_vec),\n              sleep=dv(\"sleep\", ~[T_size_t()]),\n              send=dv(\"send\", ~[T_opaque_chan_ptr(), T_ptr(T_i8())]),"}, {"sha": "3ea1f588c95b01eef80381956488d9292cef18a3", "filename": "src/comp/middle/trans_comm.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -22,6 +22,12 @@ import back::link::mangle_internal_name_by_path_and_seq;\n import trans_common::*;\n import trans::*;\n \n+export trans_port;\n+export trans_chan;\n+export trans_spawn;\n+export trans_send;\n+export trans_recv;\n+\n fn trans_port(&@block_ctxt cx, ast::node_id id) -> result {\n     auto t = node_id_type(cx.fcx.lcx.ccx, id);\n     auto unit_ty;\n@@ -123,13 +129,7 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n     auto llargs = alloc_ty(bcx, args_ty);\n     auto i = 0u;\n     for (ValueRef v in arg_vals) {\n-        // log_err #fmt(\"ty(llargs) = %s\",\n-        //              val_str(bcx.fcx.lcx.ccx.tn, llargs.val));\n-\n         auto target = bcx.build.GEP(llargs.val, ~[C_int(0), C_int(i as int)]);\n-        // log_err #fmt(\"ty(v) = %s\", val_str(bcx.fcx.lcx.ccx.tn, v));\n-        // log_err #fmt(\"ty(target) = %s\",\n-        //              val_str(bcx.fcx.lcx.ccx.tn, target));\n \n         bcx.build.Store(v, target);\n         i += 1u;\n@@ -199,55 +199,6 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n     ret rslt(cx, llfndecl);\n }\n \n-// Does a deep copy of a value. This is needed for passing arguments to child\n-// tasks, and for sending things through channels. There are probably some\n-// uniqueness optimizations and things we can do here for tasks in the same\n-// domain.\n-fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n-    -> result\n-{\n-    // TODO: make sure all paths add any reference counting that they need to.\n-\n-    // TODO: Teach deep copy to understand everything else it needs to.\n-\n-    auto tcx = bcx.fcx.lcx.ccx.tcx;\n-    if(ty::type_is_scalar(tcx, t)) {\n-        ret rslt(bcx, v);\n-    }\n-    else if(ty::type_is_str(tcx, t)) {\n-        ret rslt(bcx,\n-                bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.dup_str,\n-                               ~[bcx.fcx.lltaskptr, target_task, v]));\n-    }\n-    else if(ty::type_is_chan(tcx, t)) {\n-        // If this is a channel, we need to clone it.\n-        auto chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n-\n-        auto chan_raw_val =\n-            bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n-                           ~[bcx.fcx.lltaskptr, target_task, chan_ptr]);\n-\n-        // Cast back to the type the context was expecting.\n-        auto chan_val = bcx.build.PointerCast(chan_raw_val,\n-                                              val_ty(v));\n-\n-        ret rslt(bcx, chan_val);\n-    }\n-    else if(ty::type_is_structural(tcx, t)) {\n-        fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n-            log_err \"Unimplemented type for deep_copy.\";\n-            fail;\n-        }\n-\n-        ret iter_structural_ty(bcx, v, t, inner_deep_copy);\n-    }\n-    else {\n-        bcx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n-                                 \"trans::deep_copy: \" +\n-                                 ty_to_str(tcx, t));\n-    }\n-}\n-\n fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n               ast::node_id id) -> result {\n     auto bcx = cx;\n@@ -302,3 +253,52 @@ fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n     ret rslt(bcx, to);\n }\n \n+// Does a deep copy of a value. This is needed for passing arguments to child\n+// tasks, and for sending things through channels. There are probably some\n+// uniqueness optimizations and things we can do here for tasks in the same\n+// domain.\n+fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n+    -> result\n+{\n+    // TODO: make sure all paths add any reference counting that they need to.\n+\n+    // TODO: Teach deep copy to understand everything else it needs to.\n+\n+    auto tcx = bcx.fcx.lcx.ccx.tcx;\n+    if(ty::type_is_scalar(tcx, t)) {\n+        ret rslt(bcx, v);\n+    }\n+    else if(ty::type_is_str(tcx, t)) {\n+        ret rslt(bcx,\n+                bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.dup_str,\n+                               ~[bcx.fcx.lltaskptr, target_task, v]));\n+    }\n+    else if(ty::type_is_chan(tcx, t)) {\n+        // If this is a channel, we need to clone it.\n+        auto chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n+\n+        auto chan_raw_val =\n+            bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n+                           ~[bcx.fcx.lltaskptr, target_task, chan_ptr]);\n+\n+        // Cast back to the type the context was expecting.\n+        auto chan_val = bcx.build.PointerCast(chan_raw_val,\n+                                              val_ty(v));\n+\n+        ret rslt(bcx, chan_val);\n+    }\n+    else if(ty::type_is_structural(tcx, t)) {\n+        fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n+            log_err \"Unimplemented type for deep_copy.\";\n+            fail;\n+        }\n+\n+        ret iter_structural_ty(bcx, v, t, inner_deep_copy);\n+    }\n+    else {\n+        bcx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n+                                 \"trans::deep_copy: \" +\n+                                 ty_to_str(tcx, t));\n+    }\n+}\n+"}, {"sha": "b645a08e5638ebadb5c052a3739b191a820a8b4e", "filename": "src/rt/circular_buffer.cpp", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fcircular_buffer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fcircular_buffer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -4,14 +4,14 @@\n \n #include \"rust_internal.h\"\n \n-circular_buffer::circular_buffer(rust_task *task, size_t unit_sz) :\n-    sched(task->sched),\n-    task(task),\n+circular_buffer::circular_buffer(rust_kernel *kernel, size_t unit_sz) :\n+    sched(kernel->sched),\n+    kernel(kernel),\n     unit_sz(unit_sz),\n     _buffer_sz(initial_size()),\n     _next(0),\n     _unread(0),\n-    _buffer((uint8_t *)task->malloc(_buffer_sz)) {\n+    _buffer((uint8_t *)kernel->malloc(_buffer_sz, \"circular_buffer\")) {\n \n     A(sched, unit_sz, \"Unit size must be larger than zero.\");\n \n@@ -20,16 +20,14 @@ circular_buffer::circular_buffer(rust_task *task, size_t unit_sz) :\n          _buffer_sz, _unread, this);\n \n     A(sched, _buffer, \"Failed to allocate buffer.\");\n-    task->ref();\n }\n \n circular_buffer::~circular_buffer() {\n     DLOG(sched, mem, \"~circular_buffer 0x%\" PRIxPTR, this);\n     I(sched, _buffer);\n     W(sched, _unread == 0,\n       \"freeing circular_buffer with %d unread bytes\", _unread);\n-    task->free(_buffer);\n-    --task->ref_count;\n+    kernel->free(_buffer);\n }\n \n size_t\n@@ -144,9 +142,10 @@ circular_buffer::grow() {\n     size_t new_buffer_sz = _buffer_sz * 2;\n     I(sched, new_buffer_sz <= MAX_CIRCULAR_BUFFER_SIZE);\n     DLOG(sched, mem, \"circular_buffer is growing to %d bytes\", new_buffer_sz);\n-    void *new_buffer = task->malloc(new_buffer_sz);\n+    void *new_buffer = kernel->malloc(new_buffer_sz,\n+                                    \"new circular_buffer (grow)\");\n     transfer(new_buffer);\n-    task->free(_buffer);\n+    kernel->free(_buffer);\n     _buffer = (uint8_t *)new_buffer;\n     _next = 0;\n     _buffer_sz = new_buffer_sz;\n@@ -158,9 +157,10 @@ circular_buffer::shrink() {\n     I(sched, initial_size() <= new_buffer_sz);\n     DLOG(sched, mem, \"circular_buffer is shrinking to %d bytes\",\n          new_buffer_sz);\n-    void *new_buffer = task->malloc(new_buffer_sz);\n+    void *new_buffer = kernel->malloc(new_buffer_sz,\n+                                    \"new circular_buffer (shrink)\");\n     transfer(new_buffer);\n-    task->free(_buffer);\n+    kernel->free(_buffer);\n     _buffer = (uint8_t *)new_buffer;\n     _next = 0;\n     _buffer_sz = new_buffer_sz;"}, {"sha": "ffe9a2293a752b47b55bdeaa8d680a8436b7ae21", "filename": "src/rt/circular_buffer.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fcircular_buffer.h", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fcircular_buffer.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.h?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -6,17 +6,17 @@\n #define CIRCULAR_BUFFER_H\n \n class\n-circular_buffer : public task_owned<circular_buffer> {\n+circular_buffer : public kernel_owned<circular_buffer> {\n     static const size_t INITIAL_CIRCULAR_BUFFER_SIZE_IN_UNITS = 8;\n     static const size_t MAX_CIRCULAR_BUFFER_SIZE = 1 << 24;\n \n     rust_scheduler *sched;\n \n public:\n-    rust_task *task;\n+    rust_kernel *kernel;\n     // Size of the data unit in bytes.\n     const size_t unit_sz;\n-    circular_buffer(rust_task *task, size_t unit_sz);\n+    circular_buffer(rust_kernel *kernel, size_t unit_sz);\n     ~circular_buffer();\n     void transfer(void *dst);\n     void enqueue(void *src);"}, {"sha": "ea087d14b510251c9992752a9fdb533977a1dec9", "filename": "src/rt/memory.h", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fmemory.h", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fmemory.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory.h?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -3,33 +3,38 @@\n #define MEMORY_H\n \n // FIXME: It would be really nice to be able to get rid of this.\n-inline void *operator new[](size_t size, rust_task *task) {\n-    return task->malloc(size);\n+inline void *operator new[](size_t size, rust_task *task, const char *tag) {\n+    return task->malloc(size, tag);\n }\n \n template <typename T>\n-inline void *task_owned<T>::operator new(size_t size, rust_task *task) {\n-    return task->malloc(size);\n+inline void *task_owned<T>::operator new(size_t size, rust_task *task,\n+                                         const char *tag) {\n+    return task->malloc(size, tag);\n }\n \n template <typename T>\n-inline void *task_owned<T>::operator new[](size_t size, rust_task *task) {\n-    return task->malloc(size);\n+inline void *task_owned<T>::operator new[](size_t size, rust_task *task,\n+                                           const char *tag) {\n+    return task->malloc(size, tag);\n }\n \n template <typename T>\n-inline void *task_owned<T>::operator new(size_t size, rust_task &task) {\n-    return task.malloc(size);\n+inline void *task_owned<T>::operator new(size_t size, rust_task &task,\n+                                         const char *tag) {\n+    return task.malloc(size, tag);\n }\n \n template <typename T>\n-inline void *task_owned<T>::operator new[](size_t size, rust_task &task) {\n-    return task.malloc(size);\n+inline void *task_owned<T>::operator new[](size_t size, rust_task &task,\n+                                           const char *tag) {\n+    return task.malloc(size, tag);\n }\n \n template <typename T>\n-inline void *kernel_owned<T>::operator new(size_t size, rust_kernel *kernel) {\n-    return kernel->malloc(size);\n+inline void *kernel_owned<T>::operator new(size_t size, rust_kernel *kernel,\n+                                           const char *tag) {\n+    return kernel->malloc(size, tag);\n }\n \n "}, {"sha": "603ec12e796af03ae0543b1247e318cd1ab1df0f", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 39, "deletions": 55, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -4,7 +4,13 @@\n // NB: please do not commit code with this uncommented. It's\n // hugely expensive and should only be used as a last resort.\n //\n-// #define TRACK_ALLOCATIONS\n+#define TRACK_ALLOCATIONS\n+\n+#define MAGIC 0xbadc0ffe\n+\n+memory_region::alloc_header *memory_region::get_header(void *mem) {\n+    return (alloc_header *)((char *)mem - sizeof(alloc_header));\n+}\n \n memory_region::memory_region(rust_srv *srv, bool synchronized) :\n     _srv(srv), _parent(NULL), _live_allocations(0),\n@@ -19,37 +25,37 @@ memory_region::memory_region(memory_region *parent) :\n }\n \n void memory_region::add_alloc() {\n-    //_live_allocations++;\n-    sync::increment(_live_allocations);\n+    _live_allocations++;\n+    //sync::increment(_live_allocations);\n }\n \n void memory_region::dec_alloc() {\n-    //_live_allocations--;\n-    sync::decrement(_live_allocations);\n+    _live_allocations--;\n+    //sync::decrement(_live_allocations);\n }\n \n void memory_region::free(void *mem) {\n     // printf(\"free: ptr 0x%\" PRIxPTR\" region=%p\\n\", (uintptr_t) mem, this);\n     if (!mem) { return; }\n     if (_synchronized) { _lock.lock(); }\n+    alloc_header *alloc = get_header(mem);\n+    assert(alloc->magic == MAGIC);\n #ifdef TRACK_ALLOCATIONS\n-    int index = ((int  *)mem)[-1];\n-    if (_allocation_list[index] != (uint8_t *)mem - sizeof(int)) {\n+    if (_allocation_list[alloc->index] != alloc) {\n         printf(\"free: ptr 0x%\" PRIxPTR \" is not in allocation_list\\n\",\n                (uintptr_t) mem);\n         _srv->fatal(\"not in allocation_list\", __FILE__, __LINE__, \"\");\n     }\n     else {\n         // printf(\"freed index %d\\n\", index);\n-        _allocation_list[index] = NULL;\n+        _allocation_list[alloc->index] = NULL;\n     }\n-    mem = (void*)((uint8_t*)mem - sizeof(int));\n #endif\n     if (_live_allocations < 1) {\n         _srv->fatal(\"live_allocs < 1\", __FILE__, __LINE__, \"\");\n     }\n     dec_alloc();\n-    _srv->free(mem);\n+    _srv->free(alloc);\n     if (_synchronized) { _lock.unlock(); }\n }\n \n@@ -59,77 +65,55 @@ memory_region::realloc(void *mem, size_t size) {\n     if (!mem) {\n         add_alloc();\n     }\n+    size += sizeof(alloc_header);\n+    alloc_header *alloc = get_header(mem);\n+    assert(alloc->magic == MAGIC);\n+    alloc_header *newMem = (alloc_header *)_srv->realloc(alloc, size);\n #ifdef TRACK_ALLOCATIONS\n-    size += sizeof(int);\n-    mem = (void*)((uint8_t*)mem - sizeof(int));\n-    int index = *(int  *)mem;\n-#endif\n-    void *newMem = _srv->realloc(mem, size);\n-#ifdef TRACK_ALLOCATIONS\n-    if (_allocation_list[index] != mem) {\n+    if (_allocation_list[newMem->index] != alloc) {\n         printf(\"at index %d, found %p, expected %p\\n\",\n-               index, _allocation_list[index], mem);\n+               alloc->index, _allocation_list[alloc->index], alloc);\n         printf(\"realloc: ptr 0x%\" PRIxPTR \" is not in allocation_list\\n\",\n             (uintptr_t) mem);\n         _srv->fatal(\"not in allocation_list\", __FILE__, __LINE__, \"\");\n     }\n     else {\n-        _allocation_list[index] = newMem;\n-        (*(int*)newMem) = index;\n+        _allocation_list[newMem->index] = newMem;\n         // printf(\"realloc: stored %p at index %d, replacing %p\\n\",\n         //        newMem, index, mem);\n     }\n #endif\n     if (_synchronized) { _lock.unlock(); }\n-#ifdef TRACK_ALLOCATIONS\n-    newMem = (void *)((uint8_t*)newMem + sizeof(int));\n-#endif\n-    return newMem;\n+    return newMem->data;\n }\n \n void *\n-memory_region::malloc(size_t size) {\n+memory_region::malloc(size_t size, const char *tag, bool zero) {\n     if (_synchronized) { _lock.lock(); }\n     add_alloc();\n+    size_t old_size = size;\n+    size += sizeof(alloc_header);\n+    alloc_header *mem = (alloc_header *)_srv->malloc(size);\n+    mem->magic = MAGIC;\n+    mem->tag = tag;\n #ifdef TRACK_ALLOCATIONS\n-    size += sizeof(int);\n-#endif\n-    void *mem = _srv->malloc(size);\n-#ifdef TRACK_ALLOCATIONS\n-    int index = _allocation_list.append(mem);\n-    int *p = (int *)mem;\n-    *p = index;\n+    mem->index = _allocation_list.append(mem);\n     // printf(\"malloc: stored %p at index %d\\n\", mem, index);\n #endif\n     // printf(\"malloc: ptr 0x%\" PRIxPTR \" region=%p\\n\",\n     //        (uintptr_t) mem, this);\n+\n+    if(zero) {\n+        memset(mem->data, 0, old_size);\n+    }\n+\n     if (_synchronized) { _lock.unlock(); }\n-#ifdef TRACK_ALLOCATIONS\n-    mem = (void*)((uint8_t*)mem + sizeof(int));\n-#endif\n-    return mem;\n+    return mem->data;\n }\n \n void *\n-memory_region::calloc(size_t size) {\n-    if (_synchronized) { _lock.lock(); }\n-    add_alloc();\n-#ifdef TRACK_ALLOCATIONS\n-    size += sizeof(int);\n-#endif\n-    void *mem = _srv->malloc(size);\n-    memset(mem, 0, size);\n-#ifdef TRACK_ALLOCATIONS\n-    int index = _allocation_list.append(mem);\n-    int *p = (int *)mem;\n-    *p = index;\n-    // printf(\"calloc: stored %p at index %d\\n\", mem, index);\n-#endif\n-    if (_synchronized) { _lock.unlock(); }\n-#ifdef TRACK_ALLOCATIONS\n-    mem = (void*)((uint8_t*)mem + sizeof(int));\n-#endif\n-    return mem;\n+memory_region::calloc(size_t size, const char *tag) {\n+    return malloc(size, tag, true);\n }\n \n memory_region::~memory_region() {"}, {"sha": "96e53f1aa2292be7cd2b8850498bbaf63e33fbae", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -15,10 +15,19 @@ class rust_srv;\n \n class memory_region {\n private:\n+    struct alloc_header {\n+        uint32_t magic;\n+        int index;\n+        const char *tag;\n+        char data[];\n+    };\n+\n+    alloc_header *get_header(void *mem);\n+\n     rust_srv *_srv;\n     memory_region *_parent;\n     size_t _live_allocations;\n-    array_list<void *> _allocation_list;\n+    array_list<alloc_header *> _allocation_list;\n     const bool _detailed_leaks;\n     const bool _synchronized;\n     lock_and_signal _lock;\n@@ -29,8 +38,8 @@ class memory_region {\n public:\n     memory_region(rust_srv *srv, bool synchronized);\n     memory_region(memory_region *parent);\n-    void *malloc(size_t size);\n-    void *calloc(size_t size);\n+    void *malloc(size_t size, const char *tag, bool zero = true);\n+    void *calloc(size_t size, const char *tag);\n     void *realloc(void *mem, size_t size);\n     void free(void *mem);\n     virtual ~memory_region();\n@@ -40,12 +49,14 @@ class memory_region {\n     void hack_allow_leaks();\n };\n \n-inline void *operator new(size_t size, memory_region &region) {\n-    return region.malloc(size);\n+inline void *operator new(size_t size, memory_region &region,\n+                          const char *tag) {\n+    return region.malloc(size, tag);\n }\n \n-inline void *operator new(size_t size, memory_region *region) {\n-    return region->malloc(size);\n+inline void *operator new(size_t size, memory_region *region,\n+                          const char *tag) {\n+    return region->malloc(size, tag);\n }\n \n //"}, {"sha": "c487bee954c2741a167570e764f27321d4fef0c4", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -24,12 +24,14 @@ command_line_args : public kernel_owned<command_line_args>\n         LPCWSTR cmdline = GetCommandLineW();\n         LPWSTR *wargv = CommandLineToArgvW(cmdline, &argc);\n         kernel->win32_require(\"CommandLineToArgvW\", wargv != NULL);\n-        argv = (char **) kernel->malloc(sizeof(char*) * argc);\n+        argv = (char **) kernel->malloc(sizeof(char*) * argc,\n+                                        \"win32 command line\");\n         for (int i = 0; i < argc; ++i) {\n             int n_chars = WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1,\n                                               NULL, 0, NULL, NULL);\n             kernel->win32_require(\"WideCharToMultiByte(0)\", n_chars != 0);\n-            argv[i] = (char *) kernel->malloc(n_chars);\n+            argv[i] = (char *) kernel->malloc(n_chars,\n+                                              \"win32 command line arg\");\n             n_chars = WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1,\n                                           argv[i], n_chars, NULL, NULL);\n             kernel->win32_require(\"WideCharToMultiByte(1)\", n_chars != 0);\n@@ -38,14 +40,14 @@ command_line_args : public kernel_owned<command_line_args>\n #endif\n         size_t vec_fill = sizeof(rust_str *) * argc;\n         size_t vec_alloc = next_power_of_two(sizeof(rust_vec) + vec_fill);\n-        void *mem = kernel->malloc(vec_alloc);\n-        args = new (mem) rust_vec(task->sched, vec_alloc, 0, NULL);\n+        void *mem = kernel->malloc(vec_alloc, \"command line\");\n+        args = new (mem) rust_vec(vec_alloc, 0, NULL);\n         rust_str **strs = (rust_str**) &args->data[0];\n         for (int i = 0; i < argc; ++i) {\n             size_t str_fill = strlen(argv[i]) + 1;\n             size_t str_alloc = next_power_of_two(sizeof(rust_str) + str_fill);\n-            mem = kernel->malloc(str_alloc);\n-            strs[i] = new (mem) rust_str(task->sched, str_alloc, str_fill,\n+            mem = kernel->malloc(str_alloc, \"command line arg\");\n+            strs[i] = new (mem) rust_str(str_alloc, str_fill,\n                                          (uint8_t const *)argv[i]);\n         }\n         args->fill = vec_fill;\n@@ -106,7 +108,8 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     kernel->start();\n     rust_scheduler *sched = kernel->get_scheduler();\n     command_line_args *args\n-        = new (kernel) command_line_args(sched->root_task, argc, argv);\n+        = new (kernel, \"main command line args\")\n+        command_line_args(sched->root_task, argc, argv);\n \n     DLOG(sched, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);"}, {"sha": "977494f766958c44caca40662436c0414a0e83fa", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -9,7 +9,6 @@\n \n extern \"C\" CDECL rust_str*\n last_os_error(rust_task *task) {\n-    rust_scheduler *sched = task->sched;\n     LOG(task, task, \"last_os_error()\");\n \n #if defined(__WIN32__)\n@@ -42,12 +41,12 @@ last_os_error(rust_task *task) {\n #endif\n     size_t fill = strlen(buf) + 1;\n     size_t alloc = next_power_of_two(sizeof(rust_str) + fill);\n-    void *mem = task->malloc(alloc);\n+    void *mem = task->malloc(alloc, \"rust_str(last_os_error)\");\n     if (!mem) {\n         task->fail();\n         return NULL;\n     }\n-    rust_str *st = new (mem) rust_str(sched, alloc, fill,\n+    rust_str *st = new (mem) rust_str(alloc, fill,\n                                       (const uint8_t *)buf);\n \n #ifdef __WIN32__\n@@ -58,7 +57,6 @@ last_os_error(rust_task *task) {\n \n extern \"C\" CDECL rust_str *\n rust_getcwd(rust_task *task) {\n-    rust_scheduler *sched = task->sched;\n     LOG(task, task, \"rust_getcwd()\");\n \n     char cbuf[BUF_BYTES];\n@@ -74,14 +72,14 @@ rust_getcwd(rust_task *task) {\n \n     size_t fill = strlen(cbuf) + 1;\n     size_t alloc = next_power_of_two(sizeof(rust_str) + fill);\n-    void *mem = task->malloc(alloc);\n+    void *mem = task->malloc(alloc, \"rust_str(getcwd)\");\n     if (!mem) {\n         task->fail();\n         return NULL;\n     }\n \n     rust_str *st;\n-    st = new (mem) rust_str(sched, alloc, fill, (const uint8_t *)cbuf);\n+    st = new (mem) rust_str(alloc, fill, (const uint8_t *)cbuf);\n \n     return st;\n }\n@@ -125,17 +123,16 @@ unsupervise(rust_task *task) {\n extern \"C\" CDECL rust_vec*\n vec_alloc(rust_task *task, type_desc *t, type_desc *elem_t, size_t n_elts)\n {\n-    rust_scheduler *sched = task->sched;\n     LOG(task, mem, \"vec_alloc %\" PRIdPTR \" elements of size %\" PRIdPTR,\n         n_elts, elem_t->size);\n     size_t fill = n_elts * elem_t->size;\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + fill);\n-    void *mem = task->malloc(alloc, t->is_stateful ? t : NULL);\n+    void *mem = task->malloc(alloc, \"rust_vec\", t->is_stateful ? t : NULL);\n     if (!mem) {\n         task->fail();\n         return NULL;\n     }\n-    rust_vec *vec = new (mem) rust_vec(sched, alloc, 0, NULL);\n+    rust_vec *vec = new (mem) rust_vec(alloc, 0, NULL);\n     return vec;\n }\n \n@@ -199,11 +196,10 @@ vec_alloc_with_data(rust_task *task,\n                     size_t elt_size,\n                     void *d)\n {\n-    rust_scheduler *sched = task->sched;\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + (n_elts * elt_size));\n-    void *mem = task->malloc(alloc);\n+    void *mem = task->malloc(alloc, \"rust_vec (with data)\");\n     if (!mem) return NULL;\n-    return new (mem) rust_vec(sched, alloc, fill * elt_size, (uint8_t*)d);\n+    return new (mem) rust_vec(alloc, fill * elt_size, (uint8_t*)d);\n }\n \n extern \"C\" CDECL rust_vec*\n@@ -377,7 +373,7 @@ extern \"C\" CDECL void *\n rand_new(rust_task *task)\n {\n     rust_scheduler *sched = task->sched;\n-    randctx *rctx = (randctx *) task->malloc(sizeof(randctx));\n+    randctx *rctx = (randctx *) task->malloc(sizeof(randctx), \"randctx\");\n     if (!rctx) {\n         task->fail();\n         return NULL;\n@@ -619,16 +615,17 @@ rust_list_files_ivec(rust_task *task, rust_str *path) {\n       sizeof(size_t)            // fill\n       + sizeof(size_t)          // alloc\n       + sizeof(rust_str *) * 4; // payload\n-  rust_box *box = (rust_box *)task->malloc(sizeof(rust_box) +\n-                                           str_ivec_sz);\n+  rust_box *box = (rust_box *)task->malloc(sizeof(rust_box) + str_ivec_sz,\n+                                           \"rust_box(list_files_ivec)\");\n+\n   box->ref_count = 1;\n   rust_ivec *iv = (rust_ivec *)&box->data;\n   iv->fill = 0;\n \n   size_t alloc_sz = sizeof(rust_str *) * strings.size();\n   iv->alloc = alloc_sz;\n   iv->payload.ptr = (rust_ivec_heap *)\n-      task->kernel->malloc(alloc_sz + sizeof(size_t));\n+      task->kernel->malloc(alloc_sz + sizeof(size_t), \"files ivec\");\n   iv->payload.ptr->fill = alloc_sz;\n   memcpy(&iv->payload.ptr->data, strings.data(), alloc_sz);\n   return box;\n@@ -706,7 +703,8 @@ ivec_reserve(rust_task *task, type_desc *ty, rust_ivec *v, size_t n_elems)\n     if (v->fill || !v->payload.ptr) {\n         // On stack; spill to heap.\n         heap_part = (rust_ivec_heap *)task->malloc(new_alloc +\n-                                                   sizeof(size_t));\n+                                                   sizeof(size_t),\n+                                                   \"ivec reserve heap part\");\n         heap_part->fill = v->fill;\n         memcpy(&heap_part->data, v->payload.data, v->fill);\n \n@@ -737,8 +735,9 @@ ivec_reserve_shared(rust_task *task, type_desc *ty, rust_ivec *v,\n     rust_ivec_heap *heap_part;\n     if (v->fill || !v->payload.ptr) {\n         // On stack; spill to heap.\n-        heap_part = (rust_ivec_heap *)task->kernel->malloc(new_alloc +\n-                                                           sizeof(size_t));\n+        heap_part = (rust_ivec_heap *)\n+            task->kernel->malloc(new_alloc + sizeof(size_t),\n+                                 \"ivec reserve shared\");\n         heap_part->fill = v->fill;\n         memcpy(&heap_part->data, v->payload.data, v->fill);\n "}, {"sha": "23af8a5fef6adb2fb2edecf9c01779ee331ad6de", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -11,22 +11,21 @@ rust_chan::rust_chan(rust_task *task,\n       kernel(task->kernel),\n       task(task),\n       port(port),\n-      buffer(task, unit_sz) {\n-    ++task->ref_count;\n+      buffer(kernel, unit_sz) {\n     if (port) {\n         associate(port);\n     }\n-    LOG(task, comm, \"new rust_chan(task=0x%\" PRIxPTR\n+    DLOG(kernel->sched, comm, \"new rust_chan(task=0x%\" PRIxPTR\n         \", port=0x%\" PRIxPTR \") -> chan=0x%\" PRIxPTR,\n         (uintptr_t) task, (uintptr_t) port, (uintptr_t) this);\n }\n \n rust_chan::~rust_chan() {\n-    LOG(task, comm, \"del rust_chan(task=0x%\" PRIxPTR \")\", (uintptr_t) this);\n+    DLOG(kernel->sched, comm, \"del rust_chan(task=0x%\" PRIxPTR \")\",\n+         (uintptr_t) this);\n \n-    A(task->sched, is_associated() == false,\n+    A(kernel->sched, is_associated() == false,\n       \"Channel must be disassociated before being freed.\");\n-    --task->ref_count;\n }\n \n /**\n@@ -35,10 +34,11 @@ rust_chan::~rust_chan() {\n void rust_chan::associate(maybe_proxy<rust_port> *port) {\n     this->port = port;\n     if (port->is_proxy() == false) {\n-        LOG(task, task,\n+        DLOG(kernel->sched, task,\n             \"associating chan: 0x%\" PRIxPTR \" with port: 0x%\" PRIxPTR,\n             this, port);\n         ++this->ref_count;\n+        this->task = port->referent()->task;\n         this->port->referent()->chans.push(this);\n     }\n }\n@@ -51,14 +51,15 @@ bool rust_chan::is_associated() {\n  * Unlink this channel from its associated port.\n  */\n void rust_chan::disassociate() {\n-    A(task->sched, is_associated(),\n+    A(kernel->sched, is_associated(),\n       \"Channel must be associated with a port.\");\n \n     if (port->is_proxy() == false) {\n-        LOG(task, task,\n+        DLOG(kernel->sched, task,\n             \"disassociating chan: 0x%\" PRIxPTR \" from port: 0x%\" PRIxPTR,\n             this, port->referent());\n         --this->ref_count;\n+        this->task = NULL;\n         port->referent()->chans.swap_delete(this);\n     }\n \n@@ -72,7 +73,7 @@ void rust_chan::disassociate() {\n void rust_chan::send(void *sptr) {\n     buffer.enqueue(sptr);\n \n-    rust_scheduler *sched = task->sched;\n+    rust_scheduler *sched = kernel->sched;\n     if (!is_associated()) {\n         W(sched, is_associated(),\n           \"rust_chan::transmit with no associated port.\");\n@@ -112,19 +113,20 @@ rust_chan *rust_chan::clone(maybe_proxy<rust_task> *target) {\n         rust_handle<rust_port> *handle =\n             task->sched->kernel->get_port_handle(port->as_referent());\n         maybe_proxy<rust_port> *proxy = new rust_proxy<rust_port> (handle);\n-        LOG(task, mem, \"new proxy: \" PTR, proxy);\n+        DLOG(kernel->sched, mem, \"new proxy: \" PTR, proxy);\n         port = proxy;\n         target_task = target->as_proxy()->handle()->referent();\n     }\n-    return new (target_task->kernel) rust_chan(target_task, port, unit_sz);\n+    return new (target_task->kernel, \"cloned chan\")\n+        rust_chan(target_task, port, unit_sz);\n }\n \n /**\n  * Cannot Yield: If the task were to unwind, the dropped ref would still\n  * appear to be live, causing modify-after-free errors.\n  */\n void rust_chan::destroy() {\n-    A(task->sched, ref_count == 0,\n+    A(kernel->sched, ref_count == 0,\n       \"Channel's ref count should be zero.\");\n \n     if (is_associated()) {"}, {"sha": "52ebc40e80403c18619ee1e31c4226d1499118c5", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -10,7 +10,7 @@ class rust_chan : public kernel_owned<rust_chan>,\n     ~rust_chan();\n \n     rust_kernel *kernel;\n-    rust_task *task;\n+    smart_ptr<rust_task> task;\n     maybe_proxy<rust_port> *port;\n     size_t idx;\n     circular_buffer buffer;"}, {"sha": "953430beb689308341cab413ad38243becbc7720", "filename": "src/rt/rust_crate_cache.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_crate_cache.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_crate_cache.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_cache.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -16,7 +16,8 @@ rust_crate_cache::get_type_desc(size_t size,\n         return td;\n     }\n     DLOG(sched, cache, \"rust_crate_cache::get_type_desc miss\");\n-    td = (type_desc*) sched->kernel->malloc(sizeof(type_desc) + keysz);\n+    td = (type_desc*) sched->kernel->malloc(sizeof(type_desc) + keysz,\n+                                            \"crate cache typedesc\");\n     if (!td)\n         return NULL;\n     // By convention, desc 0 is the root descriptor."}, {"sha": "6fe3e170b79de485657f9973a0c41efb9a3ea00e", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -115,21 +115,59 @@ template <typename T> struct rc_base {\n };\n \n template <typename T> struct task_owned {\n-    inline void *operator new(size_t size, rust_task *task);\n+    inline void *operator new(size_t size, rust_task *task, const char *tag);\n \n-    inline void *operator new[](size_t size, rust_task *task);\n+    inline void *operator new[](size_t size, rust_task *task,\n+                                const char *tag);\n \n-    inline void *operator new(size_t size, rust_task &task);\n+    inline void *operator new(size_t size, rust_task &task, const char *tag);\n \n-    inline void *operator new[](size_t size, rust_task &task);\n+    inline void *operator new[](size_t size, rust_task &task,\n+                                const char *tag);\n \n     void operator delete(void *ptr) {\n         ((T *)ptr)->task->free(ptr);\n     }\n };\n \n+template<class T>\n+class smart_ptr {\n+    T *p;\n+\n+    smart_ptr(const smart_ptr &sp) : p(sp.p) {\n+        if(p) { p->ref(); }\n+    }\n+\n+public:\n+    smart_ptr() : p(NULL) {};\n+    smart_ptr(T *p) : p(p) { if(p) { p->ref(); } }\n+\n+    ~smart_ptr() {\n+        if(p) {\n+            p->deref();\n+        }\n+    }\n+\n+    T *operator=(T* p) {\n+        if(this->p) {\n+            this->p->deref();\n+        }\n+        if(p) {\n+            p->ref();\n+        }\n+        this->p = p;\n+\n+        return p;\n+    }\n+\n+    T *operator->() const { return p; };\n+\n+    operator T*() const { return p; }\n+};\n+\n template <typename T> struct kernel_owned {\n-    inline void *operator new(size_t size, rust_kernel *kernel);\n+    inline void *operator new(size_t size, rust_kernel *kernel,\n+                              const char *tag);\n \n     void operator delete(void *ptr) {\n         ((T *)ptr)->kernel->free(ptr);"}, {"sha": "d15d52ba431cd9daba7ff7a762f74d8fbbb42923", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -8,7 +8,7 @@\n   } while (0)\n \n rust_kernel::rust_kernel(rust_srv *srv) :\n-    _region(&srv->local_region),\n+    _region(srv, true),\n     _log(srv, NULL),\n     _srv(srv),\n     _interrupt_kernel_loop(FALSE)\n@@ -20,10 +20,11 @@ rust_scheduler *\n rust_kernel::create_scheduler(const char *name) {\n     _kernel_lock.lock();\n     rust_message_queue *message_queue =\n-        new (this) rust_message_queue(_srv, this);\n+        new (this, \"rust_message_queue\") rust_message_queue(_srv, this);\n     rust_srv *srv = _srv->clone();\n     rust_scheduler *sched =\n-        new (this) rust_scheduler(this, message_queue, srv, name);\n+        new (this, \"rust_scheduler\")\n+        rust_scheduler(this, message_queue, srv, name);\n     rust_handle<rust_scheduler> *handle = internal_get_sched_handle(sched);\n     message_queue->associate(handle);\n     message_queues.append(message_queue);\n@@ -51,10 +52,8 @@ rust_handle<rust_scheduler> *\n rust_kernel::internal_get_sched_handle(rust_scheduler *sched) {\n     rust_handle<rust_scheduler> *handle = NULL;\n     if (_sched_handles.get(sched, &handle) == false) {\n-        handle =\n-            new (this) rust_handle<rust_scheduler>(this,\n-                                                   sched->message_queue,\n-                                                   sched);\n+        handle = new (this, \"rust_handle<rust_scheduler\")\n+            rust_handle<rust_scheduler>(this, sched->message_queue, sched);\n         _sched_handles.put(sched, handle);\n     }\n     return handle;\n@@ -74,9 +73,8 @@ rust_kernel::get_task_handle(rust_task *task) {\n     rust_handle<rust_task> *handle = NULL;\n     if (_task_handles.get(task, &handle) == false) {\n         handle =\n-            new (this) rust_handle<rust_task>(this,\n-                                              task->sched->message_queue,\n-                                              task);\n+            new (this, \"rust_handle<rust_task>\")\n+            rust_handle<rust_task>(this, task->sched->message_queue, task);\n         _task_handles.put(task, handle);\n     }\n     _kernel_lock.unlock();\n@@ -88,7 +86,7 @@ rust_kernel::get_port_handle(rust_port *port) {\n     _kernel_lock.lock();\n     rust_handle<rust_port> *handle = NULL;\n     if (_port_handles.get(port, &handle) == false) {\n-        handle = new (this)\n+        handle = new (this, \"rust_handle<rust_port>\")\n             rust_handle<rust_port>(this,\n                                    port->task->sched->message_queue,\n                                    port);\n@@ -202,17 +200,17 @@ rust_kernel::~rust_kernel() {\n }\n \n void *\n-rust_kernel::malloc(size_t size) {\n-    return _region->malloc(size);\n+rust_kernel::malloc(size_t size, const char *tag) {\n+    return _region.malloc(size, tag);\n }\n \n void *\n rust_kernel::realloc(void *mem, size_t size) {\n-    return _region->realloc(mem, size);\n+    return _region.realloc(mem, size);\n }\n \n void rust_kernel::free(void *mem) {\n-    _region->free(mem);\n+    _region.free(mem);\n }\n \n template<class T> void"}, {"sha": "6edb0f38dd5f99ba05f50168d59b0aa0ed42562c", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -43,7 +43,7 @@ class rust_task_thread;\n  * threads.\n  */\n class rust_kernel : public rust_thread {\n-    memory_region *_region;\n+    memory_region _region;\n     rust_log _log;\n     rust_srv *_srv;\n \n@@ -109,7 +109,7 @@ class rust_kernel : public rust_thread {\n     void fatal(char const *fmt, ...);\n     virtual ~rust_kernel();\n \n-    void *malloc(size_t size);\n+    void *malloc(size_t size, const char *tag);\n     void *realloc(void *mem, size_t size);\n     void free(void *mem);\n "}, {"sha": "59645d6d5bd9f4a4bfec678fa4230b92d50885ba", "filename": "src/rt/rust_message.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -47,7 +47,8 @@ send(notification_type type, const char* label,\n      rust_handle<rust_task> *source, rust_handle<rust_task> *target) {\n     memory_region *region = &target->message_queue->region;\n     notify_message *message =\n-        new (region) notify_message(region, type, label, source, target);\n+        new (region, \"notify_message\")\n+        notify_message(region, type, label, source, target);\n     target->message_queue->enqueue(message);\n }\n \n@@ -91,8 +92,8 @@ send(uint8_t *buffer, size_t buffer_sz, const char* label,\n \n     memory_region *region = &port->message_queue->region;\n     data_message *message =\n-        new (region) data_message(region, buffer, buffer_sz, label, source,\n-                                  port);\n+        new (region, \"data_message\")\n+        data_message(region, buffer, buffer_sz, label, source, port);\n     LOG(source->referent(), comm, \"==> sending \\\"%s\\\"\" PTR \" in queue \" PTR,\n         label, message, &port->message_queue);\n     port->message_queue->enqueue(message);"}, {"sha": "48ce42ca7cb1fabbd86097f3d7b735eef1d7bcd6", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -10,7 +10,8 @@ rust_port::rust_port(rust_task *task, size_t unit_sz)\n         PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n \n     // Allocate a remote channel, for remote channel data.\n-    remote_channel = new (task->kernel) rust_chan(task, this, unit_sz);\n+    remote_channel = new (task->kernel, \"remote chan\")\n+        rust_chan(task, this, unit_sz);\n }\n \n rust_port::~rust_port() {"}, {"sha": "18ac66beb5ee3a0b1ff5fda4ac1df4dd97c3deeb", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -290,7 +290,8 @@ rust_scheduler::get_cache() {\n rust_task *\n rust_scheduler::create_task(rust_task *spawner, const char *name) {\n     rust_task *task =\n-        new (this->kernel) rust_task (this, &newborn_tasks, spawner, name);\n+        new (this->kernel, \"rust_task\")\n+        rust_task (this, &newborn_tasks, spawner, name);\n     DLOG(this, task, \"created task: \" PTR \", spawner: %s, name: %s\",\n                         task, spawner ? spawner->name : \"null\", name);\n     if(spawner) {"}, {"sha": "2b33e3d773af47e7db287505b1669cfb1ff4848d", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -34,7 +34,7 @@ new_stk(rust_task *task, size_t minsz)\n     if (minsz < min_stk_bytes)\n         minsz = min_stk_bytes;\n     size_t sz = sizeof(stk_seg) + minsz;\n-    stk_seg *stk = (stk_seg *)task->malloc(sz);\n+    stk_seg *stk = (stk_seg *)task->malloc(sz, \"stack\");\n     LOGPTR(task->sched, \"new stk\", (uintptr_t)stk);\n     memset(stk, 0, sizeof(stk_seg));\n     stk->limit = (uintptr_t) &stk->data[minsz];\n@@ -326,7 +326,7 @@ rust_task::unlink_gc(gc_alloc *gcm) {\n }\n \n void *\n-rust_task::malloc(size_t sz, type_desc *td)\n+rust_task::malloc(size_t sz, const char *tag, type_desc *td)\n {\n     // FIXME: GC is disabled for now.\n     // GC-memory classification is all wrong.\n@@ -335,7 +335,8 @@ rust_task::malloc(size_t sz, type_desc *td)\n     if (td) {\n         sz += sizeof(gc_alloc);\n     }\n-    void *mem = local_region.malloc(sz);\n+\n+    void *mem = local_region.malloc(sz, tag);\n     if (!mem)\n         return mem;\n     if (td) {\n@@ -488,8 +489,8 @@ bool rust_task::can_schedule(int id)\n }\n \n void *\n-rust_task::calloc(size_t size) {\n-    return local_region.calloc(size);\n+rust_task::calloc(size_t size, const char *tag) {\n+    return local_region.calloc(size, tag);\n }\n \n void rust_task::pin() {"}, {"sha": "13b5537d5d9bb49dce577b0e63605cd779b6dc7d", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -112,7 +112,7 @@ rust_task : public maybe_proxy<rust_task>,\n \n     void link_gc(gc_alloc *gcm);\n     void unlink_gc(gc_alloc *gcm);\n-    void *malloc(size_t sz, type_desc *td=0);\n+    void *malloc(size_t sz, const char *tag, type_desc *td=0);\n     void *realloc(void *data, size_t sz, bool gc_mem=false);\n     void free(void *p, bool gc_mem=false);\n \n@@ -157,7 +157,7 @@ rust_task : public maybe_proxy<rust_task>,\n \n     bool can_schedule(int worker);\n \n-    void *calloc(size_t size);\n+    void *calloc(size_t size, const char *tag);\n \n     void pin();\n     void pin(int id);"}, {"sha": "8a61e5e95a515500d3022f0d922f248ebc23c218", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -104,7 +104,7 @@ upcall_new_port(rust_task *task, size_t unit_sz) {\n         (uintptr_t) task, task->name, unit_sz);\n     // take a reference on behalf of the port\n     task->ref();\n-    return new (task->kernel) rust_port(task, unit_sz);\n+    return new (task->kernel, \"rust_port\") rust_port(task, unit_sz);\n }\n \n extern \"C\" CDECL void\n@@ -129,7 +129,8 @@ upcall_new_chan(rust_task *task, rust_port *port) {\n         \"task=0x%\" PRIxPTR \" (%s), port=0x%\" PRIxPTR \")\",\n         (uintptr_t) task, task->name, port);\n     I(sched, port);\n-    return new (task->kernel) rust_chan(task, port, port->unit_sz);\n+    return new (task->kernel, \"rust_chan\")\n+        rust_chan(task, port, port->unit_sz);\n }\n \n /**\n@@ -152,8 +153,6 @@ extern \"C\" CDECL\n void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n \n-    I(task->sched, chan->task == task);\n-\n     LOG(task, comm, \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n     chan->destroy();\n }\n@@ -169,6 +168,14 @@ upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n     return chan->clone(target);\n }\n \n+extern \"C\" CDECL rust_task *\n+upcall_chan_target_task(rust_task *task, rust_chan *chan) {\n+    LOG_UPCALL_ENTRY(task);\n+    I(task->sched, !chan->port->is_proxy());\n+\n+    return chan->port->referent()->task;\n+}\n+\n extern \"C\" CDECL void\n upcall_yield(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n@@ -277,7 +284,10 @@ upcall_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n         \" with gc-chain head = 0x%\" PRIxPTR,\n         nbytes, td, task->gc_alloc_chain);\n \n-    void *p = task->malloc(nbytes, td);\n+    // TODO: Maybe use dladdr here to find a more useful name for the\n+    // type_desc.\n+\n+    void *p = task->malloc(nbytes, \"tdesc\", td);\n \n     LOG(task, mem,\n         \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n@@ -308,7 +318,7 @@ upcall_shared_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n     LOG(task, mem,\n                    \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n                    nbytes, td);\n-    void *p = task->kernel->malloc(nbytes);\n+    void *p = task->kernel->malloc(nbytes, \"shared malloc\");\n     LOG(task, mem,\n                    \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n                    \") = 0x%\" PRIxPTR,\n@@ -346,14 +356,13 @@ upcall_mark(rust_task *task, void* ptr) {\n }\n \n rust_str *make_str(rust_task *task, char const *s, size_t fill) {\n-    rust_scheduler *sched = task->sched;\n     size_t alloc = next_power_of_two(sizeof(rust_str) + fill);\n-    void *mem = task->malloc(alloc);\n+    void *mem = task->malloc(alloc, \"rust_str (make_str)\");\n     if (!mem) {\n         task->fail();\n         return NULL;\n     }\n-    rust_str *st = new (mem) rust_str(sched, alloc, fill,\n+    rust_str *st = new (mem) rust_str(alloc, fill,\n                                       (uint8_t const *) s);\n     LOG(task, mem,\n         \"upcall new_str('%s', %\" PRIdPTR \") = 0x%\" PRIxPTR,\n@@ -381,12 +390,12 @@ upcall_new_vec(rust_task *task, size_t fill, type_desc *td) {\n     rust_scheduler *sched = task->sched;\n     DLOG(sched, mem, \"upcall new_vec(%\" PRIdPTR \")\", fill);\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + fill);\n-    void *mem = task->malloc(alloc, td);\n+    void *mem = task->malloc(alloc, \"rust_vec (upcall_new_vec)\", td);\n     if (!mem) {\n         task->fail();\n         return NULL;\n     }\n-    rust_vec *v = new (mem) rust_vec(sched, alloc, 0, NULL);\n+    rust_vec *v = new (mem) rust_vec(alloc, 0, NULL);\n     LOG(task, mem,\n               \"upcall new_vec(%\" PRIdPTR \") = 0x%\" PRIxPTR, fill, v);\n     return v;\n@@ -441,7 +450,7 @@ vec_grow(rust_task *task,\n          * that we need the copies performed for us.\n          */\n         LOG(task, mem, \"new vec path\");\n-        void *mem = task->malloc(alloc, td);\n+        void *mem = task->malloc(alloc, \"rust_vec (vec_grow)\", td);\n         if (!mem) {\n             task->fail();\n             return NULL;\n@@ -450,7 +459,7 @@ vec_grow(rust_task *task,\n         if (v->ref_count != CONST_REFCOUNT)\n             v->deref();\n \n-        v = new (mem) rust_vec(sched, alloc, 0, NULL);\n+        v = new (mem) rust_vec(alloc, 0, NULL);\n         *need_copy = 1;\n     }\n     I(sched, sizeof(rust_vec) + v->fill <= v->alloc);\n@@ -599,7 +608,8 @@ upcall_ivec_spill_shared(rust_task *task,\n     size_t new_alloc = next_power_of_two(newsz);\n \n     rust_ivec_heap *heap_part = (rust_ivec_heap *)\n-        task->kernel->malloc(new_alloc + sizeof(size_t));\n+        task->kernel->malloc(new_alloc + sizeof(size_t),\n+                             \"ivec spill shared\");\n     heap_part->fill = newsz;\n     memcpy(&heap_part->data, v->payload.data, v->fill);\n "}, {"sha": "e1644e9f3cfdc2f04ed3b2636fa248697292a16d", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -23,7 +23,7 @@ ptr_vec<T>::ptr_vec(rust_task *task) :\n     task(task),\n     alloc(INIT_SIZE),\n     fill(0),\n-    data(new (task) T*[alloc])\n+    data(new (task, \"ptr_vec<T>\") T*[alloc])\n {\n     I(task->sched, data);\n     DLOG(task->sched, mem, \"new ptr_vec(data=0x%\" PRIxPTR \") -> 0x%\" PRIxPTR,\n@@ -175,7 +175,7 @@ rust_vec : public rc_base<rust_vec>\n     size_t fill;\n     size_t pad; // Pad to align data[0] to 16 bytes.\n     uint8_t data[];\n-    rust_vec(rust_scheduler *sched, size_t alloc, size_t fill,\n+    rust_vec(size_t alloc, size_t fill,\n              uint8_t const *d)\n         : alloc(alloc),\n           fill(fill)"}, {"sha": "bdff7c86a9ca790c6487b14ca752439ceb47b69b", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -53,6 +53,7 @@ task_yield\n task_join\n unsafe_vec_to_mut\n unsupervise\n+upcall_chan_target_task\n upcall_clone_chan\n upcall_del_chan\n upcall_del_port"}, {"sha": "29ab1f579b2feae867ddba1e047eb50643603af5", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae4dcd41e72d197e3882835253745f79588b04a/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=3ae4dcd41e72d197e3882835253745f79588b04a", "patch": "@@ -6,17 +6,30 @@ use std;\n import std::task;\n \n fn start(chan[chan[str]] c) {\n-    let port[str] p = port();\n+    let port[str] p;\n+\n+    p = port();\n     c <| chan(p);\n-    auto a; p |> a;\n-    // auto b; p |> b; // Never read the second string.\n+    p |> a;\n+    log_err a;\n+    p |> b;\n+    log_err b;\n+\n+    auto a;\n+    auto b;\n }\n \n fn main() {\n-    let port[chan[str]] p = port();\n-    auto child = spawn start(chan(p));\n-    auto c; p |> c;\n+    let port[chan[str]] p;\n+    auto child;\n+\n+    p = port();\n+    child = spawn start(chan(p));\n+\n+    p |> c;\n     c <| \"A\";\n     c <| \"B\";\n     task::yield();\n+\n+    auto c;\n }"}]}