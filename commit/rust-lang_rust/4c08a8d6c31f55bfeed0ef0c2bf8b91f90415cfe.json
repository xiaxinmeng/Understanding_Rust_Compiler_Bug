{"sha": "4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMDhhOGQ2YzMxZjU1YmZlZWQwZWYwYzJiZjhiOTFmOTA0MTVjZmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-23T23:33:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-23T23:59:13Z"}, "message": "Removing more unnecessary unsafe blocks throughout", "tree": {"sha": "a21a928f49a8acf805d87b3e7d11a43b342d3cdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a21a928f49a8acf805d87b3e7d11a43b342d3cdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "html_url": "https://github.com/rust-lang/rust/commit/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c089a17854669925c008a5944d0490f1692dde7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c089a17854669925c008a5944d0490f1692dde7e", "html_url": "https://github.com/rust-lang/rust/commit/c089a17854669925c008a5944d0490f1692dde7e"}], "stats": {"total": 180, "additions": 83, "deletions": 97}, "files": [{"sha": "a6bae3c76631c245e8f9e5184fcbff2153ac8aa3", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "patch": "@@ -231,66 +231,64 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     // the stack.\n     let mut reached_sentinel = ptr::is_null(sentinel);\n     for stackwalk::walk_stack |frame| {\n-        unsafe {\n-            let pc = last_ret;\n-            let Segment {segment: next_segment, boundary: boundary} =\n-                find_segment_for_frame(frame.fp, segment);\n-            segment = next_segment;\n-            // Each stack segment is bounded by a morestack frame. The\n-            // morestack frame includes two return addresses, one for\n-            // morestack itself, at the normal offset from the frame\n-            // pointer, and then a second return address for the\n-            // function prologue (which called morestack after\n-            // determining that it had hit the end of the stack).\n-            // Since morestack itself takes two parameters, the offset\n-            // for this second return address is 3 greater than the\n-            // return address for morestack.\n-            let ret_offset = if boundary { 4 } else { 1 };\n-            last_ret = *ptr::offset(frame.fp, ret_offset) as *Word;\n-\n-            if ptr::is_null(pc) {\n-                loop;\n-            }\n+        let pc = last_ret;\n+        let Segment {segment: next_segment, boundary: boundary} =\n+            find_segment_for_frame(frame.fp, segment);\n+        segment = next_segment;\n+        // Each stack segment is bounded by a morestack frame. The\n+        // morestack frame includes two return addresses, one for\n+        // morestack itself, at the normal offset from the frame\n+        // pointer, and then a second return address for the\n+        // function prologue (which called morestack after\n+        // determining that it had hit the end of the stack).\n+        // Since morestack itself takes two parameters, the offset\n+        // for this second return address is 3 greater than the\n+        // return address for morestack.\n+        let ret_offset = if boundary { 4 } else { 1 };\n+        last_ret = *ptr::offset(frame.fp, ret_offset) as *Word;\n+\n+        if ptr::is_null(pc) {\n+            loop;\n+        }\n \n-            let mut delay_reached_sentinel = reached_sentinel;\n-            let sp = is_safe_point(pc);\n-            match sp {\n-              Some(sp_info) => {\n-                for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n-                    // Skip roots until we see the sentinel.\n-                    if !reached_sentinel {\n-                        if root == sentinel {\n-                            delay_reached_sentinel = true;\n-                        }\n-                        loop;\n+        let mut delay_reached_sentinel = reached_sentinel;\n+        let sp = is_safe_point(pc);\n+        match sp {\n+          Some(sp_info) => {\n+            for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n+                // Skip roots until we see the sentinel.\n+                if !reached_sentinel {\n+                    if root == sentinel {\n+                        delay_reached_sentinel = true;\n                     }\n+                    loop;\n+                }\n \n-                    // Skip null pointers, which can occur when a\n-                    // unique pointer has already been freed.\n-                    if ptr::is_null(*root) {\n-                        loop;\n-                    }\n+                // Skip null pointers, which can occur when a\n+                // unique pointer has already been freed.\n+                if ptr::is_null(*root) {\n+                    loop;\n+                }\n \n-                    if ptr::is_null(tydesc) {\n-                        // Root is a generic box.\n-                        let refcount = **root;\n-                        if mem | task_local_heap != 0 && refcount != -1 {\n-                            if !visitor(root, tydesc) { return; }\n-                        } else if mem | exchange_heap != 0 && refcount == -1 {\n-                            if !visitor(root, tydesc) { return; }\n-                        }\n-                    } else {\n-                        // Root is a non-immediate.\n-                        if mem | stack != 0 {\n-                            if !visitor(root, tydesc) { return; }\n-                        }\n+                if ptr::is_null(tydesc) {\n+                    // Root is a generic box.\n+                    let refcount = **root;\n+                    if mem | task_local_heap != 0 && refcount != -1 {\n+                        if !visitor(root, tydesc) { return; }\n+                    } else if mem | exchange_heap != 0 && refcount == -1 {\n+                        if !visitor(root, tydesc) { return; }\n+                    }\n+                } else {\n+                    // Root is a non-immediate.\n+                    if mem | stack != 0 {\n+                        if !visitor(root, tydesc) { return; }\n                     }\n                 }\n-              }\n-              None => ()\n             }\n-            reached_sentinel = delay_reached_sentinel;\n+          }\n+          None => ()\n         }\n+        reached_sentinel = delay_reached_sentinel;\n     }\n }\n "}, {"sha": "2ec3afca61269f8efbcf7de9bf323a5ff3611582", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "patch": "@@ -156,9 +156,7 @@ pub impl PacketHeader {\n     unsafe fn unblock(&self) {\n         let old_task = swap_task(&mut self.blocked_task, ptr::null());\n         if !old_task.is_null() {\n-            unsafe {\n-                rustrt::rust_task_deref(old_task)\n-            }\n+            rustrt::rust_task_deref(old_task)\n         }\n         match swap_state_acq(&mut self.state, Empty) {\n           Empty | Blocked => (),"}, {"sha": "2d1e06163beb8b6e0bad785f590dcbf830aa2c59", "filename": "src/libcore/rt/sched/local_sched.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs?ref=4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "patch": "@@ -80,10 +80,8 @@ pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n }\n \n pub unsafe fn unsafe_borrow_io() -> &mut IoFactoryObject {\n-    unsafe {\n-        let sched = unsafe_borrow();\n-        return sched.event_loop.io().unwrap();\n-    }\n+    let sched = unsafe_borrow();\n+    return sched.event_loop.io().unwrap();\n }\n \n fn tls_key() -> tls::Key {"}, {"sha": "b7eff217ff8c6c40bb54b644661d13f720b5cb6b", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "patch": "@@ -98,7 +98,7 @@ pub enum uv_req_type {\n \n pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n     assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n-    let size = unsafe { rust_uv_handle_size(handle as uint) };\n+    let size = rust_uv_handle_size(handle as uint);\n     let p = malloc(size);\n     assert!(p.is_not_null());\n     return p;\n@@ -110,7 +110,7 @@ pub unsafe fn free_handle(v: *c_void) {\n \n pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n     assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n-    let size = unsafe { rust_uv_req_size(req as uint) };\n+    let size = rust_uv_req_size(req as uint);\n     let p = malloc(size);\n     assert!(p.is_not_null());\n     return p;"}, {"sha": "4a69de26f6b134a03f30d2d50d95904ddbf2fc7f", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "patch": "@@ -262,18 +262,16 @@ pub impl<T:Owned> Exclusive<T> {\n     // the exclusive. Supporting that is a work in progress.\n     #[inline(always)]\n     unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n-        unsafe {\n-            let rec = get_shared_mutable_state(&self.x);\n-            do (*rec).lock.lock {\n-                if (*rec).failed {\n-                    fail!(\n-                        ~\"Poisoned exclusive - another task failed inside!\");\n-                }\n-                (*rec).failed = true;\n-                let result = f(&mut (*rec).data);\n-                (*rec).failed = false;\n-                result\n+        let rec = get_shared_mutable_state(&self.x);\n+        do (*rec).lock.lock {\n+            if (*rec).failed {\n+                fail!(\n+                    ~\"Poisoned exclusive - another task failed inside!\");\n             }\n+            (*rec).failed = true;\n+            let result = f(&mut (*rec).data);\n+            (*rec).failed = false;\n+            result\n         }\n     }\n "}, {"sha": "7a30bb92111b16aeede078c56d78c77859d6bf8c", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "patch": "@@ -43,11 +43,11 @@ pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n     let task = get_task_id();\n     // Expect the weak task service to be alive\n     assert!(service.try_send(RegisterWeakTask(task, shutdown_chan)));\n-    unsafe { rust_dec_kernel_live_count(); }\n+    rust_dec_kernel_live_count();\n     do (|| {\n         f(shutdown_port.take())\n     }).finally || {\n-        unsafe { rust_inc_kernel_live_count(); }\n+        rust_inc_kernel_live_count();\n         // Service my have already exited\n         service.send(UnregisterWeakTask(task));\n     }"}, {"sha": "68405f4fc5fe201b800b16a454497c601eb2713b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "patch": "@@ -2628,13 +2628,11 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             let class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n             // This code shouldn't be reached if the class is generic\n             assert!(!ty::type_has_params(class_ty));\n-            let lldty = unsafe {\n-                T_fn(~[\n+            let lldty = T_fn(~[\n                     T_ptr(T_i8()),\n                     T_ptr(type_of(ccx, class_ty))\n                 ],\n-                T_nil())\n-            };\n+                T_nil());\n             let s = get_dtor_symbol(ccx, /*bad*/copy *pt, dt.node.id, None);\n \n             /* Make the declaration for the dtor */"}, {"sha": "33aa6171de4b70f774a9236222a47ecb9807b204", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=4c08a8d6c31f55bfeed0ef0c2bf8b91f90415cfe", "patch": "@@ -177,15 +177,13 @@ pub impl<T:Owned> MutexARC<T> {\n      */\n     #[inline(always)]\n     unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n-        unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n-            // Borrowck would complain about this if the function were\n-            // not already unsafe. See borrow_rwlock, far below.\n-            do (&(*state).lock).lock {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail(&mut (*state).failed);\n-                blk(&mut (*state).data)\n-            }\n+        let state = get_shared_mutable_state(&self.x);\n+        // Borrowck would complain about this if the function were\n+        // not already unsafe. See borrow_rwlock, far below.\n+        do (&(*state).lock).lock {\n+            check_poison(true, (*state).failed);\n+            let _z = PoisonOnFail(&mut (*state).failed);\n+            blk(&mut (*state).data)\n         }\n     }\n \n@@ -195,16 +193,14 @@ pub impl<T:Owned> MutexARC<T> {\n         &self,\n         blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U\n     {\n-        unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n-            do (&(*state).lock).lock_cond |cond| {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail(&mut (*state).failed);\n-                blk(&mut (*state).data,\n-                    &Condvar {is_mutex: true,\n-                              failed: &mut (*state).failed,\n-                              cond: cond })\n-            }\n+        let state = get_shared_mutable_state(&self.x);\n+        do (&(*state).lock).lock_cond |cond| {\n+            check_poison(true, (*state).failed);\n+            let _z = PoisonOnFail(&mut (*state).failed);\n+            blk(&mut (*state).data,\n+                &Condvar {is_mutex: true,\n+                          failed: &mut (*state).failed,\n+                          cond: cond })\n         }\n     }\n }"}]}