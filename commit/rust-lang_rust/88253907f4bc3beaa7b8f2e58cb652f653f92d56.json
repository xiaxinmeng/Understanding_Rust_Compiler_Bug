{"sha": "88253907f4bc3beaa7b8f2e58cb652f653f92d56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MjUzOTA3ZjRiYzNiZWFhN2I4ZjJlNThjYjY1MmY2NTNmOTJkNTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-12T18:01:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-12T18:01:36Z"}, "message": "Merge #7358\n\n7358: Refactor reference searching to work with the ast  r=matklad a=Veykril\n\nAddresses #4290\r\n\r\nThis PR is still a bit unpolished. Its main purpose for now is to discuss the direction of the changes as to whether this seems to be the right approach or not. I annotated a few parts with reviews to give a better overwiew without having to read into it too much.\r\n\r\nBig part of the diff are test output changes in the `references` module.\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "1669ff0e6ab614c679f245f84d0f9a8202366e0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1669ff0e6ab614c679f245f84d0f9a8202366e0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88253907f4bc3beaa7b8f2e58cb652f653f92d56", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgJsKACRBK7hj4Ov3rIwAAdHIIAKiRYJpK0xh1WR0YuxSemgCa\nxhKeIUZuGSxyWEQ1B6vyeQ/2PgRfA8swWd3pjz8gtveKA9mO0207DQ1O6SXlFLKw\n2ZivIN9IKcd1SomuZyB0QhOaxb5V5gIXU83tz4dFBXaqAJqzylmxo5aWZQTnwBjx\nfQ+D+2X+1FTmJmjl+gVmZhU6vIU0Xil/fuIMQZni9lngs2V9s3qqBlt0iFaCKKXE\nvtlS+q15FN8GM77AJqWsXjpvRsfmEbg4peXfdBIhSkrAi4HWJRqrZeGxPXy1aLUb\nPCIda0wv61Dq5vbcRaNBzLILv+JUHoBcHtEmtTnN8bf8urdd4+MDEj+l4KIka94=\n=gbq2\n-----END PGP SIGNATURE-----\n", "payload": "tree 1669ff0e6ab614c679f245f84d0f9a8202366e0e\nparent 4d51b5644458c7dcb97a4d445f1b379cd2548a78\nparent fd6cf4d566174dbdb50259bbbfdaf5a12f81544d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1613152896 +0000\ncommitter GitHub <noreply@github.com> 1613152896 +0000\n\nMerge #7358\n\n7358: Refactor reference searching to work with the ast  r=matklad a=Veykril\n\nAddresses #4290\r\n\r\nThis PR is still a bit unpolished. Its main purpose for now is to discuss the direction of the changes as to whether this seems to be the right approach or not. I annotated a few parts with reviews to give a better overwiew without having to read into it too much.\r\n\r\nBig part of the diff are test output changes in the `references` module.\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88253907f4bc3beaa7b8f2e58cb652f653f92d56", "html_url": "https://github.com/rust-lang/rust/commit/88253907f4bc3beaa7b8f2e58cb652f653f92d56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88253907f4bc3beaa7b8f2e58cb652f653f92d56/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d51b5644458c7dcb97a4d445f1b379cd2548a78", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d51b5644458c7dcb97a4d445f1b379cd2548a78", "html_url": "https://github.com/rust-lang/rust/commit/4d51b5644458c7dcb97a4d445f1b379cd2548a78"}, {"sha": "fd6cf4d566174dbdb50259bbbfdaf5a12f81544d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6cf4d566174dbdb50259bbbfdaf5a12f81544d", "html_url": "https://github.com/rust-lang/rust/commit/fd6cf4d566174dbdb50259bbbfdaf5a12f81544d"}], "stats": {"total": 886, "additions": 460, "deletions": 426}, "files": [{"sha": "8d28431cf6d32a85fc739b7f57a4db583e42782a", "filename": "crates/assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=88253907f4bc3beaa7b8f2e58cb652f653f92d56", "patch": "@@ -1,7 +1,6 @@\n-use ide_db::{\n-    defs::Definition,\n-    search::{FileReference, ReferenceKind},\n-};\n+use std::collections::HashMap;\n+\n+use ide_db::{defs::Definition, search::FileReference};\n use syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n@@ -68,44 +67,51 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n \n     let wrap_in_parens = usages\n         .references\n-        .values()\n-        .flatten()\n-        .map(|&FileReference { range, .. }| {\n-            let usage_node =\n-                ctx.covering_node_for_range(range).ancestors().find_map(ast::PathExpr::cast)?;\n-            let usage_parent_option = usage_node.syntax().parent().and_then(ast::Expr::cast);\n-            let usage_parent = match usage_parent_option {\n-                Some(u) => u,\n-                None => return Ok(false),\n-            };\n-\n-            Ok(!matches!(\n-                (&initializer_expr, usage_parent),\n-                (ast::Expr::CallExpr(_), _)\n-                    | (ast::Expr::IndexExpr(_), _)\n-                    | (ast::Expr::MethodCallExpr(_), _)\n-                    | (ast::Expr::FieldExpr(_), _)\n-                    | (ast::Expr::TryExpr(_), _)\n-                    | (ast::Expr::RefExpr(_), _)\n-                    | (ast::Expr::Literal(_), _)\n-                    | (ast::Expr::TupleExpr(_), _)\n-                    | (ast::Expr::ArrayExpr(_), _)\n-                    | (ast::Expr::ParenExpr(_), _)\n-                    | (ast::Expr::PathExpr(_), _)\n-                    | (ast::Expr::BlockExpr(_), _)\n-                    | (ast::Expr::EffectExpr(_), _)\n-                    | (_, ast::Expr::CallExpr(_))\n-                    | (_, ast::Expr::TupleExpr(_))\n-                    | (_, ast::Expr::ArrayExpr(_))\n-                    | (_, ast::Expr::ParenExpr(_))\n-                    | (_, ast::Expr::ForExpr(_))\n-                    | (_, ast::Expr::WhileExpr(_))\n-                    | (_, ast::Expr::BreakExpr(_))\n-                    | (_, ast::Expr::ReturnExpr(_))\n-                    | (_, ast::Expr::MatchExpr(_))\n-            ))\n+        .iter()\n+        .map(|(&file_id, refs)| {\n+            refs.iter()\n+                .map(|&FileReference { range, .. }| {\n+                    let usage_node = ctx\n+                        .covering_node_for_range(range)\n+                        .ancestors()\n+                        .find_map(ast::PathExpr::cast)?;\n+                    let usage_parent_option =\n+                        usage_node.syntax().parent().and_then(ast::Expr::cast);\n+                    let usage_parent = match usage_parent_option {\n+                        Some(u) => u,\n+                        None => return Ok(false),\n+                    };\n+\n+                    Ok(!matches!(\n+                        (&initializer_expr, usage_parent),\n+                        (ast::Expr::CallExpr(_), _)\n+                            | (ast::Expr::IndexExpr(_), _)\n+                            | (ast::Expr::MethodCallExpr(_), _)\n+                            | (ast::Expr::FieldExpr(_), _)\n+                            | (ast::Expr::TryExpr(_), _)\n+                            | (ast::Expr::RefExpr(_), _)\n+                            | (ast::Expr::Literal(_), _)\n+                            | (ast::Expr::TupleExpr(_), _)\n+                            | (ast::Expr::ArrayExpr(_), _)\n+                            | (ast::Expr::ParenExpr(_), _)\n+                            | (ast::Expr::PathExpr(_), _)\n+                            | (ast::Expr::BlockExpr(_), _)\n+                            | (ast::Expr::EffectExpr(_), _)\n+                            | (_, ast::Expr::CallExpr(_))\n+                            | (_, ast::Expr::TupleExpr(_))\n+                            | (_, ast::Expr::ArrayExpr(_))\n+                            | (_, ast::Expr::ParenExpr(_))\n+                            | (_, ast::Expr::ForExpr(_))\n+                            | (_, ast::Expr::WhileExpr(_))\n+                            | (_, ast::Expr::BreakExpr(_))\n+                            | (_, ast::Expr::ReturnExpr(_))\n+                            | (_, ast::Expr::MatchExpr(_))\n+                    ))\n+                })\n+                .collect::<Result<_, _>>()\n+                .map(|b| (file_id, b))\n         })\n-        .collect::<Result<Vec<_>, _>>()?;\n+        .collect::<Result<HashMap<_, Vec<_>>, _>>()?;\n \n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n@@ -117,16 +123,19 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         target,\n         move |builder| {\n             builder.delete(delete_range);\n-            for (reference, should_wrap) in usages.references.values().flatten().zip(wrap_in_parens)\n-            {\n-                let replacement =\n-                    if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-                match reference.kind {\n-                    ReferenceKind::FieldShorthandForLocal => {\n-                        mark::hit!(inline_field_shorthand);\n-                        builder.insert(reference.range.end(), format!(\": {}\", replacement))\n+            for (file_id, references) in usages.references {\n+                for (&should_wrap, reference) in wrap_in_parens[&file_id].iter().zip(references) {\n+                    let replacement =\n+                        if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n+                    match reference.name.as_name_ref() {\n+                        Some(name_ref)\n+                            if ast::RecordExprField::for_field_name(name_ref).is_some() =>\n+                        {\n+                            mark::hit!(inline_field_shorthand);\n+                            builder.insert(reference.range.end(), format!(\": {}\", replacement));\n+                        }\n+                        _ => builder.replace(reference.range, replacement),\n                     }\n-                    _ => builder.replace(reference.range, replacement),\n                 }\n             }\n         },"}, {"sha": "b848945d71379b91194592a824223a258f72e9c6", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=88253907f4bc3beaa7b8f2e58cb652f653f92d56", "patch": "@@ -47,11 +47,11 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n \n     let mut calls = CallLocations::default();\n \n-    for (&file_id, references) in refs.references().iter() {\n+    for (file_id, references) in refs.references {\n         let file = sema.parse(file_id);\n         let file = file.syntax();\n-        for reference in references {\n-            let token = file.token_at_offset(reference.range.start()).next()?;\n+        for (r_range, _) in references {\n+            let token = file.token_at_offset(r_range.start()).next()?;\n             let token = sema.descend_into_macros(token);\n             let syntax = token.parent();\n \n@@ -61,7 +61,7 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n                 let def = sema.to_def(&fn_)?;\n                 def.try_to_nav(sema.db)\n             }) {\n-                let relative_range = reference.range;\n+                let relative_range = r_range;\n                 calls.add(&nav, relative_range);\n             }\n         }"}, {"sha": "592b12925a1a5a4a683d2d0d0681abca6bd8ce6a", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=88253907f4bc3beaa7b8f2e58cb652f653f92d56", "patch": "@@ -73,7 +73,7 @@ pub use crate::{\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n     markup::Markup,\n     prime_caches::PrimeCachesProgress,\n-    references::{rename::RenameError, Declaration, ReferenceSearchResult},\n+    references::{rename::RenameError, ReferenceSearchResult},\n     runnables::{Runnable, RunnableKind, TestId},\n     syntax_highlighting::{\n         tags::{Highlight, HlMod, HlMods, HlPunct, HlTag},\n@@ -94,7 +94,7 @@ pub use ide_db::{\n     call_info::CallInfo,\n     label::Label,\n     line_index::{LineCol, LineIndex},\n-    search::{FileReference, ReferenceAccess, ReferenceKind, SearchScope},\n+    search::{ReferenceAccess, SearchScope},\n     source_change::{FileSystemEdit, SourceChange},\n     symbol_index::Query,\n     RootDatabase,"}, {"sha": "c7cefb3b68b28d26bedc69cd3272dde11e1aeecc", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 180, "deletions": 190, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=88253907f4bc3beaa7b8f2e58cb652f653f92d56", "patch": "@@ -11,14 +11,14 @@\n \n pub(crate) mod rename;\n \n-use either::Either;\n use hir::Semantics;\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n-    search::{FileReference, ReferenceAccess, ReferenceKind, SearchScope, UsageSearchResult},\n+    search::{ReferenceAccess, SearchScope},\n     RootDatabase,\n };\n+use rustc_hash::FxHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n@@ -29,52 +29,16 @@ use crate::{display::TryToNav, FilePosition, NavigationTarget};\n \n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n-    declaration: Declaration,\n-    references: UsageSearchResult,\n+    pub declaration: Declaration,\n+    pub references: FxHashMap<FileId, Vec<(TextRange, Option<ReferenceAccess>)>>,\n }\n \n #[derive(Debug, Clone)]\n pub struct Declaration {\n     pub nav: NavigationTarget,\n-    pub kind: ReferenceKind,\n     pub access: Option<ReferenceAccess>,\n }\n \n-impl ReferenceSearchResult {\n-    pub fn references(&self) -> &UsageSearchResult {\n-        &self.references\n-    }\n-\n-    pub fn references_with_declaration(mut self) -> UsageSearchResult {\n-        let decl_ref = FileReference {\n-            range: self.declaration.nav.focus_or_full_range(),\n-            kind: self.declaration.kind,\n-            access: self.declaration.access,\n-        };\n-        let file_id = self.declaration.nav.file_id;\n-        self.references.references.entry(file_id).or_default().push(decl_ref);\n-        self.references\n-    }\n-\n-    /// Total number of references\n-    /// At least 1 since all valid references should\n-    /// Have a declaration\n-    pub fn len(&self) -> usize {\n-        self.references.len() + 1\n-    }\n-}\n-\n-// allow turning ReferenceSearchResult into an iterator\n-// over References\n-impl IntoIterator for ReferenceSearchResult {\n-    type Item = (FileId, Vec<FileReference>);\n-    type IntoIter = std::collections::hash_map::IntoIter<FileId, Vec<FileReference>>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.references_with_declaration().into_iter()\n-    }\n-}\n-\n pub(crate) fn find_all_refs(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n@@ -83,83 +47,72 @@ pub(crate) fn find_all_refs(\n     let _p = profile::span(\"find_all_refs\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n \n-    let (opt_name, search_kind) = if let Some(name) =\n+    let (opt_name, ctor_filter): (_, Option<fn(&_) -> bool>) = if let Some(name) =\n         get_struct_def_name_for_struct_literal_search(&sema, &syntax, position)\n     {\n-        (Some(name), ReferenceKind::StructLiteral)\n+        (\n+            Some(name),\n+            Some(|name_ref| is_record_lit_name_ref(name_ref) || is_call_expr_name_ref(name_ref)),\n+        )\n     } else if let Some(name) = get_enum_def_name_for_struct_literal_search(&sema, &syntax, position)\n     {\n-        (Some(name), ReferenceKind::EnumLiteral)\n+        (Some(name), Some(is_enum_lit_name_ref))\n     } else {\n-        (\n-            sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, position.offset),\n-            ReferenceKind::Other,\n-        )\n+        (sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, position.offset), None)\n     };\n \n-    let def = find_name(&sema, &syntax, position, opt_name)?;\n+    let def = find_def(&sema, &syntax, position, opt_name)?;\n \n     let mut usages = def.usages(sema).set_scope(search_scope).all();\n-    usages\n-        .references\n-        .values_mut()\n-        .for_each(|it| it.retain(|r| search_kind == ReferenceKind::Other || search_kind == r.kind));\n-    usages.references.retain(|_, it| !it.is_empty());\n-\n+    if let Some(ctor_filter) = ctor_filter {\n+        // filter for constructor-literals\n+        usages.references.values_mut().for_each(|it| {\n+            it.retain(|reference| reference.name.as_name_ref().map_or(false, ctor_filter));\n+        });\n+        usages.references.retain(|_, it| !it.is_empty());\n+    }\n     let nav = def.try_to_nav(sema.db)?;\n     let decl_range = nav.focus_or_full_range();\n \n-    let mut kind = ReferenceKind::Other;\n-    if let Definition::Local(local) = def {\n-        match local.source(sema.db).value {\n-            Either::Left(pat) => {\n-                if matches!(\n-                    pat.syntax().parent().and_then(ast::RecordPatField::cast),\n-                    Some(pat_field) if pat_field.name_ref().is_none()\n-                ) {\n-                    kind = ReferenceKind::FieldShorthandForLocal;\n-                }\n-            }\n-            Either::Right(_) => kind = ReferenceKind::SelfParam,\n-        }\n-    } else if matches!(\n-        def,\n-        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n-    ) {\n-        kind = ReferenceKind::Lifetime;\n-    };\n-\n-    let declaration = Declaration { nav, kind, access: decl_access(&def, &syntax, decl_range) };\n+    let declaration = Declaration { nav, access: decl_access(&def, &syntax, decl_range) };\n+    let references = usages\n+        .into_iter()\n+        .map(|(file_id, refs)| {\n+            (file_id, refs.into_iter().map(|file_ref| (file_ref.range, file_ref.access)).collect())\n+        })\n+        .collect();\n \n-    Some(ReferenceSearchResult { declaration, references: usages })\n+    Some(ReferenceSearchResult { declaration, references })\n }\n \n-fn find_name(\n+fn find_def(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n     opt_name: Option<ast::Name>,\n ) -> Option<Definition> {\n-    let def = if let Some(name) = opt_name {\n-        NameClass::classify(sema, &name)?.referenced_or_defined(sema.db)\n+    if let Some(name) = opt_name {\n+        let class = NameClass::classify(sema, &name)?;\n+        Some(class.referenced_or_defined(sema.db))\n     } else if let Some(lifetime) =\n         sema.find_node_at_offset_with_descend::<ast::Lifetime>(&syntax, position.offset)\n     {\n-        if let Some(def) =\n+        let def = if let Some(def) =\n             NameRefClass::classify_lifetime(sema, &lifetime).map(|class| class.referenced(sema.db))\n         {\n             def\n         } else {\n             NameClass::classify_lifetime(sema, &lifetime)?.referenced_or_defined(sema.db)\n-        }\n+        };\n+        Some(def)\n     } else if let Some(name_ref) =\n         sema.find_node_at_offset_with_descend::<ast::NameRef>(&syntax, position.offset)\n     {\n-        NameRefClass::classify(sema, &name_ref)?.referenced(sema.db)\n+        let class = NameRefClass::classify(sema, &name_ref)?;\n+        Some(class.referenced(sema.db))\n     } else {\n-        return None;\n-    };\n-    Some(def)\n+        None\n+    }\n }\n \n fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Option<ReferenceAccess> {\n@@ -235,6 +188,43 @@ fn get_enum_def_name_for_struct_literal_search(\n     None\n }\n \n+fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::CallExpr::cast)\n+        .and_then(|c| match c.expr()? {\n+            ast::Expr::PathExpr(p) => {\n+                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or(false)\n+}\n+\n+fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::RecordExpr::cast)\n+        .and_then(|l| l.path())\n+        .and_then(|p| p.segment())\n+        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n+        .unwrap_or(false)\n+}\n+\n+fn is_enum_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::PathExpr::cast)\n+        .and_then(|p| p.path())\n+        .and_then(|p| p.qualifier())\n+        .and_then(|p| p.segment())\n+        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n+        .unwrap_or(false)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n@@ -259,9 +249,9 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                Foo Struct FileId(0) 0..26 7..10 Other\n+                Foo Struct FileId(0) 0..26 7..10\n \n-                FileId(0) 101..104 StructLiteral\n+                FileId(0) 101..104\n             \"#]],\n         );\n     }\n@@ -277,10 +267,10 @@ struct Foo$0 {}\n }\n \"#,\n             expect![[r#\"\n-                Foo Struct FileId(0) 0..13 7..10 Other\n+                Foo Struct FileId(0) 0..13 7..10\n \n-                FileId(0) 41..44 Other\n-                FileId(0) 54..57 StructLiteral\n+                FileId(0) 41..44\n+                FileId(0) 54..57\n             \"#]],\n         );\n     }\n@@ -296,9 +286,9 @@ struct Foo<T> $0{}\n }\n \"#,\n             expect![[r#\"\n-                Foo Struct FileId(0) 0..16 7..10 Other\n+                Foo Struct FileId(0) 0..16 7..10\n \n-                FileId(0) 64..67 StructLiteral\n+                FileId(0) 64..67\n             \"#]],\n         );\n     }\n@@ -315,9 +305,9 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                Foo Struct FileId(0) 0..16 7..10 Other\n+                Foo Struct FileId(0) 0..16 7..10\n \n-                FileId(0) 54..57 StructLiteral\n+                FileId(0) 54..57\n             \"#]],\n         );\n     }\n@@ -336,9 +326,9 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                Foo Enum FileId(0) 0..26 5..8 Other\n+                Foo Enum FileId(0) 0..26 5..8\n \n-                FileId(0) 63..66 EnumLiteral\n+                FileId(0) 63..66\n             \"#]],\n         );\n     }\n@@ -357,10 +347,10 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                Foo Enum FileId(0) 0..26 5..8 Other\n+                Foo Enum FileId(0) 0..26 5..8\n \n-                FileId(0) 50..53 Other\n-                FileId(0) 63..66 EnumLiteral\n+                FileId(0) 50..53\n+                FileId(0) 63..66\n             \"#]],\n         );\n     }\n@@ -379,9 +369,9 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                Foo Enum FileId(0) 0..32 5..8 Other\n+                Foo Enum FileId(0) 0..32 5..8\n \n-                FileId(0) 73..76 EnumLiteral\n+                FileId(0) 73..76\n             \"#]],\n         );\n     }\n@@ -400,9 +390,9 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                Foo Enum FileId(0) 0..33 5..8 Other\n+                Foo Enum FileId(0) 0..33 5..8\n \n-                FileId(0) 70..73 EnumLiteral\n+                FileId(0) 70..73\n             \"#]],\n         );\n     }\n@@ -423,12 +413,12 @@ fn main() {\n     i = 5;\n }\"#,\n             expect![[r#\"\n-                i Local FileId(0) 20..25 24..25 Other Write\n+                i Local FileId(0) 20..25 24..25 Write\n \n-                FileId(0) 50..51 Other Write\n-                FileId(0) 54..55 Other Read\n-                FileId(0) 76..77 Other Write\n-                FileId(0) 94..95 Other Write\n+                FileId(0) 50..51 Write\n+                FileId(0) 54..55 Read\n+                FileId(0) 76..77 Write\n+                FileId(0) 94..95 Write\n             \"#]],\n         );\n     }\n@@ -447,10 +437,10 @@ fn bar() {\n }\n \"#,\n             expect![[r#\"\n-                spam Local FileId(0) 19..23 19..23 Other\n+                spam Local FileId(0) 19..23 19..23\n \n-                FileId(0) 34..38 Other Read\n-                FileId(0) 41..45 Other Read\n+                FileId(0) 34..38 Read\n+                FileId(0) 41..45 Read\n             \"#]],\n         );\n     }\n@@ -462,9 +452,9 @@ fn bar() {\n fn foo(i : u32) -> u32 { i$0 }\n \"#,\n             expect![[r#\"\n-                i ValueParam FileId(0) 7..8 7..8 Other\n+                i ValueParam FileId(0) 7..8 7..8\n \n-                FileId(0) 25..26 Other Read\n+                FileId(0) 25..26 Read\n             \"#]],\n         );\n     }\n@@ -476,9 +466,9 @@ fn foo(i : u32) -> u32 { i$0 }\n fn foo(i$0 : u32) -> u32 { i }\n \"#,\n             expect![[r#\"\n-                i ValueParam FileId(0) 7..8 7..8 Other\n+                i ValueParam FileId(0) 7..8 7..8\n \n-                FileId(0) 25..26 Other Read\n+                FileId(0) 25..26 Read\n             \"#]],\n         );\n     }\n@@ -497,9 +487,9 @@ fn main(s: Foo) {\n }\n \"#,\n             expect![[r#\"\n-                spam Field FileId(0) 17..30 21..25 Other\n+                spam Field FileId(0) 17..30 21..25\n \n-                FileId(0) 67..71 Other Read\n+                FileId(0) 67..71 Read\n             \"#]],\n         );\n     }\n@@ -514,7 +504,7 @@ impl Foo {\n }\n \"#,\n             expect![[r#\"\n-                f Function FileId(0) 27..43 30..31 Other\n+                f Function FileId(0) 27..43 30..31\n \n             \"#]],\n         );\n@@ -531,7 +521,7 @@ enum Foo {\n }\n \"#,\n             expect![[r#\"\n-                B Variant FileId(0) 22..23 22..23 Other\n+                B Variant FileId(0) 22..23 22..23\n \n             \"#]],\n         );\n@@ -548,7 +538,7 @@ enum Foo {\n }\n \"#,\n             expect![[r#\"\n-                field Field FileId(0) 26..35 26..31 Other\n+                field Field FileId(0) 26..35 26..31\n \n             \"#]],\n         );\n@@ -589,10 +579,10 @@ fn f() {\n }\n \"#,\n             expect![[r#\"\n-                Foo Struct FileId(1) 17..51 28..31 Other\n+                Foo Struct FileId(1) 17..51 28..31\n \n-                FileId(0) 53..56 StructLiteral\n-                FileId(2) 79..82 StructLiteral\n+                FileId(0) 53..56\n+                FileId(2) 79..82\n             \"#]],\n         );\n     }\n@@ -619,9 +609,9 @@ pub struct Foo {\n }\n \"#,\n             expect![[r#\"\n-                foo Module FileId(1) 0..35 Other\n+                foo Module FileId(1) 0..35\n \n-                FileId(0) 14..17 Other\n+                FileId(0) 14..17\n             \"#]],\n         );\n     }\n@@ -647,10 +637,10 @@ pub(super) struct Foo$0 {\n }\n \"#,\n             expect![[r#\"\n-                Foo Struct FileId(2) 0..41 18..21 Other\n+                Foo Struct FileId(2) 0..41 18..21\n \n-                FileId(1) 20..23 Other\n-                FileId(1) 47..50 StructLiteral\n+                FileId(1) 20..23\n+                FileId(1) 47..50\n             \"#]],\n         );\n     }\n@@ -675,20 +665,20 @@ pub(super) struct Foo$0 {\n             code,\n             None,\n             expect![[r#\"\n-                quux Function FileId(0) 19..35 26..30 Other\n+                quux Function FileId(0) 19..35 26..30\n \n-                FileId(1) 16..20 StructLiteral\n-                FileId(2) 16..20 StructLiteral\n+                FileId(1) 16..20\n+                FileId(2) 16..20\n             \"#]],\n         );\n \n         check_with_scope(\n             code,\n             Some(SearchScope::single_file(FileId(2))),\n             expect![[r#\"\n-                quux Function FileId(0) 19..35 26..30 Other\n+                quux Function FileId(0) 19..35 26..30\n \n-                FileId(2) 16..20 StructLiteral\n+                FileId(2) 16..20\n             \"#]],\n         );\n     }\n@@ -706,10 +696,10 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                m1 Macro FileId(0) 0..46 29..31 Other\n+                m1 Macro FileId(0) 0..46 29..31\n \n-                FileId(0) 63..65 StructLiteral\n-                FileId(0) 73..75 StructLiteral\n+                FileId(0) 63..65\n+                FileId(0) 73..75\n             \"#]],\n         );\n     }\n@@ -724,10 +714,10 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                i Local FileId(0) 19..24 23..24 Other Write\n+                i Local FileId(0) 19..24 23..24 Write\n \n-                FileId(0) 34..35 Other Write\n-                FileId(0) 38..39 Other Read\n+                FileId(0) 34..35 Write\n+                FileId(0) 38..39 Read\n             \"#]],\n         );\n     }\n@@ -746,10 +736,10 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                f Field FileId(0) 15..21 15..16 Other\n+                f Field FileId(0) 15..21 15..16\n \n-                FileId(0) 55..56 RecordFieldExprOrPat Read\n-                FileId(0) 68..69 Other Write\n+                FileId(0) 55..56 Read\n+                FileId(0) 68..69 Write\n             \"#]],\n         );\n     }\n@@ -764,9 +754,9 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                i Local FileId(0) 19..20 19..20 Other\n+                i Local FileId(0) 19..20 19..20\n \n-                FileId(0) 26..27 Other Write\n+                FileId(0) 26..27 Write\n             \"#]],\n         );\n     }\n@@ -788,9 +778,9 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                new Function FileId(0) 54..81 61..64 Other\n+                new Function FileId(0) 54..81 61..64\n \n-                FileId(0) 126..129 StructLiteral\n+                FileId(0) 126..129\n             \"#]],\n         );\n     }\n@@ -810,10 +800,10 @@ use crate::f;\n fn g() { f(); }\n \"#,\n             expect![[r#\"\n-                f Function FileId(0) 22..31 25..26 Other\n+                f Function FileId(0) 22..31 25..26\n \n-                FileId(1) 11..12 Other\n-                FileId(1) 24..25 StructLiteral\n+                FileId(1) 11..12\n+                FileId(1) 24..25\n             \"#]],\n         );\n     }\n@@ -833,9 +823,9 @@ fn f(s: S) {\n }\n \"#,\n             expect![[r#\"\n-                field Field FileId(0) 15..24 15..20 Other\n+                field Field FileId(0) 15..24 15..20\n \n-                FileId(0) 68..73 FieldShorthandForField Read\n+                FileId(0) 68..73 Read\n             \"#]],\n         );\n     }\n@@ -857,9 +847,9 @@ fn f(e: En) {\n }\n \"#,\n             expect![[r#\"\n-                field Field FileId(0) 32..41 32..37 Other\n+                field Field FileId(0) 32..41 32..37\n \n-                FileId(0) 102..107 FieldShorthandForField Read\n+                FileId(0) 102..107 Read\n             \"#]],\n         );\n     }\n@@ -881,9 +871,9 @@ fn f() -> m::En {\n }\n \"#,\n             expect![[r#\"\n-                field Field FileId(0) 56..65 56..61 Other\n+                field Field FileId(0) 56..65 56..61\n \n-                FileId(0) 125..130 RecordFieldExprOrPat Read\n+                FileId(0) 125..130 Read\n             \"#]],\n         );\n     }\n@@ -906,10 +896,10 @@ impl Foo {\n }\n \"#,\n             expect![[r#\"\n-                self SelfParam FileId(0) 47..51 47..51 SelfParam\n+                self SelfParam FileId(0) 47..51 47..51\n \n-                FileId(0) 71..75 Other Read\n-                FileId(0) 152..156 Other Read\n+                FileId(0) 71..75 Read\n+                FileId(0) 152..156 Read\n             \"#]],\n         );\n     }\n@@ -927,9 +917,9 @@ impl Foo {\n }\n \"#,\n             expect![[r#\"\n-                self SelfParam FileId(0) 47..51 47..51 SelfParam\n+                self SelfParam FileId(0) 47..51 47..51\n \n-                FileId(0) 63..67 Other Read\n+                FileId(0) 63..67 Read\n             \"#]],\n         );\n     }\n@@ -945,17 +935,17 @@ impl Foo {\n         let mut actual = String::new();\n         {\n             let decl = refs.declaration;\n-            format_to!(actual, \"{} {:?}\", decl.nav.debug_render(), decl.kind);\n+            format_to!(actual, \"{}\", decl.nav.debug_render());\n             if let Some(access) = decl.access {\n                 format_to!(actual, \" {:?}\", access)\n             }\n             actual += \"\\n\\n\";\n         }\n \n         for (file_id, references) in refs.references {\n-            for r in references {\n-                format_to!(actual, \"{:?} {:?} {:?}\", file_id, r.range, r.kind);\n-                if let Some(access) = r.access {\n+            for (range, access) in references {\n+                format_to!(actual, \"{:?} {:?}\", file_id, range);\n+                if let Some(access) = access {\n                     format_to!(actual, \" {:?}\", access);\n                 }\n                 actual += \"\\n\";\n@@ -976,13 +966,13 @@ fn foo<'a, 'b: 'a>(x: &'a$0 ()) -> &'a () where &'a (): Foo<'a> {\n }\n \"#,\n             expect![[r#\"\n-                'a LifetimeParam FileId(0) 55..57 55..57 Lifetime\n+                'a LifetimeParam FileId(0) 55..57 55..57\n \n-                FileId(0) 63..65 Lifetime\n-                FileId(0) 71..73 Lifetime\n-                FileId(0) 82..84 Lifetime\n-                FileId(0) 95..97 Lifetime\n-                FileId(0) 106..108 Lifetime\n+                FileId(0) 63..65\n+                FileId(0) 71..73\n+                FileId(0) 82..84\n+                FileId(0) 95..97\n+                FileId(0) 106..108\n             \"#]],\n         );\n     }\n@@ -994,10 +984,10 @@ fn foo<'a, 'b: 'a>(x: &'a$0 ()) -> &'a () where &'a (): Foo<'a> {\n type Foo<'a, T> where T: 'a$0 = &'a T;\n \"#,\n             expect![[r#\"\n-                'a LifetimeParam FileId(0) 9..11 9..11 Lifetime\n+                'a LifetimeParam FileId(0) 9..11 9..11\n \n-                FileId(0) 25..27 Lifetime\n-                FileId(0) 31..33 Lifetime\n+                FileId(0) 25..27\n+                FileId(0) 31..33\n             \"#]],\n         );\n     }\n@@ -1016,11 +1006,11 @@ impl<'a> Foo<'a> for &'a () {\n }\n \"#,\n             expect![[r#\"\n-                'a LifetimeParam FileId(0) 47..49 47..49 Lifetime\n+                'a LifetimeParam FileId(0) 47..49 47..49\n \n-                FileId(0) 55..57 Lifetime\n-                FileId(0) 64..66 Lifetime\n-                FileId(0) 89..91 Lifetime\n+                FileId(0) 55..57\n+                FileId(0) 64..66\n+                FileId(0) 89..91\n             \"#]],\n         );\n     }\n@@ -1036,9 +1026,9 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                a Local FileId(0) 59..60 59..60 Other\n+                a Local FileId(0) 59..60 59..60\n \n-                FileId(0) 80..81 Other Read\n+                FileId(0) 80..81 Read\n             \"#]],\n         );\n     }\n@@ -1054,9 +1044,9 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                a Local FileId(0) 59..60 59..60 Other\n+                a Local FileId(0) 59..60 59..60\n \n-                FileId(0) 80..81 Other Read\n+                FileId(0) 80..81 Read\n             \"#]],\n         );\n     }\n@@ -1075,10 +1065,10 @@ fn foo<'a>() -> &'a () {\n }\n \"#,\n             expect![[r#\"\n-                'a Label FileId(0) 29..32 29..31 Lifetime\n+                'a Label FileId(0) 29..32 29..31\n \n-                FileId(0) 80..82 Lifetime\n-                FileId(0) 108..110 Lifetime\n+                FileId(0) 80..82\n+                FileId(0) 108..110\n             \"#]],\n         );\n     }\n@@ -1092,9 +1082,9 @@ fn foo<const FOO$0: usize>() -> usize {\n }\n \"#,\n             expect![[r#\"\n-                FOO ConstParam FileId(0) 7..23 13..16 Other\n+                FOO ConstParam FileId(0) 7..23 13..16\n \n-                FileId(0) 42..45 Other\n+                FileId(0) 42..45\n             \"#]],\n         );\n     }\n@@ -1108,9 +1098,9 @@ trait Foo {\n }\n \"#,\n             expect![[r#\"\n-                Self TypeParam FileId(0) 6..9 6..9 Other\n+                Self TypeParam FileId(0) 6..9 6..9\n \n-                FileId(0) 26..30 Other\n+                FileId(0) 26..30\n             \"#]],\n         );\n     }\n@@ -1131,9 +1121,9 @@ impl Foo {\n \n \"#,\n             expect![[r#\"\n-                Bar Variant FileId(0) 11..16 11..14 Other\n+                Bar Variant FileId(0) 11..16 11..14\n \n-                FileId(0) 89..92 Other\n+                FileId(0) 89..92\n             \"#]],\n         );\n     }"}, {"sha": "b04214291ae1816f39ca8db4790042ebe898333b", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 118, "deletions": 79, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=88253907f4bc3beaa7b8f2e58cb652f653f92d56", "patch": "@@ -4,9 +4,9 @@ use std::fmt::{self, Display};\n use either::Either;\n use hir::{HasSource, InFile, Module, ModuleDef, ModuleSource, Semantics};\n use ide_db::{\n-    base_db::{AnchoredPathBuf, FileId, FileRange},\n+    base_db::{AnchoredPathBuf, FileId},\n     defs::{Definition, NameClass, NameRefClass},\n-    search::FileReference,\n+    search::{FileReference, NameLike},\n     RootDatabase,\n };\n use stdx::never;\n@@ -17,10 +17,7 @@ use syntax::{\n use test_utils::mark;\n use text_edit::TextEdit;\n \n-use crate::{\n-    display::TryToNav, FilePosition, FileSystemEdit, RangeInfo, ReferenceKind, SourceChange,\n-    TextRange,\n-};\n+use crate::{display::TryToNav, FilePosition, FileSystemEdit, RangeInfo, SourceChange, TextRange};\n \n type RenameResult<T> = Result<T, RenameError>;\n #[derive(Debug)]\n@@ -41,6 +38,8 @@ macro_rules! bail {\n     ($($tokens:tt)*) => {return Err(format_err!($($tokens)*))}\n }\n \n+/// Prepares a rename. The sole job of this function is to return the TextRange of the thing that is\n+/// being targeted for a rename.\n pub(crate) fn prepare_rename(\n     db: &RootDatabase,\n     position: FilePosition,\n@@ -123,12 +122,6 @@ fn check_identifier(new_name: &str) -> RenameResult<IdentifierKind> {\n     }\n }\n \n-enum NameLike {\n-    Name(ast::Name),\n-    NameRef(ast::NameRef),\n-    Lifetime(ast::Lifetime),\n-}\n-\n fn find_name_like(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n@@ -171,72 +164,97 @@ fn find_definition(\n }\n \n fn source_edit_from_references(\n-    sema: &Semantics<RootDatabase>,\n+    _sema: &Semantics<RootDatabase>,\n     file_id: FileId,\n     references: &[FileReference],\n+    def: Definition,\n     new_name: &str,\n ) -> (FileId, TextEdit) {\n     let mut edit = TextEdit::builder();\n     for reference in references {\n-        let mut replacement_text = String::new();\n-        let range = match reference.kind {\n-            ReferenceKind::FieldShorthandForField => {\n-                mark::hit!(test_rename_struct_field_for_shorthand);\n-                replacement_text.push_str(new_name);\n-                replacement_text.push_str(\": \");\n-                TextRange::new(reference.range.start(), reference.range.start())\n-            }\n-            ReferenceKind::FieldShorthandForLocal => {\n-                mark::hit!(test_rename_local_for_field_shorthand);\n-                replacement_text.push_str(\": \");\n-                replacement_text.push_str(new_name);\n-                TextRange::new(reference.range.end(), reference.range.end())\n-            }\n-            ReferenceKind::RecordFieldExprOrPat => {\n-                mark::hit!(test_rename_field_expr_pat);\n-                replacement_text.push_str(new_name);\n-                edit_text_range_for_record_field_expr_or_pat(\n-                    sema,\n-                    FileRange { file_id, range: reference.range },\n-                    new_name,\n-                )\n-            }\n-            _ => {\n-                replacement_text.push_str(new_name);\n-                reference.range\n-            }\n+        let (range, replacement) = match &reference.name {\n+            NameLike::Name(_) => (None, format!(\"{}\", new_name)),\n+            NameLike::NameRef(name_ref) => source_edit_from_name_ref(name_ref, new_name, def),\n+            NameLike::Lifetime(_) => (None, format!(\"{}\", new_name)),\n         };\n-        edit.replace(range, replacement_text);\n+        // FIXME: Some(range) will be incorrect when we are inside macros\n+        edit.replace(range.unwrap_or(reference.range), replacement);\n     }\n     (file_id, edit.finish())\n }\n \n-fn edit_text_range_for_record_field_expr_or_pat(\n-    sema: &Semantics<RootDatabase>,\n-    file_range: FileRange,\n+fn source_edit_from_name_ref(\n+    name_ref: &ast::NameRef,\n     new_name: &str,\n-) -> TextRange {\n-    let source_file = sema.parse(file_range.file_id);\n-    let file_syntax = source_file.syntax();\n-    let original_range = file_range.range;\n-\n-    syntax::algo::find_node_at_range::<ast::RecordExprField>(file_syntax, original_range)\n-        .and_then(|field_expr| match field_expr.expr().and_then(|e| e.name_ref()) {\n-            Some(name) if &name.to_string() == new_name => Some(field_expr.syntax().text_range()),\n-            _ => None,\n-        })\n-        .or_else(|| {\n-            syntax::algo::find_node_at_range::<ast::RecordPatField>(file_syntax, original_range)\n-                .and_then(|field_pat| match field_pat.pat() {\n-                    Some(ast::Pat::IdentPat(pat))\n-                        if pat.name().map(|n| n.to_string()).as_deref() == Some(new_name) =>\n-                    {\n-                        Some(field_pat.syntax().text_range())\n+    def: Definition,\n+) -> (Option<TextRange>, String) {\n+    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_expr = record_field.expr();\n+        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n+            // field: init-expr, check if we can use a field init shorthand\n+            (Some(field_name), Some(init)) => {\n+                if field_name == *name_ref {\n+                    if init.text() == new_name {\n+                        mark::hit!(test_rename_field_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n                     }\n-                    _ => None,\n-                })\n-        })\n-        .unwrap_or(original_range)\n+                } else if init == *name_ref {\n+                    if field_name.text() == new_name {\n+                        mark::hit!(test_rename_local_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n+                    }\n+                }\n+            }\n+            // init shorthand\n+            (None, Some(_)) => {\n+                // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n+                // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n+                match def {\n+                    Definition::Field(_) => {\n+                        mark::hit!(test_rename_field_in_field_shorthand);\n+                        let s = name_ref.syntax().text_range().start();\n+                        return (Some(TextRange::empty(s)), format!(\"{}: \", new_name));\n+                    }\n+                    Definition::Local(_) => {\n+                        mark::hit!(test_rename_local_in_field_shorthand);\n+                        let s = name_ref.syntax().text_range().end();\n+                        return (Some(TextRange::empty(s)), format!(\": {}\", new_name));\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_pat = record_field.pat();\n+        match (rcf_name_ref, rcf_pat) {\n+            // field: rename\n+            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n+                // field name is being renamed\n+                if pat.name().map_or(false, |it| it.text() == new_name) {\n+                    mark::hit!(test_rename_field_put_init_shorthand_pat);\n+                    // same names, we can use a shorthand here instead\n+                    // we do not want to erase attributes hence this range start\n+                    let s = field_name.syntax().text_range().start();\n+                    let e = record_field.syntax().text_range().end();\n+                    return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    (None, format!(\"{}\", new_name))\n }\n \n fn rename_mod(\n@@ -277,7 +295,7 @@ fn rename_mod(\n     let def = Definition::ModuleDef(ModuleDef::Module(module));\n     let usages = def.usages(sema).all();\n     let ref_edits = usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, references, new_name)\n+        source_edit_from_references(sema, file_id, references, def, new_name)\n     });\n     source_change.extend(ref_edits);\n \n@@ -346,7 +364,7 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n     let usages = def.usages(sema).all();\n     let mut source_change = SourceChange::default();\n     source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, references, \"self\")\n+        source_edit_from_references(sema, file_id, references, def, \"self\")\n     }));\n     source_change.insert_source_edit(\n         file_id.original_file(sema.db),\n@@ -403,7 +421,7 @@ fn rename_self_to_param(\n     let mut source_change = SourceChange::default();\n     source_change.insert_source_edit(file_id.original_file(sema.db), edit);\n     source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, &references, new_name)\n+        source_edit_from_references(sema, file_id, &references, def, new_name)\n     }));\n     Ok(source_change)\n }\n@@ -457,7 +475,7 @@ fn rename_reference(\n     }\n     let mut source_change = SourceChange::default();\n     source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, &references, new_name)\n+        source_edit_from_references(sema, file_id, &references, def, new_name)\n     }));\n \n     let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n@@ -545,10 +563,8 @@ mod tests {\n \n     fn check_expect(new_name: &str, ra_fixture: &str, expect: Expect) {\n         let (analysis, position) = fixture::position(ra_fixture);\n-        let source_change = analysis\n-            .rename(position, new_name)\n-            .unwrap()\n-            .expect(\"Expect returned RangeInfo to be Some, but was None\");\n+        let source_change =\n+            analysis.rename(position, new_name).unwrap().expect(\"Expect returned a RenameError\");\n         expect.assert_debug_eq(&source_change)\n     }\n \n@@ -792,8 +808,8 @@ impl Foo {\n     }\n \n     #[test]\n-    fn test_rename_struct_field_for_shorthand() {\n-        mark::check!(test_rename_struct_field_for_shorthand);\n+    fn test_rename_field_in_field_shorthand() {\n+        mark::check!(test_rename_field_in_field_shorthand);\n         check(\n             \"j\",\n             r#\"\n@@ -818,8 +834,8 @@ impl Foo {\n     }\n \n     #[test]\n-    fn test_rename_local_for_field_shorthand() {\n-        mark::check!(test_rename_local_for_field_shorthand);\n+    fn test_rename_local_in_field_shorthand() {\n+        mark::check!(test_rename_local_in_field_shorthand);\n         check(\n             \"j\",\n             r#\"\n@@ -1417,8 +1433,8 @@ impl Foo {\n     }\n \n     #[test]\n-    fn test_initializer_use_field_init_shorthand() {\n-        mark::check!(test_rename_field_expr_pat);\n+    fn test_rename_field_put_init_shorthand() {\n+        mark::check!(test_rename_field_put_init_shorthand);\n         check(\n             \"bar\",\n             r#\"\n@@ -1438,8 +1454,31 @@ fn foo(bar: i32) -> Foo {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_local_put_init_shorthand() {\n+        mark::check!(test_rename_local_put_init_shorthand);\n+        check(\n+            \"i\",\n+            r#\"\n+struct Foo { i: i32 }\n+\n+fn foo(bar$0: i32) -> Foo {\n+    Foo { i: bar }\n+}\n+\"#,\n+            r#\"\n+struct Foo { i: i32 }\n+\n+fn foo(i: i32) -> Foo {\n+    Foo { i }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_struct_field_destructure_into_shorthand() {\n+        mark::check!(test_rename_field_put_init_shorthand_pat);\n         check(\n             \"baz\",\n             r#\""}, {"sha": "38b20f2dc543707d9e171015c524a144ce011295", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 38, "deletions": 81, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=88253907f4bc3beaa7b8f2e58cb652f653f92d56", "patch": "@@ -52,25 +52,37 @@ impl IntoIterator for UsageSearchResult {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub enum NameLike {\n+    NameRef(ast::NameRef),\n+    Name(ast::Name),\n+    Lifetime(ast::Lifetime),\n+}\n+\n+impl NameLike {\n+    pub fn as_name_ref(&self) -> Option<&ast::NameRef> {\n+        match self {\n+            NameLike::NameRef(name_ref) => Some(name_ref),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+mod __ {\n+    use super::{\n+        ast::{Lifetime, Name, NameRef},\n+        NameLike,\n+    };\n+    stdx::impl_from!(NameRef, Name, Lifetime for NameLike);\n+}\n+\n #[derive(Debug, Clone)]\n pub struct FileReference {\n     pub range: TextRange,\n-    pub kind: ReferenceKind,\n+    pub name: NameLike,\n     pub access: Option<ReferenceAccess>,\n }\n \n-#[derive(Debug, Clone, PartialEq)]\n-pub enum ReferenceKind {\n-    FieldShorthandForField,\n-    FieldShorthandForLocal,\n-    StructLiteral,\n-    RecordFieldExprOrPat,\n-    SelfParam,\n-    EnumLiteral,\n-    Lifetime,\n-    Other,\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq)]\n pub enum ReferenceAccess {\n     Read,\n@@ -369,8 +381,11 @@ impl<'a> FindUsages<'a> {\n         match NameRefClass::classify_lifetime(self.sema, lifetime) {\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n                 let FileRange { file_id, range } = self.sema.original_range(lifetime.syntax());\n-                let reference =\n-                    FileReference { range, kind: ReferenceKind::Lifetime, access: None };\n+                let reference = FileReference {\n+                    range,\n+                    name: NameLike::Lifetime(lifetime.clone()),\n+                    access: None,\n+                };\n                 sink(file_id, reference)\n             }\n             _ => false, // not a usage\n@@ -384,32 +399,25 @@ impl<'a> FindUsages<'a> {\n     ) -> bool {\n         match NameRefClass::classify(self.sema, &name_ref) {\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n-                let kind = if is_record_field_expr_or_pat(&name_ref) {\n-                    ReferenceKind::RecordFieldExprOrPat\n-                } else if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref) {\n-                    ReferenceKind::StructLiteral\n-                } else if is_enum_lit_name_ref(&name_ref) {\n-                    ReferenceKind::EnumLiteral\n-                } else {\n-                    ReferenceKind::Other\n-                };\n-\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n-                let reference =\n-                    FileReference { range, kind, access: reference_access(&def, &name_ref) };\n+                let reference = FileReference {\n+                    range,\n+                    name: NameLike::NameRef(name_ref.clone()),\n+                    access: reference_access(&def, &name_ref),\n+                };\n                 sink(file_id, reference)\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = match self.def {\n                     Definition::Field(_) if &field == self.def => FileReference {\n                         range,\n-                        kind: ReferenceKind::FieldShorthandForField,\n+                        name: NameLike::NameRef(name_ref.clone()),\n                         access: reference_access(&field, &name_ref),\n                     },\n                     Definition::Local(l) if &local == l => FileReference {\n                         range,\n-                        kind: ReferenceKind::FieldShorthandForLocal,\n+                        name: NameLike::NameRef(name_ref.clone()),\n                         access: reference_access(&Definition::Local(local), &name_ref),\n                     },\n                     _ => return false, // not a usage\n@@ -433,7 +441,7 @@ impl<'a> FindUsages<'a> {\n                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n                 let reference = FileReference {\n                     range,\n-                    kind: ReferenceKind::FieldShorthandForField,\n+                    name: NameLike::Name(name.clone()),\n                     // FIXME: mutable patterns should have `Write` access\n                     access: Some(ReferenceAccess::Read),\n                 };\n@@ -473,54 +481,3 @@ fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<Referen\n     // Default Locals and Fields to read\n     mode.or(Some(ReferenceAccess::Read))\n }\n-\n-fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::CallExpr::cast)\n-        .and_then(|c| match c.expr()? {\n-            ast::Expr::PathExpr(p) => {\n-                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n-            }\n-            _ => None,\n-        })\n-        .unwrap_or(false)\n-}\n-\n-fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::RecordExpr::cast)\n-        .and_then(|l| l.path())\n-        .and_then(|p| p.segment())\n-        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n-        .unwrap_or(false)\n-}\n-\n-fn is_record_field_expr_or_pat(name_ref: &ast::NameRef) -> bool {\n-    if let Some(parent) = name_ref.syntax().parent() {\n-        match_ast! {\n-            match parent {\n-                ast::RecordExprField(it) => true,\n-                ast::RecordPatField(_it) => true,\n-                _ => false,\n-            }\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_enum_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::PathExpr::cast)\n-        .and_then(|p| p.path())\n-        .and_then(|p| p.qualifier())\n-        .and_then(|p| p.segment())\n-        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n-        .unwrap_or(false)\n-}"}, {"sha": "8898c12e3cc1d93aecca33b883890dd21248160e", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=88253907f4bc3beaa7b8f2e58cb652f653f92d56", "patch": "@@ -827,18 +827,23 @@ pub(crate) fn handle_references(\n         Some(refs) => refs,\n     };\n \n-    let locations = if params.context.include_declaration {\n-        refs.references_with_declaration()\n-            .file_ranges()\n-            .filter_map(|frange| to_proto::location(&snap, frange).ok())\n-            .collect()\n+    let decl = if params.context.include_declaration {\n+        Some(FileRange {\n+            file_id: refs.declaration.nav.file_id,\n+            range: refs.declaration.nav.focus_or_full_range(),\n+        })\n     } else {\n-        // Only iterate over the references if include_declaration was false\n-        refs.references()\n-            .file_ranges()\n-            .filter_map(|frange| to_proto::location(&snap, frange).ok())\n-            .collect()\n+        None\n     };\n+    let locations = refs\n+        .references\n+        .into_iter()\n+        .flat_map(|(file_id, refs)| {\n+            refs.into_iter().map(move |(range, _)| FileRange { file_id, range })\n+        })\n+        .chain(decl)\n+        .filter_map(|frange| to_proto::location(&snap, frange).ok())\n+        .collect();\n \n     Ok(Some(locations))\n }\n@@ -1214,8 +1219,11 @@ pub(crate) fn handle_code_lens_resolve(\n                 .find_all_refs(position, None)\n                 .unwrap_or(None)\n                 .map(|r| {\n-                    r.references()\n-                        .file_ranges()\n+                    r.references\n+                        .into_iter()\n+                        .flat_map(|(file_id, ranges)| {\n+                            ranges.into_iter().map(move |(range, _)| FileRange { file_id, range })\n+                        })\n                         .filter_map(|frange| to_proto::location(&snap, frange).ok())\n                         .collect_vec()\n                 })\n@@ -1259,17 +1267,26 @@ pub(crate) fn handle_document_highlight(\n         Some(refs) => refs,\n     };\n \n+    let decl = if refs.declaration.nav.file_id == position.file_id {\n+        Some(DocumentHighlight {\n+            range: to_proto::range(&line_index, refs.declaration.nav.focus_or_full_range()),\n+            kind: refs.declaration.access.map(to_proto::document_highlight_kind),\n+        })\n+    } else {\n+        None\n+    };\n+\n     let res = refs\n-        .references_with_declaration()\n         .references\n         .get(&position.file_id)\n         .map(|file_refs| {\n             file_refs\n                 .into_iter()\n-                .map(|r| DocumentHighlight {\n-                    range: to_proto::range(&line_index, r.range),\n-                    kind: r.access.map(to_proto::document_highlight_kind),\n+                .map(|&(range, access)| DocumentHighlight {\n+                    range: to_proto::range(&line_index, range),\n+                    kind: access.map(to_proto::document_highlight_kind),\n                 })\n+                .chain(decl)\n                 .collect()\n         })\n         .unwrap_or_default();"}, {"sha": "b105cb0e0fa1b1e058452c33edbe05dc14b06375", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88253907f4bc3beaa7b8f2e58cb652f653f92d56/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=88253907f4bc3beaa7b8f2e58cb652f653f92d56", "patch": "@@ -274,17 +274,21 @@ impl ast::Struct {\n \n impl ast::RecordExprField {\n     pub fn for_field_name(field_name: &ast::NameRef) -> Option<ast::RecordExprField> {\n-        let candidate =\n-            field_name.syntax().parent().and_then(ast::RecordExprField::cast).or_else(|| {\n-                field_name.syntax().ancestors().nth(4).and_then(ast::RecordExprField::cast)\n-            })?;\n+        let candidate = Self::for_name_ref(field_name)?;\n         if candidate.field_name().as_ref() == Some(field_name) {\n             Some(candidate)\n         } else {\n             None\n         }\n     }\n \n+    pub fn for_name_ref(name_ref: &ast::NameRef) -> Option<ast::RecordExprField> {\n+        let syn = name_ref.syntax();\n+        syn.parent()\n+            .and_then(ast::RecordExprField::cast)\n+            .or_else(|| syn.ancestors().nth(4).and_then(ast::RecordExprField::cast))\n+    }\n+\n     /// Deals with field init shorthand\n     pub fn field_name(&self) -> Option<ast::NameRef> {\n         if let Some(name_ref) = self.name_ref() {\n@@ -294,6 +298,7 @@ impl ast::RecordExprField {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq)]\n pub enum NameOrNameRef {\n     Name(ast::Name),\n     NameRef(ast::NameRef),\n@@ -309,6 +314,23 @@ impl fmt::Display for NameOrNameRef {\n }\n \n impl ast::RecordPatField {\n+    pub fn for_field_name_ref(field_name: &ast::NameRef) -> Option<ast::RecordPatField> {\n+        let candidate = field_name.syntax().parent().and_then(ast::RecordPatField::cast)?;\n+        match candidate.field_name()? {\n+            NameOrNameRef::NameRef(name_ref) if name_ref == *field_name => Some(candidate),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn for_field_name(field_name: &ast::Name) -> Option<ast::RecordPatField> {\n+        let candidate =\n+            field_name.syntax().ancestors().nth(3).and_then(ast::RecordPatField::cast)?;\n+        match candidate.field_name()? {\n+            NameOrNameRef::Name(name) if name == *field_name => Some(candidate),\n+            _ => None,\n+        }\n+    }\n+\n     /// Deals with field init shorthand\n     pub fn field_name(&self) -> Option<NameOrNameRef> {\n         if let Some(name_ref) = self.name_ref() {"}]}