{"sha": "5ff9087e05e6661990856ab3bdbc197e50380db5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZjkwODdlMDVlNjY2MTk5MDg1NmFiM2JkYmMxOTdlNTAzODBkYjU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-11-18T13:22:59Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-11-20T12:10:03Z"}, "message": "Refactored new CodeExtent type for improved abstraction.\n\n(Previously, statically identifiable scopes/regions were solely\nidentified with NodeId's; this refactoring prepares for a future\nwhere that 1:1 correspondence does not hold.)", "tree": {"sha": "7a3ea57d7fb72fbd93ede26a31b6dc902c806513", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a3ea57d7fb72fbd93ede26a31b6dc902c806513"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ff9087e05e6661990856ab3bdbc197e50380db5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff9087e05e6661990856ab3bdbc197e50380db5", "html_url": "https://github.com/rust-lang/rust/commit/5ff9087e05e6661990856ab3bdbc197e50380db5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ff9087e05e6661990856ab3bdbc197e50380db5/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b825b3496aff1ed784f7a7ca935245208b95aabb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b825b3496aff1ed784f7a7ca935245208b95aabb", "html_url": "https://github.com/rust-lang/rust/commit/b825b3496aff1ed784f7a7ca935245208b95aabb"}], "stats": {"total": 689, "additions": 420, "deletions": 269}, "files": [{"sha": "00d12ad6a382db814994f847996be223336d20bc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -18,6 +18,7 @@\n \n pub use self::DefIdSource::*;\n \n+use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{mod, Ty};\n@@ -315,17 +316,17 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n       }\n       'f' => {\n         assert_eq!(next(st), '[');\n-        let id = parse_uint(st) as ast::NodeId;\n+        let scope = parse_scope(st);\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        ty::ReFree(ty::FreeRegion {scope_id: id,\n+        ty::ReFree(ty::FreeRegion { scope: scope,\n                                     bound_region: br})\n       }\n       's' => {\n-        let id = parse_uint(st) as ast::NodeId;\n+        let scope = parse_scope(st);\n         assert_eq!(next(st), '|');\n-        ty::ReScope(id)\n+        ty::ReScope(scope)\n       }\n       't' => {\n         ty::ReStatic\n@@ -337,6 +338,16 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     }\n }\n \n+fn parse_scope(st: &mut PState) -> region::CodeExtent {\n+    match next(st) {\n+        'M' => {\n+            let node_id = parse_uint(st) as ast::NodeId;\n+            region::CodeExtent::Misc(node_id)\n+        }\n+        _ => panic!(\"parse_scope: bad input\")\n+    }\n+}\n+\n fn parse_opt<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>, f: |&mut PState<'a, 'tcx>| -> T)\n                           -> Option<T> {\n     match next(st) {"}, {"sha": "bbb2faaae0691619eb283587f7771df97e735c42", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -15,6 +15,7 @@\n \n use std::cell::RefCell;\n \n+use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::ParamTy;\n@@ -143,12 +144,16 @@ pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n                      token::get_name(name));\n         }\n         ty::ReFree(ref fr) => {\n-            mywrite!(w, \"f[{}|\", fr.scope_id);\n+            mywrite!(w, \"f[\");\n+            enc_scope(w, cx, fr.scope);\n+            mywrite!(w, \"|\");\n             enc_bound_region(w, cx, fr.bound_region);\n             mywrite!(w, \"]\");\n         }\n-        ty::ReScope(nid) => {\n-            mywrite!(w, \"s{}|\", nid);\n+        ty::ReScope(scope) => {\n+            mywrite!(w, \"s\");\n+            enc_scope(w, cx, scope);\n+            mywrite!(w, \"|\");\n         }\n         ty::ReStatic => {\n             mywrite!(w, \"t\");\n@@ -163,6 +168,12 @@ pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n     }\n }\n \n+fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n+    match scope {\n+        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id)\n+    }\n+}\n+\n fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {"}, {"sha": "7986a526b23b16188b9af78a43ff8ddce5851a6b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -489,20 +489,32 @@ impl tr for ty::Region {\n             ty::ReEarlyBound(id, space, index, ident) => {\n                 ty::ReEarlyBound(dcx.tr_id(id), space, index, ident)\n             }\n-            ty::ReScope(id) => {\n-                ty::ReScope(dcx.tr_id(id))\n+            ty::ReScope(scope) => {\n+                ty::ReScope(scope.tr(dcx))\n             }\n             ty::ReEmpty | ty::ReStatic | ty::ReInfer(..) => {\n                 *self\n             }\n             ty::ReFree(ref fr) => {\n-                ty::ReFree(ty::FreeRegion {scope_id: dcx.tr_id(fr.scope_id),\n-                                            bound_region: fr.bound_region.tr(dcx)})\n+                ty::ReFree(fr.tr(dcx))\n             }\n         }\n     }\n }\n \n+impl tr for ty::FreeRegion {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::FreeRegion {\n+        ty::FreeRegion { scope: self.scope.tr(dcx),\n+                         bound_region: self.bound_region.tr(dcx) }\n+    }\n+}\n+\n+impl tr for region::CodeExtent {\n+    fn tr(&self, dcx: &DecodeContext) -> region::CodeExtent {\n+        self.map_id(|id| dcx.tr_id(id))\n+    }\n+}\n+\n impl tr for ty::BoundRegion {\n     fn tr(&self, dcx: &DecodeContext) -> ty::BoundRegion {\n         match *self {"}, {"sha": "238a4ca7bd69eb4798217ac2de5cc57eb7c6ccc0", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -21,6 +21,7 @@ use self::UseError::*;\n use middle::borrowck::*;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n+use middle::region;\n use middle::ty;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -134,7 +135,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n             None => { }\n         }\n \n-        self.check_for_conflicting_loans(borrow_id);\n+        self.check_for_conflicting_loans(region::CodeExtent::from_node_id(borrow_id));\n     }\n \n     fn mutate(&mut self,\n@@ -215,30 +216,30 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)\n+    pub fn each_issued_loan(&self, scope: region::CodeExtent, op: |&Loan| -> bool)\n                             -> bool {\n         //! Iterates over each loan that has been issued\n-        //! on entrance to `scope_id`, regardless of whether it is\n+        //! on entrance to `scope`, regardless of whether it is\n         //! actually *in scope* at that point.  Sometimes loans\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        self.dfcx_loans.each_bit_on_entry(scope_id, |loan_index| {\n+        self.dfcx_loans.each_bit_on_entry(scope.node_id(), |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             op(loan)\n         })\n     }\n \n     pub fn each_in_scope_loan(&self,\n-                              scope_id: ast::NodeId,\n+                              scope: region::CodeExtent,\n                               op: |&Loan| -> bool)\n                               -> bool {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n         let tcx = self.tcx();\n-        self.each_issued_loan(scope_id, |loan| {\n-            if tcx.region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n+        self.each_issued_loan(scope, |loan| {\n+            if tcx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n                 true\n@@ -247,7 +248,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn each_in_scope_loan_affecting_path(&self,\n-                                         scope_id: ast::NodeId,\n+                                         scope: region::CodeExtent,\n                                          loan_path: &LoanPath,\n                                          op: |&Loan| -> bool)\n                                          -> bool {\n@@ -262,7 +263,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //     let y = a;          // Conflicts with restriction\n \n         let loan_path = owned_ptr_base_path(loan_path);\n-        let cont = self.each_in_scope_loan(scope_id, |loan| {\n+        let cont = self.each_in_scope_loan(scope, |loan| {\n             let mut ret = true;\n             for restr_path in loan.restricted_paths.iter() {\n                 if **restr_path == *loan_path {\n@@ -302,7 +303,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            let cont = self.each_in_scope_loan(scope_id, |loan| {\n+            let cont = self.each_in_scope_loan(scope, |loan| {\n                 if *loan.loan_path == *loan_path {\n                     op(loan)\n                 } else {\n@@ -318,30 +319,33 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> Vec<uint> {\n+    pub fn loans_generated_by(&self, scope: region::CodeExtent) -> Vec<uint> {\n         //! Returns a vector of the loans that are generated as\n-        //! we encounter `scope_id`.\n+        //! we enter `scope`.\n \n         let mut result = Vec::new();\n-        self.dfcx_loans.each_gen_bit(scope_id, |loan_index| {\n+        self.dfcx_loans.each_gen_bit(scope.node_id(), |loan_index| {\n             result.push(loan_index);\n             true\n         });\n         return result;\n     }\n \n-    pub fn check_for_conflicting_loans(&self, scope_id: ast::NodeId) {\n+    pub fn check_for_conflicting_loans(&self, scope: region::CodeExtent) {\n         //! Checks to see whether any of the loans that are issued\n-        //! by `scope_id` conflict with loans that have already been\n-        //! issued when we enter `scope_id` (for example, we do not\n+        //! on entrance to `scope` conflict with loans that have already been\n+        //! issued when we enter `scope` (for example, we do not\n         //! permit two `&mut` borrows of the same variable).\n+        //!\n+        //! (Note that some loans can be *issued* without necessarily\n+        //! taking effect yet.)\n \n-        debug!(\"check_for_conflicting_loans(scope_id={})\", scope_id);\n+        debug!(\"check_for_conflicting_loans(scope={})\", scope);\n \n-        let new_loan_indices = self.loans_generated_by(scope_id);\n+        let new_loan_indices = self.loans_generated_by(scope);\n         debug!(\"new_loan_indices = {}\", new_loan_indices);\n \n-        self.each_issued_loan(scope_id, |issued_loan| {\n+        self.each_issued_loan(scope, |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n@@ -535,7 +539,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 old_loan.span,\n                 format!(\"{}; {}\", borrow_summary, rule_summary).as_slice());\n \n-            let old_loan_span = self.tcx().map.span(old_loan.kill_scope);\n+            let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n                                     \"previous borrow ends here\");\n \n@@ -657,7 +661,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         let mut ret = UseOk;\n \n-        self.each_in_scope_loan_affecting_path(expr_id, use_path, |loan| {\n+        self.each_in_scope_loan_affecting_path(\n+            region::CodeExtent::from_node_id(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -924,7 +929,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 None => { return; /* no loan path, can't be any loans */ }\n             };\n \n-            this.each_in_scope_loan_affecting_path(assignment_id, &*loan_path, |loan| {\n+            let scope = region::CodeExtent::from_node_id(assignment_id);\n+            this.each_in_scope_loan_affecting_path(scope, &*loan_path, |loan| {\n                 this.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                 false\n             });"}, {"sha": "5b8cb0608b39ce0487a65542b3934bc1a7beeecf", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -16,6 +16,7 @@\n use middle::borrowck::*;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n+use middle::region;\n use middle::ty;\n use util::ppaux::Repr;\n use syntax::ast;\n@@ -24,17 +25,20 @@ use syntax::codemap::Span;\n type R = Result<(),()>;\n \n pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    item_scope_id: ast::NodeId,\n+                                    item_scope: region::CodeExtent,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n                                     cmt: mc::cmt<'tcx>,\n                                     loan_region: ty::Region,\n                                     _: ty::BorrowKind)\n                                     -> Result<(),()> {\n+    //! Reports error if `loan_region` is larger than S\n+    //! where S is `item_scope` if `cmt` is an upvar,\n+    //! and is scope of `cmt` otherwise.\n     debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n-                                         item_scope_id: item_scope_id,\n+                                         item_scope: item_scope,\n                                          span: span,\n                                          cause: cause,\n                                          loan_region: loan_region,\n@@ -48,8 +52,8 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n-    // the node id of the function body for the enclosing item\n-    item_scope_id: ast::NodeId,\n+    // the scope of the function body for the enclosing item\n+    item_scope: region::CodeExtent,\n \n     span: Span,\n     cause: euv::LoanCause,\n@@ -60,7 +64,9 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n     fn check(&self, cmt: &mc::cmt<'tcx>, discr_scope: Option<ast::NodeId>) -> R {\n-        //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n+        //! Main routine. Walks down `cmt` until we find the\n+        //! \"guarantor\".  Reports an error if `self.loan_region` is\n+        //! larger than scope of `cmt`.\n         debug!(\"guarantee_lifetime.check(cmt={}, loan_region={})\",\n                cmt.repr(self.bccx.tcx),\n                self.loan_region.repr(self.bccx.tcx));\n@@ -88,7 +94,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n     }\n \n     fn check_scope(&self, max_scope: ty::Region) -> R {\n-        //! Reports an error if `loan_region` is larger than `valid_scope`\n+        //! Reports an error if `loan_region` is larger than `max_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n             Err(self.report_error(err_out_of_scope(max_scope, self.loan_region)))\n@@ -109,7 +115,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 temp_scope\n             }\n             mc::cat_upvar(..) => {\n-                ty::ReScope(self.item_scope_id)\n+                ty::ReScope(self.item_scope)\n             }\n             mc::cat_static_item => {\n                 ty::ReStatic"}, {"sha": "c36a466919b456dd516dc064c41885a9695e1e74", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -20,6 +20,7 @@ use middle::borrowck::*;\n use middle::borrowck::move_data::MoveData;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n+use middle::region;\n use middle::ty;\n use util::ppaux::{Repr};\n \n@@ -42,7 +43,7 @@ pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         all_loans: Vec::new(),\n-        item_ub: body.id,\n+        item_ub: region::CodeExtent::from_node_id(body.id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -62,7 +63,9 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     move_data: move_data::MoveData,\n     move_error_collector: move_error::MoveErrorCollector<'tcx>,\n     all_loans: Vec<Loan>,\n-    item_ub: ast::NodeId,\n+    /// `item_ub` is used as an upper-bound on the lifetime whenever we\n+    /// ask for the scope of an expression categorized as an upvar.\n+    item_ub: region::CodeExtent,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n@@ -266,8 +269,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n             restrictions::SafeIf(loan_path, restricted_paths) => {\n                 let loan_scope = match loan_region {\n-                    ty::ReScope(id) => id,\n-                    ty::ReFree(ref fr) => fr.scope_id,\n+                    ty::ReScope(scope) => scope,\n+\n+                    ty::ReFree(ref fr) => fr.scope,\n \n                     ty::ReStatic => {\n                         // If we get here, an error must have been\n@@ -293,7 +297,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {}\", loan_scope);\n \n-                let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n+                let borrow_scope = region::CodeExtent::from_node_id(borrow_id);\n+                let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {}\", gen_scope);\n \n                 let kill_scope = self.compute_kill_scope(loan_scope, &*loan_path);\n@@ -406,23 +411,23 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn compute_gen_scope(&self,\n-                             borrow_id: ast::NodeId,\n-                             loan_scope: ast::NodeId)\n-                             -> ast::NodeId {\n+                             borrow_scope: region::CodeExtent,\n+                             loan_scope: region::CodeExtent)\n+                             -> region::CodeExtent {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n         //! later, once it comes into scope.\n \n-        if self.bccx.tcx.region_maps.is_subscope_of(borrow_id, loan_scope) {\n-            borrow_id\n+        if self.bccx.tcx.region_maps.is_subscope_of(borrow_scope, loan_scope) {\n+            borrow_scope\n         } else {\n             loan_scope\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: ast::NodeId, lp: &LoanPath)\n-                              -> ast::NodeId {\n+    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath)\n+                              -> region::CodeExtent {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,"}, {"sha": "5271a6191418ac4139e86dcd4762c37617f91bd5", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -24,6 +24,7 @@ use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n+use middle::region;\n use middle::ty::{mod, Ty};\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n@@ -169,8 +170,8 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n-        loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n+        loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n+        loan_dfcx.add_kill(loan.kill_scope.node_id(), loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, body);\n@@ -258,8 +259,19 @@ pub struct Loan {\n     loan_path: Rc<LoanPath>,\n     kind: ty::BorrowKind,\n     restricted_paths: Vec<Rc<LoanPath>>,\n-    gen_scope: ast::NodeId,\n-    kill_scope: ast::NodeId,\n+\n+    /// gen_scope indicates where loan is introduced. Typically the\n+    /// loan is introduced at the point of the borrow, but in some\n+    /// cases, notably method arguments, the loan may be introduced\n+    /// only later, once it comes into scope.  See also\n+    /// `GatherLoanCtxt::compute_gen_scope`.\n+    gen_scope: region::CodeExtent,\n+\n+    /// kill_scope indicates when the loan goes out of scope.  This is\n+    /// either when the lifetime expires or when the local variable\n+    /// which roots the loan-path goes out of scope, whichever happens\n+    /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n+    kill_scope: region::CodeExtent,\n     span: Span,\n     cause: euv::LoanCause,\n }\n@@ -297,11 +309,13 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n }\n \n impl LoanPath {\n-    pub fn kill_scope(&self, tcx: &ty::ctxt) -> ast::NodeId {\n+    pub fn kill_scope(&self, tcx: &ty::ctxt) -> region::CodeExtent {\n         match *self {\n             LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n-            LpUpvar(upvar_id) =>\n-                closure_to_block(upvar_id.closure_expr_id, tcx),\n+            LpUpvar(upvar_id) => {\n+                let block_id = closure_to_block(upvar_id.closure_expr_id, tcx);\n+                region::CodeExtent::from_node_id(block_id)\n+            }\n             LpExtend(ref base, _, _) => base.kill_scope(tcx),\n         }\n     }\n@@ -901,8 +915,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {\n      match region {\n-         ty::ReScope(node_id) => {\n-             match tcx.map.find(node_id) {\n+         ty::ReScope(scope) => {\n+             match tcx.map.find(scope.node_id()) {\n                  Some(ast_map::NodeStmt(_)) => true,\n                  _ => false\n              }"}, {"sha": "ab4c7787fe8fbc9bf4d2d4185a72202123c05447", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -435,9 +435,9 @@ impl MoveData {\n         for path in self.paths.borrow().iter() {\n             match *path.loan_path {\n                 LpVar(id) => {\n-                    let kill_id = tcx.region_maps.var_scope(id);\n+                    let kill_scope = tcx.region_maps.var_scope(id);\n                     let path = (*self.path_map.borrow())[path.loan_path];\n-                    self.kill_moves(path, kill_id, dfcx_moves);\n+                    self.kill_moves(path, kill_scope.node_id(), dfcx_moves);\n                 }\n                 LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n                     let kill_id = closure_to_block(closure_expr_id, tcx);\n@@ -453,8 +453,8 @@ impl MoveData {\n                 self.var_assignments.borrow().iter().enumerate() {\n             match *self.path_loan_path(assignment.path) {\n                 LpVar(id) => {\n-                    let kill_id = tcx.region_maps.var_scope(id);\n-                    dfcx_assign.add_kill(kill_id, assignment_index);\n+                    let kill_scope = tcx.region_maps.var_scope(id);\n+                    dfcx_assign.add_kill(kill_scope.node_id(), assignment_index);\n                 }\n                 LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n                     let kill_id = closure_to_block(closure_expr_id, tcx);"}, {"sha": "b4557021b69fc57949b7f5817dbbbc1051652550", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -11,6 +11,7 @@\n use middle::cfg::*;\n use middle::def;\n use middle::graph;\n+use middle::region::CodeExtent;\n use middle::typeck;\n use middle::ty;\n use syntax::ast;\n@@ -580,11 +581,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData {exiting_scopes: vec!() };\n-        let mut scope_id = from_expr.id;\n-        while scope_id != to_loop.loop_id {\n+        let mut scope = CodeExtent::from_node_id(from_expr.id);\n+        let target_scope = CodeExtent::from_node_id(to_loop.loop_id);\n+        while scope != target_scope {\n \n-            data.exiting_scopes.push(scope_id);\n-            scope_id = self.tcx.region_maps.encl_scope(scope_id);\n+            data.exiting_scopes.push(scope.node_id());\n+            scope = self.tcx.region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);\n     }"}, {"sha": "3215b5e8fe9af1bdba1387c408dc82f1d1898262", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -23,6 +23,7 @@ use self::OverloadedCallType::*;\n use middle::mem_categorization as mc;\n use middle::def;\n use middle::mem_categorization::Typer;\n+use middle::region;\n use middle::pat_util;\n use middle::ty::{mod, Ty};\n use middle::typeck::{MethodCall, MethodObject, MethodTraitObject};\n@@ -245,10 +246,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         for arg in decl.inputs.iter() {\n             let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n \n+            let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n-                ty::ReScope(body.id), // Args live only as long as the fn body.\n+                ty::ReScope(fn_body_scope), // Args live only as long as the fn body.\n                 arg_ty);\n \n             self.walk_pat(arg_cmt, &*arg.pat);\n@@ -443,9 +445,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // Fetch the type of the value that the iteration yields to\n                 // produce the pattern's categorized mutable type.\n                 let pattern_type = return_if_err!(self.typer.node_ty(pat.id));\n+                let blk_scope = region::CodeExtent::from_node_id(blk.id);\n                 let pat_cmt = self.mc.cat_rvalue(pat.id,\n                                                  pat.span,\n-                                                 ty::ReScope(blk.id),\n+                                                 ty::ReScope(blk_scope),\n                                                  pattern_type);\n                 self.walk_pat(pat_cmt, &**pat);\n \n@@ -519,6 +522,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         let callee_ty = ty::expr_ty_adjusted(self.tcx(), callee);\n         debug!(\"walk_callee: callee={} callee_ty={}\",\n                callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n+        let call_scope = region::CodeExtent::from_node_id(call.id);\n         match callee_ty.sty {\n             ty::ty_bare_fn(..) => {\n                 self.consume_expr(callee);\n@@ -527,7 +531,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 match f.onceness {\n                     ast::Many => {\n                         self.borrow_expr(callee,\n-                                         ty::ReScope(call.id),\n+                                         ty::ReScope(call_scope),\n                                          ty::UniqueImmBorrow,\n                                          ClosureInvocation);\n                     }\n@@ -557,13 +561,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 match overloaded_call_type {\n                     FnMutOverloadedCall => {\n                         self.borrow_expr(callee,\n-                                         ty::ReScope(call.id),\n+                                         ty::ReScope(call_scope),\n                                          ty::MutBorrow,\n                                          ClosureInvocation);\n                     }\n                     FnOverloadedCall => {\n                         self.borrow_expr(callee,\n-                                         ty::ReScope(call.id),\n+                                         ty::ReScope(call_scope),\n                                          ty::ImmBorrow,\n                                          ClosureInvocation);\n                     }\n@@ -814,7 +818,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // methods are implicitly autoref'd which sadly does not use\n         // adjustments, so we must hardcode the borrow here.\n \n-        let r = ty::ReScope(expr.id);\n+        let r = ty::ReScope(region::CodeExtent::from_node_id(expr.id));\n         let bk = ty::ImmBorrow;\n \n         for &arg in rhs.iter() {"}, {"sha": "bb5af2f4297edc4eed5edb5dc82ec3bb252058ef", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -74,6 +74,7 @@ pub use self::deref_kind::*;\n pub use self::categorization::*;\n \n use middle::def;\n+use middle::region;\n use middle::ty::{mod, Ty};\n use middle::typeck;\n use util::nodemap::{DefIdMap, NodeMap};\n@@ -289,7 +290,7 @@ pub trait Typer<'tcx> {\n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty<'tcx>>;\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause;\n@@ -702,7 +703,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n             // Region of environment pointer\n             let env_region = ty::ReFree(ty::FreeRegion {\n-                scope_id: fn_body_id,\n+                scope: region::CodeExtent::from_node_id(fn_body_id),\n                 bound_region: ty::BrEnv\n             });\n "}, {"sha": "8a50cb4ed4e1b41601d2bf557fde1c689483771b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 151, "deletions": 97, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -24,17 +24,56 @@ Most of the documentation on regions can be found in\n use session::Session;\n use middle::ty::{FreeRegion};\n use middle::ty::{mod, Ty};\n-use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use util::common::can_reach;\n \n use std::cell::RefCell;\n+use std::hash::{Hash};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n use syntax::ptr::P;\n use syntax::visit::{Visitor, FnKind};\n \n+/// CodeExtent represents a statically-describable extent that can be\n+/// used to bound the lifetime/region for values.\n+///\n+/// FIXME (pnkfelix): This currently derives `PartialOrd` and `Ord` to\n+/// placate the same deriving in `ty::FreeRegion`, but we may want to\n+/// actually attach a more meaningful ordering to scopes than the one\n+/// generated via deriving here.\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n+pub enum CodeExtent {\n+    Misc(ast::NodeId)\n+}\n+\n+impl CodeExtent {\n+    /// Creates a scope that represents the dynamic extent associated\n+    /// with `node_id`.\n+    pub fn from_node_id(node_id: ast::NodeId) -> CodeExtent {\n+        CodeExtent::Misc(node_id)\n+    }\n+\n+    /// Returns a node id associated with this scope.\n+    ///\n+    /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n+    /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n+    pub fn node_id(&self) -> ast::NodeId {\n+        match *self {\n+            CodeExtent::Misc(node_id) => node_id,\n+        }\n+    }\n+\n+    /// Maps this scope to a potentially new one according to the\n+    /// NodeId transformer `f_id`.\n+    pub fn map_id(&self, f_id: |ast::NodeId| -> ast::NodeId) -> CodeExtent {\n+        match *self {\n+            CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n+        }\n+    }\n+}\n+\n /**\n The region maps encode information about region relationships.\n \n@@ -76,11 +115,11 @@ The region maps encode information about region relationships.\n   for dynamic checks and/or arbitrary amounts of stack space.\n */\n pub struct RegionMaps {\n-    scope_map: RefCell<NodeMap<ast::NodeId>>,\n-    var_map: RefCell<NodeMap<ast::NodeId>>,\n+    scope_map: RefCell<FnvHashMap<CodeExtent, CodeExtent>>,\n+    var_map: RefCell<NodeMap<CodeExtent>>,\n     free_region_map: RefCell<FnvHashMap<FreeRegion, Vec<FreeRegion>>>,\n-    rvalue_scopes: RefCell<NodeMap<ast::NodeId>>,\n-    terminating_scopes: RefCell<NodeSet>,\n+    rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n+    terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n }\n \n pub struct Context {\n@@ -116,25 +155,25 @@ impl RegionMaps {\n         self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n     }\n \n-    pub fn record_encl_scope(&self, sub: ast::NodeId, sup: ast::NodeId) {\n+    pub fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n         debug!(\"record_encl_scope(sub={}, sup={})\", sub, sup);\n         assert!(sub != sup);\n         self.scope_map.borrow_mut().insert(sub, sup);\n     }\n \n-    pub fn record_var_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {\n+    pub fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={}, sup={})\", var, lifetime);\n-        assert!(var != lifetime);\n+        assert!(var != lifetime.node_id());\n         self.var_map.borrow_mut().insert(var, lifetime);\n     }\n \n-    pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {\n+    pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={}, sup={})\", var, lifetime);\n-        assert!(var != lifetime);\n+        assert!(var != lifetime.node_id());\n         self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n     }\n \n-    pub fn mark_as_terminating_scope(&self, scope_id: ast::NodeId) {\n+    pub fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n         /*!\n          * Records that a scope is a TERMINATING SCOPE. Whenever we\n          * create automatic temporaries -- e.g. by an\n@@ -146,21 +185,21 @@ impl RegionMaps {\n         self.terminating_scopes.borrow_mut().insert(scope_id);\n     }\n \n-    pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n+    pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.scope_map.borrow().get(&id).map(|x| *x)\n     }\n \n     #[allow(dead_code)] // used in middle::cfg\n-    pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n+    pub fn encl_scope(&self, id: CodeExtent) -> CodeExtent {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         match self.scope_map.borrow().get(&id) {\n             Some(&r) => r,\n             None => { panic!(\"no enclosing scope for id {}\", id); }\n         }\n     }\n \n-    pub fn var_scope(&self, var_id: ast::NodeId) -> ast::NodeId {\n+    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n         /*!\n          * Returns the lifetime of the local variable `var_id`\n          */\n@@ -170,7 +209,7 @@ impl RegionMaps {\n         }\n     }\n \n-    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<ast::NodeId> {\n+    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n@@ -186,7 +225,7 @@ impl RegionMaps {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = match self.opt_encl_scope(expr_id) {\n+        let mut id = match self.opt_encl_scope(CodeExtent::from_node_id(expr_id)) {\n             Some(i) => i,\n             None => { return None; }\n         };\n@@ -214,15 +253,15 @@ impl RegionMaps {\n         scope\n     }\n \n-    pub fn scopes_intersect(&self, scope1: ast::NodeId, scope2: ast::NodeId)\n+    pub fn scopes_intersect(&self, scope1: CodeExtent, scope2: CodeExtent)\n                             -> bool {\n         self.is_subscope_of(scope1, scope2) ||\n         self.is_subscope_of(scope2, scope1)\n     }\n \n     pub fn is_subscope_of(&self,\n-                          subscope: ast::NodeId,\n-                          superscope: ast::NodeId)\n+                          subscope: CodeExtent,\n+                          superscope: CodeExtent)\n                           -> bool {\n         /*!\n          * Returns true if `subscope` is equal to or is lexically\n@@ -284,7 +323,7 @@ impl RegionMaps {\n                 }\n \n                 (ty::ReScope(sub_scope), ty::ReFree(ref fr)) => {\n-                    self.is_subscope_of(sub_scope, fr.scope_id)\n+                    self.is_subscope_of(sub_scope, fr.scope)\n                 }\n \n                 (ty::ReFree(sub_fr), ty::ReFree(super_fr)) => {\n@@ -309,9 +348,9 @@ impl RegionMaps {\n     }\n \n     pub fn nearest_common_ancestor(&self,\n-                                   scope_a: ast::NodeId,\n-                                   scope_b: ast::NodeId)\n-                                   -> Option<ast::NodeId> {\n+                                   scope_a: CodeExtent,\n+                                   scope_b: CodeExtent)\n+                                   -> Option<CodeExtent> {\n         /*!\n          * Finds the nearest common ancestor (if any) of two scopes.  That\n          * is, finds the smallest scope which is greater than or equal to\n@@ -349,8 +388,8 @@ impl RegionMaps {\n             }\n         }\n \n-        fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)\n-            -> Vec<ast::NodeId> {\n+        fn ancestors_of(this: &RegionMaps, scope: CodeExtent)\n+            -> Vec<CodeExtent> {\n             // debug!(\"ancestors_of(scope={})\", scope);\n             let mut result = vec!(scope);\n             let mut scope = scope;\n@@ -374,7 +413,9 @@ fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n                         _sp: Span) {\n     match visitor.cx.parent {\n         Some(parent_id) => {\n-            visitor.region_maps.record_encl_scope(child_id, parent_id);\n+            let child_scope = CodeExtent::from_node_id(child_id);\n+            let parent_scope = CodeExtent::from_node_id(parent_id);\n+            visitor.region_maps.record_encl_scope(child_scope, parent_scope);\n         }\n         None => {}\n     }\n@@ -386,7 +427,8 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n                        _sp: Span) {\n     match visitor.cx.var_parent {\n         Some(parent_id) => {\n-            visitor.region_maps.record_var_scope(var_id, parent_id);\n+            let parent_scope = CodeExtent::from_node_id(parent_id);\n+            visitor.region_maps.record_var_scope(var_id, parent_scope);\n         }\n         None => {\n             // this can happen in extern fn declarations like\n@@ -418,11 +460,13 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n }\n \n fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n-    visitor.region_maps.mark_as_terminating_scope(arm.body.id);\n+    let arm_body_scope = CodeExtent::from_node_id(arm.body.id);\n+    visitor.region_maps.mark_as_terminating_scope(arm_body_scope);\n \n     match arm.guard {\n         Some(ref expr) => {\n-            visitor.region_maps.mark_as_terminating_scope(expr.id);\n+            let guard_scope = CodeExtent::from_node_id(expr.id);\n+            visitor.region_maps.mark_as_terminating_scope(guard_scope);\n         }\n         None => { }\n     }\n@@ -449,7 +493,8 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     let stmt_id = stmt_id(stmt);\n     debug!(\"resolve_stmt(stmt.id={})\", stmt_id);\n \n-    visitor.region_maps.mark_as_terminating_scope(stmt_id);\n+    let stmt_scope = CodeExtent::from_node_id(stmt_id);\n+    visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n     record_superlifetime(visitor, stmt_id, stmt.span);\n \n     let prev_parent = visitor.cx.parent;\n@@ -465,73 +510,80 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n \n     let prev_cx = visitor.cx;\n     visitor.cx.parent = Some(expr.id);\n-    match expr.node {\n-        // Conditional or repeating scopes are always terminating\n-        // scopes, meaning that temporaries cannot outlive them.\n-        // This ensures fixed size stacks.\n-\n-        ast::ExprBinary(ast::BiAnd, _, ref r) |\n-        ast::ExprBinary(ast::BiOr, _, ref r) => {\n-            // For shortcircuiting operators, mark the RHS as a terminating\n-            // scope since it only executes conditionally.\n-            visitor.region_maps.mark_as_terminating_scope(r.id);\n-        }\n+    {\n+        let region_maps = &mut visitor.region_maps;\n+        let terminating = |id| {\n+            let scope = CodeExtent::from_node_id(id);\n+            region_maps.mark_as_terminating_scope(scope)\n+        };\n+        match expr.node {\n+            // Conditional or repeating scopes are always terminating\n+            // scopes, meaning that temporaries cannot outlive them.\n+            // This ensures fixed size stacks.\n+\n+            ast::ExprBinary(ast::BiAnd, _, ref r) |\n+            ast::ExprBinary(ast::BiOr, _, ref r) => {\n+                // For shortcircuiting operators, mark the RHS as a terminating\n+                // scope since it only executes conditionally.\n+                terminating(r.id);\n+            }\n \n-        ast::ExprIf(_, ref then, Some(ref otherwise)) => {\n-            visitor.region_maps.mark_as_terminating_scope(then.id);\n-            visitor.region_maps.mark_as_terminating_scope(otherwise.id);\n-        }\n+            ast::ExprIf(_, ref then, Some(ref otherwise)) => {\n+                terminating(then.id);\n+                terminating(otherwise.id);\n+            }\n \n-        ast::ExprIf(ref expr, ref then, None) => {\n-            visitor.region_maps.mark_as_terminating_scope(expr.id);\n-            visitor.region_maps.mark_as_terminating_scope(then.id);\n-        }\n+            ast::ExprIf(ref expr, ref then, None) => {\n+                terminating(expr.id);\n+                terminating(then.id);\n+            }\n \n-        ast::ExprLoop(ref body, _) => {\n-            visitor.region_maps.mark_as_terminating_scope(body.id);\n-        }\n+            ast::ExprLoop(ref body, _) => {\n+                terminating(body.id);\n+            }\n \n-        ast::ExprWhile(ref expr, ref body, _) => {\n-            visitor.region_maps.mark_as_terminating_scope(expr.id);\n-            visitor.region_maps.mark_as_terminating_scope(body.id);\n-        }\n+            ast::ExprWhile(ref expr, ref body, _) => {\n+                terminating(expr.id);\n+                terminating(body.id);\n+            }\n \n-        ast::ExprForLoop(ref _pat, ref _head, ref body, _) => {\n-            visitor.region_maps.mark_as_terminating_scope(body.id);\n+            ast::ExprForLoop(ref _pat, ref _head, ref body, _) => {\n+                terminating(body.id);\n \n-            // The variable parent of everything inside (most importantly, the\n-            // pattern) is the body.\n-            visitor.cx.var_parent = Some(body.id);\n-        }\n+                // The variable parent of everything inside (most importantly, the\n+                // pattern) is the body.\n+                visitor.cx.var_parent = Some(body.id);\n+            }\n \n-        ast::ExprMatch(..) => {\n-            visitor.cx.var_parent = Some(expr.id);\n-        }\n+            ast::ExprMatch(..) => {\n+                visitor.cx.var_parent = Some(expr.id);\n+            }\n \n-        ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n-        ast::ExprUnary(..) | ast::ExprCall(..) | ast::ExprMethodCall(..) => {\n-            // FIXME(#6268) Nested method calls\n-            //\n-            // The lifetimes for a call or method call look as follows:\n-            //\n-            // call.id\n-            // - arg0.id\n-            // - ...\n-            // - argN.id\n-            // - call.callee_id\n-            //\n-            // The idea is that call.callee_id represents *the time when\n-            // the invoked function is actually running* and call.id\n-            // represents *the time to prepare the arguments and make the\n-            // call*.  See the section \"Borrows in Calls\" borrowck/doc.rs\n-            // for an extended explanation of why this distinction is\n-            // important.\n-            //\n-            // record_superlifetime(new_cx, expr.callee_id);\n-        }\n+            ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n+            ast::ExprUnary(..) | ast::ExprCall(..) | ast::ExprMethodCall(..) => {\n+                // FIXME(#6268) Nested method calls\n+                //\n+                // The lifetimes for a call or method call look as follows:\n+                //\n+                // call.id\n+                // - arg0.id\n+                // - ...\n+                // - argN.id\n+                // - call.callee_id\n+                //\n+                // The idea is that call.callee_id represents *the time when\n+                // the invoked function is actually running* and call.id\n+                // represents *the time to prepare the arguments and make the\n+                // call*.  See the section \"Borrows in Calls\" borrowck/doc.rs\n+                // for an extended explanation of why this distinction is\n+                // important.\n+                //\n+                // record_superlifetime(new_cx, expr.callee_id);\n+            }\n \n-        _ => {}\n-    };\n+            _ => {}\n+        }\n+    }\n \n     visit::walk_expr(visitor, expr);\n     visitor.cx = prev_cx;\n@@ -553,7 +605,8 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     // For convenience in trans, associate with the local-id the var\n     // scope that will be used for any bindings declared in this\n     // pattern.\n-    visitor.region_maps.record_var_scope(local.id, blk_id);\n+    let blk_scope = CodeExtent::from_node_id(blk_id);\n+    visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n     // lifetimes, initializers in a let have a temporary lifetime\n@@ -618,10 +671,10 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n \n     match local.init {\n         Some(ref expr) => {\n-            record_rvalue_scope_if_borrow_expr(visitor, &**expr, blk_id);\n+            record_rvalue_scope_if_borrow_expr(visitor, &**expr, blk_scope);\n \n             if is_binding_pat(&*local.pat) || is_borrowed_ty(&*local.ty) {\n-                record_rvalue_scope(visitor, &**expr, blk_id);\n+                record_rvalue_scope(visitor, &**expr, blk_scope);\n             }\n         }\n \n@@ -682,7 +735,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n \n     fn record_rvalue_scope_if_borrow_expr(visitor: &mut RegionResolutionVisitor,\n                                           expr: &ast::Expr,\n-                                          blk_id: ast::NodeId) {\n+                                          blk_id: CodeExtent) {\n         /*!\n          * If `expr` matches the `E&` grammar, then records an extended\n          * rvalue scope as appropriate:\n@@ -738,7 +791,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n \n     fn record_rvalue_scope<'a>(visitor: &mut RegionResolutionVisitor,\n                                expr: &'a ast::Expr,\n-                               blk_id: ast::NodeId) {\n+                               blk_scope: CodeExtent) {\n         /*!\n          * Applied to an expression `expr` if `expr` -- or something\n          * owned or partially owned by `expr` -- is going to be\n@@ -766,7 +819,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n             // because in trans if we must compile e.g. `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n-            visitor.region_maps.record_rvalue_scope(expr.id, blk_id);\n+            visitor.region_maps.record_rvalue_scope(expr.id, blk_scope);\n \n             match expr.node {\n                 ast::ExprAddrOf(_, ref subexpr) |\n@@ -809,7 +862,8 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n            body.id,\n            visitor.cx.parent);\n \n-    visitor.region_maps.mark_as_terminating_scope(body.id);\n+    let body_scope = CodeExtent::from_node_id(body.id);\n+    visitor.region_maps.mark_as_terminating_scope(body_scope);\n \n     let outer_cx = visitor.cx;\n \n@@ -873,11 +927,11 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n \n pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n-        scope_map: RefCell::new(NodeMap::new()),\n+        scope_map: RefCell::new(FnvHashMap::new()),\n         var_map: RefCell::new(NodeMap::new()),\n         free_region_map: RefCell::new(FnvHashMap::new()),\n         rvalue_scopes: RefCell::new(NodeMap::new()),\n-        terminating_scopes: RefCell::new(NodeSet::new()),\n+        terminating_scopes: RefCell::new(FnvHashSet::new()),\n     };\n     {\n         let mut visitor = RegionResolutionVisitor {"}, {"sha": "fae64ff924274c41ead2ebec5de88ab53b8bf9e1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -22,6 +22,7 @@ use self::ScopeChain::*;\n \n use session::Session;\n use middle::def;\n+use middle::region;\n use middle::resolve::DefMap;\n use middle::subst;\n use middle::ty;\n@@ -43,7 +44,7 @@ pub enum DefRegion {\n                         /* lifetime decl */ ast::NodeId),\n     DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n-    DefFreeRegion(/* block scope */ ast::NodeId,\n+    DefFreeRegion(/* block scope */ region::CodeExtent,\n                   /* lifetime decl */ ast::NodeId),\n }\n \n@@ -67,7 +68,7 @@ enum ScopeChain<'a> {\n     LateScope(&'a Vec<ast::LifetimeDef>, Scope<'a>),\n     /// lifetimes introduced by items within a code block are scoped\n     /// to that block.\n-    BlockScope(ast::NodeId, Scope<'a>),\n+    BlockScope(region::CodeExtent, Scope<'a>),\n     RootScope\n }\n \n@@ -195,7 +196,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {\n-        self.with(BlockScope(b.id, self.scope), |this| visit::walk_block(this, b));\n+        self.with(BlockScope(region::CodeExtent::from_node_id(b.id), self.scope),\n+                  |this| visit::walk_block(this, b));\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n@@ -307,8 +309,8 @@ impl<'a> LifetimeContext<'a> {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n-                BlockScope(id, s) => {\n-                    return self.resolve_free_lifetime_ref(id, lifetime_ref, s);\n+                BlockScope(blk_scope, s) => {\n+                    return self.resolve_free_lifetime_ref(blk_scope, lifetime_ref, s);\n                 }\n \n                 RootScope => {\n@@ -350,19 +352,19 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn resolve_free_lifetime_ref(&mut self,\n-                                 scope_id: ast::NodeId,\n+                                 scope_data: region::CodeExtent,\n                                  lifetime_ref: &ast::Lifetime,\n                                  scope: Scope) {\n         // Walk up the scope chain, tracking the outermost free scope,\n         // until we encounter a scope that contains the named lifetime\n         // or we run out of scopes.\n-        let mut scope_id = scope_id;\n+        let mut scope_data = scope_data;\n         let mut scope = scope;\n         let mut search_result = None;\n         loop {\n             match *scope {\n-                BlockScope(id, s) => {\n-                    scope_id = id;\n+                BlockScope(blk_scope_data, s) => {\n+                    scope_data = blk_scope_data;\n                     scope = s;\n                 }\n \n@@ -383,7 +385,7 @@ impl<'a> LifetimeContext<'a> {\n \n         match search_result {\n             Some((_depth, decl_id)) => {\n-                let def = DefFreeRegion(scope_id, decl_id);\n+                let def = DefFreeRegion(scope_data, decl_id);\n                 self.insert_lifetime(lifetime_ref, def);\n             }\n "}, {"sha": "11badf7d1900e4027876ea77f0c7d640d844be82", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -46,6 +46,7 @@ use middle::dependency_format;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n use middle::mem_categorization as mc;\n+use middle::region;\n use middle::resolve;\n use middle::resolve_lifetime;\n use middle::stability;\n@@ -837,7 +838,7 @@ pub enum Region {\n     ReFree(FreeRegion),\n \n     /// A concrete region naming some expression within the current function.\n-    ReScope(NodeId),\n+    ReScope(region::CodeExtent),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n@@ -987,8 +988,10 @@ impl Region {\n }\n \n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n+/// A \"free\" region `fr` can be interpreted as \"some region\n+/// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n-    pub scope_id: NodeId,\n+    pub scope: region::CodeExtent,\n     pub bound_region: BoundRegion\n }\n \n@@ -3564,7 +3567,7 @@ pub fn ty_region(tcx: &ctxt,\n pub fn free_region_from_def(free_id: ast::NodeId, def: &RegionParameterDef)\n     -> ty::Region\n {\n-    ty::ReFree(ty::FreeRegion { scope_id: free_id,\n+    ty::ReFree(ty::FreeRegion { scope: region::CodeExtent::from_node_id(free_id),\n                                 bound_region: ty::BrNamed(def.def_id,\n                                                           def.name) })\n }\n@@ -5629,12 +5632,14 @@ pub fn construct_parameter_environment<'tcx>(\n         regions: subst::NonerasedRegions(regions)\n     };\n \n+    let free_id_scope = region::CodeExtent::from_node_id(free_id);\n+\n     //\n     // Compute the bounds on Self and the type parameters.\n     //\n \n     let bounds = generics.to_bounds(tcx, &free_substs);\n-    let bounds = liberate_late_bound_regions(tcx, free_id, &bind(bounds)).value;\n+    let bounds = liberate_late_bound_regions(tcx, free_id_scope, &bind(bounds)).value;\n     let obligations = traits::obligations_for_generics(tcx,\n                                                        traits::ObligationCause::misc(span),\n                                                        &bounds,\n@@ -5662,7 +5667,7 @@ pub fn construct_parameter_environment<'tcx>(\n     return ty::ParameterEnvironment {\n         free_substs: free_substs,\n         bounds: bounds.types,\n-        implicit_region_bound: ty::ReScope(free_id),\n+        implicit_region_bound: ty::ReScope(free_id_scope),\n         caller_obligations: obligations,\n         selection_cache: traits::SelectionCache::new(),\n     };\n@@ -5781,7 +5786,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n         self.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n     }\n \n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId> {\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n         self.region_maps.temporary_scope(rvalue_id)\n     }\n \n@@ -5906,7 +5911,7 @@ impl<'tcx> AutoDerefRef<'tcx> {\n \n pub fn liberate_late_bound_regions<'tcx, HR>(\n     tcx: &ty::ctxt<'tcx>,\n-    scope_id: ast::NodeId,\n+    scope: region::CodeExtent,\n     value: &HR)\n     -> HR\n     where HR : HigherRankedFoldable<'tcx>\n@@ -5918,7 +5923,7 @@ pub fn liberate_late_bound_regions<'tcx, HR>(\n \n     replace_late_bound_regions(\n         tcx, value,\n-        |br, _| ty::ReFree(ty::FreeRegion{scope_id: scope_id, bound_region: br})).0\n+        |br, _| ty::ReFree(ty::FreeRegion{scope: scope, bound_region: br})).0\n }\n \n pub fn erase_late_bound_regions<'tcx, HR>("}, {"sha": "9190c8bf115b7e73234adea5af60ca8afd5fdf9d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -113,9 +113,9 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n             ty::ReEarlyBound(id, space, index, lifetime.name)\n         }\n \n-        Some(&rl::DefFreeRegion(scope_id, id)) => {\n+        Some(&rl::DefFreeRegion(scope, id)) => {\n             ty::ReFree(ty::FreeRegion {\n-                    scope_id: scope_id,\n+                    scope: scope,\n                     bound_region: ty::BrNamed(ast_util::local_def(id),\n                                               lifetime.name)\n                 })"}, {"sha": "b7e33f60147b6b1d3db662190eac995b64e7e86e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -90,6 +90,7 @@ use middle::mem_categorization::McResult;\n use middle::mem_categorization;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n+use middle::region::CodeExtent;\n use middle::subst;\n use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits;\n@@ -308,7 +309,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n         self.inh.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n     }\n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId> {\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n         self.tcx().temporary_scope(rvalue_id)\n     }\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n@@ -529,7 +530,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n     // First, we have to replace any bound regions in the fn type with free ones.\n     // The free region references will be bound the node_id of the body block.\n-    let fn_sig = liberate_late_bound_regions(tcx, body.id, fn_sig);\n+    let fn_sig = liberate_late_bound_regions(tcx, CodeExtent::from_node_id(body.id), fn_sig);\n \n     let arg_tys = fn_sig.inputs.as_slice();\n     let ret_ty = fn_sig.output;\n@@ -742,7 +743,8 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"fty (raw): {}\", fty.repr(ccx.tcx));\n \n     let body_id = method.pe_body().id;\n-    let fty = liberate_late_bound_regions(ccx.tcx, body_id, &ty::bind(fty)).value;\n+    let fty = liberate_late_bound_regions(\n+        ccx.tcx, CodeExtent::from_node_id(body_id), &ty::bind(fty)).value;\n     debug!(\"fty (liberated): {}\", fty.repr(ccx.tcx));\n \n     check_bare_fn(ccx,\n@@ -937,6 +939,8 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method(impl_trait_ref={})\",\n            impl_trait_ref.repr(tcx));\n \n+    let impl_m_body_scope = CodeExtent::from_node_id(impl_m_body_id);\n+\n     // The impl's trait ref may bind late-bound regions from the impl.\n     // Liberate them and assign them the scope of the method body.\n     //\n@@ -954,7 +958,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     //     Foo<&'A T>\n     //\n     // where `'A` is the `ReFree` version of `'a`.\n-    let impl_trait_ref = liberate_late_bound_regions(tcx, impl_m_body_id, impl_trait_ref);\n+    let impl_trait_ref = liberate_late_bound_regions(tcx, impl_m_body_scope, impl_trait_ref);\n \n     debug!(\"impl_trait_ref (liberated) = {}\",\n            impl_trait_ref.repr(tcx));\n@@ -1097,7 +1101,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if !check_region_bounds_on_impl_method(tcx,\n                                            impl_m_span,\n                                            impl_m,\n-                                           impl_m_body_id,\n+                                           impl_m_body_scope,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n                                            &trait_to_skol_substs,\n@@ -1139,7 +1143,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .map(|impl_param_def|\n              liberate_late_bound_regions(\n                  tcx,\n-                 impl_m_body_id,\n+                 impl_m_body_scope,\n                  &ty::bind(ty::bind(impl_param_def.bounds.clone()))).value.value);\n     for (i, (trait_param_bounds, impl_param_bounds)) in\n         trait_bounds.zip(impl_bounds).enumerate()\n@@ -1205,7 +1209,8 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // that we must liberate the late-bound regions from the impl.\n     let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n-    let impl_fty = liberate_late_bound_regions(tcx, impl_m_body_id, &ty::bind(impl_fty)).value;\n+    let impl_fty = liberate_late_bound_regions(\n+        tcx, impl_m_body_scope, &ty::bind(impl_fty)).value;\n     let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n@@ -1240,7 +1245,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                 span: Span,\n                                                 impl_m: &ty::Method<'tcx>,\n-                                                impl_m_body_id: ast::NodeId,\n+                                                impl_m_body_scope: CodeExtent,\n                                                 trait_generics: &ty::Generics<'tcx>,\n                                                 impl_generics: &ty::Generics<'tcx>,\n                                                 trait_to_skol_substs: &Substs<'tcx>,\n@@ -1331,9 +1336,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             // impl, and the method.\n             let impl_bounds =\n                 ty::liberate_late_bound_regions(\n-                    tcx,\n-                    impl_m_body_id,\n-                    &ty::bind(ty::bind(impl_bounds))).value.value;\n+                    tcx, impl_m_body_scope, &ty::bind(ty::bind(impl_bounds))).value.value;\n \n             debug!(\"check_region_bounds_on_impl_method: \\\n                    trait_param={} \\\n@@ -1881,7 +1884,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut bounds_checker = wf::BoundsChecker::new(self,\n                                                         ast_t.span,\n-                                                        self.body_id,\n+                                                        CodeExtent::from_node_id(self.body_id),\n                                                         None);\n         bounds_checker.check_ty(t);\n \n@@ -2055,7 +2058,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                            expr: &ast::Expr)\n     {\n         for &ty in substs.types.iter() {\n-            let default_bound = ty::ReScope(expr.id);\n+            let default_bound = ty::ReScope(CodeExtent::from_node_id(expr.id));\n             let origin = infer::RelateDefaultParamBound(expr.span, ty);\n             self.register_region_obligation(origin, ty, default_bound);\n         }"}, {"sha": "d59088454229864d69a9c1f9848832555cc08cb7", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -120,6 +120,7 @@ and report an error, and it just seems like more mess in the end.)\n \n use middle::def;\n use middle::mem_categorization as mc;\n+use middle::region::CodeExtent;\n use middle::traits;\n use middle::ty::{ReScope};\n use middle::ty::{mod, Ty};\n@@ -253,7 +254,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n             if body_id == ast::DUMMY_NODE_ID {\n                 tcx.region_maps.var_region(node_id)\n             } else {\n-                ReScope(body_id)\n+                ReScope(CodeExtent::from_node_id(body_id))\n             }\n         }\n         _ => {\n@@ -408,7 +409,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         for &ty in fn_sig_tys.iter() {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n-            let body_scope = ty::ReScope(body_id);\n+            let body_scope = CodeExtent::from_node_id(body_id);\n+            let body_scope = ty::ReScope(body_scope);\n             let constraints =\n                 regionmanip::region_wf_constraints(\n                     tcx,\n@@ -474,7 +476,7 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n         self.fcx.inh.method_map.borrow().contains_key(&MethodCall::expr(id))\n     }\n \n-    fn temporary_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n+    fn temporary_scope(&self, id: ast::NodeId) -> Option<CodeExtent> {\n         self.tcx().region_maps.temporary_scope(id)\n     }\n \n@@ -587,7 +589,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     let expr_ty = rcx.resolve_node_type(expr.id);\n \n     type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-                      expr_ty, ty::ReScope(expr.id));\n+                      expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n \n     let method_call = MethodCall::expr(expr.id);\n     let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n@@ -608,7 +610,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     // FIXME(#6268) remove to support nested method calls\n                     type_of_node_must_outlive(\n                         rcx, infer::AutoBorrow(expr.span),\n-                        expr.id, ty::ReScope(expr.id));\n+                        expr.id, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n                 }\n             }\n             /*\n@@ -695,8 +697,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             };\n             match base_ty.sty {\n                 ty::ty_rptr(r_ptr, _) => {\n-                    mk_subregion_due_to_dereference(rcx, expr.span,\n-                                                    ty::ReScope(expr.id), r_ptr);\n+                    mk_subregion_due_to_dereference(\n+                        rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), r_ptr);\n                 }\n                 _ => {}\n             }\n@@ -732,7 +734,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n             type_must_outlive(rcx, infer::AddrOf(expr.span),\n-                              ty0, ty::ReScope(expr.id));\n+                              ty0, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n             visit::walk_expr(rcx, expr);\n         }\n \n@@ -772,7 +774,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 let pat_ty = rcx.resolve_node_type(pat.id);\n                 let pat_cmt = mc.cat_rvalue(pat.id,\n                                             pat.span,\n-                                            ty::ReScope(body.id),\n+                                            ty::ReScope(CodeExtent::from_node_id(body.id)),\n                                             pat_ty);\n                 link_pattern(rcx, mc, pat_cmt, &**pat);\n             }\n@@ -781,7 +783,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             type_of_node_must_outlive(rcx,\n                                       infer::AddrOf(expr.span),\n                                       head.id,\n-                                      ty::ReScope(expr.id));\n+                                      ty::ReScope(CodeExtent::from_node_id(expr.id)));\n \n             let repeating_scope = rcx.set_repeating_scope(body.id);\n             rcx.visit_block(&**body);\n@@ -866,7 +868,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                     // outlive the appropriate temporary scope.\n                     let s = rcx.repeating_scope;\n                     rcx.fcx.mk_subr(infer::InfStackClosure(expr.span),\n-                                    bounds.region_bound, ty::ReScope(s));\n+                                    bounds.region_bound, ty::ReScope(CodeExtent::from_node_id(s)));\n                 }\n             });\n         }\n@@ -1089,7 +1091,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                     callee_id: ast::NodeId,\n                     call_expr: &ast::Expr,\n                     callee_expr: &ast::Expr) {\n-    let call_region = ty::ReScope(call_expr.id);\n+    let call_region = ty::ReScope(CodeExtent::from_node_id(call_expr.id));\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n     match callee_ty.sty {\n@@ -1147,7 +1149,7 @@ fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n     // call occurs.\n     //\n     // FIXME(#6268) to support nested method calls, should be callee_id\n-    let callee_scope = call_expr.id;\n+    let callee_scope = CodeExtent::from_node_id(call_expr.id);\n     let callee_region = ty::ReScope(callee_scope);\n \n     debug!(\"callee_region={}\", callee_region.repr(tcx));\n@@ -1191,7 +1193,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n      * this is a region pointer being dereferenced, the lifetime of\n      * the pointer includes the deref expr.\n      */\n-    let r_deref_expr = ty::ReScope(deref_expr.id);\n+    let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n     for i in range(0u, derefs) {\n         debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={}/{}\",\n                rcx.fcx.infcx().ty_to_string(derefd_ty),\n@@ -1271,7 +1273,7 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n            rcx.fcx.infcx().ty_to_string(indexed_ty));\n \n-    let r_index_expr = ty::ReScope(index_expr.id);\n+    let r_index_expr = ty::ReScope(CodeExtent::from_node_id(index_expr.id));\n     match indexed_ty.sty {\n         ty::ty_rptr(r_ptr, mt) => match mt.ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => {\n@@ -1425,7 +1427,7 @@ fn link_autoref(rcx: &Rcx,\n \n fn link_by_ref(rcx: &Rcx,\n                expr: &ast::Expr,\n-               callee_scope: ast::NodeId) {\n+               callee_scope: CodeExtent) {\n     /*!\n      * Computes the guarantor for cases where the `expr` is\n      * being passed by implicit reference and must outlive"}, {"sha": "d9c6c3cb6262ad7105a38071e2466821faf70437", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::region;\n use middle::subst;\n use middle::subst::{Subst};\n use middle::traits;\n@@ -118,8 +119,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         self.with_fcx(item, |this, fcx| {\n             let variants = lookup_fields(fcx);\n-            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n-                                                        item.id, Some(&mut this.cache));\n+            let mut bounds_checker = BoundsChecker::new(fcx,\n+                                                        item.span,\n+                                                        region::CodeExtent::from_node_id(item.id),\n+                                                        Some(&mut this.cache));\n             for variant in variants.iter() {\n                 for field in variant.fields.iter() {\n                     // Regions are checked below.\n@@ -154,8 +157,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                        item: &ast::Item)\n     {\n         self.with_fcx(item, |this, fcx| {\n-            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n-                                                        item.id, Some(&mut this.cache));\n+            let mut bounds_checker = BoundsChecker::new(fcx,\n+                                                        item.span,\n+                                                        region::CodeExtent::from_node_id(item.id),\n+                                                        Some(&mut this.cache));\n             let polytype = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n             let item_ty = polytype.ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n             bounds_checker.check_traits_in_ty(item_ty);\n@@ -166,16 +171,21 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                   item: &ast::Item)\n     {\n         self.with_fcx(item, |this, fcx| {\n-            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n-                                                        item.id, Some(&mut this.cache));\n+            let item_scope = region::CodeExtent::from_node_id(item.id);\n+\n+            let mut bounds_checker = BoundsChecker::new(fcx,\n+                                                        item.span,\n+                                                        item_scope,\n+                                                        Some(&mut this.cache));\n \n             // Find the impl self type as seen from the \"inside\" --\n             // that is, with all type parameters converted from bound\n             // to free, and any late-bound regions on the impl\n             // liberated.\n             let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n             let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n-            let self_ty = liberate_late_bound_regions(fcx.tcx(), item.id, &ty::bind(self_ty)).value;\n+            let self_ty = liberate_late_bound_regions(\n+                fcx.tcx(), item_scope, &ty::bind(self_ty)).value;\n \n             bounds_checker.check_traits_in_ty(self_ty);\n \n@@ -186,7 +196,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 Some(t) => { t }\n             };\n             let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n-            let trait_ref = liberate_late_bound_regions(fcx.tcx(), item.id, &trait_ref);\n+            let trait_ref = liberate_late_bound_regions(fcx.tcx(), item_scope, &trait_ref);\n \n             // There are special rules that apply to drop.\n             if\n@@ -257,18 +267,18 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n pub struct BoundsChecker<'cx,'tcx:'cx> {\n     fcx: &'cx FnCtxt<'cx,'tcx>,\n     span: Span,\n-    scope_id: ast::NodeId,\n+    scope: region::CodeExtent,\n     binding_count: uint,\n     cache: Option<&'cx mut HashSet<Ty<'tcx>>>,\n }\n \n impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     pub fn new(fcx: &'cx FnCtxt<'cx,'tcx>,\n                span: Span,\n-               scope_id: ast::NodeId,\n+               scope: region::CodeExtent,\n                cache: Option<&'cx mut HashSet<Ty<'tcx>>>)\n                -> BoundsChecker<'cx,'tcx> {\n-        BoundsChecker { fcx: fcx, span: span, scope_id: scope_id,\n+        BoundsChecker { fcx: fcx, span: span, scope: scope,\n                         cache: cache, binding_count: 0 }\n     }\n \n@@ -383,7 +393,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n             ty::ty_closure(box ty::ClosureTy{sig: ref fn_sig, ..}) => {\n                 self.binding_count += 1;\n \n-                let fn_sig = liberate_late_bound_regions(self.fcx.tcx(), self.scope_id, fn_sig);\n+                let fn_sig = liberate_late_bound_regions(self.fcx.tcx(), self.scope, fn_sig);\n \n                 debug!(\"late-bound regions replaced: {}\",\n                        fn_sig.repr(self.tcx()));"}, {"sha": "13a0bf0bdcb522000a9a737cdb52a37446cc4826", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -35,6 +35,7 @@ use self::CreateTypeParametersForAssociatedTypesFlag::*;\n use metadata::csearch;\n use middle::def;\n use middle::lang_items::SizedTraitLangItem;\n+use middle::region;\n use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n@@ -2161,29 +2162,25 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                 _ => typ,\n             };\n \n+            let body_scope = region::CodeExtent::from_node_id(body_id);\n+\n             // \"Required type\" comes from the trait definition. It may\n             // contain late-bound regions from the method, but not the\n             // trait (since traits only have early-bound region\n             // parameters).\n             assert!(!ty::type_escapes_depth(required_type, 1));\n             let required_type_free =\n                 ty::liberate_late_bound_regions(\n-                    crate_context.tcx,\n-                    body_id,\n-                    &ty::bind(required_type)).value;\n+                    crate_context.tcx, body_scope, &ty::bind(required_type)).value;\n \n             // The \"base type\" comes from the impl. It may have late-bound\n             // regions from the impl or the method.\n             let base_type_free = // liberate impl regions:\n                 ty::liberate_late_bound_regions(\n-                    crate_context.tcx,\n-                    body_id,\n-                    &ty::bind(ty::bind(base_type))).value.value;\n+                    crate_context.tcx, body_scope, &ty::bind(ty::bind(base_type))).value.value;\n             let base_type_free = // liberate method regions:\n                 ty::liberate_late_bound_regions(\n-                    crate_context.tcx,\n-                    body_id,\n-                    &ty::bind(base_type_free)).value;\n+                    crate_context.tcx, body_scope, &ty::bind(base_type_free)).value;\n \n             debug!(\"required_type={} required_type_free={} \\\n                     base_type={} base_type_free={}\","}, {"sha": "bc36a2bd801b46765e0db98fb094163f421f845d", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -301,11 +301,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             debug!(\"free_regions_from_same_fn(sub={}, sup={})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n-                    if fr1.scope_id != fr2.scope_id {\n+                    if fr1.scope != fr2.scope {\n                         return None\n                     }\n-                    assert!(fr1.scope_id == fr2.scope_id);\n-                    (fr1.scope_id, fr1, fr2)\n+                    assert!(fr1.scope == fr2.scope);\n+                    (fr1.scope.node_id(), fr1, fr2)\n                 },\n                 _ => return None\n             };"}, {"sha": "6a447d467cfcec46b903fdd58ac7c5dce30e1853", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -18,6 +18,7 @@ pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n use self::Classification::*;\n \n+use middle::region;\n use middle::ty;\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n@@ -747,11 +748,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n-            match self.tcx.region_maps.nearest_common_ancestor(fr.scope_id, s_id) {\n+            match self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id) {\n               // if the free region's scope `fr.scope_id` is bigger than\n               // the scope region `s_id`, then the LUB is the free\n               // region itself:\n-              Some(r_id) if r_id == fr.scope_id => f,\n+              Some(r_id) if r_id == fr.scope => f,\n \n               // otherwise, we don't know what the free region is,\n               // so we must conservatively say the LUB is static:\n@@ -856,8 +857,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 // than the scope `s_id`, then we can say that the GLB\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n-                match self.tcx.region_maps.nearest_common_ancestor(fr.scope_id, s_id) {\n-                    Some(r_id) if r_id == fr.scope_id => Ok(s),\n+                match self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id) {\n+                    Some(r_id) if r_id == fr.scope => Ok(s),\n                     _ => Err(ty::terr_regions_no_overlap(b, a))\n                 }\n             }\n@@ -909,16 +910,16 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 Ok(ty::ReFree(*b))\n             } else {\n                 this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n-                                      a.scope_id, b.scope_id)\n+                                      a.scope, b.scope)\n             }\n         }\n     }\n \n     fn intersect_scopes(&self,\n                         region_a: ty::Region,\n                         region_b: ty::Region,\n-                        scope_a: ast::NodeId,\n-                        scope_b: ast::NodeId) -> cres<'tcx, Region>\n+                        scope_a: region::CodeExtent,\n+                        scope_b: region::CodeExtent) -> cres<'tcx, Region>\n     {\n         // We want to generate the intersection of two\n         // scopes or two free regions.  So, if one of"}, {"sha": "761a1f66501ca597ad7694ee0c46a055d8a8df87", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -84,8 +84,8 @@ fn item_scope_tag(item: &ast::Item) -> &'static str {\n pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                             -> (String, Option<Span>) {\n     return match region {\n-      ReScope(node_id) => {\n-        match cx.map.find(node_id) {\n+      ReScope(scope) => {\n+        match cx.map.find(scope.node_id()) {\n           Some(ast_map::NodeBlock(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n@@ -112,7 +112,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (format!(\"unknown scope: {}.  Please report a bug.\", node_id), None)\n+            (format!(\"unknown scope: {}.  Please report a bug.\", scope), None)\n           }\n         }\n       }\n@@ -129,7 +129,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n         };\n \n-        match cx.map.find(fr.scope_id) {\n+        match cx.map.find(fr.scope.node_id()) {\n           Some(ast_map::NodeBlock(ref blk)) => {\n               let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n               (format!(\"{} {}\", prefix, msg), opt_span)\n@@ -141,7 +141,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n               // this really should not happen\n-              (format!(\"{} node {}\", prefix, fr.scope_id), None)\n+              (format!(\"{} unknown free region bounded by scope {}\", prefix, fr.scope), None)\n           }\n         }\n       }\n@@ -879,7 +879,7 @@ impl<'tcx> UserString<'tcx> for ty::Region {\n impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ReFree({}, {})\",\n-                self.scope_id,\n+                self.scope.node_id(),\n                 self.bound_region.repr(tcx))\n     }\n }"}, {"sha": "1e8c1fd14787d240f1a35f1991b43641710f6e4c", "filename": "src/librustc_trans/test.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc_trans%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc_trans%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftest.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -18,7 +18,7 @@ use driver::diagnostic;\n use driver::diagnostic::Emitter;\n use driver::driver;\n use middle::lang_items;\n-use middle::region;\n+use middle::region::{mod, CodeExtent};\n use middle::resolve;\n use middle::resolve_lifetime;\n use middle::stability;\n@@ -149,7 +149,9 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n         for child_rh in rh.sub.iter() {\n             self.create_region_hierarchy(child_rh);\n-            self.infcx.tcx.region_maps.record_encl_scope(child_rh.id, rh.id);\n+            self.infcx.tcx.region_maps.record_encl_scope(\n+                CodeExtent::from_node_id(child_rh.id),\n+                CodeExtent::from_node_id(rh.id));\n         }\n     }\n \n@@ -321,12 +323,12 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(CodeExtent::from_node_id(id)), ty::mk_int())\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: uint) -> ty::Region {\n-        ty::ReFree(ty::FreeRegion {scope_id: nid,\n-                                   bound_region: ty::BrAnon(id)})\n+        ty::ReFree(ty::FreeRegion { scope: CodeExtent::from_node_id(nid),\n+                                    bound_region: ty::BrAnon(id)})\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> Ty<'tcx> {"}, {"sha": "b0235be7497eae95dd301aee4e83c1409833ed44", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -26,6 +26,7 @@ use trans::common;\n use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n use trans::debuginfo;\n use trans::glue;\n+use middle::region;\n use trans::type_::Type;\n use middle::ty::{mod, Ty};\n use std::fmt;\n@@ -137,7 +138,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             assert_eq!(self.ccx\n                            .tcx()\n                            .region_maps\n-                           .opt_encl_scope(debug_loc.id),\n+                           .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n+                           .map(|s|s.node_id()),\n                        top_scope);\n         }\n \n@@ -1096,7 +1098,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n                        -> ScopeId {\n     match tcx.region_maps.temporary_scope(id) {\n         Some(scope) => {\n-            let r = AstScope(scope);\n+            let r = AstScope(scope.node_id());\n             debug!(\"temporary_scope({}) = {}\", id, r);\n             r\n         }\n@@ -1110,7 +1112,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n-    let r = AstScope(tcx.region_maps.var_scope(id));\n+    let r = AstScope(tcx.region_maps.var_scope(id).node_id());\n     debug!(\"var_scope({}) = {}\", id, r);\n     r\n }"}, {"sha": "235805a7c8308bf62e9e95cd805c6d9ea9ecd2f2", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff9087e05e6661990856ab3bdbc197e50380db5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5ff9087e05e6661990856ab3bdbc197e50380db5", "patch": "@@ -21,6 +21,7 @@ use llvm::{True, False, Bool};\n use middle::def;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n+use middle::region;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use trans::base;\n@@ -490,7 +491,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx().method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n     }\n \n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId> {\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n         self.tcx().region_maps.temporary_scope(rvalue_id)\n     }\n "}]}