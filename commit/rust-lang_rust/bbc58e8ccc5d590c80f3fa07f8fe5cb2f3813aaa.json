{"sha": "bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa", "node_id": "C_kwDOAAsO6NoAKGJiYzU4ZThjY2M1ZDU5MGM4MGYzZmEwN2Y4ZmU1Y2IyZjM4MTNhYWE", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-10-31T04:26:38Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-10-31T17:19:18Z"}, "message": "Reduce rightward drift", "tree": {"sha": "3630d80c3c9c4d5e113ccf25eaa6dbe62890e387", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3630d80c3c9c4d5e113ccf25eaa6dbe62890e387"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa", "html_url": "https://github.com/rust-lang/rust/commit/bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eeb2a6203b9b7072d088fbc5339f4c8311e57097", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb2a6203b9b7072d088fbc5339f4c8311e57097", "html_url": "https://github.com/rust-lang/rust/commit/eeb2a6203b9b7072d088fbc5339f4c8311e57097"}], "stats": {"total": 153, "additions": 75, "deletions": 78}, "files": [{"sha": "508407144c216865109d0586ffaf627f9a3b6bf1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 74, "deletions": 78, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa", "patch": "@@ -1215,96 +1215,92 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n }\n \n fn maybe_expand_private_type_alias(cx: &mut DocContext<'_>, path: &hir::Path<'_>) -> Option<Type> {\n-    let mut alias = None;\n-    if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n-        // Substitute private type aliases\n-        if let Some(def_id) = def_id.as_local() {\n-            let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-            if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n-                alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n-            }\n-        }\n+    let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n+    // Substitute private type aliases\n+    let Some(def_id) = def_id.as_local() else { return None };\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n+    let alias = if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n+        &cx.tcx.hir().expect_item(hir_id).kind\n+    } else {\n+        return None;\n     };\n+    let hir::ItemKind::TyAlias(ty, generics) = alias else { return None };\n \n-    if let Some(&hir::ItemKind::TyAlias(ref ty, ref generics)) = alias {\n-        let provided_params = &path.segments.last().expect(\"segments were empty\");\n-        let mut ty_substs = FxHashMap::default();\n-        let mut lt_substs = FxHashMap::default();\n-        let mut ct_substs = FxHashMap::default();\n-        let generic_args = provided_params.args();\n-        {\n-            let mut indices: hir::GenericParamCount = Default::default();\n-            for param in generics.params.iter() {\n-                match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => {\n-                        let mut j = 0;\n-                        let lifetime = generic_args.args.iter().find_map(|arg| match arg {\n-                            hir::GenericArg::Lifetime(lt) => {\n-                                if indices.lifetimes == j {\n-                                    return Some(lt);\n-                                }\n-                                j += 1;\n-                                None\n-                            }\n-                            _ => None,\n-                        });\n-                        if let Some(lt) = lifetime.cloned() {\n-                            let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                            let cleaned = if !lt.is_elided() {\n-                                lt.clean(cx)\n-                            } else {\n-                                self::types::Lifetime::elided()\n-                            };\n-                            lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n+    let provided_params = &path.segments.last().expect(\"segments were empty\");\n+    let mut ty_substs = FxHashMap::default();\n+    let mut lt_substs = FxHashMap::default();\n+    let mut ct_substs = FxHashMap::default();\n+    let generic_args = provided_params.args();\n+\n+    let mut indices: hir::GenericParamCount = Default::default();\n+    for param in generics.params.iter() {\n+        match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                let mut j = 0;\n+                let lifetime = generic_args.args.iter().find_map(|arg| match arg {\n+                    hir::GenericArg::Lifetime(lt) => {\n+                        if indices.lifetimes == j {\n+                            return Some(lt);\n                         }\n-                        indices.lifetimes += 1;\n+                        j += 1;\n+                        None\n                     }\n-                    hir::GenericParamKind::Type { ref default, .. } => {\n-                        let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                        let mut j = 0;\n-                        let type_ = generic_args.args.iter().find_map(|arg| match arg {\n-                            hir::GenericArg::Type(ty) => {\n-                                if indices.types == j {\n-                                    return Some(ty);\n-                                }\n-                                j += 1;\n-                                None\n-                            }\n-                            _ => None,\n-                        });\n-                        if let Some(ty) = type_ {\n-                            ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n-                        } else if let Some(default) = *default {\n-                            ty_substs.insert(ty_param_def_id.to_def_id(), default.clean(cx));\n+                    _ => None,\n+                });\n+                if let Some(lt) = lifetime.cloned() {\n+                    let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                    let cleaned = if !lt.is_elided() {\n+                        lt.clean(cx)\n+                    } else {\n+                        self::types::Lifetime::elided()\n+                    };\n+                    lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n+                }\n+                indices.lifetimes += 1;\n+            }\n+            hir::GenericParamKind::Type { ref default, .. } => {\n+                let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                let mut j = 0;\n+                let type_ = generic_args.args.iter().find_map(|arg| match arg {\n+                    hir::GenericArg::Type(ty) => {\n+                        if indices.types == j {\n+                            return Some(ty);\n                         }\n-                        indices.types += 1;\n+                        j += 1;\n+                        None\n                     }\n-                    hir::GenericParamKind::Const { .. } => {\n-                        let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                        let mut j = 0;\n-                        let const_ = generic_args.args.iter().find_map(|arg| match arg {\n-                            hir::GenericArg::Const(ct) => {\n-                                if indices.consts == j {\n-                                    return Some(ct);\n-                                }\n-                                j += 1;\n-                                None\n-                            }\n-                            _ => None,\n-                        });\n-                        if let Some(ct) = const_ {\n-                            ct_substs.insert(const_param_def_id.to_def_id(), ct.clean(cx));\n+                    _ => None,\n+                });\n+                if let Some(ty) = type_ {\n+                    ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n+                } else if let Some(default) = *default {\n+                    ty_substs.insert(ty_param_def_id.to_def_id(), default.clean(cx));\n+                }\n+                indices.types += 1;\n+            }\n+            hir::GenericParamKind::Const { .. } => {\n+                let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                let mut j = 0;\n+                let const_ = generic_args.args.iter().find_map(|arg| match arg {\n+                    hir::GenericArg::Const(ct) => {\n+                        if indices.consts == j {\n+                            return Some(ct);\n                         }\n-                        // FIXME(const_generics_defaults)\n-                        indices.consts += 1;\n+                        j += 1;\n+                        None\n                     }\n+                    _ => None,\n+                });\n+                if let Some(ct) = const_ {\n+                    ct_substs.insert(const_param_def_id.to_def_id(), ct.clean(cx));\n                 }\n+                // FIXME(const_generics_defaults)\n+                indices.consts += 1;\n             }\n         }\n-        Some(cx.enter_alias(ty_substs, lt_substs, ct_substs, |cx| ty.clean(cx)))\n-    } else {\n-        None\n     }\n+\n+    Some(cx.enter_alias(ty_substs, lt_substs, ct_substs, |cx| ty.clean(cx)))\n }\n \n impl Clean<Type> for hir::Ty<'_> {"}, {"sha": "8dceb2ec92a27929c068204f5f9ab87c5b5c3d67", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=bbc58e8ccc5d590c80f3fa07f8fe5cb2f3813aaa", "patch": "@@ -9,6 +9,7 @@\n #![feature(control_flow_enum)]\n #![feature(box_syntax)]\n #![feature(in_band_lifetimes)]\n+#![feature(let_else)]\n #![feature(nll)]\n #![feature(test)]\n #![feature(crate_visibility_modifier)]"}]}