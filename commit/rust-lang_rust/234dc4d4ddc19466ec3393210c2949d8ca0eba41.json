{"sha": "234dc4d4ddc19466ec3393210c2949d8ca0eba41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNGRjNGQ0ZGRjMTk0NjZlYzMzOTMyMTBjMjk0OWQ4Y2EwZWJhNDE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-03T14:46:29Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-03T21:30:48Z"}, "message": "core: use assoc types in `Index[Mut]`", "tree": {"sha": "3e437cbf3bdd6d89bfadffb96d1615cfe19529b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e437cbf3bdd6d89bfadffb96d1615cfe19529b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/234dc4d4ddc19466ec3393210c2949d8ca0eba41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/234dc4d4ddc19466ec3393210c2949d8ca0eba41", "html_url": "https://github.com/rust-lang/rust/commit/234dc4d4ddc19466ec3393210c2949d8ca0eba41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/234dc4d4ddc19466ec3393210c2949d8ca0eba41/comments", "author": null, "committer": null, "parents": [{"sha": "fc343304af6ff522b9aa3b143ef6cd4bddd7e7a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc343304af6ff522b9aa3b143ef6cd4bddd7e7a2", "html_url": "https://github.com/rust-lang/rust/commit/fc343304af6ff522b9aa3b143ef6cd4bddd7e7a2"}], "stats": {"total": 70, "additions": 64, "deletions": 6}, "files": [{"sha": "bef91dbd7604733c17a1841d248cd3131fa473a5", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/234dc4d4ddc19466ec3393210c2949d8ca0eba41/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/234dc4d4ddc19466ec3393210c2949d8ca0eba41/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=234dc4d4ddc19466ec3393210c2949d8ca0eba41", "patch": "@@ -717,6 +717,15 @@ macro_rules! shr_impl {\n \n shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n+// NOTE(stage0) remove trait after a snapshot\n+#[cfg(stage0)]\n+#[allow(missing_docs)]\n+#[lang=\"index\"]\n+pub trait Index<Sized? Index, Sized? Result> for Sized? {\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    fn index<'a>(&'a self, index: &Index) -> &'a Result;\n+}\n+\n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `arr[idx]` when used in an immutable context.\n ///\n@@ -726,12 +735,16 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `index`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Index;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Index<Foo, Foo> for Foo {\n+/// impl Index<Foo> for Foo {\n+///     type Output = Foo;\n+///\n ///     fn index<'a>(&'a self, _index: &Foo) -> &'a Foo {\n ///         println!(\"Indexing!\");\n ///         self\n@@ -742,10 +755,22 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n ///     Foo[Foo];\n /// }\n /// ```\n+#[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n #[lang=\"index\"]\n-pub trait Index<Sized? Index, Sized? Result> for Sized? {\n+pub trait Index<Sized? Index> for Sized? {\n+    type Sized? Output;\n+\n     /// The method for the indexing (`Foo[Bar]`) operation\n-    fn index<'a>(&'a self, index: &Index) -> &'a Result;\n+    fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n+}\n+\n+// NOTE(stage0) remove trait after a snapshot\n+#[cfg(stage0)]\n+#[allow(missing_docs)]\n+#[lang=\"index_mut\"]\n+pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n@@ -757,12 +782,16 @@ pub trait Index<Sized? Index, Sized? Result> for Sized? {\n /// calling `index_mut`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::IndexMut;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl IndexMut<Foo, Foo> for Foo {\n+/// impl IndexMut<Foo> for Foo {\n+///     type Output = Foo;\n+///\n ///     fn index_mut<'a>(&'a mut self, _index: &Foo) -> &'a mut Foo {\n ///         println!(\"Indexing!\");\n ///         self\n@@ -773,10 +802,13 @@ pub trait Index<Sized? Index, Sized? Result> for Sized? {\n ///     &mut Foo[Foo];\n /// }\n /// ```\n+#[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n+pub trait IndexMut<Sized? Index> for Sized? {\n+    type Sized? Output;\n+\n     /// The method for the indexing (`Foo[Bar]`) operation\n-    fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n+    fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n /// The `Slice` trait is used to specify the functionality of slicing operations"}, {"sha": "d5810a382968b29a0c56bbe280a31d3db37b78b5", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/234dc4d4ddc19466ec3393210c2949d8ca0eba41/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/234dc4d4ddc19466ec3393210c2949d8ca0eba41/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=234dc4d4ddc19466ec3393210c2949d8ca0eba41", "patch": "@@ -531,6 +531,8 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n+// NOTE(stage0) remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> ops::Index<uint, T> for [T] {\n     fn index(&self, &index: &uint) -> &T {\n         assert!(index < self.len());\n@@ -539,6 +541,19 @@ impl<T> ops::Index<uint, T> for [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n+impl<T> ops::Index<uint> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, &index: &uint) -> &T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n+// NOTE(stage0) remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> ops::IndexMut<uint, T> for [T] {\n     fn index_mut(&mut self, &index: &uint) -> &mut T {\n         assert!(index < self.len());\n@@ -547,6 +562,17 @@ impl<T> ops::IndexMut<uint, T> for [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n+impl<T> ops::IndexMut<uint> for [T] {\n+    type Output = T;\n+\n+    fn index_mut(&mut self, &index: &uint) -> &mut T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n impl<T> ops::Slice<uint, [T]> for [T] {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {"}]}