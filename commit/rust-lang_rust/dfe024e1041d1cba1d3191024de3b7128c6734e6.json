{"sha": "dfe024e1041d1cba1d3191024de3b7128c6734e6", "node_id": "C_kwDOAAsO6NoAKGRmZTAyNGUxMDQxZDFjYmExZDMxOTEwMjRkZTNiNzEyOGM2NzM0ZTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-11T10:32:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-11T10:32:41Z"}, "message": "Auto merge of #109765 - petrochenkov:encodeless, r=cjgillot\n\nrustc_metadata: Filter encoded data more aggressively using `DefKind`\n\nI focused on data that contains spans, because spans are expensive to encode/decode/hash, but also touched `should_encode_visibility` too.\n\nOne incorrect use of impl visibility in diagnostics is also replaced with trait visibility.", "tree": {"sha": "eecd231caf49b1d411c6bf94de1c86feb382086f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eecd231caf49b1d411c6bf94de1c86feb382086f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfe024e1041d1cba1d3191024de3b7128c6734e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe024e1041d1cba1d3191024de3b7128c6734e6", "html_url": "https://github.com/rust-lang/rust/commit/dfe024e1041d1cba1d3191024de3b7128c6734e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfe024e1041d1cba1d3191024de3b7128c6734e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e1162f07e8b7d59f6a0e0a5576352d888defa78", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e1162f07e8b7d59f6a0e0a5576352d888defa78", "html_url": "https://github.com/rust-lang/rust/commit/8e1162f07e8b7d59f6a0e0a5576352d888defa78"}, {"sha": "f5a9f6fb7eccc1545ff871c6f15b8a2d49df2efc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5a9f6fb7eccc1545ff871c6f15b8a2d49df2efc", "html_url": "https://github.com/rust-lang/rust/commit/f5a9f6fb7eccc1545ff871c6f15b8a2d49df2efc"}], "stats": {"total": 283, "additions": 197, "deletions": 86}, "files": [{"sha": "37c894348cd4b574134a9e6c90495a45ded8d8c7", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfe024e1041d1cba1d3191024de3b7128c6734e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe024e1041d1cba1d3191024de3b7128c6734e6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=dfe024e1041d1cba1d3191024de3b7128c6734e6", "patch": "@@ -2580,7 +2580,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.all_impls(trait_def_id)\n                     .filter(|impl_def_id| {\n                         // Consider only accessible traits\n-                        tcx.visibility(*impl_def_id).is_accessible_from(self.item_def_id(), tcx)\n+                        tcx.visibility(trait_def_id).is_accessible_from(self.item_def_id(), tcx)\n                             && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n                     })\n                     .filter_map(|impl_def_id| tcx.impl_trait_ref(impl_def_id))"}, {"sha": "77308212c32d5d10137408102cc303e77222949b", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfe024e1041d1cba1d3191024de3b7128c6734e6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe024e1041d1cba1d3191024de3b7128c6734e6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=dfe024e1041d1cba1d3191024de3b7128c6734e6", "patch": "@@ -749,6 +749,10 @@ impl CrateRoot {\n }\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n+    fn missing(self, descr: &str, id: DefIndex) -> ! {\n+        bug!(\"missing `{descr}` for {:?}\", self.local_def_id(id))\n+    }\n+\n     fn raw_proc_macro(self, id: DefIndex) -> &'a ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n@@ -782,8 +786,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn opt_item_ident(self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n         let name = self.opt_item_name(item_index)?;\n-        let span =\n-            self.root.tables.def_ident_span.get(self, item_index).unwrap().decode((self, sess));\n+        let span = self\n+            .root\n+            .tables\n+            .def_ident_span\n+            .get(self, item_index)\n+            .unwrap_or_else(|| self.missing(\"def_ident_span\", item_index))\n+            .decode((self, sess));\n         Some(Ident::new(name, span))\n     }\n \n@@ -812,7 +821,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .def_span\n             .get(self, index)\n-            .unwrap_or_else(|| panic!(\"Missing span for {index:?}\"))\n+            .unwrap_or_else(|| self.missing(\"def_span\", index))\n             .decode((self, sess))\n     }\n \n@@ -924,7 +933,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .visibility\n             .get(self, id)\n-            .unwrap()\n+            .unwrap_or_else(|| self.missing(\"visibility\", id))\n             .decode(self)\n             .map_id(|index| self.local_def_id(index))\n     }\n@@ -934,7 +943,12 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_expn_that_defined(self, id: DefIndex, sess: &Session) -> ExpnId {\n-        self.root.tables.expn_that_defined.get(self, id).unwrap().decode((self, sess))\n+        self.root\n+            .tables\n+            .expn_that_defined\n+            .get(self, id)\n+            .unwrap_or_else(|| self.missing(\"expn_that_defined\", id))\n+            .decode((self, sess))\n     }\n \n     fn get_debugger_visualizers(self) -> Vec<rustc_span::DebuggerVisualizerFile> {"}, {"sha": "77ec03165fbf25123cb5e0d353246f538a42eb47", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 160, "deletions": 72, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/dfe024e1041d1cba1d3191024de3b7128c6734e6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe024e1041d1cba1d3191024de3b7128c6734e6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=dfe024e1041d1cba1d3191024de3b7128c6734e6", "patch": "@@ -811,7 +811,7 @@ fn analyze_attr(attr: &Attribute, state: &mut AnalyzeAttrState) -> bool {\n     should_encode\n }\n \n-fn should_encode_visibility(def_kind: DefKind) -> bool {\n+fn should_encode_span(def_kind: DefKind) -> bool {\n     match def_kind {\n         DefKind::Mod\n         | DefKind::Struct\n@@ -823,25 +823,136 @@ fn should_encode_visibility(def_kind: DefKind) -> bool {\n         | DefKind::ForeignTy\n         | DefKind::TraitAlias\n         | DefKind::AssocTy\n+        | DefKind::TyParam\n         | DefKind::Fn\n         | DefKind::Const\n-        | DefKind::Static(..)\n+        | DefKind::Static(_)\n         | DefKind::Ctor(..)\n         | DefKind::AssocFn\n         | DefKind::AssocConst\n-        | DefKind::Macro(..)\n+        | DefKind::Macro(_)\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::Field\n+        | DefKind::Impl { .. }\n+        | DefKind::Closure\n+        | DefKind::Generator => true,\n+        DefKind::ConstParam\n+        | DefKind::ExternCrate\n+        | DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::ImplTraitPlaceholder\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm => false,\n+    }\n+}\n+\n+fn should_encode_attrs(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::AssocTy\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::Static(_)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Macro(_)\n+        | DefKind::Field\n+        | DefKind::Impl { .. } => true,\n+        DefKind::TyParam\n+        | DefKind::ConstParam\n+        | DefKind::Ctor(..)\n+        | DefKind::ExternCrate\n         | DefKind::Use\n         | DefKind::ForeignMod\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n         | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n-        | DefKind::Impl { .. }\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::Closure\n+        | DefKind::Generator => false,\n+    }\n+}\n+\n+fn should_encode_expn_that_defined(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::Impl { .. } => true,\n+        DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::AssocTy\n+        | DefKind::TyParam\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::ConstParam\n+        | DefKind::Static(_)\n+        | DefKind::Ctor(..)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Macro(_)\n+        | DefKind::ExternCrate\n+        | DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::ImplTraitPlaceholder\n+        | DefKind::Field\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::Closure\n+        | DefKind::Generator => false,\n+    }\n+}\n+\n+fn should_encode_visibility(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::AssocTy\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::Static(..)\n+        | DefKind::Ctor(..)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Macro(..)\n         | DefKind::Field => true,\n-        DefKind::TyParam\n+        DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::TyParam\n         | DefKind::ConstParam\n         | DefKind::LifetimeParam\n         | DefKind::AnonConst\n         | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::ImplTraitPlaceholder\n         | DefKind::GlobalAsm\n+        | DefKind::Impl { .. }\n         | DefKind::Closure\n         | DefKind::Generator\n         | DefKind::ExternCrate => false,\n@@ -1160,11 +1271,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n             self.tables.opt_def_kind.set_some(def_id.index, def_kind);\n-            let def_span = tcx.def_span(local_id);\n-            record!(self.tables.def_span[def_id] <- def_span);\n-            self.encode_attrs(local_id);\n-            record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n-            if let Some(ident_span) = tcx.def_ident_span(def_id) {\n+            if should_encode_span(def_kind) {\n+                let def_span = tcx.def_span(local_id);\n+                record!(self.tables.def_span[def_id] <- def_span);\n+            }\n+            if should_encode_attrs(def_kind) {\n+                self.encode_attrs(local_id);\n+            }\n+            if should_encode_expn_that_defined(def_kind) {\n+                record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n+            }\n+            if should_encode_span(def_kind) && let Some(ident_span) = tcx.def_ident_span(def_id) {\n                 record!(self.tables.def_ident_span[def_id] <- ident_span);\n             }\n             if def_kind.has_codegen_attrs() {\n@@ -1523,23 +1640,32 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item<'tcx>) {\n+    fn encode_info_for_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n-\n+        let def_id = item.owner_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n+        let record_associated_item_def_ids = |this: &mut Self, def_ids: &[DefId]| {\n+            record_array!(this.tables.children[def_id] <- def_ids.iter().map(|&def_id| {\n+                assert!(def_id.is_local());\n+                def_id.index\n+            }))\n+        };\n+\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 self.tables.constness.set_some(def_id.index, sig.header.constness);\n+                record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+                self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.tables.is_macro_rules.set(def_id.index, macro_def.macro_rules);\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.owner_id.def_id, m);\n+                self.encode_info_for_mod(item.owner_id.def_id, m);\n             }\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1550,9 +1676,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set_some(def_id.index, *defaultness);\n                 self.tables.constness.set_some(def_id.index, *constness);\n+                self.tables.impl_polarity.set_some(def_id.index, self.tcx.impl_polarity(def_id));\n+\n+                if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n+                    record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n \n-                let trait_ref = self.tcx.impl_trait_ref(def_id);\n-                if let Some(trait_ref) = trait_ref {\n                     let trait_ref = trait_ref.skip_binder();\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n@@ -1570,71 +1698,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     }\n                 }\n \n-                let polarity = self.tcx.impl_polarity(def_id);\n-                self.tables.impl_polarity.set_some(def_id.index, polarity);\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record_associated_item_def_ids(self, associated_item_def_ids);\n+                for &trait_item_def_id in associated_item_def_ids {\n+                    self.encode_info_for_impl_item(trait_item_def_id);\n+                }\n             }\n             hir::ItemKind::Trait(..) => {\n-                let trait_def = self.tcx.trait_def(def_id);\n-                record!(self.tables.trait_def[def_id] <- trait_def);\n+                record!(self.tables.trait_def[def_id] <- self.tcx.trait_def(def_id));\n+\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record_associated_item_def_ids(self, associated_item_def_ids);\n+                for &item_def_id in associated_item_def_ids {\n+                    self.encode_info_for_trait_item(item_def_id);\n+                }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                let trait_def = self.tcx.trait_def(def_id);\n-                record!(self.tables.trait_def[def_id] <- trait_def);\n-            }\n-            hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {\n-                bug!(\"cannot encode info for item {:?}\", item)\n+                record!(self.tables.trait_def[def_id] <- self.tcx.trait_def(def_id));\n             }\n-            hir::ItemKind::Static(..)\n+            hir::ItemKind::ExternCrate(_)\n+            | hir::ItemKind::Use(..)\n+            | hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::TyAlias(..) => {}\n-        };\n-        // FIXME(eddyb) there should be a nicer way to do this.\n-        match item.kind {\n-            hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n-                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n-                record_array!(self.tables.children[def_id] <-\n-                    associated_item_def_ids.iter().map(|&def_id| {\n-                        assert!(def_id.is_local());\n-                        def_id.index\n-                    })\n-                );\n-            }\n-            _ => {}\n-        }\n-        if let hir::ItemKind::Fn(..) = item.kind {\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n-        }\n-        if let hir::ItemKind::Impl { .. } = item.kind {\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n-                record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n-            }\n-        }\n-        // In some cases, along with the item itself, we also\n-        // encode some sub-items. Usually we want some info from the item\n-        // so it's easier to do that here then to wait until we would encounter\n-        // normally in the visitor walk.\n-        match item.kind {\n-            hir::ItemKind::Impl { .. } => {\n-                for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_impl_item(trait_item_def_id);\n-                }\n-            }\n-            hir::ItemKind::Trait(..) => {\n-                for &item_def_id in\n-                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_trait_item(item_def_id);\n-                }\n-            }\n-            _ => {}\n         }\n     }\n \n@@ -2020,10 +2111,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n-        match item.kind {\n-            hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(item.owner_id.to_def_id(), item),\n-        }\n+        self.encode_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);"}, {"sha": "e34ece9264cfb9419e1e4d4f006eed7b0a929e21", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfe024e1041d1cba1d3191024de3b7128c6734e6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe024e1041d1cba1d3191024de3b7128c6734e6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=dfe024e1041d1cba1d3191024de3b7128c6734e6", "patch": "@@ -687,7 +687,7 @@ impl Item {\n                 return None;\n             }\n             // Variants always inherit visibility\n-            VariantItem(..) => return None,\n+            VariantItem(..) | ImplItem(..) => return None,\n             // Trait items inherit the trait's visibility\n             AssocConstItem(..) | TyAssocConstItem(..) | AssocTypeItem(..) | TyAssocTypeItem(..)\n             | TyMethodItem(..) | MethodItem(..) => {"}, {"sha": "5d6b1b591810006a0d1076d877ef7a5c6237aefa", "filename": "tests/ui/associated-types/associated-types-in-ambiguous-context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfe024e1041d1cba1d3191024de3b7128c6734e6/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe024e1041d1cba1d3191024de3b7128c6734e6/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.rs?ref=dfe024e1041d1cba1d3191024de3b7128c6734e6", "patch": "@@ -1,3 +1,5 @@\n+// normalize-stderr-test: \"and \\d+ other candidates\" -> \"and N other candidates\"\n+\n trait Get {\n     type Value;\n     fn get(&self) -> <Self as Get>::Value;"}, {"sha": "1ff6fd4b821e31af0c4d445c6747328cd7e3ce98", "filename": "tests/ui/associated-types/associated-types-in-ambiguous-context.stderr", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dfe024e1041d1cba1d3191024de3b7128c6734e6/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfe024e1041d1cba1d3191024de3b7128c6734e6/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr?ref=dfe024e1041d1cba1d3191024de3b7128c6734e6", "patch": "@@ -1,5 +1,5 @@\n error[E0223]: ambiguous associated type\n-  --> $DIR/associated-types-in-ambiguous-context.rs:6:36\n+  --> $DIR/associated-types-in-ambiguous-context.rs:8:36\n    |\n LL | fn get<T:Get,U:Get>(x: T, y: U) -> Get::Value {}\n    |                                    ^^^^^^^^^^\n@@ -10,30 +10,37 @@ LL | fn get<T:Get,U:Get>(x: T, y: U) -> <Example as Get>::Value {}\n    |                                    ~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n-  --> $DIR/associated-types-in-ambiguous-context.rs:20:17\n+  --> $DIR/associated-types-in-ambiguous-context.rs:22:17\n    |\n LL | trait Foo where Foo::Assoc: Bar {\n    |                 ^^^^^^^^^^ help: use the fully-qualified path: `<Self as Foo>::Assoc`\n \n error[E0223]: ambiguous associated type\n-  --> $DIR/associated-types-in-ambiguous-context.rs:25:10\n+  --> $DIR/associated-types-in-ambiguous-context.rs:27:10\n    |\n LL | type X = std::ops::Deref::Target;\n    |          ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: if there were a type named `Example` that implemented `Deref`, you could use the fully-qualified path\n+help: use the fully-qualified path\n    |\n-LL | type X = <Example as Deref>::Target;\n+LL | type X = <CString as Deref>::Target;\n    |          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL | type X = <IoSlice<'_> as Deref>::Target;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL | type X = <IoSliceMut<'_> as Deref>::Target;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL | type X = <OsString as Deref>::Target;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+     and N other candidates\n \n error[E0223]: ambiguous associated type\n-  --> $DIR/associated-types-in-ambiguous-context.rs:11:23\n+  --> $DIR/associated-types-in-ambiguous-context.rs:13:23\n    |\n LL |     fn grab(&self) -> Grab::Value;\n    |                       ^^^^^^^^^^^ help: use the fully-qualified path: `<Self as Grab>::Value`\n \n error[E0223]: ambiguous associated type\n-  --> $DIR/associated-types-in-ambiguous-context.rs:14:22\n+  --> $DIR/associated-types-in-ambiguous-context.rs:16:22\n    |\n LL |     fn get(&self) -> Get::Value;\n    |                      ^^^^^^^^^^"}]}