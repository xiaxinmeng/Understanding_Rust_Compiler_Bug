{"sha": "03c4628a5b71af301ccf51d9b1b6ab2207b1fcca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYzQ2MjhhNWI3MWFmMzAxY2NmNTFkOWIxYjZhYjIyMDdiMWZjY2E=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-08T00:18:03Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:03:02Z"}, "message": "Avoid clone and update documentation", "tree": {"sha": "67a9271c14d7da2749f75653286fd12d425dc808", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67a9271c14d7da2749f75653286fd12d425dc808"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca", "html_url": "https://github.com/rust-lang/rust/commit/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "html_url": "https://github.com/rust-lang/rust/commit/04d33bbdb3ca017a31f9f84218d894475a2d4a0a"}], "stats": {"total": 177, "additions": 97, "deletions": 80}, "files": [{"sha": "2573a967985a5c6f97de78aacc814f67c7f78e97", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=03c4628a5b71af301ccf51d9b1b6ab2207b1fcca", "patch": "@@ -17,6 +17,7 @@ use rustc_data_structures::array_vec::ArrayVec;\n use hir::{self, GenericArg, GenericArgs};\n use hir::def::Def;\n use hir::def_id::DefId;\n+use hir::HirVec;\n use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n use rustc::ty::subst::{Kind, Subst, Substs};\n@@ -34,6 +35,7 @@ use lint;\n \n use std::iter;\n use syntax::ast;\n+use syntax::ptr::P;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::{Span, MultiSpan};\n \n@@ -90,9 +92,9 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n-pub struct GenericArgMismatchErrorCode {\n-    pub lifetimes: (&'static str, &'static str),\n-    pub types: (&'static str, &'static str),\n+struct GenericArgMismatchErrorCode {\n+    lifetimes: (&'static str, &'static str),\n+    types: (&'static str, &'static str),\n }\n \n /// Dummy type used for the `Self` of a `TraitRef` created for converting\n@@ -193,9 +195,72 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         substs\n     }\n \n+    /// Report error if there is an explicit type parameter when using `impl Trait`.\n+    fn check_impl_trait(\n+        tcx: TyCtxt,\n+        span: Span,\n+        seg: &hir::PathSegment,\n+        generics: &ty::Generics,\n+    ) -> bool {\n+        let explicit = !seg.infer_types;\n+        let impl_trait = generics.params.iter().any(|param| match param.kind {\n+            ty::GenericParamDefKind::Type {\n+                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n+            } => true,\n+            _ => false,\n+        });\n+\n+        if explicit && impl_trait {\n+            let mut err = struct_span_err! {\n+                tcx.sess,\n+                span,\n+                E0632,\n+                \"cannot provide explicit type parameters when `impl Trait` is \\\n+                used in argument position.\"\n+            };\n+\n+            err.emit();\n+        }\n+\n+        impl_trait\n+    }\n+\n+    /// Check that the correct number of generic arguments have been provided.\n+    /// Used specifically for function calls.\n+    pub fn check_generic_arg_count_for_call(\n+        tcx: TyCtxt,\n+        span: Span,\n+        def: &ty::Generics,\n+        seg: &hir::PathSegment,\n+        is_method_call: bool,\n+    ) -> bool {\n+        let empty_args = P(hir::GenericArgs {\n+            args: HirVec::new(), bindings: HirVec::new(), parenthesized: false,\n+        });\n+        let suppress_mismatch = Self::check_impl_trait(tcx, span, seg, &def);\n+        Self::check_generic_arg_count(\n+            tcx,\n+            span,\n+            def,\n+            if let Some(ref args) = seg.args {\n+                args\n+            } else {\n+                &empty_args\n+            },\n+            false, // `is_declaration`\n+            is_method_call,\n+            def.parent.is_none() && def.has_self, // `has_self`\n+            seg.infer_types || suppress_mismatch, // `infer_types`\n+            GenericArgMismatchErrorCode {\n+                lifetimes: (\"E0090\", \"E0088\"),\n+                types: (\"E0089\", \"E0087\"),\n+            },\n+        )\n+    }\n+\n     /// Check that the correct number of generic arguments have been provided.\n     /// This is used both for type declarations and function calls.\n-    pub fn check_generic_arg_count(\n+    fn check_generic_arg_count(\n         tcx: TyCtxt,\n         span: Span,\n         def: &ty::Generics,"}, {"sha": "e848508b8c04defd38fd663075926db027c61dff", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=03c4628a5b71af301ccf51d9b1b6ab2207b1fcca", "patch": "@@ -10,11 +10,10 @@\n \n use super::{probe, MethodCallee};\n \n-use astconv::{AstConv, GenericArgMismatchErrorCode};\n+use astconv::AstConv;\n use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::GenericArg;\n use hir::def_id::DefId;\n-use hir::HirVec;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, GenericParamDefKind};\n@@ -25,7 +24,6 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n use rustc::hir;\n use syntax_pos::Span;\n-use syntax::ptr::P;\n \n use std::ops::Deref;\n \n@@ -310,34 +308,24 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_substs(\n         &mut self,\n         pick: &probe::Pick<'tcx>,\n-        segment: &hir::PathSegment,\n+        seg: &hir::PathSegment,\n         parent_substs: &Substs<'tcx>,\n     ) -> &'tcx Substs<'tcx> {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n-        let method_generics = self.tcx.generics_of(pick.item.def_id);\n-        let suppress_mismatch = self.fcx.check_impl_trait(self.span, segment, &method_generics);\n-        AstConv::check_generic_arg_count(\n+        let generics = self.tcx.generics_of(pick.item.def_id);\n+        AstConv::check_generic_arg_count_for_call(\n             self.tcx,\n             self.span,\n-            &method_generics,\n-            &segment.args.clone().unwrap_or_else(|| P(hir::GenericArgs {\n-                args: HirVec::new(), bindings: HirVec::new(), parenthesized: false,\n-            })),\n-            false, // `is_declaration`\n+            &generics,\n+            &seg,\n             true, // `is_method_call`\n-            method_generics.parent.is_none() && method_generics.has_self,\n-            segment.infer_types || suppress_mismatch,\n-            GenericArgMismatchErrorCode {\n-                lifetimes: (\"E0090\", \"E0088\"),\n-                types: (\"E0089\", \"E0087\"),\n-            },\n         );\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n-        assert_eq!(method_generics.parent_count, parent_substs.len());\n+        assert_eq!(generics.parent_count, parent_substs.len());\n \n         AstConv::create_substs_for_generic_args(\n             self.tcx,\n@@ -348,7 +336,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // Provide the generic args, and whether types should be inferred.\n             |_| {\n                 // The last argument of the returned tuple here is unimportant.\n-                if let Some(ref data) = segment.args {\n+                if let Some(ref data) = seg.args {\n                     (Some(data), false)\n                 } else {\n                     (None, false)"}, {"sha": "3ed42b6b2617b7e68864f6416e7409aaa55f909e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 43, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=03c4628a5b71af301ccf51d9b1b6ab2207b1fcca", "patch": "@@ -84,10 +84,9 @@ pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{AstConv, GenericArgMismatchErrorCode};\n+use astconv::AstConv;\n use hir::GenericArg;\n use hir::def::Def;\n-use hir::HirVec;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n use namespace::Namespace;\n@@ -4945,22 +4944,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // `impl Trait` is treated as a normal generic parameter internally,\n             // but we don't allow users to specify the parameter's value\n             // explicitly, so we have to do some error-checking here.\n-            let suppress_mismatch = self.check_impl_trait(span, seg, &generics);\n-            suppress_errors.insert(index, AstConv::check_generic_arg_count(\n+            suppress_errors.insert(index, AstConv::check_generic_arg_count_for_call(\n                 self.tcx,\n                 span,\n                 &generics,\n-                &seg.args.clone().unwrap_or_else(|| P(hir::GenericArgs {\n-                    args: HirVec::new(), bindings: HirVec::new(), parenthesized: false,\n-                })),\n-                false, // `is_declaration`\n+                &seg,\n                 false, // `is_method_call`\n-                generics.parent.is_none() && generics.has_self,\n-                seg.infer_types || suppress_mismatch,\n-                GenericArgMismatchErrorCode {\n-                    lifetimes: (\"E0090\", \"E0088\"), // FIXME: E0090 and E0088 should be unified.\n-                    types: (\"E0089\", \"E0087\"), // FIXME: E0089 and E0087 should be unified.\n-                },\n             ));\n         }\n \n@@ -5112,35 +5101,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       directly, not through a function pointer\");\n     }\n \n-    /// Report error if there is an explicit type parameter when using `impl Trait`.\n-    fn check_impl_trait(&self,\n-                        span: Span,\n-                        seg: &hir::PathSegment,\n-                        generics: &ty::Generics)\n-                        -> bool {\n-        let explicit = !seg.infer_types;\n-        let impl_trait = generics.params.iter().any(|param| match param.kind {\n-            ty::GenericParamDefKind::Type {\n-                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n-            } => true,\n-            _ => false,\n-        });\n-\n-        if explicit && impl_trait {\n-            let mut err = struct_span_err! {\n-                self.tcx.sess,\n-                span,\n-                E0632,\n-                \"cannot provide explicit type parameters when `impl Trait` is \\\n-                used in argument position.\"\n-            };\n-\n-            err.emit();\n-        }\n-\n-        impl_trait\n-    }\n-\n     // Resolves `typ` by a single level if `typ` is a type variable.\n     // If no resolution is possible, then an error is reported.\n     // Numeric inference variables may be left unresolved."}, {"sha": "c01102272aeb4e7bc269ac970b14f7666cb9d1d4", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c4628a5b71af301ccf51d9b1b6ab2207b1fcca/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=03c4628a5b71af301ccf51d9b1b6ab2207b1fcca", "patch": "@@ -1041,32 +1041,34 @@ enum NightsWatch {}\n \"##,\n \n E0087: r##\"\n-Too many type parameters were supplied for a function. For example:\n+Too many type arguments were supplied for a function. For example:\n \n ```compile_fail,E0087\n fn foo<T>() {}\n \n fn main() {\n-    foo::<f64, bool>(); // error, expected 1 parameter, found 2 parameters\n+    foo::<f64, bool>(); // error: wrong number of type arguments:\n+                        //        expected 1, found 2\n }\n ```\n \n-The number of supplied parameters must exactly match the number of defined type\n+The number of supplied arguments must exactly match the number of defined type\n parameters.\n \"##,\n \n E0088: r##\"\n-You gave too many lifetime parameters. Erroneous code example:\n+You gave too many lifetime arguments. Erroneous code example:\n \n ```compile_fail,E0088\n fn f() {}\n \n fn main() {\n-    f::<'static>() // error: too many lifetime parameters provided\n+    f::<'static>() // error: wrong number of lifetime arguments:\n+                   //        expected 0, found 1\n }\n ```\n \n-Please check you give the right number of lifetime parameters. Example:\n+Please check you give the right number of lifetime arguments. Example:\n \n ```\n fn f() {}\n@@ -1101,42 +1103,44 @@ fn main() {\n \"##,\n \n E0089: r##\"\n-Not enough type parameters were supplied for a function. For example:\n+Too few type arguments were supplied for a function. For example:\n \n ```compile_fail,E0089\n fn foo<T, U>() {}\n \n fn main() {\n-    foo::<f64>(); // error, expected 2 parameters, found 1 parameter\n+    foo::<f64>(); // error: wrong number of type arguments: expected 2, found 1\n }\n ```\n \n-Note that if a function takes multiple type parameters but you want the compiler\n+Note that if a function takes multiple type arguments but you want the compiler\n to infer some of them, you can use type placeholders:\n \n ```compile_fail,E0089\n fn foo<T, U>(x: T) {}\n \n fn main() {\n     let x: bool = true;\n-    foo::<f64>(x);    // error, expected 2 parameters, found 1 parameter\n+    foo::<f64>(x);    // error: wrong number of type arguments:\n+                      //        expected 2, found 1\n     foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`\n }\n ```\n \"##,\n \n E0090: r##\"\n-You gave too few lifetime parameters. Example:\n+You gave too few lifetime arguments. Example:\n \n ```compile_fail,E0090\n fn foo<'a: 'b, 'b: 'a>() {}\n \n fn main() {\n-    foo::<'static>(); // error, expected 2 lifetime parameters\n+    foo::<'static>(); // error: wrong number of lifetime arguments:\n+                      //        expected 2, found 1\n }\n ```\n \n-Please check you give the right number of lifetime parameters. Example:\n+Please check you give the right number of lifetime arguments. Example:\n \n ```\n fn foo<'a: 'b, 'b: 'a>() {}"}]}