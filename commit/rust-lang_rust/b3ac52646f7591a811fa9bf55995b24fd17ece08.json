{"sha": "b3ac52646f7591a811fa9bf55995b24fd17ece08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYWM1MjY0NmY3NTkxYTgxMWZhOWJmNTU5OTViMjRmZDE3ZWNlMDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-11T04:09:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-11T04:09:44Z"}, "message": "Auto merge of #82964 - Nicholas-Baron:shorten_middle_ty, r=jackh726\n\nShorten `rustc_middle::ty::mod`\n\nRelated to #60302.\n\nThis PR moves all `Adt*`, `Assoc*`, `Generic*`, and `UpVar*` types to separate files.\nThis, alongside some `use` reordering, puts `mod.rs` at ~2,200 lines, thus removing the `// ignore-tidy-filelength`.\n\nThe particular groups were chosen as they had 4 or more \"substantive\" members.", "tree": {"sha": "d9845907a3e7ecf7a3ed31ba8257699031f38277", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9845907a3e7ecf7a3ed31ba8257699031f38277"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3ac52646f7591a811fa9bf55995b24fd17ece08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ac52646f7591a811fa9bf55995b24fd17ece08", "html_url": "https://github.com/rust-lang/rust/commit/b3ac52646f7591a811fa9bf55995b24fd17ece08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3ac52646f7591a811fa9bf55995b24fd17ece08/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "066f01d81bfbed746f6b6cf27a0426d829e8e832", "url": "https://api.github.com/repos/rust-lang/rust/commits/066f01d81bfbed746f6b6cf27a0426d829e8e832", "html_url": "https://github.com/rust-lang/rust/commit/066f01d81bfbed746f6b6cf27a0426d829e8e832"}, {"sha": "d022142adec5e68b65af4b781888d26cebfc1d72", "url": "https://api.github.com/repos/rust-lang/rust/commits/d022142adec5e68b65af4b781888d26cebfc1d72", "html_url": "https://github.com/rust-lang/rust/commit/d022142adec5e68b65af4b781888d26cebfc1d72"}], "stats": {"total": 2519, "additions": 1279, "deletions": 1240}, "files": [{"sha": "95159ea46aec3e9950150c87cbc4aeaf0f287ca0", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=b3ac52646f7591a811fa9bf55995b24fd17ece08", "patch": "@@ -0,0 +1,482 @@\n+use crate::ich::StableHashingContext;\n+use crate::mir::interpret::ErrorHandled;\n+use crate::ty;\n+use crate::ty::util::{Discr, IntTypeExt};\n+use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_errors::ErrorReported;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_serialize::{self, Encodable, Encoder};\n+use rustc_session::DataTypeKind;\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::VariantIdx;\n+\n+use std::cell::RefCell;\n+use std::cmp::Ordering;\n+use std::hash::{Hash, Hasher};\n+use std::ops::Range;\n+use std::{ptr, str};\n+\n+use super::{\n+    Destructor, FieldDef, GenericPredicates, ReprOptions, Ty, TyCtxt, VariantDef, VariantDiscr,\n+};\n+\n+#[derive(Clone, HashStable, Debug)]\n+pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n+\n+bitflags! {\n+    #[derive(HashStable)]\n+    pub struct AdtFlags: u32 {\n+        const NO_ADT_FLAGS        = 0;\n+        /// Indicates whether the ADT is an enum.\n+        const IS_ENUM             = 1 << 0;\n+        /// Indicates whether the ADT is a union.\n+        const IS_UNION            = 1 << 1;\n+        /// Indicates whether the ADT is a struct.\n+        const IS_STRUCT           = 1 << 2;\n+        /// Indicates whether the ADT is a struct and has a constructor.\n+        const HAS_CTOR            = 1 << 3;\n+        /// Indicates whether the type is `PhantomData`.\n+        const IS_PHANTOM_DATA     = 1 << 4;\n+        /// Indicates whether the type has a `#[fundamental]` attribute.\n+        const IS_FUNDAMENTAL      = 1 << 5;\n+        /// Indicates whether the type is `Box`.\n+        const IS_BOX              = 1 << 6;\n+        /// Indicates whether the type is `ManuallyDrop`.\n+        const IS_MANUALLY_DROP    = 1 << 7;\n+        /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n+        /// (i.e., this flag is never set unless this ADT is an enum).\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 8;\n+    }\n+}\n+\n+/// The definition of a user-defined type, e.g., a `struct`, `enum`, or `union`.\n+///\n+/// These are all interned (by `alloc_adt_def`) into the global arena.\n+///\n+/// The initialism *ADT* stands for an [*algebraic data type (ADT)*][adt].\n+/// This is slightly wrong because `union`s are not ADTs.\n+/// Moreover, Rust only allows recursive data types through indirection.\n+///\n+/// [adt]: https://en.wikipedia.org/wiki/Algebraic_data_type\n+pub struct AdtDef {\n+    /// The `DefId` of the struct, enum or union item.\n+    pub did: DefId,\n+    /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n+    pub variants: IndexVec<VariantIdx, VariantDef>,\n+    /// Flags of the ADT (e.g., is this a struct? is this non-exhaustive?).\n+    flags: AdtFlags,\n+    /// Repr options provided by the user.\n+    pub repr: ReprOptions,\n+}\n+\n+impl PartialOrd for AdtDef {\n+    fn partial_cmp(&self, other: &AdtDef) -> Option<Ordering> {\n+        Some(self.cmp(&other))\n+    }\n+}\n+\n+/// There should be only one AdtDef for each `did`, therefore\n+/// it is fine to implement `Ord` only based on `did`.\n+impl Ord for AdtDef {\n+    fn cmp(&self, other: &AdtDef) -> Ordering {\n+        self.did.cmp(&other.did)\n+    }\n+}\n+\n+impl PartialEq for AdtDef {\n+    // `AdtDef`s are always interned, and this is part of `TyS` equality.\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        ptr::eq(self, other)\n+    }\n+}\n+\n+impl Eq for AdtDef {}\n+\n+impl Hash for AdtDef {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const AdtDef).hash(s)\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for AdtDef {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.did.encode(s)\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        thread_local! {\n+            static CACHE: RefCell<FxHashMap<usize, Fingerprint>> = Default::default();\n+        }\n+\n+        let hash: Fingerprint = CACHE.with(|cache| {\n+            let addr = self as *const AdtDef as usize;\n+            *cache.borrow_mut().entry(addr).or_insert_with(|| {\n+                let ty::AdtDef { did, ref variants, ref flags, ref repr } = *self;\n+\n+                let mut hasher = StableHasher::new();\n+                did.hash_stable(hcx, &mut hasher);\n+                variants.hash_stable(hcx, &mut hasher);\n+                flags.hash_stable(hcx, &mut hasher);\n+                repr.hash_stable(hcx, &mut hasher);\n+\n+                hasher.finish()\n+            })\n+        });\n+\n+        hash.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub enum AdtKind {\n+    Struct,\n+    Union,\n+    Enum,\n+}\n+\n+impl Into<DataTypeKind> for AdtKind {\n+    fn into(self) -> DataTypeKind {\n+        match self {\n+            AdtKind::Struct => DataTypeKind::Struct,\n+            AdtKind::Union => DataTypeKind::Union,\n+            AdtKind::Enum => DataTypeKind::Enum,\n+        }\n+    }\n+}\n+\n+impl<'tcx> AdtDef {\n+    /// Creates a new `AdtDef`.\n+    pub(super) fn new(\n+        tcx: TyCtxt<'_>,\n+        did: DefId,\n+        kind: AdtKind,\n+        variants: IndexVec<VariantIdx, VariantDef>,\n+        repr: ReprOptions,\n+    ) -> Self {\n+        debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n+        let mut flags = AdtFlags::NO_ADT_FLAGS;\n+\n+        if kind == AdtKind::Enum && tcx.has_attr(did, sym::non_exhaustive) {\n+            debug!(\"found non-exhaustive variant list for {:?}\", did);\n+            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n+        }\n+\n+        flags |= match kind {\n+            AdtKind::Enum => AdtFlags::IS_ENUM,\n+            AdtKind::Union => AdtFlags::IS_UNION,\n+            AdtKind::Struct => AdtFlags::IS_STRUCT,\n+        };\n+\n+        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_def_id.is_some() {\n+            flags |= AdtFlags::HAS_CTOR;\n+        }\n+\n+        let attrs = tcx.get_attrs(did);\n+        if tcx.sess.contains_name(&attrs, sym::fundamental) {\n+            flags |= AdtFlags::IS_FUNDAMENTAL;\n+        }\n+        if Some(did) == tcx.lang_items().phantom_data() {\n+            flags |= AdtFlags::IS_PHANTOM_DATA;\n+        }\n+        if Some(did) == tcx.lang_items().owned_box() {\n+            flags |= AdtFlags::IS_BOX;\n+        }\n+        if Some(did) == tcx.lang_items().manually_drop() {\n+            flags |= AdtFlags::IS_MANUALLY_DROP;\n+        }\n+\n+        AdtDef { did, variants, flags, repr }\n+    }\n+\n+    /// Returns `true` if this is a struct.\n+    #[inline]\n+    pub fn is_struct(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_STRUCT)\n+    }\n+\n+    /// Returns `true` if this is a union.\n+    #[inline]\n+    pub fn is_union(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_UNION)\n+    }\n+\n+    /// Returns `true` if this is a enum.\n+    #[inline]\n+    pub fn is_enum(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_ENUM)\n+    }\n+\n+    /// Returns `true` if the variant list of this ADT is `#[non_exhaustive]`.\n+    #[inline]\n+    pub fn is_variant_list_non_exhaustive(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n+    }\n+\n+    /// Returns the kind of the ADT.\n+    #[inline]\n+    pub fn adt_kind(&self) -> AdtKind {\n+        if self.is_enum() {\n+            AdtKind::Enum\n+        } else if self.is_union() {\n+            AdtKind::Union\n+        } else {\n+            AdtKind::Struct\n+        }\n+    }\n+\n+    /// Returns a description of this abstract data type.\n+    pub fn descr(&self) -> &'static str {\n+        match self.adt_kind() {\n+            AdtKind::Struct => \"struct\",\n+            AdtKind::Union => \"union\",\n+            AdtKind::Enum => \"enum\",\n+        }\n+    }\n+\n+    /// Returns a description of a variant of this abstract data type.\n+    #[inline]\n+    pub fn variant_descr(&self) -> &'static str {\n+        match self.adt_kind() {\n+            AdtKind::Struct => \"struct\",\n+            AdtKind::Union => \"union\",\n+            AdtKind::Enum => \"variant\",\n+        }\n+    }\n+\n+    /// If this function returns `true`, it implies that `is_struct` must return `true`.\n+    #[inline]\n+    pub fn has_ctor(&self) -> bool {\n+        self.flags.contains(AdtFlags::HAS_CTOR)\n+    }\n+\n+    /// Returns `true` if this type is `#[fundamental]` for the purposes\n+    /// of coherence checking.\n+    #[inline]\n+    pub fn is_fundamental(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n+    }\n+\n+    /// Returns `true` if this is `PhantomData<T>`.\n+    #[inline]\n+    pub fn is_phantom_data(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n+    }\n+\n+    /// Returns `true` if this is Box<T>.\n+    #[inline]\n+    pub fn is_box(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_BOX)\n+    }\n+\n+    /// Returns `true` if this is `ManuallyDrop<T>`.\n+    #[inline]\n+    pub fn is_manually_drop(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_MANUALLY_DROP)\n+    }\n+\n+    /// Returns `true` if this type has a destructor.\n+    pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.destructor(tcx).is_some()\n+    }\n+\n+    /// Asserts this is a struct or union and returns its unique variant.\n+    pub fn non_enum_variant(&self) -> &VariantDef {\n+        assert!(self.is_struct() || self.is_union());\n+        &self.variants[VariantIdx::new(0)]\n+    }\n+\n+    #[inline]\n+    pub fn predicates(&self, tcx: TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n+        tcx.predicates_of(self.did)\n+    }\n+\n+    /// Returns an iterator over all fields contained\n+    /// by this ADT.\n+    #[inline]\n+    pub fn all_fields(&self) -> impl Iterator<Item = &FieldDef> + Clone {\n+        self.variants.iter().flat_map(|v| v.fields.iter())\n+    }\n+\n+    /// Whether the ADT lacks fields. Note that this includes uninhabited enums,\n+    /// e.g., `enum Void {}` is considered payload free as well.\n+    pub fn is_payloadfree(&self) -> bool {\n+        self.variants.iter().all(|v| v.fields.is_empty())\n+    }\n+\n+    /// Return a `VariantDef` given a variant id.\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n+        self.variants.iter().find(|v| v.def_id == vid).expect(\"variant_with_id: unknown variant\")\n+    }\n+\n+    /// Return a `VariantDef` given a constructor id.\n+    pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n+        self.variants\n+            .iter()\n+            .find(|v| v.ctor_def_id == Some(cid))\n+            .expect(\"variant_with_ctor_id: unknown variant\")\n+    }\n+\n+    /// Return the index of `VariantDef` given a variant id.\n+    pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n+        self.variants\n+            .iter_enumerated()\n+            .find(|(_, v)| v.def_id == vid)\n+            .expect(\"variant_index_with_id: unknown variant\")\n+            .0\n+    }\n+\n+    /// Return the index of `VariantDef` given a constructor id.\n+    pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n+        self.variants\n+            .iter_enumerated()\n+            .find(|(_, v)| v.ctor_def_id == Some(cid))\n+            .expect(\"variant_index_with_ctor_id: unknown variant\")\n+            .0\n+    }\n+\n+    pub fn variant_of_res(&self, res: Res) -> &VariantDef {\n+        match res {\n+            Res::Def(DefKind::Variant, vid) => self.variant_with_id(vid),\n+            Res::Def(DefKind::Ctor(..), cid) => self.variant_with_ctor_id(cid),\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::TyAlias, _)\n+            | Res::Def(DefKind::AssocTy, _)\n+            | Res::SelfTy(..)\n+            | Res::SelfCtor(..) => self.non_enum_variant(),\n+            _ => bug!(\"unexpected res {:?} in variant_of_res\", res),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n+        assert!(self.is_enum());\n+        let param_env = tcx.param_env(expr_did);\n+        let repr_type = self.repr.discr_type();\n+        match tcx.const_eval_poly(expr_did) {\n+            Ok(val) => {\n+                let ty = repr_type.to_ty(tcx);\n+                if let Some(b) = val.try_to_bits_for_ty(tcx, param_env, ty) {\n+                    trace!(\"discriminants: {} ({:?})\", b, repr_type);\n+                    Some(Discr { val: b, ty })\n+                } else {\n+                    info!(\"invalid enum discriminant: {:#?}\", val);\n+                    crate::mir::interpret::struct_error(\n+                        tcx.at(tcx.def_span(expr_did)),\n+                        \"constant evaluation of enum discriminant resulted in non-integer\",\n+                    )\n+                    .emit();\n+                    None\n+                }\n+            }\n+            Err(err) => {\n+                let msg = match err {\n+                    ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n+                        \"enum discriminant evaluation failed\"\n+                    }\n+                    ErrorHandled::TooGeneric => \"enum discriminant depends on generics\",\n+                };\n+                tcx.sess.delay_span_bug(tcx.def_span(expr_did), msg);\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn discriminants(\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n+        assert!(self.is_enum());\n+        let repr_type = self.repr.discr_type();\n+        let initial = repr_type.initial_discriminant(tcx);\n+        let mut prev_discr = None::<Discr<'tcx>>;\n+        self.variants.iter_enumerated().map(move |(i, v)| {\n+            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n+            if let VariantDiscr::Explicit(expr_did) = v.discr {\n+                if let Some(new_discr) = self.eval_explicit_discr(tcx, expr_did) {\n+                    discr = new_discr;\n+                }\n+            }\n+            prev_discr = Some(discr);\n+\n+            (i, discr)\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn variant_range(&self) -> Range<VariantIdx> {\n+        VariantIdx::new(0)..VariantIdx::new(self.variants.len())\n+    }\n+\n+    /// Computes the discriminant value used by a specific variant.\n+    /// Unlike `discriminants`, this is (amortized) constant-time,\n+    /// only doing at most one query for evaluating an explicit\n+    /// discriminant (the last one before the requested variant),\n+    /// assuming there are no constant-evaluation errors there.\n+    #[inline]\n+    pub fn discriminant_for_variant(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Discr<'tcx> {\n+        assert!(self.is_enum());\n+        let (val, offset) = self.discriminant_def_for_variant(variant_index);\n+        let explicit_value = val\n+            .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n+            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx));\n+        explicit_value.checked_add(tcx, offset as u128).0\n+    }\n+\n+    /// Yields a `DefId` for the discriminant and an offset to add to it\n+    /// Alternatively, if there is no explicit discriminant, returns the\n+    /// inferred discriminant directly.\n+    pub fn discriminant_def_for_variant(&self, variant_index: VariantIdx) -> (Option<DefId>, u32) {\n+        assert!(!self.variants.is_empty());\n+        let mut explicit_index = variant_index.as_u32();\n+        let expr_did;\n+        loop {\n+            match self.variants[VariantIdx::from_u32(explicit_index)].discr {\n+                ty::VariantDiscr::Relative(0) => {\n+                    expr_did = None;\n+                    break;\n+                }\n+                ty::VariantDiscr::Relative(distance) => {\n+                    explicit_index -= distance;\n+                }\n+                ty::VariantDiscr::Explicit(did) => {\n+                    expr_did = Some(did);\n+                    break;\n+                }\n+            }\n+        }\n+        (expr_did, variant_index.as_u32() - explicit_index)\n+    }\n+\n+    pub fn destructor(&self, tcx: TyCtxt<'tcx>) -> Option<Destructor> {\n+        tcx.adt_destructor(self.did)\n+    }\n+\n+    /// Returns a list of types such that `Self: Sized` if and only\n+    /// if that type is `Sized`, or `TyErr` if this type is recursive.\n+    ///\n+    /// Oddly enough, checking that the sized-constraint is `Sized` is\n+    /// actually more expressive than checking all members:\n+    /// the `Sized` trait is inductive, so an associated type that references\n+    /// `Self` would prevent its containing ADT from being `Sized`.\n+    ///\n+    /// Due to normalization being eager, this applies even if\n+    /// the associated type is behind a pointer (e.g., issue #31299).\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n+        tcx.adt_sized_constraint(self.did).0\n+    }\n+}"}, {"sha": "d3770fa416b53e0d51fd2dc7b171a2407aaf0e57", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=b3ac52646f7591a811fa9bf55995b24fd17ece08", "patch": "@@ -0,0 +1,170 @@\n+pub use self::AssocItemContainer::*;\n+\n+use crate::ty;\n+use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Namespace};\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+use super::{TyCtxt, Visibility};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable, Hash)]\n+pub enum AssocItemContainer {\n+    TraitContainer(DefId),\n+    ImplContainer(DefId),\n+}\n+\n+impl AssocItemContainer {\n+    /// Asserts that this is the `DefId` of an associated item declared\n+    /// in a trait, and returns the trait `DefId`.\n+    pub fn assert_trait(&self) -> DefId {\n+        match *self {\n+            TraitContainer(id) => id,\n+            _ => bug!(\"associated item has wrong container type: {:?}\", self),\n+        }\n+    }\n+\n+    pub fn id(&self) -> DefId {\n+        match *self {\n+            TraitContainer(id) => id,\n+            ImplContainer(id) => id,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable, Eq, Hash)]\n+pub struct AssocItem {\n+    pub def_id: DefId,\n+    #[stable_hasher(project(name))]\n+    pub ident: Ident,\n+    pub kind: AssocKind,\n+    pub vis: Visibility,\n+    pub defaultness: hir::Defaultness,\n+    pub container: AssocItemContainer,\n+\n+    /// Whether this is a method with an explicit self\n+    /// as its first parameter, allowing method calls.\n+    pub fn_has_self_parameter: bool,\n+}\n+\n+impl AssocItem {\n+    pub fn signature(&self, tcx: TyCtxt<'_>) -> String {\n+        match self.kind {\n+            ty::AssocKind::Fn => {\n+                // We skip the binder here because the binder would deanonymize all\n+                // late-bound regions, and we don't want method signatures to show up\n+                // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n+                // regions just fine, showing `fn(&MyType)`.\n+                tcx.fn_sig(self.def_id).skip_binder().to_string()\n+            }\n+            ty::AssocKind::Type => format!(\"type {};\", self.ident),\n+            ty::AssocKind::Const => {\n+                format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable, Eq, Hash)]\n+pub enum AssocKind {\n+    Const,\n+    Fn,\n+    Type,\n+}\n+\n+impl AssocKind {\n+    pub fn namespace(&self) -> Namespace {\n+        match *self {\n+            ty::AssocKind::Type => Namespace::TypeNS,\n+            ty::AssocKind::Const | ty::AssocKind::Fn => Namespace::ValueNS,\n+        }\n+    }\n+\n+    pub fn as_def_kind(&self) -> DefKind {\n+        match self {\n+            AssocKind::Const => DefKind::AssocConst,\n+            AssocKind::Fn => DefKind::AssocFn,\n+            AssocKind::Type => DefKind::AssocTy,\n+        }\n+    }\n+}\n+\n+/// A list of `ty::AssocItem`s in definition order that allows for efficient lookup by name.\n+///\n+/// When doing lookup by name, we try to postpone hygienic comparison for as long as possible since\n+/// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n+/// done only on items with the same name.\n+#[derive(Debug, Clone, PartialEq, HashStable)]\n+pub struct AssociatedItems<'tcx> {\n+    pub(super) items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n+}\n+\n+impl<'tcx> AssociatedItems<'tcx> {\n+    /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n+    pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n+        let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n+        AssociatedItems { items }\n+    }\n+\n+    /// Returns a slice of associated items in the order they were defined.\n+    ///\n+    /// New code should avoid relying on definition order. If you need a particular associated item\n+    /// for a known trait, make that trait a lang item instead of indexing this array.\n+    pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.iter().map(|(_, v)| *v)\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.items.len()\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name, ignoring hygiene.\n+    pub fn filter_by_name_unhygienic(\n+        &self,\n+        name: Symbol,\n+    ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.get_by_key(&name).copied()\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name.\n+    ///\n+    /// Multiple items may have the same name if they are in different `Namespace`s. For example,\n+    /// an associated type can have the same name as a method. Use one of the `find_by_name_and_*`\n+    /// methods below if you know which item you are looking for.\n+    pub fn filter_by_name(\n+        &'a self,\n+        tcx: TyCtxt<'a>,\n+        ident: Ident,\n+        parent_def_id: DefId,\n+    ) -> impl 'a + Iterator<Item = &'a ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(move |item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name and `AssocKind`, if one exists.\n+    pub fn find_by_name_and_kind(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        kind: AssocKind,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind == kind)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n+    pub fn find_by_name_and_namespace(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind.namespace() == ns)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+}"}, {"sha": "76ac6c4e08e910f588c4841824946f5f6cbd3450", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=b3ac52646f7591a811fa9bf55995b24fd17ece08", "patch": "@@ -0,0 +1,338 @@\n+use crate::hir::place::{\n+    Place as HirPlace, PlaceBase as HirPlaceBase, ProjectionKind as HirProjectionKind,\n+};\n+use crate::ty;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::lang_items::LangItem;\n+use rustc_span::Span;\n+\n+use super::{Ty, TyCtxt};\n+\n+use self::BorrowKind::*;\n+\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    HashStable\n+)]\n+pub struct UpvarPath {\n+    pub hir_id: hir::HirId,\n+}\n+\n+/// Upvars do not get their own `NodeId`. Instead, we use the pair of\n+/// the original var ID (that is, the root variable that is referenced\n+/// by the upvar) and the ID of the closure expression.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub struct UpvarId {\n+    pub var_path: UpvarPath,\n+    pub closure_expr_id: LocalDefId,\n+}\n+\n+impl UpvarId {\n+    pub fn new(var_hir_id: hir::HirId, closure_def_id: LocalDefId) -> UpvarId {\n+        UpvarId { var_path: UpvarPath { hir_id: var_hir_id }, closure_expr_id: closure_def_id }\n+    }\n+}\n+\n+/// Information describing the capture of an upvar. This is computed\n+/// during `typeck`, specifically by `regionck`.\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub enum UpvarCapture<'tcx> {\n+    /// Upvar is captured by value. This is always true when the\n+    /// closure is labeled `move`, but can also be true in other cases\n+    /// depending on inference.\n+    ///\n+    /// If the upvar was inferred to be captured by value (e.g. `move`\n+    /// was not used), then the `Span` points to a usage that\n+    /// required it. There may be more than one such usage\n+    /// (e.g. `|| { a; a; }`), in which case we pick an\n+    /// arbitrary one.\n+    ByValue(Option<Span>),\n+\n+    /// Upvar is captured by reference.\n+    ByRef(UpvarBorrow<'tcx>),\n+}\n+\n+#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub struct UpvarBorrow<'tcx> {\n+    /// The kind of borrow: by-ref upvars have access to shared\n+    /// immutable borrows, which are not part of the normal language\n+    /// syntax.\n+    pub kind: BorrowKind,\n+\n+    /// Region of the resulting reference.\n+    pub region: ty::Region<'tcx>,\n+}\n+\n+pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n+pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n+\n+/// Given the closure DefId this map provides a map of root variables to minimum\n+/// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n+pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n+\n+/// Part of `MinCaptureInformationMap`; Maps a root variable to the list of `CapturedPlace`.\n+/// Used to track the minimum set of `Place`s that need to be captured to support all\n+/// Places captured by the closure starting at a given root variable.\n+///\n+/// This provides a convenient and quick way of checking if a variable being used within\n+/// a closure is a capture of a local variable.\n+pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureList<'tcx>>;\n+\n+/// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n+pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n+\n+/// Represents the various closure traits in the language. This\n+/// will determine the type of the environment (`self`, in the\n+/// desugaring) argument that the closure expects.\n+///\n+/// You can get the environment type of a closure using\n+/// `tcx.closure_env_ty()`.\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n+#[derive(HashStable)]\n+pub enum ClosureKind {\n+    // Warning: Ordering is significant here! The ordering is chosen\n+    // because the trait Fn is a subtrait of FnMut and so in turn, and\n+    // hence we order it so that Fn < FnMut < FnOnce.\n+    Fn,\n+    FnMut,\n+    FnOnce,\n+}\n+\n+impl<'tcx> ClosureKind {\n+    // This is the initial value used when doing upvar inference.\n+    pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n+\n+    pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+        match *self {\n+            ClosureKind::Fn => tcx.require_lang_item(LangItem::Fn, None),\n+            ClosureKind::FnMut => tcx.require_lang_item(LangItem::FnMut, None),\n+            ClosureKind::FnOnce => tcx.require_lang_item(LangItem::FnOnce, None),\n+        }\n+    }\n+\n+    /// Returns `true` if a type that impls this closure kind\n+    /// must also implement `other`.\n+    pub fn extends(self, other: ty::ClosureKind) -> bool {\n+        matches!(\n+            (self, other),\n+            (ClosureKind::Fn, ClosureKind::Fn)\n+                | (ClosureKind::Fn, ClosureKind::FnMut)\n+                | (ClosureKind::Fn, ClosureKind::FnOnce)\n+                | (ClosureKind::FnMut, ClosureKind::FnMut)\n+                | (ClosureKind::FnMut, ClosureKind::FnOnce)\n+                | (ClosureKind::FnOnce, ClosureKind::FnOnce)\n+        )\n+    }\n+\n+    /// Returns the representative scalar type for this closure kind.\n+    /// See `TyS::to_opt_closure_kind` for more details.\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match self {\n+            ty::ClosureKind::Fn => tcx.types.i8,\n+            ty::ClosureKind::FnMut => tcx.types.i16,\n+            ty::ClosureKind::FnOnce => tcx.types.i32,\n+        }\n+    }\n+}\n+\n+/// A composite describing a `Place` that is captured by a closure.\n+#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub struct CapturedPlace<'tcx> {\n+    /// The `Place` that is captured.\n+    pub place: HirPlace<'tcx>,\n+\n+    /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n+    pub info: CaptureInfo<'tcx>,\n+\n+    /// Represents if `place` can be mutated or not.\n+    pub mutability: hir::Mutability,\n+}\n+\n+impl CapturedPlace<'tcx> {\n+    /// Returns the hir-id of the root variable for the captured place.\n+    /// e.g., if `a.b.c` was captured, would return the hir-id for `a`.\n+    pub fn get_root_variable(&self) -> hir::HirId {\n+        match self.place.base {\n+            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            base => bug!(\"Expected upvar, found={:?}\", base),\n+        }\n+    }\n+}\n+\n+/// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n+/// for a particular capture as well as identifying the part of the source code\n+/// that triggered this capture to occur.\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub struct CaptureInfo<'tcx> {\n+    /// Expr Id pointing to use that resulted in selecting the current capture kind\n+    ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// let mut t = (0,1);\n+    ///\n+    /// let c = || {\n+    ///     println!(\"{}\",t); // L1\n+    ///     t.1 = 4; // L2\n+    /// };\n+    /// ```\n+    /// `capture_kind_expr_id` will point to the use on L2 and `path_expr_id` will point to the\n+    /// use on L1.\n+    ///\n+    /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n+    /// possible that we don't see the use of a particular place resulting in capture_kind_expr_id being\n+    /// None. In such case we fallback on uvpars_mentioned for span.\n+    ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// let x = 5;\n+    ///\n+    /// let c = || {\n+    ///     let _ = x\n+    /// };\n+    /// ```\n+    ///\n+    /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n+    /// but we won't see it being used during capture analysis, since it's essentially a discard.\n+    pub capture_kind_expr_id: Option<hir::HirId>,\n+    /// Expr Id pointing to use that resulted the corresponding place being captured\n+    ///\n+    /// See `capture_kind_expr_id` for example.\n+    ///\n+    pub path_expr_id: Option<hir::HirId>,\n+\n+    /// Capture mode that was selected\n+    pub capture_kind: UpvarCapture<'tcx>,\n+}\n+\n+pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {\n+    let name = match place.base {\n+        HirPlaceBase::Upvar(upvar_id) => tcx.hir().name(upvar_id.var_path.hir_id).to_string(),\n+        _ => bug!(\"Capture_information should only contain upvars\"),\n+    };\n+    let mut curr_string = name;\n+\n+    for (i, proj) in place.projections.iter().enumerate() {\n+        match proj.kind {\n+            HirProjectionKind::Deref => {\n+                curr_string = format!(\"*{}\", curr_string);\n+            }\n+            HirProjectionKind::Field(idx, variant) => match place.ty_before_projection(i).kind() {\n+                ty::Adt(def, ..) => {\n+                    curr_string = format!(\n+                        \"{}.{}\",\n+                        curr_string,\n+                        def.variants[variant].fields[idx as usize].ident.name.as_str()\n+                    );\n+                }\n+                ty::Tuple(_) => {\n+                    curr_string = format!(\"{}.{}\", curr_string, idx);\n+                }\n+                _ => {\n+                    bug!(\n+                        \"Field projection applied to a type other than Adt or Tuple: {:?}.\",\n+                        place.ty_before_projection(i).kind()\n+                    )\n+                }\n+            },\n+            proj => bug!(\"{:?} unexpected because it isn't captured\", proj),\n+        }\n+    }\n+\n+    curr_string.to_string()\n+}\n+\n+#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, TypeFoldable, Copy, HashStable)]\n+pub enum BorrowKind {\n+    /// Data must be immutable and is aliasable.\n+    ImmBorrow,\n+\n+    /// Data must be immutable but not aliasable. This kind of borrow\n+    /// cannot currently be expressed by the user and is used only in\n+    /// implicit closure bindings. It is needed when the closure\n+    /// is borrowing or mutating a mutable referent, e.g.:\n+    ///\n+    /// ```\n+    /// let x: &mut isize = ...;\n+    /// let y = || *x += 5;\n+    /// ```\n+    ///\n+    /// If we were to try to translate this closure into a more explicit\n+    /// form, we'd encounter an error with the code as written:\n+    ///\n+    /// ```\n+    /// struct Env { x: & &mut isize }\n+    /// let x: &mut isize = ...;\n+    /// let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    ///\n+    /// This is then illegal because you cannot mutate a `&mut` found\n+    /// in an aliasable location. To solve, you'd have to translate with\n+    /// an `&mut` borrow:\n+    ///\n+    /// ```\n+    /// struct Env { x: & &mut isize }\n+    /// let x: &mut isize = ...;\n+    /// let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    ///\n+    /// Now the assignment to `**env.x` is legal, but creating a\n+    /// mutable pointer to `x` is not because `x` is not mutable. We\n+    /// could fix this by declaring `x` as `let mut x`. This is ok in\n+    /// user code, if awkward, but extra weird for closures, since the\n+    /// borrow is hidden.\n+    ///\n+    /// So we introduce a \"unique imm\" borrow -- the referent is\n+    /// immutable, but not aliasable. This solves the problem. For\n+    /// simplicity, we don't give users the way to express this\n+    /// borrow, it's just used when translating closures.\n+    UniqueImmBorrow,\n+\n+    /// Data is mutable and not aliasable.\n+    MutBorrow,\n+}\n+\n+impl BorrowKind {\n+    pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n+        match m {\n+            hir::Mutability::Mut => MutBorrow,\n+            hir::Mutability::Not => ImmBorrow,\n+        }\n+    }\n+\n+    /// Returns a mutability `m` such that an `&m T` pointer could be used to obtain this borrow\n+    /// kind. Because borrow kinds are richer than mutabilities, we sometimes have to pick a\n+    /// mutability that is stronger than necessary so that it at least *would permit* the borrow in\n+    /// question.\n+    pub fn to_mutbl_lossy(self) -> hir::Mutability {\n+        match self {\n+            MutBorrow => hir::Mutability::Mut,\n+            ImmBorrow => hir::Mutability::Not,\n+\n+            // We have no type corresponding to a unique imm borrow, so\n+            // use `&mut`. It gives all the capabilities of an `&uniq`\n+            // and hence is a safe \"over approximation\".\n+            UniqueImmBorrow => hir::Mutability::Mut,\n+        }\n+    }\n+\n+    pub fn to_user_str(&self) -> &'static str {\n+        match *self {\n+            MutBorrow => \"mutable\",\n+            ImmBorrow => \"immutable\",\n+            UniqueImmBorrow => \"uniquely immutable\",\n+        }\n+    }\n+}"}, {"sha": "79cd26f5668a13936cde730374aa78a7dbede1ae", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=b3ac52646f7591a811fa9bf55995b24fd17ece08", "patch": "@@ -0,0 +1,257 @@\n+use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use crate::ty;\n+use crate::ty::subst::{Subst, SubstsRef};\n+use rustc_ast as ast;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+\n+use super::{EarlyBoundRegion, InstantiatedPredicates, ParamConst, ParamTy, Predicate, TyCtxt};\n+\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub enum GenericParamDefKind {\n+    Lifetime,\n+    Type {\n+        has_default: bool,\n+        object_lifetime_default: ObjectLifetimeDefault,\n+        synthetic: Option<hir::SyntheticTyParamKind>,\n+    },\n+    Const,\n+}\n+\n+impl GenericParamDefKind {\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            GenericParamDefKind::Lifetime => \"lifetime\",\n+            GenericParamDefKind::Type { .. } => \"type\",\n+            GenericParamDefKind::Const => \"constant\",\n+        }\n+    }\n+    pub fn to_ord(&self, tcx: TyCtxt<'_>) -> ast::ParamKindOrd {\n+        match self {\n+            GenericParamDefKind::Lifetime => ast::ParamKindOrd::Lifetime,\n+            GenericParamDefKind::Type { .. } => ast::ParamKindOrd::Type,\n+            GenericParamDefKind::Const => {\n+                ast::ParamKindOrd::Const { unordered: tcx.features().const_generics }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct GenericParamDef {\n+    pub name: Symbol,\n+    pub def_id: DefId,\n+    pub index: u32,\n+\n+    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n+    /// on generic parameter `'a`/`T`, asserts data behind the parameter\n+    /// `'a`/`T` won't be accessed during the parent type's `Drop` impl.\n+    pub pure_wrt_drop: bool,\n+\n+    pub kind: GenericParamDefKind,\n+}\n+\n+impl GenericParamDef {\n+    pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n+        if let GenericParamDefKind::Lifetime = self.kind {\n+            ty::EarlyBoundRegion { def_id: self.def_id, index: self.index, name: self.name }\n+        } else {\n+            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct GenericParamCount {\n+    pub lifetimes: usize,\n+    pub types: usize,\n+    pub consts: usize,\n+}\n+\n+/// Information about the formal type/lifetime parameters associated\n+/// with an item or method. Analogous to `hir::Generics`.\n+///\n+/// The ordering of parameters is the same as in `Subst` (excluding child generics):\n+/// `Self` (optionally), `Lifetime` params..., `Type` params...\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct Generics {\n+    pub parent: Option<DefId>,\n+    pub parent_count: usize,\n+    pub params: Vec<GenericParamDef>,\n+\n+    /// Reverse map to the `index` field of each `GenericParamDef`.\n+    #[stable_hasher(ignore)]\n+    pub param_def_id_to_index: FxHashMap<DefId, u32>,\n+\n+    pub has_self: bool,\n+    pub has_late_bound_regions: Option<Span>,\n+}\n+\n+impl<'tcx> Generics {\n+    pub fn count(&self) -> usize {\n+        self.parent_count + self.params.len()\n+    }\n+\n+    pub fn own_counts(&self) -> GenericParamCount {\n+        // We could cache this as a property of `GenericParamCount`, but\n+        // the aim is to refactor this away entirely eventually and the\n+        // presence of this method will be a constant reminder.\n+        let mut own_counts = GenericParamCount::default();\n+\n+        for param in &self.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n+                GenericParamDefKind::Type { .. } => own_counts.types += 1,\n+                GenericParamDefKind::Const => own_counts.consts += 1,\n+            }\n+        }\n+\n+        own_counts\n+    }\n+\n+    pub fn own_defaults(&self) -> GenericParamCount {\n+        let mut own_defaults = GenericParamCount::default();\n+\n+        for param in &self.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => (),\n+                GenericParamDefKind::Type { has_default, .. } => {\n+                    own_defaults.types += has_default as usize;\n+                }\n+                GenericParamDefKind::Const => {\n+                    // FIXME(const_generics:defaults)\n+                }\n+            }\n+        }\n+\n+        own_defaults\n+    }\n+\n+    pub fn requires_monomorphization(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        if self.own_requires_monomorphization() {\n+            return true;\n+        }\n+\n+        if let Some(parent_def_id) = self.parent {\n+            let parent = tcx.generics_of(parent_def_id);\n+            parent.requires_monomorphization(tcx)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn own_requires_monomorphization(&self) -> bool {\n+        for param in &self.params {\n+            match param.kind {\n+                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => return true,\n+                GenericParamDefKind::Lifetime => {}\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Returns the `GenericParamDef` with the given index.\n+    pub fn param_at(&'tcx self, param_index: usize, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n+        if let Some(index) = param_index.checked_sub(self.parent_count) {\n+            &self.params[index]\n+        } else {\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n+                .param_at(param_index, tcx)\n+        }\n+    }\n+\n+    /// Returns the `GenericParamDef` associated with this `EarlyBoundRegion`.\n+    pub fn region_param(\n+        &'tcx self,\n+        param: &EarlyBoundRegion,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> &'tcx GenericParamDef {\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => param,\n+            _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n+        }\n+    }\n+\n+    /// Returns the `GenericParamDef` associated with this `ParamTy`.\n+    pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Type { .. } => param,\n+            _ => bug!(\"expected type parameter, but found another generic parameter\"),\n+        }\n+    }\n+\n+    /// Returns the `GenericParamDef` associated with this `ParamConst`.\n+    pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Const => param,\n+            _ => bug!(\"expected const parameter, but found another generic parameter\"),\n+        }\n+    }\n+}\n+\n+/// Bounds on generics.\n+#[derive(Copy, Clone, Default, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct GenericPredicates<'tcx> {\n+    pub parent: Option<DefId>,\n+    pub predicates: &'tcx [(Predicate<'tcx>, Span)],\n+}\n+\n+impl<'tcx> GenericPredicates<'tcx> {\n+    pub fn instantiate(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n+        let mut instantiated = InstantiatedPredicates::empty();\n+        self.instantiate_into(tcx, &mut instantiated, substs);\n+        instantiated\n+    }\n+\n+    pub fn instantiate_own(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n+        InstantiatedPredicates {\n+            predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n+            spans: self.predicates.iter().map(|(_, sp)| *sp).collect(),\n+        }\n+    }\n+\n+    fn instantiate_into(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        instantiated: &mut InstantiatedPredicates<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) {\n+        if let Some(def_id) = self.parent {\n+            tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n+        }\n+        instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)));\n+        instantiated.spans.extend(self.predicates.iter().map(|(_, sp)| *sp));\n+    }\n+\n+    pub fn instantiate_identity(&self, tcx: TyCtxt<'tcx>) -> InstantiatedPredicates<'tcx> {\n+        let mut instantiated = InstantiatedPredicates::empty();\n+        self.instantiate_identity_into(tcx, &mut instantiated);\n+        instantiated\n+    }\n+\n+    fn instantiate_identity_into(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        instantiated: &mut InstantiatedPredicates<'tcx>,\n+    ) {\n+        if let Some(def_id) = self.parent {\n+            tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n+        }\n+        instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p));\n+        instantiated.spans.extend(self.predicates.iter().map(|(_, s)| s));\n+    }\n+}"}, {"sha": "f5aef108927dbfb49d3a8ac256e6919217fdbd0f", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 32, "deletions": 1240, "changes": 1272, "blob_url": "https://github.com/rust-lang/rust/blob/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ac52646f7591a811fa9bf55995b24fd17ece08/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b3ac52646f7591a811fa9bf55995b24fd17ece08", "patch": "@@ -9,105 +9,78 @@\n //!\n //! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n \n-// ignore-tidy-filelength\n pub use self::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n+pub use adt::*;\n+pub use assoc::*;\n+pub use closure::*;\n+pub use generics::*;\n \n use crate::hir::exports::ExportMap;\n-use crate::hir::place::{\n-    Place as HirPlace, PlaceBase as HirPlaceBase, ProjectionKind as HirProjectionKind,\n-};\n use crate::ich::StableHashingContext;\n use crate::middle::cstore::CrateStoreDyn;\n-use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n-use crate::mir::interpret::ErrorHandled;\n-use crate::mir::Body;\n-use crate::mir::GeneratorLayout;\n+use crate::mir::{Body, GeneratorLayout};\n use crate::traits::{self, Reveal};\n use crate::ty;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n-use crate::ty::util::{Discr, IntTypeExt};\n+use crate::ty::util::Discr;\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::fx::FxIndexMap;\n-use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, par_iter, ParallelIterator};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n-use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Namespace, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Constness, Node};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n-use rustc_serialize::{self, Encodable, Encoder};\n-use rustc_session::DataTypeKind;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n-use rustc_target::abi::{Align, VariantIdx};\n+use rustc_target::abi::Align;\n \n-use std::cell::RefCell;\n use std::cmp::Ordering;\n-use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::ops::{ControlFlow, Range};\n-use std::ptr;\n-use std::str;\n+use std::ops::ControlFlow;\n+use std::{fmt, ptr, str};\n \n-pub use self::sty::BoundRegionKind::*;\n-pub use self::sty::RegionKind;\n-pub use self::sty::RegionKind::*;\n-pub use self::sty::TyKind::*;\n-pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar};\n-pub use self::sty::{BoundRegion, BoundRegionKind, EarlyBoundRegion, FreeRegion, Region};\n-pub use self::sty::{CanonicalPolyFnSig, FnSig, GenSig, PolyFnSig, PolyGenSig};\n-pub use self::sty::{ClosureSubsts, GeneratorSubsts, TypeAndMut, UpvarSubsts};\n-pub use self::sty::{ClosureSubstsParts, GeneratorSubstsParts};\n-pub use self::sty::{ConstVid, RegionVid};\n-pub use self::sty::{ExistentialPredicate, ParamConst, ParamTy, ProjectionTy};\n-pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n-pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n-pub use self::sty::{PolyTraitRef, TraitRef, TyKind};\n pub use crate::ty::diagnostics::*;\n pub use rustc_type_ir::InferTy::*;\n pub use rustc_type_ir::*;\n \n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n-\n-pub use self::context::{tls, FreeRegionInfo, TyCtxt};\n-pub use self::context::{\n-    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-    DelaySpanBugEmitted, ResolvedOpaqueTy, UserType, UserTypeAnnotationIndex,\n-};\n+pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt};\n pub use self::context::{\n-    CtxtInterners, GeneratorInteriorTypeCause, GlobalCtxt, Lift, TypeckResults,\n+    tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+    CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorInteriorTypeCause, GlobalCtxt,\n+    Lift, ResolvedOpaqueTy, TyCtxt, TypeckResults, UserType, UserTypeAnnotationIndex,\n };\n-\n pub use self::instance::{Instance, InstanceDef};\n-\n pub use self::list::List;\n-\n+pub use self::sty::BoundRegionKind::*;\n+pub use self::sty::RegionKind::*;\n+pub use self::sty::TyKind::*;\n+pub use self::sty::{\n+    Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, CanonicalPolyFnSig,\n+    ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBoundRegion, ExistentialPredicate,\n+    ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig, GeneratorSubsts,\n+    GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection, PolyExistentialTraitRef,\n+    PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind, RegionVid, TraitRef,\n+    TyKind, TypeAndMut, UpvarSubsts,\n+};\n pub use self::trait_def::TraitDef;\n \n-pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt};\n-\n pub mod _match;\n pub mod adjustment;\n pub mod binding;\n pub mod cast;\n pub mod codec;\n-mod erase_regions;\n pub mod error;\n pub mod fast_reject;\n pub mod flags;\n@@ -124,9 +97,14 @@ pub mod trait_def;\n pub mod util;\n pub mod walk;\n \n+mod adt;\n+mod assoc;\n+mod closure;\n mod consts;\n mod context;\n mod diagnostics;\n+mod erase_regions;\n+mod generics;\n mod instance;\n mod list;\n mod structural_impls;\n@@ -148,30 +126,6 @@ pub struct ResolverOutputs {\n     pub extern_prelude: FxHashMap<Symbol, bool>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable, Hash)]\n-pub enum AssocItemContainer {\n-    TraitContainer(DefId),\n-    ImplContainer(DefId),\n-}\n-\n-impl AssocItemContainer {\n-    /// Asserts that this is the `DefId` of an associated item declared\n-    /// in a trait, and returns the trait `DefId`.\n-    pub fn assert_trait(&self) -> DefId {\n-        match *self {\n-            TraitContainer(id) => id,\n-            _ => bug!(\"associated item has wrong container type: {:?}\", self),\n-        }\n-    }\n-\n-    pub fn id(&self) -> DefId {\n-        match *self {\n-            TraitContainer(id) => id,\n-            ImplContainer(id) => id,\n-        }\n-    }\n-}\n-\n /// The \"header\" of an impl is everything outside the body: a Self type, a trait\n /// ref (in the case of a trait impl), and a set of predicates (from the\n /// bounds / where-clauses).\n@@ -196,142 +150,6 @@ pub enum ImplPolarity {\n     Reservation,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, HashStable, Eq, Hash)]\n-pub struct AssocItem {\n-    pub def_id: DefId,\n-    #[stable_hasher(project(name))]\n-    pub ident: Ident,\n-    pub kind: AssocKind,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub container: AssocItemContainer,\n-\n-    /// Whether this is a method with an explicit self\n-    /// as its first parameter, allowing method calls.\n-    pub fn_has_self_parameter: bool,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug, HashStable, Eq, Hash)]\n-pub enum AssocKind {\n-    Const,\n-    Fn,\n-    Type,\n-}\n-\n-impl AssocKind {\n-    pub fn namespace(&self) -> Namespace {\n-        match *self {\n-            ty::AssocKind::Type => Namespace::TypeNS,\n-            ty::AssocKind::Const | ty::AssocKind::Fn => Namespace::ValueNS,\n-        }\n-    }\n-\n-    pub fn as_def_kind(&self) -> DefKind {\n-        match self {\n-            AssocKind::Const => DefKind::AssocConst,\n-            AssocKind::Fn => DefKind::AssocFn,\n-            AssocKind::Type => DefKind::AssocTy,\n-        }\n-    }\n-}\n-\n-impl AssocItem {\n-    pub fn signature(&self, tcx: TyCtxt<'_>) -> String {\n-        match self.kind {\n-            ty::AssocKind::Fn => {\n-                // We skip the binder here because the binder would deanonymize all\n-                // late-bound regions, and we don't want method signatures to show up\n-                // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n-                // regions just fine, showing `fn(&MyType)`.\n-                tcx.fn_sig(self.def_id).skip_binder().to_string()\n-            }\n-            ty::AssocKind::Type => format!(\"type {};\", self.ident),\n-            ty::AssocKind::Const => {\n-                format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n-            }\n-        }\n-    }\n-}\n-\n-/// A list of `ty::AssocItem`s in definition order that allows for efficient lookup by name.\n-///\n-/// When doing lookup by name, we try to postpone hygienic comparison for as long as possible since\n-/// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n-/// done only on items with the same name.\n-#[derive(Debug, Clone, PartialEq, HashStable)]\n-pub struct AssociatedItems<'tcx> {\n-    items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n-}\n-\n-impl<'tcx> AssociatedItems<'tcx> {\n-    /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n-    pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n-        let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n-        AssociatedItems { items }\n-    }\n-\n-    /// Returns a slice of associated items in the order they were defined.\n-    ///\n-    /// New code should avoid relying on definition order. If you need a particular associated item\n-    /// for a known trait, make that trait a lang item instead of indexing this array.\n-    pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.iter().map(|(_, v)| *v)\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.items.len()\n-    }\n-\n-    /// Returns an iterator over all associated items with the given name, ignoring hygiene.\n-    pub fn filter_by_name_unhygienic(\n-        &self,\n-        name: Symbol,\n-    ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.get_by_key(&name).copied()\n-    }\n-\n-    /// Returns an iterator over all associated items with the given name.\n-    ///\n-    /// Multiple items may have the same name if they are in different `Namespace`s. For example,\n-    /// an associated type can have the same name as a method. Use one of the `find_by_name_and_*`\n-    /// methods below if you know which item you are looking for.\n-    pub fn filter_by_name(\n-        &'a self,\n-        tcx: TyCtxt<'a>,\n-        ident: Ident,\n-        parent_def_id: DefId,\n-    ) -> impl 'a + Iterator<Item = &'a ty::AssocItem> {\n-        self.filter_by_name_unhygienic(ident.name)\n-            .filter(move |item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n-    }\n-\n-    /// Returns the associated item with the given name and `AssocKind`, if one exists.\n-    pub fn find_by_name_and_kind(\n-        &self,\n-        tcx: TyCtxt<'_>,\n-        ident: Ident,\n-        kind: AssocKind,\n-        parent_def_id: DefId,\n-    ) -> Option<&ty::AssocItem> {\n-        self.filter_by_name_unhygienic(ident.name)\n-            .filter(|item| item.kind == kind)\n-            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n-    }\n-\n-    /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n-    pub fn find_by_name_and_namespace(\n-        &self,\n-        tcx: TyCtxt<'_>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_def_id: DefId,\n-    ) -> Option<&ty::AssocItem> {\n-        self.filter_by_name_unhygienic(ident.name)\n-            .filter(|item| item.kind.namespace() == ns)\n-            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n-    }\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq, Copy, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n@@ -531,243 +349,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-#[derive(\n-    Clone,\n-    Copy,\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    Hash,\n-    TyEncodable,\n-    TyDecodable,\n-    TypeFoldable,\n-    HashStable\n-)]\n-pub struct UpvarPath {\n-    pub hir_id: hir::HirId,\n-}\n-\n-/// Upvars do not get their own `NodeId`. Instead, we use the pair of\n-/// the original var ID (that is, the root variable that is referenced\n-/// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct UpvarId {\n-    pub var_path: UpvarPath,\n-    pub closure_expr_id: LocalDefId,\n-}\n-\n-impl UpvarId {\n-    pub fn new(var_hir_id: hir::HirId, closure_def_id: LocalDefId) -> UpvarId {\n-        UpvarId { var_path: UpvarPath { hir_id: var_hir_id }, closure_expr_id: closure_def_id }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, TypeFoldable, Copy, HashStable)]\n-pub enum BorrowKind {\n-    /// Data must be immutable and is aliasable.\n-    ImmBorrow,\n-\n-    /// Data must be immutable but not aliasable. This kind of borrow\n-    /// cannot currently be expressed by the user and is used only in\n-    /// implicit closure bindings. It is needed when the closure\n-    /// is borrowing or mutating a mutable referent, e.g.:\n-    ///\n-    /// ```\n-    /// let x: &mut isize = ...;\n-    /// let y = || *x += 5;\n-    /// ```\n-    ///\n-    /// If we were to try to translate this closure into a more explicit\n-    /// form, we'd encounter an error with the code as written:\n-    ///\n-    /// ```\n-    /// struct Env { x: & &mut isize }\n-    /// let x: &mut isize = ...;\n-    /// let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n-    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n-    /// ```\n-    ///\n-    /// This is then illegal because you cannot mutate a `&mut` found\n-    /// in an aliasable location. To solve, you'd have to translate with\n-    /// an `&mut` borrow:\n-    ///\n-    /// ```\n-    /// struct Env { x: & &mut isize }\n-    /// let x: &mut isize = ...;\n-    /// let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n-    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n-    /// ```\n-    ///\n-    /// Now the assignment to `**env.x` is legal, but creating a\n-    /// mutable pointer to `x` is not because `x` is not mutable. We\n-    /// could fix this by declaring `x` as `let mut x`. This is ok in\n-    /// user code, if awkward, but extra weird for closures, since the\n-    /// borrow is hidden.\n-    ///\n-    /// So we introduce a \"unique imm\" borrow -- the referent is\n-    /// immutable, but not aliasable. This solves the problem. For\n-    /// simplicity, we don't give users the way to express this\n-    /// borrow, it's just used when translating closures.\n-    UniqueImmBorrow,\n-\n-    /// Data is mutable and not aliasable.\n-    MutBorrow,\n-}\n-\n-/// Information describing the capture of an upvar. This is computed\n-/// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub enum UpvarCapture<'tcx> {\n-    /// Upvar is captured by value. This is always true when the\n-    /// closure is labeled `move`, but can also be true in other cases\n-    /// depending on inference.\n-    ///\n-    /// If the upvar was inferred to be captured by value (e.g. `move`\n-    /// was not used), then the `Span` points to a usage that\n-    /// required it. There may be more than one such usage\n-    /// (e.g. `|| { a; a; }`), in which case we pick an\n-    /// arbitrary one.\n-    ByValue(Option<Span>),\n-\n-    /// Upvar is captured by reference.\n-    ByRef(UpvarBorrow<'tcx>),\n-}\n-\n-#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct UpvarBorrow<'tcx> {\n-    /// The kind of borrow: by-ref upvars have access to shared\n-    /// immutable borrows, which are not part of the normal language\n-    /// syntax.\n-    pub kind: BorrowKind,\n-\n-    /// Region of the resulting reference.\n-    pub region: ty::Region<'tcx>,\n-}\n-\n-/// Given the closure DefId this map provides a map of root variables to minimum\n-/// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n-pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n-\n-/// Part of `MinCaptureInformationMap`; Maps a root variable to the list of `CapturedPlace`.\n-/// Used to track the minimum set of `Place`s that need to be captured to support all\n-/// Places captured by the closure starting at a given root variable.\n-///\n-/// This provides a convenient and quick way of checking if a variable being used within\n-/// a closure is a capture of a local variable.\n-pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureList<'tcx>>;\n-\n-/// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n-pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n-\n-/// A composite describing a `Place` that is captured by a closure.\n-#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct CapturedPlace<'tcx> {\n-    /// The `Place` that is captured.\n-    pub place: HirPlace<'tcx>,\n-\n-    /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n-    pub info: CaptureInfo<'tcx>,\n-\n-    /// Represents if `place` can be mutated or not.\n-    pub mutability: hir::Mutability,\n-}\n-\n-impl CapturedPlace<'tcx> {\n-    /// Returns the hir-id of the root variable for the captured place.\n-    /// e.g., if `a.b.c` was captured, would return the hir-id for `a`.\n-    pub fn get_root_variable(&self) -> hir::HirId {\n-        match self.place.base {\n-            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-            base => bug!(\"Expected upvar, found={:?}\", base),\n-        }\n-    }\n-}\n-\n-pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {\n-    let name = match place.base {\n-        HirPlaceBase::Upvar(upvar_id) => tcx.hir().name(upvar_id.var_path.hir_id).to_string(),\n-        _ => bug!(\"Capture_information should only contain upvars\"),\n-    };\n-    let mut curr_string = name;\n-\n-    for (i, proj) in place.projections.iter().enumerate() {\n-        match proj.kind {\n-            HirProjectionKind::Deref => {\n-                curr_string = format!(\"*{}\", curr_string);\n-            }\n-            HirProjectionKind::Field(idx, variant) => match place.ty_before_projection(i).kind() {\n-                ty::Adt(def, ..) => {\n-                    curr_string = format!(\n-                        \"{}.{}\",\n-                        curr_string,\n-                        def.variants[variant].fields[idx as usize].ident.name.as_str()\n-                    );\n-                }\n-                ty::Tuple(_) => {\n-                    curr_string = format!(\"{}.{}\", curr_string, idx);\n-                }\n-                _ => {\n-                    bug!(\n-                        \"Field projection applied to a type other than Adt or Tuple: {:?}.\",\n-                        place.ty_before_projection(i).kind()\n-                    )\n-                }\n-            },\n-            proj => bug!(\"{:?} unexpected because it isn't captured\", proj),\n-        }\n-    }\n-\n-    curr_string.to_string()\n-}\n-\n-/// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n-/// for a particular capture as well as identifying the part of the source code\n-/// that triggered this capture to occur.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct CaptureInfo<'tcx> {\n-    /// Expr Id pointing to use that resulted in selecting the current capture kind\n-    ///\n-    /// Eg:\n-    /// ```rust,no_run\n-    /// let mut t = (0,1);\n-    ///\n-    /// let c = || {\n-    ///     println!(\"{}\",t); // L1\n-    ///     t.1 = 4; // L2\n-    /// };\n-    /// ```\n-    /// `capture_kind_expr_id` will point to the use on L2 and `path_expr_id` will point to the\n-    /// use on L1.\n-    ///\n-    /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n-    /// possible that we don't see the use of a particular place resulting in capture_kind_expr_id being\n-    /// None. In such case we fallback on uvpars_mentioned for span.\n-    ///\n-    /// Eg:\n-    /// ```rust,no_run\n-    /// let x = 5;\n-    ///\n-    /// let c = || {\n-    ///     let _ = x\n-    /// };\n-    /// ```\n-    ///\n-    /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n-    /// but we won't see it being used during capture analysis, since it's essentially a discard.\n-    pub capture_kind_expr_id: Option<hir::HirId>,\n-    /// Expr Id pointing to use that resulted the corresponding place being captured\n-    ///\n-    /// See `capture_kind_expr_id` for example.\n-    ///\n-    pub path_expr_id: Option<hir::HirId>,\n-\n-    /// Capture mode that was selected\n-    pub capture_kind: UpvarCapture<'tcx>,\n-}\n-\n-pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n-pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n-\n impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n@@ -776,252 +357,6 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub enum GenericParamDefKind {\n-    Lifetime,\n-    Type {\n-        has_default: bool,\n-        object_lifetime_default: ObjectLifetimeDefault,\n-        synthetic: Option<hir::SyntheticTyParamKind>,\n-    },\n-    Const,\n-}\n-\n-impl GenericParamDefKind {\n-    pub fn descr(&self) -> &'static str {\n-        match self {\n-            GenericParamDefKind::Lifetime => \"lifetime\",\n-            GenericParamDefKind::Type { .. } => \"type\",\n-            GenericParamDefKind::Const => \"constant\",\n-        }\n-    }\n-    pub fn to_ord(&self, tcx: TyCtxt<'_>) -> ast::ParamKindOrd {\n-        match self {\n-            GenericParamDefKind::Lifetime => ast::ParamKindOrd::Lifetime,\n-            GenericParamDefKind::Type { .. } => ast::ParamKindOrd::Type,\n-            GenericParamDefKind::Const => {\n-                ast::ParamKindOrd::Const { unordered: tcx.features().const_generics }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct GenericParamDef {\n-    pub name: Symbol,\n-    pub def_id: DefId,\n-    pub index: u32,\n-\n-    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n-    /// on generic parameter `'a`/`T`, asserts data behind the parameter\n-    /// `'a`/`T` won't be accessed during the parent type's `Drop` impl.\n-    pub pure_wrt_drop: bool,\n-\n-    pub kind: GenericParamDefKind,\n-}\n-\n-impl GenericParamDef {\n-    pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n-        if let GenericParamDefKind::Lifetime = self.kind {\n-            ty::EarlyBoundRegion { def_id: self.def_id, index: self.index, name: self.name }\n-        } else {\n-            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n-        }\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct GenericParamCount {\n-    pub lifetimes: usize,\n-    pub types: usize,\n-    pub consts: usize,\n-}\n-\n-/// Information about the formal type/lifetime parameters associated\n-/// with an item or method. Analogous to `hir::Generics`.\n-///\n-/// The ordering of parameters is the same as in `Subst` (excluding child generics):\n-/// `Self` (optionally), `Lifetime` params..., `Type` params...\n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct Generics {\n-    pub parent: Option<DefId>,\n-    pub parent_count: usize,\n-    pub params: Vec<GenericParamDef>,\n-\n-    /// Reverse map to the `index` field of each `GenericParamDef`.\n-    #[stable_hasher(ignore)]\n-    pub param_def_id_to_index: FxHashMap<DefId, u32>,\n-\n-    pub has_self: bool,\n-    pub has_late_bound_regions: Option<Span>,\n-}\n-\n-impl<'tcx> Generics {\n-    pub fn count(&self) -> usize {\n-        self.parent_count + self.params.len()\n-    }\n-\n-    pub fn own_counts(&self) -> GenericParamCount {\n-        // We could cache this as a property of `GenericParamCount`, but\n-        // the aim is to refactor this away entirely eventually and the\n-        // presence of this method will be a constant reminder.\n-        let mut own_counts = GenericParamCount::default();\n-\n-        for param in &self.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n-                GenericParamDefKind::Type { .. } => own_counts.types += 1,\n-                GenericParamDefKind::Const => own_counts.consts += 1,\n-            }\n-        }\n-\n-        own_counts\n-    }\n-\n-    pub fn own_defaults(&self) -> GenericParamCount {\n-        let mut own_defaults = GenericParamCount::default();\n-\n-        for param in &self.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => (),\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    own_defaults.types += has_default as usize;\n-                }\n-                GenericParamDefKind::Const => {\n-                    // FIXME(const_generics:defaults)\n-                }\n-            }\n-        }\n-\n-        own_defaults\n-    }\n-\n-    pub fn requires_monomorphization(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        if self.own_requires_monomorphization() {\n-            return true;\n-        }\n-\n-        if let Some(parent_def_id) = self.parent {\n-            let parent = tcx.generics_of(parent_def_id);\n-            parent.requires_monomorphization(tcx)\n-        } else {\n-            false\n-        }\n-    }\n-\n-    pub fn own_requires_monomorphization(&self) -> bool {\n-        for param in &self.params {\n-            match param.kind {\n-                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => return true,\n-                GenericParamDefKind::Lifetime => {}\n-            }\n-        }\n-        false\n-    }\n-\n-    /// Returns the `GenericParamDef` with the given index.\n-    pub fn param_at(&'tcx self, param_index: usize, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n-        if let Some(index) = param_index.checked_sub(self.parent_count) {\n-            &self.params[index]\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n-                .param_at(param_index, tcx)\n-        }\n-    }\n-\n-    /// Returns the `GenericParamDef` associated with this `EarlyBoundRegion`.\n-    pub fn region_param(\n-        &'tcx self,\n-        param: &EarlyBoundRegion,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &'tcx GenericParamDef {\n-        let param = self.param_at(param.index as usize, tcx);\n-        match param.kind {\n-            GenericParamDefKind::Lifetime => param,\n-            _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n-        }\n-    }\n-\n-    /// Returns the `GenericParamDef` associated with this `ParamTy`.\n-    pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n-        let param = self.param_at(param.index as usize, tcx);\n-        match param.kind {\n-            GenericParamDefKind::Type { .. } => param,\n-            _ => bug!(\"expected type parameter, but found another generic parameter\"),\n-        }\n-    }\n-\n-    /// Returns the `GenericParamDef` associated with this `ParamConst`.\n-    pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n-        let param = self.param_at(param.index as usize, tcx);\n-        match param.kind {\n-            GenericParamDefKind::Const => param,\n-            _ => bug!(\"expected const parameter, but found another generic parameter\"),\n-        }\n-    }\n-}\n-\n-/// Bounds on generics.\n-#[derive(Copy, Clone, Default, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct GenericPredicates<'tcx> {\n-    pub parent: Option<DefId>,\n-    pub predicates: &'tcx [(Predicate<'tcx>, Span)],\n-}\n-\n-impl<'tcx> GenericPredicates<'tcx> {\n-    pub fn instantiate(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> InstantiatedPredicates<'tcx> {\n-        let mut instantiated = InstantiatedPredicates::empty();\n-        self.instantiate_into(tcx, &mut instantiated, substs);\n-        instantiated\n-    }\n-\n-    pub fn instantiate_own(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> InstantiatedPredicates<'tcx> {\n-        InstantiatedPredicates {\n-            predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n-            spans: self.predicates.iter().map(|(_, sp)| *sp).collect(),\n-        }\n-    }\n-\n-    fn instantiate_into(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        instantiated: &mut InstantiatedPredicates<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-    ) {\n-        if let Some(def_id) = self.parent {\n-            tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n-        }\n-        instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)));\n-        instantiated.spans.extend(self.predicates.iter().map(|(_, sp)| *sp));\n-    }\n-\n-    pub fn instantiate_identity(&self, tcx: TyCtxt<'tcx>) -> InstantiatedPredicates<'tcx> {\n-        let mut instantiated = InstantiatedPredicates::empty();\n-        self.instantiate_identity_into(tcx, &mut instantiated);\n-        instantiated\n-    }\n-\n-    fn instantiate_identity_into(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        instantiated: &mut InstantiatedPredicates<'tcx>,\n-    ) {\n-        if let Some(def_id) = self.parent {\n-            tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n-        }\n-        instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p));\n-        instantiated.spans.extend(self.predicates.iter().map(|(_, s)| s));\n-    }\n-}\n-\n #[derive(Debug)]\n crate struct PredicateInner<'tcx> {\n     kind: Binder<PredicateKind<'tcx>>,\n@@ -1930,32 +1265,6 @@ pub struct Destructor {\n     pub did: DefId,\n }\n \n-bitflags! {\n-    #[derive(HashStable)]\n-    pub struct AdtFlags: u32 {\n-        const NO_ADT_FLAGS        = 0;\n-        /// Indicates whether the ADT is an enum.\n-        const IS_ENUM             = 1 << 0;\n-        /// Indicates whether the ADT is a union.\n-        const IS_UNION            = 1 << 1;\n-        /// Indicates whether the ADT is a struct.\n-        const IS_STRUCT           = 1 << 2;\n-        /// Indicates whether the ADT is a struct and has a constructor.\n-        const HAS_CTOR            = 1 << 3;\n-        /// Indicates whether the type is `PhantomData`.\n-        const IS_PHANTOM_DATA     = 1 << 4;\n-        /// Indicates whether the type has a `#[fundamental]` attribute.\n-        const IS_FUNDAMENTAL      = 1 << 5;\n-        /// Indicates whether the type is `Box`.\n-        const IS_BOX              = 1 << 6;\n-        /// Indicates whether the type is `ManuallyDrop`.\n-        const IS_MANUALLY_DROP    = 1 << 7;\n-        /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n-        /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 8;\n-    }\n-}\n-\n bitflags! {\n     #[derive(HashStable)]\n     pub struct VariantFlags: u32 {\n@@ -2079,105 +1388,6 @@ pub struct FieldDef {\n     pub vis: Visibility,\n }\n \n-/// The definition of a user-defined type, e.g., a `struct`, `enum`, or `union`.\n-///\n-/// These are all interned (by `alloc_adt_def`) into the global arena.\n-///\n-/// The initialism *ADT* stands for an [*algebraic data type (ADT)*][adt].\n-/// This is slightly wrong because `union`s are not ADTs.\n-/// Moreover, Rust only allows recursive data types through indirection.\n-///\n-/// [adt]: https://en.wikipedia.org/wiki/Algebraic_data_type\n-pub struct AdtDef {\n-    /// The `DefId` of the struct, enum or union item.\n-    pub did: DefId,\n-    /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n-    pub variants: IndexVec<VariantIdx, VariantDef>,\n-    /// Flags of the ADT (e.g., is this a struct? is this non-exhaustive?).\n-    flags: AdtFlags,\n-    /// Repr options provided by the user.\n-    pub repr: ReprOptions,\n-}\n-\n-impl PartialOrd for AdtDef {\n-    fn partial_cmp(&self, other: &AdtDef) -> Option<Ordering> {\n-        Some(self.cmp(&other))\n-    }\n-}\n-\n-/// There should be only one AdtDef for each `did`, therefore\n-/// it is fine to implement `Ord` only based on `did`.\n-impl Ord for AdtDef {\n-    fn cmp(&self, other: &AdtDef) -> Ordering {\n-        self.did.cmp(&other.did)\n-    }\n-}\n-\n-impl PartialEq for AdtDef {\n-    // `AdtDef`s are always interned, and this is part of `TyS` equality.\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        ptr::eq(self, other)\n-    }\n-}\n-\n-impl Eq for AdtDef {}\n-\n-impl Hash for AdtDef {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const AdtDef).hash(s)\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for AdtDef {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.did.encode(s)\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        thread_local! {\n-            static CACHE: RefCell<FxHashMap<usize, Fingerprint>> = Default::default();\n-        }\n-\n-        let hash: Fingerprint = CACHE.with(|cache| {\n-            let addr = self as *const AdtDef as usize;\n-            *cache.borrow_mut().entry(addr).or_insert_with(|| {\n-                let ty::AdtDef { did, ref variants, ref flags, ref repr } = *self;\n-\n-                let mut hasher = StableHasher::new();\n-                did.hash_stable(hcx, &mut hasher);\n-                variants.hash_stable(hcx, &mut hasher);\n-                flags.hash_stable(hcx, &mut hasher);\n-                repr.hash_stable(hcx, &mut hasher);\n-\n-                hasher.finish()\n-            })\n-        });\n-\n-        hash.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n-pub enum AdtKind {\n-    Struct,\n-    Union,\n-    Enum,\n-}\n-\n-impl Into<DataTypeKind> for AdtKind {\n-    fn into(self) -> DataTypeKind {\n-        match self {\n-            AdtKind::Struct => DataTypeKind::Struct,\n-            AdtKind::Union => DataTypeKind::Union,\n-            AdtKind::Enum => DataTypeKind::Enum,\n-        }\n-    }\n-}\n-\n bitflags! {\n     #[derive(TyEncodable, TyDecodable, Default, HashStable)]\n     pub struct ReprFlags: u8 {\n@@ -2300,334 +1510,6 @@ impl ReprOptions {\n     }\n }\n \n-impl<'tcx> AdtDef {\n-    /// Creates a new `AdtDef`.\n-    fn new(\n-        tcx: TyCtxt<'_>,\n-        did: DefId,\n-        kind: AdtKind,\n-        variants: IndexVec<VariantIdx, VariantDef>,\n-        repr: ReprOptions,\n-    ) -> Self {\n-        debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n-        let mut flags = AdtFlags::NO_ADT_FLAGS;\n-\n-        if kind == AdtKind::Enum && tcx.has_attr(did, sym::non_exhaustive) {\n-            debug!(\"found non-exhaustive variant list for {:?}\", did);\n-            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n-        }\n-\n-        flags |= match kind {\n-            AdtKind::Enum => AdtFlags::IS_ENUM,\n-            AdtKind::Union => AdtFlags::IS_UNION,\n-            AdtKind::Struct => AdtFlags::IS_STRUCT,\n-        };\n-\n-        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_def_id.is_some() {\n-            flags |= AdtFlags::HAS_CTOR;\n-        }\n-\n-        let attrs = tcx.get_attrs(did);\n-        if tcx.sess.contains_name(&attrs, sym::fundamental) {\n-            flags |= AdtFlags::IS_FUNDAMENTAL;\n-        }\n-        if Some(did) == tcx.lang_items().phantom_data() {\n-            flags |= AdtFlags::IS_PHANTOM_DATA;\n-        }\n-        if Some(did) == tcx.lang_items().owned_box() {\n-            flags |= AdtFlags::IS_BOX;\n-        }\n-        if Some(did) == tcx.lang_items().manually_drop() {\n-            flags |= AdtFlags::IS_MANUALLY_DROP;\n-        }\n-\n-        AdtDef { did, variants, flags, repr }\n-    }\n-\n-    /// Returns `true` if this is a struct.\n-    #[inline]\n-    pub fn is_struct(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_STRUCT)\n-    }\n-\n-    /// Returns `true` if this is a union.\n-    #[inline]\n-    pub fn is_union(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_UNION)\n-    }\n-\n-    /// Returns `true` if this is a enum.\n-    #[inline]\n-    pub fn is_enum(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_ENUM)\n-    }\n-\n-    /// Returns `true` if the variant list of this ADT is `#[non_exhaustive]`.\n-    #[inline]\n-    pub fn is_variant_list_non_exhaustive(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n-    }\n-\n-    /// Returns the kind of the ADT.\n-    #[inline]\n-    pub fn adt_kind(&self) -> AdtKind {\n-        if self.is_enum() {\n-            AdtKind::Enum\n-        } else if self.is_union() {\n-            AdtKind::Union\n-        } else {\n-            AdtKind::Struct\n-        }\n-    }\n-\n-    /// Returns a description of this abstract data type.\n-    pub fn descr(&self) -> &'static str {\n-        match self.adt_kind() {\n-            AdtKind::Struct => \"struct\",\n-            AdtKind::Union => \"union\",\n-            AdtKind::Enum => \"enum\",\n-        }\n-    }\n-\n-    /// Returns a description of a variant of this abstract data type.\n-    #[inline]\n-    pub fn variant_descr(&self) -> &'static str {\n-        match self.adt_kind() {\n-            AdtKind::Struct => \"struct\",\n-            AdtKind::Union => \"union\",\n-            AdtKind::Enum => \"variant\",\n-        }\n-    }\n-\n-    /// If this function returns `true`, it implies that `is_struct` must return `true`.\n-    #[inline]\n-    pub fn has_ctor(&self) -> bool {\n-        self.flags.contains(AdtFlags::HAS_CTOR)\n-    }\n-\n-    /// Returns `true` if this type is `#[fundamental]` for the purposes\n-    /// of coherence checking.\n-    #[inline]\n-    pub fn is_fundamental(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n-    }\n-\n-    /// Returns `true` if this is `PhantomData<T>`.\n-    #[inline]\n-    pub fn is_phantom_data(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n-    }\n-\n-    /// Returns `true` if this is Box<T>.\n-    #[inline]\n-    pub fn is_box(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_BOX)\n-    }\n-\n-    /// Returns `true` if this is `ManuallyDrop<T>`.\n-    #[inline]\n-    pub fn is_manually_drop(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_MANUALLY_DROP)\n-    }\n-\n-    /// Returns `true` if this type has a destructor.\n-    pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        self.destructor(tcx).is_some()\n-    }\n-\n-    /// Asserts this is a struct or union and returns its unique variant.\n-    pub fn non_enum_variant(&self) -> &VariantDef {\n-        assert!(self.is_struct() || self.is_union());\n-        &self.variants[VariantIdx::new(0)]\n-    }\n-\n-    #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n-        tcx.predicates_of(self.did)\n-    }\n-\n-    /// Returns an iterator over all fields contained\n-    /// by this ADT.\n-    #[inline]\n-    pub fn all_fields(&self) -> impl Iterator<Item = &FieldDef> + Clone {\n-        self.variants.iter().flat_map(|v| v.fields.iter())\n-    }\n-\n-    /// Whether the ADT lacks fields. Note that this includes uninhabited enums,\n-    /// e.g., `enum Void {}` is considered payload free as well.\n-    pub fn is_payloadfree(&self) -> bool {\n-        self.variants.iter().all(|v| v.fields.is_empty())\n-    }\n-\n-    /// Return a `VariantDef` given a variant id.\n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n-        self.variants.iter().find(|v| v.def_id == vid).expect(\"variant_with_id: unknown variant\")\n-    }\n-\n-    /// Return a `VariantDef` given a constructor id.\n-    pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n-        self.variants\n-            .iter()\n-            .find(|v| v.ctor_def_id == Some(cid))\n-            .expect(\"variant_with_ctor_id: unknown variant\")\n-    }\n-\n-    /// Return the index of `VariantDef` given a variant id.\n-    pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n-        self.variants\n-            .iter_enumerated()\n-            .find(|(_, v)| v.def_id == vid)\n-            .expect(\"variant_index_with_id: unknown variant\")\n-            .0\n-    }\n-\n-    /// Return the index of `VariantDef` given a constructor id.\n-    pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n-        self.variants\n-            .iter_enumerated()\n-            .find(|(_, v)| v.ctor_def_id == Some(cid))\n-            .expect(\"variant_index_with_ctor_id: unknown variant\")\n-            .0\n-    }\n-\n-    pub fn variant_of_res(&self, res: Res) -> &VariantDef {\n-        match res {\n-            Res::Def(DefKind::Variant, vid) => self.variant_with_id(vid),\n-            Res::Def(DefKind::Ctor(..), cid) => self.variant_with_ctor_id(cid),\n-            Res::Def(DefKind::Struct, _)\n-            | Res::Def(DefKind::Union, _)\n-            | Res::Def(DefKind::TyAlias, _)\n-            | Res::Def(DefKind::AssocTy, _)\n-            | Res::SelfTy(..)\n-            | Res::SelfCtor(..) => self.non_enum_variant(),\n-            _ => bug!(\"unexpected res {:?} in variant_of_res\", res),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n-        assert!(self.is_enum());\n-        let param_env = tcx.param_env(expr_did);\n-        let repr_type = self.repr.discr_type();\n-        match tcx.const_eval_poly(expr_did) {\n-            Ok(val) => {\n-                let ty = repr_type.to_ty(tcx);\n-                if let Some(b) = val.try_to_bits_for_ty(tcx, param_env, ty) {\n-                    trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                    Some(Discr { val: b, ty })\n-                } else {\n-                    info!(\"invalid enum discriminant: {:#?}\", val);\n-                    crate::mir::interpret::struct_error(\n-                        tcx.at(tcx.def_span(expr_did)),\n-                        \"constant evaluation of enum discriminant resulted in non-integer\",\n-                    )\n-                    .emit();\n-                    None\n-                }\n-            }\n-            Err(err) => {\n-                let msg = match err {\n-                    ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n-                        \"enum discriminant evaluation failed\"\n-                    }\n-                    ErrorHandled::TooGeneric => \"enum discriminant depends on generics\",\n-                };\n-                tcx.sess.delay_span_bug(tcx.def_span(expr_did), msg);\n-                None\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn discriminants(\n-        &'tcx self,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n-        assert!(self.is_enum());\n-        let repr_type = self.repr.discr_type();\n-        let initial = repr_type.initial_discriminant(tcx);\n-        let mut prev_discr = None::<Discr<'tcx>>;\n-        self.variants.iter_enumerated().map(move |(i, v)| {\n-            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n-            if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                if let Some(new_discr) = self.eval_explicit_discr(tcx, expr_did) {\n-                    discr = new_discr;\n-                }\n-            }\n-            prev_discr = Some(discr);\n-\n-            (i, discr)\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn variant_range(&self) -> Range<VariantIdx> {\n-        VariantIdx::new(0)..VariantIdx::new(self.variants.len())\n-    }\n-\n-    /// Computes the discriminant value used by a specific variant.\n-    /// Unlike `discriminants`, this is (amortized) constant-time,\n-    /// only doing at most one query for evaluating an explicit\n-    /// discriminant (the last one before the requested variant),\n-    /// assuming there are no constant-evaluation errors there.\n-    #[inline]\n-    pub fn discriminant_for_variant(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        variant_index: VariantIdx,\n-    ) -> Discr<'tcx> {\n-        assert!(self.is_enum());\n-        let (val, offset) = self.discriminant_def_for_variant(variant_index);\n-        let explicit_value = val\n-            .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n-            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx));\n-        explicit_value.checked_add(tcx, offset as u128).0\n-    }\n-\n-    /// Yields a `DefId` for the discriminant and an offset to add to it\n-    /// Alternatively, if there is no explicit discriminant, returns the\n-    /// inferred discriminant directly.\n-    pub fn discriminant_def_for_variant(&self, variant_index: VariantIdx) -> (Option<DefId>, u32) {\n-        assert!(!self.variants.is_empty());\n-        let mut explicit_index = variant_index.as_u32();\n-        let expr_did;\n-        loop {\n-            match self.variants[VariantIdx::from_u32(explicit_index)].discr {\n-                ty::VariantDiscr::Relative(0) => {\n-                    expr_did = None;\n-                    break;\n-                }\n-                ty::VariantDiscr::Relative(distance) => {\n-                    explicit_index -= distance;\n-                }\n-                ty::VariantDiscr::Explicit(did) => {\n-                    expr_did = Some(did);\n-                    break;\n-                }\n-            }\n-        }\n-        (expr_did, variant_index.as_u32() - explicit_index)\n-    }\n-\n-    pub fn destructor(&self, tcx: TyCtxt<'tcx>) -> Option<Destructor> {\n-        tcx.adt_destructor(self.did)\n-    }\n-\n-    /// Returns a list of types such that `Self: Sized` if and only\n-    /// if that type is `Sized`, or `TyErr` if this type is recursive.\n-    ///\n-    /// Oddly enough, checking that the sized-constraint is `Sized` is\n-    /// actually more expressive than checking all members:\n-    /// the `Sized` trait is inductive, so an associated type that references\n-    /// `Self` would prevent its containing ADT from being `Sized`.\n-    ///\n-    /// Due to normalization being eager, this applies even if\n-    /// the associated type is behind a pointer (e.g., issue #31299).\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n-        tcx.adt_sized_constraint(self.did).0\n-    }\n-}\n-\n impl<'tcx> FieldDef {\n     /// Returns the type of this field. The `subst` is typically obtained\n     /// via the second field of `TyKind::AdtDef`.\n@@ -2636,93 +1518,6 @@ impl<'tcx> FieldDef {\n     }\n }\n \n-/// Represents the various closure traits in the language. This\n-/// will determine the type of the environment (`self`, in the\n-/// desugaring) argument that the closure expects.\n-///\n-/// You can get the environment type of a closure using\n-/// `tcx.closure_env_ty()`.\n-#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable)]\n-pub enum ClosureKind {\n-    // Warning: Ordering is significant here! The ordering is chosen\n-    // because the trait Fn is a subtrait of FnMut and so in turn, and\n-    // hence we order it so that Fn < FnMut < FnOnce.\n-    Fn,\n-    FnMut,\n-    FnOnce,\n-}\n-\n-impl<'tcx> ClosureKind {\n-    // This is the initial value used when doing upvar inference.\n-    pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n-\n-    pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n-        match *self {\n-            ClosureKind::Fn => tcx.require_lang_item(LangItem::Fn, None),\n-            ClosureKind::FnMut => tcx.require_lang_item(LangItem::FnMut, None),\n-            ClosureKind::FnOnce => tcx.require_lang_item(LangItem::FnOnce, None),\n-        }\n-    }\n-\n-    /// Returns `true` if a type that impls this closure kind\n-    /// must also implement `other`.\n-    pub fn extends(self, other: ty::ClosureKind) -> bool {\n-        matches!(\n-            (self, other),\n-            (ClosureKind::Fn, ClosureKind::Fn)\n-                | (ClosureKind::Fn, ClosureKind::FnMut)\n-                | (ClosureKind::Fn, ClosureKind::FnOnce)\n-                | (ClosureKind::FnMut, ClosureKind::FnMut)\n-                | (ClosureKind::FnMut, ClosureKind::FnOnce)\n-                | (ClosureKind::FnOnce, ClosureKind::FnOnce)\n-        )\n-    }\n-\n-    /// Returns the representative scalar type for this closure kind.\n-    /// See `TyS::to_opt_closure_kind` for more details.\n-    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self {\n-            ty::ClosureKind::Fn => tcx.types.i8,\n-            ty::ClosureKind::FnMut => tcx.types.i16,\n-            ty::ClosureKind::FnOnce => tcx.types.i32,\n-        }\n-    }\n-}\n-\n-impl BorrowKind {\n-    pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n-        match m {\n-            hir::Mutability::Mut => MutBorrow,\n-            hir::Mutability::Not => ImmBorrow,\n-        }\n-    }\n-\n-    /// Returns a mutability `m` such that an `&m T` pointer could be used to obtain this borrow\n-    /// kind. Because borrow kinds are richer than mutabilities, we sometimes have to pick a\n-    /// mutability that is stronger than necessary so that it at least *would permit* the borrow in\n-    /// question.\n-    pub fn to_mutbl_lossy(self) -> hir::Mutability {\n-        match self {\n-            MutBorrow => hir::Mutability::Mut,\n-            ImmBorrow => hir::Mutability::Not,\n-\n-            // We have no type corresponding to a unique imm borrow, so\n-            // use `&mut`. It gives all the capabilities of an `&uniq`\n-            // and hence is a safe \"over approximation\".\n-            UniqueImmBorrow => hir::Mutability::Mut,\n-        }\n-    }\n-\n-    pub fn to_user_str(&self) -> &'static str {\n-        match *self {\n-            MutBorrow => \"mutable\",\n-            ImmBorrow => \"immutable\",\n-            UniqueImmBorrow => \"uniquely immutable\",\n-        }\n-    }\n-}\n-\n pub type Attributes<'tcx> = &'tcx [ast::Attribute];\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -3080,9 +1875,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-#[derive(Clone, HashStable, Debug)]\n-pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n-\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(def_id) = def_id.as_local() {"}]}