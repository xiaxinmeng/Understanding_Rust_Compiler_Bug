{"sha": "d67db0042c1f4e163292ea59bdfac546c67f7001", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2N2RiMDA0MmMxZjRlMTYzMjkyZWE1OWJkZmFjNTQ2YzY3ZjcwMDE=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2019-06-18T21:34:51Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2019-06-18T23:22:22Z"}, "message": "Preserve generator and yield source for error messages\n\nPreviously, error messages after HIR lowering all referred\nto generators and yield, regardless of whether the original\nsource was a generator or an async/await body. This change\ntracks the kind of each generator and yield source in order\nto provide appropriately tailored error messages.", "tree": {"sha": "d6ee0c8011e63c97d0389d4c463ff6f823a86369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6ee0c8011e63c97d0389d4c463ff6f823a86369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d67db0042c1f4e163292ea59bdfac546c67f7001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d67db0042c1f4e163292ea59bdfac546c67f7001", "html_url": "https://github.com/rust-lang/rust/commit/d67db0042c1f4e163292ea59bdfac546c67f7001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d67db0042c1f4e163292ea59bdfac546c67f7001/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b01a257da1fbb3f5661029dd390fdccc49dff287", "url": "https://api.github.com/repos/rust-lang/rust/commits/b01a257da1fbb3f5661029dd390fdccc49dff287", "html_url": "https://github.com/rust-lang/rust/commit/b01a257da1fbb3f5661029dd390fdccc49dff287"}], "stats": {"total": 351, "additions": 222, "deletions": 129}, "files": [{"sha": "ffbdc0373f80c782da5986df6285f06c60acefaa", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -330,7 +330,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprKind::DropTemps(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n             hir::ExprKind::Field(ref e, _) |\n-            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Yield(ref e, _) |\n             hir::ExprKind::Repeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }"}, {"sha": "0ab6f7bc46a8412380d303e4109bb6afa47548d3", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -1089,7 +1089,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_expr(expr)\n             }\n         }\n-        ExprKind::Yield(ref subexpression) => {\n+        ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }\n         ExprKind::Lit(_) | ExprKind::Err => {}"}, {"sha": "d25f3ed5c89a6dfe61058d7d22562f8a45dbfc02", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 87, "deletions": 61, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -95,8 +95,7 @@ pub struct LoweringContext<'a> {\n \n     modules: BTreeMap<NodeId, hir::ModuleItems>,\n \n-    is_generator: bool,\n-    is_async_body: bool,\n+    generator_kind: Option<hir::GeneratorKind>,\n \n     /// Used to get the current `fn`'s def span to point to when using `await`\n     /// outside of an `async fn`.\n@@ -261,8 +260,7 @@ pub fn lower_crate(\n         current_hir_id_owner: vec![(CRATE_DEF_INDEX, 0)],\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n-        is_generator: false,\n-        is_async_body: false,\n+        generator_kind: None,\n         current_item: None,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n@@ -790,18 +788,49 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n-        if self.is_generator && self.is_async_body {\n-            span_err!(\n-                self.sess,\n-                value.span,\n-                E0727,\n-                \"`async` generators are not yet supported\",\n-            );\n-            self.sess.abort_if_errors();\n+    fn generator_movability_for_fn(\n+        &mut self,\n+        decl: &ast::FnDecl,\n+        fn_decl_span: Span,\n+        generator_kind: Option<hir::GeneratorKind>,\n+        movability: Movability,\n+    ) -> Option<hir::GeneratorMovability> {\n+        match generator_kind {\n+            Some(hir::GeneratorKind::Gen) =>  {\n+                if !decl.inputs.is_empty() {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0628,\n+                        \"generators cannot have explicit arguments\"\n+                    );\n+                    self.sess.abort_if_errors();\n+                }\n+                Some(match movability {\n+                    Movability::Movable => hir::GeneratorMovability::Movable,\n+                    Movability::Static => hir::GeneratorMovability::Static,\n+                })\n+            },\n+            Some(hir::GeneratorKind::Async) => {\n+                bug!(\"non-`async` closure body turned `async` during lowering\");\n+            },\n+            None => {\n+                if movability == Movability::Static {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0697,\n+                        \"closures cannot be static\"\n+                    );\n+                }\n+                None\n+            },\n         }\n+    }\n+\n+    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n-            is_generator: self.is_generator || self.is_async_body,\n+            generator_kind: self.generator_kind,\n             arguments,\n             value,\n         };\n@@ -1142,7 +1171,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n-            this.is_async_body = true;\n+            this.generator_kind = Some(hir::GeneratorKind::Async);\n             body(this)\n         });\n         let generator = hir::Expr {\n@@ -1167,12 +1196,10 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n     ) -> hir::BodyId {\n-        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_is_async_body = mem::replace(&mut self.is_async_body, false);\n+        let prev_gen_kind = self.generator_kind.take();\n         let (arguments, result) = f(self);\n         let body_id = self.record_body(arguments, result);\n-        self.is_generator = prev_is_generator;\n-        self.is_async_body = prev_is_async_body;\n+        self.generator_kind = prev_gen_kind;\n         body_id\n     }\n \n@@ -4475,37 +4502,18 @@ impl<'a> LoweringContext<'a> {\n \n                     self.with_new_scopes(|this| {\n                         this.current_item = Some(fn_decl_span);\n-                        let mut is_generator = false;\n+                        let mut generator_kind = None;\n                         let body_id = this.lower_fn_body(decl, |this| {\n                             let e = this.lower_expr(body);\n-                            is_generator = this.is_generator;\n+                            generator_kind = this.generator_kind;\n                             e\n                         });\n-                        let generator_option = if is_generator {\n-                            if !decl.inputs.is_empty() {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0628,\n-                                    \"generators cannot have explicit arguments\"\n-                                );\n-                                this.sess.abort_if_errors();\n-                            }\n-                            Some(match movability {\n-                                Movability::Movable => hir::GeneratorMovability::Movable,\n-                                Movability::Static => hir::GeneratorMovability::Static,\n-                            })\n-                        } else {\n-                            if movability == Movability::Static {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0697,\n-                                    \"closures cannot be static\"\n-                                );\n-                            }\n-                            None\n-                        };\n+                        let generator_option = this.generator_movability_for_fn(\n+                            &decl,\n+                            fn_decl_span,\n+                            generator_kind,\n+                            movability,\n+                        );\n                         hir::ExprKind::Closure(\n                             this.lower_capture_clause(capture_clause),\n                             fn_decl,\n@@ -4677,12 +4685,26 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             ExprKind::Yield(ref opt_expr) => {\n-                self.is_generator = true;\n+                match self.generator_kind {\n+                    Some(hir::GeneratorKind::Gen) => {},\n+                    Some(hir::GeneratorKind::Async) => {\n+                        span_err!(\n+                            self.sess,\n+                            e.span,\n+                            E0727,\n+                            \"`async` generators are not yet supported\",\n+                        );\n+                        self.sess.abort_if_errors();\n+                    },\n+                    None => {\n+                        self.generator_kind = Some(hir::GeneratorKind::Gen);\n+                    }\n+                }\n                 let expr = opt_expr\n                     .as_ref()\n                     .map(|x| self.lower_expr(x))\n                     .unwrap_or_else(|| self.expr_unit(e.span));\n-                hir::ExprKind::Yield(P(expr))\n+                hir::ExprKind::Yield(P(expr), hir::YieldSource::Yield)\n             }\n \n             ExprKind::Err => hir::ExprKind::Err,\n@@ -5754,19 +5776,23 @@ impl<'a> LoweringContext<'a> {\n         //         yield ();\n         //     }\n         // }\n-        if !self.is_async_body {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                await_span,\n-                E0728,\n-                \"`await` is only allowed inside `async` functions and blocks\"\n-            );\n-            err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n-            if let Some(item_sp) = self.current_item {\n-                err.span_label(item_sp, \"this is not `async`\");\n+        match self.generator_kind {\n+            Some(hir::GeneratorKind::Async) => {},\n+            Some(hir::GeneratorKind::Gen) |\n+            None => {\n+                let mut err = struct_span_err!(\n+                    self.sess,\n+                    await_span,\n+                    E0728,\n+                    \"`await` is only allowed inside `async` functions and blocks\"\n+                );\n+                err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+                if let Some(item_sp) = self.current_item {\n+                    err.span_label(item_sp, \"this is not `async`\");\n+                }\n+                err.emit();\n+                return hir::ExprKind::Err;\n             }\n-            err.emit();\n-            return hir::ExprKind::Err;\n         }\n         let span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n@@ -5864,7 +5890,7 @@ impl<'a> LoweringContext<'a> {\n             let unit = self.expr_unit(span);\n             let yield_expr = P(self.expr(\n                 span,\n-                hir::ExprKind::Yield(P(unit)),\n+                hir::ExprKind::Yield(P(unit), hir::YieldSource::Await),\n                 ThinVec::new(),\n             ));\n             self.stmt(span, hir::StmtKind::Expr(yield_expr))"}, {"sha": "d570d34ec4e01115789fcc61fce398ee29fbd3db", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -1306,15 +1306,15 @@ pub struct BodyId {\n ///\n /// - an `arguments` array containing the `(x, y)` pattern\n /// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n-/// - `is_generator` would be false\n+/// - `generator_kind` would be `None`\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,\n     pub value: Expr,\n-    pub is_generator: bool,\n+    pub generator_kind: Option<GeneratorKind>,\n }\n \n impl Body {\n@@ -1325,6 +1325,26 @@ impl Body {\n     }\n }\n \n+/// The type of source expression that caused this generator to be created.\n+// Not `IsAsync` because we want to eventually add support for `AsyncGen`\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum GeneratorKind {\n+    /// An `async` block or function.\n+    Async,\n+    /// A generator literal created via a `yield` inside a closure.\n+    Gen,\n+}\n+\n+impl fmt::Display for GeneratorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            GeneratorKind::Async => \"`async` object\",\n+            GeneratorKind::Gen => \"generator\",\n+        })\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum BodyOwnerKind {\n     /// Functions and methods.\n@@ -1531,8 +1551,8 @@ pub enum ExprKind {\n     ///\n     /// The final span is the span of the argument block `|...|`.\n     ///\n-    /// This may also be a generator literal, indicated by the final boolean,\n-    /// in that case there is an `GeneratorClause`.\n+    /// This may also be a generator literal or an `async block` as indicated by the\n+    /// `Option<GeneratorMovability>`.\n     Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n     /// A block (e.g., `'label: { ... }`).\n     Block(P<Block>, Option<Label>),\n@@ -1576,7 +1596,7 @@ pub enum ExprKind {\n     Repeat(P<Expr>, AnonConst),\n \n     /// A suspension point for generators (i.e., `yield <expr>`).\n-    Yield(P<Expr>),\n+    Yield(P<Expr>, YieldSource),\n \n     /// A placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n@@ -1668,12 +1688,12 @@ pub enum LoopIdError {\n \n impl fmt::Display for LoopIdError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(match *self {\n+        f.write_str(match self {\n             LoopIdError::OutsideLoopScope => \"not inside loop scope\",\n             LoopIdError::UnlabeledCfInWhileCondition =>\n                 \"unlabeled control flow (break or continue) in while condition\",\n             LoopIdError::UnresolvedLabel => \"label not found\",\n-        }, f)\n+        })\n     }\n }\n \n@@ -1687,13 +1707,34 @@ pub struct Destination {\n     pub target_id: Result<HirId, LoopIdError>,\n }\n \n+/// Whether a generator contains self-references, causing it to be `!Unpin`.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n          RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum GeneratorMovability {\n+    /// May contain self-references, `!Unpin`.\n     Static,\n+    /// Must not contain self-references, `Unpin`.\n     Movable,\n }\n \n+/// The yield kind that caused an `ExprKind::Yield`.\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum YieldSource {\n+    /// An `<expr>.await`.\n+    Await,\n+    /// A plain `yield`.\n+    Yield,\n+}\n+\n+impl fmt::Display for YieldSource {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            YieldSource::Await => \"`await`\",\n+            YieldSource::Yield => \"`yield`\",\n+        })\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum CaptureClause {\n     CaptureByValue,\n@@ -2058,11 +2099,10 @@ impl Defaultness {\n \n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(match *self {\n-                              Unsafety::Normal => \"normal\",\n-                              Unsafety::Unsafe => \"unsafe\",\n-                          },\n-                          f)\n+        f.write_str(match self {\n+            Unsafety::Normal => \"normal\",\n+            Unsafety::Unsafe => \"unsafe\",\n+        })\n     }\n }\n \n@@ -2076,10 +2116,10 @@ pub enum ImplPolarity {\n \n impl fmt::Debug for ImplPolarity {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ImplPolarity::Positive => \"positive\".fmt(f),\n-            ImplPolarity::Negative => \"negative\".fmt(f),\n-        }\n+        f.write_str(match self {\n+            ImplPolarity::Positive => \"positive\",\n+            ImplPolarity::Negative => \"negative\",\n+        })\n     }\n }\n "}, {"sha": "69ee84dfa4393c5432b896ff55206321d5e3670d", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -1501,7 +1501,7 @@ impl<'a> State<'a> {\n \n                 self.pclose()?;\n             }\n-            hir::ExprKind::Yield(ref expr) => {\n+            hir::ExprKind::Yield(ref expr, _) => {\n                 self.word_space(\"yield\")?;\n                 self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }"}, {"sha": "30d76f240d1faa431cb24941d076827f4b258488", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -335,15 +335,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n-            ref arguments,\n-            ref value,\n-            is_generator,\n-        } = *self;\n+            arguments,\n+            value,\n+            generator_kind,\n+        } = self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n             arguments.hash_stable(hcx, hasher);\n             value.hash_stable(hcx, hasher);\n-            is_generator.hash_stable(hcx, hasher);\n+            generator_kind.hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "fe151bdec6a841ed927666103dfcf08c678b6e85", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -227,16 +227,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn need_type_info_err_in_generator(\n         &self,\n+        kind: hir::GeneratorKind,\n         span: Span,\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n-\n-        let mut err = struct_span_err!(self.tcx.sess,\n-                       span,\n-                       E0698,\n-                       \"type inside generator must be known in this context\");\n+        let mut err = struct_span_err!(\n+            self.tcx.sess, span, E0698, \"type inside {} must be known in this context\", kind,\n+        );\n         err.span_label(span, InferCtxt::missing_type_msg(&name));\n         err\n     }"}, {"sha": "64a560ae45bb815dfb607eb40b337c7c5548345c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprKind::Yield(ref value) => {\n+            hir::ExprKind::Yield(ref value, _) => {\n                 self.consume_expr(&value);\n             }\n         }"}, {"sha": "1568ff6e8872a6e0e29165a4112df29f38257955", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -1218,7 +1218,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::Type(ref e, _) |\n             hir::ExprKind::DropTemps(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n-            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Yield(ref e, _) |\n             hir::ExprKind::Repeat(ref e, _) => {\n                 self.propagate_through_expr(&e, succ)\n             }"}, {"sha": "5e207dedbf394aee0e2e5d8d63e1a35ea1f76883", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -332,14 +332,23 @@ pub struct ScopeTree {\n     /// The reason is that semantically, until the `box` expression returns,\n     /// the values are still owned by their containing expressions. So\n     /// we'll see that `&x`.\n-    yield_in_scope: FxHashMap<Scope, (Span, usize)>,\n+    yield_in_scope: FxHashMap<Scope, YieldData>,\n \n     /// The number of visit_expr and visit_pat calls done in the body.\n     /// Used to sanity check visit_expr/visit_pat call count when\n     /// calculating generator interiors.\n     body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n \n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct YieldData {\n+    /// `Span` of the yield.\n+    pub span: Span,\n+    /// The number of expressions and patterns appearing before the `yield` in the body + 1.\n+    pub expr_and_pat_count: usize,\n+    pub source: hir::YieldSource,\n+}\n+\n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n     /// the root of the current region tree. This is typically the id\n@@ -696,7 +705,7 @@ impl<'tcx> ScopeTree {\n     /// returns `Some((span, expr_count))` with the span of a yield we found and\n     /// the number of expressions and patterns appearing before the `yield` in the body + 1.\n     /// If there a are multiple yields in a scope, the one with the highest number is returned.\n-    pub fn yield_in_scope(&self, scope: Scope) -> Option<(Span, usize)> {\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<YieldData> {\n         self.yield_in_scope.get(&scope).cloned()\n     }\n \n@@ -707,14 +716,14 @@ impl<'tcx> ScopeTree {\n                                    scope: Scope,\n                                    expr_hir_id: hir::HirId,\n                                    body: &'tcx hir::Body) -> Option<Span> {\n-        self.yield_in_scope(scope).and_then(|(span, count)| {\n+        self.yield_in_scope(scope).and_then(|YieldData { span, expr_and_pat_count, .. }| {\n             let mut visitor = ExprLocatorVisitor {\n                 hir_id: expr_hir_id,\n                 result: None,\n                 expr_and_pat_count: 0,\n             };\n             visitor.visit_body(body);\n-            if count >= visitor.result.unwrap() {\n+            if expr_and_pat_count >= visitor.result.unwrap() {\n                 Some(span)\n             } else {\n                 None\n@@ -954,12 +963,16 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n \n     debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n-    if let hir::ExprKind::Yield(..) = expr.node {\n+    if let hir::ExprKind::Yield(_, source) = &expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope { id: expr.hir_id.local_id, data: ScopeData::Node };\n         loop {\n-            visitor.scope_tree.yield_in_scope.insert(scope,\n-                (expr.span, visitor.expr_and_pat_count));\n+            let data = YieldData {\n+                span: expr.span,\n+                expr_and_pat_count: visitor.expr_and_pat_count,\n+                source: *source,\n+            };\n+            visitor.scope_tree.yield_in_scope.insert(scope, data);\n \n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n@@ -1303,7 +1316,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n             resolve_local(self, None, Some(&body.value));\n         }\n \n-        if body.is_generator {\n+        if body.generator_kind.is_some() {\n             self.scope_tree.body_expr_count.insert(body_id, self.expr_and_pat_count);\n         }\n "}, {"sha": "eba6b22edac2f1a758448ed9c34c60075446a04d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -126,7 +126,7 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n \n-            let (yield_ty, return_ty) = if body.is_generator {\n+            let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n                 let gen_sig = match ty.sty {\n                     ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n@@ -590,7 +590,7 @@ where\n         return_ty_span,\n         upvar_debuginfo,\n         upvar_mutbls,\n-        body.is_generator);\n+        body.generator_kind.is_some());\n \n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,"}, {"sha": "544b14045e6a660b7ab2e5b07035b18e33cb3e28", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -763,7 +763,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         hir::ExprKind::Array(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n         hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n \n-        hir::ExprKind::Yield(ref v) => ExprKind::Yield { value: v.to_ref() },\n+        hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: v.to_ref() },\n         hir::ExprKind::Err => unreachable!(),\n     };\n "}, {"sha": "1190fc7728f81454b351c7078463ec4d205c35fb", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -545,7 +545,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         // Generator expressions\n-        hir::ExprKind::Yield(ref expr) => {\n+        hir::ExprKind::Yield(ref expr, _) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n         }"}, {"sha": "894c0b5ec77658721ca9b91b9f5e1fad666bdda0", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Index(ref base, ref idx) => {\n                 self.check_expr_index(base, idx, needs, expr)\n             }\n-            ExprKind::Yield(ref value) => {\n+            ExprKind::Yield(ref value, _) => {\n                 self.check_expr_yield(value, expr)\n             }\n             hir::ExprKind::Err => {"}, {"sha": "b11af364c0839e7a76a2ae31113bac626b015f1d", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -6,7 +6,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Pat, PatKind, Expr};\n-use rustc::middle::region;\n+use rustc::middle::region::{self, YieldData};\n use rustc::ty::{self, Ty};\n use syntax_pos::Span;\n use super::FnCtxt;\n@@ -17,6 +17,7 @@ struct InteriorVisitor<'a, 'tcx: 'a> {\n     types: FxHashMap<Ty<'tcx>, usize>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     expr_count: usize,\n+    kind: hir::GeneratorKind,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -27,8 +28,8 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n               source_span: Span) {\n         use syntax_pos::DUMMY_SP;\n \n-        let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n-            self.region_scope_tree.yield_in_scope(s).and_then(|(yield_span, expr_count)| {\n+        let live_across_yield = scope.map(|s| {\n+            self.region_scope_tree.yield_in_scope(s).and_then(|yield_data| {\n                 // If we are recording an expression that is the last yield\n                 // in the scope, or that has a postorder CFG index larger\n                 // than the one of all of the yields, then its value can't\n@@ -37,31 +38,43 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 // See the mega-comment at `yield_in_scope` for a proof.\n \n                 debug!(\"comparing counts yield: {} self: {}, source_span = {:?}\",\n-                       expr_count, self.expr_count, source_span);\n+                       yield_data.expr_and_pat_count, self.expr_count, source_span);\n \n-                if expr_count >= self.expr_count {\n-                    Some(yield_span)\n+                if yield_data.expr_and_pat_count >= self.expr_count {\n+                    Some(yield_data)\n                 } else {\n                     None\n                 }\n             })\n-        });\n-\n-        if let Some(yield_span) = live_across_yield {\n+        }).unwrap_or_else(|| Some(YieldData {\n+            span: DUMMY_SP,\n+            expr_and_pat_count: 0,\n+            source: match self.kind { // Guess based on the kind of the current generator.\n+                hir::GeneratorKind::Gen => hir::YieldSource::Yield,\n+                hir::GeneratorKind::Async => hir::YieldSource::Await,\n+            },\n+        }));\n+\n+        if let Some(yield_data) = live_across_yield {\n             let ty = self.fcx.resolve_vars_if_possible(&ty);\n \n             debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n-                   expr, scope, ty, self.expr_count, yield_span);\n+                   expr, scope, ty, self.expr_count, yield_data.span);\n \n             if let Some((unresolved_type, unresolved_type_span)) =\n                 self.fcx.unresolved_type_vars(&ty)\n             {\n+                let note = format!(\"the type is part of the {} because of this {}\",\n+                                   self.kind,\n+                                   yield_data.source);\n+\n                 // If unresolved type isn't a ty_var then unresolved_type_span is None\n                 self.fcx.need_type_info_err_in_generator(\n-                    unresolved_type_span.unwrap_or(yield_span),\n-                    unresolved_type)\n-                    .span_note(yield_span,\n-                               \"the type is part of the generator because of this `yield`\")\n+                    self.kind,\n+                    unresolved_type_span.unwrap_or(yield_data.span),\n+                    unresolved_type,\n+                )\n+                    .span_note(yield_data.span, &*note)\n                     .emit();\n             } else {\n                 // Map the type to the number of types added before it\n@@ -80,13 +93,15 @@ pub fn resolve_interior<'a, 'tcx>(\n     def_id: DefId,\n     body_id: hir::BodyId,\n     interior: Ty<'tcx>,\n+    kind: hir::GeneratorKind,\n ) {\n     let body = fcx.tcx.hir().body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap::default(),\n         region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n         expr_count: 0,\n+        kind,\n     };\n     intravisit::walk_body(&mut visitor, body);\n "}, {"sha": "427c5faa991722edf2728f97a1be5906323ac4aa", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -217,7 +217,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n-    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>)>>,\n+    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n     // Opaque types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n@@ -1071,7 +1071,7 @@ fn check_fn<'a, 'tcx>(\n \n     let span = body.value.span;\n \n-    if body.is_generator && can_be_generator.is_some() {\n+    if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::TypeInference,\n             span,\n@@ -1108,12 +1108,12 @@ fn check_fn<'a, 'tcx>(\n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator.\n     // resolve_generator_interiors relies on this property.\n-    let gen_ty = if can_be_generator.is_some() && body.is_generator {\n+    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n         let interior = fcx.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::MiscVariable,\n             span,\n         });\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior));\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n         Some(GeneratorTypes {\n             yield_ty: fcx.yield_ty.unwrap(),\n             interior,\n@@ -2599,9 +2599,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n-        for (body_id, interior) in generators.drain(..) {\n+        for (body_id, interior, kind) in generators.drain(..) {\n             self.select_obligations_where_possible(false);\n-            generator_interior::resolve_interior(self, def_id, body_id, interior);\n+            generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n         }\n     }\n "}, {"sha": "578d41fe0df0bc238acf0abd2743c8b4666c6155", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -7,9 +7,9 @@ async fn bar<T>() -> () {}\n \n async fn foo() {\n     bar().await;\n-    //~^ ERROR type inside generator must be known in this context\n+    //~^ ERROR type inside `async` object must be known in this context\n     //~| NOTE cannot infer type for `T`\n-    //~| NOTE the type is part of the generator because of this `yield`\n+    //~| NOTE the type is part of the `async` object because of this `await`\n     //~| NOTE in this expansion of desugaring of `await`\n }\n fn main() {}"}, {"sha": "f3090a2b980e8d34eb80d93f333b86ad2ac90363", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d67db0042c1f4e163292ea59bdfac546c67f7001/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=d67db0042c1f4e163292ea59bdfac546c67f7001", "patch": "@@ -1,10 +1,10 @@\n-error[E0698]: type inside generator must be known in this context\n+error[E0698]: type inside `async` object must be known in this context\n   --> $DIR/unresolved_type_param.rs:9:5\n    |\n LL |     bar().await;\n    |     ^^^ cannot infer type for `T`\n    |\n-note: the type is part of the generator because of this `yield`\n+note: the type is part of the `async` object because of this `await`\n   --> $DIR/unresolved_type_param.rs:9:5\n    |\n LL |     bar().await;"}]}