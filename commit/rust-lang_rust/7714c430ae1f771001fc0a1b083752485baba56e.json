{"sha": "7714c430ae1f771001fc0a1b083752485baba56e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MTRjNDMwYWUxZjc3MTAwMWZjMGExYjA4Mzc1MjQ4NWJhYmE1NmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-23T04:06:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-23T04:06:15Z"}, "message": "Auto merge of #54310 - pnkfelix:issue-52059-report-borrow-drop-conflict, r=nikomatsakis\n\nReport when borrow could cause `&mut` aliasing during Drop\n\nWe were already issuing an error for the cases where this cropped up, so this is not fixing any soundness holes. The previous diagnostic just wasn't accurately describing the problem in the user's code.\n\nFix #52059", "tree": {"sha": "fe9d0752e00e3910994223686d8ce91408cf313d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe9d0752e00e3910994223686d8ce91408cf313d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7714c430ae1f771001fc0a1b083752485baba56e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7714c430ae1f771001fc0a1b083752485baba56e", "html_url": "https://github.com/rust-lang/rust/commit/7714c430ae1f771001fc0a1b083752485baba56e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7714c430ae1f771001fc0a1b083752485baba56e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "576b640a02d7363746aacab9d2f1b91c6b685688", "url": "https://api.github.com/repos/rust-lang/rust/commits/576b640a02d7363746aacab9d2f1b91c6b685688", "html_url": "https://github.com/rust-lang/rust/commit/576b640a02d7363746aacab9d2f1b91c6b685688"}, {"sha": "c9cf4993307b9623580b1fe7f12aa87df1225fb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9cf4993307b9623580b1fe7f12aa87df1225fb8", "html_url": "https://github.com/rust-lang/rust/commit/c9cf4993307b9623580b1fe7f12aa87df1225fb8"}], "stats": {"total": 419, "additions": 346, "deletions": 73}, "files": [{"sha": "82eca4a18c88e58933a5d29b2bdfa873340f9eb9", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::WriteKind;\n+use borrow_check::{WriteKind, StorageDeadOrDrop};\n+use borrow_check::prefixes::IsPrefixOf;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::VarBindingForm;\n use rustc::mir::{BindingForm, BorrowKind, ClearCrossCrate, Field, Local};\n@@ -394,13 +395,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.buffer(&mut self.errors_buffer);\n     }\n \n+    /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n+    ///\n+    /// This means that some data referenced by `borrow` needs to live\n+    /// past the point where the StorageDeadOrDrop of `place` occurs.\n+    /// This is usually interpreted as meaning that `place` has too\n+    /// short a lifetime. (But sometimes it is more useful to report\n+    /// it as a more direct conflict between the execution of a\n+    /// `Drop::drop` with an aliasing borrow.)\n     pub(super) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         place_span: (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n+        debug!(\"report_borrowed_value_does_not_live_long_enough(\\\n+                {:?}, {:?}, {:?}, {:?}\\\n+                )\",\n+               context, borrow, place_span, kind\n+        );\n+\n         let drop_span = place_span.1;\n         let scope_tree = self.tcx.region_scope_tree(self.mir_def_id);\n         let root_place = self\n@@ -432,6 +447,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let borrow_reason = self.find_why_borrow_contains_point(context, borrow);\n \n+        if let Some(WriteKind::StorageDeadOrDrop(StorageDeadOrDrop::Destructor)) = kind\n+        {\n+            // If a borrow of path `B` conflicts with drop of `D` (and\n+            // we're not in the uninteresting case where `B` is a\n+            // prefix of `D`), then report this as a more interesting\n+            // destructor conflict.\n+            if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n+                self.report_borrow_conflicts_with_destructor(\n+                    context, borrow, borrow_reason, place_span, kind);\n+                return;\n+            }\n+        }\n+\n         let mut err = match &self.describe_place(&borrow.borrowed_place) {\n             Some(_) if self.is_place_thread_local(root_place) => {\n                 self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n@@ -495,6 +523,69 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n+    pub(super) fn report_borrow_conflicts_with_destructor(\n+        &mut self,\n+        context: Context,\n+        borrow: &BorrowData<'tcx>,\n+        borrow_reason: BorrowContainsPointReason<'tcx>,\n+        place_span: (&Place<'tcx>, Span),\n+        kind: Option<WriteKind>,\n+    ) {\n+        debug!(\n+            \"report_borrow_conflicts_with_destructor(\\\n+             {:?}, {:?}, {:?}, {:?} {:?}\\\n+             )\",\n+            context, borrow, borrow_reason, place_span, kind,\n+        );\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.var_or_use();\n+\n+        let mut err = self.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n+\n+        let drop_span = place_span.1;\n+\n+        let (what_was_dropped, dropped_ty) = {\n+            let place = place_span.0;\n+            let desc = match self.describe_place(place) {\n+                Some(name) => format!(\"`{}`\", name.as_str()),\n+                None => format!(\"temporary value\"),\n+            };\n+            let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            (desc, ty)\n+        };\n+\n+        let label = match dropped_ty.sty {\n+            ty::Adt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() => {\n+                match self.describe_place(&borrow.borrowed_place) {\n+                    Some(borrowed) =>\n+                        format!(\"here, drop of {D} needs exclusive access to `{B}`, \\\n+                                 because the type `{T}` implements the `Drop` trait\",\n+                                D=what_was_dropped, T=dropped_ty, B=borrowed),\n+                    None =>\n+                        format!(\"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n+                                D=what_was_dropped, T=dropped_ty),\n+                }\n+            }\n+            _ => format!(\"drop of {D} occurs here\", D=what_was_dropped),\n+        };\n+        err.span_label(drop_span, label);\n+\n+        // Only give this note and suggestion if they could be relevant\n+        match borrow_reason {\n+            BorrowContainsPointReason::Liveness {..}\n+            | BorrowContainsPointReason::DropLiveness {..} => {\n+                err.note(\"consider using a `let` binding to create a longer lived value\");\n+            }\n+            BorrowContainsPointReason::OutlivesFreeRegion {..} => (),\n+        }\n+\n+        self.report_why_borrow_contains_point(\n+            &mut err, borrow_reason, kind.map(|k| (k, place_span.0)));\n+\n+        err.buffer(&mut self.errors_buffer);\n+    }\n+\n     fn report_thread_local_value_does_not_live_long_enough(\n         &mut self,\n         drop_span: Span,"}, {"sha": "09fb37bccd96d888b0aedb48cd2d5e8cf09a42b1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -574,7 +574,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n                     (&Place::Local(local), span),\n-                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n+                        StorageDeadOrDrop::LocalStorageDead))),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n@@ -801,12 +802,21 @@ enum ReadKind {\n /// (For informational purposes only)\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteKind {\n-    StorageDeadOrDrop,\n+    StorageDeadOrDrop(StorageDeadOrDrop),\n     MutableBorrow(BorrowKind),\n     Mutate,\n     Move,\n }\n \n+/// Specify whether which case a StorageDeadOrDrop is in.\n+/// (For informational purposes only)\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum StorageDeadOrDrop {\n+    LocalStorageDead,\n+    BoxedStorageDead,\n+    Destructor,\n+}\n+\n /// When checking permissions for a place access, this flag is used to indicate that an immutable\n /// local place can be mutated.\n ///\n@@ -1035,7 +1045,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n                         (drop_place, span),\n-                        (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                        (Deep, Write(WriteKind::StorageDeadOrDrop(\n+                            StorageDeadOrDrop::Destructor))),\n                         LocalMutationIsAllowed::Yes,\n                         flow_state,\n                     );\n@@ -1062,15 +1073,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     //   Why? Because we do not schedule/emit\n                     //   `Drop(x)` in the MIR unless `x` needs drop in\n                     //   the first place.\n-                    //\n-                    // FIXME: Its possible this logic actually should\n-                    // be attached to the `StorageDead` statement\n-                    // rather than the `Drop`. See discussion on PR\n-                    // #52782.\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n                         (drop_place, span),\n-                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n+                            // rust-lang/rust#52059: distinguish\n+                            // between invaliding the backing storage\n+                            // vs running a destructor.\n+                            //\n+                            // See also: rust-lang/rust#52782,\n+                            // specifically #discussion_r206658948\n+                            StorageDeadOrDrop::BoxedStorageDead))),\n                         LocalMutationIsAllowed::Yes,\n                         flow_state,\n                     );\n@@ -1238,14 +1251,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n-                        WriteKind::StorageDeadOrDrop => {\n+                        WriteKind::StorageDeadOrDrop(_) => {\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n                                 context,\n                                 borrow,\n                                 place_span,\n-                                Some(kind),\n-                            );\n+                                Some(kind))\n                         }\n                         WriteKind::Mutate => {\n                             error_reported = true;\n@@ -1487,7 +1499,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns whether a borrow of this place is invalidated when the function\n+    /// Checks whether a borrow of this place is invalidated when the function\n     /// exits\n     fn check_for_invalidation_at_exit(\n         &mut self,\n@@ -1912,9 +1924,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Reservation(wk @ WriteKind::Move)\n             | Write(wk @ WriteKind::Move)\n-            | Reservation(wk @ WriteKind::StorageDeadOrDrop)\n+            | Reservation(wk @ WriteKind::StorageDeadOrDrop(_))\n             | Reservation(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n-            | Write(wk @ WriteKind::StorageDeadOrDrop)\n+            | Write(wk @ WriteKind::StorageDeadOrDrop(_))\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n                 if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     if self.tcx.migrate_borrowck() {\n@@ -1929,7 +1941,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         error_access = match wk {\n                             WriteKind::MutableBorrow(_) => AccessKind::MutableBorrow,\n                             WriteKind::Move => AccessKind::Move,\n-                            WriteKind::StorageDeadOrDrop |\n+                            WriteKind::StorageDeadOrDrop(_) |\n                             WriteKind::Mutate => AccessKind::Mutate,\n                         };\n                         self.report_mutability_error("}, {"sha": "61972629e7b855f5b845dc16b45ba628eabae061", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -160,7 +160,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         format!(\"borrow later used here, when `{}` is dropped\", local_name),\n                     );\n \n-                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n+                    if let Some((WriteKind::StorageDeadOrDrop(_), place)) = kind_place {\n                         if let Place::Local(borrowed_local) = place {\n                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n                             let borrowed_local_scope ="}, {"sha": "cd760746c125aa0d3b8229f3aefd76e375fc14b8", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -16,7 +16,7 @@ use borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n use borrow_check::{Context, ContextKind};\n use borrow_check::{LocalMutationIsAllowed, MutateMode};\n use borrow_check::ArtificialField;\n-use borrow_check::{ReadKind, WriteKind};\n+use borrow_check::{ReadKind, WriteKind, StorageDeadOrDrop};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::path_utils::*;\n use dataflow::move_paths::indexes::BorrowIndex;\n@@ -154,7 +154,8 @@ impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tc\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n                     &Place::Local(local),\n-                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop(\n+                        StorageDeadOrDrop::LocalStorageDead))),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n@@ -347,7 +348,8 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n                         drop_place,\n-                        (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                        (Deep, Write(WriteKind::StorageDeadOrDrop(\n+                            StorageDeadOrDrop::Destructor))),\n                         LocalMutationIsAllowed::Yes,\n                     );\n                 }"}, {"sha": "24197c9e4b88f6c0d844677471974466c75645db", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -2187,6 +2187,63 @@ fn main() {\n ```\n \"##,\n \n+E0713: r##\"\n+This error occurs when an attempt is made to borrow state past the end of the\n+lifetime of a type that implements the `Drop` trait.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0713\n+#![feature(nll)]\n+\n+pub struct S<'a> { data: &'a mut String }\n+\n+impl<'a> Drop for S<'a> {\n+    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n+}\n+\n+fn demo<'a>(s: S<'a>) -> &'a mut String { let p = &mut *s.data; p }\n+```\n+\n+Here, `demo` tries to borrow the string data held within its\n+argument `s` and then return that borrow. However, `S` is\n+declared as implementing `Drop`.\n+\n+Structs implementing the `Drop` trait have an implicit destructor that\n+gets called when they go out of scope. This destructor gets exclusive\n+access to the fields of the struct when it runs.\n+\n+This means that when `s` reaches the end of `demo`, its destructor\n+gets exclusive access to its `&mut`-borrowed string data.  allowing\n+another borrow of that string data (`p`), to exist across the drop of\n+`s` would be a violation of the principle that `&mut`-borrows have\n+exclusive, unaliased access to their referenced data.\n+\n+This error can be fixed by changing `demo` so that the destructor does\n+not run while the string-data is borrowed; for example by taking `S`\n+by reference:\n+\n+```\n+#![feature(nll)]\n+\n+pub struct S<'a> { data: &'a mut String }\n+\n+impl<'a> Drop for S<'a> {\n+    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n+}\n+\n+fn demo<'a>(s: &'a mut S<'a>) -> &'a mut String { let p = &mut *(*s).data; p }\n+```\n+\n+Note that this approach needs a reference to S with lifetime `'a`.\n+Nothing shorter than `'a` will suffice: a shorter lifetime would imply\n+that after `demo` finishes excuting, something else (such as the\n+destructor!) could access `s.data` after the end of that shorter\n+lifetime, which would again violate the `&mut`-borrow's exclusive\n+access.\n+\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "82617ee10747000c9a07cafc7d8b173d075345b8", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -573,6 +573,22 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n+    fn cannot_borrow_across_destructor(\n+        self,\n+        borrow_span: Span,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            borrow_span,\n+            E0713,\n+            \"borrow may still be in use when destructor runs{OGN}\",\n+            OGN = o\n+        );\n+\n+        self.cancel_if_wrong_origin(err, o)\n+    }\n+\n     fn path_does_not_live_long_enough(\n         self,\n         span: Span,"}, {"sha": "5c70294a1b90c0abc22028a7e7937939c078212b", "filename": "src/test/ui/borrowck/borrowck-fn-in-const-c.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-fn-in-const-c.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-fn-in-const-c.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-fn-in-const-c.nll.stderr?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -1,13 +1,13 @@\n-error[E0597]: `local.inner` does not live long enough\n+error[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/borrowck-fn-in-const-c.rs:27:16\n    |\n LL |         return &local.inner; //~ ERROR does not live long enough\n-   |                ^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                ^^^^^^^^^^^^\n LL |     }\n-   |     - `local.inner` dropped here while still borrowed\n+   |     - here, drop of `local` needs exclusive access to `local.inner`, because the type `DropString` implements the `Drop` trait\n    |\n    = note: borrowed value must be valid for the static lifetime...\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0713`."}, {"sha": "70d819f0f467819e26b60039e2280a5aa60302d7", "filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.migrate.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -1,11 +1,11 @@\n-warning[E0597]: `*s.0` does not live long enough\n+warning[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:63:5\n    |\n-LL |     &mut *s.0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-   |     ^^^^^^^^^ borrowed value does not live long enough\n+LL |     &mut *s.0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+   |     ^^^^^^^^^\n ...\n LL | }\n-   | - `*s.0` dropped here while still borrowed\n+   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 62:14...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:62:14\n@@ -16,14 +16,14 @@ LL | fn scribbled<'a>(s: Scribble<'a>) -> &'a mut u32 {\n            It represents potential unsoundness in your code.\n            This warning will become a hard error in the future.\n \n-warning[E0597]: `*s.0` does not live long enough\n+warning[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:73:5\n    |\n-LL |     &mut *(*s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-   |     ^^^^^^^^^^^^ borrowed value does not live long enough\n+LL |     &mut *(*s).0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+   |     ^^^^^^^^^^^^\n ...\n LL | }\n-   | - `*s.0` dropped here while still borrowed\n+   | - here, drop of `*s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 72:20...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:72:20\n@@ -34,14 +34,14 @@ LL | fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 {\n            It represents potential unsoundness in your code.\n            This warning will become a hard error in the future.\n \n-warning[E0597]: `*s.0` does not live long enough\n+warning[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:83:5\n    |\n-LL |     &mut *(**s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-   |     ^^^^^^^^^^^^^ borrowed value does not live long enough\n+LL |     &mut *(**s).0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+   |     ^^^^^^^^^^^^^\n ...\n LL | }\n-   | - `*s.0` dropped here while still borrowed\n+   | - here, drop of `**s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 82:26...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:82:26\n@@ -66,4 +66,4 @@ LL | | }\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0713`."}, {"sha": "72ec5affb182b64fb44684d42fec372865f90cfb", "filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.nll.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -1,41 +1,41 @@\n-error[E0597]: `*s.0` does not live long enough\n+error[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:63:5\n    |\n-LL |     &mut *s.0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-   |     ^^^^^^^^^ borrowed value does not live long enough\n+LL |     &mut *s.0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+   |     ^^^^^^^^^\n ...\n LL | }\n-   | - `*s.0` dropped here while still borrowed\n+   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 62:14...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:62:14\n    |\n LL | fn scribbled<'a>(s: Scribble<'a>) -> &'a mut u32 {\n    |              ^^\n \n-error[E0597]: `*s.0` does not live long enough\n+error[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:73:5\n    |\n-LL |     &mut *(*s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-   |     ^^^^^^^^^^^^ borrowed value does not live long enough\n+LL |     &mut *(*s).0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+   |     ^^^^^^^^^^^^\n ...\n LL | }\n-   | - `*s.0` dropped here while still borrowed\n+   | - here, drop of `*s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 72:20...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:72:20\n    |\n LL | fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 {\n    |                    ^^\n \n-error[E0597]: `*s.0` does not live long enough\n+error[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:83:5\n    |\n-LL |     &mut *(**s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-   |     ^^^^^^^^^^^^^ borrowed value does not live long enough\n+LL |     &mut *(**s).0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+   |     ^^^^^^^^^^^^^\n ...\n LL | }\n-   | - `*s.0` dropped here while still borrowed\n+   | - here, drop of `**s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 82:26...\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:82:26\n@@ -45,4 +45,4 @@ LL | fn boxed_boxed_scribbled<'a>(s: Box<Box<Scribble<'a>>>) -> &'a mut u32 {\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0713`."}, {"sha": "2af05172d24db05cddf4048c3b4374378154e2aa", "filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -60,8 +60,8 @@ fn boxed_boxed_borrowed_scribble<'a>(s: Box<Box<&'a mut Scribble>>) -> &'a mut u\n // this should be an error. (Which is perhaps the essence of why\n // rust-lang/rust#45696 arose in the first place.)\n fn scribbled<'a>(s: Scribble<'a>) -> &'a mut u32 {\n-    &mut *s.0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-    //[migrate]~^ WARNING `*s.0` does not live long enough [E0597]\n+    &mut *s.0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+    //[migrate]~^ WARNING borrow may still be in use when destructor runs [E0713]\n     //[migrate]~| WARNING This error has been downgraded to a warning for backwards compatibility\n }\n \n@@ -70,8 +70,8 @@ fn scribbled<'a>(s: Scribble<'a>) -> &'a mut u32 {\n // (But again, AST-borrowck was not smart enogh to know that this\n // should be an error.)\n fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 {\n-    &mut *(*s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-    //[migrate]~^ WARNING `*s.0` does not live long enough [E0597]\n+    &mut *(*s).0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+    //[migrate]~^ WARNING borrow may still be in use when destructor runs [E0713]\n     //[migrate]~| WARNING This error has been downgraded to a warning for backwards compatibility\n }\n \n@@ -80,8 +80,8 @@ fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 {\n // (But again, AST-borrowck was not smart enogh to know that this\n // should be an error.)\n fn boxed_boxed_scribbled<'a>(s: Box<Box<Scribble<'a>>>) -> &'a mut u32 {\n-    &mut *(**s).0 //[nll]~ ERROR `*s.0` does not live long enough [E0597]\n-    //[migrate]~^ WARNING `*s.0` does not live long enough [E0597]\n+    &mut *(**s).0 //[nll]~ ERROR borrow may still be in use when destructor runs [E0713]\n+    //[migrate]~^ WARNING borrow may still be in use when destructor runs [E0713]\n     //[migrate]~| WARNING This error has been downgraded to a warning for backwards compatibility\n }\n "}, {"sha": "3508f3033e62efabff66c37b9042230039e4a25e", "filename": "src/test/ui/nll/issue-31567.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fnll%2Fissue-31567.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fnll%2Fissue-31567.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-31567.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -19,7 +19,7 @@ struct VecWrapper<'a>(&'a mut S);\n struct S(Box<u32>);\n \n fn get_dangling<'a>(v: VecWrapper<'a>) -> &'a u32 {\n-    let s_inner: &'a S = &*v.0; //~ ERROR `*v.0` does not live long enough\n+    let s_inner: &'a S = &*v.0; //~ ERROR borrow may still be in use when destructor runs [E0713]\n     &s_inner.0\n }\n "}, {"sha": "63330f303198156a2348ecf79ecebe12d700c537", "filename": "src/test/ui/nll/issue-31567.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fnll%2Fissue-31567.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fnll%2Fissue-31567.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-31567.stderr?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -1,11 +1,11 @@\n-error[E0597]: `*v.0` does not live long enough\n+error[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-31567.rs:22:26\n    |\n-LL |     let s_inner: &'a S = &*v.0; //~ ERROR `*v.0` does not live long enough\n-   |                          ^^^^^ borrowed value does not live long enough\n+LL |     let s_inner: &'a S = &*v.0; //~ ERROR borrow may still be in use when destructor runs [E0713]\n+   |                          ^^^^^\n LL |     &s_inner.0\n LL | }\n-   | - `*v.0` dropped here while still borrowed\n+   | - here, drop of `v` needs exclusive access to `*v.0`, because the type `VecWrapper<'_>` implements the `Drop` trait\n    |\n note: borrowed value must be valid for the lifetime 'a as defined on the function body at 21:17...\n   --> $DIR/issue-31567.rs:21:17\n@@ -15,4 +15,4 @@ LL | fn get_dangling<'a>(v: VecWrapper<'a>) -> &'a u32 {\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0713`."}, {"sha": "fff73c6d0fa9c360e975388b7d2abd9fb61563e9", "filename": "src/test/ui/nll/issue-52059-report-when-borrow-and-drop-conflict.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.rs?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -0,0 +1,33 @@\n+// rust-lang/rust#52059: Regardless of whether you are moving out of a\n+// Drop type or just introducing an inadvertant alias via a borrow of\n+// one of its fields, it is useful to be reminded of the significance\n+// of the fact that the type implements Drop.\n+\n+#![feature(nll)]\n+#![allow(dead_code)]\n+\n+pub struct S<'a> { url: &'a mut String }\n+\n+impl<'a> Drop for S<'a> { fn drop(&mut self) { } }\n+\n+fn finish_1(s: S) -> &mut String {\n+    s.url\n+}\n+//~^^ ERROR borrow may still be in use when destructor runs\n+\n+fn finish_2(s: S) -> &mut String {\n+    let p = &mut *s.url; p\n+}\n+//~^^ ERROR borrow may still be in use when destructor runs\n+\n+fn finish_3(s: S) -> &mut String {\n+    let p: &mut _ = s.url; p\n+}\n+//~^^ ERROR borrow may still be in use when destructor runs\n+\n+fn finish_4(s: S) -> &mut String {\n+    let p = s.url; p\n+}\n+//~^^ ERROR cannot move out of type `S<'_>`, which implements the `Drop` trait\n+\n+fn main() {}"}, {"sha": "71c97b7ad6b80091d0bf8e410dc02d307cec57d2", "filename": "src/test/ui/nll/issue-52059-report-when-borrow-and-drop-conflict.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.stderr?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -0,0 +1,61 @@\n+error[E0713]: borrow may still be in use when destructor runs\n+  --> $DIR/issue-52059-report-when-borrow-and-drop-conflict.rs:14:5\n+   |\n+LL |     s.url\n+   |     ^^^^^\n+LL | }\n+   | - here, drop of `s` needs exclusive access to `*s.url`, because the type `S<'_>` implements the `Drop` trait\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...\n+  --> $DIR/issue-52059-report-when-borrow-and-drop-conflict.rs:13:1\n+   |\n+LL | / fn finish_1(s: S) -> &mut String {\n+LL | |     s.url\n+LL | | }\n+   | |_^\n+\n+error[E0713]: borrow may still be in use when destructor runs\n+  --> $DIR/issue-52059-report-when-borrow-and-drop-conflict.rs:19:13\n+   |\n+LL |     let p = &mut *s.url; p\n+   |             ^^^^^^^^^^^\n+LL | }\n+   | - here, drop of `s` needs exclusive access to `*s.url`, because the type `S<'_>` implements the `Drop` trait\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 18:1...\n+  --> $DIR/issue-52059-report-when-borrow-and-drop-conflict.rs:18:1\n+   |\n+LL | / fn finish_2(s: S) -> &mut String {\n+LL | |     let p = &mut *s.url; p\n+LL | | }\n+   | |_^\n+\n+error[E0713]: borrow may still be in use when destructor runs\n+  --> $DIR/issue-52059-report-when-borrow-and-drop-conflict.rs:24:21\n+   |\n+LL |     let p: &mut _ = s.url; p\n+   |                     ^^^^^\n+LL | }\n+   | - here, drop of `s` needs exclusive access to `*s.url`, because the type `S<'_>` implements the `Drop` trait\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 23:1...\n+  --> $DIR/issue-52059-report-when-borrow-and-drop-conflict.rs:23:1\n+   |\n+LL | / fn finish_3(s: S) -> &mut String {\n+LL | |     let p: &mut _ = s.url; p\n+LL | | }\n+   | |_^\n+\n+error[E0509]: cannot move out of type `S<'_>`, which implements the `Drop` trait\n+  --> $DIR/issue-52059-report-when-borrow-and-drop-conflict.rs:29:13\n+   |\n+LL |     let p = s.url; p\n+   |             ^^^^^\n+   |             |\n+   |             cannot move out of here\n+   |             help: consider borrowing here: `&s.url`\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors occurred: E0509, E0713.\n+For more information about an error, try `rustc --explain E0509`."}, {"sha": "c94558f12bbde9c04794ecee9fdc117d846b1391", "filename": "src/test/ui/span/borrowck-ref-into-rvalue.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.nll.stderr?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -1,16 +1,16 @@\n-error[E0597]: borrowed value does not live long enough\n-  --> $DIR/borrowck-ref-into-rvalue.rs:13:11\n+error[E0713]: borrow may still be in use when destructor runs\n+  --> $DIR/borrowck-ref-into-rvalue.rs:14:14\n    |\n-LL |     match Some(\"Hello\".to_string()) {\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL |         Some(ref m) => {\n+   |              ^^^^^\n ...\n LL |     }\n-   |     - temporary value only lives until here\n+   |     - drop of temporary value occurs here\n LL |     println!(\"{}\", *msg);\n    |                    ---- borrow later used here\n    |\n    = note: consider using a `let` binding to create a longer lived value\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0713`."}, {"sha": "1f72b78ebc76d371b3d89581dfcb2b8c68b53b8f", "filename": "src/test/ui/span/issue28498-reject-ex1.nll.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7714c430ae1f771001fc0a1b083752485baba56e/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr?ref=7714c430ae1f771001fc0a1b083752485baba56e", "patch": "@@ -1,17 +1,18 @@\n-error[E0597]: `foo.data` does not live long enough\n+error[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue28498-reject-ex1.rs:44:29\n    |\n LL |     foo.data[0].1.set(Some(&foo.data[1]));\n-   |                             ^^^^^^^^ borrowed value does not live long enough\n+   |                             ^^^^^^^^\n ...\n LL | }\n    | -\n    | |\n-   | `foo.data` dropped here while still borrowed\n+   | here, drop of `foo` needs exclusive access to `foo.data`, because the type `Foo<Concrete<'_>>` implements the `Drop` trait\n    | borrow later used here, when `foo` is dropped\n    |\n+   = note: consider using a `let` binding to create a longer lived value\n    = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0713`."}]}