{"sha": "ce8b317558a83021b7ea0f40c5719995e234da03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlOGIzMTc1NThhODMwMjFiN2VhMGY0MGM1NzE5OTk1ZTIzNGRhMDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-11T21:58:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-19T17:53:06Z"}, "message": "rustc_trans: Tidy up some style and line lengths\n\nMatch the surrounding style in the rest of the `rustc_trans::trans` module.", "tree": {"sha": "cedfaeb85cb6f67ef9ba07e65e2efbbc6ed2b95d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cedfaeb85cb6f67ef9ba07e65e2efbbc6ed2b95d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce8b317558a83021b7ea0f40c5719995e234da03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce8b317558a83021b7ea0f40c5719995e234da03", "html_url": "https://github.com/rust-lang/rust/commit/ce8b317558a83021b7ea0f40c5719995e234da03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce8b317558a83021b7ea0f40c5719995e234da03/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "181dbd71d6e979215c43356d1b9b72898b649dc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/181dbd71d6e979215c43356d1b9b72898b649dc4", "html_url": "https://github.com/rust-lang/rust/commit/181dbd71d6e979215c43356d1b9b72898b649dc4"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "4c936ddbcef00224338af15e1e1b59810db382f8", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce8b317558a83021b7ea0f40c5719995e234da03/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8b317558a83021b7ea0f40c5719995e234da03/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ce8b317558a83021b7ea0f40c5719995e234da03", "patch": "@@ -670,7 +670,8 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n-                    let llfn = foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name[..]);\n+                    let llfn = foreign::register_foreign_item_fn(ccx, fn_ty.abi,\n+                                                                 t, &name);\n                     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n                     attributes::from_fn_attrs(ccx, &attrs, llfn);\n                     llfn"}, {"sha": "e0ab5dec98dfeb9421d060ca8134e931ff4d1abe", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ce8b317558a83021b7ea0f40c5719995e234da03/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8b317558a83021b7ea0f40c5719995e234da03/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=ce8b317558a83021b7ea0f40c5719995e234da03", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n //! Declare various LLVM values.\n //!\n-//! Prefer using functions and methods from this module rather than calling LLVM functions\n-//! directly. These functions do some additional work to ensure we do the right thing given\n-//! the preconceptions of trans.\n+//! Prefer using functions and methods from this module rather than calling LLVM\n+//! functions directly. These functions do some additional work to ensure we do\n+//! the right thing given the preconceptions of trans.\n //!\n //! Some useful guidelines:\n //!\n-//! * Use declare_* family of methods if you are declaring, but are not interested in defining the\n-//! ValueRef they return.\n+//! * Use declare_* family of methods if you are declaring, but are not\n+//!   interested in defining the ValueRef they return.\n //! * Use define_* family of methods when you might be defining the ValueRef.\n //! * When in doubt, define.\n use llvm::{self, ValueRef};\n@@ -37,8 +37,8 @@ use libc::c_uint;\n \n /// Declare a global value.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will return its ValueRef\n-/// instead.\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// return its ValueRef instead.\n pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRef {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n@@ -54,10 +54,10 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n ///\n /// For rust functions use `declare_rust_fn` instead.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will update the\n-/// declaration and return existing ValueRef instead.\n-pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type,\n-                  output: ty::FnOutput) -> ValueRef {\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing ValueRef instead.\n+pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n+                  ty: Type, output: ty::FnOutput) -> ValueRef {\n     debug!(\"declare_fn(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n@@ -67,7 +67,8 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n-    // Function addresses in Rust are never significant, allowing functions to be merged.\n+    // Function addresses in Rust are never significant, allowing functions to\n+    // be merged.\n     llvm::SetUnnamedAddr(llfn, true);\n \n     if output == ty::FnDiverging {\n@@ -88,23 +89,25 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n \n /// Declare a C ABI function.\n ///\n-/// Only use this for foreign function ABIs and glue. For Rust functions use `declare_rust_fn`\n-/// instead.\n+/// Only use this for foreign function ABIs and glue. For Rust functions use\n+/// `declare_rust_fn` instead.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will update the\n-/// declaration and return existing ValueRef instead.\n-pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type, output: ty::Ty) -> ValueRef {\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing ValueRef instead.\n+pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n+                   output: ty::Ty) -> ValueRef {\n     declare_fn(ccx, name, llvm::CCallConv, fn_type, ty::FnConverging(output))\n }\n \n \n /// Declare a Rust function.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will update the\n-/// declaration and return existing ValueRef instead.\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing ValueRef instead.\n pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                  fn_type: ty::Ty<'tcx>) -> ValueRef {\n-    debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name, fn_type.repr(ccx.tcx()));\n+    debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name,\n+           fn_type.repr(ccx.tcx()));\n     let fn_type = monomorphize::normalize_associated_type(ccx.tcx(), &fn_type);\n     debug!(\"declare_rust_fn (after normalised associated types) fn_type={}\",\n            fn_type.repr(ccx.tcx()));\n@@ -131,7 +134,8 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n     debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n \n-    // it is ok to directly access sig.0.output because we erased all late-bound-regions above\n+    // it is ok to directly access sig.0.output because we erased all\n+    // late-bound-regions above\n     let llfn = declare_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output);\n     attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n     llfn\n@@ -140,8 +144,8 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n \n /// Declare a Rust function with internal linkage.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will update the\n-/// declaration and return existing ValueRef instead.\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing ValueRef instead.\n pub fn declare_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                           fn_type: ty::Ty<'tcx>) -> ValueRef {\n     let llfn = declare_rust_fn(ccx, name, fn_type);\n@@ -152,10 +156,10 @@ pub fn declare_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &s\n \n /// Declare a global with an intention to define it.\n ///\n-/// Use this function when you intend to define a global. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a global. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n         None\n@@ -169,10 +173,10 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n ///\n /// For rust functions use `define_rust_fn` instead.\n ///\n-/// Use this function when you intend to define a function. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a function. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, fn_type: Type,\n                  output: ty::FnOutput) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n@@ -185,13 +189,13 @@ pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, fn_ty\n \n /// Declare a C ABI function with an intention to define it.\n ///\n-/// Use this function when you intend to define a function. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a function. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n ///\n-/// Only use this for foreign function ABIs and glue. For Rust functions use `declare_rust_fn`\n-/// instead.\n+/// Only use this for foreign function ABIs and glue. For Rust functions use\n+/// `declare_rust_fn` instead.\n pub fn define_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n                   output: ty::Ty) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n@@ -204,10 +208,10 @@ pub fn define_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n \n /// Declare a Rust function with an intention to define it.\n ///\n-/// Use this function when you intend to define a function. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a function. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                 fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n@@ -220,10 +224,10 @@ pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n \n /// Declare a Rust function with an intention to define it.\n ///\n-/// Use this function when you intend to define a function. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a function. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n pub fn define_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                          fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n@@ -250,8 +254,8 @@ fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n             (llvm::LLVMIsDeclaration(val) != 0,\n              linkage == llvm::AvailableExternallyLinkage as c_uint)\n         };\n-        debug!(\"get_defined_value: found {:?} value (declaration: {}, aext_link: {})\", name,\n-               declaration, aext_link);\n+        debug!(\"get_defined_value: found {:?} value (declaration: {}, \\\n+                aext_link: {})\", name, declaration, aext_link);\n         if !declaration || aext_link {\n             Some(val)\n         } else {"}]}