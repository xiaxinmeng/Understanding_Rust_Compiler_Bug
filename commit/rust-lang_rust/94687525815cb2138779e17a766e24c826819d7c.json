{"sha": "94687525815cb2138779e17a766e24c826819d7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0Njg3NTI1ODE1Y2IyMTM4Nzc5ZTE3YTc2NmUyNGM4MjY4MTlkN2M=", "commit": {"author": {"name": "Adam Reichold", "email": "adam.reichold@t-online.de", "date": "2020-08-01T12:18:11Z"}, "committer": {"name": "Adam Reichold", "email": "adam.reichold@t-online.de", "date": "2020-08-05T14:57:02Z"}, "message": "Query maximum vector count on Linux and macOS\n\nBoth Linux and MacOS enforce limits on the vector count when performing vectored\nI/O via the readv and writev system calls and return EINVAL when these limits\nare exceeded. This changes the standard library to handle those limits as short\nreads and writes to avoid forcing its users to query these limits using\nplatform specific mechanisms.", "tree": {"sha": "b946ffc716e0a90a3122da17b5ece437b070fe20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b946ffc716e0a90a3122da17b5ece437b070fe20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94687525815cb2138779e17a766e24c826819d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94687525815cb2138779e17a766e24c826819d7c", "html_url": "https://github.com/rust-lang/rust/commit/94687525815cb2138779e17a766e24c826819d7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94687525815cb2138779e17a766e24c826819d7c/comments", "author": {"login": "adamreichold", "id": 12997846, "node_id": "MDQ6VXNlcjEyOTk3ODQ2", "avatar_url": "https://avatars.githubusercontent.com/u/12997846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamreichold", "html_url": "https://github.com/adamreichold", "followers_url": "https://api.github.com/users/adamreichold/followers", "following_url": "https://api.github.com/users/adamreichold/following{/other_user}", "gists_url": "https://api.github.com/users/adamreichold/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamreichold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamreichold/subscriptions", "organizations_url": "https://api.github.com/users/adamreichold/orgs", "repos_url": "https://api.github.com/users/adamreichold/repos", "events_url": "https://api.github.com/users/adamreichold/events{/privacy}", "received_events_url": "https://api.github.com/users/adamreichold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adamreichold", "id": 12997846, "node_id": "MDQ6VXNlcjEyOTk3ODQ2", "avatar_url": "https://avatars.githubusercontent.com/u/12997846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamreichold", "html_url": "https://github.com/adamreichold", "followers_url": "https://api.github.com/users/adamreichold/followers", "following_url": "https://api.github.com/users/adamreichold/following{/other_user}", "gists_url": "https://api.github.com/users/adamreichold/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamreichold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamreichold/subscriptions", "organizations_url": "https://api.github.com/users/adamreichold/orgs", "repos_url": "https://api.github.com/users/adamreichold/repos", "events_url": "https://api.github.com/users/adamreichold/events{/privacy}", "received_events_url": "https://api.github.com/users/adamreichold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b84156c6ee2b4e707dc32f5a516e3143ab924d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b84156c6ee2b4e707dc32f5a516e3143ab924d3", "html_url": "https://github.com/rust-lang/rust/commit/8b84156c6ee2b4e707dc32f5a516e3143ab924d3"}], "stats": {"total": 38, "additions": 36, "deletions": 2}, "files": [{"sha": "675528bd5267bae52a6af27dc03462e1d78cd48f", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/94687525815cb2138779e17a766e24c826819d7c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94687525815cb2138779e17a766e24c826819d7c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=94687525815cb2138779e17a766e24c826819d7c", "patch": "@@ -26,6 +26,27 @@ const READ_LIMIT: usize = c_int::MAX as usize - 1;\n #[cfg(not(target_os = \"macos\"))]\n const READ_LIMIT: usize = libc::ssize_t::MAX as usize;\n \n+#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+fn max_iov() -> c_int {\n+    let ret = unsafe {\n+        libc::sysconf(\n+            #[cfg(target_os = \"linux\")]\n+            libc::_SC_IOV_MAX,\n+            #[cfg(target_os = \"macos\")]\n+            libc::_SC_UIO_MAXIOV,\n+        )\n+    };\n+\n+    // 1024 is the default value on modern Linux systems\n+    // and hopefully more useful than `c_int::MAX`.\n+    if ret > 0 { ret as c_int } else { 1024 }\n+}\n+\n+#[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+fn max_iov() -> c_int {\n+    c_int::MAX\n+}\n+\n impl FileDesc {\n     pub fn new(fd: c_int) -> FileDesc {\n         FileDesc { fd }\n@@ -54,7 +75,7 @@ impl FileDesc {\n             libc::readv(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n+                cmp::min(bufs.len(), max_iov() as usize) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -111,7 +132,7 @@ impl FileDesc {\n             libc::writev(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n+                cmp::min(bufs.len(), max_iov() as usize) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -256,3 +277,16 @@ impl Drop for FileDesc {\n         let _ = unsafe { libc::close(self.fd) };\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{FileDesc, IoSlice};\n+\n+    #[test]\n+    fn limit_vector_count() {\n+        let stdout = FileDesc { fd: 1 };\n+        let bufs = (0..1500).map(|_| IoSlice::new(&[])).collect::<Vec<_>>();\n+\n+        assert!(stdout.write_vectored(&bufs).is_ok());\n+    }\n+}"}]}