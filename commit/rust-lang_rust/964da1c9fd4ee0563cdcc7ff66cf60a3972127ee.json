{"sha": "964da1c9fd4ee0563cdcc7ff66cf60a3972127ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NGRhMWM5ZmQ0ZWUwNTYzY2RjYzdmZjY2Y2Y2MGEzOTcyMTI3ZWU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2013-09-26T12:54:48Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2013-09-26T18:17:34Z"}, "message": "Document std::ops.\n\nAdded an overview with a 'real' example, as well as toy implementations of all of\nthe traits.\n\nCloses #9356.", "tree": {"sha": "614e2350cf2dfbe4b7ffc982178ebe41c09dce54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/614e2350cf2dfbe4b7ffc982178ebe41c09dce54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/964da1c9fd4ee0563cdcc7ff66cf60a3972127ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/964da1c9fd4ee0563cdcc7ff66cf60a3972127ee", "html_url": "https://github.com/rust-lang/rust/commit/964da1c9fd4ee0563cdcc7ff66cf60a3972127ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/964da1c9fd4ee0563cdcc7ff66cf60a3972127ee/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a268a1c4bb3867e4f8b050e07fd216e561b50521", "url": "https://api.github.com/repos/rust-lang/rust/commits/a268a1c4bb3867e4f8b050e07fd216e561b50521", "html_url": "https://github.com/rust-lang/rust/commit/a268a1c4bb3867e4f8b050e07fd216e561b50521"}], "stats": {"total": 412, "additions": 410, "deletions": 2}, "files": [{"sha": "2f3e3eb9ca89a5b8cade45b36e17685f069b400a", "filename": "src/libstd/ops.rs", "status": "modified", "additions": 410, "deletions": 2, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/964da1c9fd4ee0563cdcc7ff66cf60a3972127ee/src%2Flibstd%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964da1c9fd4ee0563cdcc7ff66cf60a3972127ee/src%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fops.rs?ref=964da1c9fd4ee0563cdcc7ff66cf60a3972127ee", "patch": "@@ -8,75 +8,483 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Traits for the built-in operators\n-\n+// So we don't have to document the actual methods on the traits.\n #[allow(missing_doc)];\n \n+/*!\n+ *\n+ * Traits for the built-in operators. Implementing these traits allows you to get\n+ * an effect similar to oveloading operators.\n+ * \n+ * The values for the right hand side of an operator are automatically\n+ * borrowed, so `a + b` is sugar for `a.add(&b)`.\n+ * \n+ * # Example\n+ * \n+ * This example creates a `Point` struct that implements `Add` and `Sub`, and then\n+ * demonstrates adding and subtracting two `Point`s.\n+ * \n+ * ```rust\n+ * use std::ops::Add;\n+ * use std::ops::Sub;\n+ * \n+ * struct Point {\n+ *     x: int,\n+ *     y: int\n+ * }\n+ * \n+ * impl Add<Point, Point> for Point {\n+ *     fn add(&self, other: &Point) -> Point {\n+ *         Point {x: self.x + other.x, y: self.y + other.y}\n+ *     }\n+ * }\n+ * \n+ * impl Sub<Point, Point> for Point {\n+ *     fn sub(&self, other: &Point) -> Point {\n+ *         Point {x: self.x - other.x, y: self.y - other.y}\n+ *     }\n+ * }\n+ * fn main() {\n+ *     println(format!(\"{:?}\", Point {x: 1, y: 0} + Point {x: 2, y: 3}));\n+ *     println(format!(\"{:?}\", Point {x: 1, y: 0} - Point {x: 2, y: 3}));\n+ * }\n+ * ```\n+ * \n+ * See the documentation for each trait for a minimum implementation that prints\n+ * something to the screen.\n+ * \n+ */\n+\n+/**\n+ * \n+ * The `Drop` trait is used to run some code when a value goes out of scope. This\n+ * is sometimes called a 'destructor'.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Drop`. The `drop` method is called when `_x` goes\n+ * out of scope, and therefore `main` prints `Dropping!`.\n+ * \n+ * ```rust\n+ * use std::ops::Drop;\n+ * \n+ * struct HasDrop;\n+ * \n+ * impl Drop for HasDrop {\n+ *   fn drop(&mut self) {\n+ *       println(\"Dropping!\");\n+ *   }\n+ * }\n+ * \n+ * fn main() {\n+ *   let _x = HasDrop;\n+ * }\n+ * ```\n+ */\n #[lang=\"drop\"]\n pub trait Drop {\n     fn drop(&mut self);\n }\n \n+/**\n+ * \n+ * The `Add` trait is used to override the functionality of `+`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n+ * calling `add`, and therefore, `main` prints `Adding!`.\n+ * \n+ * ```rust\n+ * use std::ops::Add;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Add<Foo, Foo> for Foo {\n+ *     fn add(&self, _rhs: &Foo) -> Foo {\n+ *       println(\"Adding!\");\n+ *       *self\n+ *   }\n+ * }\n+ * \n+ * fn main() {\n+ *   Foo + Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"add\"]\n pub trait Add<RHS,Result> {\n     fn add(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `Sub` trait is used to override the functionality of `-`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n+ * calling `sub`, and therefore, `main` prints `Subtracting!`.\n+ * \n+ * ```\n+ * use std::ops::Sub;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Sub<Foo, Foo> for Foo {\n+ *     fn sub(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Subtracting!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo - Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"sub\"]\n pub trait Sub<RHS,Result> {\n     fn sub(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `Mul` trait is used to override the functionality of `*`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n+ * calling `mul`, and therefore, `main` prints `Multiplying!`.\n+ * \n+ * ```rust\n+ * use std::ops::Mul;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Mul<Foo, Foo> for Foo {\n+ *     fn mul(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Multiplying!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo * Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"mul\"]\n pub trait Mul<RHS,Result> {\n     fn mul(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `Div` trait is used to override the functionality of `/`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n+ * calling `div`, and therefore, `main` prints `Dividing!`.\n+ * \n+ * ```\n+ * use std::ops::Div;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Div<Foo, Foo> for Foo {\n+ *     fn div(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Dividing!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo / Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"div\"]\n pub trait Div<RHS,Result> {\n     fn div(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `Rem` trait is used to override the functionality of `%`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implemtnation of `Rem`. When `Foo % Foo` happens, it ends up\n+ * calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n+ * \n+ * ```\n+ * use std::ops::Rem;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Rem<Foo, Foo> for Foo {\n+ *     fn rem(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Remainder-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo % Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"rem\"]\n pub trait Rem<RHS,Result> {\n     fn rem(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `Neg` trait is used to override the functionality of unary `-`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implemtnation of `Neg`. When `-Foo` happens, it ends up calling\n+ * `neg`, and therefore, `main` prints `Negating!`.\n+ * \n+ * ```\n+ * use std::ops::Neg;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Neg<Foo> for Foo {\n+ *     fn neg(&self) -> Foo {\n+ *         println(\"Negating!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     -Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"neg\"]\n pub trait Neg<Result> {\n     fn neg(&self) -> Result;\n }\n \n+/**\n+ * \n+ * The `Not` trait is used to override the functionality of `!`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Not`. When `!Foo` happens, it ends up calling\n+ * `not`, and therefore, `main` prints `Not-ing!`.\n+ * \n+ * ```\n+ * use std::ops::Not;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Not<Foo> for Foo {\n+ *     fn not(&self) -> Foo {\n+ *         println(\"Not-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     !Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"not\"]\n pub trait Not<Result> {\n     fn not(&self) -> Result;\n }\n \n+/**\n+ * \n+ * The `BitAnd` trait is used to override the functionality of `&`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n+ * calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n+ * \n+ * ```\n+ * use std::ops::BitAnd;\n+ * \n+ * struct Foo;\n+ * \n+ * impl BitAnd<Foo, Foo> for Foo {\n+ *     fn bitand(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Bitwise And-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo & Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"bitand\"]\n pub trait BitAnd<RHS,Result> {\n     fn bitand(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `BitOr` trait is used to override the functionality of `|`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n+ * calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n+ * \n+ * ```\n+ * use std::ops::BitOr;\n+ * \n+ * struct Foo;\n+ * \n+ * impl BitOr<Foo, Foo> for Foo {\n+ *     fn bitor(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Bitwise Or-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo | Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"bitor\"]\n pub trait BitOr<RHS,Result> {\n     fn bitor(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `BitXor` trait is used to override the functionality of `^`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n+ * calling `bixtor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+ * \n+ * ```\n+ * use std::ops::BitXor;\n+ * \n+ * struct Foo;\n+ * \n+ * impl BitXor<Foo, Foo> for Foo {\n+ *     fn bitxor(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Bitwise Xor-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo ^ Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"bitxor\"]\n pub trait BitXor<RHS,Result> {\n     fn bitxor(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `Shl` trait is used to override the functionality of `<<`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n+ * calling `shl`, and therefore, `main` prints `Shifting left!`.\n+ * \n+ * ```\n+ * use std::ops::Shl;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Shl<Foo, Foo> for Foo {\n+ *     fn shl(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Shifting left!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo << Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"shl\"]\n pub trait Shl<RHS,Result> {\n     fn shl(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `Shr` trait is used to override the functionality of `>>`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n+ * calling `shr`, and therefore, `main` prints `Shifting right!`.\n+ * \n+ * ```\n+ * use std::ops::Shr;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Shr<Foo, Foo> for Foo {\n+ *     fn shr(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Shifting right!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo >> Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"shr\"]\n pub trait Shr<RHS,Result> {\n     fn shr(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ * \n+ * The `Index` trait is used to override the functionality of indexing operations\n+ * like `arr[idx]`.\n+ * \n+ * # Example\n+ * \n+ * A trivial implementation of `Index`. When `Foo[idx]` happens, it ends up\n+ * calling `index`, and therefore, `main` prints `Indexing!`.\n+ * \n+ * ```\n+ * use std::ops::Index;\n+ * \n+ * struct Foo;\n+ * \n+ * impl Index<Foo, Foo> for Foo {\n+ *     fn index(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Indexing!\");\n+ *         *self\n+ *     }\n+ * }\n+ * \n+ * fn main() {\n+ *     Foo[Foo];\n+ * }\n+ * ```\n+ */\n #[lang=\"index\"]\n pub trait Index<Index,Result> {\n     fn index(&self, index: &Index) -> Result;"}]}