{"sha": "3e1eea6c97ea71c43ebde4a171e5085947634155", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMWVlYTZjOTdlYTcxYzQzZWJkZTRhMTcxZTUwODU5NDc2MzQxNTU=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-02-23T20:23:36Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-02-26T10:08:42Z"}, "message": "lintcheck: print stats how lint counts have changed between runs", "tree": {"sha": "c9155fd0283340a2bc84fcfece0916b547214388", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9155fd0283340a2bc84fcfece0916b547214388"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e1eea6c97ea71c43ebde4a171e5085947634155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e1eea6c97ea71c43ebde4a171e5085947634155", "html_url": "https://github.com/rust-lang/rust/commit/3e1eea6c97ea71c43ebde4a171e5085947634155", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e1eea6c97ea71c43ebde4a171e5085947634155/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12dc03033f9d441f1382a7684480c4a863b33bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/12dc03033f9d441f1382a7684480c4a863b33bb8", "html_url": "https://github.com/rust-lang/rust/commit/12dc03033f9d441f1382a7684480c4a863b33bb8"}], "stats": {"total": 118, "additions": 100, "deletions": 18}, "files": [{"sha": "601e88387b9829f22fd17c2564730451ceb29d19", "filename": "clippy_dev/src/lintcheck.rs", "status": "modified", "additions": 100, "deletions": 18, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3e1eea6c97ea71c43ebde4a171e5085947634155/clippy_dev%2Fsrc%2Flintcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1eea6c97ea71c43ebde4a171e5085947634155/clippy_dev%2Fsrc%2Flintcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flintcheck.rs?ref=3e1eea6c97ea71c43ebde4a171e5085947634155", "patch": "@@ -336,8 +336,7 @@ fn build_clippy() {\n }\n \n /// Read a `toml` file and return a list of `CrateSources` that we want to check with clippy\n-fn read_crates(clap_toml_path: Option<&str>) -> (String, Vec<CrateSource>) {\n-    let toml_path = lintcheck_config_toml(clap_toml_path);\n+fn read_crates(toml_path: &PathBuf) -> (String, Vec<CrateSource>) {\n     // save it so that we can use the name of the sources.toml as name for the logfile later.\n     let toml_filename = toml_path.file_stem().unwrap().to_str().unwrap().to_string();\n     let toml_content: String =\n@@ -428,7 +427,7 @@ fn parse_json_message(json_message: &str, krate: &Crate) -> ClippyWarning {\n }\n \n /// Generate a short list of occuring lints-types and their count\n-fn gather_stats(clippy_warnings: &[ClippyWarning]) -> String {\n+fn gather_stats(clippy_warnings: &[ClippyWarning]) -> (String, HashMap<&String, usize>) {\n     // count lint type occurrences\n     let mut counter: HashMap<&String, usize> = HashMap::new();\n     clippy_warnings\n@@ -441,15 +440,17 @@ fn gather_stats(clippy_warnings: &[ClippyWarning]) -> String {\n     // to not have a lint with 200 and 2 warnings take the same spot\n     stats.sort_by_key(|(lint, count)| format!(\"{:0>4}, {}\", count, lint));\n \n-    stats\n+    let stats_string = stats\n         .iter()\n         .map(|(lint, count)| format!(\"{} {}\\n\", lint, count))\n-        .collect::<String>()\n+        .collect::<String>();\n+\n+    (stats_string, counter)\n }\n \n /// check if the latest modification of the logfile is older than the modification date of the\n /// clippy binary, if this is true, we should clean the lintchec shared target directory and recheck\n-fn lintcheck_needs_rerun(toml_path: Option<&str>) -> bool {\n+fn lintcheck_needs_rerun(toml_path: &PathBuf) -> bool {\n     let clippy_modified: std::time::SystemTime = {\n         let mut times = [\"target/debug/clippy-driver\", \"target/debug/cargo-clippy\"]\n             .iter()\n@@ -459,17 +460,18 @@ fn lintcheck_needs_rerun(toml_path: Option<&str>) -> bool {\n                     .modified()\n                     .expect(\"failed to get modification date\")\n             });\n-        // the lates modification of either of the binaries\n-        std::cmp::max(times.next().unwrap(), times.next().unwrap())\n+        // the oldest modification of either of the binaries\n+        std::cmp::min(times.next().unwrap(), times.next().unwrap())\n     };\n \n-    let logs_modified: std::time::SystemTime = std::fs::metadata(lintcheck_config_toml(toml_path))\n+    let logs_modified: std::time::SystemTime = std::fs::metadata(toml_path)\n         .expect(\"failed to get metadata of file\")\n         .modified()\n         .expect(\"failed to get modification date\");\n \n-    // if clippys modification time is bigger (older) than the logs mod time, we need to rerun lintcheck\n-    clippy_modified > logs_modified\n+    // if clippys modification time is smaller (older) than the logs mod time, we need to rerun\n+    // lintcheck\n+    dbg!(clippy_modified < logs_modified)\n }\n \n /// lintchecks `main()` function\n@@ -479,11 +481,11 @@ pub fn run(clap_config: &ArgMatches) {\n     println!(\"Done compiling\");\n \n     let clap_toml_path: Option<&str> = clap_config.value_of(\"crates-toml\");\n-    let toml_path = lintcheck_config_toml(clap_toml_path);\n+    let toml_path: PathBuf = lintcheck_config_toml(clap_toml_path);\n \n     // if the clippy bin is newer than our logs, throw away target dirs to force clippy to\n     // refresh the logs\n-    if lintcheck_needs_rerun(clap_toml_path) {\n+    if dbg!(lintcheck_needs_rerun(&toml_path)) {\n         let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n         match std::fs::metadata(&shared_target_dir) {\n             Ok(metadata) => {\n@@ -518,7 +520,9 @@ pub fn run(clap_config: &ArgMatches) {\n     // download and extract the crates, then run clippy on them and collect clippys warnings\n     // flatten into one big list of warnings\n \n-    let (filename, crates) = read_crates(clap_toml_path);\n+    let (filename, crates) = read_crates(&toml_path);\n+    let file = format!(\"lintcheck-logs/{}_logs.txt\", filename);\n+    let old_stats = read_stats_from_file(&file);\n \n     let clippy_warnings: Vec<ClippyWarning> = if let Some(only_one_crate) = clap_config.value_of(\"only\") {\n         // if we don't have the specified crate in the .toml, throw an error\n@@ -587,7 +591,7 @@ pub fn run(clap_config: &ArgMatches) {\n     };\n \n     // generate some stats\n-    let stats_formatted = gather_stats(&clippy_warnings);\n+    let (stats_formatted, new_stats) = gather_stats(&clippy_warnings);\n \n     // grab crashes/ICEs, save the crate name and the ice message\n     let ices: Vec<(&String, &String)> = clippy_warnings\n@@ -598,7 +602,7 @@ pub fn run(clap_config: &ArgMatches) {\n \n     let mut all_msgs: Vec<String> = clippy_warnings.iter().map(|warning| warning.to_string()).collect();\n     all_msgs.sort();\n-    all_msgs.push(\"\\n\\n\\n\\nStats\\n\\n\".into());\n+    all_msgs.push(\"\\n\\n\\n\\nStats:\\n\".into());\n     all_msgs.push(stats_formatted);\n \n     // save the text into lintcheck-logs/logs.txt\n@@ -608,7 +612,85 @@ pub fn run(clap_config: &ArgMatches) {\n     ices.iter()\n         .for_each(|(cratename, msg)| text.push_str(&format!(\"{}: '{}'\", cratename, msg)));\n \n-    let file = format!(\"lintcheck-logs/{}_logs.txt\", filename);\n     println!(\"Writing logs to {}\", file);\n-    write(file, text).unwrap();\n+    write(&file, text).unwrap();\n+\n+    print_stats(old_stats, new_stats);\n+}\n+\n+/// read the previous stats from the lintcheck-log file\n+fn read_stats_from_file(file_path: &String) -> HashMap<String, usize> {\n+    let file_path = PathBuf::from(file_path);\n+    dbg!(&file_path);\n+    let file_content: String = match std::fs::read_to_string(file_path).ok() {\n+        Some(content) => content,\n+        None => {\n+            eprintln!(\"RETURND\");\n+            return HashMap::new();\n+        },\n+    };\n+\n+    let lines: Vec<String> = file_content.lines().map(|l| l.to_string()).collect();\n+\n+    // search for the beginning \"Stats:\" and the end \"ICEs:\" of the section we want\n+    let start = lines.iter().position(|line| line == \"Stats:\").unwrap();\n+    let end = lines.iter().position(|line| line == \"ICEs:\").unwrap();\n+\n+    let stats_lines = &lines[start + 1..=end - 1];\n+\n+    stats_lines\n+        .into_iter()\n+        .map(|line| {\n+            let mut spl = line.split(\" \").into_iter();\n+            (\n+                spl.next().unwrap().to_string(),\n+                spl.next().unwrap().parse::<usize>().unwrap(),\n+            )\n+        })\n+        .collect::<HashMap<String, usize>>()\n+}\n+\n+/// print how lint counts changed between runs\n+fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, usize>) {\n+    let same_in_both_hashmaps = old_stats\n+        .iter()\n+        .filter(|(old_key, old_val)| new_stats.get::<&String>(&old_key) == Some(old_val))\n+        .map(|(k, v)| (k.to_string(), *v))\n+        .collect::<Vec<(String, usize)>>();\n+\n+    let mut old_stats_deduped = old_stats;\n+    let mut new_stats_deduped = new_stats;\n+\n+    // remove duplicates from both hashmaps\n+    same_in_both_hashmaps.iter().for_each(|(k, v)| {\n+        assert!(old_stats_deduped.remove(k) == Some(*v));\n+        assert!(new_stats_deduped.remove(k) == Some(*v));\n+    });\n+\n+    println!(\"\\nStats:\");\n+\n+    // list all new counts  (key is in new stats but not in old stats)\n+    new_stats_deduped\n+        .iter()\n+        .filter(|(new_key, _)| old_stats_deduped.get::<str>(&new_key).is_none())\n+        .for_each(|(new_key, new_value)| {\n+            println!(\"{} 0 => {}\", new_key, new_value);\n+        });\n+\n+    // list all changed counts (key is in both maps but value differs)\n+    new_stats_deduped\n+        .iter()\n+        .filter(|(new_key, _new_val)| old_stats_deduped.get::<str>(&new_key).is_some())\n+        .for_each(|(new_key, new_val)| {\n+            let old_val = old_stats_deduped.get::<str>(&new_key).unwrap();\n+            println!(\"{} {} => {}\", new_key, old_val, new_val);\n+        });\n+\n+    // list all gone counts (key is in old status but not in new stats)\n+    old_stats_deduped\n+        .iter()\n+        .filter(|(old_key, _)| new_stats_deduped.get::<&String>(&old_key).is_none())\n+        .for_each(|(old_key, old_value)| {\n+            println!(\"{} {} => 0\", old_key, old_value);\n+        });\n }"}]}