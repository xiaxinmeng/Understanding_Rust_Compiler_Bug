{"sha": "1fb9821f8251321736e0efd411cadb1fcb194f02", "node_id": "C_kwDOAAsO6NoAKDFmYjk4MjFmODI1MTMyMTczNmUwZWZkNDExY2FkYjFmY2IxOTRmMDI", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-02-26T18:02:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-26T18:02:18Z"}, "message": "Merge pull request #131 from bjorn3/fix_non_singleton_builder\n\nFix miscompilation when cg_ssa is using multiple builders at the same time", "tree": {"sha": "076d060402db6e09533f8d33019a0b3660d89d57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/076d060402db6e09533f8d33019a0b3660d89d57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fb9821f8251321736e0efd411cadb1fcb194f02", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiGmsqCRBK7hj4Ov3rIwAA+h8IAJNn2afCgpygziA2JNWh7P0+\n0MPTOISB6XCHTs8tXNszWRCrplKpF07ufTNdYJHK4RAEu3mdS7y4eYfA0U/XZmPt\nF4tWHyZf4Aelht/Z9/azggGz7VWrDRNdWFY2IxYTt3N4OAizEcWjhX6Ry+VLaJwK\nuK+JHaTyM7D/5nNR1CxBTl21At9kkKHTzA0OCjrfCQ9iFKm0r355N3MOqVoef5Aw\ncMgtPWZNpbnLikZi6aQCTrFqQAhQrzZQR+YLxFsiL0uG0U1UmjwnwHbq3Q7/sP8t\n5bMLw0PTs29oc1njtb52NKZCSYrPXGJWvMVfqpUzfC73KcGf5ruS1QKCxzJisIQ=\n=zqT7\n-----END PGP SIGNATURE-----\n", "payload": "tree 076d060402db6e09533f8d33019a0b3660d89d57\nparent ddbbded08f8776943e35877ea304c0175579c146\nparent 9d098424cd772ab067b0f8ecb67a7eadbe9d028c\nauthor antoyo <antoyo@users.noreply.github.com> 1645898538 -0500\ncommitter GitHub <noreply@github.com> 1645898538 -0500\n\nMerge pull request #131 from bjorn3/fix_non_singleton_builder\n\nFix miscompilation when cg_ssa is using multiple builders at the same time"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb9821f8251321736e0efd411cadb1fcb194f02", "html_url": "https://github.com/rust-lang/rust/commit/1fb9821f8251321736e0efd411cadb1fcb194f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fb9821f8251321736e0efd411cadb1fcb194f02/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddbbded08f8776943e35877ea304c0175579c146", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddbbded08f8776943e35877ea304c0175579c146", "html_url": "https://github.com/rust-lang/rust/commit/ddbbded08f8776943e35877ea304c0175579c146"}, {"sha": "9d098424cd772ab067b0f8ecb67a7eadbe9d028c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d098424cd772ab067b0f8ecb67a7eadbe9d028c", "html_url": "https://github.com/rust-lang/rust/commit/9d098424cd772ab067b0f8ecb67a7eadbe9d028c"}], "stats": {"total": 142, "additions": 49, "deletions": 93}, "files": [{"sha": "580996fdefc868b1b0a0a651dadd33acf38d9258", "filename": "src/builder.rs", "status": "modified", "additions": 35, "deletions": 47, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=1fb9821f8251321736e0efd411cadb1fcb194f02", "patch": "@@ -80,15 +80,15 @@ impl EnumClone for AtomicOrdering {\n \n pub struct Builder<'a: 'gcc, 'gcc, 'tcx> {\n     pub cx: &'a CodegenCx<'gcc, 'tcx>,\n-    pub block: Option<Block<'gcc>>,\n+    pub block: Block<'gcc>,\n     stack_var_count: Cell<usize>,\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n-    fn with_cx(cx: &'a CodegenCx<'gcc, 'tcx>) -> Self {\n+    fn with_cx(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n         Builder {\n             cx,\n-            block: None,\n+            block,\n             stack_var_count: Cell::new(0),\n         }\n     }\n@@ -114,10 +114,9 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let after_block = func.new_block(\"after_while\");\n         self.llbb().end_with_jump(None, while_block);\n \n-        // NOTE: since jumps were added and compare_exchange doesn't expect this, the current blocks in the\n+        // NOTE: since jumps were added and compare_exchange doesn't expect this, the current block in the\n         // state need to be updated.\n-        self.block = Some(while_block);\n-        *self.cx.current_block.borrow_mut() = Some(while_block);\n+        self.switch_to_block(while_block);\n \n         let comparison_operator =\n             match operation {\n@@ -132,10 +131,9 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         while_block.end_with_conditional(None, cond, while_block, after_block);\n \n-        // NOTE: since jumps were added in a place rustc does not expect, the current blocks in the\n+        // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n         // state need to be updated.\n-        self.block = Some(after_block);\n-        *self.cx.current_block.borrow_mut() = Some(after_block);\n+        self.switch_to_block(after_block);\n \n         return_value.to_rvalue()\n     }\n@@ -245,7 +243,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     pub fn current_func(&self) -> Function<'gcc> {\n-        self.block.expect(\"block\").get_function()\n+        self.block.get_function()\n     }\n \n     fn function_call(&mut self, func: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n@@ -256,17 +254,16 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n         let return_type = func.get_return_type();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n+            self.block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n             result.to_rvalue()\n         }\n         else {\n-            current_block.add_eval(None, self.cx.context.new_call(None, func, &args));\n+            self.block.add_eval(None, self.cx.context.new_call(None, func, &args));\n             // Return dummy value when not having return value.\n             self.context.new_rvalue_from_long(self.isize_type, 0)\n         }\n@@ -279,9 +276,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // That's why we assign the result to a local or call add_eval().\n         let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let mut return_type = gcc_func.get_return_type();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n \n         // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n         if gcc_func.get_param_count() == 0 && format!(\"{:?}\", func_ptr) == \"__builtin_ia32_pmovmskb128\" {\n@@ -291,20 +287,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            current_block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }\n         else {\n             if gcc_func.get_param_count() == 0 {\n                 // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n-                current_block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n+                self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n             }\n             else {\n-                current_block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+                self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             }\n             // Return dummy value when not having return value.\n             let result = current_func.new_local(None, self.isize_type, \"dummyValueThatShouldNeverBeUsed\");\n-            current_block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n+            self.block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n             result.to_rvalue()\n         }\n     }\n@@ -313,12 +309,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local.\n         let return_type = self.context.new_type::<bool>();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n         // TODO(antoyo): return the new_call() directly? Since the overflow function has no side-effects.\n         unsafe { RETURN_VALUE_COUNT += 1 };\n         let result = current_func.new_local(None, return_type, &format!(\"overflowReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-        current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n+        self.block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n         result.to_rvalue()\n     }\n }\n@@ -384,14 +379,11 @@ impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n \n impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n-        let mut bx = Builder::with_cx(cx);\n-        *cx.current_block.borrow_mut() = Some(block);\n-        bx.block = Some(block);\n-        bx\n+        Builder::with_cx(cx, block)\n     }\n \n     fn llbb(&self) -> Block<'gcc> {\n-        self.block.expect(\"block\")\n+        self.block\n     }\n \n     fn append_block(cx: &'a CodegenCx<'gcc, 'tcx>, func: RValue<'gcc>, name: &str) -> Block<'gcc> {\n@@ -405,8 +397,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn switch_to_block(&mut self, block: Self::BasicBlock) {\n-        *self.cx.current_block.borrow_mut() = Some(block);\n-        self.block = Some(block);\n+        self.block = block;\n     }\n \n     fn ret_void(&mut self) {\n@@ -441,7 +432,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             let on_val = self.const_uint_big(typ, on_val);\n             gcc_cases.push(self.context.new_case(on_val, on_val, dest));\n         }\n-        self.block.expect(\"block\").end_with_switch(None, value, default_block, &gcc_cases);\n+        self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n     fn invoke(&mut self, _typ: Type<'gcc>, _func: RValue<'gcc>, _args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n@@ -454,17 +445,16 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn unreachable(&mut self) {\n         let func = self.context.get_builtin_function(\"__builtin_unreachable\");\n-        let block = self.block.expect(\"block\");\n-        block.add_eval(None, self.context.new_call(None, func, &[]));\n-        let return_type = block.get_function().get_return_type();\n+        self.block.add_eval(None, self.context.new_call(None, func, &[]));\n+        let return_type = self.block.get_function().get_return_type();\n         let void_type = self.context.new_type::<()>();\n         if return_type == void_type {\n-            block.end_with_void_return(None)\n+            self.block.end_with_void_return(None)\n         }\n         else {\n             let return_value = self.current_func()\n                 .new_local(None, return_type, \"unreachableReturn\");\n-            block.end_with_return(None, return_value)\n+            self.block.end_with_return(None, return_value)\n         }\n     }\n \n@@ -911,11 +901,13 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn ptrtoint(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.cx.ptrtoint(self.block.expect(\"block\"), value, dest_ty)\n+        let usize_value = self.cx.const_bitcast(value, self.cx.type_isize());\n+        self.intcast(usize_value, dest_ty, false)\n     }\n \n     fn inttoptr(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.cx.inttoptr(self.block.expect(\"block\"), value, dest_ty)\n+        let usize_value = self.intcast(value, self.cx.type_isize(), false);\n+        self.cx.const_bitcast(usize_value, dest_ty)\n     }\n \n     fn bitcast(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -967,9 +959,8 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let dst = self.pointercast(dst, self.type_i8p());\n         let src = self.pointercast(src, self.type_ptr_to(self.type_void()));\n         let memcpy = self.context.get_builtin_function(\"memcpy\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle aligns and is_volatile.\n-        block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n     }\n \n     fn memmove(&mut self, dst: RValue<'gcc>, dst_align: Align, src: RValue<'gcc>, src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n@@ -986,20 +977,18 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let src = self.pointercast(src, self.type_ptr_to(self.type_void()));\n \n         let memmove = self.context.get_builtin_function(\"memmove\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle is_volatile.\n-        block.add_eval(None, self.context.new_call(None, memmove, &[dst, src, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memmove, &[dst, src, size]));\n     }\n \n     fn memset(&mut self, ptr: RValue<'gcc>, fill_byte: RValue<'gcc>, size: RValue<'gcc>, _align: Align, flags: MemFlags) {\n         let _is_volatile = flags.contains(MemFlags::VOLATILE);\n         let ptr = self.pointercast(ptr, self.type_i8p());\n         let memset = self.context.get_builtin_function(\"memset\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle align and is_volatile.\n         let fill_byte = self.context.new_cast(None, fill_byte, self.i32_type);\n         let size = self.intcast(size, self.type_size_t(), false);\n-        block.add_eval(None, self.context.new_call(None, memset, &[ptr, fill_byte, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memset, &[ptr, fill_byte, size]));\n     }\n \n     fn select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, mut else_val: RValue<'gcc>) -> RValue<'gcc> {\n@@ -1019,10 +1008,9 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         else_block.add_assignment(None, variable, else_val);\n         else_block.end_with_jump(None, after_block);\n \n-        // NOTE: since jumps were added in a place rustc does not expect, the current blocks in the\n+        // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n         // state need to be updated.\n-        self.block = Some(after_block);\n-        *self.cx.current_block.borrow_mut() = Some(after_block);\n+        self.switch_to_block(after_block);\n \n         variable.to_rvalue()\n     }"}, {"sha": "e36e5bb2382dd9425d132b138dbd13e1b3b13f65", "filename": "src/common.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=1fb9821f8251321736e0efd411cadb1fcb194f02", "patch": "@@ -1,5 +1,5 @@\n use gccjit::LValue;\n-use gccjit::{Block, RValue, Type, ToRValue};\n+use gccjit::{RValue, Type, ToRValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods,\n@@ -45,27 +45,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n         // TODO(antoyo): set linkage.\n     }\n-\n-    pub fn inttoptr(&self, block: Block<'gcc>, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        let func = block.get_function();\n-        let local = func.new_local(None, value.get_type(), \"intLocal\");\n-        block.add_assignment(None, local, value);\n-        let value_address = local.get_address(None);\n-\n-        let ptr = self.context.new_cast(None, value_address, dest_ty.make_pointer());\n-        ptr.dereference(None).to_rvalue()\n-    }\n-\n-    pub fn ptrtoint(&self, block: Block<'gcc>, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): when libgccjit allow casting from pointer to int, remove this.\n-        let func = block.get_function();\n-        let local = func.new_local(None, value.get_type(), \"ptrLocal\");\n-        block.add_assignment(None, local, value);\n-        let ptr_address = local.get_address(None);\n-\n-        let ptr = self.context.new_cast(None, ptr_address, dest_ty.make_pointer());\n-        ptr.dereference(None).to_rvalue()\n-    }\n }\n \n pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n@@ -202,11 +181,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 }\n \n                 let value = self.const_uint_big(self.type_ix(bitsize), data);\n-                if layout.value == Pointer {\n-                    self.inttoptr(self.current_block.borrow().expect(\"block\"), value, ty)\n-                } else {\n-                    self.const_bitcast(value, ty)\n-                }\n+                // TODO(bjorn3): assert size is correct\n+                self.const_bitcast(value, ty)\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();"}, {"sha": "d20356b126642be972c53014bcc77c2dbb57d418", "filename": "src/context.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=1fb9821f8251321736e0efd411cadb1fcb194f02", "patch": "@@ -31,8 +31,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub codegen_unit: &'tcx CodegenUnit<'tcx>,\n     pub context: &'gcc Context<'gcc>,\n \n-    // TODO(antoyo): First set it to a dummy block to avoid using Option?\n-    pub current_block: RefCell<Option<Block<'gcc>>>,\n+    // TODO(bjorn3): Can this field be removed?\n     pub current_func: RefCell<Option<Function<'gcc>>>,\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n \n@@ -177,7 +176,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             check_overflow,\n             codegen_unit,\n             context,\n-            current_block: RefCell::new(None),\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n             functions: RefCell::new(functions),"}, {"sha": "d2df9d2dcb62212d2f2d43277855c66599e8a2cc", "filename": "src/int.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fint.rs?ref=1fb9821f8251321736e0efd411cadb1fcb194f02", "patch": "@@ -148,8 +148,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n             // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n             // state need to be updated.\n-            self.block = Some(after_block);\n-            *self.cx.current_block.borrow_mut() = Some(after_block);\n+            self.switch_to_block(after_block);\n \n             result.to_rvalue()\n         }\n@@ -494,8 +493,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n             // NOTE: since jumps were added in a place rustc does not expect, the current block in the\n             // state need to be updated.\n-            self.block = Some(after_block);\n-            *self.cx.current_block.borrow_mut() = Some(after_block);\n+            self.switch_to_block(after_block);\n \n             result.to_rvalue()\n         }"}, {"sha": "81f841e72cf7cd347d86c35776ecb1d0df096d27", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb9821f8251321736e0efd411cadb1fcb194f02/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=1fb9821f8251321736e0efd411cadb1fcb194f02", "patch": "@@ -184,10 +184,9 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                     then_block.end_with_jump(None, after_block);\n \n                                     // NOTE: since jumps were added in a place\n-                                    // count_leading_zeroes() does not expect, the current blocks\n+                                    // count_leading_zeroes() does not expect, the current block\n                                     // in the state need to be updated.\n-                                    *self.current_block.borrow_mut() = Some(else_block);\n-                                    self.block = Some(else_block);\n+                                    self.switch_to_block(else_block);\n \n                                     let zeros =\n                                         match name {\n@@ -199,9 +198,8 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                     self.llbb().end_with_jump(None, after_block);\n \n                                     // NOTE: since jumps were added in a place rustc does not\n-                                    // expect, the current blocks in the state need to be updated.\n-                                    *self.current_block.borrow_mut() = Some(after_block);\n-                                    self.block = Some(after_block);\n+                                    // expect, the current block in the state need to be updated.\n+                                    self.switch_to_block(after_block);\n \n                                     result.to_rvalue()\n                                 }\n@@ -1002,9 +1000,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n \n             // NOTE: since jumps were added in a place rustc does not\n-            // expect, the current blocks in the state need to be updated.\n-            *self.current_block.borrow_mut() = Some(after_block);\n-            self.block = Some(after_block);\n+            // expect, the current block in the state need to be updated.\n+            self.switch_to_block(after_block);\n \n             res.to_rvalue()\n         }\n@@ -1073,9 +1070,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n \n             // NOTE: since jumps were added in a place rustc does not\n-            // expect, the current blocks in the state need to be updated.\n-            *self.current_block.borrow_mut() = Some(after_block);\n-            self.block = Some(after_block);\n+            // expect, the current block in the state need to be updated.\n+            self.switch_to_block(after_block);\n \n             res.to_rvalue()\n         }"}]}