{"sha": "62a343452978f570454be38556839049aef7792b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYTM0MzQ1Mjk3OGY1NzA0NTRiZTM4NTU2ODM5MDQ5YWVmNzc5MmI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-03T23:24:12Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-04T12:07:56Z"}, "message": "stop treating char as an integer type\n\nCloses #7609", "tree": {"sha": "d81ce555593bff3a0b3a8a3265198ad8356f3175", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d81ce555593bff3a0b3a8a3265198ad8356f3175"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62a343452978f570454be38556839049aef7792b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62a343452978f570454be38556839049aef7792b", "html_url": "https://github.com/rust-lang/rust/commit/62a343452978f570454be38556839049aef7792b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62a343452978f570454be38556839049aef7792b/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "787f4c986c5c7ddad5a697ea109def652f6da88b", "url": "https://api.github.com/repos/rust-lang/rust/commits/787f4c986c5c7ddad5a697ea109def652f6da88b", "html_url": "https://github.com/rust-lang/rust/commit/787f4c986c5c7ddad5a697ea109def652f6da88b"}], "stats": {"total": 442, "additions": 227, "deletions": 215}, "files": [{"sha": "d7c2016912cb0f0217405150fbb8ee98ab0b5e37", "filename": "src/etc/unicode.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -158,6 +158,7 @@ def emit_property_module(f, mod, tbl):\n     keys.sort()\n     emit_bsearch_range_table(f);\n     for cat in keys:\n+        if cat == \"Cs\": continue\n         f.write(\"    static %s_table : &'static [(char,char)] = &[\\n\" % cat)\n         ix = 0\n         for pair in tbl[cat]:"}, {"sha": "3527a7b5e55f849c370ae1cf83a9fd7c2053c7c9", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -10,7 +10,6 @@\n \n #[allow(missing_doc)];\n \n-\n use std::str;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n@@ -90,6 +89,7 @@ pub enum EbmlEncoderTag {\n // --------------------------------------\n \n pub mod reader {\n+    use std::char;\n     use super::*;\n \n     use serialize;\n@@ -426,7 +426,7 @@ pub mod reader {\n             (unsafe { transmute::<u64, f64>(bits) }) as float\n         }\n         fn read_char(&mut self) -> char {\n-            doc_as_u32(self.next_doc(EsChar)) as char\n+            char::from_u32(doc_as_u32(self.next_doc(EsChar))).unwrap()\n         }\n         fn read_str(&mut self) -> ~str {\n             self.next_doc(EsStr).as_str()"}, {"sha": "bc8c08d4643f42180dd1d8f15538fa406baca811", "filename": "src/libextra/json.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -16,6 +16,8 @@\n \n //! json parsing and serialization\n \n+use std::char;\n+use std::cast::transmute;\n use std::iterator;\n use std::float;\n use std::hashmap::HashMap;\n@@ -490,7 +492,7 @@ pub struct Parser<T> {\n pub fn Parser<T : iterator::Iterator<char>>(rdr: ~T) -> Parser<T> {\n     let mut p = Parser {\n         rdr: rdr,\n-        ch: 0 as char,\n+        ch: '\\x00',\n         line: 1,\n         col: 0,\n     };\n@@ -517,12 +519,13 @@ impl<T: iterator::Iterator<char>> Parser<T> {\n }\n \n impl<T : iterator::Iterator<char>> Parser<T> {\n-    fn eof(&self) -> bool { self.ch == -1 as char }\n+    // FIXME: #8971: unsound\n+    fn eof(&self) -> bool { self.ch == unsafe { transmute(-1u32) } }\n \n     fn bump(&mut self) {\n         match self.rdr.next() {\n             Some(ch) => self.ch = ch,\n-            None() => self.ch = -1 as char,\n+            None() => self.ch = unsafe { transmute(-1u32) }, // FIXME: #8971: unsound\n         }\n \n         if self.ch == '\\n' {\n@@ -755,7 +758,7 @@ impl<T : iterator::Iterator<char>> Parser<T> {\n                             ~\"invalid \\\\u escape (not four digits)\");\n                       }\n \n-                      res.push_char(n as char);\n+                      res.push_char(char::from_u32(n as u32).unwrap());\n                   }\n                   _ => return self.error(~\"invalid escape\")\n                 }"}, {"sha": "c607ea03bb3b7f4004039d2df3983864e86d3113", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -258,7 +258,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             ' ' => flags.space = true,\n                             '.' => fstate = FormatStatePrecision,\n                             '0'..'9' => {\n-                                flags.width = (cur - '0') as uint;\n+                                flags.width = (cur as uint - '0' as uint);\n                                 fstate = FormatStateWidth;\n                             }\n                             _ => util::unreachable()\n@@ -330,7 +330,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         state = Nothing;\n                     }\n                     '0'..'9' => {\n-                        state = IntConstant(i*10 + ((cur - '0') as int));\n+                        state = IntConstant(i*10 + (cur as int - '0' as int));\n                         old_state = Nothing;\n                     }\n                     _ => return Err(~\"bad int constant\")\n@@ -358,23 +358,23 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         flags.space = true;\n                     }\n                     (FormatStateFlags,'0'..'9') => {\n-                        flags.width = (cur - '0') as uint;\n+                        flags.width = (cur as uint - '0' as uint);\n                         *fstate = FormatStateWidth;\n                     }\n                     (FormatStateFlags,'.') => {\n                         *fstate = FormatStatePrecision;\n                     }\n                     (FormatStateWidth,'0'..'9') => {\n                         let old = flags.width;\n-                        flags.width = flags.width * 10 + ((cur - '0') as uint);\n+                        flags.width = flags.width * 10 + (cur as uint - '0' as uint);\n                         if flags.width < old { return Err(~\"format width overflow\") }\n                     }\n                     (FormatStateWidth,'.') => {\n                         *fstate = FormatStatePrecision;\n                     }\n                     (FormatStatePrecision,'0'..'9') => {\n                         let old = flags.precision;\n-                        flags.precision = flags.precision * 10 + ((cur - '0') as uint);\n+                        flags.precision = flags.precision * 10 + (cur as uint - '0' as uint);\n                         if flags.precision < old { return Err(~\"format precision overflow\") }\n                     }\n                     _ => return Err(~\"invalid format specifier\")"}, {"sha": "8a00be0e18aa57da80c8508f72a85be5db82d4ea", "filename": "src/libextra/url.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -72,7 +72,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n         let mut out = ~\"\";\n \n         while !rdr.eof() {\n-            let ch = rdr.read_byte() as char;\n+            let ch = rdr.read_byte() as u8 as char;\n             match ch {\n               // unreserved:\n               'A' .. 'Z' |\n@@ -135,7 +135,7 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n             match rdr.read_char() {\n               '%' => {\n                 let bytes = rdr.read_bytes(2u);\n-                let ch = uint::parse_bytes(bytes, 16u).unwrap() as char;\n+                let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n \n                 if full_url {\n                     // Only decode some characters:\n@@ -186,7 +186,7 @@ fn encode_plus(s: &str) -> ~str {\n         let mut out = ~\"\";\n \n         while !rdr.eof() {\n-            let ch = rdr.read_byte() as char;\n+            let ch = rdr.read_byte() as u8 as char;\n             match ch {\n               'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n                 out.push_char(ch);\n@@ -258,7 +258,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                     let ch = match ch {\n                         '%' => {\n                             let bytes = rdr.read_bytes(2u);\n-                            uint::parse_bytes(bytes, 16u).unwrap() as char\n+                            uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n                         }\n                         '+' => ' ',\n                         ch => ch\n@@ -295,7 +295,7 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     do io::with_str_reader(s) |rdr| {\n         let mut ch;\n         while !rdr.eof() {\n-            ch = rdr.read_byte() as char;\n+            ch = rdr.read_byte() as u8 as char;\n             if ch == c {\n                 // found a match, adjust markers\n                 index = rdr.tell()-1;"}, {"sha": "e81da60ed17bc954c15f8ff37fe2660577b3e67c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -239,10 +239,10 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n       ty::ty_nil => w.write_char('n'),\n       ty::ty_bot => w.write_char('z'),\n       ty::ty_bool => w.write_char('b'),\n+      ty::ty_char => w.write_char('c'),\n       ty::ty_int(t) => {\n         match t {\n           ty_i => w.write_char('i'),\n-          ty_char => w.write_char('c'),\n           ty_i8 => w.write_str(&\"MB\"),\n           ty_i16 => w.write_str(&\"MW\"),\n           ty_i32 => w.write_str(&\"ML\"),"}, {"sha": "2642764867486d68cf99efa1772c64c5601be6fb", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -200,21 +200,19 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n         }\n     }\n     match e.node {\n-      ExprLit(@codemap::Spanned {node: lit_int(v, t), _}) => {\n-        if t != ty_char {\n+        ExprLit(@codemap::Spanned {node: lit_int(v, t), _}) => {\n             if (v as u64) > ast_util::int_ty_max(\n                 if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n                 sess.span_err(e.span, \"literal out of range for its type\");\n             }\n         }\n-      }\n-      ExprLit(@codemap::Spanned {node: lit_uint(v, t), _}) => {\n-        if v > ast_util::uint_ty_max(\n-            if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n-            sess.span_err(e.span, \"literal out of range for its type\");\n+        ExprLit(@codemap::Spanned {node: lit_uint(v, t), _}) => {\n+            if v > ast_util::uint_ty_max(\n+                if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n+                sess.span_err(e.span, \"literal out of range for its type\");\n+            }\n         }\n-      }\n-      _ => ()\n+        _ => ()\n     }\n     visit::walk_expr(v, e, is_const);\n }"}, {"sha": "ad9a3b2f4e7c18ee7a2b5883d96b1fe23799defb", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -472,6 +472,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n pub fn lit_to_const(lit: &lit) -> const_val {\n     match lit.node {\n       lit_str(s) => const_str(s),\n+      lit_char(n) => const_uint(n as u64),\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),"}, {"sha": "6f4d94e2a647a1c74f6c3492a046fa363067aa19", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -778,7 +778,6 @@ impl TypeLimitsLintVisitor {\n     fn int_ty_range(&mut self, int_ty: ast::int_ty) -> (i64, i64) {\n         match int_ty {\n             ast::ty_i =>    (i64::min_value,        i64::max_value),\n-            ast::ty_char => (u32::min_value as i64, u32::max_value as i64),\n             ast::ty_i8 =>   (i8::min_value  as i64, i8::max_value  as i64),\n             ast::ty_i16 =>  (i16::min_value as i64, i16::max_value as i64),\n             ast::ty_i32 =>  (i32::min_value as i64, i32::max_value as i64),"}, {"sha": "09491bd28be305584ac6d4e6c396b71608e0999b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -777,7 +777,7 @@ pub fn PrimitiveTypeTable() -> PrimitiveTypeTable {\n     };\n \n     table.intern(\"bool\",    ty_bool);\n-    table.intern(\"char\",    ty_int(ty_char));\n+    table.intern(\"char\",    ty_char);\n     table.intern(\"float\",   ty_float(ty_f));\n     table.intern(\"f32\",     ty_float(ty_f32));\n     table.intern(\"f64\",     ty_float(ty_f64));"}, {"sha": "2ed9af42248c905e691a6c5c22bea84513bdb39a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -566,6 +566,7 @@ pub fn compare_scalar_types(cx: @mut Block,\n     match ty::get(t).sty {\n         ty::ty_nil => rslt(cx, f(nil_type)),\n         ty::ty_bool | ty::ty_ptr(_) => rslt(cx, f(unsigned_int)),\n+        ty::ty_char => rslt(cx, f(unsigned_int)),\n         ty::ty_int(_) => rslt(cx, f(signed_int)),\n         ty::ty_uint(_) => rslt(cx, f(unsigned_int)),\n         ty::ty_float(_) => rslt(cx, f(floating_point)),"}, {"sha": "096e37136ac956a0437435fa81292fb9d0cc0761", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -39,6 +39,7 @@ pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n+      ast::lit_char(i) => C_integral(Type::char(), i as u64, false),\n       ast::lit_int(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n       ast::lit_uint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),\n       ast::lit_int_unsuffixed(i) => {"}, {"sha": "a9e3a869be098394a071dc323d121fef41deb568", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -746,9 +746,9 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n         ty::ty_bool => (~\"bool\", DW_ATE_boolean),\n+        ty::ty_char => (~\"char\", DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n             ast::ty_i => (~\"int\", DW_ATE_signed),\n-            ast::ty_char => (~\"char\", DW_ATE_signed_char),\n             ast::ty_i8 => (~\"i8\", DW_ATE_signed),\n             ast::ty_i16 => (~\"i16\", DW_ATE_signed),\n             ast::ty_i32 => (~\"i32\", DW_ATE_signed),\n@@ -1344,6 +1344,7 @@ fn type_metadata(cx: &mut CrateContext,\n         ty::ty_nil      |\n         ty::ty_bot      |\n         ty::ty_bool     |\n+        ty::ty_char     |\n         ty::ty_int(_)   |\n         ty::ty_uint(_)  |\n         ty::ty_float(_) => {"}, {"sha": "ce6fb6d3e7755c198c3b5f97f596c5b5a8bd33ee", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -1630,6 +1630,7 @@ pub enum cast_kind {\n \n pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n+        ty::ty_char       => cast_integral,\n         ty::ty_float(*)   => cast_float,\n         ty::ty_ptr(*)     => cast_pointer,\n         ty::ty_rptr(*)    => cast_pointer,"}, {"sha": "fb46aefbafe3b2ba1cee11e66cee34474feab541", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -157,8 +157,8 @@ impl Reflector {\n           ty::ty_bot => self.leaf(\"bot\"),\n           ty::ty_nil => self.leaf(\"nil\"),\n           ty::ty_bool => self.leaf(\"bool\"),\n+          ty::ty_char => self.leaf(\"char\"),\n           ty::ty_int(ast::ty_i) => self.leaf(\"int\"),\n-          ty::ty_int(ast::ty_char) => self.leaf(\"char\"),\n           ty::ty_int(ast::ty_i8) => self.leaf(\"i8\"),\n           ty::ty_int(ast::ty_i16) => self.leaf(\"i16\"),\n           ty::ty_int(ast::ty_i32) => self.leaf(\"i32\"),"}, {"sha": "8b221a89c36bc23b52090d13c96db9368dd3458f", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -119,7 +119,6 @@ impl Type {\n     pub fn int_from_ty(ctx: &CrateContext, t: ast::int_ty) -> Type {\n         match t {\n             ast::ty_i => ctx.int_type,\n-            ast::ty_char => Type::char(),\n             ast::ty_i8 => Type::i8(),\n             ast::ty_i16 => Type::i16(),\n             ast::ty_i32 => Type::i32(),"}, {"sha": "945d5a048bb0b6c30262c952404ed8861b75f8f3", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -108,6 +108,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n     let llsizingty = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => Type::nil(),\n         ty::ty_bool => Type::bool(),\n+        ty::ty_char => Type::char(),\n         ty::ty_int(t) => Type::int_from_ty(cx, t),\n         ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n         ty::ty_float(t) => Type::float_from_ty(cx, t),\n@@ -195,6 +196,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n     let mut llty = match ty::get(t).sty {\n       ty::ty_nil | ty::ty_bot => Type::nil(),\n       ty::ty_bool => Type::bool(),\n+      ty::ty_char => Type::char(),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(cx, t),"}, {"sha": "0958eeb7097a62a4b9b074110cfd0e6d3c28ccdc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -572,8 +572,8 @@ mod primitives {\n \n     def_prim_ty!(TY_NIL,    super::ty_nil,                  0)\n     def_prim_ty!(TY_BOOL,   super::ty_bool,                 1)\n-    def_prim_ty!(TY_INT,    super::ty_int(ast::ty_i),       2)\n-    def_prim_ty!(TY_CHAR,   super::ty_int(ast::ty_char),    3)\n+    def_prim_ty!(TY_CHAR,   super::ty_char,                 2)\n+    def_prim_ty!(TY_INT,    super::ty_int(ast::ty_i),       3)\n     def_prim_ty!(TY_I8,     super::ty_int(ast::ty_i8),      4)\n     def_prim_ty!(TY_I16,    super::ty_int(ast::ty_i16),     5)\n     def_prim_ty!(TY_I32,    super::ty_int(ast::ty_i32),     6)\n@@ -609,6 +609,7 @@ pub enum sty {\n     ty_nil,\n     ty_bot,\n     ty_bool,\n+    ty_char,\n     ty_int(ast::int_ty),\n     ty_uint(ast::uint_ty),\n     ty_float(ast::float_ty),\n@@ -1016,7 +1017,7 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n         flags |= rflags(r);\n         flags |= get(mt.ty).flags;\n       }\n-      &ty_nil | &ty_bool | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n+      &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_estr(_) | &ty_type | &ty_opaque_closure_ptr(_) |\n       &ty_opaque_box => (),\n       // You might think that we could just return ty_err for\n@@ -1147,7 +1148,6 @@ pub fn mk_u64() -> t { mk_prim_t(&primitives::TY_U64) }\n pub fn mk_mach_int(tm: ast::int_ty) -> t {\n     match tm {\n         ast::ty_i    => mk_int(),\n-        ast::ty_char => mk_char(),\n         ast::ty_i8   => mk_i8(),\n         ast::ty_i16  => mk_i16(),\n         ast::ty_i32  => mk_i32(),\n@@ -1303,7 +1303,7 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n         return;\n     }\n     match get(ty).sty {\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self(_) |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n       }\n@@ -1400,7 +1400,7 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n         ty_struct(did, ref substs) => {\n             ty_struct(did, fold_substs(substs, fldop))\n         }\n-        ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+        ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) | ty_err |\n         ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self(_) => {\n             (*sty).clone()\n@@ -1745,7 +1745,7 @@ pub fn type_is_unique(ty: t) -> bool {\n */\n pub fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_nil | ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) | ty_type |\n       ty_bare_fn(*) | ty_ptr(_) => true,\n       _ => false\n@@ -2079,7 +2079,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n         let result = match get(ty).sty {\n             // Scalar and unique types are sendable, freezable, and durable\n-            ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty_ptr(_) => {\n                 TC_NONE\n             }\n@@ -2414,6 +2414,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_nil |\n             ty_bot |\n             ty_bool |\n+            ty_char |\n             ty_int(_) |\n             ty_uint(_) |\n             ty_float(_) |\n@@ -2551,7 +2552,7 @@ pub fn type_is_integral(ty: t) -> bool {\n \n pub fn type_is_char(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_int(ty_char) => true,\n+        ty_char => true,\n         _ => false\n     }\n }\n@@ -2588,7 +2589,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let mut result = true;\n     match get(ty).sty {\n       // Scalar types\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) | ty_bare_fn(_) => result = true,\n       // Boxed types\n       ty_box(_) | ty_uniq(_) | ty_closure(_) |\n@@ -3428,7 +3429,7 @@ pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n \n pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n-      ty_nil | ty_bot | ty_bool | ty_int(_) |\n+      ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n       ty_uint(_) | ty_float(_) | ty_estr(_) |\n       ty_type | ty_opaque_box | ty_opaque_closure_ptr(_) => {\n         ::util::ppaux::ty_to_str(cx, t)\n@@ -4262,10 +4263,11 @@ pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n-    static tycat_int: int = 2;\n-    static tycat_float: int = 3;\n-    static tycat_struct: int = 4;\n-    static tycat_bot: int = 5;\n+    static tycat_char: int = 2;\n+    static tycat_int: int = 3;\n+    static tycat_float: int = 4;\n+    static tycat_struct: int = 5;\n+    static tycat_bot: int = 6;\n \n     static opcat_add: int = 0;\n     static opcat_sub: int = 1;\n@@ -4304,6 +4306,7 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n             return tycat(cx, simd_type(cx, ty))\n         }\n         match get(ty).sty {\n+          ty_char => tycat_char,\n           ty_bool => tycat_bool,\n           ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n           ty_float(_) | ty_infer(FloatVar(_)) => tycat_float,\n@@ -4316,16 +4319,15 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     static t: bool = true;\n     static f: bool = false;\n \n-    let tbl = ~[\n-    /*.          add,     shift,   bit\n-      .             sub,     rel,     logic\n-      .                mult,    eq,         */\n-    /*other*/   ~[f, f, f, f, f, f, f, f],\n-    /*bool*/    ~[f, f, f, f, t, t, t, t],\n-    /*int*/     ~[t, t, t, t, t, t, t, f],\n-    /*float*/   ~[t, t, t, f, t, t, f, f],\n-    /*bot*/     ~[f, f, f, f, f, f, f, f],\n-    /*struct*/  ~[t, t, t, t, f, f, t, t]];\n+    let tbl = [\n+    //           +, -, *, shift, rel, ==, bit, logic\n+    /*other*/   [f, f, f, f,     f,   f,  f,   f],\n+    /*bool*/    [f, f, f, f,     t,   t,  t,   t],\n+    /*char*/    [f, f, f, f,     t,   t,  f,   f],\n+    /*int*/     [t, t, t, t,     t,   t,  t,   f],\n+    /*float*/   [t, t, t, f,     t,   t,  f,   f],\n+    /*bot*/     [f, f, f, f,     f,   f,  f,   f],\n+    /*struct*/  [t, t, t, t,     f,   f,  t,   t]];\n \n     return tbl[tycat(cx, ty)][opcat(op)];\n }"}, {"sha": "c5f85d26e44673cb628cd24598d82d048c02f39f", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -455,6 +455,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 ty::mk_bool()\n               }\n+              ast::ty_char => {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_char()\n+              }\n               ast::ty_int(it) => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 ty::mk_mach_int(it)"}, {"sha": "d0beb5c609e89b09008db118f96f2adf3126e265", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -434,7 +434,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n             || ~\"mismatched types in range\")\n         {\n             // no-op\n-        } else if !ty::type_is_numeric(b_ty) {\n+        } else if !ty::type_is_numeric(b_ty) && !ty::type_is_char(b_ty) {\n             tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n         } else {\n             match valid_range_bounds(fcx.ccx, begin, end) {"}, {"sha": "3588fb3f51e71f421a8fe0c72775d87995337679", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -783,7 +783,7 @@ impl<'self> LookupContext<'self> {\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n             ty_self(_) | ty_param(*) | ty_nil | ty_bot | ty_bool |\n-            ty_int(*) | ty_uint(*) |\n+            ty_char | ty_int(*) | ty_uint(*) |\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_struct(*) | ty_tup(*) |\n             ty_estr(*) | ty_evec(*) | ty_trait(*) | ty_closure(*) => {\n                 self.search_for_some_kind_of_autorefd_method("}, {"sha": "9afcec7c340e1df931333300f347b8ca7eecd861", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -1021,6 +1021,7 @@ pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n \n     match lit.node {\n       ast::lit_str(*) => ty::mk_estr(tcx, ty::vstore_slice(ty::re_static)),\n+      ast::lit_char(_) => ty::mk_char(),\n       ast::lit_int(_, t) => ty::mk_mach_int(t),\n       ast::lit_uint(_, t) => ty::mk_mach_uint(t),\n       ast::lit_int_unsuffixed(_) => {\n@@ -2695,10 +2696,20 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         }, t_e, None);\n                     }\n \n-                    let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n-                    if type_is_c_like_enum(fcx,expr.span,t_e)\n-                        && t_1_is_scalar {\n-                        /* this case is allowed */\n+                    let te = structurally_resolved_type(fcx, e.span, t_e);\n+                    let t_1_is_char = type_is_char(fcx, expr.span, t_1);\n+\n+                    // casts to scalars other than `char` are allowed\n+                    let t_1_is_trivial = type_is_scalar(fcx, expr.span, t_1) && !t_1_is_char;\n+\n+                    if type_is_c_like_enum(fcx, expr.span, t_e) && t_1_is_trivial {\n+                        // casts from C-like enums are allowed\n+                    } else if t_1_is_char {\n+                        if ty::get(te).sty != ty::ty_uint(ast::ty_u8) {\n+                            fcx.type_error_message(expr.span, |actual| {\n+                                fmt!(\"only `u8` can be cast as `char`, not `%s`\", actual)\n+                            }, t_e, None);\n+                        }\n                     } else if type_is_region_ptr(fcx, expr.span, t_e) &&\n                         type_is_unsafe_ptr(fcx, expr.span, t_1) {\n \n@@ -2729,7 +2740,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n                         /* this cast is only allowed from &[T] to *T or\n                         &T to *T. */\n-                        let te = structurally_resolved_type(fcx, e.span, t_e);\n                         match (&ty::get(te).sty, &ty::get(t_1).sty) {\n                             (&ty::ty_rptr(_, mt1), &ty::ty_ptr(mt2))\n                             if types_compatible(fcx, e.span,\n@@ -2741,7 +2751,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             }\n                         }\n                     } else if !(type_is_scalar(fcx,expr.span,t_e)\n-                                && t_1_is_scalar) {\n+                                && t_1_is_trivial) {\n                         /*\n                         If more type combinations should be supported than are\n                         supported here, then file an enhancement issue and\n@@ -3439,6 +3449,11 @@ pub fn type_is_scalar(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_scalar(typ_s);\n }\n \n+pub fn type_is_char(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_char(typ_s);\n+}\n+\n pub fn type_is_unsafe_ptr(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_unsafe_ptr(typ_s);"}, {"sha": "738ed9656e38724ba940cb65470c4d1626ec9925", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -20,7 +20,7 @@ use metadata::csearch;\n use metadata::cstore::iter_crate_data;\n use middle::ty::get;\n use middle::ty::{ImplContainer, lookup_item_type, subst};\n-use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n+use middle::ty::{substs, t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n@@ -81,7 +81,7 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n             Some(resolved_type)\n         }\n \n-        ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n+        ty_nil | ty_bot | ty_bool | ty_char | ty_int(*) | ty_uint(*) | ty_float(*) |\n         ty_estr(*) | ty_evec(*) | ty_bare_fn(*) | ty_closure(*) | ty_tup(*) |\n         ty_infer(*) | ty_param(*) | ty_self(*) | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err | ty_box(_) |"}, {"sha": "b04719ee3cea883f4119e9349862b183a740593c", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -610,14 +610,10 @@ pub fn super_tys<C:Combine>(\n         vid: ty::IntVid,\n         val: ty::IntVarValue) -> cres<ty::t>\n     {\n-        if val == IntType(ast::ty_char) {\n-            Err(ty::terr_integer_as_char)\n-        } else {\n-            if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n-            match val {\n-                IntType(v) => Ok(ty::mk_mach_int(v)),\n-                UintType(v) => Ok(ty::mk_mach_uint(v))\n-            }\n+        if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n+        match val {\n+            IntType(v) => Ok(ty::mk_mach_int(v)),\n+            UintType(v) => Ok(ty::mk_mach_uint(v))\n         }\n     }\n "}, {"sha": "4ce29f3913169e5da704b1c2e4bd42636323af57", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -16,7 +16,7 @@ use middle::ty::{br_fresh, ctxt, field};\n use middle::ty::{mt, t, param_ty};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region,\n                  re_empty};\n-use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n+use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n@@ -412,8 +412,8 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_nil => ~\"()\",\n       ty_bot => ~\"!\",\n       ty_bool => ~\"bool\",\n+      ty_char => ~\"char\",\n       ty_int(ast::ty_i) => ~\"int\",\n-      ty_int(ast::ty_char) => ~\"char\",\n       ty_int(t) => ast_util::int_ty_to_str(t),\n       ty_uint(ast::ty_u) => ~\"uint\",\n       ty_uint(t) => ast_util::uint_ty_to_str(t),"}, {"sha": "7f043b2ecaab3d047d40b5aaed3b6e96271fb9d8", "filename": "src/libstd/char.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -10,8 +10,9 @@\n \n //! Utilities for manipulating the char type\n \n+use cast::transmute;\n use option::{None, Option, Some};\n-use int;\n+use i32;\n use str::StrSlice;\n use unicode::{derived_property, general_category, decompose};\n use to_str::ToStr;\n@@ -64,6 +65,19 @@ static TAG_FOUR_B: uint = 240u;\n     Cn  Unassigned              a reserved unassigned code point or a noncharacter\n */\n \n+/// The highest valid code point\n+pub static MAX: char = '\\U0010ffff';\n+\n+/// Convert from `u32` to a character.\n+pub fn from_u32(i: u32) -> Option<char> {\n+    // catch out-of-bounds and surrogates\n+    if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n+        None\n+    } else {\n+        Some(unsafe { transmute(i) })\n+    }\n+}\n+\n /// Returns whether the specified character is considered a unicode alphabetic\n /// character\n pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }\n@@ -194,10 +208,12 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n         fail!(\"from_digit: radix %? is to high (maximum 36)\", num);\n     }\n     if num < radix {\n-        if num < 10 {\n-            Some(('0' as uint + num) as char)\n-        } else {\n-            Some(('a' as uint + num - 10u) as char)\n+        unsafe {\n+            if num < 10 {\n+                Some(transmute(('0' as uint + num) as u32))\n+            } else {\n+                Some(transmute(('a' as uint + num - 10u) as u32))\n+            }\n         }\n     } else {\n         None\n@@ -220,14 +236,16 @@ fn decompose_hangul(s: char, f: &fn(char)) {\n     let si = s as uint - S_BASE;\n \n     let li = si / N_COUNT;\n-    f((L_BASE + li) as char);\n+    unsafe {\n+        f(transmute((L_BASE + li) as u32));\n \n-    let vi = (si % N_COUNT) / T_COUNT;\n-    f((V_BASE + vi) as char);\n+        let vi = (si % N_COUNT) / T_COUNT;\n+        f(transmute((V_BASE + vi) as u32));\n \n-    let ti = si % T_COUNT;\n-    if ti > 0 {\n-        f((T_BASE + ti) as char);\n+        let ti = si % T_COUNT;\n+        if ti > 0 {\n+            f(transmute((T_BASE + ti) as u32));\n+        }\n     }\n }\n \n@@ -267,10 +285,12 @@ pub fn escape_unicode(c: char, f: &fn(char)) {\n         (c <= '\\uffff') { f('u'); 4 }\n         _               { f('U'); 8 }\n     );\n-    do int::range_step(4 * (pad - 1), -1, -4) |offset| {\n-        match ((c as u32) >> offset) & 0xf {\n-            i @ 0 .. 9 => { f('0' + i as char); }\n-            i => { f('a' + (i - 10) as char); }\n+    do i32::range_step(4 * (pad - 1), -1, -4) |offset| {\n+        unsafe {\n+            match ((c as i32) >> offset) & 0xf {\n+                i @ 0 .. 9 => { f(transmute('0' as i32 + i)); }\n+                i => { f(transmute('a' as i32 + (i - 10))); }\n+            }\n         }\n         true\n     };\n@@ -416,8 +436,8 @@ impl Ord for char {\n \n #[cfg(not(test))]\n impl Zero for char {\n-    fn zero() -> char { 0 as char }\n-    fn is_zero(&self) -> bool { *self == 0 as char }\n+    fn zero() -> char { '\\x00' }\n+    fn is_zero(&self) -> bool { *self == '\\x00' }\n }\n \n #[test]"}, {"sha": "59329c5bdd203a5c622ac2ba8d60f4518f8fa1cd", "filename": "src/libstd/io.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -47,6 +47,7 @@ implement `Reader` and `Writer`, where appropriate.\n #[allow(missing_doc)];\n \n use cast;\n+use cast::transmute;\n use clone::Clone;\n use c_str::ToCStr;\n use container::Container;\n@@ -661,7 +662,9 @@ impl<T:Reader> ReaderUtil for T {\n                 i += 1;\n                 assert!((w > 0));\n                 if w == 1 {\n-                    chars.push(b0 as char);\n+                    unsafe {\n+                        chars.push(transmute(b0 as u32));\n+                    }\n                     loop;\n                 }\n                 // can't satisfy this char with the existing data\n@@ -680,7 +683,9 @@ impl<T:Reader> ReaderUtil for T {\n                 // See str::StrSlice::char_at\n                 val += ((b0 << ((w + 1) as u8)) as uint)\n                     << (w - 1) * 6 - w - 1u;\n-                chars.push(val as char);\n+                unsafe {\n+                    chars.push(transmute(val as u32));\n+                }\n             }\n             return (i, 0);\n         }\n@@ -712,7 +717,7 @@ impl<T:Reader> ReaderUtil for T {\n     fn read_char(&self) -> char {\n         let c = self.read_chars(1);\n         if c.len() == 0 {\n-            return -1 as char; // FIXME will this stay valid? // #2004\n+            return unsafe { transmute(-1u32) }; // FIXME: #8971: unsound\n         }\n         assert_eq!(c.len(), 1);\n         return c[0];\n@@ -739,9 +744,11 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn each_char(&self, it: &fn(char) -> bool) -> bool {\n+        // FIXME: #8971: unsound\n+        let eof: char = unsafe { transmute(-1u32) };\n         loop {\n             match self.read_char() {\n-                eof if eof == (-1 as char) => break,\n+                c if c == eof => break,\n                 ch => if !it(ch) { return false; }\n             }\n         }\n@@ -1896,6 +1903,7 @@ mod tests {\n     use result::{Ok, Err};\n     use u64;\n     use vec;\n+    use cast::transmute;\n \n     #[test]\n     fn test_simple() {\n@@ -2002,16 +2010,16 @@ mod tests {\n     #[test]\n     fn test_readchar() {\n         do io::with_str_reader(\"\u751f\") |inp| {\n-            let res : char = inp.read_char();\n+            let res = inp.read_char();\n             assert_eq!(res as int, 29983);\n         }\n     }\n \n     #[test]\n     fn test_readchar_empty() {\n         do io::with_str_reader(\"\") |inp| {\n-            let res : char = inp.read_char();\n-            assert_eq!(res as int, -1);\n+            let res = inp.read_char();\n+            assert_eq!(res, unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n         }\n     }\n "}, {"sha": "58c75d3b40886efdc37665acd46e3e139c192ed0", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -174,13 +174,6 @@ impl Rand for f64 {\n     }\n }\n \n-impl Rand for char {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> char {\n-        rng.next() as char\n-    }\n-}\n-\n impl Rand for bool {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> bool {\n@@ -1137,7 +1130,7 @@ mod test {\n         let _f : f32 = random();\n         let _o : Option<Option<i8>> = random();\n         let _many : ((),\n-                     (~uint, @int, ~Option<~(@char, ~(@bool,))>),\n+                     (~uint, @int, ~Option<~(@u32, ~(@bool,))>),\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n                      (f32, (f64, (float,)))) = random();\n     }"}, {"sha": "956dd08ac91f0ea553b62cbbe20e0237a843db1b", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -163,13 +163,14 @@ impl<'self> Parser<'self> {\n     // Read digit\n     fn read_digit(&mut self, radix: u8) -> Option<u8> {\n         fn parse_digit(c: char, radix: u8) -> Option<u8> {\n+            let c = c as u8;\n             // assuming radix is either 10 or 16\n-            if c >= '0' && c <= '9' {\n-                Some((c - '0') as u8)\n-            } else if radix > 10 && c >= 'a' && c < 'a' + (radix - 10) as char {\n-                Some((c - 'a' + (10 as char)) as u8)\n-            } else if radix > 10 && c >= 'A' && c < 'A' + (radix - 10) as char {\n-                Some((c - 'A' + (10 as char)) as u8)\n+            if c >= '0' as u8 && c <= '9' as u8 {\n+                Some((c - '0' as u8) as u8)\n+            } else if radix > 10 && c >= 'a' as u8 && c < 'a' as u8 + (radix - 10) {\n+                Some((c - 'a' as u8 + 10) as u8)\n+            } else if radix > 10 && c >= 'A' as u8 && c < 'A' as u8 + (radix - 10) {\n+                Some((c - 'A' as u8 + 10) as u8)\n             } else {\n                 None\n             }"}, {"sha": "6a5ec9aa6d6b779e83f69f87a1347f6bcf22d710", "filename": "src/libstd/str.rs", "status": "modified", "additions": 8, "deletions": 38, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -17,6 +17,7 @@\n \n use at_vec;\n use cast;\n+use cast::transmute;\n use char;\n use char::Char;\n use clone::{Clone, DeepClone};\n@@ -875,18 +876,18 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n         let u = v[i];\n \n         if  u <= 0xD7FF_u16 || u >= 0xE000_u16 {\n-            f(u as char);\n+            f(unsafe { cast::transmute(u as u32) });\n             i += 1u;\n \n         } else {\n             let u2 = v[i+1u];\n             assert!(u >= 0xD800_u16 && u <= 0xDBFF_u16);\n             assert!(u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16);\n-            let mut c = (u - 0xD800_u16) as char;\n+            let mut c: u32 = (u - 0xD800_u16) as u32;\n             c = c << 10;\n-            c |= (u2 - 0xDC00_u16) as char;\n-            c |= 0x1_0000_u32 as char;\n-            f(c);\n+            c |= (u2 - 0xDC00_u16) as u32;\n+            c |= 0x1_0000_u32 as u32;\n+            f(unsafe { cast::transmute(c) });\n             i += 2u;\n         }\n     }\n@@ -953,7 +954,6 @@ macro_rules! utf8_acc_cont_byte(\n )\n \n static TAG_CONT_U8: u8 = 128u8;\n-static MAX_UNICODE: uint = 1114112u;\n \n /// Unsafe operations\n pub mod raw {\n@@ -1942,7 +1942,7 @@ impl<'self> StrSlice<'self> for &'self str {\n             if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-            return CharRange {ch: val as char, next: i + w};\n+            return CharRange {ch: unsafe { transmute(val as u32) }, next: i + w};\n         }\n \n         return multibyte_char_range_at(*self, i);\n@@ -1980,7 +1980,7 @@ impl<'self> StrSlice<'self> for &'self str {\n             if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-            return CharRange {ch: val as char, next: i};\n+            return CharRange {ch: unsafe { transmute(val as u32) }, next: i};\n         }\n \n         return multibyte_char_range_at_rev(*self, prev);\n@@ -2236,7 +2236,6 @@ impl OwnedStr for ~str {\n     /// Appends a character to the back of a string\n     #[inline]\n     fn push_char(&mut self, c: char) {\n-        assert!((c as uint) < MAX_UNICODE); // FIXME: #7609: should be enforced on all `char`\n         let cur_len = self.len();\n         self.reserve_at_least(cur_len + 4); // may use up to 4 bytes\n \n@@ -2433,8 +2432,6 @@ impl Default for @str {\n mod tests {\n     use container::Container;\n     use option::{None, Some};\n-    use libc::c_char;\n-    use libc;\n     use ptr;\n     use str::*;\n     use vec;\n@@ -3178,13 +3175,6 @@ mod tests {\n         assert!(!\"\".contains_char('a'));\n     }\n \n-    #[test]\n-    fn test_map() {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        assert_eq!(~\"\", \"\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n-        assert_eq!(~\"YMCA\", \"ymca\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n-    }\n-\n     #[test]\n     fn test_utf16() {\n         let pairs =\n@@ -3903,26 +3893,6 @@ mod bench {\n         }\n     }\n \n-    #[bench]\n-    fn map_chars_100_ascii(bh: &mut BenchHarness) {\n-        let s = \"HelloHelloHelloHelloHelloHelloHelloHelloHelloHello\\\n-                 HelloHelloHelloHelloHelloHelloHelloHelloHelloHello\";\n-        do bh.iter {\n-            s.map_chars(|c| ((c as uint) + 1) as char);\n-        }\n-    }\n-\n-    #[bench]\n-    fn map_chars_100_multibytes(bh: &mut BenchHarness) {\n-        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\\\n-                 \ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\\\n-                 \ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\\\n-                 \ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\";\n-        do bh.iter {\n-            s.map_chars(|c| ((c as uint) + 1) as char);\n-        }\n-    }\n-\n     #[bench]\n     fn bench_with_capacity(bh: &mut BenchHarness) {\n         do bh.iter {"}, {"sha": "4ed969f628e6ac8ed50fa2f911a732ae84650f12", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -149,7 +149,7 @@ impl AsciiCast<Ascii> for char {\n \n     #[inline]\n     fn is_ascii(&self) -> bool {\n-        *self - ('\\x7F' & *self) == '\\x00'\n+        *self as u32 - ('\\x7F' as u32 & *self as u32) == 0\n     }\n }\n \n@@ -380,6 +380,7 @@ static ASCII_UPPER_MAP: &'static [u8] = &[\n mod tests {\n     use super::*;\n     use str::from_char;\n+    use char::from_u32;\n \n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => ( [$(Ascii{chr:$e}),*]);\n@@ -469,9 +470,10 @@ mod tests {\n \n         let mut i = 0;\n         while i <= 500 {\n-            let c = i as char;\n-            let upper = if 'a' <= c && c <= 'z' { c + 'A' - 'a' } else { c };\n-            assert_eq!(from_char(i as char).to_ascii_upper(), from_char(upper))\n+            let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n+                        else { i };\n+            assert_eq!(from_char(from_u32(i).unwrap()).to_ascii_upper(),\n+                       from_char(from_u32(upper).unwrap()))\n             i += 1;\n         }\n     }\n@@ -484,9 +486,10 @@ mod tests {\n \n         let mut i = 0;\n         while i <= 500 {\n-            let c = i as char;\n-            let lower = if 'A' <= c && c <= 'Z' { c + 'a' - 'A' } else { c };\n-            assert_eq!(from_char(i as char).to_ascii_lower(), from_char(lower))\n+            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                        else { i };\n+            assert_eq!(from_char(from_u32(i).unwrap()).to_ascii_lower(),\n+                       from_char(from_u32(lower).unwrap()))\n             i += 1;\n         }\n     }\n@@ -503,9 +506,11 @@ mod tests {\n \n         let mut i = 0;\n         while i <= 500 {\n-            let c = i as char;\n-            let lower = if 'A' <= c && c <= 'Z' { c + 'a' - 'A' } else { c };\n-            assert!(from_char(i as char).eq_ignore_ascii_case(from_char(lower)));\n+            let c = i;\n+            let lower = if 'A' as u32 <= c && c <= 'Z' as u32 { c + 'a' as u32 - 'A' as u32 }\n+                        else { c };\n+            assert!(from_char(from_u32(i).unwrap()).\n+                eq_ignore_ascii_case(from_char(from_u32(lower).unwrap())));\n             i += 1;\n         }\n     }"}, {"sha": "1b1e4be4ee14c25e8abba968d1ccc50cea8adc42", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -56,14 +56,6 @@ pub mod general_category {\n         bsearch_range_table(c, Co_table)\n     }\n \n-    static Cs_table : &'static [(char,char)] = &[\n-        ('\\ud800', '\\udfff')\n-    ];\n-\n-    pub fn Cs(c: char) -> bool {\n-        bsearch_range_table(c, Cs_table)\n-    }\n-\n     static Ll_table : &'static [(char,char)] = &[\n         ('\\x61', '\\x7a'), ('\\xb5', '\\xb5'),\n         ('\\xdf', '\\xf6'), ('\\xf8', '\\xff'),"}, {"sha": "c7ebc344a9c870fffe5b806668e0548681c46057", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -632,6 +632,7 @@ pub type lit = Spanned<lit_>;\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum lit_ {\n     lit_str(@str),\n+    lit_char(u32),\n     lit_int(i64, int_ty),\n     lit_uint(u64, uint_ty),\n     lit_int_unsuffixed(i64),\n@@ -680,7 +681,6 @@ pub enum trait_method {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum int_ty {\n     ty_i,\n-    ty_char,\n     ty_i8,\n     ty_i16,\n     ty_i32,\n@@ -737,6 +737,7 @@ pub enum prim_ty {\n     ty_float(float_ty),\n     ty_str,\n     ty_bool,\n+    ty_char\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]"}, {"sha": "5ee8537750ed508193864ff7090e42d56fcbca77", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -151,7 +151,6 @@ pub fn is_path(e: @Expr) -> bool {\n \n pub fn int_ty_to_str(t: int_ty) -> ~str {\n     match t {\n-      ty_char => ~\"u8\", // ???\n       ty_i => ~\"\",\n       ty_i8 => ~\"i8\",\n       ty_i16 => ~\"i16\",\n@@ -164,7 +163,7 @@ pub fn int_ty_max(t: int_ty) -> u64 {\n     match t {\n       ty_i8 => 0x80u64,\n       ty_i16 => 0x8000u64,\n-      ty_i | ty_char | ty_i32 => 0x80000000u64, // actually ni about ty_i\n+      ty_i | ty_i32 => 0x80000000u64, // actually ni about ty_i\n       ty_i64 => 0x8000000000000000u64\n     }\n }"}, {"sha": "cac311b008825533a8df02abbe77fabe5a49630b", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -16,6 +16,8 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n \n+use std::char;\n+\n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n     // Gather all argument expressions\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n@@ -53,8 +55,8 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> bas\n                 }\n \n                 // char literal, push to vector expression\n-                ast::lit_int(v, ast::ty_char) => {\n-                    if (v as char).is_ascii() {\n+                ast::lit_char(v) => {\n+                    if char::from_u32(v).unwrap().is_ascii() {\n                         bytes.push(cx.expr_u8(sp, v as u8));\n                     } else {\n                         cx.span_err(sp, \"Non-ascii char literal in bytes!\")"}, {"sha": "b63b829a392f0744c7d4fbefc19d982a232e8054", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -495,8 +495,7 @@ impl Context {\n \n                 // Translate the format\n                 let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n-                let fill = self.ecx.expr_lit(sp, ast::lit_int(fill as i64,\n-                                                              ast::ty_char));\n+                let fill = self.ecx.expr_lit(sp, ast::lit_char(fill as u32));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n                         self.ecx.path_global(sp, parsepath(\"AlignLeft\"))"}, {"sha": "4e8b7467c5c00c84a61bb3eecdbb37de226167c5", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -387,10 +387,18 @@ fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n                                       ~[mk_binop(cx, sp, binop)]);\n         }\n \n+        LIT_CHAR(i) => {\n+            let s_ity = ~\"ty_char\";\n+            let e_ity = cx.expr_ident(sp, id_ext(s_ity));\n+\n+            let e_char = cx.expr_lit(sp, ast::lit_char(i));\n+\n+            return cx.expr_call_ident(sp, id_ext(\"LIT_CHAR\"), ~[e_char, e_ity]);\n+        }\n+\n         LIT_INT(i, ity) => {\n             let s_ity = match ity {\n                 ast::ty_i => ~\"ty_i\",\n-                ast::ty_char => ~\"ty_char\",\n                 ast::ty_i8 => ~\"ty_i8\",\n                 ast::ty_i16 => ~\"ty_i16\",\n                 ast::ty_i32 => ~\"ty_i32\","}, {"sha": "9dfea678b8703034a19400702a6d641b217b472f", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -17,6 +17,7 @@ use ext::tt::transcribe::{dup_tt_reader};\n use parse::token;\n use parse::token::{str_to_ident};\n \n+use std::cast::transmute;\n use std::char;\n use std::either;\n use std::u64;\n@@ -184,7 +185,7 @@ pub fn bump(rdr: &mut StringReader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr, rdr.pos).to_uint();\n     if current_byte_offset < (rdr.src).len() {\n-        assert!(rdr.curr != -1 as char);\n+        assert!(rdr.curr != unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n         let last_char = rdr.curr;\n         let next = rdr.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n@@ -201,17 +202,17 @@ pub fn bump(rdr: &mut StringReader) {\n                 BytePos(current_byte_offset), byte_offset_diff);\n         }\n     } else {\n-        rdr.curr = -1 as char;\n+        rdr.curr = unsafe { transmute(-1u32) }; // FIXME: #8971: unsound\n     }\n }\n pub fn is_eof(rdr: @mut StringReader) -> bool {\n-    rdr.curr == -1 as char\n+    rdr.curr == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n }\n pub fn nextch(rdr: @mut StringReader) -> char {\n     let offset = byte_offset(rdr, rdr.pos).to_uint();\n     if offset < (rdr.src).len() {\n         return rdr.src.char_at(offset);\n-    } else { return -1 as char; }\n+    } else { return unsafe { transmute(-1u32) }; } // FIXME: #8971: unsound\n }\n \n fn dec_digit_val(c: char) -> int { return (c as int) - ('0' as int); }\n@@ -532,7 +533,10 @@ fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n         accum_int += hex_digit_val(n);\n         i -= 1u;\n     }\n-    return accum_int as char;\n+    match char::from_u32(accum_int as u32) {\n+        Some(x) => x,\n+        None => rdr.fatal(fmt!(\"illegal numeric character escape\"))\n+    }\n }\n \n fn ident_start(c: char) -> bool {\n@@ -707,7 +711,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             rdr.fatal(~\"unterminated character constant\");\n         }\n         bump(rdr); // advance curr past token\n-        return token::LIT_INT(c2 as i64, ast::ty_char);\n+        return token::LIT_CHAR(c2 as u32);\n       }\n       '\"' => {\n         let mut accum_str = ~\"\";\n@@ -891,21 +895,21 @@ mod test {\n         let env = setup(@\"'a'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        assert_eq!(tok,token::LIT_INT('a' as i64, ast::ty_char));\n+        assert_eq!(tok,token::LIT_CHAR('a' as u32));\n     }\n \n     #[test] fn character_space() {\n         let env = setup(@\"' '\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        assert_eq!(tok, token::LIT_INT(' ' as i64, ast::ty_char));\n+        assert_eq!(tok, token::LIT_CHAR(' ' as u32));\n     }\n \n     #[test] fn character_escaped() {\n         let env = setup(@\"'\\n'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        assert_eq!(tok, token::LIT_INT('\\n' as i64, ast::ty_char));\n+        assert_eq!(tok, token::LIT_CHAR('\\n' as u32));\n     }\n \n     #[test] fn lifetime_name() {"}, {"sha": "51c5522ae2f7c2be972808d1b7d186a5d277d747", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -37,7 +37,7 @@ use ast::{foreign_item, foreign_item_static, foreign_item_fn, foreign_mod};\n use ast::{Ident, impure_fn, inherited, item, item_, item_static};\n use ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n-use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n+use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int, lit_char};\n use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local};\n use ast::{MutImmutable, MutMutable, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mt, BiMul, Mutability};\n@@ -1334,6 +1334,7 @@ impl Parser {\n     // matches token_lit = LIT_INT | ...\n     pub fn lit_from_token(&self, tok: &token::Token) -> lit_ {\n         match *tok {\n+            token::LIT_CHAR(i) => lit_char(i),\n             token::LIT_INT(i, it) => lit_int(i, it),\n             token::LIT_UINT(u, ut) => lit_uint(u, ut),\n             token::LIT_INT_UNSUFFIXED(i) => lit_int_unsuffixed(i),"}, {"sha": "591b4b10bd31451d8bbe5e894a65a6ef0626d845", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -15,6 +15,7 @@ use parse::token;\n use util::interner::StrInterner;\n use util::interner;\n \n+use std::char;\n use std::cmp::Equiv;\n use std::local_data;\n use std::rand;\n@@ -73,6 +74,7 @@ pub enum Token {\n     DOLLAR,\n \n     /* Literals */\n+    LIT_CHAR(u32),\n     LIT_INT(i64, ast::int_ty),\n     LIT_UINT(u64, ast::uint_ty),\n     LIT_INT_UNSUFFIXED(i64),\n@@ -164,9 +166,9 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n       DOLLAR => ~\"$\",\n \n       /* Literals */\n-      LIT_INT(c, ast::ty_char) => {\n+      LIT_CHAR(c) => {\n           let mut res = ~\"'\";\n-          do (c as char).escape_default |c| {\n+          do char::from_u32(c).unwrap().escape_default |c| {\n               res.push_char(c);\n           }\n           res.push_char('\\'');\n@@ -236,6 +238,7 @@ pub fn can_begin_expr(t: &Token) -> bool {\n       IDENT(_, _) => true,\n       UNDERSCORE => true,\n       TILDE => true,\n+      LIT_CHAR(_) => true,\n       LIT_INT(_, _) => true,\n       LIT_UINT(_, _) => true,\n       LIT_INT_UNSUFFIXED(_) => true,\n@@ -276,6 +279,7 @@ pub fn flip_delimiter(t: &token::Token) -> token::Token {\n \n pub fn is_lit(t: &Token) -> bool {\n     match *t {\n+      LIT_CHAR(_) => true,\n       LIT_INT(_, _) => true,\n       LIT_UINT(_, _) => true,\n       LIT_INT_UNSUFFIXED(_) => true,"}, {"sha": "32cf30fd3a00d5eff5a10daf8f536da60714f19b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -27,6 +27,7 @@ use print::pp::{breaks, consistent, inconsistent, eof};\n use print::pp;\n use print::pprust;\n \n+use std::char;\n use std::io;\n \n // The @ps is stored here to prevent recursive type.\n@@ -2044,9 +2045,9 @@ pub fn print_literal(s: @ps, lit: &ast::lit) {\n     }\n     match lit.node {\n       ast::lit_str(st) => print_string(s, st),\n-      ast::lit_int(ch, ast::ty_char) => {\n+      ast::lit_char(ch) => {\n           let mut res = ~\"'\";\n-          do (ch as char).escape_default |c| {\n+          do char::from_u32(ch).unwrap().escape_default |c| {\n               res.push_char(c);\n           }\n           res.push_char('\\'');"}, {"sha": "333794e98bfb87a1e03eb709e80ba108edcfdd28", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -42,22 +42,6 @@ fn test_bool() {\n     assert_eq!(true ^ true, false);\n }\n \n-fn test_char() {\n-    let ch10 = 10 as char;\n-    let ch4 = 4 as char;\n-    let ch2 = 2 as char;\n-    assert_eq!(ch10 + ch4, 14 as char);\n-    assert_eq!(ch10 - ch4, 6 as char);\n-    assert_eq!(ch10 * ch4, 40 as char);\n-    assert_eq!(ch10 / ch4, ch2);\n-    assert_eq!(ch10 % ch4, ch2);\n-    assert_eq!(ch10 >> ch2, ch2);\n-    assert_eq!(ch10 << ch4, 160 as char);\n-    assert_eq!(ch10 | ch4, 14 as char);\n-    assert_eq!(ch10 & ch2, ch2);\n-    assert_eq!(ch10 ^ ch2, 8 as char);\n-}\n-\n fn test_box() {\n     assert_eq!(@10, @10);\n }\n@@ -111,7 +95,6 @@ fn test_class() {\n pub fn main() {\n     test_nil();\n     test_bool();\n-    test_char();\n     test_box();\n     test_ptr();\n     test_class();"}, {"sha": "00d3155cd98212e8ae290a1d5bfe64c7e2da4a37", "filename": "src/test/run-pass/cast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Ftest%2Frun-pass%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Ftest%2Frun-pass%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n-\n // -*- rust -*-\n pub fn main() {\n     let i: int = 'Q' as int;\n@@ -20,7 +17,7 @@ pub fn main() {\n     assert_eq!(u, 'Q' as u32);\n     assert_eq!(i as u8, 'Q' as u8);\n     assert_eq!(i as u8 as i8, 'Q' as u8 as i8);\n-    assert_eq!(0x51 as char, 'Q');\n+    assert_eq!(0x51u8 as char, 'Q');\n     assert_eq!(true, 1 as bool);\n     assert_eq!(0 as u32, false as u32);\n }"}, {"sha": "945bb885ad1bf2ddee2004ad72cf90d1cc663c8e", "filename": "src/test/run-pass/shift.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Ftest%2Frun-pass%2Fshift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Ftest%2Frun-pass%2Fshift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshift.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n }\n \n fn test_misc() {\n-    assert_eq!(1 << 1i8 << 1u8 << 1i16 << 1 as char << 1u64, 32);\n+    assert_eq!(1 << 1i8 << 1u8 << 1i16 << 1u8 << 1u64, 32);\n }\n \n fn test_expr() {"}, {"sha": "db258d48f9f1c4a9568f8713f88edc8ebbd83cae", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62a343452978f570454be38556839049aef7792b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a343452978f570454be38556839049aef7792b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=62a343452978f570454be38556839049aef7792b", "patch": "@@ -14,7 +14,7 @@ use std::str;\n \n pub fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n-    let chs: ~[char] = ~['e', '\u00e9', '\u20ac', 0x10000 as char];\n+    let chs: ~[char] = ~['e', '\u00e9', '\u20ac', '\\U00010000'];\n     let s: ~str = str::from_chars(chs);\n     let schs: ~[char] = s.iter().collect();\n "}]}