{"sha": "de48274c50952dc629914e33d8b65ba222c1e093", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNDgyNzRjNTA5NTJkYzYyOTkxNGUzM2Q4YjY1YmEyMjJjMWUwOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-12T07:32:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-12T07:32:11Z"}, "message": "auto merge of #8418 : pnkfelix/rust/fsk-issue3192-improve-parse-error-for-empty-struct-init, r=pcwalton,me\n\nFix #3192.  r? anyone\r\n\r\nThere are 4 different new tests, to check some different scenarios for\r\nwhat the parse context is at the time of recovery, becasue our\r\ncompile-fail infrastructure does not appear to handle verifying\r\nerror-recovery situations.\r\n\r\nDifferentiate between unit-like struct definition item and unit-like\r\nstruct construction in the error message.\r\n\r\n----\r\n\r\nMore generally, outlines a more generic strategy for parse error\r\nrecovery: By committing to an expression/statement at set points in\r\nthe parser, we can then do some look-ahead to catch common mistakes\r\nand skip over them.\r\n\r\nOne detail about this strategy is that you want to avoid emitting the\r\n\"helpful\" message unless the input is reasonably close to the case of\r\ninterest.  (E.g. do not warn about a potential unit struct for an\r\ninput of the form `let hmm = do foo { } { };`)\r\n\r\nTo accomplish this, I added (partial) last_token tracking; used for\r\n`commit_stmt` support.\r\n\r\nThe check_for_erroneous_unit_struct_expecting fn returns bool to\r\nsignal whether it \"made progress\"; currently unused; this is meant for\r\nuse to compose several such recovery checks together in a loop.", "tree": {"sha": "99a839b77545858f03063ea02aea76a0c2445547", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99a839b77545858f03063ea02aea76a0c2445547"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de48274c50952dc629914e33d8b65ba222c1e093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de48274c50952dc629914e33d8b65ba222c1e093", "html_url": "https://github.com/rust-lang/rust/commit/de48274c50952dc629914e33d8b65ba222c1e093", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de48274c50952dc629914e33d8b65ba222c1e093/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1785841a5b8d33f13a7d90495213ce67c41b680e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1785841a5b8d33f13a7d90495213ce67c41b680e", "html_url": "https://github.com/rust-lang/rust/commit/1785841a5b8d33f13a7d90495213ce67c41b680e"}, {"sha": "eee044734c55bcdc540e334d6edc8cb7d7a040d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/eee044734c55bcdc540e334d6edc8cb7d7a040d7", "html_url": "https://github.com/rust-lang/rust/commit/eee044734c55bcdc540e334d6edc8cb7d7a040d7"}], "stats": {"total": 219, "additions": 187, "deletions": 32}, "files": [{"sha": "7e18c440d816c49105122a777968a105f2f6833d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 114, "deletions": 31, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/de48274c50952dc629914e33d8b65ba222c1e093/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de48274c50952dc629914e33d8b65ba222c1e093/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=de48274c50952dc629914e33d8b65ba222c1e093", "patch": "@@ -283,6 +283,7 @@ pub fn Parser(sess: @mut ParseSess,\n         token: @mut tok0.tok,\n         span: @mut span,\n         last_span: @mut span,\n+        last_token: @mut None,\n         buffer: @mut ([\n             placeholder.clone(),\n             placeholder.clone(),\n@@ -309,6 +310,8 @@ pub struct Parser {\n     span: @mut span,\n     // the span of the prior token:\n     last_span: @mut span,\n+    // the previous token or None (only stashed sometimes).\n+    last_token: @mut Option<~token::Token>,\n     buffer: @mut [TokenAndSpan, ..4],\n     buffer_start: @mut int,\n     buffer_end: @mut int,\n@@ -376,6 +379,89 @@ impl Parser {\n         }\n     }\n \n+    // Expect next token to be edible or inedible token.  If edible,\n+    // then consume it; if inedible, then return without consuming\n+    // anything.  Signal a fatal error if next token is unexpected.\n+    pub fn expect_one_of(&self, edible: &[token::Token], inedible: &[token::Token]) {\n+        fn tokens_to_str(p:&Parser, tokens: &[token::Token]) -> ~str {\n+            let mut i = tokens.iter();\n+            // This might be a sign we need a connect method on Iterator.\n+            let b = i.next().map_default(~\"\", |t| p.token_to_str(*t));\n+            i.fold(b, |b,a| b + \" \" + p.token_to_str(a))\n+        }\n+        if edible.contains(self.token) {\n+            self.bump();\n+        } else if inedible.contains(self.token) {\n+            // leave it in the input\n+        } else {\n+            let expected = vec::append(edible.to_owned(), inedible);\n+            let expect = tokens_to_str(self, expected);\n+            let actual = self.this_token_to_str();\n+            self.fatal(\n+                if expected.len() != 1 {\n+                    fmt!(\"expected one of `%s` but found `%s`\", expect, actual)\n+                } else {\n+                    fmt!(\"expected `%s` but found `%s`\", expect, actual)\n+                }\n+            )\n+        }\n+    }\n+\n+    // Check for erroneous `ident { }`; if matches, signal error and\n+    // recover (without consuming any expected input token).  Returns\n+    // true if and only if input was consumed for recovery.\n+    pub fn check_for_erroneous_unit_struct_expecting(&self, expected: &[token::Token]) -> bool {\n+        if *self.token == token::LBRACE\n+            && expected.iter().all(|t| *t != token::LBRACE)\n+            && self.look_ahead(1, |t| *t == token::RBRACE) {\n+            // matched; signal non-fatal error and recover.\n+            self.span_err(*self.span,\n+                          \"Unit-like struct construction is written with no trailing `{ }`\");\n+            self.eat(&token::LBRACE);\n+            self.eat(&token::RBRACE);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    // Commit to parsing a complete expression `e` expected to be\n+    // followed by some token from the set edible + inedible.  Recover\n+    // from anticipated input errors, discarding erroneous characters.\n+    pub fn commit_expr(&self, e: @expr, edible: &[token::Token], inedible: &[token::Token]) {\n+        debug!(\"commit_expr %?\", e);\n+        match e.node {\n+            expr_path(*) => {\n+                // might be unit-struct construction; check for recoverableinput error.\n+                let expected = vec::append(edible.to_owned(), inedible);\n+                self.check_for_erroneous_unit_struct_expecting(expected);\n+            }\n+            _ => {}\n+        }\n+        self.expect_one_of(edible, inedible)\n+    }\n+\n+    pub fn commit_expr_expecting(&self, e: @expr, edible: token::Token) {\n+        self.commit_expr(e, &[edible], &[])\n+    }\n+\n+    // Commit to parsing a complete statement `s`, which expects to be\n+    // followed by some token from the set edible + inedible.  Check\n+    // for recoverable input errors, discarding erroneous characters.\n+    pub fn commit_stmt(&self, s: @stmt, edible: &[token::Token], inedible: &[token::Token]) {\n+        debug!(\"commit_stmt %?\", s);\n+        let _s = s; // unused, but future checks might want to inspect `s`.\n+        if self.last_token.map_default(false, |t|is_ident_or_path(*t)) {\n+            let expected = vec::append(edible.to_owned(), inedible);\n+            self.check_for_erroneous_unit_struct_expecting(expected);\n+        }\n+        self.expect_one_of(edible, inedible)\n+    }\n+\n+    pub fn commit_stmt_expecting(&self, s: @stmt, edible: token::Token) {\n+        self.commit_stmt(s, &[edible], &[])\n+    }\n+\n     pub fn parse_ident(&self) -> ast::ident {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n@@ -578,6 +664,12 @@ impl Parser {\n     // advance the parser by one token\n     pub fn bump(&self) {\n         *self.last_span = *self.span;\n+        // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n+        *self.last_token = if is_ident_or_path(self.token) {\n+            Some(~(*self.token).clone())\n+        } else {\n+            None\n+        };\n         let next = if *self.buffer_start == *self.buffer_end {\n             self.reader.next_token()\n         } else {\n@@ -1595,17 +1687,19 @@ impl Parser {\n                 return self.mk_expr(lo, hi, expr_lit(lit));\n             }\n             let mut es = ~[self.parse_expr()];\n+            self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n             while *self.token == token::COMMA {\n                 self.bump();\n                 if *self.token != token::RPAREN {\n                     es.push(self.parse_expr());\n+                    self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n                 }\n                 else {\n                     trailing_comma = true;\n                 }\n             }\n             hi = self.span.hi;\n-            self.expect(&token::RPAREN);\n+            self.commit_expr_expecting(*es.last(), token::RPAREN);\n \n             return if es.len() == 1 && !trailing_comma {\n                 self.mk_expr(lo, self.span.hi, expr_paren(es[0]))\n@@ -1745,7 +1839,7 @@ impl Parser {\n                             break;\n                         }\n \n-                        self.expect(&token::COMMA);\n+                        self.commit_expr(fields.last().expr, &[token::COMMA], &[token::RBRACE]);\n \n                         if self.eat(&token::DOTDOT) {\n                             base = Some(self.parse_expr());\n@@ -1760,7 +1854,7 @@ impl Parser {\n                     }\n \n                     hi = pth.span.hi;\n-                    self.expect(&token::RBRACE);\n+                    self.commit_expr_expecting(fields.last().expr, token::RBRACE);\n                     ex = expr_struct(pth, fields, base);\n                     return self.mk_expr(lo, hi, ex);\n                 }\n@@ -1854,7 +1948,7 @@ impl Parser {\n                 self.bump();\n                 let ix = self.parse_expr();\n                 hi = ix.span.hi;\n-                self.expect(&token::RBRACKET);\n+                self.commit_expr_expecting(ix, token::RBRACKET);\n                 e = self.mk_expr(lo, hi, self.mk_index(e, ix));\n               }\n \n@@ -2463,7 +2557,7 @@ impl Parser {\n     fn parse_match_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n-        self.expect(&token::LBRACE);\n+        self.commit_expr_expecting(discriminant, token::LBRACE);\n         let mut arms: ~[arm] = ~[];\n         while *self.token != token::RBRACE {\n             let pats = self.parse_pats();\n@@ -2479,7 +2573,7 @@ impl Parser {\n                 && *self.token != token::RBRACE;\n \n             if require_comma {\n-                self.expect(&token::COMMA);\n+                self.commit_expr(expr, &[token::COMMA], &[token::RBRACE]);\n             } else {\n                 self.eat(&token::COMMA);\n             }\n@@ -3179,37 +3273,26 @@ impl Parser {\n                     match stmt.node {\n                         stmt_expr(e, stmt_id) => {\n                             // expression without semicolon\n-                            let has_semi;\n+                            if classify::stmt_ends_with_semi(stmt) {\n+                                // Just check for errors and recover; do not eat semicolon yet.\n+                                self.commit_stmt(stmt, &[], &[token::SEMI, token::RBRACE]);\n+                            }\n+\n                             match *self.token {\n                                 token::SEMI => {\n-                                    has_semi = true;\n+                                    self.bump();\n+                                    stmts.push(@codemap::spanned {\n+                                        node: stmt_semi(e, stmt_id),\n+                                        span: stmt.span,\n+                                    });\n                                 }\n                                 token::RBRACE => {\n-                                    has_semi = false;\n                                     expr = Some(e);\n                                 }\n-                                ref t => {\n-                                    has_semi = false;\n-                                    if classify::stmt_ends_with_semi(stmt) {\n-                                        self.fatal(\n-                                            fmt!(\n-                                                \"expected `;` or `}` after \\\n-                                                 expression but found `%s`\",\n-                                                self.token_to_str(t)\n-                                            )\n-                                        );\n-                                    }\n+                                _ => {\n                                     stmts.push(stmt);\n                                 }\n                             }\n-\n-                            if has_semi {\n-                                self.bump();\n-                                stmts.push(@codemap::spanned {\n-                                    node: stmt_semi(e, stmt_id),\n-                                    span: stmt.span,\n-                                });\n-                            }\n                         }\n                         stmt_mac(ref m, _) => {\n                             // statement macro; might be an expr\n@@ -3245,7 +3328,7 @@ impl Parser {\n                             stmts.push(stmt);\n \n                             if classify::stmt_ends_with_semi(stmt) {\n-                                self.expect(&token::SEMI);\n+                                self.commit_stmt_expecting(stmt, token::SEMI);\n                             }\n                         }\n                     }\n@@ -3760,7 +3843,7 @@ impl Parser {\n                 }\n             }\n             if fields.len() == 0 {\n-                self.fatal(fmt!(\"Unit-like struct should be written as `struct %s;`\",\n+                self.fatal(fmt!(\"Unit-like struct definition should be written as `struct %s;`\",\n                                 get_ident_interner().get(class_name.name)));\n             }\n             self.bump();\n@@ -3952,7 +4035,7 @@ impl Parser {\n         let ty = self.parse_ty(false);\n         self.expect(&token::EQ);\n         let e = self.parse_expr();\n-        self.expect(&token::SEMI);\n+        self.commit_expr_expecting(e, token::SEMI);\n         (id, item_static(ty, m, e), None)\n     }\n "}, {"sha": "b6a40a0e8e976f114bf88b2b1d0430e9673ecae7", "filename": "src/test/compile-fail/struct-no-fields-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-2.rs?ref=de48274c50952dc629914e33d8b65ba222c1e093", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: Unit-like struct construction is written with no trailing `{ }`\n+struct Foo;\n+\n+fn f2() {\n+    let _end_stmt     = Foo { };\n+}\n+\n+fn main() {}"}, {"sha": "b6845ce72920847db282ed6d25b4e13d475a4662", "filename": "src/test/compile-fail/struct-no-fields-3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-3.rs?ref=de48274c50952dc629914e33d8b65ba222c1e093", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: Unit-like struct construction is written with no trailing `{ }`\n+struct Foo;\n+\n+fn g3() {\n+    let _mid_tuple    = (Foo { }, 2);\n+}\n+\n+fn main() {}"}, {"sha": "0bd3c8d58553dc37471de5230960add438a12a5a", "filename": "src/test/compile-fail/struct-no-fields-4.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-4.rs?ref=de48274c50952dc629914e33d8b65ba222c1e093", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: Unit-like struct construction is written with no trailing `{ }`\n+struct Foo;\n+\n+fn h4() {\n+    let _end_of_tuple = (3, Foo { });\n+}\n+\n+fn main() {}"}, {"sha": "1af72ff6d78d930a861f1e68598e2cb7d8bd81d8", "filename": "src/test/compile-fail/struct-no-fields-5.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields-5.rs?ref=de48274c50952dc629914e33d8b65ba222c1e093", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: Unit-like struct construction is written with no trailing `{ }`\n+struct Foo;\n+\n+fn i5() {\n+    let _end_of_block = { Foo { } };\n+}\n+\n+fn main() {}"}, {"sha": "5053b842e65ba3052b1861bb51c3834595766c68", "filename": "src/test/compile-fail/struct-no-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de48274c50952dc629914e33d8b65ba222c1e093/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-no-fields.rs?ref=de48274c50952dc629914e33d8b65ba222c1e093", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: Unit-like struct should be written as `struct Foo;`\n+// error-pattern: Unit-like struct definition should be written as `struct Foo;`\n struct Foo {}\n \n fn main() {}"}]}