{"sha": "8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "node_id": "C_kwDOAAsO6NoAKDhlODE4ZmZhMWI4NWY0ZTc0MGM0MDk2ZmQzOGM2MmIyYjczZjRkODM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-17T17:18:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-17T17:18:01Z"}, "message": "Auto merge of #2029 - RalfJung:simd-bitmask, r=RalfJung\n\nimplement simd bitmask intrinsics\n\nCc https://github.com/rust-lang/miri/issues/1912", "tree": {"sha": "dab443487606cb46dd39af6c8966ee33d9866f63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dab443487606cb46dd39af6c8966ee33d9866f63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "html_url": "https://github.com/rust-lang/rust/commit/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "670dc7d55126cad910e554d98ad6f49e5381f645", "url": "https://api.github.com/repos/rust-lang/rust/commits/670dc7d55126cad910e554d98ad6f49e5381f645", "html_url": "https://github.com/rust-lang/rust/commit/670dc7d55126cad910e554d98ad6f49e5381f645"}, {"sha": "1b1321a685f4d5e362786c1876dbcc9e2de866ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1321a685f4d5e362786c1876dbcc9e2de866ba", "html_url": "https://github.com/rust-lang/rust/commit/1b1321a685f4d5e362786c1876dbcc9e2de866ba"}], "stats": {"total": 145, "additions": 128, "deletions": 17}, "files": [{"sha": "fe2f33ffd33e52c78b20f9aa2c35fa20774779c5", "filename": "src/helpers.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "patch": "@@ -775,18 +775,3 @@ pub fn isolation_abort_error(name: &str) -> InterpResult<'static> {\n         name,\n     )))\n }\n-\n-pub fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n-    // SIMD uses all-1 as pattern for \"true\"\n-    let val = if b { -1 } else { 0 };\n-    Scalar::from_int(val, size)\n-}\n-\n-pub fn simd_element_to_bool<'tcx>(elem: ImmTy<'tcx, Tag>) -> InterpResult<'tcx, bool> {\n-    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n-    Ok(match val {\n-        0 => false,\n-        -1 => true,\n-        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n-    })\n-}"}, {"sha": "c344d0ff9c34db5c4c956f2f3448bc6407b8380a", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 83, "deletions": 2, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "patch": "@@ -1,14 +1,15 @@\n+use std::convert::TryInto;\n use std::iter;\n \n use log::trace;\n \n use rustc_apfloat::{Float, Round};\n use rustc_middle::ty::layout::{HasParamEnv, IntegerExt, LayoutOf};\n use rustc_middle::{mir, mir::BinOp, ty, ty::FloatTy};\n-use rustc_target::abi::{Align, Integer};\n+use rustc_target::abi::{Align, Endian, HasDataLayout, Integer, Size};\n \n use crate::*;\n-use helpers::{bool_to_simd_element, check_arg_count, simd_element_to_bool};\n+use helpers::check_arg_count;\n \n pub enum AtomicOp {\n     MirOp(mir::BinOp, bool),\n@@ -663,6 +664,45 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.write_immediate(*val, &dest.into())?;\n                 }\n             }\n+            \"simd_select_bitmask\" => {\n+                let &[ref mask, ref yes, ref no] = check_arg_count(args)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+                let bitmask_len = dest_len.max(8);\n+\n+                assert!(mask.layout.ty.is_integral());\n+                assert!(bitmask_len <= 64);\n+                assert_eq!(bitmask_len, mask.layout.size.bits());\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+\n+                let mask: u64 = this\n+                    .read_scalar(mask)?\n+                    .check_init()?\n+                    .to_bits(mask.layout.size)?\n+                    .try_into()\n+                    .unwrap();\n+                for i in 0..dest_len {\n+                    let mask =\n+                        mask & (1 << simd_bitmask_index(i, dest_len, this.data_layout().endian));\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if mask != 0 { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+                for i in dest_len..bitmask_len {\n+                    // If the mask is \"padded\", ensure that padding is all-zero.\n+                    let mask = mask & (1 << i);\n+                    if mask != 0 {\n+                        throw_ub_format!(\n+                            \"a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\"\n+                        );\n+                    }\n+                }\n+            }\n             #[rustfmt::skip]\n             \"simd_cast\" | \"simd_as\" => {\n                 let &[ref op] = check_arg_count(args)?;\n@@ -787,6 +827,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     }\n                 }\n             }\n+            \"simd_bitmask\" => {\n+                let &[ref op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let bitmask_len = op_len.max(8);\n+\n+                assert!(dest.layout.ty.is_integral());\n+                assert!(bitmask_len <= 64);\n+                assert_eq!(bitmask_len, dest.layout.size.bits());\n+\n+                let mut res = 0u64;\n+                for i in 0..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    if simd_element_to_bool(op)? {\n+                        res |= 1 << simd_bitmask_index(i, op_len, this.data_layout().endian);\n+                    }\n+                }\n+                this.write_int(res, dest)?;\n+            }\n \n             // Atomic operations\n             \"atomic_load\" => this.atomic_load(args, dest, AtomicReadOp::SeqCst)?,\n@@ -1307,3 +1365,26 @@ fn fmin_op<'tcx>(\n         FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),\n     })\n }\n+\n+fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n+    // SIMD uses all-1 as pattern for \"true\"\n+    let val = if b { -1 } else { 0 };\n+    Scalar::from_int(val, size)\n+}\n+\n+fn simd_element_to_bool<'tcx>(elem: ImmTy<'tcx, Tag>) -> InterpResult<'tcx, bool> {\n+    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n+    Ok(match val {\n+        0 => false,\n+        -1 => true,\n+        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n+    })\n+}\n+\n+fn simd_bitmask_index(idx: u64, vec_len: u64, endianess: Endian) -> u64 {\n+    assert!(idx < vec_len);\n+    match endianess {\n+        Endian::Little => idx,\n+        Endian::Big => vec_len - 1 - idx, // reverse order of bits\n+    }\n+}"}, {"sha": "ab69072c30976d1237525d8554602dcdabc53892", "filename": "tests/compile-fail/intrinsics/simd-select-bitmask-invalid.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-select-bitmask-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-select-bitmask-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-select-bitmask-invalid.rs?ref=8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "patch": "@@ -0,0 +1,15 @@\n+#![feature(platform_intrinsics, repr_simd)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_select_bitmask<M, T>(m: M, yes: T, no: T) -> T;\n+}\n+\n+#[repr(simd)]\n+#[allow(non_camel_case_types)]\n+#[derive(Copy, Clone)]\n+struct i32x2(i32, i32);\n+\n+fn main() { unsafe {\n+    let x = i32x2(0, 1);\n+    simd_select_bitmask(0b11111111u8, x, x); //~ERROR bitmask less than 8 bits long must be filled with 0s for the remaining bits\n+} }"}, {"sha": "98f67cfcd7e1364e8e73a4e2406ff092a19cf710", "filename": "tests/compile-fail/intrinsics/simd-select-invalid-bool.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-select-invalid-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-select-invalid-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fsimd-select-invalid-bool.rs?ref=8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "patch": "@@ -0,0 +1,15 @@\n+#![feature(platform_intrinsics, repr_simd)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n+}\n+\n+#[repr(simd)]\n+#[allow(non_camel_case_types)]\n+#[derive(Copy, Clone)]\n+struct i32x2(i32, i32);\n+\n+fn main() { unsafe {\n+    let x = i32x2(0, 1);\n+    simd_select(x, x, x); //~ERROR must be all-0-bits or all-1-bits\n+} }"}, {"sha": "99a64ea370f6b872712e0ddc557f2be8f6bcc07f", "filename": "tests/run-pass/portable-simd.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/tests%2Frun-pass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83/tests%2Frun-pass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fportable-simd.rs?ref=8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "patch": "@@ -187,6 +187,21 @@ fn simd_mask() {\n     let intmask = Mask::from_int(i32x4::from_array([0, -1, 0, 0]));\n     assert_eq!(intmask, Mask::from_array([false, true, false, false]));\n     assert_eq!(intmask.to_array(), [false, true, false, false]);\n+\n+    let values = [\n+        true, false, false, true, false, false, true, false, true, true, false, false, false, true,\n+        false, true,\n+    ];\n+    let mask = Mask::<i64, 16>::from_array(values);\n+    let bitmask = mask.to_bitmask();\n+    assert_eq!(bitmask, 0b1010001101001001);\n+    assert_eq!(Mask::<i64, 16>::from_bitmask(bitmask), mask);\n+\n+    let values = [false, false, false, true];\n+    let mask = Mask::<i64, 4>::from_array(values);\n+    let bitmask = mask.to_bitmask();\n+    // FIXME fails until https://github.com/rust-lang/portable-simd/pull/267 lands: assert_eq!(bitmask, 0b1000);\n+    assert_eq!(Mask::<i64, 4>::from_bitmask(bitmask), mask);\n }\n \n fn simd_cast() {"}]}