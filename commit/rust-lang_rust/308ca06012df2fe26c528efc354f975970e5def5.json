{"sha": "308ca06012df2fe26c528efc354f975970e5def5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwOGNhMDYwMTJkZjJmZTI2YzUyOGVmYzM1NGY5NzU5NzBlNWRlZjU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-13T02:55:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-13T02:55:16Z"}, "message": "Rename str::unsafe to str::raw", "tree": {"sha": "11cf9a8ba8822b93da9ea3c7d78dd0fe1ed1553d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11cf9a8ba8822b93da9ea3c7d78dd0fe1ed1553d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/308ca06012df2fe26c528efc354f975970e5def5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/308ca06012df2fe26c528efc354f975970e5def5", "html_url": "https://github.com/rust-lang/rust/commit/308ca06012df2fe26c528efc354f975970e5def5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/308ca06012df2fe26c528efc354f975970e5def5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59c3c6c147be95cec1390f8eb75b98c5effa1699", "url": "https://api.github.com/repos/rust-lang/rust/commits/59c3c6c147be95cec1390f8eb75b98c5effa1699", "html_url": "https://github.com/rust-lang/rust/commit/59c3c6c147be95cec1390f8eb75b98c5effa1699"}], "stats": {"total": 100, "additions": 50, "deletions": 50}, "files": [{"sha": "06286906b70c336ab1d4e2693c95350ea83548ef", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -170,7 +170,7 @@ impl T : FromStr {\n fn to_str(n: T, radix: uint) -> ~str {\n     do to_str_bytes(n, radix) |slice| {\n         do vec::as_buf(slice) |p, len| {\n-            unsafe { str::unsafe::from_buf_len(p, len) }\n+            unsafe { str::raw::from_buf_len(p, len) }\n         }\n     }\n }"}, {"sha": "50e12af8c04135af90b20fb11ea059ea4e7093c6", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -69,7 +69,7 @@ fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n     do vec::as_mut_buf(buf) |b, sz| {\n         if f(b, sz as size_t) unsafe {\n-            Some(str::unsafe::from_buf(b as *u8))\n+            Some(str::raw::from_buf(b as *u8))\n         } else {\n             None\n         }\n@@ -226,7 +226,7 @@ mod global_env {\n                     option::None::<~str>\n                 } else {\n                     let s = unsafe::reinterpret_cast(&s);\n-                    option::Some::<~str>(str::unsafe::from_buf(s))\n+                    option::Some::<~str>(str::raw::from_buf(s))\n                 };\n             }\n         }"}, {"sha": "7c6af7e1c40276b3920c7681d574622f40772bb9", "filename": "src/libcore/str.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -114,7 +114,7 @@ export\n    escape_default,\n    escape_unicode,\n \n-   unsafe,\n+   raw,\n    extensions,\n    StrSlice,\n    UniqueStr;\n@@ -132,12 +132,12 @@ Section: Creating a string\n  */\n pure fn from_bytes(vv: &[const u8]) -> ~str {\n     assert is_utf8(vv);\n-    return unsafe { unsafe::from_bytes(vv) };\n+    return unsafe { raw::from_bytes(vv) };\n }\n \n /// Copy a slice into a new unique str\n pure fn from_slice(s: &str) -> ~str {\n-    unsafe { unsafe::slice_bytes(s, 0, len(s)) }\n+    unsafe { raw::slice_bytes(s, 0, len(s)) }\n }\n \n /**\n@@ -219,7 +219,7 @@ fn push_char(&s: ~str, ch: char) {\n             }\n         }\n \n-        unsafe::set_len(s, new_len);\n+        raw::set_len(s, new_len);\n     }\n }\n \n@@ -254,7 +254,7 @@ fn push_str_no_overallocate(&lhs: ~str, rhs: &str) {\n                 ptr::memcpy(dst, rbuf, rlen);\n             }\n         }\n-        unsafe::set_len(lhs, llen + rlen);\n+        raw::set_len(lhs, llen + rlen);\n     }\n }\n /// Appends a string slice to the back of a string\n@@ -271,7 +271,7 @@ fn push_str(&lhs: ~str, rhs: &str) {\n                 ptr::memcpy(dst, rbuf, rlen);\n             }\n         }\n-        unsafe::set_len(lhs, llen + rlen);\n+        raw::set_len(lhs, llen + rlen);\n     }\n }\n \n@@ -318,7 +318,7 @@ fn pop_char(&s: ~str) -> char {\n     let end = len(s);\n     assert end > 0u;\n     let {ch, prev} = char_range_at_reverse(s, end);\n-    unsafe { unsafe::set_len(s, prev); }\n+    unsafe { raw::set_len(s, prev); }\n     return ch;\n }\n \n@@ -331,7 +331,7 @@ fn pop_char(&s: ~str) -> char {\n  */\n fn shift_char(&s: ~str) -> char {\n     let {ch, next} = char_range_at(s, 0u);\n-    s = unsafe { unsafe::slice_bytes(s, next, len(s)) };\n+    s = unsafe { raw::slice_bytes(s, next, len(s)) };\n     return ch;\n }\n \n@@ -347,7 +347,7 @@ fn shift_char(&s: ~str) -> char {\n #[inline]\n fn view_shift_char(s: &a/str) -> (char, &a/str) {\n     let {ch, next} = char_range_at(s, 0u);\n-    let next_s = unsafe { unsafe::view_bytes(s, next, len(s)) };\n+    let next_s = unsafe { raw::view_bytes(s, next, len(s)) };\n     return (ch, next_s);\n }\n \n@@ -368,7 +368,7 @@ pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n \n     match find(s, |c| !chars_to_trim.contains(c)) {\n       None => ~\"\",\n-      Some(first) => unsafe { unsafe::slice_bytes(s, first, s.len()) }\n+      Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n     }\n }\n \n@@ -388,7 +388,7 @@ pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n       None => ~\"\",\n       Some(last) => {\n         let {next, _} = char_range_at(s, last);\n-        unsafe { unsafe::slice_bytes(s, 0u, next) }\n+        unsafe { raw::slice_bytes(s, 0u, next) }\n       }\n     }\n }\n@@ -410,7 +410,7 @@ pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n pure fn trim_left(s: &str) -> ~str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n-      Some(first) => unsafe { unsafe::slice_bytes(s, first, len(s)) }\n+      Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n     }\n }\n \n@@ -420,7 +420,7 @@ pure fn trim_right(s: &str) -> ~str {\n       None => ~\"\",\n       Some(last) => {\n         let {next, _} = char_range_at(s, last);\n-        unsafe { unsafe::slice_bytes(s, 0u, next) }\n+        unsafe { raw::slice_bytes(s, 0u, next) }\n       }\n     }\n }\n@@ -482,7 +482,7 @@ pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n-    unsafe { unsafe::slice_bytes(s, begin, end) }\n+    unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n /**\n@@ -494,7 +494,7 @@ pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n-    unsafe { unsafe::view_bytes(s, begin, end) }\n+    unsafe { raw::view_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n@@ -527,15 +527,15 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             if s[i] == b {\n                 if allow_empty || start < i unchecked {\n                     vec::push(result,\n-                              unsafe { unsafe::slice_bytes(s, start, i) });\n+                              unsafe { raw::slice_bytes(s, start, i) });\n                 }\n                 start = i + 1u;\n                 done += 1u;\n             }\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            unsafe { vec::push(result, unsafe::slice_bytes(s, start, l) ) };\n+            unsafe { vec::push(result, raw::slice_bytes(s, start, l) ) };\n         }\n         move result\n     } else {\n@@ -570,15 +570,15 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i unchecked {\n-                vec::push(result, unsafe { unsafe::slice_bytes(s, start, i)});\n+                vec::push(result, unsafe { raw::slice_bytes(s, start, i)});\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_empty || start < l unchecked {\n-        vec::push(result, unsafe { unsafe::slice_bytes(s, start, l) });\n+        vec::push(result, unsafe { raw::slice_bytes(s, start, l) });\n     }\n     move result\n }\n@@ -632,7 +632,7 @@ pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n-        unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n+        unsafe { vec::push(result, raw::slice_bytes(s, from, to)); }\n     }\n     move result\n }\n@@ -641,7 +641,7 @@ pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n-            unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n+            unsafe { vec::push(result, raw::slice_bytes(s, from, to)); }\n         }\n     }\n     move result\n@@ -661,7 +661,7 @@ pure fn lines_any(s: &str) -> ~[~str] {\n         let l = len(s);\n         let mut cp = copy s;\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n-            unsafe { unsafe::set_len(cp, l - 1u); }\n+            unsafe { raw::set_len(cp, l - 1u); }\n         }\n         move cp\n     })\n@@ -703,7 +703,7 @@ pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n         if first { first = false; } else { unchecked {push_str(result, to); }}\n-        unsafe { push_str(result, unsafe::slice_bytes(s, start, end)); }\n+        unsafe { push_str(result, raw::slice_bytes(s, start, end)); }\n     }\n     move result\n }\n@@ -1963,7 +1963,7 @@ pure fn escape_unicode(s: &str) -> ~str {\n }\n \n /// Unsafe operations\n-mod unsafe {\n+mod raw {\n    export\n       from_buf,\n       from_buf_len,\n@@ -2029,7 +2029,7 @@ mod unsafe {\n     }\n \n     /// Converts a byte to a string.\n-    unsafe fn from_byte(u: u8) -> ~str { unsafe::from_bytes([u]) }\n+    unsafe fn from_byte(u: u8) -> ~str { raw::from_bytes([u]) }\n \n     /**\n      * Takes a bytewise (not UTF-8) slice from a string.\n@@ -2112,7 +2112,7 @@ mod unsafe {\n         let len = len(s);\n         assert (len > 0u);\n         let b = s[0];\n-        s = unsafe { unsafe::slice_bytes(s, 1u, len) };\n+        s = unsafe { raw::slice_bytes(s, 1u, len) };\n         return b;\n     }\n \n@@ -2646,9 +2646,9 @@ mod tests {\n     #[test]\n     fn test_unsafe_slice() {\n         unsafe {\n-            assert ~\"ab\" == unsafe::slice_bytes(~\"abc\", 0u, 2u);\n-            assert ~\"bc\" == unsafe::slice_bytes(~\"abc\", 1u, 3u);\n-            assert ~\"\" == unsafe::slice_bytes(~\"abc\", 1u, 1u);\n+            assert ~\"ab\" == raw::slice_bytes(~\"abc\", 0u, 2u);\n+            assert ~\"bc\" == raw::slice_bytes(~\"abc\", 1u, 3u);\n+            assert ~\"\" == raw::slice_bytes(~\"abc\", 1u, 1u);\n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n@@ -2662,7 +2662,7 @@ mod tests {\n                 return rs;\n             }\n             assert half_a_million_letter_a() ==\n-                unsafe::slice_bytes(a_million_letter_a(), 0u, 500000u);\n+                raw::slice_bytes(a_million_letter_a(), 0u, 500000u);\n         }\n     }\n \n@@ -2881,23 +2881,23 @@ mod tests {\n     #[test]\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";\n-        let b = unsafe { unsafe::shift_byte(s) };\n+        let b = unsafe { raw::shift_byte(s) };\n         assert (s == ~\"BC\");\n         assert (b == 65u8);\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n-        let b = unsafe { unsafe::pop_byte(s) };\n+        let b = unsafe { raw::pop_byte(s) };\n         assert (s == ~\"AB\");\n         assert (b == 67u8);\n     }\n \n     #[test]\n     fn test_unsafe_from_bytes() {\n         let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-        let b = unsafe { unsafe::from_bytes(a) };\n+        let b = unsafe { raw::from_bytes(a) };\n         assert (b == ~\"AAAAAAA\");\n     }\n \n@@ -2941,7 +2941,7 @@ mod tests {\n         unsafe {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n-            let c = unsafe::from_buf(b);\n+            let c = raw::from_buf(b);\n             assert (c == ~\"AAAAAAA\");\n         }\n     }\n@@ -2979,7 +2979,7 @@ mod tests {\n         unsafe {\n             let s = ~\"hello\";\n             let sb = as_buf(s, |b, _l| b);\n-            let s_cstr = unsafe::from_buf(sb);\n+            let s_cstr = raw::from_buf(sb);\n             assert s_cstr == s;\n         }\n     }"}, {"sha": "5610a00e2caa86958b9e4fd54f9622de934640cf", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -175,7 +175,7 @@ fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n pure fn to_str(num: T, radix: uint) -> ~str {\n     do to_str_bytes(false, num, radix) |slice| {\n         do vec::as_buf(slice) |p, len| {\n-            unsafe { str::unsafe::from_buf_len(p, len) }\n+            unsafe { str::raw::from_buf_len(p, len) }\n         }\n     }\n }"}, {"sha": "f6b64cc24266f155dee0d265e589d29f49309781", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -834,7 +834,7 @@ unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n         // to see if it is the string representation of\n         // INADDR_NONE (0xffffffff or 255.255.255.255 on\n         // many platforms)\n-        str::unsafe::from_buf(dst_buf)\n+        str::raw::from_buf(dst_buf)\n     }\n }\n unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n@@ -852,7 +852,7 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);\n         match result {\n-          0i32 => str::unsafe::from_buf(dst_buf),\n+          0i32 => str::raw::from_buf(dst_buf),\n           _ => ~\"\"\n         }\n     }\n@@ -962,17 +962,17 @@ unsafe fn free_base_of_buf(buf: uv_buf_t) {\n unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::addr_of(err);\n-    let err_name = str::unsafe::from_c_str(err_name(err_ptr));\n-    let err_msg = str::unsafe::from_c_str(strerror(err_ptr));\n+    let err_name = str::raw::from_c_str(err_name(err_ptr));\n+    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n                     err_name, err_msg);\n }\n \n unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::addr_of(err);\n-    let err_name = str::unsafe::from_c_str(err_name(err_ptr));\n-    let err_msg = str::unsafe::from_c_str(strerror(err_ptr));\n+    let err_name = str::raw::from_c_str(err_name(err_ptr));\n+    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     { err_name: err_name, err_msg: err_msg }\n }\n "}, {"sha": "0079ec9f363a73e07d39920003d58553e027b628", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -37,7 +37,7 @@ fn llvm_err(sess: session, msg: ~str) -> ! unsafe {\n     let cstr = llvm::LLVMRustGetLastError();\n     if cstr == ptr::null() {\n         sess.fatal(msg);\n-    } else { sess.fatal(msg + ~\": \" + str::unsafe::from_c_str(cstr)); }\n+    } else { sess.fatal(msg + ~\": \" + str::raw::from_c_str(cstr)); }\n }\n \n fn WriteOutputFile(sess:session,"}, {"sha": "e12d158dd8ba48bdd9d5ae946a2fcca3c1543099", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -181,7 +181,7 @@ fn get_metadata_section(os: os,\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n         let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        let name = unsafe { str::unsafe::from_c_str(name_buf) };\n+        let name = unsafe { str::raw::from_c_str(name_buf) };\n         if name == meta_section_name(os) {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;"}, {"sha": "7194b0fbb4bbd372aa5500da019bc5696f0312de", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -59,7 +59,7 @@ fn make_repeat_fasta(wr: io::Writer, id: ~str, desc: ~str, s: ~str, n: int) unsa\n     let mut op: ~str = ~\"\";\n     let sl: uint = str::len(s);\n     for uint::range(0u, n as uint) |i| {\n-        str::unsafe::push_byte(op, s[i % sl]);\n+        str::raw::push_byte(op, s[i % sl]);\n         if str::len(op) >= LINE_LENGTH() {\n             wr.write_line(op);\n             op = ~\"\";"}, {"sha": "da4a226d9c028cdd26a24cbd0426f070151ebaa4", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -49,7 +49,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n       let (k,v) = kv;\n-      buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v));\n+      buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::raw::from_bytes(k)), v));\n       return true;\n    });\n "}, {"sha": "5da1fd2ecd0ee3d0c245a44a67928a5a97745c10", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/308ca06012df2fe26c528efc354f975970e5def5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308ca06012df2fe26c528efc354f975970e5def5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=308ca06012df2fe26c528efc354f975970e5def5", "patch": "@@ -48,7 +48,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n       let (k,v) = kv;\n-      buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v));\n+      buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::raw::from_bytes(k)), v));\n       return true;\n    });\n "}]}