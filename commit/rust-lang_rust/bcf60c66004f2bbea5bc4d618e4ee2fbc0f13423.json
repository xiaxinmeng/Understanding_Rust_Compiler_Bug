{"sha": "bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZjYwYzY2MDA0ZjJiYmVhNWJjNGQ2MThlNGVlMmZiYzBmMTM0MjM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T11:52:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T11:54:02Z"}, "message": "Warn when inserting an implicit copy that may be expensive", "tree": {"sha": "edc3ac0bf1ed95900f1497b54a79314e4c40117b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edc3ac0bf1ed95900f1497b54a79314e4c40117b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423", "html_url": "https://github.com/rust-lang/rust/commit/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "html_url": "https://github.com/rust-lang/rust/commit/8dd46d4384faa257f940e3f3d51f70f6655b3b4b"}], "stats": {"total": 69, "additions": 53, "deletions": 16}, "files": [{"sha": "cfffa6e89c6c93ffe1a3f8946f205cec5733c767", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423", "patch": "@@ -26,6 +26,7 @@ type restrict =\n     @{root_var: option::t<node_id>,\n       node_id: node_id,\n       ty: ty::t,\n+      span: span,\n       local_id: uint,\n       bindings: [node_id],\n       unsafe_ty: option::t<ty::t>,\n@@ -169,6 +170,12 @@ fn cant_copy(cx: ctx, r: restrict) -> bool {\n     if ty::type_allows_implicit_copy(cx.tcx, r.ty) {\n         r.given_up = true;\n         cx.copy_map.insert(r.node_id, ());\n+        if copy_is_expensive(cx.tcx, r.ty) {\n+            // FIXME better message\n+            cx.tcx.sess.span_warn(r.span,\n+                                  \"inserting an implicit copy for type \" +\n+                                  util::ppaux::ty_to_str(cx.tcx, r.ty));\n+        }\n         ret false;\n     } else { ret true; }\n }\n@@ -201,6 +208,7 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n              @{root_var: root_var,\n                node_id: arg_t.mode == ast::by_mut_ref ? 0 : arg.id,\n                ty: arg_t.ty,\n+               span: arg.span,\n                local_id: cx.next_local,\n                bindings: [arg.id],\n                unsafe_ty: unsafe_t,\n@@ -282,19 +290,17 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n         let new_sc = sc;\n         if vec::len(dnums) > 0u {\n             let root_var = path_def_id(cx, root.ex);\n-            new_sc =\n-                @(*sc +\n-                      [\n-                       // FIXME need to use separate restrict for each binding\n-                       @{root_var: root_var,\n-                         node_id: 0,\n-                         ty: ty::mk_int(cx.tcx),\n-                         local_id: cx.next_local,\n-                         bindings: dnums,\n-                         unsafe_ty: inner_mut(root.ds),\n-                         depends_on: deps(sc, root_var),\n-                         mutable ok: valid,\n-                         mutable given_up: false}]);\n+            // FIXME need to use separate restrict for each binding\n+            new_sc = @(*sc + [@{root_var: root_var,\n+                                node_id: 0,\n+                                ty: ty::mk_int(cx.tcx),\n+                                span: a.pats[0].span,\n+                                local_id: cx.next_local,\n+                                bindings: dnums,\n+                                unsafe_ty: inner_mut(root.ds),\n+                                depends_on: deps(sc, root_var),\n+                                mutable ok: valid,\n+                                mutable given_up: false}]);\n         }\n         register_locals(cx, a.pats[0]);\n         visit::visit_arm(a, new_sc, v);\n@@ -332,10 +338,10 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n     let root_var = path_def_id(cx, root.ex);\n     let new_sc =\n         @{root_var: root_var,\n-\n           // FIXME reenable when trans knows how to copy for vars\n           node_id: 0, // blk.node.id,\n           ty: elt_t,\n+          span: local.node.pat.span,\n           local_id: cx.next_local,\n           bindings: ast_util::pat_binding_ids(local.node.pat),\n           unsafe_ty: unsafe,\n@@ -516,6 +522,37 @@ fn def_is_local(d: ast::def, objfields_count: bool) -> bool {\n         };\n }\n \n+// Heuristic, somewhat random way to decide whether to warn when inserting an\n+// implicit copy.\n+fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n+    fn score_ty(tcx: ty::ctxt, ty: ty::t) -> uint {\n+        ret alt ty::struct(tcx, ty) {\n+          ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. |\n+          ty::ty_uint. | ty::ty_float. | ty::ty_machine(_) |\n+          ty::ty_char. | ty::ty_type. | ty::ty_native(_) |\n+          ty::ty_ptr(_) { 1u }\n+          ty::ty_box(_) { 3u }\n+          ty::ty_constr(t, _) | ty::ty_res(_, t, _) { score_ty(tcx, t) }\n+          ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _, _) |\n+          ty::ty_obj(_) { 4u }\n+          ty::ty_str. | ty::ty_vec(_) { 50u }\n+          ty::ty_uniq(t) { 1u + score_ty(tcx, t) }\n+          ty::ty_tag(_, ts) | ty::ty_tup(ts) {\n+            let sum = 0u;\n+            for t in ts { sum += score_ty(tcx, t); }\n+            sum\n+          }\n+          ty::ty_rec(fs) {\n+            let sum = 0u;\n+            for f in fs { sum += score_ty(tcx, f.mt.ty); }\n+            sum\n+          }\n+          ty::ty_param(_, _) { 5u }\n+        };\n+    }\n+    ret score_ty(tcx, ty) > 8u;\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "2276d3486115b97d3361b2606ff93cb06792cdb6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=bcf60c66004f2bbea5bc4d618e4ee2fbc0f13423", "patch": "@@ -2604,8 +2604,8 @@ fn build_closure(cx: @block_ctxt, upvars: @[ast::def], copying: bool) ->\n         closure_tys += [ty];\n     }\n \n-    ret build_environment(cx, cx.fcx.lltydescs, closure_tys, closure_vals,\n-                          copying);\n+    ret build_environment(cx, copy cx.fcx.lltydescs, closure_tys,\n+                          closure_vals, copying);\n }\n \n // Return a pointer to the stored typarams in a closure."}]}