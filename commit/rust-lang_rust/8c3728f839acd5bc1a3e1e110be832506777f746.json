{"sha": "8c3728f839acd5bc1a3e1e110be832506777f746", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMzcyOGY4MzlhY2Q1YmMxYTNlMWUxMTBiZTgzMjUwNjc3N2Y3NDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-06T21:45:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-06T21:45:51Z"}, "message": "auto merge of #5125 : nikomatsakis/rust/issue-4846-lifetime-defaults, r=nikomatsakis\n\nWork towards #4846.\r\n\r\n- Institute new region defaults where all omitted regions get a fresh lifetime.\r\n- Require explicit region names except in functions.\r\n- Fix a bug in region parameterization inference.  I've been putting this off because it will not be important when we remove RP inference in favor of explicit declarations, but then it was blocking this patch.\r\n\r\nr? @pcwalton", "tree": {"sha": "f23884b2da0f3486df5e73537a546f0661e052b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f23884b2da0f3486df5e73537a546f0661e052b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c3728f839acd5bc1a3e1e110be832506777f746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c3728f839acd5bc1a3e1e110be832506777f746", "html_url": "https://github.com/rust-lang/rust/commit/8c3728f839acd5bc1a3e1e110be832506777f746", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c3728f839acd5bc1a3e1e110be832506777f746/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02623871ed4e7d5b4d74bf21c0a710ee648a149b", "url": "https://api.github.com/repos/rust-lang/rust/commits/02623871ed4e7d5b4d74bf21c0a710ee648a149b", "html_url": "https://github.com/rust-lang/rust/commit/02623871ed4e7d5b4d74bf21c0a710ee648a149b"}, {"sha": "078fd23a077f4046a9951f02755e080d8e661e96", "url": "https://api.github.com/repos/rust-lang/rust/commits/078fd23a077f4046a9951f02755e080d8e661e96", "html_url": "https://github.com/rust-lang/rust/commit/078fd23a077f4046a9951f02755e080d8e661e96"}], "stats": {"total": 1287, "additions": 686, "deletions": 601}, "files": [{"sha": "4d42aa2b06704ce2de32b9acd5a4ce591e1294c3", "filename": "doc/rust.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -1144,22 +1144,23 @@ Constants are declared with the `const` keyword.\n A constant item must have an expression giving its definition.\n The definition expression of a constant is limited to expression forms that can be evaluated at compile time.\n \n-Constants must be explicitly typed. The type may be ```bool```, ```char```, a number, or a type derived from\n-those primitive types. The derived types are borrowed pointers, static arrays, tuples, and structs.\n+Constants must be explicitly typed. The type may be ```bool```, ```char```, a number, or a type derived from those primitive types.\n+The derived types are borrowed pointers, static arrays, tuples, and structs.\n+Borrowed pointers must be have the `'static` lifetime.\n \n ~~~~\n const bit1: uint = 1 << 0;\n const bit2: uint = 1 << 1;\n \n const bits: [uint * 2] = [bit1, bit2];\n-const string: &str = \"bitstring\";\n+const string: &'static str = \"bitstring\";\n \n struct BitsNStrings {\n     mybits: [uint *2],\n-    mystring: &str\n+    mystring: &'self str\n }\n \n-const bits_n_strings: BitsNStrings = BitsNStrings {\n+const bits_n_strings: BitsNStrings<'static> = BitsNStrings {\n     mybits: bits,\n     mystring: string\n };\n@@ -1630,7 +1631,7 @@ The following are examples of structure expressions:\n ~~~~\n # struct Point { x: float, y: float }\n # struct TuplePoint(float, float);\n-# mod game { pub struct User { name: &str, age: uint, score: uint } }\n+# mod game { pub struct User<'self> { name: &'self str, age: uint, score: uint } }\n # struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10f, y: 20f};\n TuplePoint(10f, 20f);\n@@ -2556,8 +2557,8 @@ order specified by the tuple type.\n An example of a tuple type and its use:\n \n ~~~~\n-type Pair = (int,&str);\n-let p: Pair = (10,\"hello\");\n+type Pair<'self> = (int,&'self str);\n+let p: Pair<'static> = (10,\"hello\");\n let (a, b) = p;\n assert b != \"world\";\n ~~~~\n@@ -2718,7 +2719,7 @@ fn add(x: int, y: int) -> int {\n \n let mut x = add(5,7);\n \n-type Binop = fn(int,int) -> int;\n+type Binop<'self> = &'self fn(int,int) -> int;\n let bo: Binop = add;\n x = bo(5,7);\n ~~~~~~~~"}, {"sha": "b1eceeab70eb667050131b23cdfc4743dcd0083d", "filename": "doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -1951,7 +1951,7 @@ trait Printable {\n Traits may be implemented for specific types with [impls]. An impl\n that implements a trait includes the name of the trait at the start of\n the definition, as in the following impls of `Printable` for `int`\n-and `&str`.\n+and `~str`.\n \n [impls]: #functions-and-methods\n \n@@ -1961,12 +1961,12 @@ impl Printable for int {\n     fn print(&self) { io::println(fmt!(\"%d\", *self)) }\n }\n \n-impl Printable for &str {\n+impl Printable for ~str {\n     fn print(&self) { io::println(*self) }\n }\n \n # 1.print();\n-# (\"foo\").print();\n+# (~\"foo\").print();\n ~~~~\n \n Methods defined in an implementation of a trait may be called just like"}, {"sha": "d87979f2a79d019138dec92723e8266bb86a6003", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -168,7 +168,7 @@ pub mod traits {\n     use kinds::Copy;\n     use ops::Add;\n \n-    impl<T:Copy> Add<&[const T],@[T]> for @[T] {\n+    impl<T:Copy> Add<&self/[const T],@[T]> for @[T] {\n         #[inline(always)]\n         pure fn add(&self, rhs: & &self/[const T]) -> @[T] {\n             append(*self, (*rhs))"}, {"sha": "45628318f905fe0c8d828d6d8bade2eb86e49d2c", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -22,8 +22,8 @@ use cast::transmute;\n  * NB: These must match the representation in the C++ runtime.\n  */\n \n-type DropGlue = fn(**TypeDesc, *c_void);\n-type FreeGlue = fn(**TypeDesc, *c_void);\n+type DropGlue = &self/fn(**TypeDesc, *c_void);\n+type FreeGlue = &self/fn(**TypeDesc, *c_void);\n \n type TaskID = uintptr_t;\n "}, {"sha": "566de2e880ebd8f4ee8a82bd94b76e9f3666b2f1", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -22,10 +22,10 @@ pub struct Handler<T, U> {\n \n pub struct Condition<T, U> {\n     name: &static/str,\n-    key: task::local_data::LocalDataKey<Handler<T, U>>\n+    key: task::local_data::LocalDataKey/&self<Handler<T, U>>\n }\n \n-pub impl<T, U> Condition<T, U> {\n+pub impl<T, U> Condition/&self<T, U> {\n     fn trap(&self, h: &self/fn(T) -> U) -> Trap/&self<T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n@@ -65,11 +65,11 @@ pub impl<T, U> Condition<T, U> {\n }\n \n struct Trap<T, U> {\n-    cond: &Condition<T, U>,\n+    cond: &self/Condition/&self<T, U>,\n     handler: @Handler<T, U>\n }\n \n-pub impl<T, U> Trap<T, U> {\n+pub impl<T, U> Trap/&self<T, U> {\n     fn in<V>(&self, inner: &self/fn() -> V) -> V {\n         unsafe {\n             let _g = Guard { cond: self.cond };\n@@ -81,10 +81,10 @@ pub impl<T, U> Trap<T, U> {\n }\n \n struct Guard<T, U> {\n-    cond: &Condition<T, U>\n+    cond: &self/Condition/&self<T, U>\n }\n \n-impl<T, U> Drop for Guard<T, U> {\n+impl<T, U> Drop for Guard/&self<T, U> {\n     fn finalize(&self) {\n         unsafe {\n             debug!(\"Guard: popping handler from TLS\");"}, {"sha": "36424d1bfaaa3cd20f6a61fa9c1dda0fa1a40e2f", "filename": "src/libcore/container.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,7 +10,6 @@\n \n //! Container traits\n \n-use cmp::Equiv;\n use option::Option;\n \n pub trait Container {"}, {"sha": "a077a6003b4959e5939784fbc5bdbe32c93162ed", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -115,7 +115,7 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n     return None;\n }\n \n-type Visitor = fn(root: **Word, tydesc: *Word) -> bool;\n+type Visitor = &self/fn(root: **Word, tydesc: *Word) -> bool;\n \n // Walks the list of roots for the given safe point, and calls visitor\n // on each root."}, {"sha": "4c455e8d6b2c7c8ee3c5aef42c3e7486deaf1a29", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -298,7 +298,7 @@ impl io::Writer for SipState {\n     }\n }\n \n-impl Streaming for &SipState {\n+impl Streaming for SipState {\n \n     #[inline(always)]\n     fn input(&self, buf: &[const u8]) {"}, {"sha": "c74e8ecee75e1a1e34e68680b373bac415fb466a", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -268,7 +268,9 @@ pub mod linear {\n         }\n     }\n \n-    impl<K:Hash + IterBytes + Eq,V> BaseIter<(&K, &V)> for LinearMap<K, V> {\n+    impl<K:Hash + IterBytes + Eq,V>\n+        BaseIter<(&self/K, &self/V)> for LinearMap<K, V>\n+    {\n         /// Visit all key-value pairs\n         pure fn each(&self, blk: fn(&(&self/K, &self/V)) -> bool) {\n             for uint::range(0, self.buckets.len()) |i| {"}, {"sha": "0621d78ec7e20f5d9ae8e10b36e32bc94d88961b", "filename": "src/libcore/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -585,11 +585,11 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n \n // Byte readers\n pub struct BytesReader {\n-    bytes: &[u8],\n+    bytes: &self/[u8],\n     mut pos: uint\n }\n \n-impl Reader for BytesReader {\n+impl Reader for BytesReader/&self {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - self.pos);\n "}, {"sha": "c92f747fc9872a1282c0cc53f637db95b04c18b2", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -20,7 +20,7 @@ use option::{None, Option, Some};\n use vec;\n \n /// A function used to initialize the elements of a sequence\n-pub type InitOp<T> = &fn(uint) -> T;\n+pub type InitOp<T> = &self/fn(uint) -> T;\n \n pub trait BaseIter<A> {\n     pure fn each(&self, blk: fn(v: &A) -> bool);"}, {"sha": "d5e38664270c1267a5e4c5cee98958f6289d7d52", "filename": "src/libcore/os.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -1028,11 +1028,11 @@ pub mod consts {\n     pub use os::consts::windows::*;\n \n     pub mod unix {\n-        pub const FAMILY: &str = \"unix\";\n+        pub const FAMILY: &static/str = \"unix\";\n     }\n \n     pub mod windows {\n-        pub const FAMILY: &str = \"windows\";\n+        pub const FAMILY: &static/str = \"windows\";\n     }\n \n     #[cfg(target_os = \"macos\")]\n@@ -1051,38 +1051,38 @@ pub mod consts {\n     pub use os::consts::win32::*;\n \n     pub mod macos {\n-        pub const SYSNAME: &str = \"macos\";\n-        pub const DLL_PREFIX: &str = \"lib\";\n-        pub const DLL_SUFFIX: &str = \".dylib\";\n-        pub const EXE_SUFFIX: &str = \"\";\n+        pub const SYSNAME: &static/str = \"macos\";\n+        pub const DLL_PREFIX: &static/str = \"lib\";\n+        pub const DLL_SUFFIX: &static/str = \".dylib\";\n+        pub const EXE_SUFFIX: &static/str = \"\";\n     }\n \n     pub mod freebsd {\n-        pub const SYSNAME: &str = \"freebsd\";\n-        pub const DLL_PREFIX: &str = \"lib\";\n-        pub const DLL_SUFFIX: &str = \".so\";\n-        pub const EXE_SUFFIX: &str = \"\";\n+        pub const SYSNAME: &static/str = \"freebsd\";\n+        pub const DLL_PREFIX: &static/str = \"lib\";\n+        pub const DLL_SUFFIX: &static/str = \".so\";\n+        pub const EXE_SUFFIX: &static/str = \"\";\n     }\n \n     pub mod linux {\n-        pub const SYSNAME: &str = \"linux\";\n-        pub const DLL_PREFIX: &str = \"lib\";\n-        pub const DLL_SUFFIX: &str = \".so\";\n-        pub const EXE_SUFFIX: &str = \"\";\n+        pub const SYSNAME: &static/str = \"linux\";\n+        pub const DLL_PREFIX: &static/str = \"lib\";\n+        pub const DLL_SUFFIX: &static/str = \".so\";\n+        pub const EXE_SUFFIX: &static/str = \"\";\n     }\n \n     pub mod android {\n-        pub const SYSNAME: &str = \"android\";\n-        pub const DLL_PREFIX: &str = \"lib\";\n-        pub const DLL_SUFFIX: &str = \".so\";\n-        pub const EXE_SUFFIX: &str = \"\";\n+        pub const SYSNAME: &static/str = \"android\";\n+        pub const DLL_PREFIX: &static/str = \"lib\";\n+        pub const DLL_SUFFIX: &static/str = \".so\";\n+        pub const EXE_SUFFIX: &static/str = \"\";\n     }\n \n     pub mod win32 {\n-        pub const SYSNAME: &str = \"win32\";\n-        pub const DLL_PREFIX: &str = \"\";\n-        pub const DLL_SUFFIX: &str = \".dll\";\n-        pub const EXE_SUFFIX: &str = \".exe\";\n+        pub const SYSNAME: &static/str = \"win32\";\n+        pub const DLL_PREFIX: &static/str = \"\";\n+        pub const DLL_SUFFIX: &static/str = \".dll\";\n+        pub const EXE_SUFFIX: &static/str = \".exe\";\n     }\n \n \n@@ -1099,16 +1099,16 @@ pub mod consts {\n     use os::consts::mips::*;\n \n     pub mod x86 {\n-        pub const ARCH: &str = \"x86\";\n+        pub const ARCH: &'static str = \"x86\";\n     }\n     pub mod x86_64 {\n-        pub const ARCH: &str = \"x86_64\";\n+        pub const ARCH: &'static str = \"x86_64\";\n     }\n     pub mod arm {\n-        pub const ARCH: &str = \"arm\";\n+        pub const ARCH: &'static str = \"arm\";\n     }\n     pub mod mips {\n-        pub const ARCH: &str = \"mips\";\n+        pub const ARCH: &'static str = \"mips\";\n     }\n }\n "}, {"sha": "6682aaa89683209b78973c4e3ce69ab8569e1e4e", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -440,7 +440,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     let p = unsafe { &*p_ };\n \n     struct DropState {\n-        p: &PacketHeader,\n+        p: &self/PacketHeader,\n \n         drop {\n             if task::failing() {"}, {"sha": "6a2e5003d1822d7a54c12d2c59569308d5d88a83", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -264,7 +264,7 @@ impl<T> Ord for *const T {\n \n // Equality for region pointers\n #[cfg(notest)]\n-impl<T:Eq> Eq for &const T {\n+impl<T:Eq> Eq for &self/const T {\n     #[inline(always)]\n     pure fn eq(&self, other: & &self/const T) -> bool {\n         return *(*self) == *(*other);\n@@ -277,7 +277,7 @@ impl<T:Eq> Eq for &const T {\n \n // Comparison for region pointers\n #[cfg(notest)]\n-impl<T:Ord> Ord for &const T {\n+impl<T:Ord> Ord for &self/const T {\n     #[inline(always)]\n     pure fn lt(&self, other: & &self/const T) -> bool {\n         *(*self) < *(*other)"}, {"sha": "4b76b2b89f2a0ce12bfa2f88ffab5df346d72ca7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -787,7 +787,7 @@ pure fn cmp(a: &str, b: &str) -> Ordering {\n }\n \n #[cfg(notest)]\n-impl TotalOrd for &str {\n+impl TotalOrd for &'self str {\n     pure fn cmp(&self, other: & &self/str) -> Ordering { cmp(*self, *other) }\n }\n \n@@ -833,7 +833,7 @@ pure fn gt(a: &str, b: &str) -> bool {\n }\n \n #[cfg(notest)]\n-impl Eq for &str {\n+impl Eq for &self/str {\n     #[inline(always)]\n     pure fn eq(&self, other: & &self/str) -> bool {\n         eq_slice((*self), (*other))\n@@ -875,7 +875,7 @@ impl Ord for ~str {\n }\n \n #[cfg(notest)]\n-impl Ord for &str {\n+impl Ord for &self/str {\n     #[inline(always)]\n     pure fn lt(&self, other: & &self/str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n@@ -899,7 +899,7 @@ impl Ord for @str {\n }\n \n #[cfg(notest)]\n-impl Equiv<~str> for &str {\n+impl Equiv<~str> for &'self str {\n     #[inline(always)]\n     pure fn equiv(&self, other: &~str) -> bool { eq_slice(*self, *other) }\n }\n@@ -2226,7 +2226,7 @@ pub mod traits {\n     use ops::Add;\n     use str::append;\n \n-    impl Add<&str,~str> for ~str {\n+    impl Add<&self/str,~str> for ~str {\n         #[inline(always)]\n         pure fn add(&self, rhs: & &self/str) -> ~str {\n             append(copy *self, (*rhs))\n@@ -2270,7 +2270,7 @@ pub trait StrSlice {\n }\n \n /// Extension methods for strings\n-impl StrSlice for &str {\n+impl StrSlice for &self/str {\n     /**\n      * Return true if a predicate matches all characters or if the string\n      * contains no characters"}, {"sha": "b080cd58c605afc35d056d162756b1a1e75e09fd", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -19,7 +19,7 @@ use libc::{c_void, c_char, size_t};\n use repr;\n use str;\n \n-pub type FreeGlue = fn(*TypeDesc, *c_void);\n+pub type FreeGlue = &self/fn(*TypeDesc, *c_void);\n \n // Corresponds to runtime type_desc type\n pub enum TypeDesc = {"}, {"sha": "725bb4ff89f6077d7f6728ab4243b2232591b772", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -44,7 +44,7 @@ use task::rt;\n  *\n  * These two cases aside, the interface is safe.\n  */\n-pub type LocalDataKey<T> = &fn(v: @T);\n+pub type LocalDataKey<T> = &self/fn(v: @T);\n \n /**\n  * Remove a task-local data value from the table, returning the"}, {"sha": "9605e4a43561fb8ac03d70d50b3e430da4500ace", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -123,7 +123,7 @@ struct TaskGroupData {\n }\n type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n \n-type TaskGroupInner = &mut Option<TaskGroupData>;\n+type TaskGroupInner = &self/mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {"}, {"sha": "60665bcddf6bdc3efe5135c0ad288e6fd99de3f3", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -19,7 +19,7 @@ use io::Writer;\n use option::{None, Option, Some};\n use str;\n \n-pub type Cb = &fn(buf: &[const u8]) -> bool;\n+pub type Cb = &self/fn(buf: &[const u8]) -> bool;\n \n /**\n  * A trait to implement in order to make a type hashable;\n@@ -197,7 +197,7 @@ impl IterBytes for int {\n     }\n }\n \n-impl<A:IterBytes> IterBytes for &[A] {\n+impl<A:IterBytes> IterBytes for &self/[A] {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         for (*self).each |elt| {\n@@ -352,7 +352,7 @@ pub pure fn iter_bytes_7<A: IterBytes,\n     g.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-impl IterBytes for &str {\n+impl IterBytes for &self/str {\n     #[inline(always)]\n     pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         do str::byte_slice(*self) |bytes| {\n@@ -389,7 +389,7 @@ impl<A:IterBytes> IterBytes for Option<A> {\n     }\n }\n \n-impl<A:IterBytes> IterBytes for &A {\n+impl<A:IterBytes> IterBytes for &self/A {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);"}, {"sha": "3b5d1f9e2ae4c3fff22c19df61b20ca810b35315", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -32,7 +32,7 @@ impl ToStr for ~str {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str { copy *self }\n }\n-impl ToStr for &str {\n+impl ToStr for &self/str {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n@@ -72,7 +72,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n     }\n }\n \n-impl<A:ToStr> ToStr for &[A] {\n+impl<A:ToStr> ToStr for &self/[A] {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {\n         unsafe {"}, {"sha": "02c14b155bbb5d1e4be05dc742839e2052e20e88", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -29,7 +29,7 @@ pub struct TrieMap<T> {\n     priv length: uint\n }\n \n-impl<T> BaseIter<(uint, &T)> for TrieMap<T> {\n+impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in order\n     #[inline(always)]\n     pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) {\n@@ -39,7 +39,7 @@ impl<T> BaseIter<(uint, &T)> for TrieMap<T> {\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<T> ReverseIter<(uint, &T)> for TrieMap<T> {\n+impl<T> ReverseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n     pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) {"}, {"sha": "14d35078d0d2e83b64b58eece4c9b2a74beff3db", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -71,7 +71,7 @@ pub trait ExtendedTupleOps<A,B> {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n }\n \n-impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&[A], &[B]) {\n+impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&self/[A], &self/[B]) {\n     #[inline(always)]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {"}, {"sha": "3ad580389df19100ca826c8b061a86fa9f2cfe02", "filename": "src/libcore/unstable/finally.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -31,7 +31,7 @@ pub trait Finally<T> {\n     fn finally(&self, dtor: &fn()) -> T;\n }\n \n-impl<T> Finally<T> for &fn() -> T {\n+impl<T> Finally<T> for &self/fn() -> T {\n     fn finally(&self, dtor: &fn()) -> T {\n         let _d = Finallyalizer {\n             dtor: dtor\n@@ -42,10 +42,10 @@ impl<T> Finally<T> for &fn() -> T {\n }\n \n struct Finallyalizer {\n-    dtor: &fn()\n+    dtor: &self/fn()\n }\n \n-impl Drop for Finallyalizer {\n+impl Drop for Finallyalizer/&self {\n     fn finalize(&self) {\n         (self.dtor)();\n     }"}, {"sha": "ac42e26fedda9ceaa0a637f84d5fa5be469f3db9", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -42,7 +42,7 @@ use sys::Closure;\n #[cfg(test)] use task::spawn;\n #[cfg(test)] use uint;\n \n-pub type GlobalDataKey<T> = &fn(v: T);\n+pub type GlobalDataKey<T> = &self/fn(v: T);\n \n pub unsafe fn global_data_clone_create<T:Owned + Clone>(\n     key: GlobalDataKey<T>, create: &fn() -> ~T) -> T {"}, {"sha": "b3707be9869cadafa7a67a962a3b85eb0cc4991f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -1549,7 +1549,7 @@ pure fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n }\n \n #[cfg(notest)]\n-impl<T:Eq> Eq for &[T] {\n+impl<T:Eq> Eq for &self/[T] {\n     #[inline(always)]\n     pure fn eq(&self, other: & &self/[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n@@ -1574,7 +1574,7 @@ impl<T:Eq> Eq for @[T] {\n }\n \n #[cfg(notest)]\n-impl<T:Eq> Equiv<~[T]> for &[T] {\n+impl<T:Eq> Equiv<~[T]> for &'self [T] {\n     #[inline(always)]\n     pure fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n }\n@@ -1596,7 +1596,7 @@ pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n }\n \n #[cfg(notest)]\n-impl<T: TotalOrd> TotalOrd for &[T] {\n+impl<T: TotalOrd> TotalOrd for &'self [T] {\n     #[inline(always)]\n     pure fn cmp(&self, other: & &self/[T]) -> Ordering { cmp(*self, *other) }\n }\n@@ -1633,7 +1633,7 @@ pure fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n pure fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n #[cfg(notest)]\n-impl<T:Ord> Ord for &[T] {\n+impl<T:Ord> Ord for &self/[T] {\n     #[inline(always)]\n     pure fn lt(&self, other: & &self/[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n@@ -1674,15 +1674,15 @@ pub mod traits {\n     use ops::Add;\n     use vec::append;\n \n-    impl<T:Copy> Add<&[const T],~[T]> for ~[T] {\n+    impl<T:Copy> Add<&self/[const T],~[T]> for ~[T] {\n         #[inline(always)]\n         pure fn add(&self, rhs: & &self/[const T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n }\n \n-impl<T> Container for &[const T] {\n+impl<T> Container for &self/[const T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     pure fn is_empty(&self) -> bool { is_empty(*self) }\n@@ -1697,7 +1697,7 @@ pub trait CopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T: Copy> CopyableVector<T> for &[const T] {\n+impl<T: Copy> CopyableVector<T> for &'self [const T] {\n     /// Returns a copy of the elements from [`start`..`end`) from `v`.\n     #[inline]\n     pure fn slice(&self, start: uint, end: uint) -> ~[T] {\n@@ -1725,7 +1725,7 @@ pub trait ImmutableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T> ImmutableVector<T> for &[T] {\n+impl<T> ImmutableVector<T> for &self/[T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n     pure fn view(&self, start: uint, end: uint) -> &self/[T] {\n@@ -1828,7 +1828,7 @@ pub trait ImmutableEqVector<T:Eq> {\n     pure fn rposition_elem(&self, t: &T) -> Option<uint>;\n }\n \n-impl<T:Eq> ImmutableEqVector<T> for &[T] {\n+impl<T:Eq> ImmutableEqVector<T> for &self/[T] {\n     /**\n      * Find the first index matching some predicate\n      *\n@@ -1873,7 +1873,7 @@ pub trait ImmutableCopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T:Copy> ImmutableCopyableVector<T> for &[T] {\n+impl<T:Copy> ImmutableCopyableVector<T> for &self/[T] {\n     /**\n      * Construct a new vector from the elements of a vector for which some\n      * predicate holds.\n@@ -2266,7 +2266,7 @@ pub mod bytes {\n // This cannot be used with iter-trait.rs because of the region pointer\n // required in the slice.\n \n-impl<A> iter::BaseIter<A> for &[A] {\n+impl<A> iter::BaseIter<A> for &self/[A] {\n     pub pure fn each(&self, blk: fn(v: &A) -> bool) {\n         // FIXME(#2263)---should be able to call each(self, blk)\n         for each(*self) |e| {\n@@ -2304,7 +2304,7 @@ impl<A> iter::BaseIter<A> for @[A] {\n     pure fn size_hint(&self) -> Option<uint> { Some(len(*self)) }\n }\n \n-impl<A> iter::ExtendedIter<A> for &[A] {\n+impl<A> iter::ExtendedIter<A> for &self/[A] {\n     pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n@@ -2381,7 +2381,7 @@ impl<A> iter::ExtendedIter<A> for @[A] {\n     }\n }\n \n-impl<A:Eq> iter::EqIter<A> for &[A] {\n+impl<A:Eq> iter::EqIter<A> for &self/[A] {\n     pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n     pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n@@ -2398,7 +2398,7 @@ impl<A:Eq> iter::EqIter<A> for @[A] {\n     pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n-impl<A:Copy> iter::CopyableIter<A> for &[A] {\n+impl<A:Copy> iter::CopyableIter<A> for &self/[A] {\n     pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n@@ -2430,7 +2430,7 @@ impl<A:Copy> iter::CopyableIter<A> for @[A] {\n     }\n }\n \n-impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for &[A] {\n+impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for &self/[A] {\n     pure fn min(&self) -> A { iter::min(self) }\n     pure fn max(&self) -> A { iter::max(self) }\n }\n@@ -2447,7 +2447,7 @@ impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for @[A] {\n     pure fn max(&self) -> A { iter::max(self) }\n }\n \n-impl<A:Copy> iter::CopyableNonstrictIter<A> for &[A] {\n+impl<A:Copy> iter::CopyableNonstrictIter<A> for &self/[A] {\n     pure fn each_val(&const self, f: fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {"}, {"sha": "023383b3dccc84d0517d8e5c50f4ae087e4a85c9", "filename": "src/librust/rust.rc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -36,23 +36,23 @@ impl ValidUsage {\n }\n \n enum Action {\n-    Exec(&str),\n-    Call(&fn(args: &[~str]) -> ValidUsage)\n+    Exec(&self/str),\n+    Call(&self/fn(args: &[~str]) -> ValidUsage)\n }\n \n enum UsageSource {\n-    UsgExec(&str),\n-    UsgStr(&str)\n+    UsgExec(&self/str),\n+    UsgStr(&self/str)\n }\n \n struct Command {\n-    cmd: &str,\n-    action: Action,\n-    usage_line: &str,\n-    usage_full: UsageSource\n+    cmd: &self/str,\n+    action: Action/&self,\n+    usage_line: &self/str,\n+    usage_full: UsageSource/&self\n }\n \n-const commands: &[Command] = &[\n+const commands: &static/[Command/&static] = &[\n     Command{\n         cmd: \"build\",\n         action: Exec(\"rustc\"),"}, {"sha": "3ffcd5838162e0155f48a8ff3baa5586568645e8", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -68,7 +68,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n     None\n }\n \n-pub type GetCrateDataCb = &fn(ast::crate_num) -> cmd;\n+pub type GetCrateDataCb = &self/fn(ast::crate_num) -> cmd;\n \n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n@@ -546,7 +546,7 @@ pub fn get_item_path(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n     item_path(intr, lookup_item(id, cdata.data))\n }\n \n-pub type decode_inlined_item = fn(\n+pub type decode_inlined_item = &self/fn(\n     cdata: @cstore::crate_metadata,\n     tcx: ty::ctxt,\n     path: ast_map::path,"}, {"sha": "3d81b01a0c9f81a64d2f6c8095c660c711ba447d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -1276,11 +1276,12 @@ fn encode_hash(ebml_w: writer::Encoder, hash: &str) {\n }\n \n // NB: Increment this as you change the metadata encoding version.\n-pub const metadata_encoding_version : &[u8] = &[0x72, //'r' as u8,\n-                                                0x75, //'u' as u8,\n-                                                0x73, //'s' as u8,\n-                                                0x74, //'t' as u8,\n-                                                0, 0, 0, 1 ];\n+pub const metadata_encoding_version : &static/[u8] =\n+    &[0x72, //'r' as u8,\n+      0x75, //'u' as u8,\n+      0x73, //'s' as u8,\n+      0x74, //'t' as u8,\n+      0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();"}, {"sha": "cd2c26a5ff46c478fe2f6442747f8fb50ac2a61b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -21,7 +21,7 @@ use core::result::Result;\n use core::result;\n use core::str;\n \n-pub type pick<T> = fn(path: &Path) -> Option<T>;\n+pub type pick<T> = &self/fn(path: &Path) -> Option<T>;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n     if path.file_path() == file { option::Some(copy *path) }"}, {"sha": "64da6e5cabd94c864ba941313d2d81a6225ffb83", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -49,7 +49,7 @@ pub enum DefIdSource {\n     // Identifies a type parameter (`fn foo<X>() { ... }`).\n     TypeParameter\n }\n-type conv_did = fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n+type conv_did = &self/fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n \n pub struct PState {\n     data: @~[u8],"}, {"sha": "328fe1c4f3e747a79f8d49654fd22937e25dfae1", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -64,7 +64,7 @@ pub impl BorrowckCtxt {\n }\n \n struct PreserveCtxt {\n-    bccx: &BorrowckCtxt,\n+    bccx: &self/BorrowckCtxt,\n \n     // the region scope for which we must preserve the memory\n     scope_region: ty::Region,\n@@ -79,7 +79,7 @@ struct PreserveCtxt {\n     root_managed_data: bool\n }\n \n-pub impl PreserveCtxt {\n+pub impl PreserveCtxt/&self {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     fn preserve(&self, cmt: cmt) -> bckres<PreserveCondition> {"}, {"sha": "84de194915ad03be627005be7d4847280a4d884e", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -55,7 +55,7 @@ use syntax::{visit, ast_util};\n // primitives in the stdlib are explicitly annotated to only take sendable\n // types.\n \n-pub const try_adding: &str = \"Try adding a move\";\n+pub const try_adding: &static/str = \"Try adding a move\";\n \n pub type rval_map = HashMap<node_id, ()>;\n "}, {"sha": "32567d71cd9652e6ef05e5fae3ca31d39e2b0402", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -312,15 +312,15 @@ fn LanguageItemCollector(crate: @crate,\n }\n \n struct LanguageItemCollector {\n-    items: &mut LanguageItems,\n+    items: &self/mut LanguageItems,\n \n     crate: @crate,\n     session: Session,\n \n     item_refs: HashMap<@~str, uint>,\n }\n \n-pub impl LanguageItemCollector {\n+pub impl LanguageItemCollector/&self {\n     fn match_and_collect_meta_item(&self, item_def_id: def_id,\n                                    meta_item: @meta_item) {\n         match meta_item.node {"}, {"sha": "5479dac4d95be3fbb31673c814d030195bb97e20", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -212,9 +212,9 @@ pub impl<T> ResolveResult<T> {\n }\n \n pub enum TypeParameters/& {\n-    NoTypeParameters,              //< No type parameters.\n-    HasTypeParameters(&Generics,   //< Type parameters.\n-                      node_id,     //< ID of the enclosing item\n+    NoTypeParameters,                  //< No type parameters.\n+    HasTypeParameters(&self/Generics,  //< Type parameters.\n+                      node_id,         //< ID of the enclosing item\n \n                       // The index to start numbering the type parameters at.\n                       // This is zero if this is the outermost set of type"}, {"sha": "2db3cae74e33b25d3f8cab4894273b51d0468e14", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -328,13 +328,13 @@ pub type BindingsMap = HashMap<ident, BindingInfo>;\n \n pub struct ArmData {\n     bodycx: block,\n-    arm: &ast::arm,\n+    arm: &self/ast::arm,\n     bindings_map: BindingsMap\n }\n \n pub struct Match {\n     pats: ~[@ast::pat],\n-    data: @ArmData\n+    data: @ArmData/&self\n }\n \n pub fn match_to_str(bcx: block, m: &Match) -> ~str {\n@@ -392,7 +392,7 @@ pub fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n     }\n }\n \n-pub type enter_pat = fn(@ast::pat) -> Option<~[@ast::pat]>;\n+pub type enter_pat = &self/fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n pub fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {"}, {"sha": "b7ac909eee42e9fc3f0525c16536a0798df12ddb", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -550,8 +550,8 @@ pub fn trans_call_inner(\n \n \n pub enum CallArgs {\n-    ArgExprs(&[@ast::expr]),\n-    ArgVals(&[ValueRef])\n+    ArgExprs(&self/[@ast::expr]),\n+    ArgVals(&self/[ValueRef])\n }\n \n pub struct Args {"}, {"sha": "1e3c4f21bd8752ea1c6f01201c79c2f8290849f1", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -97,11 +97,11 @@ fn c_stack_tys(ccx: @CrateContext,\n     };\n }\n \n-type shim_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n-                           llargbundle: ValueRef) -> ~[ValueRef];\n+type shim_arg_builder = &self/fn(bcx: block, tys: @c_stack_tys,\n+                                 llargbundle: ValueRef) -> ~[ValueRef];\n \n-type shim_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n-                           llargbundle: ValueRef, llretval: ValueRef);\n+type shim_ret_builder = &self/fn(bcx: block, tys: @c_stack_tys,\n+                                 llargbundle: ValueRef, llretval: ValueRef);\n \n fn build_shim_fn_(ccx: @CrateContext,\n                   +shim_name: ~str,\n@@ -133,12 +133,12 @@ fn build_shim_fn_(ccx: @CrateContext,\n     return llshimfn;\n }\n \n-type wrap_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n-                           llwrapfn: ValueRef,\n-                           llargbundle: ValueRef);\n+type wrap_arg_builder = &self/fn(bcx: block, tys: @c_stack_tys,\n+                                 llwrapfn: ValueRef,\n+                                 llargbundle: ValueRef);\n \n-type wrap_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n-                           llargbundle: ValueRef);\n+type wrap_ret_builder = &self/fn(bcx: block, tys: @c_stack_tys,\n+                                 llargbundle: ValueRef);\n \n fn build_wrap_fn_(ccx: @CrateContext,\n                   tys: @c_stack_tys,"}, {"sha": "3e4486476c0b9d93fdc6b131ecc1eb740439c029", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -520,7 +520,7 @@ pub fn get_base_and_len(bcx: block,\n \n pub type val_and_ty_fn = @fn(block, ValueRef, ty::t) -> Result;\n \n-pub type iter_vec_block = &fn(block, ValueRef, ty::t) -> block;\n+pub type iter_vec_block = &self/fn(block, ValueRef, ty::t) -> block;\n \n pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                     fill: ValueRef, f: iter_vec_block) -> block {"}, {"sha": "606ba59fbf644c4f31551ca082b65c40cc616eb4", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -57,15 +57,15 @@ use core::prelude::*;\n use middle::ty::{arg, field, substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n-use middle::typeck::rscope::{in_anon_rscope, in_binding_rscope};\n-use middle::typeck::rscope::{region_scope, type_rscope};\n+use middle::typeck::rscope::{in_binding_rscope};\n+use middle::typeck::rscope::{region_scope, type_rscope, RegionError};\n use middle::typeck::{CrateCtxt, write_substs_to_tcx, write_ty_to_tcx};\n \n use core::result;\n use core::vec;\n use syntax::ast;\n use syntax::codemap::span;\n-use syntax::print::pprust::path_to_str;\n+use syntax::print::pprust::{region_to_str, path_to_str};\n use util::common::indenter;\n \n pub trait AstConv {\n@@ -76,17 +76,31 @@ pub trait AstConv {\n     fn ty_infer(&self, span: span) -> ty::t;\n }\n \n-pub fn get_region_reporting_err(tcx: ty::ctxt,\n-                                span: span,\n-                                res: Result<ty::Region, ~str>)\n-                             -> ty::Region {\n-\n+pub fn get_region_reporting_err(\n+    tcx: ty::ctxt,\n+    span: span,\n+    a_r: Option<@ast::region>,\n+    res: Result<ty::Region, RegionError>) -> ty::Region\n+{\n     match res {\n-      result::Ok(r) => r,\n-      result::Err(ref e) => {\n-        tcx.sess.span_err(span, (/*bad*/copy *e));\n-        ty::re_static\n-      }\n+        result::Ok(r) => r,\n+        result::Err(ref e) => {\n+            let descr = match a_r {\n+                None => ~\"anonymous lifetime\",\n+                Some(a) if a.node == ast::re_anon => {\n+                    ~\"anonymous lifetime\"\n+                }\n+                Some(a) => {\n+                    fmt!(\"lifetime %s\",\n+                         region_to_str(a, tcx.sess.intr()))\n+                }\n+            };\n+            tcx.sess.span_err(\n+                span,\n+                fmt!(\"Illegal %s: %s\",\n+                     descr, e.msg));\n+            e.replacement\n+        }\n     }\n }\n \n@@ -103,7 +117,7 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + Durable>(\n         ast::re_named(id) => rscope.named_region(span, id)\n     };\n \n-    get_region_reporting_err(self.tcx(), span, res)\n+    get_region_reporting_err(self.tcx(), span, Some(a_r), res)\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n@@ -139,7 +153,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n       }\n       (Some(_), None) => {\n         let res = rscope.anon_region(path.span);\n-        let r = get_region_reporting_err(self.tcx(), path.span, res);\n+        let r = get_region_reporting_err(self.tcx(), path.span, None, res);\n         Some(r)\n       }\n       (Some(_), Some(r)) => {\n@@ -315,8 +329,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n       }\n       ast::ty_rptr(region, mt) => {\n         let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n-        let anon_rscope = in_anon_rscope(rscope, r);\n-        mk_pointer(self, &anon_rscope, mt, ty::vstore_slice(r),\n+        mk_pointer(self, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(fields) => {\n@@ -522,7 +535,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n                 ast::BorrowedSigil => {\n                     // &fn() defaults to an anonymous region:\n                     let r_result = rscope.anon_region(span);\n-                    get_region_reporting_err(self.tcx(), span, r_result)\n+                    get_region_reporting_err(self.tcx(), span, None, r_result)\n                 }\n             }\n         }"}, {"sha": "e437563647e2b84c7d968ab79f21e86f3b6671d5", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -143,7 +143,7 @@ pub struct LookupContext {\n     self_expr: @ast::expr,\n     callee_id: node_id,\n     m_name: ast::ident,\n-    supplied_tps: &[ty::t],\n+    supplied_tps: &self/[ty::t],\n     impl_dups: HashMap<def_id, ()>,\n     inherent_candidates: DVec<Candidate>,\n     extension_candidates: DVec<Candidate>,\n@@ -176,7 +176,7 @@ pub enum TransformTypeFlag {\n     TransformTypeForObject,\n }\n \n-pub impl LookupContext {\n+pub impl LookupContext/&self {\n     fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         debug!(\"do_lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n                self.ty_to_str(self_ty),"}, {"sha": "66c2a28da3d6b4386f6f50c8eb4b41959db41c3e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -95,7 +95,8 @@ use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n-use middle::typeck::rscope::{anon_rscope, binding_rscope, bound_self_region};\n+use middle::typeck::rscope::{binding_rscope, bound_self_region};\n+use middle::typeck::rscope::{RegionError};\n use middle::typeck::rscope::{in_binding_rscope, region_scope, type_rscope};\n use middle::typeck::rscope;\n use middle::typeck::{isr_alist, lookup_def_ccx, method_map_entry};\n@@ -649,9 +650,11 @@ impl AstConv for FnCtxt {\n \n pub impl FnCtxt {\n     fn infcx(&self) -> @mut infer::InferCtxt { self.inh.infcx }\n-    fn search_in_scope_regions(&self,\n-                               br: ty::bound_region)\n-                            -> Result<ty::Region, ~str> {\n+    fn search_in_scope_regions(\n+        &self,\n+        span: span,\n+        br: ty::bound_region) -> Result<ty::Region, RegionError>\n+    {\n         let in_scope_regions = self.in_scope_regions;\n         match in_scope_regions.find(br) {\n             Some(r) => result::Ok(r),\n@@ -660,32 +663,35 @@ pub impl FnCtxt {\n                 if br == blk_br {\n                     result::Ok(self.block_region())\n                 } else {\n-                    result::Err(fmt!(\"named region `%s` not in scope here\",\n-                                     bound_region_to_str(self.tcx(), br)))\n+                    result::Err(RegionError {\n+                        msg: fmt!(\"named region `%s` not in scope here\",\n+                                  bound_region_to_str(self.tcx(), br)),\n+                        replacement: self.infcx().next_region_var_nb(span)\n+                    })\n                 }\n             }\n         }\n     }\n }\n \n impl region_scope for FnCtxt {\n-    fn anon_region(&self, span: span) -> Result<ty::Region, ~str> {\n+    fn anon_region(&self, span: span) -> Result<ty::Region, RegionError> {\n         result::Ok(self.infcx().next_region_var_nb(span))\n     }\n-    fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        self.search_in_scope_regions(ty::br_self)\n+    fn self_region(&self, span: span) -> Result<ty::Region, RegionError> {\n+        self.search_in_scope_regions(span, ty::br_self)\n     }\n     fn named_region(&self,\n-                    _span: span,\n-                    id: ast::ident) -> Result<ty::Region, ~str> {\n-        self.search_in_scope_regions(ty::br_named(id))\n+                    span: span,\n+                    id: ast::ident) -> Result<ty::Region, RegionError> {\n+        self.search_in_scope_regions(span, ty::br_named(id))\n     }\n }\n \n pub impl FnCtxt {\n-    fn tag(@mut self) -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n+    fn tag(&self) -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n \n-    fn local_ty(@mut self, span: span, nid: ast::node_id) -> ty::t {\n+    fn local_ty(&self, span: span, nid: ast::node_id) -> ty::t {\n         match self.inh.locals.find(&nid) {\n             Some(t) => t,\n             None => {\n@@ -696,7 +702,7 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn expr_to_str(@mut self, expr: @ast::expr) -> ~str {\n+    fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n         fmt!(\"expr(%?:%s)\", expr.id,\n              pprust::expr_to_str(expr, self.tcx().sess.intr()))\n     }\n@@ -706,13 +712,13 @@ pub impl FnCtxt {\n     }\n \n     #[inline(always)]\n-    fn write_ty(@mut self, node_id: ast::node_id, ty: ty::t) {\n+    fn write_ty(&self, node_id: ast::node_id, ty: ty::t) {\n         debug!(\"write_ty(%d, %s) in fcx %s\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n-    fn write_substs(@mut self, node_id: ast::node_id, +substs: ty::substs) {\n+    fn write_substs(&self, node_id: ast::node_id, +substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n             debug!(\"write_substs(%d, %s) in fcx %s\",\n                    node_id,\n@@ -722,7 +728,7 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn write_ty_substs(@mut self,\n+    fn write_ty_substs(&self,\n                        node_id: ast::node_id,\n                        ty: ty::t,\n                        +substs: ty::substs) {\n@@ -731,7 +737,7 @@ pub impl FnCtxt {\n         self.write_substs(node_id, substs);\n     }\n \n-    fn write_autoderef_adjustment(@mut self,\n+    fn write_autoderef_adjustment(&self,\n                                   node_id: ast::node_id,\n                                   derefs: uint) {\n         if derefs == 0 { return; }\n@@ -743,33 +749,33 @@ pub impl FnCtxt {\n         );\n     }\n \n-    fn write_adjustment(@mut self,\n+    fn write_adjustment(&self,\n                         node_id: ast::node_id,\n                         adj: @ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id=%?, adj=%?)\", node_id, adj);\n         self.inh.adjustments.insert(node_id, adj);\n     }\n \n-    fn write_nil(@mut self, node_id: ast::node_id) {\n+    fn write_nil(&self, node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n-    fn write_bot(@mut self, node_id: ast::node_id) {\n+    fn write_bot(&self, node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_bot(self.tcx()));\n     }\n \n-    fn to_ty(@mut self, ast_t: @ast::Ty) -> ty::t {\n+    fn to_ty(&self, ast_t: @ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n-    fn expr_to_str(@mut self, expr: @ast::expr) -> ~str {\n+    fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n         expr_repr(self.tcx(), expr)\n     }\n \n-    fn pat_to_str(@mut self, pat: @ast::pat) -> ~str {\n+    fn pat_to_str(&self, pat: @ast::pat) -> ~str {\n         pat_repr(self.tcx(), pat)\n     }\n \n-    fn expr_ty(@mut self, ex: @ast::expr) -> ty::t {\n+    fn expr_ty(&self, ex: @ast::expr) -> ty::t {\n         match self.inh.node_types.find(&ex.id) {\n             Some(t) => t,\n             None => {\n@@ -779,7 +785,7 @@ pub impl FnCtxt {\n             }\n         }\n     }\n-    fn node_ty(@mut self, id: ast::node_id) -> ty::t {\n+    fn node_ty(&self, id: ast::node_id) -> ty::t {\n         match self.inh.node_types.find(&id) {\n             Some(t) => t,\n             None => {\n@@ -792,7 +798,7 @@ pub impl FnCtxt {\n             }\n         }\n     }\n-    fn node_ty_substs(@mut self, id: ast::node_id) -> ty::substs {\n+    fn node_ty_substs(&self, id: ast::node_id) -> ty::substs {\n         match self.inh.node_type_substs.find(&id) {\n             Some(ref ts) => (/*bad*/copy *ts),\n             None => {\n@@ -805,12 +811,12 @@ pub impl FnCtxt {\n             }\n         }\n     }\n-    fn opt_node_ty_substs(@mut self, id: ast::node_id) -> Option<ty::substs> {\n+    fn opt_node_ty_substs(&self, id: ast::node_id) -> Option<ty::substs> {\n         self.inh.node_type_substs.find(&id)\n     }\n \n \n-    fn mk_subty(@mut self,\n+    fn mk_subty(&self,\n                 a_is_expected: bool,\n                 span: span,\n                 sub: ty::t,\n@@ -819,14 +825,14 @@ pub impl FnCtxt {\n         infer::mk_subty(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn can_mk_subty(@mut self,\n+    fn can_mk_subty(&self,\n                     sub: ty::t,\n                     sup: ty::t)\n                  -> Result<(), ty::type_err> {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    fn mk_assignty(@mut self, expr: @ast::expr, sub: ty::t, sup: ty::t)\n+    fn mk_assignty(&self, expr: @ast::expr, sub: ty::t, sup: ty::t)\n                 -> Result<(), ty::type_err> {\n         match infer::mk_coercety(self.infcx(), false, expr.span, sub, sup) {\n             Ok(None) => result::Ok(()),\n@@ -838,14 +844,14 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn can_mk_assignty(@mut self,\n+    fn can_mk_assignty(&self,\n                        sub: ty::t,\n                        sup: ty::t)\n                     -> Result<(), ty::type_err> {\n         infer::can_mk_coercety(self.infcx(), sub, sup)\n     }\n \n-    fn mk_eqty(@mut self,\n+    fn mk_eqty(&self,\n                a_is_expected: bool,\n                span: span,\n                sub: ty::t,\n@@ -854,7 +860,7 @@ pub impl FnCtxt {\n         infer::mk_eqty(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn mk_subr(@mut self,\n+    fn mk_subr(&self,\n                a_is_expected: bool,\n                span: span,\n                sub: ty::Region,\n@@ -863,7 +869,7 @@ pub impl FnCtxt {\n         infer::mk_subr(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn require_unsafe(@mut self, sp: span, op: ~str) {\n+    fn require_unsafe(&self, sp: span, op: ~str) {\n         match self.purity {\n           ast::unsafe_fn => {/*ok*/}\n           _ => {\n@@ -873,15 +879,16 @@ pub impl FnCtxt {\n           }\n         }\n     }\n-    fn with_region_lb<R>(@mut self, lb: ast::node_id, f: fn() -> R) -> R {\n+\n+    fn with_region_lb<R>(@mut self, lb: ast::node_id, f: &fn() -> R) -> R {\n         let old_region_lb = self.region_lb;\n         self.region_lb = lb;\n         let v = f();\n         self.region_lb = old_region_lb;\n         v\n     }\n \n-    fn region_var_if_parameterized(@mut self,\n+    fn region_var_if_parameterized(&self,\n                                    rp: Option<ty::region_variance>,\n                                    span: span,\n                                    lower_bound: ty::Region)\n@@ -890,15 +897,15 @@ pub impl FnCtxt {\n             |_rp| self.infcx().next_region_var_with_lb(span, lower_bound))\n     }\n \n-    fn type_error_message(@mut self,\n+    fn type_error_message(&self,\n                           sp: span,\n                           mk_msg: &fn(~str) -> ~str,\n                           actual_ty: ty::t,\n                           err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n-    fn report_mismatched_return_types(@mut self,\n+    fn report_mismatched_return_types(&self,\n                                       sp: span,\n                                       e: ty::t,\n                                       a: ty::t,\n@@ -919,12 +926,12 @@ pub impl FnCtxt {\n         }\n     }\n \n-    fn report_mismatched_types(@mut self,\n+    fn report_mismatched_types(&self,\n                                sp: span,\n                                e: ty::t,\n                                a: ty::t,\n                                err: &ty::type_err) {\n-            self.infcx().report_mismatched_types(sp, e, a, err)\n+        self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n }\n "}, {"sha": "5c59f1215e499c207f52ea57ff7e6c26e7644ed1", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -58,7 +58,7 @@ pub trait LatticeValue {\n                  -> cres<Self>;\n }\n \n-pub type LatticeOp<T> = &fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n+pub type LatticeOp<T> = &self/fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n \n impl LatticeValue for ty::t {\n     static fn sub(&self, cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n@@ -378,7 +378,7 @@ pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n     }\n }\n \n-pub type LatticeDirOp<T> = &fn(a: &T, b: &T) -> cres<T>;\n+pub type LatticeDirOp<T> = &self/fn(a: &T, b: &T) -> cres<T>;\n \n pub enum LatticeVarResult<V,T> {\n     VarResult(V),"}, {"sha": "3c342e9986bb503d57878274d1d725291524b31c", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 55, "deletions": 52, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -17,24 +17,33 @@ use core::result;\n use syntax::ast;\n use syntax::codemap::span;\n \n+pub struct RegionError {\n+    msg: ~str,\n+    replacement: ty::Region\n+}\n+\n pub trait region_scope {\n-    fn anon_region(&self, span: span) -> Result<ty::Region, ~str>;\n-    fn self_region(&self, span: span) -> Result<ty::Region, ~str>;\n+    fn anon_region(&self, span: span) -> Result<ty::Region, RegionError>;\n+    fn self_region(&self, span: span) -> Result<ty::Region, RegionError>;\n     fn named_region(&self, span: span, id: ast::ident)\n-                      -> Result<ty::Region, ~str>;\n+                      -> Result<ty::Region, RegionError>;\n }\n \n pub enum empty_rscope { empty_rscope }\n impl region_scope for empty_rscope {\n-    fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        Ok(ty::re_static)\n+    fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+        result::Err(RegionError {\n+            msg: ~\"only 'static is allowed here\",\n+            replacement: ty::re_static\n+        })\n     }\n-    fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        result::Err(~\"only the static region is allowed here\")\n+    fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+        self.anon_region(_span)\n     }\n     fn named_region(&self, _span: span, _id: ast::ident)\n-        -> Result<ty::Region, ~str> {\n-        result::Err(~\"only the static region is allowed here\")\n+        -> Result<ty::Region, RegionError>\n+    {\n+        self.anon_region(_span)\n     }\n }\n \n@@ -43,38 +52,59 @@ pub struct MethodRscope {\n     region_parameterization: Option<ty::region_variance>\n }\n impl region_scope for MethodRscope {\n-    fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        result::Err(~\"anonymous region types are not permitted here\")\n+    fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+        result::Err(RegionError {\n+            msg: ~\"anonymous lifetimes are not permitted here\",\n+            replacement: ty::re_bound(ty::br_self)\n+        })\n     }\n-    fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+    fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n         assert self.region_parameterization.is_some() ||\n             self.self_ty.is_borrowed();\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n     fn named_region(&self, span: span, id: ast::ident)\n-                      -> Result<ty::Region, ~str> {\n+                      -> Result<ty::Region, RegionError> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n-            result::Err(~\"region is not in scope here\")\n+            result::Err(RegionError {\n+                msg: ~\"lifetime is not in scope\",\n+                replacement: ty::re_bound(ty::br_self)\n+            })\n         }\n     }\n }\n \n pub enum type_rscope = Option<ty::region_variance>;\n+impl type_rscope {\n+    priv fn replacement(&self) -> ty::Region {\n+        if self.is_some() {\n+            ty::re_bound(ty::br_self)\n+        } else {\n+            ty::re_static\n+        }\n+    }\n+}\n impl region_scope for type_rscope {\n-    fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n-        // if the anon or self region is used, region parameterization should\n+    fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+        result::Err(RegionError {\n+            msg: ~\"anonymous lifetimes are not permitted here\",\n+            replacement: self.replacement()\n+        })\n+    }\n+    fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+        // if the self region is used, region parameterization should\n         // have inferred that this type is RP\n         assert self.is_some();\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n-    fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n-        self.anon_region(span)\n-    }\n     fn named_region(&self, span: span, id: ast::ident)\n-                      -> Result<ty::Region, ~str> {\n+                      -> Result<ty::Region, RegionError> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n-            result::Err(~\"named regions other than `self` are not \\\n-                          allowed as part of a type declaration\")\n+            result::Err(RegionError {\n+                msg: ~\"only 'self is allowed allowed as \\\n+                       part of a type declaration\",\n+                replacement: self.replacement()\n+            })\n         }\n     }\n }\n@@ -87,33 +117,6 @@ pub fn bound_self_region(rp: Option<ty::region_variance>)\n     }\n }\n \n-pub struct anon_rscope { anon: ty::Region, base: @region_scope }\n-pub fn in_anon_rscope<RS:region_scope + Copy + Durable>(\n-    self: &RS,\n-    r: ty::Region) -> anon_rscope\n-{\n-    let base = @(copy *self) as @region_scope;\n-    anon_rscope {anon: r, base: base}\n-}\n-impl region_scope for anon_rscope {\n-    fn anon_region(&self,\n-                   _span: span) -> Result<ty::Region, ~str>\n-    {\n-        result::Ok(self.anon)\n-    }\n-    fn self_region(&self,\n-                   span: span) -> Result<ty::Region, ~str>\n-    {\n-        self.base.self_region(span)\n-    }\n-    fn named_region(&self,\n-                    span: span,\n-                    id: ast::ident) -> Result<ty::Region, ~str>\n-    {\n-        self.base.named_region(span, id)\n-    }\n-}\n-\n pub struct binding_rscope {\n     base: @region_scope,\n     anon_bindings: @mut uint,\n@@ -125,17 +128,17 @@ pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: &RS)\n     binding_rscope { base: base, anon_bindings: @mut 0 }\n }\n impl region_scope for binding_rscope {\n-    fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+    fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n         let idx = *self.anon_bindings;\n         *self.anon_bindings += 1;\n         result::Ok(ty::re_bound(ty::br_anon(idx)))\n     }\n-    fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n+    fn self_region(&self, span: span) -> Result<ty::Region, RegionError> {\n         self.base.self_region(span)\n     }\n     fn named_region(&self,\n                     span: span,\n-                    id: ast::ident) -> Result<ty::Region, ~str>\n+                    id: ast::ident) -> Result<ty::Region, RegionError>\n     {\n         do self.base.named_region(span, id).chain_err |_e| {\n             result::Ok(ty::re_bound(ty::br_named(id)))"}, {"sha": "85d9dfe6fa68efdd2404f8bf4e1dc18133d132f1", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -36,7 +36,7 @@ pub struct Ctxt {\n     ast_map: ast_map::map\n }\n \n-type SrvOwner<T> = &fn(srv: Srv) -> T;\n+type SrvOwner<T> = &'self fn(srv: Srv) -> T;\n pub type CtxtHandler<T> = ~fn(ctxt: Ctxt) -> T;\n type Parser = ~fn(Session, s: ~str) -> @ast::crate;\n "}, {"sha": "b9b39063667ef02027ba681df8a0e6c9304cb761", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -25,46 +25,55 @@ use core::ptr;\n use core::task;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n-pub struct Condvar { is_mutex: bool, failed: &mut bool, cond: &sync::Condvar }\n+pub struct Condvar {\n+    is_mutex: bool,\n+    failed: &self/mut bool,\n+    cond: &self/sync::Condvar/&self\n+}\n \n-pub impl &Condvar {\n+pub impl Condvar/&self {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n     #[inline(always)]\n-    fn wait() { self.wait_on(0) }\n+    fn wait(&self) { self.wait_on(0) }\n+\n     /**\n      * Atomically exit the associated ARC and block on a specified condvar\n      * until a signal is sent on that same condvar (as sync::cond.wait_on).\n      *\n      * wait() is equivalent to wait_on(0).\n      */\n     #[inline(always)]\n-    fn wait_on(condvar_id: uint) {\n+    fn wait_on(&self, condvar_id: uint) {\n         assert !*self.failed;\n         self.cond.wait_on(condvar_id);\n         // This is why we need to wrap sync::condvar.\n         check_poison(self.is_mutex, *self.failed);\n     }\n+\n     /// Wake up a blocked task. Returns false if there was no blocked task.\n     #[inline(always)]\n-    fn signal() -> bool { self.signal_on(0) }\n+    fn signal(&self) -> bool { self.signal_on(0) }\n+\n     /**\n      * Wake up a blocked task on a specified condvar (as\n      * sync::cond.signal_on). Returns false if there was no blocked task.\n      */\n     #[inline(always)]\n-    fn signal_on(condvar_id: uint) -> bool {\n+    fn signal_on(&self, condvar_id: uint) -> bool {\n         assert !*self.failed;\n         self.cond.signal_on(condvar_id)\n     }\n+\n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n     #[inline(always)]\n-    fn broadcast() -> uint { self.broadcast_on(0) }\n+    fn broadcast(&self) -> uint { self.broadcast_on(0) }\n+\n     /**\n      * Wake up all blocked tasks on a specified condvar (as\n      * sync::cond.broadcast_on). Returns Returns the number of tasks woken.\n      */\n     #[inline(always)]\n-    fn broadcast_on(condvar_id: uint) -> uint {\n+    fn broadcast_on(&self, condvar_id: uint) -> uint {\n         assert !*self.failed;\n         self.cond.broadcast_on(condvar_id)\n     }\n@@ -141,7 +150,7 @@ impl<T:Owned> Clone for MutexARC<T> {\n     }\n }\n \n-pub impl<T:Owned> &MutexARC<T> {\n+pub impl<T:Owned> MutexARC<T> {\n \n     /**\n      * Access the underlying mutable data with mutual exclusion from other\n@@ -167,7 +176,7 @@ pub impl<T:Owned> &MutexARC<T> {\n      * blocked on the mutex) will also fail immediately.\n      */\n     #[inline(always)]\n-    unsafe fn access<U>(blk: fn(x: &mut T) -> U) -> U {\n+    unsafe fn access<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             // Borrowck would complain about this if the function were\n@@ -179,9 +188,13 @@ pub impl<T:Owned> &MutexARC<T> {\n             }\n         }\n     }\n+\n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline(always)]\n-    unsafe fn access_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    unsafe fn access_cond<U>(\n+        &self,\n+        blk: &fn(x: &x/mut T, c: &c/Condvar) -> U) -> U\n+    {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (&(*state).lock).lock_cond |cond| {\n@@ -276,7 +289,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n \n }\n \n-pub impl<T:Const + Owned> &RWARC<T> {\n+pub impl<T:Const + Owned> RWARC<T> {\n     /**\n      * Access the underlying data mutably. Locks the rwlock in write mode;\n      * other readers and writers will block.\n@@ -288,7 +301,7 @@ pub impl<T:Const + Owned> &RWARC<T> {\n      * poison the ARC, so subsequent readers and writers will both also fail.\n      */\n     #[inline(always)]\n-    fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n+    fn write<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write {\n@@ -300,7 +313,7 @@ pub impl<T:Const + Owned> &RWARC<T> {\n     }\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n-    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write_cond |cond| {\n@@ -389,13 +402,13 @@ fn borrow_rwlock<T:Const + Owned>(state: *const RWARCInner<T>) -> *RWlock {\n \n /// The \"write permission\" token used for RWARC.write_downgrade().\n pub enum RWWriteMode<T> =\n-    (&mut T, sync::RWlockWriteMode, PoisonOnFail);\n+    (&self/mut T, sync::RWlockWriteMode/&self, PoisonOnFail);\n /// The \"read permission\" token used for RWARC.write_downgrade().\n-pub enum RWReadMode<T> = (&T, sync::RWlockReadMode);\n+pub enum RWReadMode<T> = (&self/T, sync::RWlockReadMode/&self);\n \n-pub impl<T:Const + Owned> &RWWriteMode<T> {\n+pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n     /// Access the pre-downgrade RWARC in write mode.\n-    fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n+    fn write<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n         match *self {\n             RWWriteMode((ref data, ref token, _)) => {\n                 do token.write {\n@@ -405,7 +418,7 @@ pub impl<T:Const + Owned> &RWWriteMode<T> {\n         }\n     }\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n-    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         match *self {\n             RWWriteMode((ref data, ref token, ref poison)) => {\n                 do token.write_cond |cond| {\n@@ -423,9 +436,9 @@ pub impl<T:Const + Owned> &RWWriteMode<T> {\n     }\n }\n \n-pub impl<T:Const + Owned> &RWReadMode<T> {\n+pub impl<T:Const + Owned> RWReadMode/&self<T> {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(blk: fn(x: &T) -> U) -> U {\n+    fn read<U>(&self, blk: fn(x: &T) -> U) -> U {\n         match *self {\n             RWReadMode((data, ref token)) => {\n                 do token.read { blk(data) }"}, {"sha": "7bbd5cd41a3f420a501eec8c15f8fa727fdc45af", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -160,9 +160,9 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (reinterpret_cast(&(p & !1)), p & 1 == 1)\n }\n \n-pub impl &Arena {\n+pub impl Arena {\n     // Functions for the POD part of the arena\n-    fn alloc_pod_grow(n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_pod_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -174,7 +174,7 @@ pub impl &Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod_inner(n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_pod_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n         let head = &mut self.pod_head;\n \n         let start = round_up_to(head.fill, align);\n@@ -193,7 +193,7 @@ pub impl &Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod<T>(op: fn() -> T) -> &self/T {\n+    fn alloc_pod<T>(&self, op: fn() -> T) -> &self/T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -204,7 +204,7 @@ pub impl &Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_nonpod_grow(n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    fn alloc_nonpod_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -216,7 +216,7 @@ pub impl &Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod_inner(n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    fn alloc_nonpod_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n         let head = &mut self.head;\n \n         let tydesc_start = head.fill;\n@@ -238,7 +238,7 @@ pub impl &Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod<T>(op: fn() -> T) -> &self/T {\n+    fn alloc_nonpod<T>(&self, op: fn() -> T) -> &self/T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -260,7 +260,7 @@ pub impl &Arena {\n \n     // The external interface\n     #[inline(always)]\n-    fn alloc<T>(op: fn() -> T) -> &self/T {\n+    fn alloc<T>(&self, op: fn() -> T) -> &self/T {\n         unsafe {\n             if !rusti::needs_drop::<T>() {\n                 self.alloc_pod(op)"}, {"sha": "dceb39312daf3bb8a97fe77157a23b10aa57a338", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -16,7 +16,7 @@ pub trait ToBase64 {\n     pure fn to_base64() -> ~str;\n }\n \n-impl ToBase64 for &[u8] {\n+impl ToBase64 for &self/[u8] {\n     pure fn to_base64() -> ~str {\n         let chars = str::chars(\n           ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n@@ -69,7 +69,7 @@ impl ToBase64 for &[u8] {\n     }\n }\n \n-impl ToBase64 for &str {\n+impl ToBase64 for &self/str {\n     pure fn to_base64() -> ~str {\n         str::to_bytes(self).to_base64()\n     }"}, {"sha": "a3109c00c0125fb1a30e1d962e1c121344ac466b", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -1045,7 +1045,9 @@ mod biguint_tests {\n         assert BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value;\n     }\n \n-    const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+    const sum_triples: &static/[(&static/[BigDigit],\n+                                 &static/[BigDigit],\n+                                 &static/[BigDigit])] = &[\n         (&[],          &[],       &[]),\n         (&[],          &[ 1],     &[ 1]),\n         (&[ 1],        &[ 1],     &[ 2]),\n@@ -1083,7 +1085,9 @@ mod biguint_tests {\n         }\n     }\n \n-    const mul_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+    const mul_triples: &static/[(&static/[BigDigit],\n+                                 &static/[BigDigit],\n+                                 &static/[BigDigit])] = &[\n         (&[],               &[],               &[]),\n         (&[],               &[ 1],             &[]),\n         (&[ 2],             &[],               &[]),\n@@ -1107,8 +1111,10 @@ mod biguint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    const divmod_quadruples: &[(&[BigDigit], &[BigDigit],\n-                                &[BigDigit], &[BigDigit])]\n+    const divmod_quadruples: &static/[(&static/[BigDigit],\n+                                       &static/[BigDigit],\n+                                       &static/[BigDigit],\n+                                       &static/[BigDigit])]\n         = &[\n             (&[ 1],        &[ 2], &[],               &[1]),\n             (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n@@ -1393,7 +1399,9 @@ mod bigint_tests {\n         ).to_uint() == 0;\n     }\n \n-    const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+    const sum_triples: &static/[(&static/[BigDigit],\n+                                 &static/[BigDigit],\n+                                 &static/[BigDigit])] = &[\n         (&[],          &[],       &[]),\n         (&[],          &[ 1],     &[ 1]),\n         (&[ 1],        &[ 1],     &[ 2]),\n@@ -1443,7 +1451,9 @@ mod bigint_tests {\n         }\n     }\n \n-    const mul_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+    const mul_triples: &static/[(&static/[BigDigit],\n+                                 &static/[BigDigit],\n+                                 &static/[BigDigit])] = &[\n         (&[],               &[],               &[]),\n         (&[],               &[ 1],             &[]),\n         (&[ 2],             &[],               &[]),\n@@ -1467,8 +1477,10 @@ mod bigint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    const divmod_quadruples: &[(&[BigDigit], &[BigDigit],\n-                                &[BigDigit], &[BigDigit])]\n+    const divmod_quadruples: &static/[(&static/[BigDigit],\n+                                       &static/[BigDigit],\n+                                       &static/[BigDigit],\n+                                       &static/[BigDigit])]\n         = &[\n             (&[ 1],        &[ 2], &[],               &[1]),\n             (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),"}, {"sha": "798c5ae57c782a3876e54568be092ca306581a2e", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -468,8 +468,8 @@ pub mod flatteners {\n         static fn from_writer(w: Writer) -> Self;\n     }\n \n-    impl FromReader for json::Decoder {\n-        static fn from_reader(r: Reader) -> json::Decoder {\n+    impl FromReader for json::Decoder/&self {\n+        static fn from_reader(r: Reader) -> json::Decoder/&self {\n             match json::from_reader(r) {\n                 Ok(json) => {\n                     json::Decoder(json)"}, {"sha": "cfa66ae000aa5207b2ebda3d00f9cecc57603c18", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -749,14 +749,14 @@ pub fn from_str(s: &str) -> Result<Json, Error> {\n \n pub struct Decoder {\n     priv json: Json,\n-    priv mut stack: ~[&Json],\n+    priv mut stack: ~[&self/Json],\n }\n \n pub fn Decoder(json: Json) -> Decoder {\n     Decoder { json: json, stack: ~[] }\n }\n \n-priv impl Decoder {\n+priv impl Decoder/&self {\n     fn peek(&self) -> &self/Json {\n         if self.stack.len() == 0 { self.stack.push(&self.json); }\n         self.stack[self.stack.len() - 1]\n@@ -768,7 +768,7 @@ priv impl Decoder {\n     }\n }\n \n-impl serialize::Decoder for Decoder {\n+impl serialize::Decoder for Decoder/&self {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n         match *self.pop() {"}, {"sha": "5bbd926ba6bebf8bb539088af2be3a2cb6461b2e", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -213,7 +213,7 @@ impl<D:Decoder> Decodable<D> for i64 {\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for &str {\n+impl<S:Encoder> Encodable<S> for &self/str {\n     fn encode(&self, s: &S) { s.emit_borrowed_str(*self) }\n }\n \n@@ -286,7 +286,7 @@ impl<D:Decoder> Decodable<D> for () {\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for &T {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for &self/T {\n     fn encode(&self, s: &S) {\n         s.emit_borrowed(|| (**self).encode(s))\n     }\n@@ -316,7 +316,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for &[T] {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for &self/[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_borrowed_vec(self.len()) {\n             for self.eachi |i, e| {"}, {"sha": "aad8fab834f3452c6f21bdc6cad50174cb37aa65", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -22,7 +22,7 @@ pub struct SmallIntMap<T> {\n     priv v: ~[Option<T>],\n }\n \n-impl<V> BaseIter<(uint, &V)> for SmallIntMap<V> {\n+impl<V> BaseIter<(uint, &self/V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in order\n     pure fn each(&self, it: fn(&(uint, &self/V)) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n@@ -36,7 +36,7 @@ impl<V> BaseIter<(uint, &V)> for SmallIntMap<V> {\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<V> ReverseIter<(uint, &V)> for SmallIntMap<V> {\n+impl<V> ReverseIter<(uint, &self/V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, it: fn(&(uint, &self/V)) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {"}, {"sha": "5c037b5bac5bff01301fa9c030c95da1a702c502", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -17,7 +17,7 @@ use core::util;\n use core::vec::{len, push};\n use core::vec;\n \n-type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n+type Le<T> = &self/pure fn(v1: &T, v2: &T) -> bool;\n \n /**\n  * Merge sort. Returns a new vector containing the sorted list.\n@@ -169,7 +169,7 @@ pub trait Sort {\n     fn qsort(self);\n }\n \n-impl<T:Copy + Ord + Eq> Sort for &mut [T] {\n+impl<T:Copy + Ord + Eq> Sort for &self/mut [T] {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n@@ -1178,11 +1178,10 @@ mod big_tests {\n \n     struct LVal {\n         val: uint,\n-        key: fn(@uint),\n-\n+        key: &self/fn(@uint),\n     }\n \n-    impl Drop for LVal {\n+    impl Drop for LVal/&self {\n         fn finalize(&self) {\n             let x = unsafe { task::local_data::local_data_get(self.key) };\n             match x {\n@@ -1196,7 +1195,7 @@ mod big_tests {\n         }\n     }\n \n-    impl Ord for LVal {\n+    impl Ord for LVal/&self {\n         pure fn lt(&self, other: &a/LVal/&self) -> bool {\n             (*self).val < other.val\n         }"}, {"sha": "b786699351e3514ea26b7eb76002f26e6f1a4ece", "filename": "src/libstd/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstats.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -30,7 +30,7 @@ pub trait Stats {\n     fn median_abs_dev_pct(self) -> f64;\n }\n \n-impl Stats for &[f64] {\n+impl Stats for &self/[f64] {\n     fn sum(self) -> f64 {\n         vec::foldl(0.0, self, |p,q| p + *q)\n     }"}, {"sha": "e02d09954d32a327165218064ff45bc5eca7b4b5", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -98,7 +98,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-pub impl<Q:Owned> &Sem<Q> {\n+pub impl<Q:Owned> &self/Sem<Q> {\n     fn acquire() {\n         let mut waiter_nobe = None;\n         unsafe {\n@@ -134,7 +134,7 @@ pub impl<Q:Owned> &Sem<Q> {\n }\n // FIXME(#3154) move both copies of this into Sem<Q>, and unify the 2 structs\n #[doc(hidden)]\n-pub impl &Sem<()> {\n+pub impl &self/Sem<()> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n@@ -147,7 +147,7 @@ pub impl &Sem<()> {\n     }\n }\n #[doc(hidden)]\n-pub impl &Sem<~[Waitqueue]> {\n+pub impl &self/Sem<~[Waitqueue]> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n@@ -162,11 +162,11 @@ pub impl &Sem<~[Waitqueue]> {\n \n // FIXME(#3588) should go inside of access()\n #[doc(hidden)]\n-type SemRelease = SemReleaseGeneric<()>;\n-type SemAndSignalRelease = SemReleaseGeneric<~[Waitqueue]>;\n-struct SemReleaseGeneric<Q> { sem: &Sem<Q> }\n+type SemRelease = SemReleaseGeneric/&self<()>;\n+type SemAndSignalRelease = SemReleaseGeneric/&self<~[Waitqueue]>;\n+struct SemReleaseGeneric<Q> { sem: &self/Sem<Q> }\n \n-impl<Q:Owned> Drop for SemReleaseGeneric<Q> {\n+impl<Q:Owned> Drop for SemReleaseGeneric/&self<Q> {\n     fn finalize(&self) {\n         self.sem.release();\n     }\n@@ -186,11 +186,11 @@ fn SemAndSignalRelease(sem: &r/Sem<~[Waitqueue]>)\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar { priv sem: &Sem<~[Waitqueue]> }\n+pub struct Condvar { priv sem: &self/Sem<~[Waitqueue]> }\n \n-impl Drop for Condvar { fn finalize(&self) {} }\n+impl Drop for Condvar/&self { fn finalize(&self) {} }\n \n-pub impl &Condvar {\n+pub impl Condvar/&self {\n     /**\n      * Atomically drop the associated lock, and block until a signal is sent.\n      *\n@@ -199,7 +199,8 @@ pub impl &Condvar {\n      * while waiting on a condition variable will wake up, fail, and unlock\n      * the associated lock as it unwinds.\n      */\n-    fn wait() { self.wait_on(0) }\n+    fn wait(&self) { self.wait_on(0) }\n+\n     /**\n      * As wait(), but can specify which of multiple condition variables to\n      * wait on. Only a signal_on() or broadcast_on() with the same condvar_id\n@@ -211,7 +212,7 @@ pub impl &Condvar {\n      *\n      * wait() is equivalent to wait_on(0).\n      */\n-    fn wait_on(condvar_id: uint) {\n+    fn wait_on(&self, condvar_id: uint) {\n         // Create waiter nobe.\n         let (WaitEnd, SignalEnd) = comm::oneshot();\n         let mut WaitEnd   = Some(WaitEnd);\n@@ -256,10 +257,10 @@ pub impl &Condvar {\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct SemAndSignalReacquire {\n-            sem: &Sem<~[Waitqueue]>,\n+            sem: &self/Sem<~[Waitqueue]>,\n         }\n \n-        impl Drop for SemAndSignalReacquire {\n+        impl Drop for SemAndSignalReacquire/&self {\n             fn finalize(&self) {\n                 unsafe {\n                     // Needs to succeed, instead of itself dying.\n@@ -279,9 +280,10 @@ pub impl &Condvar {\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n-    fn signal() -> bool { self.signal_on(0) }\n+    fn signal(&self) -> bool { self.signal_on(0) }\n+\n     /// As signal, but with a specified condvar_id. See wait_on.\n-    fn signal_on(condvar_id: uint) -> bool {\n+    fn signal_on(&self, condvar_id: uint) -> bool {\n         let mut out_of_bounds = None;\n         let mut result = false;\n         unsafe {\n@@ -299,9 +301,10 @@ pub impl &Condvar {\n     }\n \n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    fn broadcast() -> uint { self.broadcast_on(0) }\n+    fn broadcast(&self) -> uint { self.broadcast_on(0) }\n+\n     /// As broadcast, but with a specified condvar_id. See wait_on.\n-    fn broadcast_on(condvar_id: uint) -> uint {\n+    fn broadcast_on(&self, condvar_id: uint) -> uint {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n         unsafe {\n@@ -342,9 +345,9 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n }\n \n #[doc(hidden)]\n-pub impl &Sem<~[Waitqueue]> {\n+pub impl Sem<~[Waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n-    fn access_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n+    fn access_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n         do self.access { blk(&Condvar { sem: self }) }\n     }\n }\n@@ -368,18 +371,18 @@ impl Clone for Semaphore {\n     }\n }\n \n-pub impl &Semaphore {\n+pub impl Semaphore {\n     /**\n      * Acquire a resource represented by the semaphore. Blocks if necessary\n      * until resource(s) become available.\n      */\n-    fn acquire() { (&self.sem).acquire() }\n+    fn acquire(&self) { (&self.sem).acquire() }\n \n     /**\n      * Release a held resource represented by the semaphore. Wakes a blocked\n      * contending task, if any exist. Won't block the caller.\n      */\n-    fn release() { (&self.sem).release() }\n+    fn release(&self) { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n     fn access<U>(blk: fn() -> U) -> U { (&self.sem).access(blk) }\n@@ -416,12 +419,12 @@ impl Clone for Mutex {\n     fn clone(&self) -> Mutex { Mutex { sem: Sem((*self.sem).clone()) } }\n }\n \n-pub impl &Mutex {\n+pub impl Mutex {\n     /// Run a function with ownership of the mutex.\n-    fn lock<U>(blk: fn() -> U) -> U { (&self.sem).access(blk) }\n+    fn lock<U>(&self, blk: fn() -> U) -> U { (&self.sem).access(blk) }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    fn lock_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n+    fn lock_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -465,9 +468,9 @@ pub fn rwlock_with_condvars(num_condvars: uint) -> RWlock {\n                                              read_count: 0 }) }\n }\n \n-pub impl &RWlock {\n+pub impl RWlock {\n     /// Create a new handle to the rwlock.\n-    fn clone() -> RWlock {\n+    fn clone(&self) -> RWlock {\n         RWlock { order_lock:  (&(self.order_lock)).clone(),\n                  access_lock: Sem((*self.access_lock).clone()),\n                  state:       self.state.clone() }\n@@ -477,7 +480,7 @@ pub impl &RWlock {\n      * Run a function with the rwlock in read mode. Calls to 'read' from other\n      * tasks may run concurrently with this one.\n      */\n-    fn read<U>(blk: fn() -> U) -> U {\n+    fn read<U>(&self, blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -508,7 +511,7 @@ pub impl &RWlock {\n      * Run a function with the rwlock in write mode. No calls to 'read' or\n      * 'write' from other tasks will run concurrently with this one.\n      */\n-    fn write<U>(blk: fn() -> U) -> U {\n+    fn write<U>(&self, blk: fn() -> U) -> U {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n@@ -526,7 +529,7 @@ pub impl &RWlock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    fn write_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n         // NB: You might think I should thread the order_lock into the cond\n         // wait call, so that it gets waited on before access_lock gets\n         // reacquired upon being woken up. However, (a) this would be not\n@@ -561,7 +564,7 @@ pub impl &RWlock {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(blk: fn(v: RWlockWriteMode) -> U) -> U {\n+    fn write_downgrade<U>(&self, blk: fn(v: RWlockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         let mut _release = None;\n@@ -577,7 +580,7 @@ pub impl &RWlock {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade(token: RWlockWriteMode/&a) -> RWlockReadMode/&a {\n+    fn downgrade(&self, token: RWlockWriteMode/&a) -> RWlockReadMode/&a {\n         if !ptr::ref_eq(self, token.lock) {\n             fail!(~\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n@@ -606,10 +609,10 @@ pub impl &RWlock {\n // FIXME(#3588) should go inside of read()\n #[doc(hidden)]\n struct RWlockReleaseRead {\n-    lock: &RWlock,\n+    lock: &self/RWlock,\n }\n \n-impl Drop for RWlockReleaseRead {\n+impl Drop for RWlockReleaseRead/&self {\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n@@ -640,10 +643,10 @@ fn RWlockReleaseRead(lock: &r/RWlock) -> RWlockReleaseRead/&r {\n // FIXME(#3588) should go inside of downgrade()\n #[doc(hidden)]\n struct RWlockReleaseDowngrade {\n-    lock: &RWlock,\n+    lock: &self/RWlock,\n }\n \n-impl Drop for RWlockReleaseDowngrade {\n+impl Drop for RWlockReleaseDowngrade/&self {\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n@@ -680,23 +683,25 @@ fn RWlockReleaseDowngrade(lock: &r/RWlock) -> RWlockReleaseDowngrade/&r {\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockWriteMode { priv lock: &RWlock }\n-impl Drop for RWlockWriteMode { fn finalize(&self) {} }\n+pub struct RWlockWriteMode { priv lock: &self/RWlock }\n+impl Drop for RWlockWriteMode/&self { fn finalize(&self) {} }\n+\n /// The \"read permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockReadMode  { priv lock: &RWlock }\n-impl Drop for RWlockReadMode { fn finalize(&self) {} }\n+pub struct RWlockReadMode  { priv lock: &self/RWlock }\n+impl Drop for RWlockReadMode/&self { fn finalize(&self) {} }\n \n-pub impl &RWlockWriteMode {\n+pub impl RWlockWriteMode/&self {\n     /// Access the pre-downgrade rwlock in write mode.\n-    fn write<U>(blk: fn() -> U) -> U { blk() }\n+    fn write<U>(&self, blk: fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    fn write_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n         blk(&Condvar { sem: &self.lock.access_lock })\n     }\n }\n-pub impl &RWlockReadMode {\n+\n+pub impl RWlockReadMode/&self {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(blk: fn() -> U) -> U { blk() }\n+    fn read<U>(&self, blk: fn() -> U) -> U { blk() }\n }\n \n /****************************************************************************"}, {"sha": "d1fe1d4c67a86a7e41c5fba59f022da1687b6f4b", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -94,15 +94,18 @@ impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<'self, K: TotalOrd, V> BaseIter<(&'self K, &'self V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n     pure fn each(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each(&self.root, f)\n     }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<K: TotalOrd, V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<'self, K: TotalOrd, V>\n+    ReverseIter<(&'self K, &'self V)>\n+    for TreeMap<K, V>\n+{\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each_reverse(&self.root, f);\n@@ -195,8 +198,8 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<K, V> {\n-    priv stack: ~[&~TreeNode<K, V>],\n-    priv node: &Option<~TreeNode<K, V>>\n+    priv stack: ~[&self/~TreeNode<K, V>],\n+    priv node: &self/Option<~TreeNode<K, V>>\n }\n \n /// Advance the iterator to the next node (in order) and return a\n@@ -494,7 +497,7 @@ pub impl <T: TotalOrd> TreeSet<T> {\n \n /// Lazy forward iterator over a set\n pub struct TreeSetIterator<T> {\n-    priv iter: TreeMapIterator<T, ()>\n+    priv iter: TreeMapIterator/&self<T, ()>\n }\n \n /// Advance the iterator to the next node (in order). If this iterator is"}, {"sha": "e5435ca18b7a1e4bc683af5ac33f60da06257873", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -168,7 +168,8 @@ struct Database {\n }\n \n pub impl Database {\n-    fn prepare(&mut self, fn_name: &str,\n+    fn prepare(&mut self,\n+               fn_name: &str,\n                declared_inputs: &WorkMap) -> Option<(WorkMap, WorkMap, ~str)>\n     {\n         let k = json_encode(&(fn_name, declared_inputs));\n@@ -233,7 +234,9 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n     }\n }\n \n-fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n+fn json_decode<T:Decodable<json::Decoder/&static>>( // FIXME(#5121)\n+    s: &str) -> T\n+{\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));\n         Decodable::decode(&json::Decoder(j))\n@@ -261,7 +264,9 @@ pub impl Context {\n         Context{db: db, logger: lg, cfg: cfg, freshness: LinearMap::new()}\n     }\n \n-    fn prep<T:Owned + Encodable<json::Encoder> + Decodable<json::Decoder>>(\n+    fn prep<T:Owned +\n+              Encodable<json::Encoder> +\n+              Decodable<json::Decoder/&static>>( // FIXME(#5121)\n                   @self,\n                   fn_name:&str,\n                   blk: fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n@@ -277,7 +282,9 @@ trait TPrep {\n     fn declare_input(&self, kind:&str, name:&str, val:&str);\n     fn is_fresh(&self, cat:&str, kind:&str, name:&str, val:&str) -> bool;\n     fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n-    fn exec<T:Owned + Encodable<json::Encoder> + Decodable<json::Decoder>>(\n+    fn exec<T:Owned +\n+              Encodable<json::Encoder> +\n+              Decodable<json::Decoder/&static>>( // FIXME(#5121)\n         &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n }\n \n@@ -316,7 +323,9 @@ impl TPrep for @Mut<Prep> {\n         return true;\n     }\n \n-    fn exec<T:Owned + Encodable<json::Encoder> + Decodable<json::Decoder>>(\n+    fn exec<T:Owned +\n+              Encodable<json::Encoder> +\n+              Decodable<json::Decoder/&static>>( // FIXME(#5121)\n             &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n         let mut bo = Some(blk);\n \n@@ -355,14 +364,18 @@ impl TPrep for @Mut<Prep> {\n     }\n }\n \n-pub impl<T:Owned+Encodable<json::Encoder>+Decodable<json::Decoder>> Work<T> {\n+pub impl<T:Owned +\n+         Encodable<json::Encoder> +\n+         Decodable<json::Decoder/&static>> Work<T> { // FIXME(#5121)\n     static fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n }\n \n // FIXME (#3724): movable self. This should be in impl Work.\n-fn unwrap<T:Owned + Encodable<json::Encoder> + Decodable<json::Decoder>>(\n+fn unwrap<T:Owned +\n+            Encodable<json::Encoder> +\n+            Decodable<json::Decoder/&static>>( // FIXME(#5121)\n         w: Work<T>) -> T {\n     let mut ww = w;\n     let mut s = None;"}, {"sha": "8c12bbad3607bbd6db9d80f4a2ff4448b3be6776", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -46,18 +46,16 @@ pub impl Junction {\n     }\n }\n \n-type ExpandDerivingStructDefFn = &fn(ext_ctxt,\n-                                     span,\n-                                     x: &struct_def,\n-                                     ident,\n-                                     y: &Generics)\n-                                  -> @item;\n-type ExpandDerivingEnumDefFn = &fn(ext_ctxt,\n-                                   span,\n-                                   x: &enum_def,\n-                                   ident,\n-                                   y: &Generics)\n-                                -> @item;\n+type ExpandDerivingStructDefFn = &self/fn(ext_ctxt,\n+                                          span,\n+                                          x: &struct_def,\n+                                          ident,\n+                                          y: &Generics) -> @item;\n+type ExpandDerivingEnumDefFn = &self/fn(ext_ctxt,\n+                                        span,\n+                                        x: &enum_def,\n+                                        ident,\n+                                        y: &Generics) -> @item;\n \n pub fn expand_deriving_eq(cx: ext_ctxt,\n                           span: span,"}, {"sha": "7b4f92ab3ca83a2cbec6e97752d54c452194fc33", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -442,11 +442,12 @@ pub fn core_macros() -> ~str {\n             mod $c {\n                 fn key(_x: @::core::condition::Handler<$in,$out>) { }\n \n-                pub const cond : ::core::condition::Condition<$in,$out> =\n+                pub const cond :\n+                    ::core::condition::Condition/&static<$in,$out> =\n                     ::core::condition::Condition {\n-                    name: stringify!($c),\n-                    key: key\n-                };\n+                        name: stringify!($c),\n+                        key: key\n+                    };\n             }\n         }\n     )"}, {"sha": "f71f07655f29ad37f2231658b66f65a76d691be2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -599,6 +599,12 @@ pub impl Parser {\n         }\n     }\n \n+    fn region_from_lifetime(&self, l: &ast::Lifetime) -> @region {\n+        // eventually `ast::region` should go away in favor of\n+        // `ast::Lifetime`.  For now we convert between them.\n+        self.region_from_name(Some(l.ident))\n+    }\n+\n     fn parse_ty(&self, colons_before_params: bool) -> @Ty {\n         maybe_whole!(self, nt_ty);\n \n@@ -944,7 +950,7 @@ pub impl Parser {\n \n         // Parse the region parameter, if any, which will\n         // be written \"foo/&x\"\n-        let rp = {\n+        let rp_slash = {\n             // Hack: avoid parsing vstores like /@ and /~.  This is painful\n             // because the notation for region bounds and the notation for\n             // vstores is... um... the same.  I guess that's my fault.  This\n@@ -961,9 +967,23 @@ pub impl Parser {\n         };\n \n         // Parse any lifetime or type parameters which may appear:\n-        let tps = self.parse_generic_values();\n+        let (lifetimes, tps) = self.parse_generic_values();\n         let hi = self.span.lo;\n \n+        let rp = match (&rp_slash, &lifetimes) {\n+            (&Some(_), _) => rp_slash,\n+            (&None, v) => {\n+                if v.len() == 0 {\n+                    None\n+                } else if v.len() == 1 {\n+                    Some(self.region_from_lifetime(v.get(0)))\n+                } else {\n+                    self.fatal(fmt!(\"Expected at most one \\\n+                                     lifetime name (for now)\"));\n+                }\n+            }\n+        };\n+\n         @ast::path { span: mk_sp(lo, hi),\n                      rp: rp,\n                      types: tps,\n@@ -1316,11 +1336,11 @@ pub impl Parser {\n                   token::IDENT(i, _) => {\n                     hi = self.span.hi;\n                     self.bump();\n-                    let tys = if self.eat(&token::MOD_SEP) {\n+                    let (_, tys) = if self.eat(&token::MOD_SEP) {\n                         self.expect(&token::LT);\n                         self.parse_generic_values_after_lt()\n                     } else {\n-                        ~[]\n+                        (opt_vec::Empty, ~[])\n                     };\n \n                     // expr.f() method call\n@@ -2776,20 +2796,24 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_generic_values(&self) -> ~[@Ty] {\n+    fn parse_generic_values(\n+        &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n+    {\n         if !self.eat(&token::LT) {\n-            ~[]\n+            (opt_vec::Empty, ~[])\n         } else {\n             self.parse_generic_values_after_lt()\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&self) -> ~[@Ty] {\n-        let _lifetimes = self.parse_lifetimes();\n+    fn parse_generic_values_after_lt(\n+        &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n+    {\n+        let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n             |p| p.parse_ty(false));\n-        opt_vec::take_vec(result)\n+        (lifetimes, opt_vec::take_vec(result))\n     }\n \n     fn parse_fn_decl(&self, parse_arg_fn: fn(&Parser) -> arg_or_capture_item)"}, {"sha": "2b85a9183641a5c99b909fcb989efa40532d040c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -35,8 +35,8 @@ use core::u64;\n use core::vec;\n \n // The @ps is stored here to prevent recursive type.\n-pub enum ann_node/& {\n-    node_block(@ps, &ast::blk),\n+pub enum ann_node<'self> {\n+    node_block(@ps, &'self ast::blk),\n     node_item(@ps, @ast::item),\n     node_expr(@ps, @ast::expr),\n     node_pat(@ps, @ast::pat),\n@@ -147,6 +147,10 @@ pub fn expr_to_str(e: @ast::expr, intr: @ident_interner) -> ~str {\n     to_str(e, print_expr, intr)\n }\n \n+pub fn region_to_str(e: @ast::region, intr: @ident_interner) -> ~str {\n+    to_str(e, |s, e| print_region(s, ~\"&\", e, ~\"\"), intr)\n+}\n+\n pub fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n     to_str(tt, print_tt, intr)\n }\n@@ -1813,6 +1817,7 @@ pub fn print_generics(s: @ps, &&generics: &ast::Generics) {\n                 let lifetime = generics.lifetimes.get(idx);\n                 print_lifetime(s, lifetime);\n             } else {\n+                let idx = idx - generics.lifetimes.len();\n                 let param = generics.ty_params.get(idx);\n                 print_ident(s, param.ident);\n                 print_bounds(s, param.bounds);"}, {"sha": "5e97793b4806963d82d97dc6fb9c8a0e70cbb0fa", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -28,14 +28,14 @@ use opt_vec::OptVec;\n // hold functions that take visitors. A vt enum is used to break the cycle.\n pub enum vt<E> { mk_vt(visitor<E>), }\n \n-pub enum fn_kind {\n-    fk_item_fn(ident, &Generics, purity),   // fn foo()\n-    fk_method(ident, &Generics, &method),   // fn foo(&self)\n+pub enum fn_kind<'self> {\n+    fk_item_fn(ident, &'self Generics, purity),   // fn foo()\n+    fk_method(ident, &'self Generics, &'self method),   // fn foo(&self)\n     fk_anon(ast::Sigil),                    // fn@(x, y) { ... }\n     fk_fn_block,                            // |x, y| ...\n     fk_dtor( // class destructor\n-        &Generics,\n-        &[attribute],\n+        &'self Generics,\n+        &'self [attribute],\n         node_id /* self id */,\n         def_id /* parent class id */\n     )"}, {"sha": "59ee07b2cf8ebc888f0cdb170cc9245b5abc85fb", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -12,7 +12,10 @@ extern mod std;\n use std::arena;\n use methods = std::arena::Arena;\n \n-enum tree/& { nil, node(&tree, &tree, int), }\n+enum tree {\n+    nil,\n+    node(&'self tree<'self>, &'self tree<'self>, int),\n+}\n \n fn item_check(t: &tree) -> int {\n     match *t {\n@@ -23,9 +26,9 @@ fn item_check(t: &tree) -> int {\n     }\n }\n \n-fn bottom_up_tree(arena: &r/arena::Arena,\n+fn bottom_up_tree(arena: &'r arena::Arena,\n                   item: int,\n-                  depth: int) -> &r/tree {\n+                  depth: int) -> &'r tree<'r> {\n     if depth > 0 {\n         return arena.alloc(\n             || node(bottom_up_tree(arena, 2 * item - 1, depth - 1),"}, {"sha": "3cf1c770df794ec11cdc2cc8c6d7168e88738ce5", "filename": "src/test/compile-fail/auto-ref-borrowck-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fauto-ref-borrowck-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fauto-ref-borrowck-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-borrowck-failure.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -18,7 +18,7 @@ trait Stuff {\n     fn printme();\n }\n \n-impl Stuff for &mut Foo {\n+impl Stuff for &'self mut Foo {\n     fn printme() {\n         io::println(fmt!(\"%d\", self.x));\n     }"}, {"sha": "7faee6f7ea28f5525d610a008ddcf6f1a22cc1aa", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -23,6 +23,6 @@ trait MyIter {\n     pure fn test_mut(&mut self);\n }\n \n-impl MyIter for &[int] {\n+impl MyIter for &'self [int] {\n     pure fn test_mut(&mut self) { }\n }"}, {"sha": "7873adbf21d8e0fc21ee52d6b4e646f8940e363b", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n enum X = Either<(uint,uint),extern fn()>;\n-pub impl &X {\n+pub impl &'self X {\n     fn with(blk: fn(x: &Either<(uint,uint),extern fn()>)) {\n         blk(&**self)\n     }"}, {"sha": "fd8190358c9d03278022e7868f875e90420b401f", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n struct defer {\n-    x: &[&str],\n+    x: &'self [&'self str],\n }\n \n-impl Drop for defer {\n+impl Drop for defer<'self> {\n     fn finalize(&self) {\n         error!(\"%?\", self.x);\n     }\n }\n \n-fn defer(x: &r/[&r/str]) -> defer/&r {\n+fn defer(x: &'r [&'r str]) -> defer<'r> {\n     defer {\n         x: x\n     }"}, {"sha": "29544caed5336e2eefd08abe69b66f85982b159a", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct boxedFn { theFn: ~fn() -> uint }\n+struct boxedFn { theFn: &'self fn() -> uint }\n \n fn createClosure (closedUint: uint) -> boxedFn {\n-    let result: @fn() -> uint = || closedUint;\n-    boxedFn { theFn: result } //~ ERROR mismatched types\n+    let theFn: @fn() -> uint = || closedUint;\n+    boxedFn {theFn: theFn} //~ ERROR illegal borrow\n }\n \n fn main () {"}, {"sha": "615bf64eed54e1456c8f73a03d0c3d94d39734bb", "filename": "src/test/compile-fail/issue-3154.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct thing<Q> {\n-    x: &Q\n+    x: &'self Q\n }\n \n fn thing<Q>(x: &Q) -> thing<Q> {"}, {"sha": "8872357a8d440c01d4b80fe4ed031e2c9923f2c6", "filename": "src/test/compile-fail/issue-3311.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,17 +10,17 @@\n \n #[legacy_mode]\n struct Foo {\n-    s: &str,\n+    s: &'self str,\n     u: ~()\n }\n \n-pub impl Foo {\n+pub impl Foo<'self> {\n     fn get_s(&self) -> &self/str {\n         self.s\n     }\n }\n \n-fn bar(s: &str, f: fn(Option<Foo>)) {\n+fn bar(s: &str, f: &fn(Option<Foo>)) {\n     f(Some(Foo {s: s, u: ~()}));\n }\n "}, {"sha": "6045ac6cba3519f58859921913ab96aeb1303eda", "filename": "src/test/compile-fail/issue-4523.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,7 +10,7 @@\n \n fn foopy() {}\n \n-const f: fn() = foopy; //~ ERROR mismatched types: expected `&static/fn()`\n+const f: &'static fn() = foopy; //~ ERROR mismatched types: expected `&static/fn()`\n \n fn main () {\n     f();"}, {"sha": "a51f7d8efbeb6f991a854770f7bf1b55ee097931", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -12,11 +12,11 @@\n // be parameterized by a region due to the &self/int constraint.\n \n trait foo {\n-    fn foo(i: &self/int) -> int;\n+    fn foo(i: &'self int) -> int;\n }\n \n-impl<T:Copy> foo for T {\n-    fn foo(i: &self/int) -> int {*i}\n+impl<T:Copy> foo<'self> for T {\n+    fn foo(i: &'self int) -> int {*i}\n }\n \n fn to_foo<T:Copy>(t: T) {"}, {"sha": "c7a951c9c056db76eb80e93f5fda4c6a8f120393", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -12,25 +12,25 @@\n // nominal types (but not on other types) and that they are type\n // checked.\n \n-enum an_enum = &int;\n+enum an_enum = &'self int;\n trait a_trait {\n     fn foo() -> &'self int;\n }\n struct a_class { x:&'self int }\n \n-fn a_fn1(e: an_enum/&a) -> an_enum/&b {\n+fn a_fn1(e: an_enum<'a>) -> an_enum<'b> {\n     return e; //~ ERROR mismatched types: expected `an_enum/&b` but found `an_enum/&a`\n }\n \n-fn a_fn2(e: a_trait/&a) -> a_trait/&b {\n+fn a_fn2(e: a_trait<'a>) -> a_trait<'b> {\n     return e; //~ ERROR mismatched types: expected `@a_trait/&b` but found `@a_trait/&a`\n }\n \n-fn a_fn3(e: a_class/&a) -> a_class/&b {\n+fn a_fn3(e: a_class<'a>) -> a_class<'b> {\n     return e; //~ ERROR mismatched types: expected `a_class/&b` but found `a_class/&a`\n }\n \n-fn a_fn4(e: int/&a) -> int/&b {\n+fn a_fn4(e: int<'a>) -> int<'b> {\n     //~^ ERROR region parameters are not allowed on this type\n     //~^^ ERROR region parameters are not allowed on this type\n     return e;"}, {"sha": "27fcd2338fa5185eb2fdc7b936db2ddf09f7f608", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -12,7 +12,7 @@\n \n enum ast {\n     num(uint),\n-    add(&ast, &ast)\n+    add(&'self ast<'self>, &'self ast<'self>)\n }\n \n fn build() {"}, {"sha": "de0f18392e643e20990f8540f9683e718bdef5d1", "filename": "src/test/compile-fail/regions-creating-enums3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,10 +10,10 @@\n \n enum ast {\n     num(uint),\n-    add(&ast, &ast)\n+    add(&'self ast<'self>, &'self ast<'self>)\n }\n \n-fn mk_add_bad1(x: &a/ast, y: &b/ast) -> ast/&a {\n+fn mk_add_bad1(x: &'a ast<'a>, y: &'b ast<'b>) -> ast<'a> {\n     add(x, y) //~ ERROR cannot infer an appropriate lifetime\n }\n "}, {"sha": "d9a6c48fa27e5ea45e7ec0b90a2b16f541528113", "filename": "src/test/compile-fail/regions-creating-enums4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum ast {\n+enum ast<'self> {\n     num(uint),\n-    add(&ast, &ast)\n+    add(&'self ast<'self>, &'self ast<'self>)\n }\n \n-fn mk_add_bad2(x: &a/ast, y: &a/ast, z: &ast) -> ast {\n+fn mk_add_bad2(x: &'a ast<'a>, y: &'a ast<'a>, z: &ast) -> ast {\n     add(x, y)\n          //~^ ERROR cannot infer an appropriate lifetime\n }"}, {"sha": "0a1e917c361af27d67282779db9db7680cc4a243", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -12,7 +12,7 @@ trait deref {\n     fn get() -> int;\n }\n \n-impl deref for &int {\n+impl deref for &'self int {\n     fn get() -> int {\n         *self\n     }"}, {"sha": "2732e49555894469c6f61163b07805dcfb21c6ed", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -11,19 +11,19 @@\n mod argparse {\n     extern mod std;\n \n-    pub struct Flag {\n-        name: &str,\n-        desc: &str,\n+    pub struct Flag<'self> {\n+        name: &'self str,\n+        desc: &'self str,\n         max_count: uint,\n         value: uint\n     }\n \n-    pub fn flag(name: &r/str, desc: &r/str) -> Flag/&r {\n+    pub fn flag(name: &'r str, desc: &'r str) -> Flag<'r> {\n         Flag { name: name, desc: desc, max_count: 1, value: 0 }\n     }\n \n-    pub impl Flag {\n-        fn set_desc(self, s: &str) -> Flag {\n+    pub impl Flag<'self> {\n+        fn set_desc(self, s: &str) -> Flag<'self> {\n             Flag { //~ ERROR cannot infer an appropriate lifetime\n                 name: self.name,\n                 desc: s,"}, {"sha": "19dea9a57ee49bc56587074046884b571a0b5f3b", "filename": "src/test/compile-fail/regions-in-consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const c_x: &blk/int = &22; //~ ERROR only the static region is allowed here\n-const c_y: &static/int = &22;\n+const c_x: &'blk int = &22; //~ ERROR Illegal lifetime &blk: only 'static is allowed here\n+const c_y: &int = &22; //~ ERROR Illegal anonymous lifetime: only 'static is allowed here\n+const c_z: &'static int = &22;\n \n fn main() {\n }"}, {"sha": "5c2269977d19439631ce4c91adb058ea04288101", "filename": "src/test/compile-fail/regions-in-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,15 +10,15 @@\n \n enum yes0<'lt> {\n     // This will eventually be legal (and in fact the only way):\n-    X3(&'lt uint) //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n+    X3(&'lt uint) //~ ERROR Illegal lifetime &lt: only 'self is allowed allowed as part of a type declaration\n }\n \n enum yes1 {\n     X4(&'self uint)\n }\n \n enum yes2 {\n-    X5(&'foo uint) //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n+    X5(&'foo uint) //~ ERROR Illegal lifetime &foo: only 'self is allowed allowed as part of a type declaration\n }\n \n fn main() {}"}, {"sha": "10d7a921ed031eac2726d7d9476cbc1379b06585", "filename": "src/test/compile-fail/regions-in-structs.rs", "status": "renamed", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,28 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct yes0 {\n-  x: &uint,\n+struct yes0<'self> {\n+  x: &uint, //~ ERROR Illegal anonymous lifetime: anonymous lifetimes are not permitted here\n }\n \n-impl Drop for yes0 {\n-    fn finalize(&self) {}\n+struct yes1<'self> {\n+  x: &'self uint,\n }\n \n-struct yes1 {\n-  x: &self/uint,\n-}\n-\n-impl Drop for yes1 {\n-    fn finalize(&self) {}\n-}\n-\n-struct yes2 {\n-  x: &foo/uint, //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n-}\n-\n-impl Drop for yes2 {\n-    fn finalize(&self) {}\n+struct yes2<'self> {\n+  x: &'foo uint, //~ ERROR Illegal lifetime &foo: only 'self is allowed allowed as part of a type declaration\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/regions-in-rsrcs.rs"}, {"sha": "2397c8f231131e42e48986817b7c7eb8ccaf34d5", "filename": "src/test/compile-fail/regions-in-type-items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n type item_ty_yes0 = {\n-    x: &uint\n+    x: &uint //~ ERROR Illegal anonymous lifetime: anonymous lifetimes are not permitted here\n };\n \n type item_ty_yes1 = {\n-    x: &self/uint\n+    x: &'self uint\n };\n \n type item_ty_yes2 = {\n-    x: &foo/uint //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n+    x: &'foo uint //~ ERROR Illegal lifetime &foo: only 'self is allowed allowed as part of a type declaration\n };\n \n fn main() {}"}, {"sha": "bde0e3f80c0fdb2e1735da92c5dfca4fa2e2749b", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,25 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct param1 {\n-    g: &fn()\n+struct parameterized1 {\n+    g: &'self fn()\n }\n \n-struct param2 {\n-    g: fn()\n-}\n-\n-struct not_param1 {\n+struct not_parameterized1 {\n     g: @fn()\n }\n \n-struct not_param2 {\n+struct not_parameterized2 {\n     g: @fn()\n }\n \n-fn take1(p: param1) -> param1 { p } //~ ERROR mismatched types\n-fn take2(p: param2) -> param2 { p } //~ ERROR mismatched types\n-fn take3(p: not_param1) -> not_param1 { p }\n-fn take4(p: not_param2) -> not_param2 { p }\n+fn take1(p: parameterized1) -> parameterized1 { p } //~ ERROR mismatched types\n+fn take3(p: not_parameterized1) -> not_parameterized1 { p }\n+fn take4(p: not_parameterized2) -> not_parameterized2 { p }\n \n fn main() {}"}, {"sha": "fca8f759da0b24955f9da6de39f22d28a94b819c", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-immutability.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n struct contravariant {\n-    f: &int\n+    f: &'self int\n }\n \n-fn to_same_lifetime(bi: contravariant/&r) {\n-    let bj: contravariant/&r = bi;\n+fn to_same_lifetime(bi: contravariant<'r>) {\n+    let bj: contravariant<'r> = bi;\n }\n \n-fn to_shorter_lifetime(bi: contravariant/&r) {\n-    let bj: contravariant/&blk = bi;\n+fn to_shorter_lifetime(bi: contravariant<'r>) {\n+    let bj: contravariant<'blk> = bi;\n }\n \n-fn to_longer_lifetime(bi: contravariant/&r) -> contravariant/&static {\n+fn to_longer_lifetime(bi: contravariant<'r>) -> contravariant/&static {\n     bi //~ ERROR mismatched types\n }\n "}, {"sha": "3ad841923e3131bae98f3d0d72f96f1fa1af13dc", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-arg-and-ret.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -13,18 +13,18 @@\n // You cannot convert between regions.\n \n struct invariant {\n-    f: fn(x: &self/int) -> &self/int\n+    f: &'self fn(x: &'self int) -> &'self int\n }\n \n-fn to_same_lifetime(bi: invariant/&r) {\n-    let bj: invariant/&r = bi;\n+fn to_same_lifetime(bi: invariant<'r>) {\n+    let bj: invariant<'r> = bi;\n }\n \n-fn to_shorter_lifetime(bi: invariant/&r) {\n-    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+fn to_shorter_lifetime(bi: invariant<'r>) {\n+    let bj: invariant<'blk> = bi; //~ ERROR mismatched types\n }\n \n-fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+fn to_longer_lifetime(bi: invariant<'r>) -> invariant/&static {\n     bi //~ ERROR mismatched types\n }\n "}, {"sha": "b1d0249380f46e8729aa9783399bc4ae5b5ca81a", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-1.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n struct invariant {\n-    f: @mut &int\n+    f: @mut &'self int\n }\n \n-fn to_same_lifetime(bi: invariant/&r) {\n-    let bj: invariant/&r = bi;\n+fn to_same_lifetime(bi: invariant<'r>) {\n+    let bj: invariant<'r> = bi;\n }\n \n-fn to_shorter_lifetime(bi: invariant/&r) {\n-    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+fn to_shorter_lifetime(bi: invariant<'r>) {\n+    let bj: invariant<'blk> = bi; //~ ERROR mismatched types\n }\n \n-fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+fn to_longer_lifetime(bi: invariant<'r>) -> invariant<'static> {\n     bi //~ ERROR mismatched types\n }\n "}, {"sha": "ae62ef6f39a264c3d3d03feb371c49841e887d54", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,19 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct invariant {\n-    f: @mut [&int]\n+struct invariant<'self> {\n+    f: @mut [&'self int]\n }\n \n-fn to_same_lifetime(bi: invariant/&r) {\n-    let bj: invariant/&r = bi;\n+fn to_same_lifetime(bi: invariant<'r>) {\n+    let bj: invariant<'r> = bi;\n }\n \n-fn to_shorter_lifetime(bi: invariant/&r) {\n-    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+fn to_shorter_lifetime(bi: invariant<'r>) {\n+    let bj: invariant<'blk> = bi; //~ ERROR mismatched types\n }\n \n-fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+fn to_longer_lifetime(bi: invariant<'r>) -> invariant<'static> {\n     bi //~ ERROR mismatched types\n }\n "}, {"sha": "f9c6e2e36ec955493e15696b8e450b4049c900ee", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n struct invariant {\n-    f: &int\n+    f: @mut &'self int\n }\n \n-fn to_same_lifetime(bi: invariant/&r) {\n-    let bj: invariant/&r = bi;\n+fn to_same_lifetime(bi: invariant<'r>) {\n+    let bj: invariant<'r> = bi;\n }\n \n-fn to_shorter_lifetime(bi: invariant/&r) {\n-    let bj: invariant/&blk = bi;\n-}   \n+fn to_shorter_lifetime(bi: invariant<'r>) {\n+    let bj: invariant<'blk> = bi; //~ ERROR mismatched types\n+}\n \n-fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+fn to_longer_lifetime(bi: invariant<'r>) -> invariant/&static {\n     bi //~ ERROR mismatched types\n }\n "}, {"sha": "b5f8d99829870b23d841ecfef117f9ebf4f74101", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct direct {\n-    f: &int\n+struct direct<'self> {\n+    f: &'self int\n }\n \n struct indirect1 {\n@@ -21,7 +21,7 @@ struct indirect2 {\n }\n \n struct indirect3 {\n-    g: @fn(direct/&self)\n+    g: @fn(direct<'self>)\n }\n \n fn take_direct(p: direct) -> direct { p } //~ ERROR mismatched types"}, {"sha": "ddf1454070c776c823a11057a79f96cfb2d22d75", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -11,17 +11,17 @@\n // Check that we correctly infer that b and c must be region\n // parameterized because they reference a which requires a region.\n \n-type a = &int;\n-type b = @a;\n-type c = {f: @b};\n+type a<'self> = &'self int;\n+type b<'self> = @a<'self>;\n+type c<'self> = {f: @b<'self>};\n \n-trait set_f {\n-    fn set_f_ok(b: @b/&self);\n+trait set_f<'self> {\n+    fn set_f_ok(b: @b<'self>);\n     fn set_f_bad(b: @b);\n }\n \n-impl set_f for c {\n-    fn set_f_ok(b: @b/&self) {\n+impl<'self> set_f<'self> for c<'self> {\n+    fn set_f_ok(b: @b<'self>) {\n         self.f = b;\n     }\n "}, {"sha": "32702663c6e06904fe54f1006ebf2d220700145f", "filename": "src/test/compile-fail/regions-infer-paramd-method.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -11,22 +11,22 @@\n // Here: foo is parameterized because it contains a method that\n // refers to self.\n \n-trait foo {\n-    fn self_int() -> &self/int;\n+trait foo<'self> {\n+    fn self_int() -> &'self int;\n \n     fn any_int() -> &int;\n }\n \n-struct with_foo {\n-    f: foo\n+struct with_foo<'self> {\n+    f: foo<'self>\n }\n \n trait set_foo_foo {\n-    fn set_foo(&mut self, f: foo);\n+    fn set_foo(&mut self, f: @foo);\n }\n \n-impl set_foo_foo for with_foo {\n-    fn set_foo(&mut self, f: foo) {\n+impl<'self> set_foo_foo for with_foo<'self> {\n+    fn set_foo(&mut self, f: @foo) {\n         self.f = f; //~ ERROR mismatched types: expected `@foo/&self` but found `@foo/&`\n     }\n }"}, {"sha": "8b12813447ef2919bd78b961ab4e80b6949b49d2", "filename": "src/test/compile-fail/regions-steal-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct closure_box {\n-    cl: &fn()\n+struct closure_box<'self> {\n+    cl: &'self fn()\n }\n \n-fn box_it(x: &r/fn()) -> closure_box/&r {\n+fn box_it(x: &'r fn()) -> closure_box<'r> {\n     closure_box {cl: x}\n }\n "}, {"sha": "8b81b31173099ae9424bf8d9eda2bd91bffb9dab", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -15,13 +15,13 @@ trait get_ctxt {\n     fn get_ctxt() -> &ctxt;\n }\n \n-struct has_ctxt { c: &ctxt }\n+struct has_ctxt { c: &'self ctxt }\n \n-impl get_ctxt for has_ctxt {\n+impl get_ctxt for has_ctxt<'self> {\n \n     // Here an error occurs because we used `&self` but\n     // the definition used `&`:\n-    fn get_ctxt() -> &self/ctxt { //~ ERROR method `get_ctxt` has an incompatible type\n+    fn get_ctxt() -> &'self ctxt { //~ ERROR method `get_ctxt` has an incompatible type\n         self.c\n     }\n "}, {"sha": "12ab58ec8907e58005292307f0d0356ec28315bf", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,13 +10,13 @@\n \n struct ctxt { v: uint }\n \n-trait get_ctxt {\n-    fn get_ctxt() -> &self/ctxt;\n+trait get_ctxt<'self> {\n+    fn get_ctxt() -> &'self ctxt;\n }\n \n-struct has_ctxt { c: &ctxt }\n+struct has_ctxt<'self> { c: &'self ctxt }\n \n-impl get_ctxt for has_ctxt {\n+impl<'self> get_ctxt<'self> for has_ctxt<'self> {\n     fn get_ctxt() -> &self/ctxt { self.c }\n }\n "}, {"sha": "c537eb9997f3f7478d4d2c95d95b8d8eebd4a1d8", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -16,7 +16,7 @@ trait iterable<A> {\n     fn iterate(blk: fn(x: &A) -> bool);\n }\n \n-impl<A> iterable<A> for &[A] {\n+impl<A> iterable<A> for &self/[A] {\n     fn iterate(f: fn(x: &A) -> bool) {\n         for vec::each(self) |e| {\n             if !f(e) { break; }"}, {"sha": "eda06709692999655277ccd0938f70794ceb7c6b", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -16,12 +16,12 @@ trait MyIter {\n     pure fn test_const(&const self);\n }\n \n-impl MyIter for &[int] {\n+impl MyIter for &'self [int] {\n     pure fn test_imm(&self) { assert self[0] == 1 }\n     pure fn test_const(&const self) { assert self[0] == 1 }\n }\n \n-impl MyIter for &str {\n+impl MyIter for &'self str {\n     pure fn test_imm(&self) { assert *self == \"test\" }\n     pure fn test_const(&const self) { assert *self == \"test\" }\n }"}, {"sha": "b6d71fcfb55af20f3908713100258781686513db", "filename": "src/test/run-pass/auto-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fauto-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fauto-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -16,7 +16,7 @@ trait Stuff {\n     fn printme();\n }\n \n-impl Stuff for &Foo {\n+impl Stuff for &self/Foo {\n     fn printme() {\n         io::println(fmt!(\"%d\", self.x));\n     }"}, {"sha": "02dbfeda2586953f61b683490f96f923fc93a0d3", "filename": "src/test/run-pass/borrow-by-val-method-receiver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -12,7 +12,7 @@ trait Foo {\n     fn foo(self);\n }\n \n-impl Foo for &[int] {\n+impl Foo for &'self [int] {\n     fn foo(self) {}\n }\n "}, {"sha": "34203b091fe2af4922ff194dc19addba515f08ab", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -49,8 +49,8 @@ pub impl<T> cat<T> {\n     }\n }\n \n-impl<T> BaseIter<(int, &T)> for cat<T> {\n-    pure fn each(&self, f: fn(&(int, &self/T)) -> bool) {\n+impl<T> BaseIter<(int, &'self T)> for cat<T> {\n+    pure fn each(&self, f: fn(&(int, &'self T)) -> bool) {\n         let mut n = int::abs(self.meows);\n         while n > 0 {\n             if !f(&(n, &self.name)) { break; }\n@@ -86,7 +86,7 @@ impl<T> Map<int, T> for cat<T> {\n         true\n     }\n \n-    pure fn find(&self, k: &int) -> Option<&self/T> {\n+    pure fn find(&self, k: &int) -> Option<&'self T> {\n         if *k <= self.meows {\n             Some(&self.name)\n         } else {\n@@ -104,7 +104,7 @@ impl<T> Map<int, T> for cat<T> {\n }\n \n pub impl<T> cat<T> {\n-    pure fn get(&self, k: &int) -> &self/T {\n+    pure fn get(&self, k: &int) -> &'self T {\n         match self.find(k) {\n           Some(v) => { v }\n           None    => { fail!(~\"epic fail\"); }"}, {"sha": "8f0a7a1a4dba3286247973490abc23d1f3c9e805", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -2,7 +2,7 @@ trait Reverser {\n     fn reverse(&self);\n }\n \n-impl Reverser for &mut [uint] {\n+impl Reverser for &'self mut [uint] {\n     fn reverse(&self) {\n         vec::reverse(*self);\n     }"}, {"sha": "bad2b71200c57291f70b7942e3287a073f569226", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n enum E { V1(int), V0 }\n-const C: &[E] = &[V0, V1(0xDEADBEE)];\n+const C: &'static [E] = &[V0, V1(0xDEADBEE)];\n const C0: E = C[0];\n const C1: E = C[1];\n "}, {"sha": "c2c2792e0d2e7e5883f2b2481e3214e7d21fa685", "filename": "src/test/run-pass/const-fields-and-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,7 +10,7 @@\n \n const x : [int * 4] = [1,2,3,4];\n const p : int = x[2];\n-const y : &[int] = &[1,2,3,4];\n+const y : &'static [int] = &[1,2,3,4];\n const q : int = y[2];\n \n struct S {a: int, b: int}"}, {"sha": "4e46d67cafeb941283ddf224473c76d255156249", "filename": "src/test/run-pass/const-fn-val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -12,9 +12,9 @@ fn foo() -> int {\n     return 0xca7f000d;\n }\n \n-struct Bar { f: &fn() -> int }\n+struct Bar { f: &'self fn() -> int }\n \n-const b : Bar = Bar { f: foo };\n+const b : Bar/&static = Bar { f: foo };\n \n pub fn main() {\n     assert (b.f)() == 0xca7f000d;"}, {"sha": "c847b4ff0f12f8af0f35e796a11c80d09e0ee9e7", "filename": "src/test/run-pass/const-region-ptrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n \n-struct Pair { a: int, b: &int }\n+struct Pair { a: int, b: &'self int }\n \n-const x: &int = &10;\n+const x: &'static int = &10;\n \n-const y: &Pair = &Pair {a: 15, b: x};\n+const y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n     io::println(fmt!(\"x = %?\", *x));"}, {"sha": "e49488a66e82aa484d23764062b2bf64fd5c6f33", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -22,7 +22,7 @@ impl cmp::Eq for foo {\n \n const x : foo = foo { a:1, b:2, c: 3 };\n const y : foo = foo { b:2, c:3, a: 1 };\n-const z : &foo = &foo { a: 10, b: 22, c: 12 };\n+const z : &'static foo = &foo { a: 10, b: 22, c: 12 };\n \n pub fn main() {\n     assert x.b == 2;"}, {"sha": "5598756ac75a6ab2b711aabd738fed9d0a8ec88c", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -16,10 +16,9 @@\n  */\n \n fn f() { }\n-const bare_fns: &[extern fn()] = &[f, f];\n-// NOTE Why does this not type without the struct?\n-struct S(&fn());\n-const closures: &[S] = &[S(f), S(f)];\n+const bare_fns: &'static [extern fn()] = &[f, f];\n+struct S<'self>(&'self fn());\n+const closures: &'static [S<'static>] = &[S(f), S(f)];\n \n pub fn main() {\n     for bare_fns.each |&bare_fn| { bare_fn() }"}, {"sha": "a719af7120edb9617f246839881474854247060d", "filename": "src/test/run-pass/const-vecs-and-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n const x : [int * 4] = [1,2,3,4];\n-const y : &[int] = &[1,2,3,4];\n+const y : &'static [int] = &[1,2,3,4];\n \n pub fn main() {\n     io::println(fmt!(\"%?\", x[1]));"}, {"sha": "1bd6304fabc261711ee12b2d9aa74b7d891968ee", "filename": "src/test/run-pass/infer-with-expected.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -16,7 +16,7 @@\n fn eat_tup(_r: ~@(int, @fn(Pair) -> int)) {}\n fn eat_rec(_r: @~Rec) {}\n \n-struct Rec { a: int, b: fn(Pair) -> int }\n+struct Rec { a: int, b: &'self fn(Pair) -> int }\n struct Pair { x: int, y: int }\n \n pub fn main() {"}, {"sha": "c7a7dc539658c54c69031d9e3b17f8029761c649", "filename": "src/test/run-pass/issue-2502.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2502.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct font {\n-    fontbuf: &self/~[u8],\n+    fontbuf: &'self ~[u8],\n }\n \n-pub impl font {\n+pub impl font/&self {\n     fn buf() -> &self/~[u8] {\n         self.fontbuf\n     }"}, {"sha": "438abe9841337425c5acf23da23ebd72cd86f3ef", "filename": "src/test/run-pass/issue-2735-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,16 +10,16 @@\n \n // This test should behave exactly like issue-2735-3\n struct defer {\n-    b: &mut bool,\n+    b: &'self mut bool,\n }\n \n-impl Drop for defer {\n+impl Drop for defer/&self {\n     fn finalize(&self) {\n         *(self.b) = true;\n     }\n }\n \n-fn defer(b: &r/mut bool) -> defer/&r {\n+fn defer(b: &'r mut bool) -> defer/&r {\n     defer {\n         b: b\n     }"}, {"sha": "75fc9f3a87e72c43a01c4e9c3bc25d8e6f72a0dd", "filename": "src/test/run-pass/issue-2735-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,16 +10,16 @@\n \n // This test should behave exactly like issue-2735-2\n struct defer {\n-    b: &mut bool,\n+    b: &'self mut bool,\n }\n \n-impl Drop for defer {\n+impl Drop for defer/&self {\n     fn finalize(&self) {\n         *(self.b) = true;\n     }\n }\n \n-fn defer(b: &r/mut bool) -> defer/&r {\n+fn defer(b: &'r mut bool) -> defer/&r {\n     defer {\n         b: b\n     }"}, {"sha": "f36b364aadda45deda26c65557a664c15c11bbac", "filename": "src/test/run-pass/issue-2748-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct CMap {\n-    buf: &[u8],\n+    buf: &'self [u8],\n }\n \n-fn CMap(buf: &r/[u8]) -> CMap/&r {\n+fn CMap(buf: &'r [u8]) -> CMap/&r {\n     CMap {\n         buf: buf\n     }"}, {"sha": "816678fa3208ea528794e1b92c17f910def88054", "filename": "src/test/run-pass/issue-3447.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-3447.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-3447.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3447.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n struct list<T> {\n-    element: &self/T,\n-    next: Option<@mut list<T>>\n+    element: &'self T,\n+    next: Option<@mut list<'self, T>>\n }\n \n-pub impl<T> list<T>{\n-    fn addEnd(&mut self, element: &self/T) {\n+pub impl<'self, T> list<'self, T>{\n+    fn addEnd(&mut self, element: &'self T) {\n         let newList = list {\n             element: element,\n             next: option::None"}, {"sha": "4d2862146555003f528ffc64b6e879580fd5f50b", "filename": "src/test/run-pass/issue-5243.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-5243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fissue-5243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5243.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that merely have lifetime parameters is not\n+// Check that merely having lifetime parameters is not\n // enough for trans to consider this as non-monomorphic,\n // which led to various assertions and failures in turn.\n \n struct S<'self> {\n     v: &'self int\n }\n \n-fn f<'lt>(_s: &S<'lt>) {}\n+fn f<'lt>(_s: &'lt S<'lt>) {}\n \n fn main() {\n     f(& S { v: &42 });"}, {"sha": "12e54c9c1918d90710b171c790a03ce87b620446", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -13,7 +13,7 @@ trait get {\n }\n \n // Note: impl on a slice\n-impl get for &int {\n+impl get for &'self int {\n     fn get() -> int {\n         return *self;\n     }"}, {"sha": "0091962dcf3aa635d4da0dfb93ff441821f89ad6", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -13,7 +13,7 @@ trait sum {\n }\n \n // Note: impl on a slice\n-impl sum for &[int] {\n+impl sum for &'self [int] {\n     fn sum() -> int {\n         let mut sum = 0;\n         for vec::each(self) |e| { sum += *e; }"}, {"sha": "dd040767f6b1b606ed72a46bcfd91a293920db1e", "filename": "src/test/run-pass/regions-copy-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct closure_box {\n-    cl: &fn(),\n+    cl: &'self fn(),\n }\n \n-fn box_it(+x: &r/fn()) -> closure_box/&r {\n+fn box_it(+x: &'r fn()) -> closure_box/&r {\n     closure_box {cl: x}\n }\n "}, {"sha": "c0bbdca07aafb7ceda81679e1376eee8efaa1bac", "filename": "src/test/run-pass/regions-creating-enums2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,10 +10,10 @@\n \n enum ast {\n     num(uint),\n-    add(&ast, &ast)\n+    add(&'self ast<'self>, &'self ast<'self>)\n }\n \n-fn mk_add_ok(x: &r/ast, y: &r/ast) -> ast/&r {\n+fn mk_add_ok(x: &'r ast<'r>, y: &'r ast<'r>) -> ast<'r> {\n     add(x, y)\n }\n "}, {"sha": "aeb167c5b6d18c6a72fd0f1a21882b9d01904792", "filename": "src/test/run-pass/regions-creating-enums5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -10,10 +10,10 @@\n \n enum ast {\n     num(uint),\n-    add(&ast, &ast)\n+    add(&'self ast<'self>, &'self ast<'self>)\n }\n \n-fn mk_add_ok(x: &a/ast, y: &a/ast, z: &ast) -> ast/&a {\n+fn mk_add_ok(x: &'a ast<'a>, y: &'a ast<'a>, z: &ast) -> ast<'a> {\n     add(x, y)\n }\n "}, {"sha": "ec5b30fa308548963e102e284160e4676c50f74e", "filename": "src/test/run-pass/regions-infer-contravariance-due-to-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct boxed_int {\n-    f: &int,\n+    f: &'self int,\n }\n \n fn max(bi: &r/boxed_int, f: &r/int) -> int {"}, {"sha": "1406240c1d1cd968284da98513a23f22b80e6850", "filename": "src/test/run-pass/regions-infer-contravariance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct boxed_int {\n-    f: &int,\n+    f: &'self int,\n }\n \n-fn get(bi: &r/boxed_int) -> &r/int {\n+fn get(bi: &'r boxed_int<'r>) -> &'r int {\n     bi.f\n }\n "}, {"sha": "df8a4f6f770b6543282a09942031a98bb474763e", "filename": "src/test/run-pass/regions-mock-trans-impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -17,19 +17,19 @@ use core::cast;\n use std::arena::Arena;\n \n struct Bcx {\n-    fcx: &Fcx\n+    fcx: &'self Fcx<'self>\n }\n \n struct Fcx {\n-    arena: &Arena,\n-    ccx: &Ccx\n+    arena: &'self Arena,\n+    ccx: &'self Ccx\n }\n \n struct Ccx {\n     x: int\n }\n \n-fn h(bcx : &r/Bcx) -> &r/Bcx {\n+fn h(bcx : &'r Bcx<'r>) -> &'r Bcx<'r> {\n     return bcx.fcx.arena.alloc(|| Bcx { fcx: bcx.fcx });\n }\n "}, {"sha": "7a1b9ae563aa59de3587cbc4e186fd95bc265031", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -11,26 +11,26 @@\n enum arena = ();\n \n struct Bcx {\n-    fcx: &Fcx\n+    fcx: &'self Fcx<'self>\n }\n \n struct Fcx {\n-    arena: &arena,\n-    ccx: &Ccx\n+    arena: &'self arena,\n+    ccx: &'self Ccx\n }\n \n struct Ccx {\n     x: int\n }\n \n-fn alloc(_bcx : &arena) -> &Bcx {   \n+fn alloc(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n         return cast::reinterpret_cast(\n             &libc::malloc(sys::size_of::<Bcx/&blk>() as libc::size_t));\n     }\n }\n \n-fn h(bcx : &Bcx) -> &Bcx {\n+fn h(bcx : &'a Bcx<'a>) -> &'a Bcx<'a> {\n     return alloc(bcx.fcx.arena);\n }\n "}, {"sha": "da03864338bdc9b6d0de6719f1b5b9113f2bbf51", "filename": "src/test/run-pass/regions-nullary-variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n enum roption {\n-    a, b(&uint)\n+    a, b(&'self uint)\n }\n \n-fn mk(cond: bool, ptr: &r/uint) -> roption/&r {\n+fn mk(cond: bool, ptr: &'r uint) -> roption<'r> {\n     if cond {a} else {b(ptr)}\n }\n "}, {"sha": "6f1044e305407939f6366790b36816c924c22528", "filename": "src/test/run-pass/regions-self-in-enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n enum int_wrapper {\n-    int_wrapper_ctor(&int)\n+    int_wrapper_ctor(&'self int)\n }\n \n pub fn main() {"}, {"sha": "0351f031e093756821227112308468bdfa32d1c6", "filename": "src/test/run-pass/regions-static-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct closure_box {\n-    cl: &fn(),\n+    cl: &'self fn(),\n }\n \n-fn box_it(+x: &r/fn()) -> closure_box/&r {\n+fn box_it(+x: &'r fn()) -> closure_box<'r> {\n     closure_box {cl: x}\n }\n "}, {"sha": "819499b3953317a2bed6967d5f32256c4f466f5b", "filename": "src/test/run-pass/regions-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-trait.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -14,9 +14,9 @@ trait get_ctxt {\n     fn get_ctxt() -> &self/Ctxt;\n }\n \n-struct HasCtxt { c: &Ctxt }\n+struct HasCtxt { c: &'self Ctxt }\n \n-impl get_ctxt for HasCtxt {\n+impl get_ctxt<'self> for HasCtxt<'self> {\n     fn get_ctxt() -> &self/Ctxt {\n         self.c\n     }"}, {"sha": "64f75e37051de6d0f488803741bc0ff8703d33f5", "filename": "src/test/run-pass/struct-field-assignability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fstruct-field-assignability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3728f839acd5bc1a3e1e110be832506777f746/src%2Ftest%2Frun-pass%2Fstruct-field-assignability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-field-assignability.rs?ref=8c3728f839acd5bc1a3e1e110be832506777f746", "patch": "@@ -1,5 +1,5 @@\n struct Foo {\n-    x: &int\n+    x: &'self int\n }\n \n pub fn main() {"}]}