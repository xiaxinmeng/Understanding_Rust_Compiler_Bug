{"sha": "41c36fabefbf20351a9c8263a17131e15b19d35a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYzM2ZmFiZWZiZjIwMzUxYTljODI2M2ExNzEzMWUxNWIxOWQzNWE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-30T11:05:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-30T11:05:05Z"}, "message": "light refactoring of global AllocMap\n\n* rename AllocKind -> GlobalAlloc. This stores the allocation itself, not just its kind.\n* rename the methods that allocate stuff to have consistent names.", "tree": {"sha": "e53c4624e5170180660eee7ff80c7edfd80b0e57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e53c4624e5170180660eee7ff80c7edfd80b0e57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41c36fabefbf20351a9c8263a17131e15b19d35a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41c36fabefbf20351a9c8263a17131e15b19d35a", "html_url": "https://github.com/rust-lang/rust/commit/41c36fabefbf20351a9c8263a17131e15b19d35a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41c36fabefbf20351a9c8263a17131e15b19d35a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c28084ac16af4ab594b6860958df140e7c876a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/c28084ac16af4ab594b6860958df140e7c876a13", "html_url": "https://github.com/rust-lang/rust/commit/c28084ac16af4ab594b6860958df140e7c876a13"}], "stats": {"total": 149, "additions": 81, "deletions": 68}, "files": [{"sha": "964d6c01d74ad282e39b20e92d55b0c4f140328b", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -72,20 +72,20 @@ pub fn specialized_encode_alloc_id<\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc_kind: AllocKind<'tcx> =\n+    let alloc: GlobalAlloc<'tcx> =\n         tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n-    match alloc_kind {\n-        AllocKind::Memory(alloc) => {\n+    match alloc {\n+        GlobalAlloc::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             AllocDiscriminant::Alloc.encode(encoder)?;\n             alloc.encode(encoder)?;\n         }\n-        AllocKind::Function(fn_instance) => {\n+        GlobalAlloc::Function(fn_instance) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n             AllocDiscriminant::Fn.encode(encoder)?;\n             fn_instance.encode(encoder)?;\n         }\n-        AllocKind::Static(did) => {\n+        GlobalAlloc::Static(did) => {\n             // referring to statics doesn't need to know about their allocations,\n             // just about its DefId\n             AllocDiscriminant::Static.encode(encoder)?;\n@@ -239,7 +239,7 @@ impl<'s> AllocDecodingSession<'s> {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc id at\");\n                     let did = DefId::decode(decoder)?;\n-                    let alloc_id = decoder.tcx().alloc_map.lock().intern_static(did);\n+                    let alloc_id = decoder.tcx().alloc_map.lock().create_static_alloc(did);\n                     Ok(alloc_id)\n                 }\n             }\n@@ -259,8 +259,10 @@ impl fmt::Display for AllocId {\n     }\n }\n \n+/// An allocation in the global (tcx-managed) memory can be either a function pointer,\n+/// a static, or a \"real\" allocation with some data in it.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub enum AllocKind<'tcx> {\n+pub enum GlobalAlloc<'tcx> {\n     /// The alloc ID is used as a function pointer\n     Function(Instance<'tcx>),\n     /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n@@ -272,10 +274,12 @@ pub enum AllocKind<'tcx> {\n \n pub struct AllocMap<'tcx> {\n     /// Lets you know what an `AllocId` refers to.\n-    id_to_kind: FxHashMap<AllocId, AllocKind<'tcx>>,\n+    alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,\n \n-    /// Used to ensure that statics only get one associated `AllocId`.\n-    type_interner: FxHashMap<AllocKind<'tcx>, AllocId>,\n+    /// Used to ensure that statics and functions only get one associated `AllocId`.\n+    /// Should never contain a `GlobalAlloc::Memory`!\n+    /// FIXME: Should we just have two separate dedup maps for statics and functions each?\n+    dedup: FxHashMap<GlobalAlloc<'tcx>, AllocId>,\n \n     /// The `AllocId` to assign to the next requested ID.\n     /// Always incremented, never gets smaller.\n@@ -285,8 +289,8 @@ pub struct AllocMap<'tcx> {\n impl<'tcx> AllocMap<'tcx> {\n     pub fn new() -> Self {\n         AllocMap {\n-            id_to_kind: Default::default(),\n-            type_interner: Default::default(),\n+            alloc_map: Default::default(),\n+            dedup: Default::default(),\n             next_id: AllocId(0),\n         }\n     }\n@@ -308,17 +312,32 @@ impl<'tcx> AllocMap<'tcx> {\n         next\n     }\n \n-    fn intern(&mut self, alloc_kind: AllocKind<'tcx>) -> AllocId {\n-        if let Some(&alloc_id) = self.type_interner.get(&alloc_kind) {\n+    /// Reserve a new ID *if* this allocation has not been dedup-reserved before.\n+    /// Should only be used for function pointers and statics, we don't want\n+    /// to dedup IDs for \"real\" memory!\n+    fn reserve_and_set_dedup(&mut self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+        match alloc {\n+            GlobalAlloc::Function(..) | GlobalAlloc::Static(..) => {},\n+            GlobalAlloc::Memory(..) => bug!(\"Trying to dedup-reserve memory with real data!\"),\n+        }\n+        if let Some(&alloc_id) = self.dedup.get(&alloc) {\n             return alloc_id;\n         }\n         let id = self.reserve();\n-        debug!(\"creating alloc_kind {:?} with id {}\", alloc_kind, id);\n-        self.id_to_kind.insert(id, alloc_kind.clone());\n-        self.type_interner.insert(alloc_kind, id);\n+        debug!(\"creating alloc {:?} with id {}\", alloc, id);\n+        self.alloc_map.insert(id, alloc.clone());\n+        self.dedup.insert(alloc, id);\n         id\n     }\n \n+    /// Generates an `AllocId` for a static or return a cached one in case this function has been\n+    /// called on the same static before.\n+    pub fn create_static_alloc(&mut self, static_id: DefId) -> AllocId {\n+        self.reserve_and_set_dedup(GlobalAlloc::Static(static_id))\n+    }\n+\n+    /// Generates an `AllocId` for a function.  Depending on the function type,\n+    /// this might get deduplicated or assigned a new ID each time.\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n         // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n         // by the linker (we set the \"unnamed_addr\" attribute for LLVM) and functions can be\n@@ -336,61 +355,55 @@ impl<'tcx> AllocMap<'tcx> {\n         if is_generic {\n             // Get a fresh ID\n             let id = self.reserve();\n-            self.id_to_kind.insert(id, AllocKind::Function(instance));\n+            self.alloc_map.insert(id, GlobalAlloc::Function(instance));\n             id\n         } else {\n             // Deduplicate\n-            self.intern(AllocKind::Function(instance))\n+            self.reserve_and_set_dedup(GlobalAlloc::Function(instance))\n         }\n     }\n \n+    /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n+    /// `Allocation` with a different `AllocId`.\n+    /// Statics with identical content will still point to the same `Allocation`, i.e.,\n+    /// their data will be deduplicated through `Allocation` interning -- but they\n+    /// are different places in memory and as such need different IDs.\n+    pub fn create_memory_alloc(&mut self, mem: &'tcx Allocation) -> AllocId {\n+        let id = self.reserve();\n+        self.set_alloc_id_memory(id, mem);\n+        id\n+    }\n+\n     /// Returns `None` in case the `AllocId` is dangling. An `InterpretCx` can still have a\n     /// local `Allocation` for that `AllocId`, but having such an `AllocId` in a constant is\n     /// illegal and will likely ICE.\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n     #[inline]\n-    pub fn get(&self, id: AllocId) -> Option<AllocKind<'tcx>> {\n-        self.id_to_kind.get(&id).cloned()\n+    pub fn get(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n+        self.alloc_map.get(&id).cloned()\n     }\n \n     /// Panics if the `AllocId` does not refer to an `Allocation`\n     pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n         match self.get(id) {\n-            Some(AllocKind::Memory(mem)) => mem,\n+            Some(GlobalAlloc::Memory(mem)) => mem,\n             _ => bug!(\"expected allocation id {} to point to memory\", id),\n         }\n     }\n \n-    /// Generates an `AllocId` for a static or return a cached one in case this function has been\n-    /// called on the same static before.\n-    pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n-        self.intern(AllocKind::Static(static_id))\n-    }\n-\n-    /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n-    /// `Allocation` with a different `AllocId`.\n-    // FIXME: is this really necessary? Can we ensure `FOO` and `BAR` being different after codegen\n-    // in `static FOO: u32 = 42; static BAR: u32 = 42;` even if they reuse the same allocation\n-    // inside rustc?\n-    pub fn allocate(&mut self, mem: &'tcx Allocation) -> AllocId {\n-        let id = self.reserve();\n-        self.set_alloc_id_memory(id, mem);\n-        id\n-    }\n-\n     /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        if let Some(old) = self.id_to_kind.insert(id, AllocKind::Memory(mem)) {\n+        if let Some(old) = self.alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n             bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n     fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        self.id_to_kind.insert_same(id, AllocKind::Memory(mem));\n+        self.alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n     }\n }\n "}, {"sha": "9a7184dc194cd719e3987b4ab1ce8d5e3a0f14a4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -1191,7 +1191,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // create an allocation that just contains these bytes\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes, ());\n         let alloc = self.intern_const_alloc(alloc);\n-        self.alloc_map.lock().allocate(alloc)\n+        self.alloc_map.lock().create_memory_alloc(alloc)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {"}, {"sha": "0b23aac5224c6c8531189aba42e0a741ff778c10", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -12,7 +12,7 @@ use rustc_codegen_ssa::traits::*;\n \n use crate::consts::const_alloc_to_llvm;\n use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n-use rustc::mir::interpret::{Scalar, AllocKind, Allocation};\n+use rustc::mir::interpret::{Scalar, GlobalAlloc, Allocation};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n use libc::{c_uint, c_char};\n@@ -310,18 +310,18 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             Scalar::Ptr(ptr) => {\n                 let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n                 let base_addr = match alloc_kind {\n-                    Some(AllocKind::Memory(alloc)) => {\n+                    Some(GlobalAlloc::Memory(alloc)) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         if alloc.mutability == Mutability::Mutable {\n                             self.static_addr_of_mut(init, alloc.align, None)\n                         } else {\n                             self.static_addr_of(init, alloc.align, None)\n                         }\n                     }\n-                    Some(AllocKind::Function(fn_instance)) => {\n+                    Some(GlobalAlloc::Function(fn_instance)) => {\n                         self.get_fn(fn_instance)\n                     }\n-                    Some(AllocKind::Static(def_id)) => {\n+                    Some(GlobalAlloc::Static(def_id)) => {\n                         assert!(self.tcx.is_static(def_id));\n                         self.get_static(def_id)\n                     }"}, {"sha": "3f53f992a5b71294db6329c71931e1089971bba4", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n                 let a = Scalar::from(Pointer::new(\n-                    bx.tcx().alloc_map.lock().allocate(data),\n+                    bx.tcx().alloc_map.lock().create_memory_alloc(data),\n                     Size::from_bytes(start as u64),\n                 )).into();\n                 let a_llval = bx.scalar_to_backend("}, {"sha": "e089b9a148feeeb5e1f734bcd2bbbfdb6a5f1fb4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -18,7 +18,7 @@ use syntax::ast::Mutability;\n \n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n-    EvalResult, Scalar, InterpError, AllocKind, PointerArithmetic,\n+    EvalResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, InboundsCheck,\n };\n \n@@ -193,12 +193,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             None => {\n                 // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(AllocKind::Function(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Function(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n-                    Some(AllocKind::Static(..)) |\n-                    Some(AllocKind::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Static(..)) |\n+                    Some(GlobalAlloc::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"static\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n@@ -313,15 +313,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let def_id = match alloc {\n-            Some(AllocKind::Memory(mem)) => {\n+            Some(GlobalAlloc::Memory(mem)) => {\n                 // We got tcx memory. Let the machine figure out whether and how to\n                 // turn that into memory with the right pointer tag.\n                 return Ok(M::adjust_static_allocation(mem, memory_extra))\n             }\n-            Some(AllocKind::Function(..)) => {\n+            Some(GlobalAlloc::Function(..)) => {\n                 return err!(DerefFunctionPointer)\n             }\n-            Some(AllocKind::Static(did)) => {\n+            Some(GlobalAlloc::Static(did)) => {\n                 did\n             }\n             None =>\n@@ -429,8 +429,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         // Could also be a fn ptr or extern static\n         match self.tcx.alloc_map.lock().get(id) {\n-            Some(AllocKind::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n-            Some(AllocKind::Static(did)) => {\n+            Some(GlobalAlloc::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n+            Some(GlobalAlloc::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n                 // Use size and align of the type\n@@ -456,7 +456,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n         match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-            Some(AllocKind::Function(instance)) => Ok(instance),\n+            Some(GlobalAlloc::Function(instance)) => Ok(instance),\n             _ => Err(InterpError::ExecuteMemory.into()),\n         }\n     }\n@@ -554,16 +554,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Err(()) => {\n                     // static alloc?\n                     match self.tcx.alloc_map.lock().get(id) {\n-                        Some(AllocKind::Memory(alloc)) => {\n+                        Some(GlobalAlloc::Memory(alloc)) => {\n                             self.dump_alloc_helper(\n                                 &mut allocs_seen, &mut allocs_to_print,\n                                 msg, alloc, \" (immutable)\".to_owned()\n                             );\n                         }\n-                        Some(AllocKind::Function(func)) => {\n+                        Some(GlobalAlloc::Function(func)) => {\n                             trace!(\"{} {}\", msg, func);\n                         }\n-                        Some(AllocKind::Static(did)) => {\n+                        Some(GlobalAlloc::Static(did)) => {\n                             trace!(\"{} {:?}\", msg, did);\n                         }\n                         None => {"}, {"sha": "764b5f38e4956fdfd877b0fedb145d350cd11ff2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -550,7 +550,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             ConstValue::Slice { data, start, end } =>\n                 Operand::Immediate(Immediate::ScalarPair(\n                     Scalar::from(Pointer::new(\n-                        self.tcx.alloc_map.lock().allocate(data),\n+                        self.tcx.alloc_map.lock().create_memory_alloc(data),\n                         Size::from_bytes(start as u64),\n                     )).with_default_tag().into(),\n                     Scalar::from_uint("}, {"sha": "faed52b74c8494eef4923fe32fc1f368cb5f782e", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -597,7 +597,7 @@ where\n                 // want!  This way, computing statics works concistently between codegen\n                 // and miri: They use the same query to eventually obtain a `ty::Const`\n                 // and use that for further computation.\n-                let alloc = self.tcx.alloc_map.lock().intern_static(cid.instance.def_id());\n+                let alloc = self.tcx.alloc_map.lock().create_static_alloc(cid.instance.def_id());\n                 MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n             }\n         })"}, {"sha": "4afadaa4b1982b73a31a129c3d2b2f26128076a6", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -8,7 +8,7 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocKind, EvalResult, InterpError, CheckInAllocMsg,\n+    Scalar, GlobalAlloc, EvalResult, InterpError, CheckInAllocMsg,\n };\n \n use super::{\n@@ -403,7 +403,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                             \"integer pointer in non-ZST reference\", self.path);\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                        if let Some(AllocKind::Static(did)) = alloc_kind {\n+                        if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                             // `extern static` cannot be validated as they have no body.\n                             // FIXME: Statics from other crates are also skipped.\n                             // They might be checked at a different type, but for now we"}, {"sha": "bd94e573c6f3f35d1f67ecbe89b555dab5f4043f", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c36fabefbf20351a9c8263a17131e15b19d35a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=41c36fabefbf20351a9c8263a17131e15b19d35a", "patch": "@@ -187,7 +187,7 @@ use rustc::session::config::EntryFnType;\n use rustc::mir::{self, Location, Place, PlaceBase, Promoted, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n-use rustc::mir::interpret::{Scalar, GlobalId, AllocKind, ErrorHandled};\n+use rustc::mir::interpret::{Scalar, GlobalId, GlobalAlloc, ErrorHandled};\n \n use crate::monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -1183,20 +1183,20 @@ fn collect_miri<'a, 'tcx>(\n ) {\n     let alloc_kind = tcx.alloc_map.lock().get(alloc_id);\n     match alloc_kind {\n-        Some(AllocKind::Static(did)) => {\n+        Some(GlobalAlloc::Static(did)) => {\n             let instance = Instance::mono(tcx, did);\n             if should_monomorphize_locally(tcx, &instance) {\n                 trace!(\"collecting static {:?}\", did);\n                 output.push(MonoItem::Static(did));\n             }\n         }\n-        Some(AllocKind::Memory(alloc)) => {\n+        Some(GlobalAlloc::Memory(alloc)) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n             for &((), inner) in alloc.relocations.values() {\n                 collect_miri(tcx, inner, output);\n             }\n         },\n-        Some(AllocKind::Function(fn_instance)) => {\n+        Some(GlobalAlloc::Function(fn_instance)) => {\n             if should_monomorphize_locally(tcx, &fn_instance) {\n                 trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n                 output.push(create_fn_mono_item(fn_instance));"}]}