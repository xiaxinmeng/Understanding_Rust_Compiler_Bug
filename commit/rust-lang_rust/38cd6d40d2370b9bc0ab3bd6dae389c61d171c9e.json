{"sha": "38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4Y2Q2ZDQwZDIzNzBiOWJjMGFiM2JkNmRhZTM4OWM2MWQxNzFjOWU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-17T15:05:30Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-10-01T15:02:42Z"}, "message": "share stored predicates\n\nwhile most of the duplication in predicates was caused by stubs,\nthis is still a 5% win on libcore.\n\n567924 liballoc-bb943c5a.rlib\n1425564 liballoc_jemalloc-bb943c5a.rlib\n10520 liballoc_system-bb943c5a.rlib\n154842 libarena-bb943c5a.rlib\n4113790 libcollections-bb943c5a.rlib\n18513674 libcore-bb943c5a.rlib\n199466 libflate-bb943c5a.rlib\n249548 libfmt_macros-bb943c5a.rlib\n560488 libgetopts-bb943c5a.rlib\n226772 libgraphviz-bb943c5a.rlib\n442966 liblibc-bb943c5a.rlib\n189884 liblog-bb943c5a.rlib\n736764 librand-bb943c5a.rlib\n609874 librbml-bb943c5a.rlib\n1411678 librustc_back-bb943c5a.rlib\n38770354 librustc-bb943c5a.rlib\n12868 librustc_bitflags-bb943c5a.rlib\n2327196 librustc_borrowck-bb943c5a.rlib\n582178 librustc_data_structures-bb943c5a.rlib\n9379344 librustc_driver-bb943c5a.rlib\n9540324 librustc_front-bb943c5a.rlib\n1614996 librustc_lint-bb943c5a.rlib\n79217876 librustc_llvm-bb943c5a.rlib\n4833518 librustc_mir-bb943c5a.rlib\n3535794 librustc_platform_intrinsics-bb943c5a.rlib\n603190 librustc_privacy-bb943c5a.rlib\n3158032 librustc_resolve-bb943c5a.rlib\n14300126 librustc_trans-bb943c5a.rlib\n12024054 librustc_typeck-bb943c5a.rlib\n1834852 librustc_unicode-bb943c5a.rlib\n15611582 librustdoc-bb943c5a.rlib\n2926594 libserialize-bb943c5a.rlib\n8780060 libstd-bb943c5a.rlib\n30772000 libsyntax-bb943c5a.rlib\n917984 libterm-bb943c5a.rlib\n1369754 libtest-bb943c5a.rlib", "tree": {"sha": "14a5ad6bb455808ec8f6526537e087273df7d0bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14a5ad6bb455808ec8f6526537e087273df7d0bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "html_url": "https://github.com/rust-lang/rust/commit/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d98165941d85de37007a0851d268c13169c3fa45", "url": "https://api.github.com/repos/rust-lang/rust/commits/d98165941d85de37007a0851d268c13169c3fa45", "html_url": "https://github.com/rust-lang/rust/commit/d98165941d85de37007a0851d268c13169c3fa45"}], "stats": {"total": 181, "additions": 115, "deletions": 66}, "files": [{"sha": "bf099a7e52c0645d251d8688d110c6b2a2bf5966", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "patch": "@@ -222,9 +222,9 @@ pub const tag_type_param_def: usize = 0x94;\n pub const tag_item_generics: usize = 0x95;\n pub const tag_method_ty_generics: usize = 0x96;\n \n-pub const tag_predicate: usize = 0x97;\n-pub const tag_predicate_space: usize = 0x98;\n-pub const tag_predicate_data: usize = 0x99;\n+pub const tag_type_predicate: usize = 0x97;\n+pub const tag_self_predicate: usize = 0x98;\n+pub const tag_fn_predicate: usize = 0x99;\n \n pub const tag_unsafety: usize = 0x9a;\n "}, {"sha": "565ec2414f41dbd82730ca01c54b2d57ac842645", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "patch": "@@ -1473,6 +1473,19 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n     ty::Generics { types: types, regions: regions }\n }\n \n+fn doc_predicate<'tcx>(cdata: Cmd,\n+                       doc: rbml::Doc,\n+                       tcx: &ty::ctxt<'tcx>)\n+                       -> ty::Predicate<'tcx>\n+{\n+    let predicate_pos = cdata.xref_index.lookup(\n+        cdata.data(), reader::doc_as_u32(doc)).unwrap() as usize;\n+    TyDecoder::new(\n+        cdata.data(), cdata.cnum, predicate_pos, tcx,\n+        &mut |_, did| translate_def_id(cdata, did)\n+    ).parse_predicate()\n+}\n+\n fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n                         tcx: &ty::ctxt<'tcx>,\n                         cdata: Cmd,\n@@ -1482,17 +1495,17 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n     let doc = reader::get_doc(base_doc, tag);\n \n     let mut predicates = subst::VecPerParamSpace::empty();\n-    for predicate_doc in reader::tagged_docs(doc, tag_predicate) {\n-        let space_doc = reader::get_doc(predicate_doc, tag_predicate_space);\n-        let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as usize);\n-\n-        let data_doc = reader::get_doc(predicate_doc, tag_predicate_data);\n-        let data =\n-            TyDecoder::with_doc(tcx, cdata.cnum, data_doc,\n-                                &mut |_, did| translate_def_id(cdata, did))\n-            .parse_predicate();\n-\n-        predicates.push(space, data);\n+    for predicate_doc in reader::tagged_docs(doc, tag_type_predicate) {\n+        predicates.push(subst::TypeSpace,\n+                        doc_predicate(cdata, predicate_doc, tcx));\n+    }\n+    for predicate_doc in reader::tagged_docs(doc, tag_self_predicate) {\n+        predicates.push(subst::SelfSpace,\n+                        doc_predicate(cdata, predicate_doc, tcx));\n+    }\n+    for predicate_doc in reader::tagged_docs(doc, tag_fn_predicate) {\n+        predicates.push(subst::FnSpace,\n+                        doc_predicate(cdata, predicate_doc, tcx));\n     }\n \n     ty::GenericPredicates { predicates: predicates }"}, {"sha": "fd10639fbc7a16ff60480e1cc42553ac16161ac0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 88, "deletions": 52, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "patch": "@@ -25,6 +25,7 @@ use middle::def;\n use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::dependency_format::Linkage;\n use middle::stability;\n+use middle::subst;\n use middle::ty::{self, Ty};\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n@@ -76,7 +77,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n \n /// \"interned\" entries referenced by id\n #[derive(PartialEq, Eq, Hash)]\n-pub enum XRef<'tcx> { Unused(&'tcx ()) }\n+pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n \n struct CrateIndex<'tcx> {\n     items: Vec<IndexEntry>,\n@@ -90,6 +91,11 @@ impl<'tcx> CrateIndex<'tcx> {\n             pos: rbml_w.mark_stable_position(),\n         });\n     }\n+\n+    fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n+        let old_len = self.xrefs.len() as u32;\n+        *self.xrefs.entry(xref).or_insert(old_len)\n+    }\n }\n \n fn encode_name(rbml_w: &mut Encoder, name: Name) {\n@@ -140,18 +146,22 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              ecx: &EncodeContext<'a, 'tcx>,\n+                                             index: &mut CrateIndex<'tcx>,\n                                              id: NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n+                           index,\n                            &ecx.tcx.lookup_item_type(DefId::local(id)),\n                            &ecx.tcx.lookup_predicates(DefId::local(id)));\n }\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     ecx: &EncodeContext<'a, 'tcx>,\n+                                    index: &mut CrateIndex<'tcx>,\n                                     scheme: &ty::TypeScheme<'tcx>,\n                                     predicates: &ty::GenericPredicates<'tcx>) {\n-    encode_generics(rbml_w, ecx, &scheme.generics, &predicates, tag_item_generics);\n+    encode_generics(rbml_w, ecx, index,\n+                    &scheme.generics, &predicates, tag_item_generics);\n     encode_type(ecx, rbml_w, scheme.ty);\n }\n \n@@ -327,7 +337,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_disr_val(ecx, rbml_w, specified_disr_val);\n             disr_val = specified_disr_val;\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, vid.node);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, vid.node);\n \n         ecx.tcx.map.with_path(vid.node, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n@@ -617,7 +627,7 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     debug!(\"encode_field: encoding {} {}\", nm, id);\n     encode_struct_field_family(rbml_w, field.vis);\n     encode_name(rbml_w, nm);\n-    encode_bounds_and_type_for_item(rbml_w, ecx, id);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n     encode_def_id(rbml_w, DefId::local(id));\n \n     let stab = stability::lookup(ecx.tcx, field.did);\n@@ -636,7 +646,7 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, DefId::local(ctor_id));\n     encode_family(rbml_w, 'o');\n-    encode_bounds_and_type_for_item(rbml_w, ecx, ctor_id);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index, ctor_id);\n     encode_name(rbml_w, name);\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n     encode_parent_item(rbml_w, DefId::local(struct_id));\n@@ -658,6 +668,7 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n+                             index: &mut CrateIndex<'tcx>,\n                              generics: &ty::Generics<'tcx>,\n                              predicates: &ty::GenericPredicates<'tcx>,\n                              tag: usize)\n@@ -702,51 +713,47 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n     }\n \n-    encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n+    encode_predicates_in_current_doc(rbml_w, ecx, index, predicates);\n \n     rbml_w.end_tag();\n }\n \n fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n-                                             ecx: &EncodeContext<'a,'tcx>,\n+                                             _ecx: &EncodeContext<'a,'tcx>,\n+                                             index: &mut CrateIndex<'tcx>,\n                                              predicates: &ty::GenericPredicates<'tcx>)\n {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-\n     for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n-        rbml_w.start_tag(tag_predicate);\n-\n-        rbml_w.wr_tagged_u8(tag_predicate_space, space as u8);\n-\n-        rbml_w.start_tag(tag_predicate_data);\n-        tyencode::enc_predicate(rbml_w, ty_str_ctxt, predicate);\n-        rbml_w.end_tag();\n+        let tag = match space {\n+            subst::TypeSpace => tag_type_predicate,\n+            subst::SelfSpace => tag_self_predicate,\n+            subst::FnSpace => tag_fn_predicate\n+        };\n \n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_u32(tag,\n+            index.add_xref(XRef::Predicate(predicate.clone())));\n     }\n }\n \n fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a,'tcx>,\n+                              index: &mut CrateIndex<'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>,\n                               tag: usize)\n {\n     rbml_w.start_tag(tag);\n-    encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n+    encode_predicates_in_current_doc(rbml_w, ecx, index, predicates);\n     rbml_w.end_tag();\n }\n \n fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                      rbml_w: &mut Encoder,\n+                                     index: &mut CrateIndex<'tcx>,\n                                      method_ty: &ty::Method<'tcx>) {\n     encode_def_id(rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n-    encode_generics(rbml_w, ecx, &method_ty.generics, &method_ty.predicates,\n+    encode_generics(rbml_w, ecx, index,\n+                    &method_ty.generics, &method_ty.predicates,\n                     tag_method_ty_generics);\n     encode_method_fty(ecx, rbml_w, &method_ty.fty);\n     encode_visibility(rbml_w, method_ty.vis);\n@@ -759,16 +766,18 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     }\n }\n \n-fn encode_info_for_associated_const(ecx: &EncodeContext,\n-                                    rbml_w: &mut Encoder,\n-                                    associated_const: &ty::AssociatedConst,\n-                                    impl_path: PathElems,\n-                                    parent_id: NodeId,\n-                                    impl_item_opt: Option<&hir::ImplItem>) {\n+fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                              rbml_w: &mut Encoder,\n+                                              index: &mut CrateIndex<'tcx>,\n+                                              associated_const: &ty::AssociatedConst,\n+                                              impl_path: PathElems,\n+                                              parent_id: NodeId,\n+                                              impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_const({:?},{:?})\",\n            associated_const.def_id,\n            associated_const.name);\n \n+    index.index_item(rbml_w, associated_const.def_id.node);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id(rbml_w, associated_const.def_id);\n@@ -779,7 +788,8 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n     encode_parent_item(rbml_w, DefId::local(parent_id));\n     encode_item_sort(rbml_w, 'C');\n \n-    encode_bounds_and_type_for_item(rbml_w, ecx, associated_const.def_id.local_id());\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n+                                    associated_const.def_id.local_id());\n \n     let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n     encode_stability(rbml_w, stab);\n@@ -797,6 +807,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n \n fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n+                                    index: &mut CrateIndex<'tcx>,\n                                     m: &ty::Method<'tcx>,\n                                     impl_path: PathElems,\n                                     is_default_impl: bool,\n@@ -805,17 +816,18 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            m.name);\n+    index.index_item(rbml_w, m.def_id.node);\n     rbml_w.start_tag(tag_items_data_item);\n \n-    encode_method_ty_fields(ecx, rbml_w, m);\n+    encode_method_ty_fields(ecx, rbml_w, index, m);\n     encode_parent_item(rbml_w, DefId::local(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n     let stab = stability::lookup(ecx.tcx, m.def_id);\n     encode_stability(rbml_w, stab);\n \n     // The type for methods gets encoded twice, which is unfortunate.\n-    encode_bounds_and_type_for_item(rbml_w, ecx, m.def_id.local_id());\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index, m.def_id.local_id());\n \n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n@@ -843,6 +855,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                              rbml_w: &mut Encoder,\n+                                             index: &mut CrateIndex<'tcx>,\n                                              associated_type: &ty::AssociatedType<'tcx>,\n                                              impl_path: PathElems,\n                                              parent_id: NodeId,\n@@ -851,6 +864,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n            associated_type.def_id,\n            associated_type.name);\n \n+    index.index_item(rbml_w, associated_type.def_id.node);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id(rbml_w, associated_type.def_id);\n@@ -869,7 +883,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n     } else {\n-        encode_predicates(rbml_w, ecx,\n+        encode_predicates(rbml_w, ecx, index,\n                           &ecx.tcx.lookup_predicates(associated_type.def_id),\n                           tag_item_generics);\n     }\n@@ -959,14 +973,31 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n     });\n }\n \n-fn encode_xrefs<'a, 'tcx>(_ecx: &EncodeContext<'a, 'tcx>,\n+fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n-                          _xrefs: FnvHashMap<XRef<'tcx>, u32>)\n+                          xrefs: FnvHashMap<XRef<'tcx>, u32>)\n {\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+\n+    let mut xref_positions = vec![0; xrefs.len()];\n     rbml_w.start_tag(tag_xref_data);\n+    for (xref, id) in xrefs.into_iter() {\n+        xref_positions[id as usize] = rbml_w.mark_stable_position() as u32;\n+        match xref {\n+            XRef::Predicate(p) => {\n+                tyencode::enc_predicate(rbml_w, ty_str_ctxt, &p)\n+            }\n+        }\n+    }\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_xref_index);\n+    index::write_dense_index(xref_positions, rbml_w.writer);\n     rbml_w.end_tag();\n }\n \n@@ -994,7 +1025,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         } else {\n             encode_family(rbml_w, 'c');\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_symbol(ecx, rbml_w, item.id);\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n@@ -1008,7 +1039,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n@@ -1023,7 +1054,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, FN_FAMILY);\n         let tps_len = generics.ty_params.len();\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n@@ -1073,7 +1104,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n@@ -1087,7 +1118,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 't');\n         encode_item_variances(rbml_w, ecx, item.id);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n@@ -1121,7 +1152,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'S');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.name);\n@@ -1178,7 +1209,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n@@ -1230,11 +1261,11 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                 None\n             };\n \n-            index.index_item(rbml_w, trait_item_def_id.def_id().node);\n             match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n                 ty::ConstTraitItem(ref associated_const) => {\n                     encode_info_for_associated_const(ecx,\n                                                      rbml_w,\n+                                                     index,\n                                                      &*associated_const,\n                                                      path.clone(),\n                                                      item.id,\n@@ -1243,6 +1274,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                 ty::MethodTraitItem(ref method_type) => {\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n+                                           index,\n                                            &**method_type,\n                                            path.clone(),\n                                            false,\n@@ -1252,6 +1284,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                 ty::TypeTraitItem(ref associated_type) => {\n                     encode_info_for_associated_type(ecx,\n                                                     rbml_w,\n+                                                    index,\n                                                     &**associated_type,\n                                                     path.clone(),\n                                                     item.id,\n@@ -1272,9 +1305,11 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n         encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n-        encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates,\n+        encode_generics(rbml_w, ecx, index,\n+                        &trait_def.generics, &trait_predicates,\n                         tag_item_generics);\n-        encode_predicates(rbml_w, ecx, &tcx.lookup_super_predicates(def_id),\n+        encode_predicates(rbml_w, ecx, index,\n+                          &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.name);\n@@ -1340,15 +1375,15 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n                     encode_family(rbml_w, 'C');\n \n-                    encode_bounds_and_type_for_item(rbml_w, ecx,\n+                    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n                                                     associated_const.def_id.local_id());\n \n                     is_nonstatic_method = false;\n                 }\n                 ty::MethodTraitItem(method_ty) => {\n                     let method_def_id = item_def_id.def_id();\n \n-                    encode_method_ty_fields(ecx, rbml_w, &*method_ty);\n+                    encode_method_ty_fields(ecx, rbml_w, index, &*method_ty);\n \n                     let elem = ast_map::PathName(method_ty.name);\n                     encode_path(rbml_w,\n@@ -1364,7 +1399,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                           METHOD_FAMILY);\n                         }\n                     }\n-                    encode_bounds_and_type_for_item(rbml_w, ecx, method_def_id.local_id());\n+                    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n+                                                    method_def_id.local_id());\n \n                     is_nonstatic_method = method_ty.explicit_self !=\n                         ty::StaticExplicitSelfCategory;\n@@ -1407,7 +1443,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                     if is_nonstatic_method {\n                         // FIXME: I feel like there is something funny\n                         // going on.\n-                        encode_bounds_and_type_for_item(rbml_w, ecx,\n+                        encode_bounds_and_type_for_item(rbml_w, ecx, index,\n                             item_def_id.def_id().local_id());\n                     }\n \n@@ -1446,7 +1482,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_name(rbml_w, nitem.name);\n         if abi == abi::RustIntrinsic || abi == abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n@@ -1463,7 +1499,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         } else {\n             encode_family(rbml_w, 'c');\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_attributes(rbml_w, &*nitem.attrs);\n         let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n         encode_stability(rbml_w, stab);"}]}