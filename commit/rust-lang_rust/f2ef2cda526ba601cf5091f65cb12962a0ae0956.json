{"sha": "f2ef2cda526ba601cf5091f65cb12962a0ae0956", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZWYyY2RhNTI2YmE2MDFjZjUwOTFmNjVjYjEyOTYyYTBhZTA5NTY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-15T03:46:59Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-19T15:43:24Z"}, "message": "libregex: use `#[deriving(Copy)]`", "tree": {"sha": "020d5860f63056176f6749edcb999e9a1559ddfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/020d5860f63056176f6749edcb999e9a1559ddfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2ef2cda526ba601cf5091f65cb12962a0ae0956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2ef2cda526ba601cf5091f65cb12962a0ae0956", "html_url": "https://github.com/rust-lang/rust/commit/f2ef2cda526ba601cf5091f65cb12962a0ae0956", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2ef2cda526ba601cf5091f65cb12962a0ae0956/comments", "author": null, "committer": null, "parents": [{"sha": "fd4a5d9ef12a87cad61f2fa5dd0a011df263a2d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd4a5d9ef12a87cad61f2fa5dd0a011df263a2d0", "html_url": "https://github.com/rust-lang/rust/commit/fd4a5d9ef12a87cad61f2fa5dd0a011df263a2d0"}], "stats": {"total": 13, "additions": 4, "deletions": 9}, "files": [{"sha": "78558a322665db29cdc12cb1ac40d19ddbdf5b94", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2ef2cda526ba601cf5091f65cb12962a0ae0956/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2ef2cda526ba601cf5091f65cb12962a0ae0956/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=f2ef2cda526ba601cf5091f65cb12962a0ae0956", "patch": "@@ -77,14 +77,12 @@ pub enum Repeater {\n     OneMore,\n }\n \n-#[deriving(Show, Clone)]\n+#[deriving(Copy, Show, Clone)]\n pub enum Greed {\n     Greedy,\n     Ungreedy,\n }\n \n-impl Copy for Greed {}\n-\n impl Greed {\n     pub fn is_greedy(&self) -> bool {\n         match *self {"}, {"sha": "151587e423abb7ec6272d6bd0eca3c1328947574", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2ef2cda526ba601cf5091f65cb12962a0ae0956/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2ef2cda526ba601cf5091f65cb12962a0ae0956/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=f2ef2cda526ba601cf5091f65cb12962a0ae0956", "patch": "@@ -126,6 +126,7 @@ pub struct ExDynamic {\n }\n \n #[doc(hidden)]\n+#[deriving(Copy)]\n pub struct ExNative {\n     #[doc(hidden)]\n     pub original: &'static str,\n@@ -135,8 +136,6 @@ pub struct ExNative {\n     pub prog: fn(MatchKind, &str, uint, uint) -> Vec<Option<uint>>\n }\n \n-impl Copy for ExNative {}\n-\n impl Clone for ExNative {\n     fn clone(&self) -> ExNative {\n         *self"}, {"sha": "990d5a159f60d879216efd4df4350d6a6b77b1b3", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2ef2cda526ba601cf5091f65cb12962a0ae0956/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2ef2cda526ba601cf5091f65cb12962a0ae0956/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=f2ef2cda526ba601cf5091f65cb12962a0ae0956", "patch": "@@ -50,6 +50,7 @@ use unicode::regex::PERLW;\n pub type CaptureLocs = Vec<Option<uint>>;\n \n /// Indicates the type of match to be performed by the VM.\n+#[deriving(Copy)]\n pub enum MatchKind {\n     /// Only checks if a match exists or not. Does not return location.\n     Exists,\n@@ -60,8 +61,6 @@ pub enum MatchKind {\n     Submatches,\n }\n \n-impl Copy for MatchKind {}\n-\n /// Runs an NFA simulation on the compiled expression given on the search text\n /// `input`. The search begins at byte index `start` and ends at byte index\n /// `end`. (The range is specified here so that zero-width assertions will work\n@@ -96,6 +95,7 @@ struct Nfa<'r, 't> {\n \n /// Indicates the next action to take after a single non-empty instruction\n /// is processed.\n+#[deriving(Copy)]\n pub enum StepState {\n     /// This is returned if and only if a Match instruction is reached and\n     /// we only care about the existence of a match. It instructs the VM to\n@@ -109,8 +109,6 @@ pub enum StepState {\n     StepContinue,\n }\n \n-impl Copy for StepState {}\n-\n impl<'r, 't> Nfa<'r, 't> {\n     fn run(&mut self) -> CaptureLocs {\n         let ncaps = match self.which {"}]}