{"sha": "02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYWRhY2E0ZGM3ZWI0NTk0ZDhiZGE5YTdlMDRiYzAyNDdmYzJhNzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-29T05:26:56Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-18T16:01:37Z"}, "message": "librustc: Implement unboxed closures with mutable receivers", "tree": {"sha": "2edb47de67e3c8a0d006f61217d7dffaab824b27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2edb47de67e3c8a0d006f61217d7dffaab824b27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "html_url": "https://github.com/rust-lang/rust/commit/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ddc7b4a252fbebee5f2ac87ed755139816d6823", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ddc7b4a252fbebee5f2ac87ed755139816d6823", "html_url": "https://github.com/rust-lang/rust/commit/5ddc7b4a252fbebee5f2ac87ed755139816d6823"}], "stats": {"total": 2289, "additions": 1905, "deletions": 384}, "files": [{"sha": "8a1962c2bbd79decd5edf7a1dfd693a6bdc0eb9a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -749,19 +749,23 @@ pub trait DerefMut<Result>: Deref<Result> {\n #[lang=\"fn\"]\n pub trait Fn<Args,Result> {\n     /// This is called when the call operator is used.\n+    #[rust_call_abi_hack]\n     fn call(&self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n pub trait FnMut<Args,Result> {\n     /// This is called when the call operator is used.\n+    #[rust_call_abi_hack]\n     fn call_mut(&mut self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used.\n+    #[rust_call_abi_hack]\n     fn call_once(self, args: Args) -> Result;\n }\n+"}, {"sha": "d27689eeaf4176d445441c861450e667b175ce30", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -35,6 +35,7 @@ pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop, Deref, DerefMut};\n pub use ops::{Shl, Shr};\n pub use ops::{Index, IndexMut};\n+pub use ops::{Fn, FnMut, FnOnce};\n pub use option::{Option, Some, None};\n pub use result::{Result, Ok, Err};\n "}, {"sha": "9f15c9a9b3fa0dd1d6d3c9a9fe82d2d0d2a75627", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -67,6 +67,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"quad_precision_float\", Removed),\n \n     (\"rustc_diagnostic_macros\", Active),\n+    (\"unboxed_closures\", Active),\n \n     // A temporary feature gate used to enable parser extensions needed\n     // to bootstrap fix for #5723.\n@@ -327,6 +328,12 @@ impl<'a> Visitor<()> for Context<'a> {\n             ast::ExprUnary(ast::UnBox, _) => {\n                 self.gate_box(e.span);\n             }\n+            ast::ExprUnboxedFn(..) => {\n+                self.gate_feature(\"unboxed_closures\",\n+                                  e.span,\n+                                  \"unboxed closures are a work-in-progress \\\n+                                   feature with known bugs\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e, ());"}, {"sha": "3f4f51236997191403f8add494035fcf0a408d68", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -1451,6 +1451,9 @@ impl LintPass for Stability {\n                             typeck::MethodStatic(def_id) => {\n                                 def_id\n                             }\n+                            typeck::MethodStaticUnboxedClosure(def_id) => {\n+                                def_id\n+                            }\n                             typeck::MethodParam(typeck::MethodParam {\n                                 trait_id: trait_id,\n                                 method_num: index,"}, {"sha": "216a575f2fb2b30e1c35adf917bbb3849b3c1f83", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -138,10 +138,11 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_vtable_map = 0x50,\n     tag_table_adjustments = 0x51,\n     tag_table_moves_map = 0x52,\n-    tag_table_capture_map = 0x53\n+    tag_table_capture_map = 0x53,\n+    tag_table_unboxed_closure_type = 0x54,\n }\n static first_astencode_tag: uint = tag_ast as uint;\n-static last_astencode_tag: uint = tag_table_capture_map as uint;\n+static last_astencode_tag: uint = tag_table_unboxed_closure_type as uint;\n impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n@@ -155,6 +156,10 @@ pub static tag_item_trait_method_sort: uint = 0x60;\n \n pub static tag_item_impl_type_basename: uint = 0x61;\n \n+pub static tag_crate_triple: uint = 0x66;\n+\n+pub static tag_dylib_dependency_formats: uint = 0x67;\n+\n // Language items are a top-level directory (for speed). Hierarchy:\n //\n // tag_lang_items\n@@ -199,10 +204,6 @@ pub static tag_plugin_registrar_fn: uint = 0x8b;\n pub static tag_exported_macros: uint = 0x8c;\n pub static tag_macro_def: uint = 0x8d;\n \n-pub static tag_crate_triple: uint = 0x66;\n-\n-pub static tag_dylib_dependency_formats: uint = 0x67;\n-\n pub static tag_method_argument_names: uint = 0x8e;\n pub static tag_method_argument_name: uint = 0x8f;\n \n@@ -211,7 +212,6 @@ pub static tag_reachable_extern_fn_id: uint = 0x91;\n \n pub static tag_items_data_item_stability: uint = 0x92;\n \n-\n #[deriving(Clone, Show)]\n pub struct LinkMeta {\n     pub crate_name: String,\n@@ -223,3 +223,7 @@ pub static tag_region_param_def_ident: uint = 0x91;\n pub static tag_region_param_def_def_id: uint = 0x92;\n pub static tag_region_param_def_space: uint = 0x93;\n pub static tag_region_param_def_index: uint = 0x94;\n+\n+pub static tag_unboxed_closures: uint = 0x95;\n+pub static tag_unboxed_closure: uint = 0x96;\n+pub static tag_unboxed_closure_type: uint = 0x97;"}, {"sha": "b86f5ee6cc2bc8fc6a9f146f302a82c0801bd95f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -209,6 +209,18 @@ fn encode_variant_id(ebml_w: &mut Encoder, vid: DefId) {\n     ebml_w.end_tag();\n }\n \n+pub fn write_closure_type(ecx: &EncodeContext,\n+                          ebml_w: &mut Encoder,\n+                          closure_type: &ty::ClosureTy) {\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+    tyencode::enc_closure_ty(ebml_w.writer, ty_str_ctxt, closure_type);\n+}\n+\n pub fn write_type(ecx: &EncodeContext,\n                   ebml_w: &mut Encoder,\n                   typ: ty::t) {\n@@ -1618,6 +1630,26 @@ fn encode_macro_defs(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n+fn encode_unboxed_closures<'a>(\n+                           ecx: &'a EncodeContext,\n+                           ebml_w: &'a mut Encoder) {\n+    ebml_w.start_tag(tag_unboxed_closures);\n+    for (unboxed_closure_id, unboxed_closure_type) in\n+            ecx.tcx.unboxed_closure_types.borrow().iter() {\n+        if unboxed_closure_id.krate != LOCAL_CRATE {\n+            continue\n+        }\n+\n+        ebml_w.start_tag(tag_unboxed_closure);\n+        encode_def_id(ebml_w, *unboxed_closure_id);\n+        ebml_w.start_tag(tag_unboxed_closure_type);\n+        write_closure_type(ecx, ebml_w, unboxed_closure_type);\n+        ebml_w.end_tag();\n+        ebml_w.end_tag();\n+    }\n+    ebml_w.end_tag();\n+}\n+\n struct ImplVisitor<'a,'b,'c> {\n     ecx: &'a EncodeContext<'b>,\n     ebml_w: &'a mut Encoder<'c>,\n@@ -1787,6 +1819,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         native_lib_bytes: u64,\n         plugin_registrar_fn_bytes: u64,\n         macro_defs_bytes: u64,\n+        unboxed_closure_bytes: u64,\n         impl_bytes: u64,\n         misc_bytes: u64,\n         item_bytes: u64,\n@@ -1801,6 +1834,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         native_lib_bytes: 0,\n         plugin_registrar_fn_bytes: 0,\n         macro_defs_bytes: 0,\n+        unboxed_closure_bytes: 0,\n         impl_bytes: 0,\n         misc_bytes: 0,\n         item_bytes: 0,\n@@ -1873,6 +1907,11 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     encode_macro_defs(&ecx, krate, &mut ebml_w);\n     stats.macro_defs_bytes = ebml_w.writer.tell().unwrap() - i;\n \n+    // Encode the types of all unboxed closures in this crate.\n+    i = ebml_w.writer.tell().unwrap();\n+    encode_unboxed_closures(&ecx, &mut ebml_w);\n+    stats.unboxed_closure_bytes = ebml_w.writer.tell().unwrap() - i;\n+\n     // Encode the def IDs of impls, for coherence checking.\n     i = ebml_w.writer.tell().unwrap();\n     encode_impls(&ecx, krate, &mut ebml_w);\n@@ -1911,6 +1950,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         println!(\"          native bytes: {}\", stats.native_lib_bytes);\n         println!(\"plugin registrar bytes: {}\", stats.plugin_registrar_fn_bytes);\n         println!(\"       macro def bytes: {}\", stats.macro_defs_bytes);\n+        println!(\" unboxed closure bytes: {}\", stats.unboxed_closure_bytes);\n         println!(\"            impl bytes: {}\", stats.impl_bytes);\n         println!(\"            misc bytes: {}\", stats.misc_bytes);\n         println!(\"            item bytes: {}\", stats.item_bytes);"}, {"sha": "ffa0cca753904b9911c614781ec931717eb1257e", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -130,6 +130,16 @@ fn data_log_string(data: &[u8], pos: uint) -> String {\n     buf\n }\n \n+pub fn parse_ty_closure_data(data: &[u8],\n+                             crate_num: ast::CrateNum,\n+                             pos: uint,\n+                             tcx: &ty::ctxt,\n+                             conv: conv_did)\n+                             -> ty::ClosureTy {\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_closure_ty(&mut st, conv)\n+}\n+\n pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                      conv: conv_did) -> ty::t {\n     debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n@@ -420,6 +430,10 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n+      'k' => {\n+          let did = parse_def(st, NominalType, |x,y| conv(x,y));\n+          return ty::mk_unboxed_closure(st.tcx, did);\n+      }\n       'e' => {\n           return ty::mk_err();\n       }\n@@ -502,12 +516,14 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let store = parse_trait_store(st, |x,y| conv(x,y));\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let sig = parse_sig(st, |x,y| conv(x,y));\n+    let abi = parse_abi_set(st);\n     ty::ClosureTy {\n         fn_style: fn_style,\n         onceness: onceness,\n         store: store,\n         bounds: bounds.builtin_bounds,\n-        sig: sig\n+        sig: sig,\n+        abi: abi,\n     }\n }\n "}, {"sha": "15e4e85ddb7114323b884f90f3c4bf057642330a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -284,6 +284,9 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n+        ty::ty_unboxed_closure(def) => {\n+            mywrite!(w, \"k{}\", (cx.ds)(def));\n+        }\n         ty::ty_err => {\n             mywrite!(w, \"e\");\n         }\n@@ -316,14 +319,15 @@ pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_closure_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n+pub fn enc_closure_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n     enc_fn_style(w, ft.fn_style);\n     enc_onceness(w, ft.onceness);\n     enc_trait_store(w, cx, ft.store);\n     let bounds = ty::ParamBounds {builtin_bounds: ft.bounds,\n                                   trait_bounds: Vec::new()};\n     enc_bounds(w, cx, &bounds);\n     enc_fn_sig(w, cx, &ft.sig);\n+    enc_abi(w, ft.abi);\n }\n \n fn enc_fn_sig(w: &mut MemWriter, cx: &ctxt, fsig: &ty::FnSig) {"}, {"sha": "722715405bce4ec08c06e69f070ac309f712f1ba", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -609,6 +609,9 @@ impl tr for MethodOrigin {\n     fn tr(&self, xcx: &ExtendedDecodeContext) -> MethodOrigin {\n         match *self {\n             typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(xcx)),\n+            typeck::MethodStaticUnboxedClosure(did) => {\n+                typeck::MethodStaticUnboxedClosure(did.tr(xcx))\n+            }\n             typeck::MethodParam(ref mp) => {\n                 typeck::MethodParam(\n                     typeck::MethodParam {\n@@ -696,8 +699,18 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                 })\n             })\n           }\n+          typeck::vtable_unboxed_closure(def_id) => {\n+              ebml_w.emit_enum_variant(\"vtable_unboxed_closure\",\n+                                       2u,\n+                                       1u,\n+                                       |ebml_w| {\n+                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n+                    Ok(ebml_w.emit_def_id(def_id))\n+                })\n+              })\n+          }\n           typeck::vtable_error => {\n-            ebml_w.emit_enum_variant(\"vtable_error\", 2u, 3u, |_ebml_w| {\n+            ebml_w.emit_enum_variant(\"vtable_error\", 3u, 3u, |_ebml_w| {\n                 Ok(())\n             })\n           }\n@@ -771,7 +784,8 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n         self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant([\"vtable_static\",\n                                     \"vtable_param\",\n-                                    \"vtable_error\"],\n+                                    \"vtable_error\",\n+                                    \"vtable_unboxed_closure\"],\n                                    |this, i| {\n                 Ok(match i {\n                   0 => {\n@@ -798,6 +812,13 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                     )\n                   }\n                   2 => {\n+                    typeck::vtable_unboxed_closure(\n+                        this.read_enum_variant_arg(0u, |this| {\n+                            Ok(this.read_def_id_noxcx(cdata))\n+                        }).unwrap()\n+                    )\n+                  }\n+                  3 => {\n                     typeck::vtable_error\n                   }\n                   _ => fail!(\"bad enum variant\")\n@@ -838,6 +859,9 @@ impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n }\n \n trait ebml_writer_helpers {\n+    fn emit_closure_type(&mut self,\n+                         ecx: &e::EncodeContext,\n+                         closure_type: &ty::ClosureTy);\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t);\n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]);\n     fn emit_type_param_def(&mut self,\n@@ -851,6 +875,14 @@ trait ebml_writer_helpers {\n }\n \n impl<'a> ebml_writer_helpers for Encoder<'a> {\n+    fn emit_closure_type(&mut self,\n+                         ecx: &e::EncodeContext,\n+                         closure_type: &ty::ClosureTy) {\n+        self.emit_opaque(|this| {\n+            Ok(e::write_closure_type(ecx, this, closure_type))\n+        });\n+    }\n+\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n@@ -1127,6 +1159,18 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             })\n         })\n     }\n+\n+    for unboxed_closure_type in tcx.unboxed_closure_types\n+                                   .borrow()\n+                                   .find(&ast_util::local_def(id))\n+                                   .iter() {\n+        ebml_w.tag(c::tag_table_unboxed_closure_type, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_closure_type(ecx, *unboxed_closure_type)\n+            })\n+        })\n+    }\n }\n \n trait doc_decoder_helpers {\n@@ -1150,6 +1194,8 @@ trait ebml_decoder_decoder_helpers {\n                      -> ty::Polytype;\n     fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs;\n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n+    fn read_unboxed_closure_type(&mut self, xcx: &ExtendedDecodeContext)\n+                                 -> ty::ClosureTy;\n     fn convert_def_id(&mut self,\n                       xcx: &ExtendedDecodeContext,\n                       source: DefIdSource,\n@@ -1322,6 +1368,18 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n+    fn read_unboxed_closure_type(&mut self, xcx: &ExtendedDecodeContext)\n+                                 -> ty::ClosureTy {\n+        self.read_opaque(|this, doc| {\n+            Ok(tydecode::parse_ty_closure_data(\n+                doc.data,\n+                xcx.dcx.cdata.cnum,\n+                doc.start,\n+                xcx.dcx.tcx,\n+                |s, a| this.convert_def_id(xcx, s, a)))\n+        }).unwrap()\n+    }\n+\n     fn convert_def_id(&mut self,\n                       xcx: &ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n@@ -1442,6 +1500,15 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(xcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n+                    c::tag_table_unboxed_closure_type => {\n+                        let unboxed_closure_type =\n+                            val_dsr.read_unboxed_closure_type(xcx);\n+                        dcx.tcx\n+                           .unboxed_closure_types\n+                           .borrow_mut()\n+                           .insert(ast_util::local_def(id),\n+                                   unboxed_closure_type);\n+                    }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug(\n                             format!(\"unknown tag found in side tables: {:x}\","}, {"sha": "fecd40dae016a441978c4365e186422f978f0b3f", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -832,3 +832,4 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.loan_path_to_string(loan_path)).as_slice());\n     }\n }\n+"}, {"sha": "208a9d057166eeb76b100428c518c6636d8d0c31", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -446,6 +446,7 @@ impl<'a> CFGBuilder<'a> {\n             ast::ExprMac(..) |\n             ast::ExprFnBlock(..) |\n             ast::ExprProc(..) |\n+            ast::ExprUnboxedFn(..) |\n             ast::ExprLit(..) |\n             ast::ExprPath(..) => {\n                 self.straightline(expr, pred, [])"}, {"sha": "ac8faaa6c6db5266ed57968b61e8ce9731d5c8cf", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -42,7 +42,9 @@ impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n             ast::ExprLoop(ref b, _) => {\n                 self.visit_block(&**b, Loop);\n             }\n-            ast::ExprFnBlock(_, ref b) | ast::ExprProc(_, ref b) => {\n+            ast::ExprFnBlock(_, ref b) |\n+            ast::ExprProc(_, ref b) |\n+            ast::ExprUnboxedFn(_, ref b) => {\n                 self.visit_block(&**b, Closure);\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", cx, e.span),"}, {"sha": "9fc589ddf59eb3a5ba8aa8e5aa567d2439596b2d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -104,6 +104,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n                             None => self.check_def_id(def_id)\n                         }\n                     }\n+                    typeck::MethodStaticUnboxedClosure(_) => {}\n                     typeck::MethodParam(typeck::MethodParam {\n                         trait_id: trait_id,\n                         method_num: index,"}, {"sha": "b911e636da0917176a4569e39eae63946f499e94", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -20,7 +20,7 @@ use middle::freevars;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck::{MethodCall, MethodObject, MethodOrigin, MethodParam};\n-use middle::typeck::{MethodStatic};\n+use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure};\n use middle::typeck;\n use util::ppaux::Repr;\n \n@@ -160,6 +160,9 @@ impl OverloadedCallType {\n             MethodStatic(def_id) => {\n                 OverloadedCallType::from_method_id(tcx, def_id)\n             }\n+            MethodStaticUnboxedClosure(def_id) => {\n+                OverloadedCallType::from_method_id(tcx, def_id)\n+            }\n             MethodParam(ref method_param) => {\n                 OverloadedCallType::from_trait_id(tcx, method_param.trait_id)\n             }\n@@ -439,6 +442,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n             }\n \n             ast::ExprFnBlock(..) |\n+            ast::ExprUnboxedFn(..) |\n             ast::ExprProc(..) => {\n                 self.walk_captures(expr)\n             }"}, {"sha": "f6887718ec1379f8fffdbf3f7c670d84b12d3184", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -16,7 +16,7 @@\n use middle::def;\n use middle::resolve;\n use middle::ty;\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{DefIdSet, NodeMap, NodeSet};\n \n use syntax::codemap::Span;\n use syntax::{ast};\n@@ -39,8 +39,11 @@ pub struct freevar_entry {\n     pub def: def::Def, //< The variable being accessed free.\n     pub span: Span     //< First span where it is accessed (there can be multiple)\n }\n+\n pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n \n+pub type UnboxedClosureList = DefIdSet;\n+\n struct CollectFreevarsVisitor<'a> {\n     seen: NodeSet,\n     refs: Vec<freevar_entry>,\n@@ -54,7 +57,8 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, depth: int) {\n         match expr.node {\n-            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n+            ast::ExprFnBlock(..) | ast::ExprProc(..) |\n+            ast::ExprUnboxedFn(..) => {\n                 visit::walk_expr(self, expr, depth + 1)\n             }\n             ast::ExprPath(..) => {\n@@ -125,8 +129,8 @@ impl<'a> Visitor<()> for AnnotateFreevarsVisitor<'a> {\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate) ->\n-   freevar_map {\n+pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate)\n+                         -> freevar_map {\n     let mut visitor = AnnotateFreevarsVisitor {\n         def_map: def_map,\n         freevars: NodeMap::new(),"}, {"sha": "a45bb69a53ee1da04dfc46fba957807680dbf818", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -216,6 +216,9 @@ fn with_appropriate_checker(cx: &Context,\n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n         }\n+\n+        ty::ty_unboxed_closure(_) => {}\n+\n         ref s => {\n             cx.tcx.sess.bug(format!(\"expect fn type in kind checker, not \\\n                                      {:?}\",\n@@ -321,7 +324,9 @@ fn check_bounds_on_type_parameters(cx: &mut Context, e: &Expr) {\n         Some(method) => {\n             let is_object_call = match method.origin {\n                 typeck::MethodObject(..) => true,\n-                typeck::MethodStatic(..) | typeck::MethodParam(..) => false\n+                typeck::MethodStatic(..) |\n+                typeck::MethodStaticUnboxedClosure(..) |\n+                typeck::MethodParam(..) => false\n             };\n             (&method.substs.types, is_object_call)\n         }"}, {"sha": "737b952151b67058d577cb6544dadc56841e3edf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -448,7 +448,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         }\n         visit::walk_expr(ir, expr, ());\n       }\n-      ExprFnBlock(..) | ExprProc(..) => {\n+      ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -941,8 +941,11 @@ impl<'a> Liveness<'a> {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprFnBlock(_, ref blk) | ExprProc(_, ref blk) => {\n-              debug!(\"{} is an ExprFnBlock or ExprProc\", expr_to_string(expr));\n+          ExprFnBlock(_, ref blk) |\n+          ExprProc(_, ref blk) |\n+          ExprUnboxedFn(_, ref blk) => {\n+              debug!(\"{} is an ExprFnBlock, ExprProc, or ExprUnboxedFn\",\n+                     expr_to_string(expr));\n \n               /*\n               The next-node for a break is the successor of the entire\n@@ -1411,8 +1414,8 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n       ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n-      ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprPath(..) |\n-      ExprBox(..) => {\n+      ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) |\n+      ExprPath(..) | ExprBox(..) => {\n         visit::walk_expr(this, expr, ());\n       }\n       ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")"}, {"sha": "baf7f2dd77650e5da41190bd833704efaf27c2ae", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -473,7 +473,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n-          ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprRet(..) |\n+          ast::ExprFnBlock(..) | ast::ExprProc(..) |\n+          ast::ExprUnboxedFn(..) | ast::ExprRet(..) |\n           ast::ExprUnary(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) | ast::ExprVstore(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n@@ -578,6 +579,20 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                           }))\n                       }\n                   }\n+                  ty::ty_unboxed_closure(_) => {\n+                      // FIXME #2152 allow mutation of moved upvars\n+                      Ok(Rc::new(cmt_ {\n+                          id: id,\n+                          span: span,\n+                          cat: cat_copied_upvar(CopiedUpvar {\n+                              upvar_id: var_id,\n+                              onceness: ast::Many,\n+                              capturing_proc: fn_node_id,\n+                          }),\n+                          mutbl: McImmutable,\n+                          ty: expr_ty\n+                      }))\n+                  }\n                   _ => {\n                       self.tcx().sess.span_bug(\n                           span,"}, {"sha": "cdb3f9dbb1dbf817516a3f016cce7718ea879bff", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -21,7 +21,7 @@ use lint;\n use middle::resolve;\n use middle::ty;\n use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n-use middle::typeck::{MethodStatic, MethodObject};\n+use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject};\n use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n@@ -772,6 +772,7 @@ impl<'a> PrivacyVisitor<'a> {\n             MethodStatic(method_id) => {\n                 self.check_static_method(span, method_id, ident)\n             }\n+            MethodStaticUnboxedClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n             MethodParam(MethodParam { trait_id: trait_id, .. }) |"}, {"sha": "f1e6db1cab1731531413ee646e2d9998ef9cb177", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -5254,7 +5254,8 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprFnBlock(fn_decl, block) |\n-            ExprProc(fn_decl, block) => {\n+            ExprProc(fn_decl, block) |\n+            ExprUnboxedFn(fn_decl, block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n                                       Some(fn_decl), NoTypeParameters,\n                                       block);"}, {"sha": "9f1f4057be6b9b39a6a7f0a8a20f345d69515d95", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -842,7 +842,8 @@ impl <'l> DxrVisitor<'l> {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n         let method_callee = method_map.get(&typeck::MethodCall::expr(ex.id));\n         let (def_id, decl_id) = match method_callee.origin {\n-            typeck::MethodStatic(def_id) => {\n+            typeck::MethodStatic(def_id) |\n+            typeck::MethodStaticUnboxedClosure(def_id) => {\n                 // method invoked on an object with a concrete type (not a static method)\n                 let decl_id = ty::trait_method_of_method(&self.analysis.ty_cx, def_id);\n "}, {"sha": "ef0709316f0af43c880808dc45b4e89c6296ae41", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -317,6 +317,9 @@ impl<T> VecPerParamSpace<T> {\n         VecPerParamSpace::empty().with_vec(TypeSpace, types)\n     }\n \n+    /// `t` is the type space.\n+    /// `s` is the self space.\n+    /// `f` is the fn space.\n     pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n         let type_limit = t.len();\n         let self_limit = t.len() + s.len();"}, {"sha": "1d0108fa3f7f29e2dce5cbbc42be861e4f023fb6", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -163,6 +163,12 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n \n             return Univariant(mk_struct(cx, ftys.as_slice(), packed), dtor)\n         }\n+        ty::ty_unboxed_closure(def_id) => {\n+            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n+            let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n+            return Univariant(mk_struct(cx, upvar_types.as_slice(), false),\n+                              false)\n+        }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n             let hint = ty::lookup_repr_hint(cx.tcx(), def_id);"}, {"sha": "98342bfbcdc320643aa0d804544d3d7e6c46887a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 260, "deletions": 51, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -29,17 +29,16 @@ use back::link::{mangle_exported_name};\n use back::{link, abi};\n use driver::config;\n use driver::config::{NoDebugInfo, FullDebugInfo};\n-use driver::session::Session;\n use driver::driver::{CrateAnalysis, CrateTranslation};\n+use driver::session::Session;\n+use lint;\n+use llvm::{BasicBlockRef, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n-use llvm::{ModuleRef, ValueRef, BasicBlockRef};\n-use llvm::{Vector};\n use metadata::{csearch, encoder, loader};\n-use lint;\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n-use middle::weak_lang_items;\n use middle::subst;\n+use middle::weak_lang_items;\n use middle::subst::Subst;\n use middle::trans::_match;\n use middle::trans::adt;\n@@ -82,7 +81,8 @@ use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n use std::gc::Gc;\n-use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel, Rust, RustIntrinsic};\n+use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel, Rust, RustCall};\n+use syntax::abi::{RustIntrinsic, Abi};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -254,13 +254,32 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n }\n \n pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n-    let (inputs, output, has_env) = match ty::get(fn_ty).sty {\n-        ty::ty_bare_fn(ref f) => (f.sig.inputs.clone(), f.sig.output, false),\n-        ty::ty_closure(ref f) => (f.sig.inputs.clone(), f.sig.output, true),\n+    let (inputs, output, abi, env) = match ty::get(fn_ty).sty {\n+        ty::ty_bare_fn(ref f) => {\n+            (f.sig.inputs.clone(), f.sig.output, f.abi, None)\n+        }\n+        ty::ty_closure(ref f) => {\n+            (f.sig.inputs.clone(), f.sig.output, f.abi, Some(Type::i8p(ccx)))\n+        }\n+        ty::ty_unboxed_closure(closure_did) => {\n+            let unboxed_closure_types = ccx.tcx\n+                                           .unboxed_closure_types\n+                                           .borrow();\n+            let function_type = unboxed_closure_types.get(&closure_did);\n+            let llenvironment_type = type_of(ccx, fn_ty).ptr_to();\n+            (function_type.sig.inputs.clone(),\n+             function_type.sig.output,\n+             RustCall,\n+             Some(llenvironment_type))\n+        }\n         _ => fail!(\"expected closure or fn\")\n     };\n \n-    let llfty = type_of_rust_fn(ccx, has_env, inputs.as_slice(), output);\n+    let llfty = type_of_rust_fn(ccx, env, inputs.as_slice(), output, abi);\n+    debug!(\"decl_rust_fn(input count={},type={})\",\n+           inputs.len(),\n+           ccx.tn.type_to_string(llfty));\n+\n     let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, output);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n     for &(idx, attr) in attrs.iter() {\n@@ -674,6 +693,14 @@ pub fn iter_structural_ty<'r,\n               }\n           })\n       }\n+      ty::ty_unboxed_closure(def_id) => {\n+          let repr = adt::represent_type(cx.ccx(), t);\n+          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n+          for (i, upvar) in upvars.iter().enumerate() {\n+              let llupvar = adt::trans_field_ptr(cx, &*repr, av, 0, i);\n+              cx = f(cx, llupvar, upvar.ty);\n+          }\n+      }\n       ty::ty_vec(_, Some(n)) => {\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n         let (base, len) = tvec::get_fixed_base_and_byte_len(cx, av, unit_ty, n);\n@@ -870,7 +897,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n         ty::ty_bare_fn(ref fn_ty) => {\n             match fn_ty.abi.for_target(ccx.sess().targ_cfg.os,\n                                        ccx.sess().targ_cfg.arch) {\n-                Some(Rust) => {\n+                Some(Rust) | Some(RustCall) => {\n                     get_extern_rust_fn(ccx, t, name.as_slice(), did)\n                 }\n                 Some(RustIntrinsic) => {\n@@ -1150,13 +1177,11 @@ pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n                            -> ValueRef {\n-    unsafe {\n-        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n-            llvm::LLVMGetParam(fcx.llfn, 0)\n-        } else {\n-            let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            AllocaFcx(fcx, lloutputtype, \"__make_return_pointer\")\n-        }\n+    if type_of::return_uses_outptr(fcx.ccx, output_type) {\n+        get_param(fcx.llfn, 0)\n+    } else {\n+        let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n+        AllocaFcx(fcx, lloutputtype, \"__make_return_pointer\")\n     }\n }\n \n@@ -1213,9 +1238,7 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n     };\n \n     if has_env {\n-        fcx.llenv = Some(unsafe {\n-            llvm::LLVMGetParam(fcx.llfn, fcx.env_arg_pos() as c_uint)\n-        });\n+        fcx.llenv = Some(get_param(fcx.llfn, fcx.env_arg_pos() as c_uint))\n     }\n \n     fcx\n@@ -1280,16 +1303,85 @@ pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n                                  -> Vec<RvalueDatum> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n \n-    // Return an array wrapping the ValueRefs that we get from\n-    // llvm::LLVMGetParam for each argument into datums.\n+    // Return an array wrapping the ValueRefs that we get from `get_param` for\n+    // each argument into datums.\n     arg_tys.iter().enumerate().map(|(i, &arg_ty)| {\n-        let llarg = unsafe {\n-            llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(i) as c_uint)\n-        };\n+        let llarg = get_param(fcx.llfn, fcx.arg_pos(i) as c_uint);\n         datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty))\n     }).collect()\n }\n \n+/// Creates rvalue datums for each of the incoming function arguments and\n+/// tuples the arguments. These will later be stored into appropriate lvalue\n+/// datums.\n+fn create_datums_for_fn_args_under_call_abi<\n+        'a>(\n+        mut bcx: &'a Block<'a>,\n+        arg_scope: cleanup::CustomScopeIndex,\n+        arg_tys: &[ty::t])\n+        -> Vec<RvalueDatum> {\n+    let mut result = Vec::new();\n+    for (i, &arg_ty) in arg_tys.iter().enumerate() {\n+        if i < arg_tys.len() - 1 {\n+            // Regular argument.\n+            let llarg = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(i) as c_uint);\n+            result.push(datum::Datum::new(llarg, arg_ty, arg_kind(bcx.fcx,\n+                                                                  arg_ty)));\n+            continue\n+        }\n+\n+        // This is the last argument. Tuple it.\n+        match ty::get(arg_ty).sty {\n+            ty::ty_tup(ref tupled_arg_tys) => {\n+                let tuple_args_scope_id = cleanup::CustomScope(arg_scope);\n+                let tuple =\n+                    unpack_datum!(bcx,\n+                                  datum::lvalue_scratch_datum(bcx,\n+                                                              arg_ty,\n+                                                              \"tupled_args\",\n+                                                              false,\n+                                                              tuple_args_scope_id,\n+                                                              (),\n+                                                              |(),\n+                                                               mut bcx,\n+                                                               llval| {\n+                        for (j, &tupled_arg_ty) in\n+                                    tupled_arg_tys.iter().enumerate() {\n+                            let llarg =\n+                                get_param(bcx.fcx.llfn,\n+                                          bcx.fcx.arg_pos(i + j) as c_uint);\n+                            let lldest = GEPi(bcx, llval, [0, j]);\n+                            let datum = datum::Datum::new(\n+                                llarg,\n+                                tupled_arg_ty,\n+                                arg_kind(bcx.fcx, tupled_arg_ty));\n+                            bcx = datum.store_to(bcx, lldest);\n+                        }\n+                        bcx\n+                    }));\n+                let tuple = unpack_datum!(bcx,\n+                                          tuple.to_expr_datum()\n+                                               .to_rvalue_datum(bcx,\n+                                                                \"argtuple\"));\n+                result.push(tuple);\n+            }\n+            ty::ty_nil => {\n+                let mode = datum::Rvalue::new(datum::ByValue);\n+                result.push(datum::Datum::new(C_nil(bcx.ccx()),\n+                                              ty::mk_nil(),\n+                                              mode))\n+            }\n+            _ => {\n+                bcx.tcx().sess.bug(\"last argument of a function with \\\n+                                    `rust-call` ABI isn't a tuple?!\")\n+            }\n+        };\n+\n+    }\n+\n+    result\n+}\n+\n fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n                             arg_scope: cleanup::CustomScopeIndex,\n                             bcx: &'a Block<'a>,\n@@ -1322,6 +1414,59 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n     bcx\n }\n \n+fn copy_unboxed_closure_args_to_allocas<'a>(\n+                                        mut bcx: &'a Block<'a>,\n+                                        arg_scope: cleanup::CustomScopeIndex,\n+                                        args: &[ast::Arg],\n+                                        arg_datums: Vec<RvalueDatum>,\n+                                        monomorphized_arg_types: &[ty::t])\n+                                        -> &'a Block<'a> {\n+    let _icx = push_ctxt(\"copy_unboxed_closure_args_to_allocas\");\n+    let arg_scope_id = cleanup::CustomScope(arg_scope);\n+\n+    assert_eq!(arg_datums.len(), 1);\n+\n+    let arg_datum = arg_datums.move_iter().next().unwrap();\n+\n+    // Untuple the rest of the arguments.\n+    let tuple_datum =\n+        unpack_datum!(bcx,\n+                      arg_datum.to_lvalue_datum_in_scope(bcx,\n+                                                         \"argtuple\",\n+                                                         arg_scope_id));\n+    let empty = Vec::new();\n+    let untupled_arg_types = match ty::get(monomorphized_arg_types[0]).sty {\n+        ty::ty_tup(ref types) => types.as_slice(),\n+        ty::ty_nil => empty.as_slice(),\n+        _ => {\n+            bcx.tcx().sess.span_bug(args[0].pat.span,\n+                                    \"first arg to `rust-call` ABI function \\\n+                                     wasn't a tuple?!\")\n+        }\n+    };\n+    for j in range(0, args.len()) {\n+        let tuple_element_type = untupled_arg_types[j];\n+        let tuple_element_datum =\n+            tuple_datum.get_element(tuple_element_type,\n+                                    |llval| GEPi(bcx, llval, [0, j]));\n+        let tuple_element_datum = tuple_element_datum.to_expr_datum();\n+        let tuple_element_datum =\n+            unpack_datum!(bcx,\n+                          tuple_element_datum.to_rvalue_datum(bcx,\n+                                                              \"arg\"));\n+        bcx = _match::store_arg(bcx,\n+                                args[j].pat,\n+                                tuple_element_datum,\n+                                arg_scope_id);\n+\n+        if bcx.fcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n+            debuginfo::create_argument_metadata(bcx, &args[j]);\n+        }\n+    }\n+\n+    bcx\n+}\n+\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n@@ -1379,6 +1524,12 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n     Ret(ret_cx, retval);\n }\n \n+#[deriving(Clone, Eq, PartialEq)]\n+pub enum IsUnboxedClosureFlag {\n+    NotUnboxedClosure,\n+    IsUnboxedClosure,\n+}\n+\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n@@ -1389,7 +1540,11 @@ pub fn trans_closure(ccx: &CrateContext,\n                      param_substs: &param_substs,\n                      id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n+                     arg_types: Vec<ty::t>,\n                      output_type: ty::t,\n+                     abi: Abi,\n+                     has_env: bool,\n+                     is_unboxed_closure: IsUnboxedClosureFlag,\n                      maybe_load_env: <'a> |&'a Block<'a>| -> &'a Block<'a>) {\n     ccx.stats.n_closures.set(ccx.stats.n_closures.get() + 1);\n \n@@ -1399,11 +1554,6 @@ pub fn trans_closure(ccx: &CrateContext,\n     debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx()));\n \n-    let has_env = match ty::get(ty::node_id_to_type(ccx.tcx(), id)).sty {\n-        ty::ty_closure(_) => true,\n-        _ => false\n-    };\n-\n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx,\n                           llfndecl,\n@@ -1421,14 +1571,44 @@ pub fn trans_closure(ccx: &CrateContext,\n     let block_ty = node_id_type(bcx, body.id);\n \n     // Set up arguments to the function.\n-    let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n+    let monomorphized_arg_types =\n+        arg_types.iter()\n+                 .map(|at| monomorphize_type(bcx, *at))\n+                 .collect::<Vec<_>>();\n+    for monomorphized_arg_type in monomorphized_arg_types.iter() {\n+        debug!(\"trans_closure: monomorphized_arg_type: {}\",\n+               ty_to_string(ccx.tcx(), *monomorphized_arg_type));\n+    }\n+    debug!(\"trans_closure: function lltype: {}\",\n+           bcx.fcx.ccx.tn.val_to_string(bcx.fcx.llfn));\n+\n+    let arg_datums = if abi != RustCall {\n+        create_datums_for_fn_args(&fcx,\n+                                  monomorphized_arg_types.as_slice())\n+    } else {\n+        create_datums_for_fn_args_under_call_abi(\n+            bcx,\n+            arg_scope,\n+            monomorphized_arg_types.as_slice())\n+    };\n \n-    bcx = copy_args_to_allocas(&fcx,\n-                               arg_scope,\n-                               bcx,\n-                               decl.inputs.as_slice(),\n-                               arg_datums);\n+    bcx = match is_unboxed_closure {\n+        NotUnboxedClosure => {\n+            copy_args_to_allocas(&fcx,\n+                                 arg_scope,\n+                                 bcx,\n+                                 decl.inputs.as_slice(),\n+                                 arg_datums)\n+        }\n+        IsUnboxedClosure => {\n+            copy_unboxed_closure_args_to_allocas(\n+                bcx,\n+                arg_scope,\n+                decl.inputs.as_slice(),\n+                arg_datums,\n+                monomorphized_arg_types.as_slice())\n+        }\n+    };\n \n     bcx = maybe_load_env(bcx);\n \n@@ -1488,9 +1668,23 @@ pub fn trans_fn(ccx: &CrateContext,\n     let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n-    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), id));\n-    trans_closure(ccx, decl, body, llfndecl,\n-                  param_substs, id, attrs, output_type, |bcx| bcx);\n+    let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n+    let arg_types = ty::ty_fn_args(fn_ty);\n+    let output_type = ty::ty_fn_ret(fn_ty);\n+    let abi = ty::ty_fn_abi(fn_ty);\n+    trans_closure(ccx,\n+                  decl,\n+                  body,\n+                  llfndecl,\n+                  param_substs,\n+                  id,\n+                  attrs,\n+                  arg_types,\n+                  output_type,\n+                  abi,\n+                  false,\n+                  NotUnboxedClosure,\n+                  |bcx| bcx);\n }\n \n pub fn trans_enum_variant(ccx: &CrateContext,\n@@ -1657,7 +1851,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n-        if abi != Rust  {\n+        if abi != Rust {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n                 ccx, &**decl, &**body, item.attrs.as_slice(), llfndecl, item.id);\n@@ -1792,7 +1986,7 @@ fn register_fn(ccx: &CrateContext,\n                -> ValueRef {\n     match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n-            assert!(f.abi == Rust);\n+            assert!(f.abi == Rust || f.abi == RustCall);\n         }\n         _ => fail!(\"expected bare rust fn\")\n     };\n@@ -1802,15 +1996,30 @@ fn register_fn(ccx: &CrateContext,\n     llfn\n }\n \n-pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u64)> {\n+pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n+                              -> Vec<(uint, u64)> {\n     use middle::ty::{BrAnon, ReLateBound};\n \n-    let (fn_sig, has_env) = match ty::get(fn_ty).sty {\n-        ty::ty_closure(ref f) => (f.sig.clone(), true),\n-        ty::ty_bare_fn(ref f) => (f.sig.clone(), false),\n+    let (fn_sig, abi, has_env) = match ty::get(fn_ty).sty {\n+        ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n+        ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n+        ty::ty_unboxed_closure(closure_did) => {\n+            let unboxed_closure_types = ccx.tcx\n+                                           .unboxed_closure_types\n+                                           .borrow();\n+            let function_type = unboxed_closure_types.get(&closure_did);\n+            (function_type.sig.clone(), RustCall, true)\n+        }\n         _ => fail!(\"expected closure or function.\")\n     };\n \n+    // These have an odd calling convention, so we skip them for now.\n+    //\n+    // FIXME(pcwalton): We don't have to skip them; just untuple the result.\n+    if abi == RustCall {\n+        return Vec::new()\n+    }\n+\n     // Since index 0 is the return value of the llvm func, we start\n     // at either 1 or 2 depending on whether there's an env slot or not\n     let mut first_arg_offset = if has_env { 2 } else { 1 };\n@@ -1986,16 +2195,16 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n \n                     vec!(\n                         opaque_rust_main,\n-                        llvm::LLVMGetParam(llfn, 0),\n-                        llvm::LLVMGetParam(llfn, 1)\n+                        get_param(llfn, 0),\n+                        get_param(llfn, 1)\n                      )\n                 };\n                 (start_fn, args)\n             } else {\n                 debug!(\"using user-defined start fn\");\n                 let args = vec!(\n-                    llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                    llvm::LLVMGetParam(llfn, 1 as c_uint)\n+                    get_param(llfn, 0 as c_uint),\n+                    get_param(llfn, 1 as c_uint)\n                 );\n \n                 (rust_main, args)"}, {"sha": "8eab227ad16f7793da3e69836a979a58faf15fcf", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 194, "deletions": 30, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -19,18 +19,20 @@\n use arena::TypedArena;\n use back::abi;\n use back::link;\n+use llvm::{ValueRef, get_param};\n use llvm;\n-use llvm::ValueRef;\n use metadata::csearch;\n use middle::def;\n use middle::subst;\n use middle::subst::{Subst, VecPerParamSpace};\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n+use middle::trans::closure;\n use middle::trans::common;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n@@ -74,7 +76,7 @@ pub enum CalleeData {\n \n pub struct Callee<'a> {\n     pub bcx: &'a Block<'a>,\n-    pub data: CalleeData\n+    pub data: CalleeData,\n }\n \n fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n@@ -97,12 +99,18 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(..) => {\n                 let llval = datum.to_llscalarish(bcx);\n-                return Callee {bcx: bcx, data: Fn(llval)};\n+                return Callee {\n+                    bcx: bcx,\n+                    data: Fn(llval),\n+                };\n             }\n             ty::ty_closure(..) => {\n                 let datum = unpack_datum!(\n                     bcx, datum.to_lvalue_datum(bcx, \"callee\", expr.id));\n-                return Callee {bcx: bcx, data: Closure(datum)};\n+                return Callee {\n+                    bcx: bcx,\n+                    data: Closure(datum),\n+                };\n             }\n             _ => {\n                 bcx.tcx().sess.span_bug(\n@@ -115,7 +123,10 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     }\n \n     fn fn_callee<'a>(bcx: &'a Block<'a>, llfn: ValueRef) -> Callee<'a> {\n-        return Callee {bcx: bcx, data: Fn(llfn)};\n+        return Callee {\n+            bcx: bcx,\n+            data: Fn(llfn),\n+        };\n     }\n \n     fn trans_def<'a>(bcx: &'a Block<'a>, def: def::Def, ref_expr: &ast::Expr)\n@@ -206,9 +217,14 @@ fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n                                            substs: subst::Substs,\n                                            vtables: typeck::vtable_res)\n                                            -> Callee<'a> {\n-    Callee {bcx: bcx,\n-            data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ExprId(ref_id),\n-                                               substs, vtables))}\n+    Callee {\n+        bcx: bcx,\n+        data: Fn(trans_fn_ref_with_vtables(bcx,\n+                                           def_id,\n+                                           ExprId(ref_id),\n+                                           substs,\n+                                           vtables)),\n+    }\n }\n \n fn resolve_default_method_vtables(bcx: &Block,\n@@ -304,9 +320,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n     let boxed_self_kind = arg_kind(&fcx, boxed_self_type);\n \n     // Create a datum for self.\n-    let llboxedself = unsafe {\n-        llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(0) as u32)\n-    };\n+    let llboxedself = get_param(fcx.llfn, fcx.arg_pos(0) as u32);\n     let llboxedself = Datum::new(llboxedself,\n                                  boxed_self_type,\n                                  boxed_self_kind);\n@@ -340,9 +354,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n     // Now call the function.\n     let mut llshimmedargs = vec!(llself.val);\n     for i in range(1, arg_types.len()) {\n-        llshimmedargs.push(unsafe {\n-            llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(i) as u32)\n-        });\n+        llshimmedargs.push(get_param(fcx.llfn, fcx.arg_pos(i) as u32));\n     }\n     bcx = trans_call_inner(bcx,\n                            None,\n@@ -402,9 +414,6 @@ pub fn trans_fn_ref_with_vtables(\n \n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n-    // Polytype of the function item (may have type params)\n-    let fn_tpt = ty::lookup_item_type(tcx, def_id);\n-\n     // Load the info for the appropriate trait if necessary.\n     match ty::trait_of_method(tcx, def_id) {\n         None => {}\n@@ -465,6 +474,12 @@ pub fn trans_fn_ref_with_vtables(\n         }\n     };\n \n+    // If this is an unboxed closure, redirect to it.\n+    match closure::get_or_create_declaration_if_unboxed_closure(ccx, def_id) {\n+        None => {}\n+        Some(llfn) => return llfn,\n+    }\n+\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = {\n@@ -509,6 +524,9 @@ pub fn trans_fn_ref_with_vtables(\n         return val;\n     }\n \n+    // Polytype of the function item (may have type params)\n+    let fn_tpt = ty::lookup_item_type(tcx, def_id);\n+\n     // Find the actual function pointer.\n     let mut val = {\n         if def_id.krate == ast::LOCAL_CRATE {\n@@ -546,7 +564,10 @@ pub fn trans_fn_ref_with_vtables(\n     let llty = type_of::type_of_fn_from_ty(ccx, fn_tpt.ty);\n     let llptrty = llty.ptr_to();\n     if val_ty(val) != llptrty {\n+        debug!(\"trans_fn_ref_with_vtables(): casting pointer!\");\n         val = BitCast(bcx, val, llptrty);\n+    } else {\n+        debug!(\"trans_fn_ref_with_vtables(): not casting pointer!\");\n     }\n \n     val\n@@ -660,7 +681,7 @@ pub fn trans_call_inner<'a>(\n \n     let (abi, ret_ty) = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref f) => (f.abi, f.sig.output),\n-        ty::ty_closure(ref f) => (synabi::Rust, f.sig.output),\n+        ty::ty_closure(ref f) => (f.abi, f.sig.output),\n         _ => fail!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n \n@@ -723,7 +744,7 @@ pub fn trans_call_inner<'a>(\n     // and done, either the return value of the function will have been\n     // written in opt_llretslot (if it is Some) or `llresult` will be\n     // set appropriately (otherwise).\n-    if abi == synabi::Rust {\n+    if abi == synabi::Rust || abi == synabi::RustCall {\n         let mut llargs = Vec::new();\n \n         // Push the out-pointer if we use an out-pointer for this\n@@ -742,9 +763,13 @@ pub fn trans_call_inner<'a>(\n         }\n \n         // Push the arguments.\n-        bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n+        bcx = trans_args(bcx,\n+                         args,\n+                         callee_ty,\n+                         &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n-                         llself.is_some());\n+                         llself.is_some(),\n+                         abi);\n \n         fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n@@ -779,8 +804,13 @@ pub fn trans_call_inner<'a>(\n             ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, &**x)).collect(),\n             _ => fail!(\"expected arg exprs.\")\n         };\n-        bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope), false);\n+        bcx = trans_args(bcx,\n+                         args,\n+                         callee_ty,\n+                         &mut llargs,\n+                         cleanup::CustomScope(arg_cleanup_scope),\n+                         false,\n+                         abi);\n         fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(),\n@@ -821,15 +851,130 @@ pub enum CallArgs<'a> {\n     // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n     // the right-hand-side (if any).\n     ArgOverloadedOp(Datum<Expr>, Option<(Datum<Expr>, ast::NodeId)>),\n+\n+    // Supply value of arguments as a list of expressions that must be\n+    // translated, for overloaded call operators.\n+    ArgOverloadedCall(&'a [Gc<ast::Expr>]),\n }\n \n-pub fn trans_args<'a>(cx: &'a Block<'a>,\n-                      args: CallArgs,\n-                      fn_ty: ty::t,\n-                      llargs: &mut Vec<ValueRef> ,\n-                      arg_cleanup_scope: cleanup::ScopeId,\n-                      ignore_self: bool)\n-                      -> &'a Block<'a> {\n+fn trans_args_under_call_abi<'a>(\n+                             mut bcx: &'a Block<'a>,\n+                             arg_exprs: &[Gc<ast::Expr>],\n+                             fn_ty: ty::t,\n+                             llargs: &mut Vec<ValueRef>,\n+                             arg_cleanup_scope: cleanup::ScopeId,\n+                             ignore_self: bool)\n+                             -> &'a Block<'a> {\n+    // Translate the `self` argument first.\n+    let arg_tys = ty::ty_fn_args(fn_ty);\n+    if !ignore_self {\n+        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n+        llargs.push(unpack_result!(bcx, {\n+            trans_arg_datum(bcx,\n+                            *arg_tys.get(0),\n+                            arg_datum,\n+                            arg_cleanup_scope,\n+                            DontAutorefArg)\n+        }))\n+    }\n+\n+    // Now untuple the rest of the arguments.\n+    let tuple_expr = arg_exprs[1];\n+    let tuple_type = node_id_type(bcx, tuple_expr.id);\n+\n+    match ty::get(tuple_type).sty {\n+        ty::ty_tup(ref field_types) => {\n+            let tuple_datum = unpack_datum!(bcx,\n+                                            expr::trans(bcx, &*tuple_expr));\n+            let tuple_lvalue_datum =\n+                unpack_datum!(bcx,\n+                              tuple_datum.to_lvalue_datum(bcx,\n+                                                          \"args\",\n+                                                          tuple_expr.id));\n+            let repr = adt::represent_type(bcx.ccx(), tuple_type);\n+            let repr_ptr = &*repr;\n+            for i in range(0, field_types.len()) {\n+                let arg_datum = tuple_lvalue_datum.get_element(\n+                    *field_types.get(i),\n+                    |srcval| {\n+                        adt::trans_field_ptr(bcx, repr_ptr, srcval, 0, i)\n+                    });\n+                let arg_datum = arg_datum.to_expr_datum();\n+                let arg_datum =\n+                    unpack_datum!(bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n+                let arg_datum =\n+                    unpack_datum!(bcx, arg_datum.to_appropriate_datum(bcx));\n+                llargs.push(arg_datum.add_clean(bcx.fcx, arg_cleanup_scope));\n+            }\n+        }\n+        ty::ty_nil => {}\n+        _ => {\n+            bcx.sess().span_bug(tuple_expr.span,\n+                                \"argument to `.call()` wasn't a tuple?!\")\n+        }\n+    };\n+\n+    bcx\n+}\n+\n+fn trans_overloaded_call_args<'a>(\n+                              mut bcx: &'a Block<'a>,\n+                              arg_exprs: &[Gc<ast::Expr>],\n+                              fn_ty: ty::t,\n+                              llargs: &mut Vec<ValueRef>,\n+                              arg_cleanup_scope: cleanup::ScopeId,\n+                              ignore_self: bool)\n+                              -> &'a Block<'a> {\n+    // Translate the `self` argument first.\n+    let arg_tys = ty::ty_fn_args(fn_ty);\n+    if !ignore_self {\n+        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n+        llargs.push(unpack_result!(bcx, {\n+            trans_arg_datum(bcx,\n+                            *arg_tys.get(0),\n+                            arg_datum,\n+                            arg_cleanup_scope,\n+                            DontAutorefArg)\n+        }))\n+    }\n+\n+    // Now untuple the rest of the arguments.\n+    let tuple_type = *arg_tys.get(1);\n+    match ty::get(tuple_type).sty {\n+        ty::ty_tup(ref field_types) => {\n+            for (i, &field_type) in field_types.iter().enumerate() {\n+                let arg_datum =\n+                    unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[i + 1]));\n+                llargs.push(unpack_result!(bcx, {\n+                    trans_arg_datum(bcx,\n+                                    field_type,\n+                                    arg_datum,\n+                                    arg_cleanup_scope,\n+                                    DontAutorefArg)\n+                }))\n+            }\n+        }\n+        ty::ty_nil => {}\n+        _ => {\n+            bcx.sess().span_bug(arg_exprs[0].span,\n+                                \"argument to `.call()` wasn't a tuple?!\")\n+        }\n+    };\n+\n+    bcx\n+}\n+\n+pub fn trans_args<'a>(\n+                  cx: &'a Block<'a>,\n+                  args: CallArgs,\n+                  fn_ty: ty::t,\n+                  llargs: &mut Vec<ValueRef> ,\n+                  arg_cleanup_scope: cleanup::ScopeId,\n+                  ignore_self: bool,\n+                  abi: synabi::Abi)\n+                  -> &'a Block<'a> {\n+    debug!(\"trans_args(abi={})\", abi);\n+\n     let _icx = push_ctxt(\"trans_args\");\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     let variadic = ty::fn_is_variadic(fn_ty);\n@@ -841,6 +986,17 @@ pub fn trans_args<'a>(cx: &'a Block<'a>,\n     // to cast her view of the arguments to the caller's view.\n     match args {\n         ArgExprs(arg_exprs) => {\n+            if abi == synabi::RustCall {\n+                // This is only used for direct calls to the `call`,\n+                // `call_mut` or `call_once` functions.\n+                return trans_args_under_call_abi(cx,\n+                                                 arg_exprs,\n+                                                 fn_ty,\n+                                                 llargs,\n+                                                 arg_cleanup_scope,\n+                                                 ignore_self)\n+            }\n+\n             let num_formal_args = arg_tys.len();\n             for (i, arg_expr) in arg_exprs.iter().enumerate() {\n                 if i == 0 && ignore_self {\n@@ -861,6 +1017,14 @@ pub fn trans_args<'a>(cx: &'a Block<'a>,\n                 }));\n             }\n         }\n+        ArgOverloadedCall(arg_exprs) => {\n+            return trans_overloaded_call_args(cx,\n+                                              arg_exprs,\n+                                              fn_ty,\n+                                              llargs,\n+                                              arg_cleanup_scope,\n+                                              ignore_self)\n+        }\n         ArgOverloadedOp(lhs, rhs) => {\n             assert!(!variadic);\n "}, {"sha": "a3d8ab1733f97cbe39409ca1001eba86f01bbd15", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 160, "deletions": 10, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -16,6 +16,7 @@ use llvm::ValueRef;\n use middle::def;\n use middle::freevars;\n use middle::lang_items::ClosureExchangeMallocFnLangItem;\n+use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -31,6 +32,7 @@ use util::ppaux::ty_to_string;\n \n use arena::TypedArena;\n use syntax::ast;\n+use syntax::ast_util;\n \n // ___Good to know (tm)__________________________________________________\n //\n@@ -285,7 +287,6 @@ fn load_environment<'a>(bcx: &'a Block<'a>,\n         let def_id = freevar.def.def_id();\n \n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvarptr);\n-\n         for &env_pointer_alloca in env_pointer_alloca.iter() {\n             debuginfo::create_captured_var_metadata(\n                 bcx,\n@@ -303,6 +304,26 @@ fn load_environment<'a>(bcx: &'a Block<'a>,\n     bcx\n }\n \n+fn load_unboxed_closure_environment<'a>(\n+                                    bcx: &'a Block<'a>,\n+                                    freevars: &Vec<freevars::freevar_entry>)\n+                                    -> &'a Block<'a> {\n+    let _icx = push_ctxt(\"closure::load_environment\");\n+\n+    if freevars.len() == 0 {\n+        return bcx\n+    }\n+\n+    let llenv = bcx.fcx.llenv.unwrap();\n+    for (i, freevar) in freevars.iter().enumerate() {\n+        let upvar_ptr = GEPi(bcx, llenv, [0, i]);\n+        let def_id = freevar.def.def_id();\n+        bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n+    }\n+\n+    bcx\n+}\n+\n fn fill_fn_pair(bcx: &Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n     Store(bcx, llfn, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n     let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n@@ -352,20 +373,149 @@ pub fn trans_expr_fn<'a>(\n \n     let freevar_mode = freevars::get_capture_mode(tcx, id);\n     let freevars: Vec<freevars::freevar_entry> =\n-        freevars::with_freevars(\n-            tcx, id,\n-            |fv| fv.iter().map(|&fv| fv).collect());\n-\n-    let ClosureResult {llbox, cdata_ty, bcx} =\n-        build_closure(bcx, freevar_mode, &freevars, store);\n-    trans_closure(ccx, decl, body, llfn,\n-                  bcx.fcx.param_substs, id,\n-                  [], ty::ty_fn_ret(fty),\n+        freevars::with_freevars(tcx,\n+                                id,\n+                                |fv| fv.iter().map(|&fv| fv).collect());\n+\n+    let ClosureResult {\n+        llbox,\n+        cdata_ty,\n+        bcx\n+    } = build_closure(bcx, freevar_mode, &freevars, store);\n+    trans_closure(ccx,\n+                  decl,\n+                  body,\n+                  llfn,\n+                  bcx.fcx.param_substs,\n+                  id,\n+                  [],\n+                  ty::ty_fn_args(fty),\n+                  ty::ty_fn_ret(fty),\n+                  ty::ty_fn_abi(fty),\n+                  true,\n+                  NotUnboxedClosure,\n                   |bcx| load_environment(bcx, cdata_ty, &freevars, store));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n }\n \n+/// Returns the LLVM function declaration for an unboxed closure, creating it\n+/// if necessary. If the ID does not correspond to a closure ID, returns None.\n+pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n+                                                    closure_id: ast::DefId)\n+                                                    -> Option<ValueRef> {\n+    if !ccx.tcx.unboxed_closure_types.borrow().contains_key(&closure_id) {\n+        // Not an unboxed closure.\n+        return None\n+    }\n+\n+    match ccx.unboxed_closure_vals.borrow().find(&closure_id) {\n+        Some(llfn) => {\n+            debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n+                    closure\");\n+            return Some(*llfn)\n+        }\n+        None => {}\n+    }\n+\n+    let function_type = ty::mk_unboxed_closure(&ccx.tcx, closure_id);\n+    let symbol = ccx.tcx.map.with_path(closure_id.node, |path| {\n+        mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n+    });\n+\n+    let llfn = decl_internal_rust_fn(ccx, function_type, symbol.as_slice());\n+\n+    // set an inline hint for all closures\n+    set_inline_hint(llfn);\n+\n+    debug!(\"get_or_create_declaration_if_unboxed_closure(): inserting new \\\n+            closure {} (type {})\",\n+           closure_id,\n+           ccx.tn.type_to_string(val_ty(llfn)));\n+    ccx.unboxed_closure_vals.borrow_mut().insert(closure_id, llfn);\n+\n+    Some(llfn)\n+}\n+\n+pub fn trans_unboxed_closure<'a>(\n+                             mut bcx: &'a Block<'a>,\n+                             decl: &ast::FnDecl,\n+                             body: &ast::Block,\n+                             id: ast::NodeId,\n+                             dest: expr::Dest)\n+                             -> &'a Block<'a> {\n+    let _icx = push_ctxt(\"closure::trans_unboxed_closure\");\n+\n+    debug!(\"trans_unboxed_closure()\");\n+\n+    let closure_id = ast_util::local_def(id);\n+    let llfn = get_or_create_declaration_if_unboxed_closure(\n+        bcx.ccx(),\n+        closure_id).unwrap();\n+\n+    // Untuple the arguments.\n+    let unboxed_closure_types = bcx.tcx().unboxed_closure_types.borrow();\n+    let /*mut*/ function_type = (*unboxed_closure_types.get(&closure_id)).clone();\n+    /*function_type.sig.inputs =\n+        match ty::get(*function_type.sig.inputs.get(0)).sty {\n+            ty::ty_tup(ref tuple_types) => {\n+                tuple_types.iter().map(|x| (*x).clone()).collect()\n+            }\n+            _ => {\n+                bcx.tcx().sess.span_bug(body.span,\n+                                        \"unboxed closure wasn't a tuple?!\")\n+            }\n+        };*/\n+    let function_type = ty::mk_closure(bcx.tcx(), function_type);\n+\n+    let freevars: Vec<freevars::freevar_entry> =\n+        freevars::with_freevars(bcx.tcx(),\n+                                id,\n+                                |fv| fv.iter().map(|&fv| fv).collect());\n+    let freevars_ptr = &freevars;\n+\n+    trans_closure(bcx.ccx(),\n+                  decl,\n+                  body,\n+                  llfn,\n+                  bcx.fcx.param_substs,\n+                  id,\n+                  [],\n+                  ty::ty_fn_args(function_type),\n+                  ty::ty_fn_ret(function_type),\n+                  ty::ty_fn_abi(function_type),\n+                  true,\n+                  IsUnboxedClosure,\n+                  |bcx| load_unboxed_closure_environment(bcx, freevars_ptr));\n+\n+    // Don't hoist this to the top of the function. It's perfectly legitimate\n+    // to have a zero-size unboxed closure (in which case dest will be\n+    // `Ignore`) and we must still generate the closure body.\n+    let dest_addr = match dest {\n+        expr::SaveIn(p) => p,\n+        expr::Ignore => {\n+            debug!(\"trans_unboxed_closure() ignoring result\");\n+            return bcx\n+        }\n+    };\n+\n+    let repr = adt::represent_type(bcx.ccx(), node_id_type(bcx, id));\n+\n+    // Create the closure.\n+    adt::trans_start_init(bcx, &*repr, dest_addr, 0);\n+    for freevar in freevars_ptr.iter() {\n+        let datum = expr::trans_local_var(bcx, freevar.def);\n+        let upvar_slot_dest = adt::trans_field_ptr(bcx,\n+                                                   &*repr,\n+                                                   dest_addr,\n+                                                   0,\n+                                                   0);\n+        bcx = datum.store_to(bcx, upvar_slot_dest);\n+    }\n+\n+    bcx\n+}\n+\n pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n                                closure_ty: ty::t,\n                                def: def::Def,"}, {"sha": "320e291e928653ec48a6147ba7fba4ffef2bd039", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -71,7 +71,8 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     }\n     match ty::get(ty).sty {\n         ty::ty_bot => true,\n-        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) => {\n+        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n+        ty::ty_unboxed_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type)\n         }\n@@ -632,12 +633,6 @@ pub fn C_bytes(ccx: &CrateContext, bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMGetParam(fndecl, param as c_uint)\n-    }\n-}\n-\n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n@@ -792,6 +787,9 @@ pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n         typeck::vtable_param(n_param, n_bound) => {\n             find_vtable(tcx, param_substs, n_param, n_bound)\n         }\n+        typeck::vtable_unboxed_closure(def_id) => {\n+            typeck::vtable_unboxed_closure(def_id)\n+        }\n         typeck::vtable_error => typeck::vtable_error\n     }\n }"}, {"sha": "be39d435ee4584e4a24b78eabb745f2abf414478", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -117,6 +117,10 @@ pub struct CrateContext {\n     pub int_type: Type,\n     pub opaque_vec_type: Type,\n     pub builder: BuilderRef_res,\n+\n+    /// Holds the LLVM values for closure IDs.\n+    pub unboxed_closure_vals: RefCell<DefIdMap<ValueRef>>,\n+\n     /// Set when at least one function uses GC. Needed so that\n     /// decl_gc_metadata knows whether to link to the module metadata, which\n     /// is not emitted by LLVM's GC pass when no functions use GC.\n@@ -225,6 +229,7 @@ impl CrateContext {\n                 int_type: Type::from_ref(ptr::mut_null()),\n                 opaque_vec_type: Type::from_ref(ptr::mut_null()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n+                unboxed_closure_vals: RefCell::new(DefIdMap::new()),\n                 uses_gc: false,\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),"}, {"sha": "47e941755460fc427f06c931bff8e61082e1c035", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -452,7 +452,8 @@ impl TypeMap {\n                                                onceness,\n                                                store,\n                                                ref bounds,\n-                                               ref sig }) => {\n+                                               ref sig,\n+                                               abi: _ }) => {\n                 if fn_style == ast::UnsafeFn {\n                     unique_type_id.push_str(\"unsafe \");\n                 }\n@@ -1150,7 +1151,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n                 ast::ExprFnBlock(fn_decl, top_level_block) |\n-                ast::ExprProc(fn_decl, top_level_block) => {\n+                ast::ExprProc(fn_decl, top_level_block) |\n+                ast::ExprUnboxedFn(fn_decl, top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name.as_slice());\n                     (name, fn_decl,\n@@ -3602,7 +3604,8 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprFnBlock(ref decl, ref block) |\n-            ast::ExprProc(ref decl, ref block) => {\n+            ast::ExprProc(ref decl, ref block) |\n+            ast::ExprUnboxedFn(ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n@@ -3877,6 +3880,9 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 push_debuginfo_type_name(cx, sig.output, true, output);\n             }\n         },\n+        ty::ty_unboxed_closure(_) => {\n+            output.push_str(\"closure\");\n+        }\n         ty::ty_err      |\n         ty::ty_infer(_) |\n         ty::ty_param(_) => {"}, {"sha": "e7bde00b3ded9d1ae2c5c771bc1a448ba3d6f456", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -783,12 +783,14 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                    expr_to_string(expr), expr_ty.repr(tcx));\n             closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n         }\n+        ast::ExprUnboxedFn(decl, body) => {\n+            closure::trans_unboxed_closure(bcx, &*decl, &*body, expr.id, dest)\n+        }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n-                let callee_datum = unpack_datum!(bcx, trans(bcx, &**f));\n                 trans_overloaded_call(bcx,\n                                       expr,\n-                                      callee_datum,\n+                                      *f,\n                                       args.as_slice(),\n                                       Some(dest))\n             } else {\n@@ -1502,54 +1504,18 @@ fn trans_overloaded_op<'a, 'b>(\n fn trans_overloaded_call<'a>(\n                          mut bcx: &'a Block<'a>,\n                          expr: &ast::Expr,\n-                         callee: Datum<Expr>,\n+                         callee: Gc<ast::Expr>,\n                          args: &[Gc<ast::Expr>],\n                          dest: Option<Dest>)\n                          -> &'a Block<'a> {\n-    // Evaluate and tuple the arguments.\n-    let tuple_type = ty::mk_tup(bcx.tcx(),\n-                                args.iter()\n-                                    .map(|e| ty::expr_ty_adjusted(bcx.tcx(), &**e))\n-                                    .collect());\n-    let repr = adt::represent_type(bcx.ccx(), tuple_type);\n-    let numbered_fields: Vec<(uint, Gc<ast::Expr>)> =\n-        args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n-    let argument_scope = bcx.fcx.push_custom_cleanup_scope();\n-    let tuple_datum =\n-        unpack_datum!(bcx,\n-                      lvalue_scratch_datum(bcx,\n-                                           tuple_type,\n-                                           \"tupled_arguments\",\n-                                           false,\n-                                           cleanup::CustomScope(\n-                                               argument_scope),\n-                                           (),\n-                                           |(), bcx, addr| {\n-            trans_adt(bcx,\n-                      &*repr,\n-                      0,\n-                      numbered_fields.as_slice(),\n-                      None,\n-                      SaveIn(addr))\n-        }));\n-\n     let method_call = MethodCall::expr(expr.id);\n     let method_type = bcx.tcx()\n                          .method_map\n                          .borrow()\n                          .get(&method_call)\n                          .ty;\n-    let callee_rvalue = unpack_datum!(bcx,\n-                                      callee.to_rvalue_datum(bcx, \"callee\"));\n-    let tuple_datum = tuple_datum.to_expr_datum();\n-    let tuple_rvalue = unpack_datum!(bcx,\n-                                     tuple_datum.to_rvalue_datum(bcx,\n-                                                                 \"tuple\"));\n-    let argument_values = [\n-        callee_rvalue.add_clean(bcx.fcx,\n-                                cleanup::CustomScope(argument_scope)),\n-        tuple_rvalue.add_clean(bcx.fcx, cleanup::CustomScope(argument_scope))\n-    ];\n+    let mut all_args = vec!(callee);\n+    all_args.push_all(args);\n     unpack_result!(bcx,\n                    callee::trans_call_inner(bcx,\n                                             Some(expr_info(expr)),\n@@ -1562,10 +1528,9 @@ fn trans_overloaded_call<'a>(\n                                                     None,\n                                                     arg_cleanup_scope)\n                                             },\n-                                            callee::ArgVals(argument_values),\n+                                            callee::ArgOverloadedCall(\n+                                                all_args.as_slice()),\n                                             dest));\n-\n-    bcx.fcx.pop_custom_cleanup_scope(argument_scope);\n     bcx\n }\n "}, {"sha": "d7630d7ec3ab3b813152411bb8e5fec176e116f1", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -10,8 +10,8 @@\n \n \n use back::{link};\n+use llvm::{ValueRef, CallConv, Linkage, get_param};\n use llvm;\n-use llvm::{ValueRef, CallConv, Linkage};\n use middle::weak_lang_items;\n use middle::trans::base::push_ctxt;\n use middle::trans::base;\n@@ -27,7 +27,7 @@ use middle::ty;\n use std::cmp;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n-use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall, System};\n+use syntax::abi::{RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n@@ -84,6 +84,11 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n                 ccx.sess().unimpl(\"foreign functions with Rust ABI\");\n             }\n \n+            RustCall => {\n+                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n+                ccx.sess().unimpl(\"foreign functions with RustCall ABI\");\n+            }\n+\n             // It's the ABI's job to select this, not us.\n             System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n \n@@ -646,7 +651,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         // If there is an out pointer on the foreign function\n         let foreign_outptr = {\n             if tys.fn_ty.ret_ty.is_indirect() {\n-                Some(llvm::LLVMGetParam(llwrapfn, next_foreign_arg(false)))\n+                Some(get_param(llwrapfn, next_foreign_arg(false)))\n             } else {\n                 None\n             }\n@@ -708,7 +713,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n             // skip padding\n             let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n-            let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n+            let mut llforeign_arg = get_param(llwrapfn, foreign_index);\n \n             debug!(\"llforeign_arg {}{}: {}\", \"#\",\n                    i, ccx.tn.val_to_string(llforeign_arg));"}, {"sha": "aad7ba95a73a964b7bfda8d3b45ebbde959dfed9", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -15,8 +15,8 @@\n \n use back::abi;\n use back::link::*;\n+use llvm::{ValueRef, True, get_param};\n use llvm;\n-use llvm::{ValueRef, True};\n use middle::lang_items::{FreeFnLangItem, ExchangeFreeFnLangItem};\n use middle::subst;\n use middle::trans::adt;\n@@ -353,6 +353,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 }\n             }\n         }\n+        ty::ty_unboxed_closure(..) => iter_structural_ty(bcx, v0, t, drop_ty),\n         ty::ty_closure(ref f) if f.store == ty::UniqTraitStore => {\n             let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n             let env = Load(bcx, box_cell_v);\n@@ -502,7 +503,7 @@ fn make_generic_glue(ccx: &CrateContext,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, fcx.arg_pos(0) as c_uint) };\n+    let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n     let bcx = helper(bcx, llrawptr0, t);\n     finish_fn(&fcx, bcx, ty::mk_nil());\n "}, {"sha": "2e3d7b291eab170ef15dbcc2c6bf48eef2612e45", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -29,6 +29,7 @@ use middle::trans::machine;\n use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n use middle::ty;\n+use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::parse::token;\n use util::ppaux::ty_to_string;\n@@ -193,8 +194,13 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n \n     // Push the arguments.\n     let mut llargs = Vec::new();\n-    bcx = callee::trans_args(bcx, args, callee_ty, &mut llargs,\n-                             cleanup::CustomScope(cleanup_scope), false);\n+    bcx = callee::trans_args(bcx,\n+                             args,\n+                             callee_ty,\n+                             &mut llargs,\n+                             cleanup::CustomScope(cleanup_scope),\n+                             false,\n+                             RustIntrinsic);\n \n     fcx.pop_custom_cleanup_scope(cleanup_scope);\n "}, {"sha": "53f89c9d8b879ccc038ef2953dfa76e8655ce427", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 78, "deletions": 11, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -13,6 +13,7 @@ use back::abi;\n use llvm;\n use llvm::ValueRef;\n use metadata::csearch;\n+use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -35,7 +36,7 @@ use util::ppaux::Repr;\n \n use std::c_str::ToCStr;\n use std::gc::Gc;\n-use syntax::abi::Rust;\n+use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n use syntax::ast_util::PostExpansionMethod;\n@@ -104,10 +105,13 @@ pub fn trans_method_callee<'a>(\n     };\n \n     match origin {\n-        typeck::MethodStatic(did) => {\n+        typeck::MethodStatic(did) |\n+        typeck::MethodStaticUnboxedClosure(did) => {\n             Callee {\n                 bcx: bcx,\n-                data: Fn(callee::trans_fn_ref(bcx, did, MethodCall(method_call)))\n+                data: Fn(callee::trans_fn_ref(bcx,\n+                                              did,\n+                                              MethodCall(method_call))),\n             }\n         }\n         typeck::MethodParam(typeck::MethodParam {\n@@ -200,6 +204,9 @@ pub fn trans_static_method_callee(bcx: &Block,\n             let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n             PointerCast(bcx, llfn, llty)\n         }\n+        typeck::vtable_unboxed_closure(_) => {\n+            bcx.tcx().sess.bug(\"can't call a closure vtable in a static way\");\n+        }\n         _ => {\n             fail!(\"vtable_param left in monomorphized \\\n                    function's vtable substs\");\n@@ -225,12 +232,13 @@ fn method_with_name(ccx: &CrateContext,\n     *meth_did\n }\n \n-fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n-                                  method_call: MethodCall,\n-                                  trait_id: ast::DefId,\n-                                  n_method: uint,\n-                                  vtbl: typeck::vtable_origin)\n-                                  -> Callee<'a> {\n+fn trans_monomorphized_callee<'a>(\n+                              bcx: &'a Block<'a>,\n+                              method_call: MethodCall,\n+                              trait_id: ast::DefId,\n+                              n_method: uint,\n+                              vtbl: typeck::vtable_origin)\n+                              -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtbl {\n       typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n@@ -253,6 +261,26 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n \n           Callee { bcx: bcx, data: Fn(llfn) }\n       }\n+      typeck::vtable_unboxed_closure(closure_def_id) => {\n+          // The static region and type parameters are lies, but we're in\n+          // trans so it doesn't matter.\n+          //\n+          // FIXME(pcwalton): Is this true in the case of type parameters?\n+          let callee_substs = get_callee_substitutions_for_unboxed_closure(\n+                bcx,\n+                closure_def_id);\n+\n+          let llfn = trans_fn_ref_with_vtables(bcx,\n+                                               closure_def_id,\n+                                               MethodCall(method_call),\n+                                               callee_substs,\n+                                               VecPerParamSpace::empty());\n+\n+          Callee {\n+              bcx: bcx,\n+              data: Fn(llfn),\n+          }\n+      }\n       typeck::vtable_param(..) => {\n           bcx.tcx().sess.bug(\n               \"vtable_param left in monomorphized function's vtable substs\");\n@@ -385,8 +413,12 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     debug!(\"(translating trait callee) loading method\");\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(ref f) if f.abi == Rust => {\n-            type_of_rust_fn(ccx, true, f.sig.inputs.slice_from(1), f.sig.output)\n+        ty::ty_bare_fn(ref f) if f.abi == Rust || f.abi == RustCall => {\n+            type_of_rust_fn(ccx,\n+                            Some(Type::i8p(ccx)),\n+                            f.sig.inputs.slice_from(1),\n+                            f.sig.output,\n+                            f.abi)\n         }\n         _ => {\n             ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n@@ -409,6 +441,26 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     };\n }\n \n+/// Creates the self type and (fake) callee substitutions for an unboxed\n+/// closure with the given def ID. The static region and type parameters are\n+/// lies, but we're in trans so it doesn't matter.\n+fn get_callee_substitutions_for_unboxed_closure(bcx: &Block,\n+                                                def_id: ast::DefId)\n+                                                -> subst::Substs {\n+    let self_ty = ty::mk_unboxed_closure(bcx.tcx(), def_id);\n+    subst::Substs::erased(\n+        VecPerParamSpace::new(Vec::new(),\n+                              vec![\n+                                  ty::mk_rptr(bcx.tcx(),\n+                                              ty::ReStatic,\n+                                              ty::mt {\n+                                                ty: self_ty,\n+                                                mutbl: ast::MutMutable,\n+                                              })\n+                              ],\n+                              Vec::new()))\n+}\n+\n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n fn get_vtable(bcx: &Block,\n@@ -436,6 +488,21 @@ fn get_vtable(bcx: &Block,\n             typeck::vtable_static(id, substs, sub_vtables) => {\n                 emit_vtable_methods(bcx, id, substs, sub_vtables).move_iter()\n             }\n+            typeck::vtable_unboxed_closure(closure_def_id) => {\n+                let callee_substs =\n+                    get_callee_substitutions_for_unboxed_closure(\n+                        bcx,\n+                        closure_def_id);\n+\n+                let llfn = trans_fn_ref_with_vtables(\n+                    bcx,\n+                    closure_def_id,\n+                    ExprId(0),\n+                    callee_substs,\n+                    VecPerParamSpace::empty());\n+\n+                (vec!(llfn)).move_iter()\n+            }\n             _ => ccx.sess().bug(\"get_vtable: expected a static origin\"),\n         }\n     });"}, {"sha": "dac3b6bd8eee47bfdff7b296240f667a4797d0b5", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -254,6 +254,13 @@ pub fn make_vtable_id(_ccx: &CrateContext,\n             }\n         }\n \n+        &typeck::vtable_unboxed_closure(def_id) => {\n+            MonoId {\n+                def: def_id,\n+                params: subst::VecPerParamSpace::empty(),\n+            }\n+        }\n+\n         // can't this be checked at the callee?\n         _ => fail!(\"make_vtable_id needs vtable_static\")\n     }"}, {"sha": "7d8700b9426091e761d8388ec3e8f8552ac749cb", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm;\n-use llvm::{ValueRef};\n+use llvm::{ValueRef, get_param};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -316,14 +315,10 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                                       None, &arena);\n                 let bcx = init_function(&fcx, false, ty::mk_u64());\n \n-                let arg = unsafe {\n-                    //\n-                    // we know the return type of llfdecl is an int here, so\n-                    // no need for a special check to see if the return type\n-                    // is immediate.\n-                    //\n-                    llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n-                };\n+                // we know the return type of llfdecl is an int here, so\n+                // no need for a special check to see if the return type\n+                // is immediate.\n+                let arg = get_param(llfdecl, fcx.arg_pos(0u) as c_uint);\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, &*repr, arg, Some(Type::i64(ccx)));\n                 Store(bcx, ret, fcx.llretptr.get().unwrap());\n@@ -366,6 +361,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           // Miscellaneous extra types\n           ty::ty_infer(_) => self.leaf(\"infer\"),\n           ty::ty_err => self.leaf(\"err\"),\n+          ty::ty_unboxed_closure(..) => self.leaf(\"err\"),\n           ty::ty_param(ref p) => {\n               let extra = vec!(self.c_uint(p.idx));\n               self.visit(\"param\", extra.as_slice())"}, {"sha": "94c376c09c86a66a3257c0c455e1cfd11cea39db", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -39,10 +39,56 @@ pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n     }\n }\n \n-pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n-                       inputs: &[ty::t], output: ty::t) -> Type {\n+/// Yields the types of the \"real\" arguments for this function. For most\n+/// functions, these are simply the types of the arguments. For functions with\n+/// the `RustCall` ABI, however, this untuples the arguments of the function.\n+fn untuple_arguments_if_necessary(ccx: &CrateContext,\n+                                  inputs: &[ty::t],\n+                                  abi: abi::Abi)\n+                                  -> Vec<ty::t> {\n+    if abi != abi::RustCall {\n+        return inputs.iter().map(|x| (*x).clone()).collect()\n+    }\n+\n+    if inputs.len() == 0 {\n+        return Vec::new()\n+    }\n+\n+    let mut result = Vec::new();\n+    for (i, &arg_prior_to_tuple) in inputs.iter().enumerate() {\n+        if i < inputs.len() - 1 {\n+            result.push(arg_prior_to_tuple);\n+        }\n+    }\n+\n+    match ty::get(inputs[inputs.len() - 1]).sty {\n+        ty::ty_tup(ref tupled_arguments) => {\n+            debug!(\"untuple_arguments_if_necessary(): untupling arguments\");\n+            for &tupled_argument in tupled_arguments.iter() {\n+                result.push(tupled_argument);\n+            }\n+        }\n+        ty::ty_nil => {}\n+        _ => {\n+            ccx.tcx().sess.bug(\"argument to function with \\\"rust-call\\\" ABI \\\n+                                is neither a tuple nor unit\")\n+        }\n+    }\n+\n+    result\n+}\n+\n+pub fn type_of_rust_fn(cx: &CrateContext,\n+                       llenvironment_type: Option<Type>,\n+                       inputs: &[ty::t],\n+                       output: ty::t,\n+                       abi: abi::Abi)\n+                       -> Type {\n     let mut atys: Vec<Type> = Vec::new();\n \n+    // First, munge the inputs, if this has the `rust-call` ABI.\n+    let inputs = untuple_arguments_if_necessary(cx, inputs, abi);\n+\n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n     let use_out_pointer = return_uses_outptr(cx, output);\n@@ -52,8 +98,9 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n     }\n \n     // Arg 1: Environment\n-    if has_env {\n-        atys.push(Type::i8p(cx));\n+    match llenvironment_type {\n+        None => {}\n+        Some(llenvironment_type) => atys.push(llenvironment_type),\n     }\n \n     // ... then explicit args.\n@@ -72,16 +119,19 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n-            type_of_rust_fn(cx, true, f.sig.inputs.as_slice(), f.sig.output)\n+            type_of_rust_fn(cx,\n+                            Some(Type::i8p(cx)),\n+                            f.sig.inputs.as_slice(),\n+                            f.sig.output,\n+                            f.abi)\n         }\n         ty::ty_bare_fn(ref f) => {\n-            if f.abi == abi::Rust {\n+            if f.abi == abi::Rust || f.abi == abi::RustCall {\n                 type_of_rust_fn(cx,\n-                                false,\n+                                None,\n                                 f.sig.inputs.as_slice(),\n-                                f.sig.output)\n-            } else if f.abi == abi::RustIntrinsic {\n-                cx.sess().bug(\"type_of_fn_from_ty given intrinsic\")\n+                                f.sig.output,\n+                                f.abi)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)\n             }\n@@ -142,7 +192,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n-        ty::ty_tup(..) | ty::ty_enum(..) => {\n+        ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, &*repr)\n         }\n@@ -223,6 +273,13 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         let name = llvm_type_name(cx, an_enum, did, tps);\n         adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n+      ty::ty_unboxed_closure(did) => {\n+        // Only create the named struct, but don't fill it in. We\n+        // fill it in *after* placing it into the type cache.\n+        let repr = adt::represent_type(cx, t);\n+        let name = llvm_type_name(cx, an_unboxed_closure, did, []);\n+        adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+      }\n       ty::ty_box(typ) => {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n       }\n@@ -299,7 +356,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n-        ty::ty_enum(..) | ty::ty_struct(..) if !ty::type_is_simd(cx.tcx(), t) => {\n+        ty::ty_enum(..) | ty::ty_struct(..) | ty::ty_unboxed_closure(..)\n+                if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &*repr, &mut llty);\n         }\n@@ -310,7 +368,11 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n }\n \n // Want refinements! (Or case classes, I guess\n-pub enum named_ty { a_struct, an_enum }\n+pub enum named_ty {\n+    a_struct,\n+    an_enum,\n+    an_unboxed_closure,\n+}\n \n pub fn llvm_type_name(cx: &CrateContext,\n                       what: named_ty,\n@@ -319,8 +381,9 @@ pub fn llvm_type_name(cx: &CrateContext,\n                       -> String\n {\n     let name = match what {\n-        a_struct => { \"struct\" }\n-        an_enum => { \"enum\" }\n+        a_struct => \"struct\",\n+        an_enum => \"enum\",\n+        an_unboxed_closure => return \"closure\".to_string(),\n     };\n \n     let base = ty::item_path_str(cx.tcx(), did);"}, {"sha": "50563d42e44122bc9fdbb08ac6364139ee894499", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 102, "deletions": 11, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -18,7 +18,7 @@ use lint;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n-use middle::lang_items::OpaqueStructLangItem;\n+use middle::lang_items::{FnMutTraitLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::freevars;\n use middle::resolve;\n@@ -370,6 +370,10 @@ pub struct ctxt {\n \n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n+    /// Records the type of each unboxed closure. The def ID is the ID of the\n+    /// expression defining the unboxed closure.\n+    pub unboxed_closure_types: RefCell<DefIdMap<ClosureTy>>,\n+\n     pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::LintId),\n                                           lint::LevelSource>>,\n \n@@ -454,6 +458,7 @@ pub struct ClosureTy {\n     pub store: TraitStore,\n     pub bounds: BuiltinBounds,\n     pub sig: FnSig,\n+    pub abi: abi::Abi,\n }\n \n /**\n@@ -736,6 +741,7 @@ pub enum sty {\n     ty_closure(Box<ClosureTy>),\n     ty_trait(Box<TyTrait>),\n     ty_struct(DefId, Substs),\n+    ty_unboxed_closure(DefId),\n     ty_tup(Vec<t>),\n \n     ty_param(ParamTy), // type parameter\n@@ -1054,7 +1060,7 @@ pub fn mk_ctxt(s: Session,\n                region_maps: middle::region::RegionMaps,\n                lang_items: middle::lang_items::LanguageItems,\n                stability: stability::Index)\n-            -> ctxt {\n+               -> ctxt {\n     ctxt {\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n@@ -1106,6 +1112,7 @@ pub fn mk_ctxt(s: Session,\n         method_map: RefCell::new(FnvHashMap::new()),\n         vtable_map: RefCell::new(FnvHashMap::new()),\n         dependency_formats: RefCell::new(HashMap::new()),\n+        unboxed_closure_types: RefCell::new(DefIdMap::new()),\n         node_lint_levels: RefCell::new(HashMap::new()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability)\n@@ -1164,7 +1171,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     }\n     match &st {\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n-      &ty_str => {}\n+      &ty_str | &ty_unboxed_closure(_) => {}\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n       // rid of the has_ty_err flag -- likewise for ty_bot (with\n@@ -1429,6 +1436,10 @@ pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: Substs) -> t {\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n+pub fn mk_unboxed_closure(cx: &ctxt, closure_id: ast::DefId) -> t {\n+    mk_t(cx, ty_unboxed_closure(closure_id))\n+}\n+\n pub fn mk_var(cx: &ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n \n pub fn mk_int_var(cx: &ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n@@ -1459,7 +1470,7 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_infer(_) | ty_param(_) | ty_err => {\n+        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(_) | ty_err => {\n         }\n         ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_vec(ref tm, _) => {\n@@ -1567,7 +1578,7 @@ pub fn type_is_vec(ty: t) -> bool {\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) |\n-      ty_vec(_, Some(_)) => true,\n+      ty_vec(_, Some(_)) | ty_unboxed_closure(_) => true,\n       _ => type_is_slice(ty) | type_is_trait(ty)\n     }\n }\n@@ -2082,6 +2093,12 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n+            ty_unboxed_closure(did) => {\n+                let upvars = unboxed_closure_upvars(cx, did);\n+                TypeContents::union(upvars.as_slice(),\n+                                    |f| tc_ty(cx, f.ty, cache))\n+            }\n+\n             ty_tup(ref tys) => {\n                 TypeContents::union(tys.as_slice(),\n                                     |ty| tc_ty(cx, *ty, cache))\n@@ -2323,6 +2340,11 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n                 r\n             }\n \n+            ty_unboxed_closure(did) => {\n+                let upvars = unboxed_closure_upvars(cx, did);\n+                upvars.iter().any(|f| type_requires(cx, seen, r_ty, f.ty))\n+            }\n+\n             ty_tup(ref ts) => {\n                 ts.iter().any(|t| type_requires(cx, seen, r_ty, *t))\n             }\n@@ -2427,6 +2449,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n                 seen.pop();\n                 r\n             }\n+\n             ty_enum(did, ref substs) => {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n@@ -2445,6 +2468,14 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n                 r\n             }\n \n+            ty_unboxed_closure(did) => {\n+                let upvars = unboxed_closure_upvars(cx, did);\n+                find_nonrepresentable(cx,\n+                                      sp,\n+                                      seen,\n+                                      upvars.iter().map(|f| f.ty))\n+            }\n+\n             _ => Representable,\n         }\n     }\n@@ -2655,6 +2686,15 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n     }\n }\n \n+/// Returns the ABI of the given function.\n+pub fn ty_fn_abi(fty: t) -> abi::Abi {\n+    match get(fty).sty {\n+        ty_bare_fn(ref f) => f.abi,\n+        ty_closure(ref f) => f.abi,\n+        _ => fail!(\"ty_fn_abi() called on non-fn type\"),\n+    }\n+}\n+\n // Type accessors for substructures of types\n pub fn ty_fn_args(fty: t) -> Vec<t> {\n     match get(fty).sty {\n@@ -2669,6 +2709,11 @@ pub fn ty_fn_args(fty: t) -> Vec<t> {\n pub fn ty_closure_store(fty: t) -> TraitStore {\n     match get(fty).sty {\n         ty_closure(ref f) => f.store,\n+        ty_unboxed_closure(_) => {\n+            // Close enough for the purposes of all the callers of this\n+            // function (which is soon to be deprecated anyhow).\n+            UniqTraitStore\n+        }\n         ref s => {\n             fail!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n         }\n@@ -2816,11 +2861,14 @@ pub fn adjust_ty(cx: &ctxt,\n                         ty::ty_bare_fn(ref b) => {\n                             ty::mk_closure(\n                                 cx,\n-                                ty::ClosureTy {fn_style: b.fn_style,\n-                                               onceness: ast::Many,\n-                                               store: store,\n-                                               bounds: ty::all_builtin_bounds(),\n-                                               sig: b.sig.clone()})\n+                                ty::ClosureTy {\n+                                    fn_style: b.fn_style,\n+                                    onceness: ast::Many,\n+                                    store: store,\n+                                    bounds: ty::all_builtin_bounds(),\n+                                    sig: b.sig.clone(),\n+                                    abi: b.abi,\n+                                })\n                         }\n                         ref b => {\n                             cx.sess.bug(\n@@ -2990,6 +3038,14 @@ pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n         typeck::MethodStatic(did) => {\n             ty::lookup_item_type(tcx, did).generics.types.clone()\n         }\n+        typeck::MethodStaticUnboxedClosure(_) => {\n+            match tcx.lang_items.require(FnMutTraitLangItem) {\n+                Ok(def_id) => {\n+                    lookup_trait_def(tcx, def_id).generics.types.clone()\n+                }\n+                Err(s) => tcx.sess.fatal(s.as_slice()),\n+            }\n+        }\n         typeck::MethodParam(typeck::MethodParam{trait_id: trt_id,\n                                                 method_num: n_mth, ..}) |\n         typeck::MethodObject(typeck::MethodObject{trait_id: trt_id,\n@@ -3104,6 +3160,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprMatch(..) |\n         ast::ExprFnBlock(..) |\n         ast::ExprProc(..) |\n+        ast::ExprUnboxedFn(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n         ast::ExprVstore(_, ast::ExprVstoreSlice) |\n@@ -3250,6 +3307,7 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n         ty_struct(id, _) => {\n             format!(\"struct {}\", item_path_str(cx, id))\n         }\n+        ty_unboxed_closure(_) => \"closure\".to_string(),\n         ty_tup(_) => \"tuple\".to_string(),\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n@@ -3617,7 +3675,8 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n     match get(ty).sty {\n         ty_trait(box TyTrait { def_id: id, .. }) |\n         ty_struct(id, _) |\n-        ty_enum(id, _) => Some(id),\n+        ty_enum(id, _) |\n+        ty_unboxed_closure(id) => Some(id),\n         _ => None\n     }\n }\n@@ -4046,6 +4105,34 @@ pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)\n     }).collect()\n }\n \n+pub struct UnboxedClosureUpvar {\n+    pub def: def::Def,\n+    pub span: Span,\n+    pub ty: t,\n+}\n+\n+// Returns a list of `UnboxedClosureUpvar`s for each upvar.\n+pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId)\n+                              -> Vec<UnboxedClosureUpvar> {\n+    if closure_id.krate == ast::LOCAL_CRATE {\n+        match tcx.freevars.borrow().find(&closure_id.node) {\n+            None => tcx.sess.bug(\"no freevars for unboxed closure?!\"),\n+            Some(ref freevars) => {\n+                freevars.iter().map(|freevar| {\n+                    let freevar_def_id = freevar.def.def_id();\n+                    UnboxedClosureUpvar {\n+                        def: freevar.def,\n+                        span: freevar.span,\n+                        ty: node_id_to_type(tcx, freevar_def_id.node),\n+                    }\n+                }).collect()\n+            }\n+        }\n+    } else {\n+        tcx.sess.bug(\"unimplemented cross-crate closure upvars\")\n+    }\n+}\n+\n pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n@@ -4623,6 +4710,10 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             }\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n+            ty_unboxed_closure(d) => {\n+                byte!(24);\n+                did(&mut state, d);\n+            }\n         }\n     });\n "}, {"sha": "e2b984959060c2b270e9536b509fbcaaa67e512b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -220,6 +220,9 @@ impl TypeFoldable for typeck::vtable_origin {\n             typeck::vtable_param(n, b) => {\n                 typeck::vtable_param(n, b)\n             }\n+            typeck::vtable_unboxed_closure(def_id) => {\n+                typeck::vtable_unboxed_closure(def_id)\n+            }\n             typeck::vtable_error => {\n                 typeck::vtable_error\n             }\n@@ -326,6 +329,7 @@ pub fn super_fold_closure_ty<T:TypeFolder>(this: &mut T,\n         fn_style: fty.fn_style,\n         onceness: fty.onceness,\n         bounds: fty.bounds,\n+        abi: fty.abi,\n     }\n }\n \n@@ -388,6 +392,9 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_struct(did, ref substs) => {\n             ty::ty_struct(did, substs.fold_with(this))\n         }\n+        ty::ty_unboxed_closure(did) => {\n+            ty::ty_unboxed_closure(did)\n+        }\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n         ty::ty_err | ty::ty_infer(_) |"}, {"sha": "56fda065796778ea7b330c8f872c3984ad5a2330", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -762,6 +762,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             bounds,\n                                             store,\n                                             &*f.decl,\n+                                            abi::Rust,\n                                             None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n@@ -780,6 +781,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             bounds,\n                                             ty::UniqTraitStore,\n                                             &*f.decl,\n+                                            abi::Rust,\n                                             None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n@@ -879,9 +881,9 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             }\n             ast::TyInfer => {\n                 // TyInfer also appears as the type of arguments or return\n-                // values in a ExprFnBlock or ExprProc, or as the type of\n-                // local variables. Both of these cases are handled specially\n-                // and will not descend into this routine.\n+                // values in a ExprFnBlock, ExprProc, or ExprUnboxedFn, or as\n+                // the type of local variables. Both of these cases are\n+                // handled specially and will not descend into this routine.\n                 this.ty_infer(ast_ty.span)\n             }\n         }\n@@ -911,7 +913,8 @@ pub fn ty_of_method<AC:AstConv>(\n                     fn_style: ast::FnStyle,\n                     untransformed_self_ty: ty::t,\n                     explicit_self: ast::ExplicitSelf,\n-                    decl: &ast::FnDecl)\n+                    decl: &ast::FnDecl,\n+                    abi: abi::Abi)\n                     -> (ty::BareFnTy, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n@@ -921,7 +924,7 @@ pub fn ty_of_method<AC:AstConv>(\n         ty_of_method_or_bare_fn(this,\n                                 id,\n                                 fn_style,\n-                                abi::Rust,\n+                                abi,\n                                 self_info,\n                                 decl);\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n@@ -1083,6 +1086,7 @@ pub fn ty_of_closure<AC:AstConv>(\n     bounds: ty::BuiltinBounds,\n     store: ty::TraitStore,\n     decl: &ast::FnDecl,\n+    abi: abi::Abi,\n     expected_sig: Option<ty::FnSig>)\n     -> ty::ClosureTy\n {\n@@ -1117,6 +1121,7 @@ pub fn ty_of_closure<AC:AstConv>(\n         onceness: onceness,\n         store: store,\n         bounds: bounds,\n+        abi: abi,\n         sig: ty::FnSig {binder_id: id,\n                         inputs: input_tys,\n                         output: output_ty,"}, {"sha": "1805c18eaf10c9771011e12430b51e488b52e210", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 97, "deletions": 5, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -87,10 +87,11 @@ use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, PreferMutLvalue, impl_self_ty};\n use middle::typeck::check;\n+use middle::typeck::infer::MiscVariable;\n use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n use middle::typeck::{MethodOrigin, MethodParam};\n-use middle::typeck::{MethodStatic, MethodObject};\n+use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject};\n use middle::typeck::{param_index};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::TypeAndSubsts;\n@@ -341,7 +342,7 @@ struct Candidate {\n #[deriving(Clone)]\n pub enum RcvrMatchCondition {\n     RcvrMatchesIfObject(ast::DefId),\n-    RcvrMatchesIfSubtype(ty::t)\n+    RcvrMatchesIfSubtype(ty::t),\n }\n \n impl<'a> LookupContext<'a> {\n@@ -441,7 +442,9 @@ impl<'a> LookupContext<'a> {\n                     }\n                     _ => {}\n                 },\n-                ty_enum(did, _) | ty_struct(did, _) => {\n+                ty_enum(did, _) |\n+                ty_struct(did, _) |\n+                ty_unboxed_closure(did) => {\n                     if self.check_traits == CheckTraitsAndInherentMethods {\n                         self.push_inherent_impl_candidates_for_type(did);\n                     }\n@@ -465,6 +468,10 @@ impl<'a> LookupContext<'a> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n                 }\n+                ty_unboxed_closure(closure_did) => {\n+                    self.push_unboxed_closure_call_candidates_if_applicable(\n+                        closure_did);\n+                }\n                 _ => { /* No bound methods in these types */ }\n             }\n \n@@ -497,11 +504,89 @@ impl<'a> LookupContext<'a> {\n         let opt_applicable_traits = self.fcx.ccx.trait_map.find(&expr_id);\n         for applicable_traits in opt_applicable_traits.move_iter() {\n             for trait_did in applicable_traits.iter() {\n+                debug!(\"push_extension_candidates() found trait: {}\",\n+                       if trait_did.krate == ast::LOCAL_CRATE {\n+                           self.fcx.ccx.tcx.map.node_to_string(trait_did.node)\n+                       } else {\n+                           \"(external)\".to_string()\n+                       });\n                 self.push_extension_candidate(*trait_did);\n             }\n         }\n     }\n \n+    fn push_unboxed_closure_call_candidate_if_applicable(\n+            &mut self,\n+            trait_did: DefId,\n+            closure_did: DefId,\n+            closure_function_type: &ClosureTy) {\n+        let method =\n+            ty::trait_methods(self.tcx(), trait_did).get(0).clone();\n+\n+        let vcx = self.fcx.vtable_context();\n+        let region_params =\n+            vec!(vcx.infcx.next_region_var(MiscVariable(self.span)));\n+\n+        // Get the tupled type of the arguments.\n+        let arguments_type = *closure_function_type.sig.inputs.get(0);\n+        let return_type = closure_function_type.sig.output;\n+\n+        let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),\n+                                                          closure_did);\n+        self.extension_candidates.push(Candidate {\n+            rcvr_match_condition:\n+                RcvrMatchesIfSubtype(unboxed_closure_type),\n+            rcvr_substs: subst::Substs::new_trait(\n+                vec![arguments_type, return_type],\n+                region_params,\n+                *vcx.infcx.next_ty_vars(1).get(0)),\n+            method_ty: method,\n+            origin: MethodStaticUnboxedClosure(closure_did),\n+        });\n+    }\n+\n+    fn push_unboxed_closure_call_candidates_if_applicable(\n+            &mut self,\n+            closure_did: DefId) {\n+        // FIXME(pcwalton): Try `Fn` and `FnOnce` too.\n+        let trait_did = match self.tcx().lang_items.fn_mut_trait() {\n+            Some(trait_did) => trait_did,\n+            None => return,\n+        };\n+\n+        match self.tcx()\n+                  .unboxed_closure_types\n+                  .borrow()\n+                  .find(&closure_did) {\n+            None => {}  // Fall through to try inherited.\n+            Some(closure_function_type) => {\n+                self.push_unboxed_closure_call_candidate_if_applicable(\n+                    trait_did,\n+                    closure_did,\n+                    closure_function_type);\n+                return\n+            }\n+        }\n+\n+        match self.fcx\n+                  .inh\n+                  .unboxed_closure_types\n+                  .borrow()\n+                  .find(&closure_did) {\n+            Some(closure_function_type) => {\n+                self.push_unboxed_closure_call_candidate_if_applicable(\n+                    trait_did,\n+                    closure_did,\n+                    closure_function_type);\n+                return\n+            }\n+            None => {}\n+        }\n+\n+        self.tcx().sess.bug(\"didn't find unboxed closure type in tcx map or \\\n+                             inherited map, so there\")\n+    }\n+\n     fn push_inherent_candidates_from_object(&mut self,\n                                             did: DefId,\n                                             substs: &subst::Substs) {\n@@ -926,7 +1011,8 @@ impl<'a> LookupContext<'a> {\n             ty_infer(FloatVar(_)) |\n             ty_param(..) | ty_nil | ty_bot | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n-            ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) | ty_tup(..) |\n+            ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) |\n+            ty_unboxed_closure(..) | ty_tup(..) |\n             ty_str | ty_vec(..) | ty_trait(..) | ty_closure(..) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [MutImmutable, MutMutable],\n@@ -1212,7 +1298,9 @@ impl<'a> LookupContext<'a> {\n          */\n \n         match candidate.origin {\n-            MethodStatic(..) | MethodParam(..) => {\n+            MethodStatic(..) |\n+            MethodParam(..) |\n+            MethodStaticUnboxedClosure(..) => {\n                 return; // not a call to a trait instance\n             }\n             MethodObject(..) => {}\n@@ -1268,6 +1356,7 @@ impl<'a> LookupContext<'a> {\n             MethodStatic(method_id) => {\n                 bad = self.tcx().destructors.borrow().contains(&method_id);\n             }\n+            MethodStaticUnboxedClosure(_) => bad = false,\n             // FIXME: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n             MethodParam(MethodParam { trait_id: trait_id, .. }) |\n@@ -1409,6 +1498,9 @@ impl<'a> LookupContext<'a> {\n                 };\n                 self.report_static_candidate(idx, did)\n             }\n+            MethodStaticUnboxedClosure(did) => {\n+                self.report_static_candidate(idx, did)\n+            }\n             MethodParam(ref mp) => {\n                 self.report_param_candidate(idx, (*mp).trait_id)\n             }"}, {"sha": "557fd522fa918522b826af21349dd191a05e81ff", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -114,7 +114,7 @@ use lint;\n use util::common::{block_query, indenter, loop_query};\n use util::ppaux;\n use util::ppaux::{UserString, Repr};\n-use util::nodemap::{FnvHashMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n@@ -167,6 +167,7 @@ pub struct Inherited<'a> {\n     method_map: MethodMap,\n     vtable_map: vtable_map,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n+    unboxed_closure_types: RefCell<DefIdMap<ty::ClosureTy>>,\n }\n \n /// When type-checking an expression, we propagate downward\n@@ -273,6 +274,7 @@ impl<'a> Inherited<'a> {\n             method_map: RefCell::new(FnvHashMap::new()),\n             vtable_map: RefCell::new(FnvHashMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n+            unboxed_closure_types: RefCell::new(DefIdMap::new()),\n         }\n     }\n }\n@@ -1251,7 +1253,8 @@ impl<'a> FnCtxt<'a> {\n     pub fn vtable_context<'a>(&'a self) -> VtableContext<'a> {\n         VtableContext {\n             infcx: self.infcx(),\n-            param_env: &self.inh.param_env\n+            param_env: &self.inh.param_env,\n+            unboxed_closure_types: &self.inh.unboxed_closure_types,\n         }\n     }\n }\n@@ -1861,7 +1864,8 @@ fn check_argument_types(fcx: &FnCtxt,\n         for (i, arg) in args.iter().take(t).enumerate() {\n             let is_block = match arg.node {\n                 ast::ExprFnBlock(..) |\n-                ast::ExprProc(..) => true,\n+                ast::ExprProc(..) |\n+                ast::ExprUnboxedFn(..) => true,\n                 _ => false\n             };\n \n@@ -2514,6 +2518,47 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         })\n     }\n \n+    fn check_unboxed_closure(fcx: &FnCtxt,\n+                             expr: &ast::Expr,\n+                             decl: &ast::FnDecl,\n+                             body: ast::P<ast::Block>) {\n+        // The `RegionTraitStore` is a lie, but we ignore it so it doesn't\n+        // matter.\n+        //\n+        // FIXME(pcwalton): Refactor this API.\n+        let mut fn_ty = astconv::ty_of_closure(\n+            fcx,\n+            expr.id,\n+            ast::NormalFn,\n+            ast::Many,\n+            ty::empty_builtin_bounds(),\n+            ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n+            decl,\n+            abi::RustCall,\n+            None);\n+\n+        let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n+                                                  local_def(expr.id));\n+        fcx.write_ty(expr.id, closure_type);\n+\n+        check_fn(fcx.ccx,\n+                 ast::NormalFn,\n+                 &fn_ty.sig,\n+                 decl,\n+                 expr.id,\n+                 &*body,\n+                 fcx.inh);\n+\n+        // Tuple up the arguments and insert the resulting function type into\n+        // the `unboxed_closure_types` table.\n+        fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n+\n+        fcx.inh\n+           .unboxed_closure_types\n+           .borrow_mut()\n+           .insert(local_def(expr.id), fn_ty);\n+    }\n+\n     fn check_expr_fn(fcx: &FnCtxt,\n                      expr: &ast::Expr,\n                      store: ty::TraitStore,\n@@ -2577,6 +2622,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                            expected_bounds,\n                                            store,\n                                            decl,\n+                                           abi::Rust,\n                                            expected_sig);\n         let fty_sig = fn_ty.sig.clone();\n         let fty = ty::mk_closure(tcx, fn_ty);\n@@ -2593,8 +2639,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ty::UniqTraitStore => (ast::NormalFn, expr.id)\n         };\n \n-        check_fn(fcx.ccx, inherited_style, &fty_sig,\n-                 &*decl, id, &*body, fcx.inh);\n+        check_fn(fcx.ccx,\n+                 inherited_style,\n+                 &fty_sig,\n+                 decl,\n+                 id,\n+                 &*body,\n+                 fcx.inh);\n     }\n \n \n@@ -3241,6 +3292,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                       body.clone(),\n                       expected);\n       }\n+      ast::ExprUnboxedFn(ref decl, ref body) => {\n+        check_unboxed_closure(fcx,\n+                              expr,\n+                              &**decl,\n+                              *body);\n+      }\n       ast::ExprProc(ref decl, ref body) => {\n         check_expr_fn(fcx,\n                       expr,"}, {"sha": "22d52d0b7d2a0e4752ec0f3a760ad15ab9358915", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -587,7 +587,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprFnBlock(_, ref body) | ast::ExprProc(_, ref body) => {\n+        ast::ExprFnBlock(_, ref body) |\n+        ast::ExprProc(_, ref body) |\n+        ast::ExprUnboxedFn(_, ref body) => {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n "}, {"sha": "ea82a62d6c684f39b58c6683fe3ec2e740a743b1", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 104, "deletions": 10, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -15,21 +15,23 @@ use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n+use middle::typeck::check::regionmanip;\n use middle::typeck::check::writeback;\n use middle::typeck::infer::fixup_err_to_string;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n-use middle::typeck::{vtable_origin, vtable_res, vtable_param_res};\n-use middle::typeck::{vtable_static, vtable_param, vtable_error};\n-use middle::typeck::{param_index};\n-use middle::typeck::MethodCall;\n-use middle::typeck::TypeAndSubsts;\n+use middle::typeck::{MethodCall, TypeAndSubsts};\n+use middle::typeck::{param_index, vtable_error, vtable_origin, vtable_param};\n+use middle::typeck::{vtable_param_res, vtable_res, vtable_static};\n+use middle::typeck::{vtable_unboxed_closure};\n use middle::subst;\n use middle::subst::{Subst, VecPerParamSpace};\n use util::common::indenter;\n+use util::nodemap::DefIdMap;\n use util::ppaux;\n use util::ppaux::Repr;\n \n+use std::cell::RefCell;\n use std::rc::Rc;\n use std::collections::HashSet;\n use syntax::ast;\n@@ -69,6 +71,7 @@ use syntax::visit::Visitor;\n pub struct VtableContext<'a> {\n     pub infcx: &'a infer::InferCtxt<'a>,\n     pub param_env: &'a ty::ParameterEnvironment,\n+    pub unboxed_closure_types: &'a RefCell<DefIdMap<ty::ClosureTy>>,\n }\n \n impl<'a> VtableContext<'a> {\n@@ -248,10 +251,13 @@ fn lookup_vtable(vcx: &VtableContext,\n         ty::ty_param(ParamTy {space, idx: n, ..}) => {\n             let env_bounds = &vcx.param_env.bounds;\n             let type_param_bounds = &env_bounds.get(space, n).trait_bounds;\n-            lookup_vtable_from_bounds(vcx, span,\n+            lookup_vtable_from_bounds(vcx,\n+                                      span,\n                                       type_param_bounds.as_slice(),\n-                                      param_index { space: space,\n-                                                    index: n },\n+                                      param_index {\n+                                          space: space,\n+                                          index: n,\n+                                      },\n                                       trait_ref.clone())\n         }\n \n@@ -297,6 +303,75 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n     ret\n }\n \n+fn search_for_unboxed_closure_vtable(vcx: &VtableContext,\n+                                     span: Span,\n+                                     ty: ty::t,\n+                                     trait_ref: Rc<ty::TraitRef>)\n+                                     -> Option<vtable_origin> {\n+    let tcx = vcx.tcx();\n+    let closure_def_id = match ty::get(ty).sty {\n+        ty::ty_unboxed_closure(closure_def_id) => closure_def_id,\n+        _ => return None,\n+    };\n+\n+    let fn_traits = [\n+        tcx.lang_items.fn_trait(),\n+        tcx.lang_items.fn_mut_trait(),\n+        tcx.lang_items.fn_once_trait()\n+    ];\n+    for fn_trait in fn_traits.iter() {\n+        match *fn_trait {\n+            Some(ref fn_trait) if *fn_trait == trait_ref.def_id => {}\n+            _ => continue,\n+        };\n+\n+        // Check to see whether the argument and return types match.\n+        let unboxed_closure_types = tcx.unboxed_closure_types.borrow();\n+        let closure_type = match unboxed_closure_types.find(&closure_def_id) {\n+            Some(closure_type) => (*closure_type).clone(),\n+            None => {\n+                // Try the inherited unboxed closure type map.\n+                let unboxed_closure_types = vcx.unboxed_closure_types\n+                                               .borrow();\n+                match unboxed_closure_types.find(&closure_def_id) {\n+                    Some(closure_type) => (*closure_type).clone(),\n+                    None => {\n+                        tcx.sess.span_bug(span,\n+                                          \"didn't find unboxed closure type \\\n+                                           in tcx map or inh map\")\n+                    }\n+                }\n+            }\n+        };\n+\n+        // FIXME(pcwalton): This is a bogus thing to do, but\n+        // it'll do for now until we get the new trait-bound\n+        // region skolemization working.\n+        let (_, new_signature) =\n+            regionmanip::replace_late_bound_regions_in_fn_sig(\n+                tcx,\n+                &closure_type.sig,\n+                |br| {\n+                    vcx.infcx.next_region_var(infer::LateBoundRegion(span,\n+                                                                     br))\n+                });\n+\n+        let arguments_tuple = *new_signature.inputs.get(0);\n+        let corresponding_trait_ref = Rc::new(ty::TraitRef {\n+            def_id: trait_ref.def_id,\n+            substs: subst::Substs::new_trait(\n+                vec![arguments_tuple, new_signature.output],\n+                Vec::new(),\n+                ty)\n+        });\n+\n+        relate_trait_refs(vcx, span, corresponding_trait_ref, trait_ref);\n+        return Some(vtable_unboxed_closure(closure_def_id))\n+    }\n+\n+    None\n+}\n+\n fn search_for_vtable(vcx: &VtableContext,\n                      span: Span,\n                      ty: ty::t,\n@@ -306,6 +381,18 @@ fn search_for_vtable(vcx: &VtableContext,\n     debug!(\"nrc - search_for_vtable\");\n     let tcx = vcx.tcx();\n \n+    // First, check to see whether this is a call to the `call` method of an\n+    // unboxed closure. If so, and the arguments match, we're done.\n+    match search_for_unboxed_closure_vtable(vcx,\n+                                            span,\n+                                            ty,\n+                                            trait_ref.clone()) {\n+        Some(vtable_origin) => return Some(vtable_origin),\n+        None => {}\n+    }\n+\n+    // Nope. Continue.\n+\n     let mut found = Vec::new();\n     let mut impls_seen = HashSet::new();\n \n@@ -799,7 +886,12 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n     debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(tcx));\n \n     let infcx = &infer::new_infer_ctxt(tcx);\n-    let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n+    let unboxed_closure_types = RefCell::new(DefIdMap::new());\n+    let vcx = VtableContext {\n+        infcx: infcx,\n+        param_env: &param_env,\n+        unboxed_closure_types: &unboxed_closure_types,\n+    };\n \n     // Resolve the vtables for the trait reference on the impl.  This\n     // serves many purposes, best explained by example. Imagine we have:\n@@ -847,9 +939,11 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n                             substs: &subst::Substs) -> vtable_res {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n+    let unboxed_closure_types = RefCell::new(DefIdMap::new());\n     let vcx = VtableContext {\n         infcx: &infer::new_infer_ctxt(tcx),\n-        param_env: &ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id)\n+        param_env: &ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id),\n+        unboxed_closure_types: &unboxed_closure_types,\n     };\n \n     lookup_vtables(&vcx,"}, {"sha": "d802e3d14433c3590a10e319b7d328e0ca95af56", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -30,7 +30,7 @@ use util::ppaux::Repr;\n use std::cell::Cell;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::codemap::{DUMMY_SP, Span};\n use syntax::print::pprust::pat_to_string;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -43,6 +43,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     let mut wbcx = WritebackCx::new(fcx);\n     wbcx.visit_expr(e, ());\n     wbcx.visit_upvar_borrow_map();\n+    wbcx.visit_unboxed_closure_types();\n }\n \n pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n@@ -61,6 +62,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n         }\n     }\n     wbcx.visit_upvar_borrow_map();\n+    wbcx.visit_unboxed_closure_types();\n }\n \n pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n@@ -130,7 +132,9 @@ impl<'cx> Visitor<()> for WritebackCx<'cx> {\n                                     MethodCall::expr(e.id));\n \n         match e.node {\n-            ast::ExprFnBlock(ref decl, _) | ast::ExprProc(ref decl, _) => {\n+            ast::ExprFnBlock(ref decl, _) |\n+            ast::ExprProc(ref decl, _) |\n+            ast::ExprUnboxedFn(ref decl, _) => {\n                 for input in decl.inputs.iter() {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);\n@@ -201,6 +205,26 @@ impl<'cx> WritebackCx<'cx> {\n         }\n     }\n \n+    fn visit_unboxed_closure_types(&self) {\n+        if self.fcx.writeback_errors.get() {\n+            return\n+        }\n+\n+        for (def_id, closure_ty) in self.fcx\n+                                        .inh\n+                                        .unboxed_closure_types\n+                                        .borrow()\n+                                        .iter() {\n+            let closure_ty = self.resolve(closure_ty,\n+                                          ResolvingUnboxedClosure(*def_id));\n+            self.fcx\n+                .tcx()\n+                .unboxed_closure_types\n+                .borrow_mut()\n+                .insert(*def_id, closure_ty);\n+        }\n+    }\n+\n     fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n         // Resolve any borrowings for the node with id `id`\n         self.visit_adjustments(reason, id);\n@@ -332,6 +356,7 @@ enum ResolveReason {\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n     ResolvingImplRes(Span),\n+    ResolvingUnboxedClosure(ast::DefId),\n }\n \n impl ResolveReason {\n@@ -344,6 +369,13 @@ impl ResolveReason {\n                 ty::expr_span(tcx, upvar_id.closure_expr_id)\n             }\n             ResolvingImplRes(s) => s,\n+            ResolvingUnboxedClosure(did) => {\n+                if did.krate == ast::LOCAL_CRATE {\n+                    ty::expr_span(tcx, did.node)\n+                } else {\n+                    DUMMY_SP\n+                }\n+            }\n         }\n     }\n }\n@@ -441,6 +473,13 @@ impl<'cx> Resolver<'cx> {\n                                   \"cannot determine a type for impl \\\n                                    supertrait\");\n                 }\n+\n+                ResolvingUnboxedClosure(_) => {\n+                    let span = self.reason.span(self.tcx);\n+                    self.tcx.sess.span_err(span,\n+                                           \"cannot determine a type for this \\\n+                                            unboxed closure\")\n+                }\n             }\n         }\n     }"}, {"sha": "9e6d059650cc5b0aede25a72194cde54fcc340d2", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -25,7 +25,8 @@ use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n-use middle::ty::{ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n+use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n+use middle::ty::{ty_closure};\n use middle::ty::type_is_ty_var;\n use middle::subst::Subst;\n use middle::ty;\n@@ -75,7 +76,7 @@ fn get_base_type(inference_context: &InferCtxt,\n     }\n \n     match get(resolved_type).sty {\n-        ty_enum(..) | ty_struct(..) => {\n+        ty_enum(..) | ty_struct(..) | ty_unboxed_closure(..) => {\n             debug!(\"(getting base type) found base type\");\n             Some(resolved_type)\n         }\n@@ -111,7 +112,8 @@ fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n     ty::walk_ty(original_type, |t| {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n-            ty_struct(def_id, _) => {\n+            ty_struct(def_id, _) |\n+            ty_unboxed_closure(def_id) => {\n                 if def_id.krate == ast::LOCAL_CRATE {\n                     found_nominal = true;\n                 }\n@@ -154,7 +156,8 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n         Some(base_type) => {\n             match get(base_type).sty {\n                 ty_enum(def_id, _) |\n-                ty_struct(def_id, _) => {\n+                ty_struct(def_id, _) |\n+                ty_unboxed_closure(def_id) => {\n                     Some(def_id)\n                 }\n                 ty_rptr(_, ty::mt {ty, ..}) | ty_uniq(ty) => match ty::get(ty).sty {\n@@ -691,7 +694,8 @@ impl<'a> CoherenceChecker<'a> {\n             let self_type = self.get_self_type_for_implementation(impl_did);\n             match ty::get(self_type.ty).sty {\n                 ty::ty_enum(type_def_id, _) |\n-                ty::ty_struct(type_def_id, _) => {\n+                ty::ty_struct(type_def_id, _) |\n+                ty::ty_unboxed_closure(type_def_id) => {\n                     tcx.destructor_for_type.borrow_mut().insert(type_def_id,\n                                                                 method_def_id);\n                     tcx.destructors.borrow_mut().insert(method_def_id);"}, {"sha": "5fd9b85d69aa044f960dffc965d0bb9e81ebc2e5", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -208,9 +208,16 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                         let ty_method = Rc::new(match m {\n                             &ast::Required(ref m) => {\n                                 ty_method_of_trait_method(\n-                                    ccx, trait_id, &trait_def.generics,\n-                                    &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.fn_style, &*m.decl)\n+                                    ccx,\n+                                    trait_id,\n+                                    &trait_def.generics,\n+                                    &m.id,\n+                                    &m.ident,\n+                                    &m.explicit_self,\n+                                    m.abi,\n+                                    &m.generics,\n+                                    &m.fn_style,\n+                                    &*m.decl)\n                             }\n \n                             &ast::Provided(ref m) => {\n@@ -221,6 +228,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                     &m.id,\n                                     &m.pe_ident(),\n                                     m.pe_explicit_self(),\n+                                    m.pe_abi(),\n                                     m.pe_generics(),\n                                     &m.pe_fn_style(),\n                                     &*m.pe_fn_decl())\n@@ -272,25 +280,25 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  m_id: &ast::NodeId,\n                                  m_ident: &ast::Ident,\n                                  m_explicit_self: &ast::ExplicitSelf,\n+                                 m_abi: abi::Abi,\n                                  m_generics: &ast::Generics,\n                                  m_fn_style: &ast::FnStyle,\n-                                 m_decl: &ast::FnDecl) -> ty::Method\n-    {\n-        let trait_self_ty = ty::mk_param(this.tcx,\n-                                         subst::SelfSpace,\n-                                         0,\n-                                         local_def(trait_id));\n-        let ty_generics = ty_generics_for_fn_or_method(\n-            this,\n-            m_generics,\n-            (*trait_generics).clone());\n+                                 m_decl: &ast::FnDecl)\n+                                 -> ty::Method {\n+        let trait_self_ty = ty::mk_self_type(this.tcx, local_def(trait_id));\n+\n         let (fty, explicit_self_category) =\n             astconv::ty_of_method(this,\n                                   *m_id,\n                                   *m_fn_style,\n                                   trait_self_ty,\n                                   *m_explicit_self,\n-                                  m_decl);\n+                                  m_decl,\n+                                  m_abi);\n+        let ty_generics =\n+            ty_generics_for_fn_or_method(this,\n+                                         m_generics,\n+                                         (*trait_generics).clone());\n         ty::Method::new(\n             *m_ident,\n             ty_generics,\n@@ -381,15 +389,29 @@ fn convert_methods(ccx: &CrateCtxt,\n                     untransformed_rcvr_ty: ty::t,\n                     rcvr_ty_generics: &ty::Generics,\n                     rcvr_visibility: ast::Visibility)\n-                    -> ty::Method\n-    {\n+                    -> ty::Method {\n+        // FIXME(pcwalton): Hack until we have syntax in stage0 for snapshots.\n+        let real_abi = match container {\n+            ty::TraitContainer(trait_id) => {\n+                if ccx.tcx.lang_items.fn_trait() == Some(trait_id) ||\n+                        ccx.tcx.lang_items.fn_mut_trait() == Some(trait_id) ||\n+                        ccx.tcx.lang_items.fn_once_trait() == Some(trait_id) {\n+                    abi::RustCall\n+                } else {\n+                    m.pe_abi()\n+                }\n+            }\n+            _ => m.pe_abi(),\n+        };\n+\n         let (fty, explicit_self_category) =\n             astconv::ty_of_method(ccx,\n                                   m.id,\n                                   m.pe_fn_style(),\n                                   untransformed_rcvr_ty,\n                                   *m.pe_explicit_self(),\n-                                  &*m.pe_fn_decl());\n+                                  &*m.pe_fn_decl(),\n+                                  real_abi);\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl"}, {"sha": "1aae97d3d83e9266a68d0b2a536dbcdb77772829", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -223,12 +223,14 @@ pub trait Combine {\n         let onceness = if_ok!(self.oncenesses(a.onceness, b.onceness));\n         let bounds = if_ok!(self.bounds(a.bounds, b.bounds));\n         let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n+        let abi = if_ok!(self.abi(a.abi, b.abi));\n         Ok(ty::ClosureTy {\n             fn_style: fn_style,\n             onceness: onceness,\n             store: store,\n             bounds: bounds,\n-            sig: sig\n+            sig: sig,\n+            abi: abi,\n         })\n     }\n \n@@ -490,6 +492,11 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n             Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n+      (&ty::ty_unboxed_closure(a_id), &ty::ty_unboxed_closure(b_id))\n+      if a_id == b_id => {\n+          Ok(ty::mk_unboxed_closure(tcx, a_id))\n+      }\n+\n       (&ty::ty_box(a_inner), &ty::ty_box(b_inner)) => {\n         this.tys(a_inner, b_inner).and_then(|typ| Ok(ty::mk_box(tcx, typ)))\n       }"}, {"sha": "aebdb5943826afe1a4724df70914a9d28df24448", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -97,6 +97,9 @@ pub enum MethodOrigin {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n \n+    // fully statically resolved unboxed closure invocation\n+    MethodStaticUnboxedClosure(ast::DefId),\n+\n     // method invoked on a type parameter with a bounded trait\n     MethodParam(MethodParam),\n \n@@ -232,6 +235,12 @@ pub enum vtable_origin {\n      */\n     vtable_param(param_index, uint),\n \n+    /*\n+      Vtable automatically generated for an unboxed closure. The def ID is the\n+      ID of the closure expression.\n+     */\n+    vtable_unboxed_closure(ast::DefId),\n+\n     /*\n       Asked to determine the vtable for ty_err. This is the value used\n       for the vtables of `Self` in a virtual call like `foo.bar()`\n@@ -256,6 +265,10 @@ impl Repr for vtable_origin {\n                 format!(\"vtable_param({:?}, {:?})\", x, y)\n             }\n \n+            vtable_unboxed_closure(def_id) => {\n+                format!(\"vtable_unboxed_closure({})\", def_id)\n+            }\n+\n             vtable_error => {\n                 format!(\"vtable_error\")\n             }"}, {"sha": "d230b08096641c623c5db945a77720a35b332da9", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -715,7 +715,7 @@ impl<'a> ConstraintContext<'a> {\n         match ty::get(ty).sty {\n             ty::ty_nil | ty::ty_bot | ty::ty_bool |\n             ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n-            ty::ty_float(_) | ty::ty_str => {\n+            ty::ty_float(_) | ty::ty_str | ty::ty_unboxed_closure(..) => {\n                 /* leaf type -- noop */\n             }\n "}, {"sha": "c3986d01d3da5ef74c8d296f0985ba43fce246d3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -21,6 +21,7 @@ use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n+use middle::ty::{ty_unboxed_closure};\n use middle::ty;\n use middle::typeck;\n use middle::typeck::infer;\n@@ -414,6 +415,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n                   bound_str)\n       }\n       ty_str => \"str\".to_string(),\n+      ty_unboxed_closure(..) => \"closure\".to_string(),\n       ty_vec(ref mt, sz) => {\n           match sz {\n               Some(n) => {\n@@ -878,6 +880,9 @@ impl Repr for typeck::MethodOrigin {\n             &typeck::MethodStatic(def_id) => {\n                 format!(\"MethodStatic({})\", def_id.repr(tcx))\n             }\n+            &typeck::MethodStaticUnboxedClosure(def_id) => {\n+                format!(\"MethodStaticUnboxedClosure({})\", def_id.repr(tcx))\n+            }\n             &typeck::MethodParam(ref p) => {\n                 p.repr(tcx)\n             }"}, {"sha": "cb9519b1eb8157f86b0b5c20530d620b2e14b5fa", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -239,6 +239,7 @@ mod svh_visitor {\n         SawExprWhile,\n         SawExprMatch,\n         SawExprFnBlock,\n+        SawExprUnboxedFn,\n         SawExprProc,\n         SawExprBlock,\n         SawExprAssign,\n@@ -270,6 +271,7 @@ mod svh_visitor {\n             ExprLoop(_, id)          => SawExprLoop(id.map(content)),\n             ExprMatch(..)            => SawExprMatch,\n             ExprFnBlock(..)          => SawExprFnBlock,\n+            ExprUnboxedFn(..)        => SawExprUnboxedFn,\n             ExprProc(..)             => SawExprProc,\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,"}, {"sha": "4ea4958e544ae0f1720697af779f01aa2f82557f", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -1944,6 +1944,14 @@ pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n     }\n }\n \n+/// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n+pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n+    unsafe {\n+        assert!(index < LLVMCountParams(llfn));\n+        LLVMGetParam(llfn, index)\n+    }\n+}\n+\n // FIXME #15460 - create a public function that actually calls our\n // static LLVM symbols. Otherwise the linker will just throw llvm\n // away.  We're just calling lots of stuff until we transitively get"}, {"sha": "9f5df205aa4c36d608eda02ce6c2437b6c779fc3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -1301,6 +1301,8 @@ impl Clean<Type> for ty::t {\n                 }\n             }\n \n+            ty::ty_unboxed_closure(..) => Primitive(Unit), // FIXME(pcwalton)\n+\n             ty::ty_infer(..) => fail!(\"ty_infer\"),\n             ty::ty_err => fail!(\"ty_err\"),\n         }"}, {"sha": "6f809383620494f4cb58ae940a4b0a437d330e20", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -30,6 +30,7 @@ pub enum Abi {\n     C,\n     System,\n     RustIntrinsic,\n+    RustCall,\n }\n \n #[allow(non_camel_case_types)]\n@@ -85,6 +86,7 @@ static AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: C, name: \"C\", abi_arch: AllArch},\n     AbiData {abi: System, name: \"system\", abi_arch: AllArch},\n     AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\", abi_arch: RustArch},\n+    AbiData {abi: RustCall, name: \"rust-call\", abi_arch: RustArch},\n ];\n \n /// Returns the ABI with the given name (if any)."}, {"sha": "394d4a825167d321bedc6ce425ea11db31e7b576", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -503,6 +503,7 @@ pub enum Expr_ {\n     ExprMatch(Gc<Expr>, Vec<Arm>),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n+    ExprUnboxedFn(P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(Gc<Expr>, Gc<Expr>),\n@@ -690,6 +691,7 @@ pub struct TypeMethod {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n     pub fn_style: FnStyle,\n+    pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n     pub explicit_self: ExplicitSelf,\n@@ -966,13 +968,20 @@ pub struct Method {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub node: Method_\n+    pub node: Method_,\n }\n \n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Method_ {\n     /// Represents a method declaration\n-    MethDecl(Ident, Generics, ExplicitSelf, FnStyle, P<FnDecl>, P<Block>, Visibility),\n+    MethDecl(Ident,\n+             Generics,\n+             Abi,\n+             ExplicitSelf,\n+             FnStyle,\n+             P<FnDecl>,\n+             P<Block>,\n+             Visibility),\n     /// Represents a macro in method position\n     MethMac(Mac),\n }"}, {"sha": "c77f7db1c6da0d2f1198f14914e406460d25ab25", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -320,13 +320,15 @@ impl Map {\n             }\n             NodeForeignItem(i) => PathName(i.ident.name),\n             NodeMethod(m) => match m.node {\n-                MethDecl(ident, _, _, _, _, _, _) => PathName(ident.name),\n+                MethDecl(ident, _, _, _, _, _, _, _) => PathName(ident.name),\n                 MethMac(_) => fail!(\"no path elem for {:?}\", node)\n             },\n             NodeTraitMethod(tm) => match *tm {\n                 Required(ref m) => PathName(m.ident.name),\n                 Provided(m) => match m.node {\n-                    MethDecl(ident, _, _, _, _, _, _) => PathName(ident.name),\n+                    MethDecl(ident, _, _, _, _, _, _, _) => {\n+                        PathName(ident.name)\n+                    }\n                     MethMac(_) => fail!(\"no path elem for {:?}\", node),\n                 }\n             },\n@@ -709,7 +711,7 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n             format!(\"foreign item {} (id={})\", path_str, id)\n         }\n         Some(NodeMethod(m)) => match m.node {\n-            MethDecl(ident, _, _, _, _, _, _) =>\n+            MethDecl(ident, _, _, _, _, _, _, _) =>\n                 format!(\"method {} in {} (id={})\",\n                         token::get_ident(ident),\n                         map.path_to_string(id), id),"}, {"sha": "2b98a3bdd28efa482573c116c320661127a564f1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use abi::Abi;\n use ast::*;\n use ast;\n use ast_util;\n@@ -249,7 +250,14 @@ pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n         Required(ref m) => (*m).clone(),\n         Provided(m) => {\n             match m.node {\n-                MethDecl(ident, ref generics, explicit_self, fn_style, decl, _, vis) => {\n+                MethDecl(ident,\n+                         ref generics,\n+                         abi,\n+                         explicit_self,\n+                         fn_style,\n+                         decl,\n+                         _,\n+                         vis) => {\n                     TypeMethod {\n                         ident: ident,\n                         attrs: m.attrs.clone(),\n@@ -260,6 +268,7 @@ pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n                         id: m.id,\n                         span: m.span,\n                         vis: vis,\n+                        abi: abi,\n                     }\n                 },\n                 MethMac(_) => fail!(\"expected non-macro method declaration\")\n@@ -749,6 +758,7 @@ pub fn static_has_significant_address(mutbl: ast::Mutability,\n pub trait PostExpansionMethod {\n     fn pe_ident(&self) -> ast::Ident;\n     fn pe_generics<'a>(&'a self) -> &'a ast::Generics;\n+    fn pe_abi(&self) -> Abi;\n     fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf;\n     fn pe_fn_style(&self) -> ast::FnStyle;\n     fn pe_fn_decl(&self) -> P<ast::FnDecl>;\n@@ -797,25 +807,28 @@ macro_rules! mf_method{\n // PRE\n impl PostExpansionMethod for Method {\n     fn pe_ident(&self) -> ast::Ident {\n-        mf_method_body!(self,MethDecl(ident,_,_,_,_,_,_),ident)\n+        mf_method_body!(self, MethDecl(ident,_,_,_,_,_,_,_),ident)\n     }\n     fn pe_generics<'a>(&'a self) -> &'a ast::Generics {\n-        mf_method_body!(self,MethDecl(_,ref generics,_,_,_,_,_),generics)\n+        mf_method_body!(self, MethDecl(_,ref generics,_,_,_,_,_,_),generics)\n+    }\n+    fn pe_abi(&self) -> Abi {\n+        mf_method_body!(self, MethDecl(_,_,abi,_,_,_,_,_),abi)\n     }\n     fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf {\n-        mf_method_body!(self,MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n+        mf_method_body!(self, MethDecl(_,_,_,ref explicit_self,_,_,_,_),explicit_self)\n     }\n     fn pe_fn_style(&self) -> ast::FnStyle{\n-        mf_method_body!(self,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n+        mf_method_body!(self, MethDecl(_,_,_,_,fn_style,_,_,_),fn_style)\n     }\n     fn pe_fn_decl(&self) -> P<ast::FnDecl> {\n-        mf_method_body!(self,MethDecl(_,_,_,_,decl,_,_),decl)\n+        mf_method_body!(self, MethDecl(_,_,_,_,_,decl,_,_),decl)\n     }\n     fn pe_body(&self) -> P<ast::Block> {\n-        mf_method_body!(self,MethDecl(_,_,_,_,_,body,_),body)\n+        mf_method_body!(self, MethDecl(_,_,_,_,_,_,body,_),body)\n     }\n     fn pe_vis(&self) -> ast::Visibility {\n-        mf_method_body!(self,MethDecl(_,_,_,_,_,_,vis),vis)\n+        mf_method_body!(self, MethDecl(_,_,_,_,_,_,_,vis),vis)\n     }\n }\n "}, {"sha": "871f277a2da28b9ffc944531ec4102f43e7c1504", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -183,6 +183,8 @@\n use std::cell::RefCell;\n use std::gc::{Gc, GC};\n \n+use abi::Abi;\n+use abi;\n use ast;\n use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n@@ -477,9 +479,13 @@ impl<'a> TraitDef<'a> {\n                                                      nonself_args.as_slice())\n             };\n \n-            method_def.create_method(cx, self,\n-                                     type_ident, generics,\n-                                     explicit_self, tys,\n+            method_def.create_method(cx,\n+                                     self,\n+                                     type_ident,\n+                                     generics,\n+                                     abi::Rust,\n+                                     explicit_self,\n+                                     tys,\n                                      body)\n         }).collect();\n \n@@ -513,9 +519,13 @@ impl<'a> TraitDef<'a> {\n                                                    nonself_args.as_slice())\n             };\n \n-            method_def.create_method(cx, self,\n-                                     type_ident, generics,\n-                                     explicit_self, tys,\n+            method_def.create_method(cx,\n+                                     self,\n+                                     type_ident,\n+                                     generics,\n+                                     abi::Rust,\n+                                     explicit_self,\n+                                     tys,\n                                      body)\n         }).collect();\n \n@@ -622,9 +632,11 @@ impl<'a> MethodDef<'a> {\n                      trait_: &TraitDef,\n                      type_ident: Ident,\n                      generics: &Generics,\n+                     abi: Abi,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: Gc<Expr>) -> Gc<ast::Method> {\n+                     body: Gc<Expr>)\n+                     -> Gc<ast::Method> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -653,6 +665,7 @@ impl<'a> MethodDef<'a> {\n             span: trait_.span,\n             node: ast::MethDecl(method_ident,\n                                 fn_generics,\n+                                abi,\n                                 explicit_self,\n                                 ast::NormalFn,\n                                 fn_decl,"}, {"sha": "fdb698441fc0c0d48358a92837124755662725c0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -910,7 +910,14 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast::Method>> {\n     let id = fld.new_id(m.id);\n     match m.node {\n-        ast::MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+        ast::MethDecl(ident,\n+                      ref generics,\n+                      abi,\n+                      ref explicit_self,\n+                      fn_style,\n+                      decl,\n+                      body,\n+                      vis) => {\n             let (rewritten_fn_decl, rewritten_body)\n                 = expand_and_rename_fn_decl_and_block(&*decl,body,fld);\n             SmallVector::one(box(GC) ast::Method {\n@@ -919,6 +926,7 @@ fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast\n                     span: fld.new_span(m.span),\n                     node: ast::MethDecl(fld.fold_ident(ident),\n                                         fold_generics(generics, fld),\n+                                        abi,\n                                         fld.fold_explicit_self(explicit_self),\n                                         fn_style,\n                                         rewritten_fn_decl,"}, {"sha": "5417991c9df19f23bf901799a1c2dbe6a0a78568", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -727,6 +727,7 @@ pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMeth\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n         fn_style: m.fn_style,\n+        abi: m.abi,\n         decl: fld.fold_fn_decl(&*m.decl),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: fld.fold_explicit_self(&m.explicit_self),\n@@ -818,9 +819,17 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc\n         id: id,\n         span: folder.new_span(m.span),\n         node: match m.node {\n-            MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+            MethDecl(ident,\n+                     ref generics,\n+                     abi,\n+                     ref explicit_self,\n+                     fn_style,\n+                     decl,\n+                     body,\n+                     vis) => {\n                 MethDecl(folder.fold_ident(ident),\n                          fold_generics(generics, folder),\n+                         abi,\n                          folder.fold_explicit_self(explicit_self),\n                          fn_style,\n                          folder.fold_fn_decl(&*decl),\n@@ -948,7 +957,11 @@ pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n             ExprProc(folder.fold_fn_decl(&**decl),\n                      folder.fold_block(body.clone()))\n         }\n-        ExprBlock(ref blk) => ExprBlock(folder.fold_block(blk.clone())),\n+        ExprUnboxedFn(ref decl, ref body) => {\n+            ExprUnboxedFn(folder.fold_fn_decl(&**decl),\n+                          folder.fold_block(*body))\n+        }\n+        ExprBlock(ref blk) => ExprBlock(folder.fold_block(*blk)),\n         ExprAssign(el, er) => {\n             ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n         }"}, {"sha": "394288bd9f29bfcaadf0c78aef2802353ca31a52", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 63, "deletions": 56, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -25,7 +25,7 @@ use ast::{ExprBreak, ExprCall, ExprCast};\n use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n-use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n+use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n use ast::{ExprVec, ExprVstore, ExprVstoreSlice};\n use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, Field, FnDecl};\n use ast::{ExprVstoreUniq, Once, Many};\n@@ -59,6 +59,7 @@ use ast::Visibility;\n use ast;\n use ast_util::{as_prec, ident_to_path, lit_is_str, operator_prec};\n use ast_util;\n+use attr;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n use codemap;\n use parse;\n@@ -1217,6 +1218,16 @@ impl<'a> Parser<'a> {\n             // NB: at the moment, trait methods are public by default; this\n             // could change.\n             let vis = p.parse_visibility();\n+            let abi = if p.eat_keyword(keywords::Extern) {\n+                p.parse_opt_abi().unwrap_or(abi::C)\n+            } else if attr::contains_name(attrs.as_slice(),\n+                                          \"rust_call_abi_hack\") {\n+                // FIXME(stage0, pcwalton): Remove this awful hack after a\n+                // snapshot, and change to `extern \"rust-call\" fn`.\n+                abi::RustCall\n+            } else {\n+                abi::Rust\n+            };\n             let style = p.parse_fn_style();\n             let ident = p.parse_ident();\n \n@@ -1239,6 +1250,7 @@ impl<'a> Parser<'a> {\n                     fn_style: style,\n                     decl: d,\n                     generics: generics,\n+                    abi: abi,\n                     explicit_self: explicit_self,\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi),\n@@ -1254,7 +1266,14 @@ impl<'a> Parser<'a> {\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi),\n-                    node: ast::MethDecl(ident, generics, explicit_self, style, d, body, vis)\n+                    node: ast::MethDecl(ident,\n+                                        generics,\n+                                        abi,\n+                                        explicit_self,\n+                                        style,\n+                                        d,\n+                                        body,\n+                                        vis)\n                 })\n               }\n \n@@ -2620,51 +2639,11 @@ impl<'a> Parser<'a> {\n         self.mk_expr(lo, hi, ExprIf(cond, thn, els))\n     }\n \n-    /// `|args| { ... }` or `{ ...}` like in `do` expressions\n-    pub fn parse_lambda_block_expr(&mut self) -> Gc<Expr> {\n-        self.parse_lambda_expr_(\n-            |p| {\n-                match p.token {\n-                    token::BINOP(token::OR) | token::OROR => {\n-                        p.parse_fn_block_decl()\n-                    }\n-                    _ => {\n-                        // No argument list - `do foo {`\n-                        P(FnDecl {\n-                            inputs: Vec::new(),\n-                            output: P(Ty {\n-                                id: ast::DUMMY_NODE_ID,\n-                                node: TyInfer,\n-                                span: p.span\n-                            }),\n-                            cf: Return,\n-                            variadic: false\n-                        })\n-                    }\n-                }\n-            },\n-            |p| {\n-                let blk = p.parse_block();\n-                p.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk))\n-            })\n-    }\n-\n-    /// `|args| expr`\n+    // `|args| expr`\n     pub fn parse_lambda_expr(&mut self) -> Gc<Expr> {\n-        self.parse_lambda_expr_(|p| p.parse_fn_block_decl(),\n-                                |p| p.parse_expr())\n-    }\n-\n-    /// parse something of the form |args| expr\n-    /// this is used both in parsing a lambda expr\n-    /// and in parsing a block expr as e.g. in for...\n-    pub fn parse_lambda_expr_(&mut self,\n-                              parse_decl: |&mut Parser| -> P<FnDecl>,\n-                              parse_body: |&mut Parser| -> Gc<Expr>)\n-                              -> Gc<Expr> {\n         let lo = self.span.lo;\n-        let decl = parse_decl(self);\n-        let body = parse_body(self);\n+        let (decl, is_unboxed) = self.parse_fn_block_decl();\n+        let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n             view_items: Vec::new(),\n             stmts: Vec::new(),\n@@ -2674,7 +2653,11 @@ impl<'a> Parser<'a> {\n             span: body.span,\n         });\n \n-        return self.mk_expr(lo, body.span.hi, ExprFnBlock(decl, fakeblock));\n+        if is_unboxed {\n+            self.mk_expr(lo, body.span.hi, ExprUnboxedFn(decl, fakeblock))\n+        } else {\n+            self.mk_expr(lo, body.span.hi, ExprFnBlock(decl, fakeblock))\n+        }\n     }\n \n     pub fn parse_else_expr(&mut self) -> Gc<Expr> {\n@@ -3955,18 +3938,30 @@ impl<'a> Parser<'a> {\n         (spanned(lo, hi, explicit_self), fn_decl)\n     }\n \n-    /// Parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&mut self) -> P<FnDecl> {\n-        let inputs_captures = {\n+    // parse the |arg, arg| header on a lambda\n+    fn parse_fn_block_decl(&mut self) -> (P<FnDecl>, bool) {\n+        let (is_unboxed, inputs_captures) = {\n             if self.eat(&token::OROR) {\n-                Vec::new()\n+                (false, Vec::new())\n             } else {\n-                self.parse_unspanned_seq(\n-                    &token::BINOP(token::OR),\n+                self.expect(&token::BINOP(token::OR));\n+                let is_unboxed = self.token == token::BINOP(token::AND) &&\n+                    self.look_ahead(1, |t| {\n+                        token::is_keyword(keywords::Mut, t)\n+                    }) &&\n+                    self.look_ahead(2, |t| *t == token::COLON);\n+                if is_unboxed {\n+                    self.bump();\n+                    self.bump();\n+                    self.bump();\n+                }\n+                let args = self.parse_seq_to_before_end(\n                     &token::BINOP(token::OR),\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_fn_block_arg()\n-                )\n+                );\n+                self.bump();\n+                (is_unboxed, args)\n             }\n         };\n         let output = if self.eat(&token::RARROW) {\n@@ -3979,12 +3974,12 @@ impl<'a> Parser<'a> {\n             })\n         };\n \n-        P(FnDecl {\n+        (P(FnDecl {\n             inputs: inputs_captures,\n             output: output,\n             cf: Return,\n             variadic: false\n-        })\n+        }), is_unboxed)\n     }\n \n     /// Parses the `(arg, arg) -> return_type` header on a procedure.\n@@ -4079,6 +4074,11 @@ impl<'a> Parser<'a> {\n                 (ast::MethMac(m), self.span.hi, attrs)\n             } else {\n                 let visa = self.parse_visibility();\n+                let abi = if self.eat_keyword(keywords::Extern) {\n+                    self.parse_opt_abi().unwrap_or(abi::C)\n+                } else {\n+                    abi::Rust\n+                };\n                 let fn_style = self.parse_fn_style();\n                 let ident = self.parse_ident();\n                 let generics = self.parse_generics();\n@@ -4087,7 +4087,14 @@ impl<'a> Parser<'a> {\n                     });\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n                 let new_attrs = attrs.append(inner_attrs.as_slice());\n-                (ast::MethDecl(ident, generics, explicit_self, fn_style, decl, body, visa),\n+                (ast::MethDecl(ident,\n+                               generics,\n+                               abi,\n+                               explicit_self,\n+                               fn_style,\n+                               decl,\n+                               body,\n+                               visa),\n                  body.span.hi, new_attrs)\n             }\n         };"}, {"sha": "dd96118ea49ee7f2adc504cc0330a7c8e2b37a11", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -188,7 +188,7 @@ pub fn method_to_string(p: &ast::Method) -> String {\n }\n \n pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n-    to_string(|s| s.print_fn_block_args(p))\n+    to_string(|s| s.print_fn_block_args(p, false))\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n@@ -259,7 +259,8 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprAssign(..) | ast::ExprBinary(..) |\n         ast::ExprFnBlock(..) | ast::ExprProc(..) |\n-        ast::ExprAssignOp(..) | ast::ExprCast(..) => true,\n+        ast::ExprUnboxedFn(..) | ast::ExprAssignOp(..) |\n+        ast::ExprCast(..) => true,\n         _ => false,\n     }\n }\n@@ -1004,9 +1005,20 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(meth.attrs.as_slice()));\n         match meth.node {\n-            ast::MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n-                try!(self.print_fn(&*decl, Some(fn_style), abi::Rust,\n-                                   ident, generics, Some(explicit_self.node),\n+            ast::MethDecl(ident,\n+                          ref generics,\n+                          abi,\n+                          ref explicit_self,\n+                          fn_style,\n+                          decl,\n+                          body,\n+                          vis) => {\n+                try!(self.print_fn(&*decl,\n+                                   Some(fn_style),\n+                                   abi,\n+                                   ident,\n+                                   generics,\n+                                   Some(explicit_self.node),\n                                    vis));\n                 try!(word(&mut self.s, \" \"));\n                 self.print_block_with_attrs(&*body, meth.attrs.as_slice())\n@@ -1446,7 +1458,37 @@ impl<'a> State<'a> {\n                 // we are inside.\n                 //\n                 // if !decl.inputs.is_empty() {\n-                try!(self.print_fn_block_args(&**decl));\n+                try!(self.print_fn_block_args(&**decl, false));\n+                try!(space(&mut self.s));\n+                // }\n+\n+                if !body.stmts.is_empty() || !body.expr.is_some() {\n+                    try!(self.print_block_unclosed(&**body));\n+                } else {\n+                    // we extract the block, so as not to create another set of boxes\n+                    match body.expr.unwrap().node {\n+                        ast::ExprBlock(blk) => {\n+                            try!(self.print_block_unclosed(&*blk));\n+                        }\n+                        _ => {\n+                            // this is a bare expression\n+                            try!(self.print_expr(&*body.expr.unwrap()));\n+                            try!(self.end()); // need to close a box\n+                        }\n+                    }\n+                }\n+                // a box will be closed by print_expr, but we didn't want an overall\n+                // wrapper so we closed the corresponding opening. so create an\n+                // empty box to satisfy the close.\n+                try!(self.ibox(0));\n+            }\n+            ast::ExprUnboxedFn(ref decl, ref body) => {\n+                // in do/for blocks we don't want to show an empty\n+                // argument list, but at this point we don't know which\n+                // we are inside.\n+                //\n+                // if !decl.inputs.is_empty() {\n+                try!(self.print_fn_block_args(&**decl, true));\n                 try!(space(&mut self.s));\n                 // }\n \n@@ -1939,8 +1981,13 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_block_args(&mut self,\n-                               decl: &ast::FnDecl) -> IoResult<()> {\n+                               decl: &ast::FnDecl,\n+                               is_unboxed: bool)\n+                               -> IoResult<()> {\n         try!(word(&mut self.s, \"|\"));\n+        if is_unboxed {\n+            try!(self.word_space(\"&mut:\"));\n+        }\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n "}, {"sha": "d5fb75a4d695d2dd9a1066db1cf41570e388e141", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -562,7 +562,7 @@ pub fn walk_method_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    method: &Method,\n                                                    env: E) {\n     match method.node {\n-        MethDecl(ident, ref generics, _, _, decl, body, _) => {\n+        MethDecl(ident, ref generics, _, _, _, decl, body, _) => {\n             visitor.visit_ident(method.span, ident, env.clone());\n             visitor.visit_fn(&FkMethod(ident, generics, method),\n                              &*decl,\n@@ -594,7 +594,7 @@ pub fn walk_fn<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         FkMethod(_, generics, method) => {\n             visitor.visit_generics(generics, env.clone());\n             match method.node {\n-                MethDecl(_, _, ref explicit_self, _, _, _, _) =>\n+                MethDecl(_, _, _, ref explicit_self, _, _, _, _) =>\n                     visitor.visit_explicit_self(explicit_self, env.clone()),\n                 MethMac(ref mac) =>\n                     visitor.visit_mac(mac, env.clone())\n@@ -790,6 +790,14 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n                              expression.id,\n                              env.clone())\n         }\n+        ExprUnboxedFn(ref function_declaration, ref body) => {\n+            visitor.visit_fn(&FkFnBlock,\n+                             &**function_declaration,\n+                             &**body,\n+                             expression.span,\n+                             expression.id,\n+                             env.clone())\n+        }\n         ExprProc(ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n                              &**function_declaration,"}, {"sha": "f134c2aa09bd581a83e09861d7a4ed15add2b528", "filename": "src/test/compile-fail/borrowck-overloaded-call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -18,7 +18,7 @@ struct SFn {\n }\n \n impl Fn<(int,),int> for SFn {\n-    fn call(&self, (z,): (int,)) -> int {\n+    extern \"rust-call\" fn call(&self, (z,): (int,)) -> int {\n         self.x * self.y * z\n     }\n }\n@@ -29,7 +29,7 @@ struct SFnMut {\n }\n \n impl FnMut<(int,),int> for SFnMut {\n-    fn call_mut(&mut self, (z,): (int,)) -> int {\n+    extern \"rust-call\" fn call_mut(&mut self, (z,): (int,)) -> int {\n         self.x * self.y * z\n     }\n }\n@@ -39,7 +39,7 @@ struct SFnOnce {\n }\n \n impl FnOnce<(String,),uint> for SFnOnce {\n-    fn call_once(self, (z,): (String,)) -> uint {\n+    extern \"rust-call\" fn call_once(self, (z,): (String,)) -> uint {\n         self.x.len() + z.len()\n     }\n }"}, {"sha": "cc01c0b3c9f1cfe6ef39a8011fe0329da9eb2d17", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -18,7 +18,7 @@ struct S {\n }\n \n impl FnMut<(int,),int> for S {\n-    fn call_mut(&mut self, (z,): (int,)) -> int {\n+    extern \"rust-call\" fn call_mut(&mut self, (z,): (int,)) -> int {\n         self.x * self.y * z\n     }\n }"}, {"sha": "ee2fe3522470a679e93de414e876a3e1665ce616", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -18,7 +18,7 @@ struct S {\n }\n \n impl FnMut<int,int> for S {\n-    fn call_mut(&mut self, z: int) -> int {\n+    extern \"rust-call\" fn call_mut(&mut self, z: int) -> int {\n         self.x + self.y + z\n     }\n }"}, {"sha": "09f13b7738694ea504a4b652a3843af46f0f3c57", "filename": "src/test/compile-fail/unboxed-closures-type-mismatch.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::FnMut;\n+\n+pub fn main() {\n+    let mut f = |&mut: x: int, y: int| -> int { x + y };\n+    let z = f.call_mut((1u, 2));    //~ ERROR mismatched types\n+    println!(\"{}\", z);\n+}"}, {"sha": "2ee632b9093c82dea2d41b65e949939aac530222", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::FnMut;\n+\n+fn call_it<F:FnMut<(int,int),int>>(y: int, mut f: F) -> int {\n+    f.call_mut((2, y))\n+}\n+\n+pub fn main() {\n+    let f = |&mut: x: uint, y: int| -> int { (x as int) + y };\n+    let z = call_it(3, f);  //~ ERROR expected core::ops::FnMut\n+    //~^ ERROR expected core::ops::FnMut\n+    println!(\"{}\", z);\n+}\n+"}, {"sha": "ccb5634f7a2906699a469c92e3b514743754e741", "filename": "src/test/run-pass/fn-trait-sugar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Ffn-trait-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Ffn-trait-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-trait-sugar.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -16,7 +16,7 @@ use std::ops::FnMut;\n struct S;\n \n impl FnMut<(int,),int> for S {\n-    fn call_mut(&mut self, (x,): (int,)) -> int {\n+    extern \"rust-call\" fn call_mut(&mut self, (x,): (int,)) -> int {\n         x * x\n     }\n }"}, {"sha": "b53c2258736ff515e04519048e0efa04b9b202d9", "filename": "src/test/run-pass/issue-14958.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -15,7 +15,7 @@ trait Foo {}\n struct Bar;\n \n impl<'a> std::ops::Fn<(&'a Foo,), ()> for Bar {\n-    fn call(&self, _: (&'a Foo,)) {}\n+    extern \"rust-call\" fn call(&self, _: (&'a Foo,)) {}\n }\n \n struct Baz;"}, {"sha": "af0bc78094e5f3ebb703e002846bec64ae295038", "filename": "src/test/run-pass/issue-14959.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14959.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -34,7 +34,7 @@ impl Alloy {\n }\n \n impl<'a, 'b> Fn<(&'b mut Response,),()> for SendFile<'a> {\n-    fn call(&self, (_res,): (&'b mut Response,)) {}\n+    extern \"rust-call\" fn call(&self, (_res,): (&'b mut Response,)) {}\n }\n \n impl<Rq: Request, Rs: Response> Ingot<Rq, Rs> for HelloWorld {"}, {"sha": "76c7e60116f80b8adf4a121a065fd02421fac1e2", "filename": "src/test/run-pass/overloaded-calls-simple.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(lang_items, overloaded_calls)]\n \n use std::ops::{Fn, FnMut, FnOnce};\n \n@@ -18,7 +18,7 @@ struct S1 {\n }\n \n impl FnMut<(int,),int> for S1 {\n-    fn call_mut(&mut self, (z,): (int,)) -> int {\n+    extern \"rust-call\" fn call_mut(&mut self, (z,): (int,)) -> int {\n         self.x * self.y * z\n     }\n }\n@@ -29,7 +29,7 @@ struct S2 {\n }\n \n impl Fn<(int,),int> for S2 {\n-    fn call(&self, (z,): (int,)) -> int {\n+    extern \"rust-call\" fn call(&self, (z,): (int,)) -> int {\n         self.x * self.y * z\n     }\n }\n@@ -40,7 +40,7 @@ struct S3 {\n }\n \n impl FnOnce<(int,int),int> for S3 {\n-    fn call_once(self, (z,zz): (int,int)) -> int {\n+    extern \"rust-call\" fn call_once(self, (z,zz): (int,int)) -> int {\n         self.x * self.y * z * zz\n     }\n }\n@@ -50,21 +50,21 @@ fn main() {\n         x: 3,\n         y: 3,\n     };\n-    let ans = s(3);\n-    assert_eq!(ans, 27);\n+    let ans = s.call_mut((3,));\n \n+    assert_eq!(ans, 27);\n     let s = S2 {\n         x: 3,\n         y: 3,\n     };\n-    let ans = s(3);\n+    let ans = s.call((3,));\n     assert_eq!(ans, 27);\n \n     let s = S3 {\n         x: 3,\n         y: 3,\n     };\n-    let ans = s(3, 1);\n+    let ans = s.call_once((3, 1));\n     assert_eq!(ans, 27);\n }\n "}, {"sha": "b868c8c96b5fb0cd689fc5d3740cb3ce7258fb07", "filename": "src/test/run-pass/overloaded-calls-zero-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -18,7 +18,7 @@ struct S {\n }\n \n impl FnMut<(),int> for S {\n-    fn call_mut(&mut self, (): ()) -> int {\n+    extern \"rust-call\" fn call_mut(&mut self, (): ()) -> int {\n         self.x * self.y\n     }\n }"}, {"sha": "c4b990abf7e6553c0271ce1b136dedf1e4131517", "filename": "src/test/run-pass/unboxed-closures-boxed.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-boxed.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::FnMut;\n+\n+fn make_adder(x: int) -> Box<FnMut<(int,),int>> {\n+    (box |&mut: y: int| -> int { x + y }) as Box<FnMut<(int,),int>>\n+}\n+\n+pub fn main() {\n+    let mut adder = make_adder(3);\n+    let z = adder.call_mut((2,));\n+    println!(\"{}\", z);\n+    assert_eq!(z, 5);\n+}\n+"}, {"sha": "9d1d81fe259b3683e0ba7b307694442ac3ddca3d", "filename": "src/test/run-pass/unboxed-closures-generic.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Funboxed-closures-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Funboxed-closures-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-generic.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::FnMut;\n+\n+fn call_it<F:FnMut<(int,int),int>>(y: int, mut f: F) -> int {\n+    f.call_mut((2, y))\n+}\n+\n+pub fn main() {\n+    let f = |&mut: x: int, y: int| -> int { x + y };\n+    let z = call_it(3, f);\n+    println!(\"{}\", z);\n+    assert_eq!(z, 5);\n+}\n+"}, {"sha": "f11096ba5ffc6b732ef0f739423e944cee2c9948", "filename": "src/test/run-pass/unboxed-closures-simple.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Funboxed-closures-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74/src%2Ftest%2Frun-pass%2Funboxed-closures-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-simple.rs?ref=02adaca4dc7eb4594d8bda9a7e04bc0247fc2a74", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::FnMut;\n+\n+pub fn main() {\n+    let mut f = |&mut: x: int, y: int| -> int { x + y };\n+    let z = f.call_mut((1, 2));\n+    assert_eq!(z, 3);\n+}"}]}