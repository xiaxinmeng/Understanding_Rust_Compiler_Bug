{"sha": "feb139f53f62b936ad94e9449212e130a71723b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYjEzOWY1M2Y2MmI5MzZhZDk0ZTk0NDkyMTJlMTMwYTcxNzIzYjc=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-17T09:21:54Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-18T08:53:10Z"}, "message": "Check lifetimes on existential types", "tree": {"sha": "837a7c21979887bb363976ca455a5dc902d85fe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/837a7c21979887bb363976ca455a5dc902d85fe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/feb139f53f62b936ad94e9449212e130a71723b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/feb139f53f62b936ad94e9449212e130a71723b7", "html_url": "https://github.com/rust-lang/rust/commit/feb139f53f62b936ad94e9449212e130a71723b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/feb139f53f62b936ad94e9449212e130a71723b7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "240fcdf65b183e64a7dc4f5992c72194226636b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/240fcdf65b183e64a7dc4f5992c72194226636b7", "html_url": "https://github.com/rust-lang/rust/commit/240fcdf65b183e64a7dc4f5992c72194226636b7"}], "stats": {"total": 257, "additions": 218, "deletions": 39}, "files": [{"sha": "ae4d88704a098e830c10bc3faafd19b5c1095f5d", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -653,6 +653,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         value.fold_with(&mut BottomUpFolder {\n             tcx,\n+            reg_op: |reg| reg,\n             fldop: |ty| {\n                 if let ty::TyAnon(def_id, substs) = ty.sty {\n                     // Check that this is `impl Trait` type is"}, {"sha": "e4484041b065ce829306f816f8a7e04e1212482c", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -200,22 +200,30 @@ pub trait TypeVisitor<'tcx> : Sized {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F>\n-    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n+pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F, G>\n+    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+          G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub fldop: F,\n+    pub reg_op: G,\n }\n \n-impl<'a, 'gcx, 'tcx, F> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F>\n+impl<'a, 'gcx, 'tcx, F, G> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F, G>\n     where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+          G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t1 = ty.super_fold_with(self);\n         (self.fldop)(t1)\n     }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let r = r.super_fold_with(self);\n+        (self.reg_op)(r)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "03ecb945cbd3c9497f0f71182ba58ada0d49d37d", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -575,9 +575,10 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                     let anon_node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n                     if may_define_existential_type(tcx, fn_def_id, anon_node_id) {\n                         trace!(\"check_existential_types may define. Generics: {:#?}\", generics);\n+                        let mut seen: FxHashMap<_, Vec<_>> = FxHashMap();\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n-                            if let ty::subst::UnpackedKind::Type(ty) = subst.unpack() {\n-                                match ty.sty {\n+                            match subst.unpack() {\n+                                ty::subst::UnpackedKind::Type(ty) => match ty.sty {\n                                     ty::TyParam(..) => {},\n                                     // prevent `fn foo() -> Foo<u32>` from being defining\n                                     _ => {\n@@ -597,11 +598,47 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                                                 ),\n                                             )\n                                             .emit();\n-                                        return tcx.types.err;\n                                     },\n-                                } // match ty\n-                            } // if let Type = subst\n+                                }, // match ty\n+                                ty::subst::UnpackedKind::Lifetime(region) => {\n+                                    let param_span = tcx.def_span(param.def_id);\n+                                    if let ty::ReStatic = region {\n+                                        tcx\n+                                            .sess\n+                                            .struct_span_err(\n+                                                span,\n+                                                \"non-defining existential type use \\\n+                                                    in defining scope\",\n+                                            )\n+                                            .span_label(\n+                                                param_span,\n+                                                \"cannot use static lifetime, use a bound lifetime \\\n+                                                instead or remove the lifetime parameter from the \\\n+                                                existential type\",\n+                                            )\n+                                            .emit();\n+                                    } else {\n+                                        seen.entry(region).or_default().push(param_span);\n+                                    }\n+                                },\n+                            } // match subst\n                         } // for (subst, param)\n+                        for (_, spans) in seen {\n+                            if spans.len() > 1 {\n+                                tcx\n+                                    .sess\n+                                    .struct_span_err(\n+                                        span,\n+                                        \"non-defining existential type use \\\n+                                            in defining scope\",\n+                                    ).\n+                                    span_note(\n+                                        spans,\n+                                        \"lifetime used multiple times\",\n+                                    )\n+                                    .emit();\n+                            }\n+                        }\n                     } // if may_define_existential_type\n \n                     // now register the bounds on the parameters of the existential type\n@@ -631,6 +668,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n             } // if let TyAnon\n             ty\n         },\n+        reg_op: |reg| reg,\n     });\n     substituted_predicates\n }"}, {"sha": "b37f489b2c721419002f3ad2d96fae2e51153ecd", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -389,16 +389,17 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n             let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n             let instantiated_ty = self.resolve(&anon_defn.concrete_ty, &node_id);\n-            let mut definition_ty = self.fcx.infer_anon_definition_from_instantiation(\n-                def_id,\n-                anon_defn,\n-                instantiated_ty,\n-            );\n \n             let generics = self.tcx().generics_of(def_id);\n \n-            // named existential type, not an impl trait\n-            if generics.parent.is_none() {\n+            let definition_ty = if generics.parent.is_some() {\n+                // impl trait\n+                self.fcx.infer_anon_definition_from_instantiation(\n+                    def_id,\n+                    anon_defn,\n+                    instantiated_ty,\n+                )\n+            } else {\n                 // prevent\n                 // * `fn foo<T>() -> Foo<T>`\n                 // * `fn foo<T: Bound + Other>() -> Foo<T>`\n@@ -411,9 +412,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 // fn foo<U>() -> Foo<U> { .. }\n                 // ```\n                 // figures out the concrete type with `U`, but the stored type is with `T`\n-                definition_ty = definition_ty.fold_with(&mut BottomUpFolder {\n+                instantiated_ty.fold_with(&mut BottomUpFolder {\n                     tcx: self.tcx().global_tcx(),\n                     fldop: |ty| {\n+                        trace!(\"checking type {:?}: {:#?}\", ty, ty.sty);\n                         // find a type parameter\n                         if let ty::TyParam(..) = ty.sty {\n                             // look it up in the substitution list\n@@ -445,8 +447,50 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                         }\n                         ty\n                     },\n-                });\n-            }\n+                    reg_op: |region| {\n+                        match region {\n+                            // ignore static regions\n+                            ty::ReStatic => region,\n+                            _ => {\n+                                trace!(\"checking {:?}\", region);\n+                                for (subst, p) in anon_defn.substs.iter().zip(&generics.params) {\n+                                    if let UnpackedKind::Lifetime(subst) = subst.unpack() {\n+                                        if subst == region {\n+                                            // found it in the substitution list, replace with the\n+                                            // parameter from the existential type\n+                                            let reg = ty::EarlyBoundRegion {\n+                                                def_id: p.def_id,\n+                                                index: p.index,\n+                                                name: p.name,\n+                                            };\n+                                            trace!(\"replace {:?} with {:?}\", region, reg);\n+                                            return self.tcx().global_tcx()\n+                                                .mk_region(ty::ReEarlyBound(reg));\n+                                        }\n+                                    }\n+                                }\n+                                trace!(\"anon_defn: {:#?}\", anon_defn);\n+                                trace!(\"generics: {:#?}\", generics);\n+                                self.tcx().sess\n+                                    .struct_span_err(\n+                                        span,\n+                                        \"non-defining existential type use in defining scope\",\n+                                    )\n+                                    .span_label(\n+                                        span,\n+                                        format!(\n+                                            \"lifetime `{}` is part of concrete type but not used \\\n+                                            in parameter list of existential type\",\n+                                            region,\n+                                        ),\n+                                    )\n+                                    .emit();\n+                                self.tcx().global_tcx().mk_region(ty::ReStatic)\n+                            }\n+                        }\n+                    }\n+                })\n+            };\n \n             let old = self.tables.concrete_existential_types.insert(def_id, definition_ty);\n             if let Some(old) = old {"}, {"sha": "92b234aa6dc63f4972ca438b557bca87c856dc25", "filename": "src/test/ui/existential_types/generic_duplicate_lifetime_param.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.rs?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![feature(existential_type)]\n+\n+fn main() {}\n+\n+existential type Two<'a, 'b>: std::fmt::Debug;\n+\n+fn one<'a>(t: &'a ()) -> Two<'a, 'a> { //~ ERROR non-defining existential type use\n+    t\n+}"}, {"sha": "0316832a1af902aaf8eebb22c46bc24f4a6e3949", "filename": "src/test/ui/existential_types/generic_duplicate_lifetime_param.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_lifetime_param.stderr?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -0,0 +1,16 @@\n+error: non-defining existential type use in defining scope\n+  --> $DIR/generic_duplicate_lifetime_param.rs:18:1\n+   |\n+LL | / fn one<'a>(t: &'a ()) -> Two<'a, 'a> { //~ ERROR non-defining existential type use\n+LL | |     t\n+LL | | }\n+   | |_^\n+   |\n+note: lifetime used multiple times\n+  --> $DIR/generic_duplicate_lifetime_param.rs:16:22\n+   |\n+LL | existential type Two<'a, 'b>: std::fmt::Debug;\n+   |                      ^^  ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "52e36fa9b615313a9cd5df2fc60004c90e53850e", "filename": "src/test/ui/existential_types/generic_duplicate_param_use.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_param_use.rs?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![feature(existential_type)]\n+\n+fn main() {}\n+\n+existential type Two<T, U>: 'static; //~ ERROR type parameter `U` is unused\n+\n+fn one<T: 'static>(t: T) -> Two<T, T> {\n+    t\n+}"}, {"sha": "e4a92dba58f3e5d4eadafebead03bea87ff19701", "filename": "src/test/ui/existential_types/generic_duplicate_param_use.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_duplicate_param_use.stderr?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -0,0 +1,9 @@\n+error[E0091]: type parameter `U` is unused\n+  --> $DIR/generic_duplicate_param_use.rs:16:25\n+   |\n+LL | existential type Two<T, U>: 'static; //~ ERROR type parameter `U` is unused\n+   |                         ^ unused type parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0091`."}, {"sha": "3bdb69eec7f3e31a6722e1d7679afed0382ca08e", "filename": "src/test/ui/existential_types/generic_lifetime_param.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_lifetime_param.rs?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(existential_type)]\n+\n+fn main() {}\n+\n+existential type Region<'a>: std::fmt::Debug;\n+\n+fn region<'b>(a: &'b ()) -> Region<'b> {\n+    a\n+}"}, {"sha": "41c17c357bc807225f1219710ca7f825eb6e67bc", "filename": "src/test/ui/existential_types/no_revealing_outside_defining_module.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -13,21 +13,23 @@\n \n fn main() {}\n \n-mod boo2 {\n-    mod boo {\n-        pub existential type Boo: ::std::fmt::Debug;\n-        fn bomp() -> Boo {\n-            \"\"\n-        }\n+mod boo {\n+    pub existential type Boo: ::std::fmt::Debug;\n+    fn bomp() -> Boo {\n+        \"\"\n     }\n+}\n \n-    // don't actually know the type here\n+// don't actually know the type here\n \n-    fn bomp2() {\n-        let _: &str = bomp(); //~ ERROR mismatched types\n-    }\n+fn bomp2() {\n+    let _: &str = bomp(); //~ ERROR mismatched types\n+}\n \n-    fn bomp() -> boo::Boo {\n-        \"\" //~ ERROR mismatched types\n-    }\n+fn bomp() -> boo::Boo {\n+    \"\" //~ ERROR mismatched types\n }\n+\n+fn bomp_loop() -> boo::Boo {\n+    loop {}\n+}\n\\ No newline at end of file"}, {"sha": "a1c98c6d4b89ea9279f5ed6df05e8786ff6dfa1f", "filename": "src/test/ui/existential_types/no_revealing_outside_defining_module.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/feb139f53f62b936ad94e9449212e130a71723b7/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.stderr?ref=feb139f53f62b936ad94e9449212e130a71723b7", "patch": "@@ -1,19 +1,19 @@\n error[E0308]: mismatched types\n-  --> $DIR/no_revealing_outside_defining_module.rs:27:23\n+  --> $DIR/no_revealing_outside_defining_module.rs:26:19\n    |\n-LL |         let _: &str = bomp(); //~ ERROR mismatched types\n-   |                       ^^^^^^ expected &str, found anonymized type\n+LL |     let _: &str = bomp(); //~ ERROR mismatched types\n+   |                   ^^^^^^ expected &str, found anonymized type\n    |\n    = note: expected type `&str`\n               found type `Boo`\n \n error[E0308]: mismatched types\n-  --> $DIR/no_revealing_outside_defining_module.rs:31:9\n+  --> $DIR/no_revealing_outside_defining_module.rs:30:5\n    |\n-LL |     fn bomp() -> boo::Boo {\n-   |                  -------- expected `Boo` because of return type\n-LL |         \"\" //~ ERROR mismatched types\n-   |         ^^ expected anonymized type, found reference\n+LL | fn bomp() -> boo::Boo {\n+   |              -------- expected `Boo` because of return type\n+LL |     \"\" //~ ERROR mismatched types\n+   |     ^^ expected anonymized type, found reference\n    |\n    = note: expected type `Boo`\n               found type `&'static str`"}]}