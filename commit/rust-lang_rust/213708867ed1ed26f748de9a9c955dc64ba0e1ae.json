{"sha": "213708867ed1ed26f748de9a9c955dc64ba0e1ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMzcwODg2N2VkMWVkMjZmNzQ4ZGU5YTljOTU1ZGM2NGJhMGUxYWU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-18T19:29:13Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-20T13:37:45Z"}, "message": "TRPL editing: enums\n\nNow that we're not doing the guessing game, a lot of this is irrelevant.", "tree": {"sha": "7ebeb926faa412592679dfd42095efc59dd29f7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ebeb926faa412592679dfd42095efc59dd29f7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/213708867ed1ed26f748de9a9c955dc64ba0e1ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/213708867ed1ed26f748de9a9c955dc64ba0e1ae", "html_url": "https://github.com/rust-lang/rust/commit/213708867ed1ed26f748de9a9c955dc64ba0e1ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/213708867ed1ed26f748de9a9c955dc64ba0e1ae/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5910dc0e8e396a4af7b948b83bab03f27b414a0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5910dc0e8e396a4af7b948b83bab03f27b414a0e", "html_url": "https://github.com/rust-lang/rust/commit/5910dc0e8e396a4af7b948b83bab03f27b414a0e"}], "stats": {"total": 129, "additions": 25, "deletions": 104}, "files": [{"sha": "80ea25eb35ce92125c82027c7275bf10bba3353e", "filename": "src/doc/trpl/enums.md", "status": "modified", "additions": 25, "deletions": 104, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/213708867ed1ed26f748de9a9c955dc64ba0e1ae/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/213708867ed1ed26f748de9a9c955dc64ba0e1ae/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=213708867ed1ed26f748de9a9c955dc64ba0e1ae", "patch": "@@ -1,11 +1,9 @@\n % Enums\n \n-Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n-feature of Rust, and are used throughout the standard library. An `enum` is\n-a type which relates a set of alternates to a specific name. For example, below\n-we define `Character` to be either a `Digit` or something else. These\n-can be used via their fully scoped names: `Character::Other` (more about `::`\n-below).\n+Rust has a \u2018sum type\u2019, an `enum`. Enums are an incredibly useful feature of\n+Rust, and are used throughout the standard library. An `enum` is a type which\n+relates a set of alternates to a specific name. For example, below we define\n+`Character` to be either a `Digit` or something else.\n \n ```rust\n enum Character {\n@@ -14,14 +12,14 @@ enum Character {\n }\n ```\n \n-Most normal types are allowed as the variant components of an `enum`. Here are\n-some examples:\n+Most types are allowed as the variant components of an `enum`. Here are some\n+examples:\n \n ```rust\n struct Empty;\n struct Color(i32, i32, i32);\n struct Length(i32);\n-struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n+struct Stats { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n struct HeightDatabase(Vec<i32>);\n ```\n \n@@ -30,12 +28,12 @@ In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n value, where `Other` is only a name. However, the fact that they represent\n distinct categories of `Character` is a very useful property.\n \n-As with structures, the variants of an enum by default are not comparable with\n-equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n-support other binary operations such as `*` and `+`. As such, the following code\n-is invalid for the example `Character` type:\n+The variants of an `enum` by default are not comparable with equality operators\n+(`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not support other\n+binary operations such as `*` and `+`. As such, the following code is invalid\n+for the example `Character` type:\n \n-```{rust,ignore}\n+```rust,ignore\n // These assignments both succeed\n let ten  = Character::Digit(10);\n let four = Character::Digit(4);\n@@ -50,98 +48,21 @@ let four_is_smaller = four <= ten;\n let four_equals_ten = four == ten;\n ```\n \n-This may seem rather limiting, but it's a limitation which we can overcome.\n-There are two ways: by implementing equality ourselves, or by pattern matching\n-variants with [`match`][match] expressions, which you'll learn in the next\n-chapter. We don't know enough about Rust to implement equality yet, but we can\n-use the `Ordering` enum from the standard library, which does:\n+We use the `::` syntax to use the name of each variant: They\u2019re scoped by the name\n+of the `enum` itself. This allows both of these to work:\n \n-```\n-enum Ordering {\n-    Less,\n-    Equal,\n-    Greater,\n-}\n-```\n-\n-Because `Ordering` has already been defined for us, we will import it with the\n-`use` keyword. Here's an example of how it is used:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives\n-in the `cmp` submodule of the `std` module. We'll talk more about modules later\n-in the guide. For now, all you need to know is that you can `use` things from\n-the standard library if you need them.\n-\n-Okay, let's talk about the actual code in the example. `cmp` is a function that\n-compares two things, and returns an `Ordering`. We return either\n-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n-whether the first value is less than, greater than, or equal to the second. Note\n-that each variant of the `enum` is namespaced under the `enum` itself: it's\n-`Ordering::Greater`, not `Greater`.\n-\n-The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We then do a bunch of `if`/`else` comparisons to check which\n-one it is.\n-\n-This `Ordering::Greater` notation is too long. Let's use another form of `use`\n-to import the `enum` variants instead. This will avoid full scoping:\n-\n-```{rust}\n-use std::cmp::Ordering::{self, Equal, Less, Greater};\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Less { println!(\"less\"); }\n-    else if ordering == Greater { println!(\"greater\"); }\n-    else if ordering == Equal { println!(\"equal\"); }\n-}\n+```rust,ignore\n+Character::Digit(10);\n+Hand::Digit;\n ```\n \n-Importing variants is convenient and compact, but can also cause name conflicts,\n-so do this with caution. For this reason, it's normally considered better style\n-to `use` an enum rather than its variants directly.\n+Both variants are named `Digit`, but since they\u2019re scoped to the `enum` name,\n \n-As you can see, `enum`s are quite a powerful tool for data representation, and\n-are even more useful when they're [generic][generics] across types. Before we\n-get to generics, though, let's talk about how to use enums with pattern\n-matching, a tool that will let us deconstruct sum types (the type theory term\n-for enums) like `Ordering` in a very elegant way that avoids all these messy\n-and brittle `if`/`else`s.\n+Not supporting these operations may seem rather limiting, but it\u2019s a limitation\n+which we can overcome. There are two ways: by implementing equality ourselves,\n+or by pattern matching variants with [`match`][match] expressions, which you\u2019ll\n+learn in the next section. We don\u2019t know enough about Rust to implement\n+equality yet, but we\u2019ll find out in the [`traits`][traits] section.\n \n-[match]: ./match.html\n-[generics]: ./generics.html\n+[match]: match.html\n+[traits]: traits.html"}]}