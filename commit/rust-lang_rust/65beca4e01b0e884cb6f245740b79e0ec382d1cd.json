{"sha": "65beca4e01b0e884cb6f245740b79e0ec382d1cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YmVjYTRlMDFiMGU4ODRjYjZmMjQ1NzQwYjc5ZTBlYzM4MmQxY2Q=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-26T20:43:27Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-27T00:10:48Z"}, "message": "Use iteration protocol for ebml, use vec::view in more places (issue #2880)", "tree": {"sha": "7dbf6cf0dfbae9d15b573e8bf4d74a65ae8f2aa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dbf6cf0dfbae9d15b573e8bf4d74a65ae8f2aa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65beca4e01b0e884cb6f245740b79e0ec382d1cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65beca4e01b0e884cb6f245740b79e0ec382d1cd", "html_url": "https://github.com/rust-lang/rust/commit/65beca4e01b0e884cb6f245740b79e0ec382d1cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65beca4e01b0e884cb6f245740b79e0ec382d1cd/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbbaa50290ed7c97154bbc44e7bd73937a9dcb5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbbaa50290ed7c97154bbc44e7bd73937a9dcb5e", "html_url": "https://github.com/rust-lang/rust/commit/dbbaa50290ed7c97154bbc44e7bd73937a9dcb5e"}], "stats": {"total": 109, "additions": 51, "deletions": 58}, "files": [{"sha": "88a415465d4d1abf6f8cc0ff1f0ba60f87aada9d", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=65beca4e01b0e884cb6f245740b79e0ec382d1cd", "patch": "@@ -98,33 +98,36 @@ fn get_doc(d: doc, tg: uint) -> doc {\n     }\n }\n \n-fn docs(d: doc, it: fn(uint, doc)) {\n+fn docs(d: doc, it: fn(uint, doc) -> bool) {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n-        it(elt_tag.val, {data: d.data, start: elt_size.next, end: pos});\n+        if !it(elt_tag.val, {data: d.data, start: elt_size.next, end: pos}) {\n+            break;\n+        }\n     }\n }\n \n-fn tagged_docs(d: doc, tg: uint, it: fn(doc)) {\n+fn tagged_docs(d: doc, tg: uint, it: fn(doc) -> bool) {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            it({data: d.data, start: elt_size.next, end: pos});\n+            if !it({data: d.data, start: elt_size.next, end: pos}) {\n+                break;\n+            }\n         }\n     }\n }\n \n fn doc_data(d: doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n fn with_doc_data<T>(d: doc, f: fn(x: &[u8]) -> T) -> T {\n-    // FIXME (#2880): use vec::view once the region inferencer can handle it.\n-    ret f(vec::slice::<u8>(*d.data, d.start, d.end));\n+    ret f(vec::slice(*d.data, d.start, d.end));\n }\n \n fn doc_as_str(d: doc) -> ~str { ret str::from_bytes(doc_data(d)); }"}, {"sha": "6d08b21f7e68c0531f71858601e0b401b4b54808", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=65beca4e01b0e884cb6f245740b79e0ec382d1cd", "patch": "@@ -63,37 +63,32 @@ export translate_def_id;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::doc, eq_fn: fn@(x:&[u8]) -> bool, hash: uint) ->\n-   ~[ebml::doc] {\n+fn lookup_hash(d: ebml::doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n+   option<ebml::doc> {\n     let index = ebml::get_doc(d, tag_index);\n     let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n     let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n     let {tag:_, doc:bucket} = ebml::doc_at(d.data, pos);\n-    // Awkward logic because we can't ret from foreach yet\n \n-    let mut result: ~[ebml::doc] = ~[];\n     let belt = tag_index_buckets_bucket_elt;\n-    do ebml::tagged_docs(bucket, belt) |elt| {\n+    for ebml::tagged_docs(bucket, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n-        // FIXME (#2880): use view here.\n-        if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n-            vec::push(result, ebml::doc_at(d.data, pos).doc);\n+        if eq_fn(vec::slice(*elt.data, elt.start + 4u, elt.end)) {\n+            ret some(ebml::doc_at(d.data, pos).doc);\n         }\n     };\n-    ret result;\n+    none\n }\n \n fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         ret io::u64_from_be_bytes(vec::slice(bytes, 0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n-    let eqer = |a| eq_item(a, item_id);\n-    let found = lookup_hash(items, eqer, hash_node_id(item_id));\n-    if vec::len(found) == 0u {\n-        ret option::none::<ebml::doc>;\n-    } else { ret option::some::<ebml::doc>(found[0]); }\n+    lookup_hash(items,\n+                |a| eq_item(a, item_id),\n+                hash_node_id(item_id))\n }\n \n fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n@@ -121,11 +116,10 @@ fn item_symbol(item: ebml::doc) -> ~str {\n }\n \n fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n-    let mut found = none;\n-    do ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        found = some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n+    for ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n+        ret some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n     }\n-    found\n+    none\n }\n \n // XXX: This has nothing to do with classes.\n@@ -171,7 +165,7 @@ fn item_type(item_id: ast::def_id, item: ebml::doc,\n \n fn item_impl_traits(item: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n     let mut results = ~[];\n-    do ebml::tagged_docs(item, tag_impl_trait) |ity| {\n+    for ebml::tagged_docs(item, tag_impl_trait) |ity| {\n         vec::push(results, doc_type(ity, tcx, cdata));\n     };\n     results\n@@ -180,7 +174,7 @@ fn item_impl_traits(item: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    do ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n+    for ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, |did| {\n             translate_def_id(cdata, did)\n         });\n@@ -199,14 +193,14 @@ fn item_ty_region_param(item: ebml::doc) -> bool {\n fn item_ty_param_count(item: ebml::doc) -> uint {\n     let mut n = 0u;\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n-                      |_p| n += 1u );\n+                      |_p| { n += 1u; true } );\n     n\n }\n \n fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    do ebml::tagged_docs(item, v) |p| {\n+    for ebml::tagged_docs(item, v) |p| {\n         let ext = ebml::with_doc_data(p, |d| parse_def_id(d));\n         vec::push(ids, {crate: cdata.cnum, node: ext.node});\n     };\n@@ -254,7 +248,7 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     let mut result = ~[];\n     vec::reserve(result, len);\n \n-    do ebml::docs(path_doc) |tag, elt_doc| {\n+    for ebml::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);\n             vec::push(result, ast_map::path_mod(@str));\n@@ -342,7 +336,7 @@ fn get_impl_method(cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n-    do ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n+    for ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n         let m_did = ebml::with_doc_data(mid, |d| parse_def_id(d));\n         if item_name(find_item(m_did.node, items)) == name {\n             found = some(translate_def_id(cdata, m_did));\n@@ -359,7 +353,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n             some(it) { it }\n             none { fail (#fmt(\"get_class_method: class id not found \\\n              when looking up method %s\", *name)) }};\n-    do ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n+    for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = class_member_id(mid, cdata);\n         if item_name(mid) == name {\n             found = some(m_did);\n@@ -379,7 +373,7 @@ fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n             none     { fail (#fmt(\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id)); }\n     };\n-    do ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n+    for ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n          let doc1 = ebml::get_doc(doc, tag_def_id);\n          let did = ebml::with_doc_data(doc1, |d| parse_def_id(d));\n          found = some(translate_def_id(cdata, did));\n@@ -428,7 +422,7 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n     let mut broken = false;\n \n     // First, go through all the explicit items.\n-    do ebml::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n+    for ebml::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n         if !broken {\n             let name = ast_map::path_to_str_with_sep(item_path(item_doc),\n                                                      ~\"::\");\n@@ -494,11 +488,11 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n         }\n     }\n \n-    do ebml::tagged_docs(inner_paths, tag_paths_data_item) |path_doc| {\n+    for ebml::tagged_docs(inner_paths, tag_paths_data_item) |path_doc| {\n         g(cdata, items, path_doc, broken, f);\n     }\n \n-    do ebml::tagged_docs(inner_paths, tag_paths_foreign_path) |path_doc| {\n+    for ebml::tagged_docs(inner_paths, tag_paths_foreign_path) |path_doc| {\n         g(cdata, items, path_doc, broken, f);\n     }\n }\n@@ -577,7 +571,7 @@ type _impl = {did: ast::def_id, ident: ast::ident, methods: ~[@method_info]};\n fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n     -> ~[@method_info] {\n     let mut rslt = ~[];\n-    do ebml::tagged_docs(item, tag_item_impl_method) |doc| {\n+    for ebml::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         vec::push(rslt, @{did: translate_def_id(cdata, m_did),\n@@ -597,7 +591,7 @@ fn get_impls_for_mod(cdata: cmd,\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n-    do ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n+    for ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n         let did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n         let local_did = translate_def_id(cdata, did);\n         #debug(\"(get impls for mod) getting did %? for '%?'\",\n@@ -625,7 +619,7 @@ fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n+    for ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n@@ -655,7 +649,7 @@ fn get_method_names_if_trait(cdata: cmd, node_id: ast::node_id)\n     }\n \n     let resulting_method_names = @dvec();\n-    do ebml::tagged_docs(item, tag_item_trait_method) |method| {\n+    for ebml::tagged_docs(item, tag_item_trait_method) |method| {\n         (*resulting_method_names).push(item_name(method));\n     }\n     ret some(resulting_method_names);\n@@ -666,8 +660,8 @@ fn get_item_attrs(cdata: cmd,\n                   f: fn(~[@ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n-    do ebml::tagged_docs(item, tag_attributes) |attributes| {\n-        do ebml::tagged_docs(attributes, tag_attribute) |attribute| {\n+    for ebml::tagged_docs(item, tag_attributes) |attributes| {\n+        for ebml::tagged_docs(attributes, tag_attribute) |attribute| {\n             f(get_meta_items(attribute));\n         }\n     }\n@@ -679,7 +673,7 @@ fn get_class_members(cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do ebml::tagged_docs(item, tag_item_field) |an_item| {\n+    for ebml::tagged_docs(item, tag_item_field) |an_item| {\n        let f = item_family(an_item);\n        if p(f) {\n           let name = item_name(an_item);\n@@ -760,12 +754,12 @@ fn item_family_to_str(fam: char) -> ~str {\n \n fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n-    do ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n+    for ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         vec::push(items, attr::mk_word_item(@n));\n     };\n-    do ebml::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n+    for ebml::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = str::from_bytes(ebml::doc_data(nd));\n@@ -774,7 +768,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n         // but currently the encoder just drops them\n         vec::push(items, attr::mk_name_value_item_str(@n, v));\n     };\n-    do ebml::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n+    for ebml::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n@@ -787,7 +781,7 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n     alt ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n-        do ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n+        for ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -835,7 +829,7 @@ fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     fn docstr(doc: ebml::doc, tag_: uint) -> ~str {\n         str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n     }\n-    do ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n+    for ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         vec::push(deps, {cnum: crate_num,\n                   name: @docstr(depdoc, tag_crate_dep_name),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n@@ -889,9 +883,9 @@ fn iter_crate_items(bytes: @~[u8], proc: fn(uint, ~str, ast::def_id)) {\n     let paths = ebml::get_doc(md, tag_paths);\n     let index = ebml::get_doc(paths, tag_index);\n     let bs = ebml::get_doc(index, tag_index_buckets);\n-    do ebml::tagged_docs(bs, tag_index_buckets_bucket) |bucket| {\n+    for ebml::tagged_docs(bs, tag_index_buckets_bucket) |bucket| {\n         let et = tag_index_buckets_bucket_elt;\n-        do ebml::tagged_docs(bucket, et) |elt| {\n+        for ebml::tagged_docs(bucket, et) |elt| {\n             let data = read_path(elt);\n             let {tag:t, doc:def} = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);"}, {"sha": "38c23be1b5c4922302f6d6a6f581d0ed0a1ab1f9", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=65beca4e01b0e884cb6f245740b79e0ec382d1cd", "patch": "@@ -841,7 +841,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                       ast_doc: ebml::doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table];\n-    do ebml::docs(tbl_doc) |tag, entry_doc| {\n+    for ebml::docs(tbl_doc) |tag, entry_doc| {\n         let id0 = entry_doc[c::tag_table_id].as_int();\n         let id = xcx.tr_id(id0);\n "}, {"sha": "1f55d003bceaad2e2b2c1b51ce1f4268ccda4fa4", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=65beca4e01b0e884cb6f245740b79e0ec382d1cd", "patch": "@@ -15,8 +15,7 @@ fn main(argv: ~[~str]) {\n         ]\n     ];\n \n-    // FIXME (#2880)\n-    let tests = vec::slice(argv, 1, argv.len());\n+    let tests = vec::view(argv, 1, argv.len());\n \n     #bench[shift_push];\n     #bench[read_line];"}, {"sha": "2d9eaec7ad1eb4c854af21f250c5f6fa95240aac", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=65beca4e01b0e884cb6f245740b79e0ec382d1cd", "patch": "@@ -81,8 +81,7 @@ fn windows_with_carry(bb: ~[const u8], nn: uint,\n \n    let len = vec::len(bb);\n    while ii < len - (nn - 1u) {\n-       // FIXME (#2880)\n-      it(vec::slice(bb, ii, ii+nn));\n+      it(vec::view(bb, ii, ii+nn));\n       ii += 1u;\n    }\n "}, {"sha": "31f373ff295908f06d8dfcb490c379a9631e830c", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=65beca4e01b0e884cb6f245740b79e0ec382d1cd", "patch": "@@ -79,8 +79,7 @@ fn windows_with_carry(bb: ~[const u8], nn: uint,\n \n    let len = vec::len(bb);\n    while ii < len - (nn - 1u) {\n-       // FIXME (#2880)\n-      it(vec::slice(bb, ii, ii+nn));\n+      it(vec::view(bb, ii, ii+nn));\n       ii += 1u;\n    }\n "}, {"sha": "f5e0e81cc38aa3353471a8f5dd997d2b89cb720c", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65beca4e01b0e884cb6f245740b79e0ec382d1cd/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=65beca4e01b0e884cb6f245740b79e0ec382d1cd", "patch": "@@ -308,8 +308,7 @@ fn main(argv: ~[~str]) {\n     }\n \n     let readers: ~[fn~() -> word_reader]  = if argv.len() >= 2 {\n-        // FIXME (#2880)\n-        vec::slice(argv, 1u, argv.len()).map(\n+        vec::view(argv, 1u, argv.len()).map(\n             |f| fn~() -> word_reader { file_word_reader(f) } )\n     }\n     else {"}]}