{"sha": "2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "node_id": "C_kwDOAAsO6NoAKDJmMWZhMTI2NTlhYzZiODUyYTlkZWM0NmI3OWEwYjAyNzM2ZjRlNDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-13T21:20:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-13T21:20:13Z"}, "message": "Auto merge of #2506 - pvdrz:a-really-bad-clock, r=saethlin\n\nMake `sleep` work with isolation enabled\n\nImplement a virtual monotone clock that can be used to track time while isolation is enabled. This virtual clock keeps an internal nanoseconds counter that will be increased by a fixed amount at the end of every basic block.\n\nWhen a process sleeps, this clock will return immediately and increase the counter by the interval the process was supposed to sleep. Making miri execution faster than native code :trollface:.\n\ncc `@RalfJung` `@saethlin` `@JakobDegen`", "tree": {"sha": "d4aff5aa053c6916728623863cd834b54d329d58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4aff5aa053c6916728623863cd834b54d329d58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "html_url": "https://github.com/rust-lang/rust/commit/2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e66a9ff1690a7b4e0b46110350814ff8de251c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e66a9ff1690a7b4e0b46110350814ff8de251c9", "html_url": "https://github.com/rust-lang/rust/commit/7e66a9ff1690a7b4e0b46110350814ff8de251c9"}, {"sha": "c8346376264ea99cafd6550b5b5f460cf82b326f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8346376264ea99cafd6550b5b5f460cf82b326f", "html_url": "https://github.com/rust-lang/rust/commit/c8346376264ea99cafd6550b5b5f460cf82b326f"}], "stats": {"total": 257, "additions": 204, "deletions": 53}, "files": [{"sha": "3f33273e1e541d577409d58e6fd756da531580bc", "filename": "src/clock.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fclock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fclock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclock.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -0,0 +1,115 @@\n+use std::sync::atomic::{AtomicU64, Ordering};\n+use std::time::{Duration, Instant as StdInstant};\n+\n+/// When using a virtual clock, this defines how many nanoseconds we pretend are passing for each\n+/// basic block.\n+const NANOSECONDS_PER_BASIC_BLOCK: u64 = 10;\n+\n+#[derive(Debug)]\n+pub struct Instant {\n+    kind: InstantKind,\n+}\n+\n+#[derive(Debug)]\n+enum InstantKind {\n+    Host(StdInstant),\n+    Virtual { nanoseconds: u64 },\n+}\n+\n+impl Instant {\n+    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {\n+        match self.kind {\n+            InstantKind::Host(instant) =>\n+                instant.checked_add(duration).map(|i| Instant { kind: InstantKind::Host(i) }),\n+            InstantKind::Virtual { nanoseconds } =>\n+                u128::from(nanoseconds)\n+                    .checked_add(duration.as_nanos())\n+                    .and_then(|n| u64::try_from(n).ok())\n+                    .map(|nanoseconds| Instant { kind: InstantKind::Virtual { nanoseconds } }),\n+        }\n+    }\n+\n+    pub fn duration_since(&self, earlier: Instant) -> Duration {\n+        match (&self.kind, earlier.kind) {\n+            (InstantKind::Host(instant), InstantKind::Host(earlier)) =>\n+                instant.duration_since(earlier),\n+            (\n+                InstantKind::Virtual { nanoseconds },\n+                InstantKind::Virtual { nanoseconds: earlier },\n+            ) => Duration::from_nanos(nanoseconds.saturating_sub(earlier)),\n+            _ => panic!(\"all `Instant` must be of the same kind\"),\n+        }\n+    }\n+}\n+\n+/// A monotone clock used for `Instant` simulation.\n+#[derive(Debug)]\n+pub struct Clock {\n+    kind: ClockKind,\n+}\n+\n+#[derive(Debug)]\n+enum ClockKind {\n+    Host {\n+        /// The \"time anchor\" for this machine's monotone clock.\n+        time_anchor: StdInstant,\n+    },\n+    Virtual {\n+        /// The \"current virtual time\".\n+        nanoseconds: AtomicU64,\n+    },\n+}\n+\n+impl Clock {\n+    /// Create a new clock based on the availability of communication with the host.\n+    pub fn new(communicate: bool) -> Self {\n+        let kind = if communicate {\n+            ClockKind::Host { time_anchor: StdInstant::now() }\n+        } else {\n+            ClockKind::Virtual { nanoseconds: 0.into() }\n+        };\n+\n+        Self { kind }\n+    }\n+\n+    /// Let the time pass for a small interval.\n+    pub fn tick(&self) {\n+        match &self.kind {\n+            ClockKind::Host { .. } => {\n+                // Time will pass without us doing anything.\n+            }\n+            ClockKind::Virtual { nanoseconds } => {\n+                nanoseconds.fetch_add(NANOSECONDS_PER_BASIC_BLOCK, Ordering::SeqCst);\n+            }\n+        }\n+    }\n+\n+    /// Sleep for the desired duration.\n+    pub fn sleep(&self, duration: Duration) {\n+        match &self.kind {\n+            ClockKind::Host { .. } => std::thread::sleep(duration),\n+            ClockKind::Virtual { nanoseconds } => {\n+                // Just pretend that we have slept for some time.\n+                nanoseconds.fetch_add(duration.as_nanos().try_into().unwrap(), Ordering::SeqCst);\n+            }\n+        }\n+    }\n+\n+    /// Return the `anchor` instant, to convert between monotone instants and durations relative to the anchor.\n+    pub fn anchor(&self) -> Instant {\n+        match &self.kind {\n+            ClockKind::Host { time_anchor } => Instant { kind: InstantKind::Host(*time_anchor) },\n+            ClockKind::Virtual { .. } => Instant { kind: InstantKind::Virtual { nanoseconds: 0 } },\n+        }\n+    }\n+\n+    pub fn now(&self) -> Instant {\n+        match &self.kind {\n+            ClockKind::Host { .. } => Instant { kind: InstantKind::Host(StdInstant::now()) },\n+            ClockKind::Virtual { nanoseconds } =>\n+                Instant {\n+                    kind: InstantKind::Virtual { nanoseconds: nanoseconds.load(Ordering::SeqCst) },\n+                },\n+        }\n+    }\n+}"}, {"sha": "78a357dd6aff8f205f37d174c5348178377d3dc7", "filename": "src/concurrency/thread.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fthread.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -3,7 +3,7 @@\n use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::num::TryFromIntError;\n-use std::time::{Duration, Instant, SystemTime};\n+use std::time::{Duration, SystemTime};\n \n use log::trace;\n \n@@ -189,9 +189,9 @@ pub enum Time {\n \n impl Time {\n     /// How long do we have to wait from now until the specified time?\n-    fn get_wait_time(&self) -> Duration {\n+    fn get_wait_time(&self, clock: &Clock) -> Duration {\n         match self {\n-            Time::Monotonic(instant) => instant.saturating_duration_since(Instant::now()),\n+            Time::Monotonic(instant) => instant.duration_since(clock.now()),\n             Time::RealTime(time) =>\n                 time.duration_since(SystemTime::now()).unwrap_or(Duration::new(0, 0)),\n         }\n@@ -490,13 +490,16 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get a callback that is ready to be called.\n-    fn get_ready_callback(&mut self) -> Option<(ThreadId, TimeoutCallback<'mir, 'tcx>)> {\n+    fn get_ready_callback(\n+        &mut self,\n+        clock: &Clock,\n+    ) -> Option<(ThreadId, TimeoutCallback<'mir, 'tcx>)> {\n         // We iterate over all threads in the order of their indices because\n         // this allows us to have a deterministic scheduler.\n         for thread in self.threads.indices() {\n             match self.timeout_callbacks.entry(thread) {\n                 Entry::Occupied(entry) =>\n-                    if entry.get().call_time.get_wait_time() == Duration::new(0, 0) {\n+                    if entry.get().call_time.get_wait_time(clock) == Duration::new(0, 0) {\n                         return Some((thread, entry.remove().callback));\n                     },\n                 Entry::Vacant(_) => {}\n@@ -553,7 +556,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// used in stateless model checkers such as Loom: run the active thread as\n     /// long as we can and switch only when we have to (the active thread was\n     /// blocked, terminated, or has explicitly asked to be preempted).\n-    fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n+    fn schedule(&mut self, clock: &Clock) -> InterpResult<'tcx, SchedulingAction> {\n         // Check whether the thread has **just** terminated (`check_terminated`\n         // checks whether the thread has popped all its stack and if yes, sets\n         // the thread state to terminated).\n@@ -580,7 +583,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         // at the time of the call\".\n         // <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html>\n         let potential_sleep_time =\n-            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min();\n+            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time(clock)).min();\n         if potential_sleep_time == Some(Duration::new(0, 0)) {\n             return Ok(SchedulingAction::ExecuteTimeoutCallback);\n         }\n@@ -615,7 +618,8 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             // All threads are currently blocked, but we have unexecuted\n             // timeout_callbacks, which may unblock some of the threads. Hence,\n             // sleep until the first callback.\n-            std::thread::sleep(sleep_time);\n+\n+            clock.sleep(sleep_time);\n             Ok(SchedulingAction::ExecuteTimeoutCallback)\n         } else {\n             throw_machine_stop!(TerminationInfo::Deadlock);\n@@ -865,6 +869,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         callback: TimeoutCallback<'mir, 'tcx>,\n     ) {\n         let this = self.eval_context_mut();\n+        if !this.machine.communicate() && matches!(call_time, Time::RealTime(..)) {\n+            panic!(\"cannot have `RealTime` callback with isolation enabled!\")\n+        }\n         this.machine.threads.register_timeout_callback(thread, call_time, callback);\n     }\n \n@@ -878,18 +885,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn run_timeout_callback(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let (thread, callback) =\n-            if let Some((thread, callback)) = this.machine.threads.get_ready_callback() {\n-                (thread, callback)\n-            } else {\n-                // get_ready_callback can return None if the computer's clock\n-                // was shifted after calling the scheduler and before the call\n-                // to get_ready_callback (see issue\n-                // https://github.com/rust-lang/miri/issues/1763). In this case,\n-                // just do nothing, which effectively just returns to the\n-                // scheduler.\n-                return Ok(());\n-            };\n+        let (thread, callback) = if let Some((thread, callback)) =\n+            this.machine.threads.get_ready_callback(&this.machine.clock)\n+        {\n+            (thread, callback)\n+        } else {\n+            // get_ready_callback can return None if the computer's clock\n+            // was shifted after calling the scheduler and before the call\n+            // to get_ready_callback (see issue\n+            // https://github.com/rust-lang/miri/issues/1763). In this case,\n+            // just do nothing, which effectively just returns to the\n+            // scheduler.\n+            return Ok(());\n+        };\n         // This back-and-forth with `set_active_thread` is here because of two\n         // design decisions:\n         // 1. Make the caller and not the callback responsible for changing\n@@ -906,7 +914,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.schedule()\n+        this.machine.threads.schedule(&this.machine.clock)\n     }\n \n     /// Handles thread termination of the active thread: wakes up threads joining on this one,"}, {"sha": "e1ef7fa9817533b573025b3b4189ec0fe5a70ebd", "filename": "src/eval.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -359,11 +359,6 @@ pub fn eval_entry<'tcx>(\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n                 }\n                 SchedulingAction::ExecuteTimeoutCallback => {\n-                    assert!(\n-                        ecx.machine.communicate(),\n-                        \"scheduler callbacks require disabled isolation, but the code \\\n-                        that created the callback did not check it\"\n-                    );\n                     ecx.run_timeout_callback()?;\n                 }\n                 SchedulingAction::ExecuteDtors => {"}, {"sha": "016ed01f4dac28bd2ec4ec88da97797f39087f5f", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -51,6 +51,7 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n \n+mod clock;\n mod concurrency;\n mod diagnostics;\n mod eval;\n@@ -81,6 +82,7 @@ pub use crate::shims::time::EvalContextExt as _;\n pub use crate::shims::tls::{EvalContextExt as _, TlsData};\n pub use crate::shims::EvalContextExt as _;\n \n+pub use crate::clock::{Clock, Instant};\n pub use crate::concurrency::{\n     data_race::{\n         AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n@@ -89,7 +91,7 @@ pub use crate::concurrency::{\n     sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId},\n     thread::{\n         EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager,\n-        ThreadState,\n+        ThreadState, Time,\n     },\n };\n pub use crate::diagnostics::{"}, {"sha": "bd2c43004653c7fb4c667e5770255f760bd50765", "filename": "src/machine.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -4,7 +4,6 @@\n use std::borrow::Cow;\n use std::cell::RefCell;\n use std::fmt;\n-use std::time::Instant;\n \n use rand::rngs::StdRng;\n use rand::SeedableRng;\n@@ -327,8 +326,8 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// The table of directory descriptors.\n     pub(crate) dir_handler: shims::unix::DirHandler,\n \n-    /// The \"time anchor\" for this machine's monotone clock (for `Instant` simulation).\n-    pub(crate) time_anchor: Instant,\n+    /// This machine's monotone clock.\n+    pub(crate) clock: Clock,\n \n     /// The set of threads.\n     pub(crate) threads: ThreadManager<'mir, 'tcx>,\n@@ -434,7 +433,6 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             enforce_abi: config.check_abi,\n             file_handler: FileHandler::new(config.mute_stdout_stderr),\n             dir_handler: Default::default(),\n-            time_anchor: Instant::now(),\n             layouts,\n             threads: ThreadManager::default(),\n             static_roots: Vec::new(),\n@@ -454,6 +452,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             preemption_rate: config.preemption_rate,\n             report_progress: config.report_progress,\n             basic_block_count: 0,\n+            clock: Clock::new(config.isolated_op == IsolatedOp::Allow),\n             external_so_lib: config.external_so_file.as_ref().map(|lib_file_path| {\n                 // Check if host target == the session target.\n                 if env!(\"TARGET\") != target_triple {\n@@ -1036,6 +1035,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n         // These are our preemption points.\n         ecx.maybe_preempt_active_thread();\n+\n+        // Make sure some time passes.\n+        ecx.machine.clock.tick();\n+\n         Ok(())\n     }\n "}, {"sha": "f083ab499009994be03a277b91ea80e50cefbabb", "filename": "src/shims/time.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -1,6 +1,5 @@\n-use std::time::{Duration, Instant, SystemTime};\n+use std::time::{Duration, SystemTime};\n \n-use crate::concurrency::thread::Time;\n use crate::*;\n \n /// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n@@ -23,7 +22,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"linux\", \"clock_gettime\");\n-        this.check_no_isolation(\"`clock_gettime`\")?;\n \n         let clk_id = this.read_scalar(clk_id_op)?.to_i32()?;\n \n@@ -40,9 +38,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             [this.eval_libc_i32(\"CLOCK_MONOTONIC\")?, this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\")?];\n \n         let duration = if absolute_clocks.contains(&clk_id) {\n+            this.check_no_isolation(\"`clock_gettime` with `REALTIME` clocks\")?;\n             system_time_to_duration(&SystemTime::now())?\n         } else if relative_clocks.contains(&clk_id) {\n-            Instant::now().duration_since(this.machine.time_anchor)\n+            this.machine.clock.now().duration_since(this.machine.clock.anchor())\n         } else {\n             let einval = this.eval_libc(\"EINVAL\")?;\n             this.set_last_error(einval)?;\n@@ -123,11 +122,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"QueryPerformanceCounter\");\n-        this.check_no_isolation(\"`QueryPerformanceCounter`\")?;\n \n         // QueryPerformanceCounter uses a hardware counter as its basis.\n         // Miri will emulate a counter with a resolution of 1 nanosecond.\n-        let duration = Instant::now().duration_since(this.machine.time_anchor);\n+        let duration = this.machine.clock.now().duration_since(this.machine.clock.anchor());\n         let qpc = i64::try_from(duration.as_nanos()).map_err(|_| {\n             err_unsup_format!(\"programs running longer than 2^63 nanoseconds are not supported\")\n         })?;\n@@ -146,7 +144,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"QueryPerformanceFrequency\");\n-        this.check_no_isolation(\"`QueryPerformanceFrequency`\")?;\n \n         // Retrieves the frequency of the hardware performance counter.\n         // The frequency of the performance counter is fixed at system boot and\n@@ -164,11 +161,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_ref();\n \n         this.assert_target_os(\"macos\", \"mach_absolute_time\");\n-        this.check_no_isolation(\"`mach_absolute_time`\")?;\n \n         // This returns a u64, with time units determined dynamically by `mach_timebase_info`.\n         // We return plain nanoseconds.\n-        let duration = Instant::now().duration_since(this.machine.time_anchor);\n+        let duration = this.machine.clock.now().duration_since(this.machine.clock.anchor());\n         let res = u64::try_from(duration.as_nanos()).map_err(|_| {\n             err_unsup_format!(\"programs running longer than 2^64 nanoseconds are not supported\")\n         })?;\n@@ -182,7 +178,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"macos\", \"mach_timebase_info\");\n-        this.check_no_isolation(\"`mach_timebase_info`\")?;\n \n         let info = this.deref_operand(info_op)?;\n \n@@ -202,7 +197,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os_is_unix(\"nanosleep\");\n-        this.check_no_isolation(\"`nanosleep`\")?;\n \n         let duration = match this.read_timespec(&this.deref_operand(req_op)?)? {\n             Some(duration) => duration,\n@@ -213,17 +207,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         };\n         // If adding the duration overflows, let's just sleep for an hour. Waking up early is always acceptable.\n-        let timeout_time = Instant::now()\n+        let now = this.machine.clock.now();\n+        let timeout_time = now\n             .checked_add(duration)\n-            .unwrap_or_else(|| Instant::now().checked_add(Duration::from_secs(3600)).unwrap());\n-        let timeout_time = Time::Monotonic(timeout_time);\n+            .unwrap_or_else(|| now.checked_add(Duration::from_secs(3600)).unwrap());\n \n         let active_thread = this.get_active_thread();\n         this.block_thread(active_thread);\n \n         this.register_timeout_callback(\n             active_thread,\n-            timeout_time,\n+            Time::Monotonic(timeout_time),\n             Box::new(move |ecx| {\n                 ecx.unblock_thread(active_thread);\n                 Ok(())\n@@ -238,19 +232,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"Sleep\");\n-        this.check_no_isolation(\"`Sleep`\")?;\n \n         let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n \n         let duration = Duration::from_millis(timeout_ms.into());\n-        let timeout_time = Time::Monotonic(Instant::now().checked_add(duration).unwrap());\n+        let timeout_time = this.machine.clock.now().checked_add(duration).unwrap();\n \n         let active_thread = this.get_active_thread();\n         this.block_thread(active_thread);\n \n         this.register_timeout_callback(\n             active_thread,\n-            timeout_time,\n+            Time::Monotonic(timeout_time),\n             Box::new(move |ecx| {\n                 ecx.unblock_thread(active_thread);\n                 Ok(())"}, {"sha": "cf5a945c5fa5b9f757ce4b8cc1fecf69c98f1320", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -1,7 +1,7 @@\n use crate::concurrency::thread::Time;\n use crate::*;\n use rustc_target::abi::{Align, Size};\n-use std::time::{Instant, SystemTime};\n+use std::time::SystemTime;\n \n /// Implementation of the SYS_futex syscall.\n /// `args` is the arguments *after* the syscall number.\n@@ -106,14 +106,14 @@ pub fn futex<'tcx>(\n                     if op & futex_realtime != 0 {\n                         Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n                     } else {\n-                        Time::Monotonic(this.machine.time_anchor.checked_add(duration).unwrap())\n+                        Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())\n                     }\n                 } else {\n                     // FUTEX_WAIT uses a relative timestamp.\n                     if op & futex_realtime != 0 {\n                         Time::RealTime(SystemTime::now().checked_add(duration).unwrap())\n                     } else {\n-                        Time::Monotonic(Instant::now().checked_add(duration).unwrap())\n+                        Time::Monotonic(this.machine.clock.now().checked_add(duration).unwrap())\n                     }\n                 })\n             };"}, {"sha": "496985fd083fc1d30c213adc45342b233925c6ee", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -840,7 +840,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n             Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n         } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n-            Time::Monotonic(this.machine.time_anchor.checked_add(duration).unwrap())\n+            Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())\n         } else {\n             throw_unsup_format!(\"unsupported clock id: {}\", clock_id);\n         };"}, {"sha": "b6444319b59b9ca40dcd37544fed6ffc337b7ae9", "filename": "tests/pass/shims/time-with-isolation.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/tests%2Fpass%2Fshims%2Ftime-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1fa12659ac6b852a9dec46b79a0b02736f4e44/tests%2Fpass%2Fshims%2Ftime-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fshims%2Ftime-with-isolation.rs?ref=2f1fa12659ac6b852a9dec46b79a0b02736f4e44", "patch": "@@ -0,0 +1,35 @@\n+use std::time::{Duration, Instant};\n+\n+fn test_sleep() {\n+    // We sleep a *long* time here -- but the clock is virtual so the test should still pass quickly.\n+    let before = Instant::now();\n+    std::thread::sleep(Duration::from_secs(3600));\n+    let after = Instant::now();\n+    assert!((after - before).as_secs() >= 3600);\n+}\n+\n+/// Ensure that time passes even if we don't sleep (but just work).\n+fn test_time_passes() {\n+    // Check `Instant`.\n+    let now1 = Instant::now();\n+    // Do some work to make time pass.\n+    for _ in 0..10 {\n+        drop(vec![42]);\n+    }\n+    let now2 = Instant::now();\n+    assert!(now2 > now1);\n+    // Sanity-check the difference we got.\n+    let diff = now2.duration_since(now1);\n+    assert_eq!(now1 + diff, now2);\n+    assert_eq!(now2 - diff, now1);\n+    // The virtual clock is deterministic and I got 29us on a 64-bit Linux machine. However, this\n+    // changes according to the platform so we use an interval to be safe. This should be updated\n+    // if `NANOSECONDS_PER_BASIC_BLOCK` changes.\n+    assert!(diff.as_micros() > 10);\n+    assert!(diff.as_micros() < 40);\n+}\n+\n+fn main() {\n+    test_time_passes();\n+    test_sleep();\n+}"}]}