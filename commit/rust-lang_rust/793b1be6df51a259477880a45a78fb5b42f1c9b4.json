{"sha": "793b1be6df51a259477880a45a78fb5b42f1c9b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5M2IxYmU2ZGY1MWEyNTk0Nzc4ODBhNDVhNzhmYjViNDJmMWM5YjQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-01-10T19:50:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-10T19:50:46Z"}, "message": "Rollup merge of #67258 - Centril:open-ended-ranges, r=oli-obk\n\nIntroduce `X..`, `..X`, and `..=X` range patterns\n\nTracking issue: https://github.com/rust-lang/rust/issues/67264\nFeature gate: `#![feature(half_open_range_patterns)]`\n\n---------------------------\n\nIn this PR, we introduce range-from (`X..`), range-to (`..X`), and range-to-inclusive (`..=X`) patterns.\nThese correspond to the `RangeFrom`, `RangeTo`, and `RangeToInclusive` expression forms introduced with the same syntaxes. The correspondence is both syntactic and semantic (in the sense that e.g. a `X..` pattern matching on a scrutinee `s` holds exactly when `(X..).contains(&s)` holds).\n\n---------------------------\n\nNoteworthy:\n\n- The compiler complexity added with this PR is around 10 lines (discounting new tests, which account for the large PR size).\n\n- `...X` is accepted syntactically with the same meaning as `..=X`. This is done primarily to simplify and unify the implementation & spec. If-and-when we decide to make `X...Y` a hard error on a new edition, we can do the same for `...X` patterns as well.\n\n- `X...` and `X..=` is rejected syntactically just like it is for the expression equivalents. We should perhaps make these into semantic restrictions (cc @petrochenkov).\n\n- In HAIR, these half-open ranges are represented by inserting the max/min values for the approprate types. That is, `X..` where `X: u8` would become `X..=u8::MAX` in HAIR (note the `..=` since `RangeFrom` includes the end).\n\n- Exhaustive integer / char matching does not (yet) allow for e.g. exhaustive matching on `0usize..` or `..5usize | 5..` (same idea for `isize`). This would be a substantially more invasive change, and could be added in some other PR.\n\n- The issues with slice pattern syntax has been resolved as we decided to use `..` to mean a \"rest-pattern\" and `[xs @ ..]` to bind the rest to a name in a slice pattern.\n\n- Like with https://github.com/rust-lang/rust/pull/35712, which provided `X..Y` range patterns, this is not yet backed up by an RFC. I'm providing this experimental implementation now to have something concrete to discuss. I would be happy to provide an RFC for this PR as well as for #35712 to finalize and confirm the ideas with the larger community.\n\nCloses https://github.com/rust-lang/rfcs/issues/947.\n\n---------------------------\n\nr? @varkor cc @matthewjasper @oli-obk\n\nI would recommend reviewing this (in particular HAIR-lowering and pattern parsing changes) with whitespace changes ignored.", "tree": {"sha": "d29b8a4b57c383e12742c71fa115759e47595e4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d29b8a4b57c383e12742c71fa115759e47595e4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/793b1be6df51a259477880a45a78fb5b42f1c9b4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeGNWXCRBK7hj4Ov3rIwAAdHIIACbdvr+I+xblkTIitAtnYUJB\nlwS/dfh9uaNYU12+PmizuRpa8jW3IRgVbrIzOee7cmV5fmr8pcDXDgrXNYbz/+bj\n8m92DBAtKgYZlRKp4F0zsyzcztL3GTZ7t0kWhjGRJ1YZCTkqigvamr26Nn0kUM+H\nStv1lWmVZnrTK1aD1/DzCQs3Kbwf/APlvTQg/CJnVuWtudlF5hiyftZCgGY11BzV\nIFLCbbZrBz1dmgoWZgWOFM9D71ytbsI4TOOtC4STrDSX1iC+FIEWlTbdtJT1hjpU\nnmYwqiTny6T+X132urLbPBbmSqTyEZ13KiQfHsWYRsTfEPH4/2S3jIwyhxSgF9g=\n=nSoh\n-----END PGP SIGNATURE-----\n", "payload": "tree d29b8a4b57c383e12742c71fa115759e47595e4e\nparent 2dbcf0841a81fbada9a2b3af253b62b30a8318cc\nparent d5598aa7a07b324789576585f4f035c93993fea4\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1578685846 +0900\ncommitter GitHub <noreply@github.com> 1578685846 +0900\n\nRollup merge of #67258 - Centril:open-ended-ranges, r=oli-obk\n\nIntroduce `X..`, `..X`, and `..=X` range patterns\n\nTracking issue: https://github.com/rust-lang/rust/issues/67264\nFeature gate: `#![feature(half_open_range_patterns)]`\n\n---------------------------\n\nIn this PR, we introduce range-from (`X..`), range-to (`..X`), and range-to-inclusive (`..=X`) patterns.\nThese correspond to the `RangeFrom`, `RangeTo`, and `RangeToInclusive` expression forms introduced with the same syntaxes. The correspondence is both syntactic and semantic (in the sense that e.g. a `X..` pattern matching on a scrutinee `s` holds exactly when `(X..).contains(&s)` holds).\n\n---------------------------\n\nNoteworthy:\n\n- The compiler complexity added with this PR is around 10 lines (discounting new tests, which account for the large PR size).\n\n- `...X` is accepted syntactically with the same meaning as `..=X`. This is done primarily to simplify and unify the implementation & spec. If-and-when we decide to make `X...Y` a hard error on a new edition, we can do the same for `...X` patterns as well.\n\n- `X...` and `X..=` is rejected syntactically just like it is for the expression equivalents. We should perhaps make these into semantic restrictions (cc @petrochenkov).\n\n- In HAIR, these half-open ranges are represented by inserting the max/min values for the approprate types. That is, `X..` where `X: u8` would become `X..=u8::MAX` in HAIR (note the `..=` since `RangeFrom` includes the end).\n\n- Exhaustive integer / char matching does not (yet) allow for e.g. exhaustive matching on `0usize..` or `..5usize | 5..` (same idea for `isize`). This would be a substantially more invasive change, and could be added in some other PR.\n\n- The issues with slice pattern syntax has been resolved as we decided to use `..` to mean a \"rest-pattern\" and `[xs @ ..]` to bind the rest to a name in a slice pattern.\n\n- Like with https://github.com/rust-lang/rust/pull/35712, which provided `X..Y` range patterns, this is not yet backed up by an RFC. I'm providing this experimental implementation now to have something concrete to discuss. I would be happy to provide an RFC for this PR as well as for #35712 to finalize and confirm the ideas with the larger community.\n\nCloses https://github.com/rust-lang/rfcs/issues/947.\n\n---------------------------\n\nr? @varkor cc @matthewjasper @oli-obk\n\nI would recommend reviewing this (in particular HAIR-lowering and pattern parsing changes) with whitespace changes ignored.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/793b1be6df51a259477880a45a78fb5b42f1c9b4", "html_url": "https://github.com/rust-lang/rust/commit/793b1be6df51a259477880a45a78fb5b42f1c9b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/793b1be6df51a259477880a45a78fb5b42f1c9b4/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dbcf0841a81fbada9a2b3af253b62b30a8318cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dbcf0841a81fbada9a2b3af253b62b30a8318cc", "html_url": "https://github.com/rust-lang/rust/commit/2dbcf0841a81fbada9a2b3af253b62b30a8318cc"}, {"sha": "d5598aa7a07b324789576585f4f035c93993fea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5598aa7a07b324789576585f4f035c93993fea4", "html_url": "https://github.com/rust-lang/rust/commit/d5598aa7a07b324789576585f4f035c93993fea4"}], "stats": {"total": 3032, "additions": 2183, "deletions": 849}, "files": [{"sha": "8d22ac9dbbe97b60c704a78ad0cf274574e6789c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 73, "deletions": 22, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -3,18 +3,18 @@\n use crate::hir::map::DefPathData;\n use crate::ich::NodeIdHashingMode;\n use crate::mir::interpret::{sign_extend, truncate};\n-use crate::ty::layout::{Integer, IntegerExt};\n+use crate::ty::layout::{Integer, IntegerExt, Size};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use crate::ty::TyKind::*;\n use crate::ty::{self, DefIdTree, GenericParamDefKind, Ty, TyCtxt, TypeFoldable};\n use crate::util::common::ErrorReported;\n+use rustc_apfloat::Float as _;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use rustc_span::Span;\n use std::{cmp, fmt};\n@@ -43,41 +43,54 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n     }\n }\n \n+fn signed_min(size: Size) -> i128 {\n+    sign_extend(1_u128 << (size.bits() - 1), size) as i128\n+}\n+\n+fn signed_max(size: Size) -> i128 {\n+    i128::max_value() >> (128 - size.bits())\n+}\n+\n+fn unsigned_max(size: Size) -> u128 {\n+    u128::max_value() >> (128 - size.bits())\n+}\n+\n+fn int_size_and_signed<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (Size, bool) {\n+    let (int, signed) = match ty.kind {\n+        Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n+        Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n+        _ => bug!(\"non integer discriminant\"),\n+    };\n+    (int.size(), signed)\n+}\n+\n impl<'tcx> Discr<'tcx> {\n     /// Adds `1` to the value and wraps around if the maximum for the type is reached.\n     pub fn wrap_incr(self, tcx: TyCtxt<'tcx>) -> Self {\n         self.checked_add(tcx, 1).0\n     }\n     pub fn checked_add(self, tcx: TyCtxt<'tcx>, n: u128) -> (Self, bool) {\n-        let (int, signed) = match self.ty.kind {\n-            Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n-            Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n-            _ => bug!(\"non integer discriminant\"),\n-        };\n-\n-        let size = int.size();\n-        let bit_size = int.size().bits();\n-        let shift = 128 - bit_size;\n-        if signed {\n-            let sext = |u| sign_extend(u, size) as i128;\n-            let min = sext(1_u128 << (bit_size - 1));\n-            let max = i128::max_value() >> shift;\n-            let val = sext(self.val);\n+        let (size, signed) = int_size_and_signed(tcx, self.ty);\n+        let (val, oflo) = if signed {\n+            let min = signed_min(size);\n+            let max = signed_max(size);\n+            let val = sign_extend(self.val, size) as i128;\n             assert!(n < (i128::max_value() as u128));\n             let n = n as i128;\n             let oflo = val > max - n;\n             let val = if oflo { min + (n - (max - val) - 1) } else { val + n };\n             // zero the upper bits\n             let val = val as u128;\n             let val = truncate(val, size);\n-            (Self { val: val as u128, ty: self.ty }, oflo)\n+            (val, oflo)\n         } else {\n-            let max = u128::max_value() >> shift;\n+            let max = unsigned_max(size);\n             let val = self.val;\n             let oflo = val > max - n;\n             let val = if oflo { n - (max - val) - 1 } else { val + n };\n-            (Self { val: val, ty: self.ty }, oflo)\n-        }\n+            (val, oflo)\n+        };\n+        (Self { val, ty: self.ty }, oflo)\n     }\n }\n \n@@ -621,6 +634,44 @@ impl<'tcx> TyCtxt<'tcx> {\n }\n \n impl<'tcx> ty::TyS<'tcx> {\n+    /// Returns the maximum value for the given numeric type (including `char`s)\n+    /// or returns `None` if the type is not numeric.\n+    pub fn numeric_max_val(&'tcx self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n+        let val = match self.kind {\n+            ty::Int(_) | ty::Uint(_) => {\n+                let (size, signed) = int_size_and_signed(tcx, self);\n+                let val = if signed { signed_max(size) as u128 } else { unsigned_max(size) };\n+                Some(val)\n+            }\n+            ty::Char => Some(std::char::MAX as u128),\n+            ty::Float(fty) => Some(match fty {\n+                ast::FloatTy::F32 => ::rustc_apfloat::ieee::Single::INFINITY.to_bits(),\n+                ast::FloatTy::F64 => ::rustc_apfloat::ieee::Double::INFINITY.to_bits(),\n+            }),\n+            _ => None,\n+        };\n+        val.map(|v| ty::Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n+    }\n+\n+    /// Returns the minimum value for the given numeric type (including `char`s)\n+    /// or returns `None` if the type is not numeric.\n+    pub fn numeric_min_val(&'tcx self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n+        let val = match self.kind {\n+            ty::Int(_) | ty::Uint(_) => {\n+                let (size, signed) = int_size_and_signed(tcx, self);\n+                let val = if signed { truncate(signed_min(size) as u128, size) } else { 0 };\n+                Some(val)\n+            }\n+            ty::Char => Some(0),\n+            ty::Float(fty) => Some(match fty {\n+                ast::FloatTy::F32 => (-::rustc_apfloat::ieee::Single::INFINITY).to_bits(),\n+                ast::FloatTy::F64 => (-::rustc_apfloat::ieee::Double::INFINITY).to_bits(),\n+            }),\n+            _ => None,\n+        };\n+        val.map(|v| ty::Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n+    }\n+\n     /// Checks whether values of this type `T` are *moved* or *copied*\n     /// when referenced -- this amounts to a check for whether `T:\n     /// Copy`, but note that we **don't** consider lifetimes when"}, {"sha": "6cf640a0e98a2a78575a9a9c0432179041bf04e5", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -65,9 +65,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n             PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n             PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n-                self.lower_expr(e1),\n-                self.lower_expr(e2),\n-                self.lower_range_end(end),\n+                e1.as_deref().map(|e| self.lower_expr(e)),\n+                e2.as_deref().map(|e| self.lower_expr(e)),\n+                self.lower_range_end(end, e2.is_some()),\n             ),\n             PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n             PatKind::Rest => {\n@@ -253,10 +253,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::PatKind::Wild\n     }\n \n-    fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n+    fn lower_range_end(&mut self, e: &RangeEnd, has_end: bool) -> hir::RangeEnd {\n         match *e {\n-            RangeEnd::Included(_) => hir::RangeEnd::Included,\n-            RangeEnd::Excluded => hir::RangeEnd::Excluded,\n+            RangeEnd::Excluded if has_end => hir::RangeEnd::Excluded,\n+            // No end; so `X..` behaves like `RangeFrom`.\n+            RangeEnd::Excluded | RangeEnd::Included(_) => hir::RangeEnd::Included,\n         }\n     }\n }"}, {"sha": "d3876ecc7c3ada5f15e30e3a20ab04ed3b12e228", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -534,6 +534,9 @@ declare_features! (\n     /// Allows the use of `#[cfg(sanitize = \"option\")]`; set when -Zsanitizer is used.\n     (active, cfg_sanitize, \"1.41.0\", Some(39699), None),\n \n+    /// Allows using `..X`, `..=X`, `...X`, and `X..` as a pattern.\n+    (active, half_open_range_patterns, \"1.41.0\", Some(67264), None),\n+\n     /// Allows using `&mut` in constant functions.\n     (active, const_mut_refs, \"1.41.0\", Some(57349), None),\n "}, {"sha": "550e3654d0800965d890d96ea4850048272c3c9d", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -905,7 +905,7 @@ pub enum PatKind<'hir> {\n     Lit(&'hir Expr<'hir>),\n \n     /// A range pattern (e.g., `1..=2` or `1..2`).\n-    Range(&'hir Expr<'hir>, &'hir Expr<'hir>, RangeEnd),\n+    Range(Option<&'hir Expr<'hir>>, Option<&'hir Expr<'hir>>, RangeEnd),\n \n     /// A slice pattern, `[before_0, ..., before_n, (slice, after_0, ..., after_n)?]`.\n     ///"}, {"sha": "3dbc5253a9abf5ce3fc6b68fb05ce37fce256d50", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -766,8 +766,8 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n         }\n         PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n         PatKind::Range(ref lower_bound, ref upper_bound, _) => {\n-            visitor.visit_expr(lower_bound);\n-            visitor.visit_expr(upper_bound)\n+            walk_list!(visitor, visit_expr, lower_bound);\n+            walk_list!(visitor, visit_expr, upper_bound);\n         }\n         PatKind::Wild => (),\n         PatKind::Slice(prepatterns, ref slice_pattern, postpatterns) => {"}, {"sha": "759f423070aa0b35019e0840b47403f8266f8327", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1767,13 +1767,17 @@ impl<'a> State<'a> {\n             }\n             PatKind::Lit(ref e) => self.print_expr(&e),\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n-                self.print_expr(&begin);\n-                self.s.space();\n+                if let Some(expr) = begin {\n+                    self.print_expr(expr);\n+                    self.s.space();\n+                }\n                 match *end_kind {\n                     RangeEnd::Included => self.s.word(\"...\"),\n                     RangeEnd::Excluded => self.s.word(\"..\"),\n                 }\n-                self.print_expr(&end);\n+                if let Some(expr) = end {\n+                    self.print_expr(expr);\n+                }\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n                 self.s.word(\"[\");"}, {"sha": "c8a595267569eeea62a55e6fdbd359e5d418267f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -46,7 +46,6 @@ use syntax::ast::{self, Expr};\n use syntax::attr::{self, HasAttrs};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::{self, expr_to_string};\n-use syntax::ptr::P;\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::visit::FnKind;\n \n@@ -1309,11 +1308,13 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n \n         /// If `pat` is a `...` pattern, return the start and end of the range, as well as the span\n         /// corresponding to the ellipsis.\n-        fn matches_ellipsis_pat(pat: &ast::Pat) -> Option<(&P<Expr>, &P<Expr>, Span)> {\n+        fn matches_ellipsis_pat(pat: &ast::Pat) -> Option<(Option<&Expr>, &Expr, Span)> {\n             match &pat.kind {\n-                PatKind::Range(a, b, Spanned { span, node: RangeEnd::Included(DotDotDot), .. }) => {\n-                    Some((a, b, *span))\n-                }\n+                PatKind::Range(\n+                    a,\n+                    Some(b),\n+                    Spanned { span, node: RangeEnd::Included(DotDotDot) },\n+                ) => Some((a.as_deref(), b, *span)),\n                 _ => None,\n             }\n         }\n@@ -1328,11 +1329,16 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n             let suggestion = \"use `..=` for an inclusive range\";\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n+                let end = expr_to_string(&end);\n+                let replace = match start {\n+                    Some(start) => format!(\"&({}..={})\", expr_to_string(&start), end),\n+                    None => format!(\"&(..={})\", end),\n+                };\n                 let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg);\n                 err.span_suggestion(\n                     pat.span,\n                     suggestion,\n-                    format!(\"&({}..={})\", expr_to_string(&start), expr_to_string(&end)),\n+                    replace,\n                     Applicability::MachineApplicable,\n                 );\n                 err.emit();"}, {"sha": "2598ce2391fb326bc97c0de25759025b5d9abf1b", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 94, "deletions": 68, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -429,14 +429,87 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> (PatKind<'tcx>, Option<Ascription<'tcx>>) {\n         match self.lower_lit(expr) {\n-            PatKind::AscribeUserType {\n-                ascription: lo_ascription,\n-                subpattern: Pat { kind: box kind, .. },\n-            } => (kind, Some(lo_ascription)),\n+            PatKind::AscribeUserType { ascription, subpattern: Pat { kind: box kind, .. } } => {\n+                (kind, Some(ascription))\n+            }\n             kind => (kind, None),\n         }\n     }\n \n+    fn lower_pattern_range(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        lo: &'tcx ty::Const<'tcx>,\n+        hi: &'tcx ty::Const<'tcx>,\n+        end: RangeEnd,\n+        span: Span,\n+    ) -> PatKind<'tcx> {\n+        assert_eq!(lo.ty, ty);\n+        assert_eq!(hi.ty, ty);\n+        let cmp = compare_const_vals(self.tcx, lo, hi, self.param_env, ty);\n+        match (end, cmp) {\n+            // `x..y` where `x < y`.\n+            // Non-empty because the range includes at least `x`.\n+            (RangeEnd::Excluded, Some(Ordering::Less)) => PatKind::Range(PatRange { lo, hi, end }),\n+            // `x..y` where `x >= y`. The range is empty => error.\n+            (RangeEnd::Excluded, _) => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0579,\n+                    \"lower range bound must be less than upper\"\n+                )\n+                .emit();\n+                PatKind::Wild\n+            }\n+            // `x..=y` where `x == y`.\n+            (RangeEnd::Included, Some(Ordering::Equal)) => PatKind::Constant { value: lo },\n+            // `x..=y` where `x < y`.\n+            (RangeEnd::Included, Some(Ordering::Less)) => PatKind::Range(PatRange { lo, hi, end }),\n+            // `x..=y` where `x > y` hence the range is empty => error.\n+            (RangeEnd::Included, _) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0030,\n+                    \"lower range bound must be less than or equal to upper\"\n+                );\n+                err.span_label(span, \"lower bound larger than upper bound\");\n+                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                    err.note(\n+                        \"When matching against a range, the compiler \\\n+                              verifies that the range is non-empty. Range \\\n+                              patterns include both end-points, so this is \\\n+                              equivalent to requiring the start of the range \\\n+                              to be less than or equal to the end of the range.\",\n+                    );\n+                }\n+                err.emit();\n+                PatKind::Wild\n+            }\n+        }\n+    }\n+\n+    fn normalize_range_pattern_ends(\n+        &self,\n+        ty: Ty<'tcx>,\n+        lo: Option<&PatKind<'tcx>>,\n+        hi: Option<&PatKind<'tcx>>,\n+    ) -> Option<(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>)> {\n+        match (lo, hi) {\n+            (Some(PatKind::Constant { value: lo }), Some(PatKind::Constant { value: hi })) => {\n+                Some((lo, hi))\n+            }\n+            (Some(PatKind::Constant { value: lo }), None) => {\n+                Some((lo, ty.numeric_max_val(self.tcx)?))\n+            }\n+            (None, Some(PatKind::Constant { value: hi })) => {\n+                Some((ty.numeric_min_val(self.tcx)?, hi))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n@@ -451,78 +524,31 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             hir::PatKind::Lit(ref value) => self.lower_lit(value),\n \n             hir::PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n-                let (lo, lo_ascription) = self.lower_range_expr(lo_expr);\n-                let (hi, hi_ascription) = self.lower_range_expr(hi_expr);\n-\n-                let mut kind = match (lo, hi) {\n-                    (PatKind::Constant { value: lo }, PatKind::Constant { value: hi }) => {\n-                        assert_eq!(lo.ty, ty);\n-                        assert_eq!(hi.ty, ty);\n-                        let cmp = compare_const_vals(self.tcx, lo, hi, self.param_env, ty);\n-                        match (end, cmp) {\n-                            (RangeEnd::Excluded, Some(Ordering::Less)) => {\n-                                PatKind::Range(PatRange { lo, hi, end })\n-                            }\n-                            (RangeEnd::Excluded, _) => {\n-                                struct_span_err!(\n-                                    self.tcx.sess,\n-                                    lo_expr.span,\n-                                    E0579,\n-                                    \"lower range bound must be less than upper\",\n-                                )\n-                                .emit();\n-                                PatKind::Wild\n-                            }\n-                            (RangeEnd::Included, Some(Ordering::Equal)) => {\n-                                PatKind::Constant { value: lo }\n-                            }\n-                            (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatKind::Range(PatRange { lo, hi, end })\n-                            }\n-                            (RangeEnd::Included, _) => {\n-                                let mut err = struct_span_err!(\n-                                    self.tcx.sess,\n-                                    lo_expr.span,\n-                                    E0030,\n-                                    \"lower range bound must be less than or equal to upper\"\n-                                );\n-                                err.span_label(lo_expr.span, \"lower bound larger than upper bound\");\n-                                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                                    err.note(\n-                                        \"When matching against a range, the compiler \\\n-                                              verifies that the range is non-empty. Range \\\n-                                              patterns include both end-points, so this is \\\n-                                              equivalent to requiring the start of the range \\\n-                                              to be less than or equal to the end of the range.\",\n-                                    );\n-                                }\n-                                err.emit();\n-                                PatKind::Wild\n-                            }\n-                        }\n-                    }\n-                    ref pats => {\n-                        self.tcx.sess.delay_span_bug(\n-                            pat.span,\n-                            &format!(\n-                                \"found bad range pattern `{:?}` outside of error recovery\",\n-                                pats,\n-                            ),\n+                let (lo_expr, hi_expr) = (lo_expr.as_deref(), hi_expr.as_deref());\n+                let lo_span = lo_expr.map_or(pat.span, |e| e.span);\n+                let lo = lo_expr.map(|e| self.lower_range_expr(e));\n+                let hi = hi_expr.map(|e| self.lower_range_expr(e));\n+\n+                let (lp, hp) = (lo.as_ref().map(|x| &x.0), hi.as_ref().map(|x| &x.0));\n+                let mut kind = match self.normalize_range_pattern_ends(ty, lp, hp) {\n+                    Some((lc, hc)) => self.lower_pattern_range(ty, lc, hc, end, lo_span),\n+                    None => {\n+                        let msg = &format!(\n+                            \"found bad range pattern `{:?}` outside of error recovery\",\n+                            (&lo, &hi),\n                         );\n-\n+                        self.tcx.sess.delay_span_bug(pat.span, msg);\n                         PatKind::Wild\n                     }\n                 };\n \n                 // If we are handling a range with associated constants (e.g.\n                 // `Foo::<'a>::A..=Foo::B`), we need to put the ascriptions for the associated\n                 // constants somewhere. Have them on the range pattern.\n-                for ascription in &[lo_ascription, hi_ascription] {\n-                    if let Some(ascription) = ascription {\n-                        kind = PatKind::AscribeUserType {\n-                            ascription: *ascription,\n-                            subpattern: Pat { span: pat.span, ty, kind: Box::new(kind) },\n-                        };\n+                for end in &[lo, hi] {\n+                    if let Some((_, Some(ascription))) = end {\n+                        let subpattern = Pat { span: pat.span, ty, kind: Box::new(kind) };\n+                        kind = PatKind::AscribeUserType { ascription: *ascription, subpattern };\n                     }\n                 }\n "}, {"sha": "d321383424cabc85a87b6dd10c28deeaa842860c", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -51,7 +51,6 @@ pub enum Error {\n         secondary_path: String,\n     },\n     UselessDocComment,\n-    InclusiveRangeWithNoEnd,\n }\n \n impl Error {\n@@ -102,11 +101,6 @@ impl Error {\n                 );\n                 err\n             }\n-            Error::InclusiveRangeWithNoEnd => {\n-                let mut err = struct_span_err!(handler, sp, E0586, \"inclusive range with no end\",);\n-                err.help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\");\n-                err\n-            }\n         }\n     }\n }"}, {"sha": "2d6a94ce620cfd9fb51e0b26677af7c451925f12", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,4 +1,3 @@\n-use super::diagnostics::Error;\n use super::pat::{GateOr, PARAM_EXPECTED};\n use super::{BlockMode, Parser, PathStyle, PrevTokenKind, Restrictions, TokenType};\n use super::{SemiColonMode, SeqSep, TokenExpectType};\n@@ -1967,7 +1966,8 @@ impl<'a> Parser<'a> {\n         limits: RangeLimits,\n     ) -> PResult<'a, ExprKind> {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            Err(self.span_fatal_err(self.token.span, Error::InclusiveRangeWithNoEnd))\n+            self.error_inclusive_range_with_no_end(self.token.span);\n+            Ok(ExprKind::Err)\n         } else {\n             Ok(ExprKind::Range(start, end, limits))\n         }"}, {"sha": "50756ddec9f2d950db9369839b01d58add296295", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 132, "deletions": 187, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,6 +1,6 @@\n use super::{Parser, PathStyle};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n-use rustc_errors::{Applicability, DiagnosticBuilder, PResult};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym};\n use syntax::ast::{self, AttrVec, Attribute, FieldPat, Mac, Pat, PatKind, RangeEnd, RangeSyntax};\n@@ -281,91 +281,73 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtPat, |x| x);\n \n         let lo = self.token.span;\n-        let pat = match self.token.kind {\n-            token::BinOp(token::And) | token::AndAnd => self.parse_pat_deref(expected)?,\n-            token::OpenDelim(token::Paren) => self.parse_pat_tuple_or_parens()?,\n-            token::OpenDelim(token::Bracket) => {\n-                // Parse `[pat, pat,...]` as a slice pattern.\n-                let (pats, _) =\n-                    self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat_with_or_inner())?;\n-                PatKind::Slice(pats)\n-            }\n-            token::DotDot => {\n-                self.bump();\n-                if self.is_pat_range_end_start() {\n-                    // Parse `..42` for recovery.\n-                    self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n-                } else {\n-                    // A rest pattern `..`.\n-                    PatKind::Rest\n-                }\n-            }\n-            token::DotDotEq => {\n-                // Parse `..=42` for recovery.\n-                self.bump();\n-                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?\n-            }\n-            token::DotDotDot => {\n-                // Parse `...42` for recovery.\n-                self.bump();\n-                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?\n+\n+        let pat = if self.check(&token::BinOp(token::And)) || self.token.kind == token::AndAnd {\n+            self.parse_pat_deref(expected)?\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n+            self.parse_pat_tuple_or_parens()?\n+        } else if self.check(&token::OpenDelim(token::Bracket)) {\n+            // Parse `[pat, pat,...]` as a slice pattern.\n+            let (pats, _) =\n+                self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat_with_or_inner())?;\n+            PatKind::Slice(pats)\n+        } else if self.check(&token::DotDot) && !self.is_pat_range_end_start(1) {\n+            // A rest pattern `..`.\n+            self.bump(); // `..`\n+            PatKind::Rest\n+        } else if let Some(form) = self.parse_range_end() {\n+            self.parse_pat_range_to(form)? // `..=X`, `...X`, or `..X`.\n+        } else if self.eat_keyword(kw::Underscore) {\n+            // Parse _\n+            PatKind::Wild\n+        } else if self.eat_keyword(kw::Mut) {\n+            self.parse_pat_ident_mut()?\n+        } else if self.eat_keyword(kw::Ref) {\n+            // Parse ref ident @ pat / ref mut ident @ pat\n+            let mutbl = self.parse_mutability();\n+            self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n+        } else if self.eat_keyword(kw::Box) {\n+            // Parse `box pat`\n+            let pat = self.parse_pat_with_range_pat(false, None)?;\n+            self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_span));\n+            PatKind::Box(pat)\n+        } else if self.can_be_ident_pat() {\n+            // Parse `ident @ pat`\n+            // This can give false positives and parse nullary enums,\n+            // they are dealt with later in resolve.\n+            self.parse_pat_ident(BindingMode::ByValue(Mutability::Not))?\n+        } else if self.is_start_of_pat_with_path() {\n+            // Parse pattern starting with a path\n+            let (qself, path) = if self.eat_lt() {\n+                // Parse a qualified path\n+                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                (Some(qself), path)\n+            } else {\n+                // Parse an unqualified path\n+                (None, self.parse_path(PathStyle::Expr)?)\n+            };\n+            let span = lo.to(self.prev_span);\n+\n+            if qself.is_none() && self.check(&token::Not) {\n+                self.parse_pat_mac_invoc(path)?\n+            } else if let Some(form) = self.parse_range_end() {\n+                let begin = self.mk_expr(span, ExprKind::Path(qself, path), AttrVec::new());\n+                self.parse_pat_range_begin_with(begin, form)?\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                self.parse_pat_struct(qself, path)?\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n+                self.parse_pat_tuple_struct(qself, path)?\n+            } else {\n+                PatKind::Path(qself, path)\n             }\n-            // At this point, token != `&`, `&&`, `(`, `[`, `..`, `..=`, or `...`.\n-            _ => {\n-                if self.eat_keyword(kw::Underscore) {\n-                    // Parse _\n-                    PatKind::Wild\n-                } else if self.eat_keyword(kw::Mut) {\n-                    self.parse_pat_ident_mut()?\n-                } else if self.eat_keyword(kw::Ref) {\n-                    // Parse ref ident @ pat / ref mut ident @ pat\n-                    let mutbl = self.parse_mutability();\n-                    self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n-                } else if self.eat_keyword(kw::Box) {\n-                    // Parse `box pat`\n-                    let pat = self.parse_pat_with_range_pat(false, None)?;\n-                    self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_span));\n-                    PatKind::Box(pat)\n-                } else if self.can_be_ident_pat() {\n-                    // Parse `ident @ pat`\n-                    // This can give false positives and parse nullary enums,\n-                    // they are dealt with later in resolve.\n-                    self.parse_pat_ident(BindingMode::ByValue(Mutability::Not))?\n-                } else if self.is_start_of_pat_with_path() {\n-                    // Parse pattern starting with a path\n-                    let (qself, path) = if self.eat_lt() {\n-                        // Parse a qualified path\n-                        let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n-                        (Some(qself), path)\n-                    } else {\n-                        // Parse an unqualified path\n-                        (None, self.parse_path(PathStyle::Expr)?)\n-                    };\n-                    match self.token.kind {\n-                        token::Not if qself.is_none() => self.parse_pat_mac_invoc(path)?,\n-                        token::DotDotDot | token::DotDotEq | token::DotDot => {\n-                            self.parse_pat_range_starting_with_path(lo, qself, path)?\n-                        }\n-                        token::OpenDelim(token::Brace) => self.parse_pat_struct(qself, path)?,\n-                        token::OpenDelim(token::Paren) => {\n-                            self.parse_pat_tuple_struct(qself, path)?\n-                        }\n-                        _ => PatKind::Path(qself, path),\n-                    }\n-                } else {\n-                    // Try to parse everything else as literal with optional minus\n-                    match self.parse_literal_maybe_minus() {\n-                        Ok(begin)\n-                            if self.check(&token::DotDot)\n-                                || self.check(&token::DotDotEq)\n-                                || self.check(&token::DotDotDot) =>\n-                        {\n-                            self.parse_pat_range_starting_with_lit(begin)?\n-                        }\n-                        Ok(begin) => PatKind::Lit(begin),\n-                        Err(err) => return self.fatal_unexpected_non_pat(err, expected),\n-                    }\n-                }\n+        } else {\n+            // Try to parse everything else as literal with optional minus\n+            match self.parse_literal_maybe_minus() {\n+                Ok(begin) => match self.parse_range_end() {\n+                    Some(form) => self.parse_pat_range_begin_with(begin, form)?,\n+                    None => PatKind::Lit(begin),\n+                },\n+                Err(err) => return self.fatal_unexpected_non_pat(err, expected),\n             }\n         };\n \n@@ -374,7 +356,7 @@ impl<'a> Parser<'a> {\n         let pat = self.recover_intersection_pat(pat)?;\n \n         if !allow_range_pat {\n-            self.ban_pat_range_if_ambiguous(&pat)?\n+            self.ban_pat_range_if_ambiguous(&pat)\n         }\n \n         Ok(pat)\n@@ -441,26 +423,25 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Ban a range pattern if it has an ambiguous interpretation.\n-    fn ban_pat_range_if_ambiguous(&self, pat: &Pat) -> PResult<'a, ()> {\n+    fn ban_pat_range_if_ambiguous(&self, pat: &Pat) {\n         match pat.kind {\n             PatKind::Range(\n                 ..,\n                 Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. },\n-            ) => return Ok(()),\n+            ) => return,\n             PatKind::Range(..) => {}\n-            _ => return Ok(()),\n+            _ => return,\n         }\n \n-        let mut err =\n-            self.struct_span_err(pat.span, \"the range pattern here has ambiguous interpretation\");\n-        err.span_suggestion(\n-            pat.span,\n-            \"add parentheses to clarify the precedence\",\n-            format!(\"({})\", pprust::pat_to_string(&pat)),\n-            // \"ambiguous interpretation\" implies that we have to be guessing\n-            Applicability::MaybeIncorrect,\n-        );\n-        Err(err)\n+        self.struct_span_err(pat.span, \"the range pattern here has ambiguous interpretation\")\n+            .span_suggestion(\n+                pat.span,\n+                \"add parentheses to clarify the precedence\",\n+                format!(\"({})\", pprust::pat_to_string(&pat)),\n+                // \"ambiguous interpretation\" implies that we have to be guessing\n+                Applicability::MaybeIncorrect,\n+            )\n+            .emit();\n     }\n \n     /// Parse `&pat` / `&mut pat`.\n@@ -618,51 +599,6 @@ impl<'a> Parser<'a> {\n         Ok(PatKind::Mac(mac))\n     }\n \n-    fn excluded_range_end(&self, span: Span) -> RangeEnd {\n-        self.sess.gated_spans.gate(sym::exclusive_range_pattern, span);\n-        RangeEnd::Excluded\n-    }\n-\n-    /// Parse a range pattern `$path $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n-    /// The `$path` has already been parsed and the next token is the `$form`.\n-    fn parse_pat_range_starting_with_path(\n-        &mut self,\n-        lo: Span,\n-        qself: Option<QSelf>,\n-        path: Path,\n-    ) -> PResult<'a, PatKind> {\n-        let (end_kind, form) = match self.token.kind {\n-            token::DotDot => (self.excluded_range_end(self.token.span), \"..\"),\n-            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n-            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n-            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges (checked above)\"),\n-        };\n-        let op_span = self.token.span;\n-        // Parse range\n-        let span = lo.to(self.prev_span);\n-        let begin = self.mk_expr(span, ExprKind::Path(qself, path), AttrVec::new());\n-        self.bump();\n-        let end = self.parse_pat_range_end_opt(&begin, form)?;\n-        Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n-    }\n-\n-    /// Parse a range pattern `$literal $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n-    /// The `$path` has already been parsed and the next token is the `$form`.\n-    fn parse_pat_range_starting_with_lit(&mut self, begin: P<Expr>) -> PResult<'a, PatKind> {\n-        let op_span = self.token.span;\n-        let (end_kind, form) = if self.eat(&token::DotDotDot) {\n-            (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n-        } else if self.eat(&token::DotDotEq) {\n-            (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n-        } else if self.eat(&token::DotDot) {\n-            (self.excluded_range_end(op_span), \"..\")\n-        } else {\n-            panic!(\"impossible case: we already matched on a range-operator token\")\n-        };\n-        let end = self.parse_pat_range_end_opt(&begin, form)?;\n-        Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n-    }\n-\n     fn fatal_unexpected_non_pat(\n         &mut self,\n         mut err: DiagnosticBuilder<'a>,\n@@ -684,57 +620,66 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n-    /// Is the current token suitable as the start of a range patterns end?\n-    fn is_pat_range_end_start(&self) -> bool {\n-        self.token.is_path_start() // e.g. `MY_CONST`;\n-            || self.token == token::Dot // e.g. `.5` for recovery;\n-            || self.token.can_begin_literal_or_bool() // e.g. `42`.\n-            || self.token.is_whole_expr()\n-    }\n-\n-    /// Parse a range-to pattern, e.g. `..X` and `..=X` for recovery.\n-    fn parse_pat_range_to(&mut self, re: RangeEnd, form: &str) -> PResult<'a, PatKind> {\n-        let lo = self.prev_span;\n-        let end = self.parse_pat_range_end()?;\n-        let range_span = lo.to(end.span);\n-        let begin = self.mk_expr(range_span, ExprKind::Err, AttrVec::new());\n-\n-        self.struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n-            .span_suggestion(\n-                range_span,\n-                \"try using the minimum value for the type\",\n-                format!(\"MIN{}{}\", form, pprust::expr_to_string(&end)),\n-                Applicability::HasPlaceholders,\n-            )\n-            .emit();\n-\n-        Ok(PatKind::Range(begin, end, respan(lo, re)))\n+    /// Parses the range pattern end form `\"..\" | \"...\" | \"..=\" ;`.\n+    fn parse_range_end(&mut self) -> Option<Spanned<RangeEnd>> {\n+        let re = if self.eat(&token::DotDotDot) {\n+            RangeEnd::Included(RangeSyntax::DotDotDot)\n+        } else if self.eat(&token::DotDotEq) {\n+            RangeEnd::Included(RangeSyntax::DotDotEq)\n+        } else if self.eat(&token::DotDot) {\n+            self.sess.gated_spans.gate(sym::exclusive_range_pattern, self.prev_span);\n+            RangeEnd::Excluded\n+        } else {\n+            return None;\n+        };\n+        Some(respan(self.prev_span, re))\n     }\n \n-    /// Parse the end of a `X..Y`, `X..=Y`, or `X...Y` range pattern  or recover\n-    /// if that end is missing treating it as `X..`, `X..=`, or `X...` respectively.\n-    fn parse_pat_range_end_opt(&mut self, begin: &Expr, form: &str) -> PResult<'a, P<Expr>> {\n-        if self.is_pat_range_end_start() {\n+    /// Parse a range pattern `$begin $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n+    /// `$begin $form` has already been parsed.\n+    fn parse_pat_range_begin_with(\n+        &mut self,\n+        begin: P<Expr>,\n+        re: Spanned<RangeEnd>,\n+    ) -> PResult<'a, PatKind> {\n+        let end = if self.is_pat_range_end_start(0) {\n             // Parsing e.g. `X..=Y`.\n-            self.parse_pat_range_end()\n+            Some(self.parse_pat_range_end()?)\n         } else {\n             // Parsing e.g. `X..`.\n-            let range_span = begin.span.to(self.prev_span);\n+            self.sess.gated_spans.gate(sym::half_open_range_patterns, begin.span.to(re.span));\n+            if let RangeEnd::Included(_) = re.node {\n+                // FIXME(Centril): Consider semantic errors instead in `ast_validation`.\n+                // Possibly also do this for `X..=` in *expression* contexts.\n+                self.error_inclusive_range_with_no_end(re.span);\n+            }\n+            None\n+        };\n+        Ok(PatKind::Range(Some(begin), end, re))\n+    }\n \n-            self.struct_span_err(\n-                range_span,\n-                &format!(\"`X{}` range patterns are not supported\", form),\n-            )\n-            .span_suggestion(\n-                range_span,\n-                \"try using the maximum value for the type\",\n-                format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n-                Applicability::HasPlaceholders,\n-            )\n+    pub(super) fn error_inclusive_range_with_no_end(&self, span: Span) {\n+        use rustc_error_codes::E0586;\n+        struct_span_err!(self.sess.span_diagnostic, span, E0586, \"inclusive range with no end\")\n+            .help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\")\n             .emit();\n+    }\n \n-            Ok(self.mk_expr(range_span, ExprKind::Err, AttrVec::new()))\n-        }\n+    /// Parse a range-to pattern, e.g. `..X` and `..=X` where `X` remains to be parsed.\n+    fn parse_pat_range_to(&mut self, re: Spanned<RangeEnd>) -> PResult<'a, PatKind> {\n+        let end = self.parse_pat_range_end()?;\n+        self.sess.gated_spans.gate(sym::half_open_range_patterns, re.span.to(self.prev_span));\n+        Ok(PatKind::Range(None, Some(end), re))\n+    }\n+\n+    /// Is the token `dist` away from the current suitable as the start of a range patterns end?\n+    fn is_pat_range_end_start(&self, dist: usize) -> bool {\n+        self.look_ahead(dist, |t| {\n+            t.is_path_start() // e.g. `MY_CONST`;\n+                || t.kind == token::Dot // e.g. `.5` for recovery;\n+                || t.can_begin_literal_or_bool() // e.g. `42`.\n+                || t.is_whole_expr()\n+        })\n     }\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {"}, {"sha": "43c997d34e160ea178faa275b0f1271187a71cbc", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -920,8 +920,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.check_expr_within_pat(expr, false);\n             }\n             PatKind::Range(ref start, ref end, _) => {\n-                self.check_expr_within_pat(start, true);\n-                self.check_expr_within_pat(end, true);\n+                if let Some(expr) = start {\n+                    self.check_expr_within_pat(expr, true);\n+                }\n+                if let Some(expr) = end {\n+                    self.check_expr_within_pat(expr, true);\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "a8b2db300a478c51b2db47ee8fc3e6d13d9c1c5b", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -343,6 +343,7 @@ symbols! {\n         global_allocator,\n         global_asm,\n         globs,\n+        half_open_range_patterns,\n         hash,\n         Hash,\n         HashSet,"}, {"sha": "c2db165e29d1521ea842f8c1f267c805fad45c6b", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 55, "deletions": 53, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -135,12 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = match pat.kind {\n             PatKind::Wild => expected,\n             PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, ti),\n-            PatKind::Range(begin, end, _) => {\n-                match self.check_pat_range(pat.span, begin, end, expected, ti) {\n-                    None => return,\n-                    Some(ty) => ty,\n-                }\n-            }\n+            PatKind::Range(lhs, rhs, _) => self.check_pat_range(pat.span, lhs, rhs, expected, ti),\n             PatKind::Binding(ba, var_id, _, sub) => {\n                 self.check_pat_ident(pat, ba, var_id, sub, expected, def_bm, ti)\n             }\n@@ -395,39 +390,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_range(\n         &self,\n         span: Span,\n-        lhs: &'tcx hir::Expr<'tcx>,\n-        rhs: &'tcx hir::Expr<'tcx>,\n+        lhs: Option<&'tcx hir::Expr<'tcx>>,\n+        rhs: Option<&'tcx hir::Expr<'tcx>>,\n         expected: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n-    ) -> Option<Ty<'tcx>> {\n-        let lhs_ty = self.check_expr(lhs);\n-        let rhs_ty = self.check_expr(rhs);\n-\n-        // Check that both end-points are of numeric or char type.\n-        let numeric_or_char = |ty: Ty<'_>| ty.is_numeric() || ty.is_char() || ty.references_error();\n-        let lhs_fail = !numeric_or_char(lhs_ty);\n-        let rhs_fail = !numeric_or_char(rhs_ty);\n-\n-        if lhs_fail || rhs_fail {\n-            self.emit_err_pat_range(span, lhs.span, rhs.span, lhs_fail, rhs_fail, lhs_ty, rhs_ty);\n-            return None;\n+    ) -> Ty<'tcx> {\n+        let calc_side = |opt_expr: Option<&'tcx hir::Expr<'tcx>>| match opt_expr {\n+            None => (None, None),\n+            Some(expr) => {\n+                let ty = self.check_expr(expr);\n+                // Check that the end-point is of numeric or char type.\n+                let fail = !(ty.is_numeric() || ty.is_char() || ty.references_error());\n+                (Some(ty), Some((fail, ty, expr.span)))\n+            }\n+        };\n+        let (lhs_ty, lhs) = calc_side(lhs);\n+        let (rhs_ty, rhs) = calc_side(rhs);\n+\n+        if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n+            // There exists a side that didn't meet our criteria that the end-point\n+            // be of a numeric or char type, as checked in `calc_side` above.\n+            self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.types.err;\n         }\n \n-        // Now that we know the types can be unified we find the unified type and use\n-        // it to type the entire expression.\n-        let common_type = self.resolve_vars_if_possible(&lhs_ty);\n+        // Now that we know the types can be unified we find the unified type\n+        // and use it to type the entire expression.\n+        let common_type = self.resolve_vars_if_possible(&lhs_ty.or(rhs_ty).unwrap_or(expected));\n \n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n-        let demand_eqtype = |x_span, y_span, x_ty, y_ty| {\n-            self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti).map(|mut err| {\n-                self.endpoint_has_type(&mut err, y_span, y_ty);\n-                err.emit();\n-            });\n+        let demand_eqtype = |x, y| {\n+            if let Some((_, x_ty, x_span)) = x {\n+                self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti).map(|mut err| {\n+                    if let Some((_, y_ty, y_span)) = y {\n+                        self.endpoint_has_type(&mut err, y_span, y_ty);\n+                    }\n+                    err.emit();\n+                });\n+            }\n         };\n-        demand_eqtype(lhs.span, rhs.span, lhs_ty, rhs_ty);\n-        demand_eqtype(rhs.span, lhs.span, rhs_ty, lhs_ty);\n+        demand_eqtype(lhs, rhs);\n+        demand_eqtype(rhs, lhs);\n \n-        Some(common_type)\n+        common_type\n     }\n \n     fn endpoint_has_type(&self, err: &mut DiagnosticBuilder<'_>, span: Span, ty: Ty<'_>) {\n@@ -439,39 +444,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn emit_err_pat_range(\n         &self,\n         span: Span,\n-        begin_span: Span,\n-        end_span: Span,\n-        lhs_fail: bool,\n-        rhs_fail: bool,\n-        lhs_ty: Ty<'tcx>,\n-        rhs_ty: Ty<'tcx>,\n+        lhs: Option<(bool, Ty<'tcx>, Span)>,\n+        rhs: Option<(bool, Ty<'tcx>, Span)>,\n     ) {\n-        let span = if lhs_fail && rhs_fail {\n-            span\n-        } else if lhs_fail {\n-            begin_span\n-        } else {\n-            end_span\n+        let span = match (lhs, rhs) {\n+            (Some((true, ..)), Some((true, ..))) => span,\n+            (Some((true, _, sp)), _) => sp,\n+            (_, Some((true, _, sp))) => sp,\n+            _ => span_bug!(span, \"emit_err_pat_range: no side failed or exists but still error?\"),\n         };\n-\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             span,\n             E0029,\n             \"only char and numeric types are allowed in range patterns\"\n         );\n         let msg = |ty| format!(\"this is of type `{}` but it should be `char` or numeric\", ty);\n-        let mut one_side_err = |first_span, first_ty, second_span, second_ty: Ty<'_>| {\n+        let mut one_side_err = |first_span, first_ty, second: Option<(bool, Ty<'tcx>, Span)>| {\n             err.span_label(first_span, &msg(first_ty));\n-            self.endpoint_has_type(&mut err, second_span, second_ty);\n+            if let Some((_, ty, sp)) = second {\n+                self.endpoint_has_type(&mut err, sp, ty);\n+            }\n         };\n-        if lhs_fail && rhs_fail {\n-            err.span_label(begin_span, &msg(lhs_ty));\n-            err.span_label(end_span, &msg(rhs_ty));\n-        } else if lhs_fail {\n-            one_side_err(begin_span, lhs_ty, end_span, rhs_ty);\n-        } else {\n-            one_side_err(end_span, rhs_ty, begin_span, lhs_ty);\n+        match (lhs, rhs) {\n+            (Some((true, lhs_ty, lhs_sp)), Some((true, rhs_ty, rhs_sp))) => {\n+                err.span_label(lhs_sp, &msg(lhs_ty));\n+                err.span_label(rhs_sp, &msg(rhs_ty));\n+            }\n+            (Some((true, lhs_ty, lhs_sp)), rhs) => one_side_err(lhs_sp, lhs_ty, rhs),\n+            (lhs, Some((true, rhs_ty, rhs_sp))) => one_side_err(rhs_sp, rhs_ty, lhs),\n+            _ => span_bug!(span, \"Impossible, verified above.\"),\n         }\n         if self.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note("}, {"sha": "33acba8eba0109fe09f89f1e64639bd33b4de103", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -649,7 +649,7 @@ pub enum PatKind {\n     Lit(P<Expr>),\n \n     /// A range pattern (e.g., `1...2`, `1..=2` or `1..2`).\n-    Range(P<Expr>, P<Expr>, Spanned<RangeEnd>),\n+    Range(Option<P<Expr>>, Option<P<Expr>>, Spanned<RangeEnd>),\n \n     /// A slice pattern `[a, b, c]`.\n     Slice(Vec<P<Pat>>),"}, {"sha": "5e4319051728f72e6744924f98dc412f0743c42e", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -911,6 +911,7 @@ pub fn check_crate(\n     gate_all!(raw_ref_op, \"raw address of syntax is experimental\");\n     gate_all!(const_trait_bound_opt_out, \"`?const` on trait bounds is experimental\");\n     gate_all!(const_trait_impl, \"const trait impls are experimental\");\n+    gate_all!(half_open_range_patterns, \"half-open range patterns are unstable\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "58d4e46111b83adb5dc7344c014724dd4b793d0a", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1075,8 +1075,8 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         PatKind::Box(inner) => vis.visit_pat(inner),\n         PatKind::Ref(inner, _mutbl) => vis.visit_pat(inner),\n         PatKind::Range(e1, e2, Spanned { span: _, node: _ }) => {\n-            vis.visit_expr(e1);\n-            vis.visit_expr(e2);\n+            visit_opt(e1, |e| vis.visit_expr(e));\n+            visit_opt(e2, |e| vis.visit_expr(e));\n             vis.visit_span(span);\n         }\n         PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {"}, {"sha": "11c8cb8ef750017b1137cbb7266f1871799c3ea1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -2329,14 +2329,18 @@ impl<'a> State<'a> {\n             }\n             PatKind::Lit(ref e) => self.print_expr(&**e),\n             PatKind::Range(ref begin, ref end, Spanned { node: ref end_kind, .. }) => {\n-                self.print_expr(begin);\n-                self.s.space();\n+                if let Some(e) = begin {\n+                    self.print_expr(e);\n+                    self.s.space();\n+                }\n                 match *end_kind {\n                     RangeEnd::Included(RangeSyntax::DotDotDot) => self.s.word(\"...\"),\n                     RangeEnd::Included(RangeSyntax::DotDotEq) => self.s.word(\"..=\"),\n                     RangeEnd::Excluded => self.s.word(\"..\"),\n                 }\n-                self.print_expr(end);\n+                if let Some(e) = end {\n+                    self.print_expr(e);\n+                }\n             }\n             PatKind::Slice(ref elts) => {\n                 self.s.word(\"[\");"}, {"sha": "3c2ebacbc4e346a7c2d403cb5035f9b933dafced", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -492,8 +492,8 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n         }\n         PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n         PatKind::Range(ref lower_bound, ref upper_bound, _) => {\n-            visitor.visit_expr(lower_bound);\n-            visitor.visit_expr(upper_bound);\n+            walk_list!(visitor, visit_expr, lower_bound);\n+            walk_list!(visitor, visit_expr, upper_bound);\n         }\n         PatKind::Wild | PatKind::Rest => {}\n         PatKind::Tuple(ref elems) | PatKind::Slice(ref elems) | PatKind::Or(ref elems) => {"}, {"sha": "3f4c17836c4fc623c92f6e53de2f122d2843ab43", "filename": "src/test/ui/half-open-range-patterns/exclusive_range_pattern_syntax_collision.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,10 +1,10 @@\n+#![feature(half_open_range_patterns)]\n #![feature(exclusive_range_pattern)]\n \n fn main() {\n     match [5..4, 99..105, 43..44] {\n         [_, 99.., _] => {},\n-        //~^ ERROR `X..` range patterns are not supported\n-        //~| ERROR mismatched types\n+        //~^ ERROR mismatched types\n         _ => {},\n     }\n }", "previous_filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision.rs"}, {"sha": "a6f8563a047851e8a0ea337d02ca329895a881d5", "filename": "src/test/ui/half-open-range-patterns/exclusive_range_pattern_syntax_collision.stderr", "status": "renamed", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,11 +1,5 @@\n-error: `X..` range patterns are not supported\n-  --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:13\n-   |\n-LL |         [_, 99.., _] => {},\n-   |             ^^^^ help: try using the maximum value for the type: `99..MAX`\n-\n error[E0308]: mismatched types\n-  --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:13\n+  --> $DIR/exclusive_range_pattern_syntax_collision.rs:6:13\n    |\n LL |     match [5..4, 99..105, 43..44] {\n    |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n@@ -15,6 +9,6 @@ LL |         [_, 99.., _] => {},\n    = note: expected struct `std::ops::Range<{integer}>`\n                 found type `{integer}`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0308`.", "previous_filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision.stderr"}, {"sha": "dedc85491b4a98735df3200b34bc8441f035f931", "filename": "src/test/ui/half-open-range-patterns/exclusive_range_pattern_syntax_collision2.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision2.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,10 +1,10 @@\n+#![feature(half_open_range_patterns)]\n #![feature(exclusive_range_pattern)]\n \n fn main() {\n     match [5..4, 99..105, 43..44] {\n         [_, 99..] => {},\n-        //~^ ERROR `X..` range patterns are not supported\n-        //~| ERROR pattern requires 2 elements but array has 3\n+        //~^ ERROR pattern requires 2 elements but array has 3\n         //~| ERROR mismatched types\n         _ => {},\n     }", "previous_filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision2.rs"}, {"sha": "4e0102c930da82b7ab86b7bac25a73033f2fe8f6", "filename": "src/test/ui/half-open-range-patterns/exclusive_range_pattern_syntax_collision2.stderr", "status": "renamed", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision2.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,17 +1,11 @@\n-error: `X..` range patterns are not supported\n-  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:13\n-   |\n-LL |         [_, 99..] => {},\n-   |             ^^^^ help: try using the maximum value for the type: `99..MAX`\n-\n error[E0527]: pattern requires 2 elements but array has 3\n-  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:9\n+  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:6:9\n    |\n LL |         [_, 99..] => {},\n    |         ^^^^^^^^^ expected 3 elements\n \n error[E0308]: mismatched types\n-  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:13\n+  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:6:13\n    |\n LL |     match [5..4, 99..105, 43..44] {\n    |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n@@ -21,7 +15,7 @@ LL |         [_, 99..] => {},\n    = note: expected struct `std::ops::Range<{integer}>`\n                 found type `{integer}`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0308, E0527.\n For more information about an error, try `rustc --explain E0308`.", "previous_filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision2.stderr"}, {"sha": "6a9b562cc3a3b73634bfbc57422d98000791c146", "filename": "src/test/ui/half-open-range-patterns/exclusive_range_pattern_syntax_collision3.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision3.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,10 +1,10 @@\n+#![feature(half_open_range_patterns)]\n #![feature(exclusive_range_pattern)]\n \n fn main() {\n     match [5..4, 99..105, 43..44] {\n         [..9, 99..100, _] => {},\n-        //~^ ERROR `..X` range patterns are not supported\n-        //~| ERROR mismatched types\n+        //~^ ERROR mismatched types\n         //~| ERROR mismatched types\n         //~| ERROR mismatched types\n         _ => {},", "previous_filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision3.rs"}, {"sha": "665eef2fcb96c80ea7aff1c1f8ae0dbb3e0b5eb6", "filename": "src/test/ui/half-open-range-patterns/exclusive_range_pattern_syntax_collision3.stderr", "status": "renamed", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fexclusive_range_pattern_syntax_collision3.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,11 +1,5 @@\n-error: `..X` range patterns are not supported\n-  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:10\n-   |\n-LL |         [..9, 99..100, _] => {},\n-   |          ^^^ help: try using the minimum value for the type: `MIN..9`\n-\n error[E0308]: mismatched types\n-  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:12\n+  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:6:12\n    |\n LL |     match [5..4, 99..105, 43..44] {\n    |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n@@ -16,7 +10,7 @@ LL |         [..9, 99..100, _] => {},\n                 found type `{integer}`\n \n error[E0308]: mismatched types\n-  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:15\n+  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:6:15\n    |\n LL |     match [5..4, 99..105, 43..44] {\n    |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n@@ -29,7 +23,7 @@ LL |         [..9, 99..100, _] => {},\n                 found type `{integer}`\n \n error[E0308]: mismatched types\n-  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:19\n+  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:6:19\n    |\n LL |     match [5..4, 99..105, 43..44] {\n    |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n@@ -41,6 +35,6 @@ LL |         [..9, 99..100, _] => {},\n    = note: expected struct `std::ops::Range<{integer}>`\n                 found type `{integer}`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`.", "previous_filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision3.stderr"}, {"sha": "4cb8230a7b6204e9d7b304ce17411b3e303cb946", "filename": "src/test/ui/half-open-range-patterns/feature-gate-half-open-range-patterns.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,21 @@\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn foo() {\n+    if let ..=5 = 0 {}\n+    //~^ ERROR half-open range patterns are unstable\n+    if let ...5 = 0 {}\n+    //~^ ERROR half-open range patterns are unstable\n+    if let ..5 = 0 {}\n+    //~^ ERROR half-open range patterns are unstable\n+    if let 5.. = 0 {}\n+    //~^ ERROR half-open range patterns are unstable\n+    if let 5..= = 0 {}\n+    //~^ ERROR half-open range patterns are unstable\n+    //~| ERROR inclusive range with no end\n+    if let 5... = 0 {}\n+    //~^ ERROR half-open range patterns are unstable\n+    //~| ERROR inclusive range with no end\n+}"}, {"sha": "68ba654de76daa7b305627d6e0ca951dedf9af49", "filename": "src/test/ui/half-open-range-patterns/feature-gate-half-open-range-patterns.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,74 @@\n+error[E0586]: inclusive range with no end\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:15:13\n+   |\n+LL |     if let 5..= = 0 {}\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error[E0586]: inclusive range with no end\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:18:13\n+   |\n+LL |     if let 5... = 0 {}\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error[E0658]: half-open range patterns are unstable\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:7:12\n+   |\n+LL |     if let ..=5 = 0 {}\n+   |            ^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/67264\n+   = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n+\n+error[E0658]: half-open range patterns are unstable\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:9:12\n+   |\n+LL |     if let ...5 = 0 {}\n+   |            ^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/67264\n+   = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n+\n+error[E0658]: half-open range patterns are unstable\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:11:12\n+   |\n+LL |     if let ..5 = 0 {}\n+   |            ^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/67264\n+   = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n+\n+error[E0658]: half-open range patterns are unstable\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:13:12\n+   |\n+LL |     if let 5.. = 0 {}\n+   |            ^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/67264\n+   = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n+\n+error[E0658]: half-open range patterns are unstable\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:15:12\n+   |\n+LL |     if let 5..= = 0 {}\n+   |            ^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/67264\n+   = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n+\n+error[E0658]: half-open range patterns are unstable\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:18:12\n+   |\n+LL |     if let 5... = 0 {}\n+   |            ^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/67264\n+   = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0586, E0658.\n+For more information about an error, try `rustc --explain E0586`."}, {"sha": "7cddf5f652a319cb06324ea5b398d0b31be23373", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-bad-types.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-bad-types.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,8 @@\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {\n+    let \"a\".. = \"a\"; //~ ERROR only char and numeric types are allowed in range patterns\n+    let ..\"a\" = \"a\"; //~ ERROR only char and numeric types are allowed in range patterns\n+    let ..=\"a\" = \"a\"; //~ ERROR only char and numeric types are allowed in range patterns\n+}"}, {"sha": "68ca3637150d3a218ccf057bcf7ddfaa4a2d2f4e", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-bad-types.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-bad-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-bad-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-bad-types.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,21 @@\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/half-open-range-pats-bad-types.rs:5:9\n+   |\n+LL |     let \"a\".. = \"a\";\n+   |         ^^^ this is of type `&'static str` but it should be `char` or numeric\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/half-open-range-pats-bad-types.rs:6:11\n+   |\n+LL |     let ..\"a\" = \"a\";\n+   |           ^^^ this is of type `&'static str` but it should be `char` or numeric\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/half-open-range-pats-bad-types.rs:7:12\n+   |\n+LL |     let ..=\"a\" = \"a\";\n+   |            ^^^ this is of type `&'static str` but it should be `char` or numeric\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0029`."}, {"sha": "b135891d0b82f09f5820bd28c8c3339e68b93673", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-fail.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,168 @@\n+// Test various non-exhaustive matches for `X..`, `..=X` and `..X` ranges.\n+\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n+#![allow(illegal_floating_point_literal_pattern)]\n+\n+fn main() {}\n+\n+macro_rules! m {\n+    ($s:expr, $($t:tt)+) => {\n+        match $s { $($t)+ => {} }\n+    }\n+}\n+\n+fn floats() {\n+    m!(0f32, core::f32::NEG_INFINITY..); //~ ERROR non-exhaustive patterns: `_` not covered\n+    m!(0f32, ..core::f32::INFINITY); //~ ERROR non-exhaustive patterns: `_` not covered\n+}\n+\n+fn khar() {\n+    const ALMOST_MAX: char = '\\u{10fffe}';\n+    const ALMOST_MIN: char = '\\u{1}';\n+    const VAL: char = 'a';\n+    const VAL_1: char = 'b';\n+    const VAL_2: char = 'c';\n+    m!('a', ..core::char::MAX); //~ ERROR non-exhaustive patterns\n+    m!('a', ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+    m!('a', ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+    m!('a', ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+    m!('a', ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+    m!('a', ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+}\n+\n+mod unsigned {\n+    fn u8() {\n+        const ALMOST_MAX: u8 = core::u8::MAX - 1;\n+        const ALMOST_MIN: u8 = core::u8::MIN + 1;\n+        const VAL: u8 = 42;\n+        const VAL_1: u8 = VAL + 1;\n+        const VAL_2: u8 = VAL + 2;\n+        m!(0, ..core::u8::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+    fn u16() {\n+        const ALMOST_MAX: u16 = core::u16::MAX - 1;\n+        const ALMOST_MIN: u16 = core::u16::MIN + 1;\n+        const VAL: u16 = 42;\n+        const VAL_1: u16 = VAL + 1;\n+        const VAL_2: u16 = VAL + 2;\n+        m!(0, ..core::u16::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+    fn u32() {\n+        const ALMOST_MAX: u32 = core::u32::MAX - 1;\n+        const ALMOST_MIN: u32 = core::u32::MIN + 1;\n+        const VAL: u32 = 42;\n+        const VAL_1: u32 = VAL + 1;\n+        const VAL_2: u32 = VAL + 2;\n+        m!(0, ..core::u32::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+    fn u64() {\n+        const ALMOST_MAX: u64 = core::u64::MAX - 1;\n+        const ALMOST_MIN: u64 = core::u64::MIN + 1;\n+        const VAL: u64 = 42;\n+        const VAL_1: u64 = VAL + 1;\n+        const VAL_2: u64 = VAL + 2;\n+        m!(0, ..core::u64::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+    fn u128() {\n+        const ALMOST_MAX: u128 = core::u128::MAX - 1;\n+        const ALMOST_MIN: u128 = core::u128::MIN + 1;\n+        const VAL: u128 = 42;\n+        const VAL_1: u128 = VAL + 1;\n+        const VAL_2: u128 = VAL + 2;\n+        m!(0, ..core::u128::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+}\n+\n+mod signed {\n+    fn i8() {\n+        const ALMOST_MAX: i8 = core::i8::MAX - 1;\n+        const ALMOST_MIN: i8 = core::i8::MIN + 1;\n+        const VAL: i8 = 42;\n+        const VAL_1: i8 = VAL + 1;\n+        const VAL_2: i8 = VAL + 2;\n+        m!(0, ..core::i8::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+    fn i16() {\n+        const ALMOST_MAX: i16 = core::i16::MAX - 1;\n+        const ALMOST_MIN: i16 = core::i16::MIN + 1;\n+        const VAL: i16 = 42;\n+        const VAL_1: i16 = VAL + 1;\n+        const VAL_2: i16 = VAL + 2;\n+        m!(0, ..core::i16::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+    fn i32() {\n+        const ALMOST_MAX: i32 = core::i32::MAX - 1;\n+        const ALMOST_MIN: i32 = core::i32::MIN + 1;\n+        const VAL: i32 = 42;\n+        const VAL_1: i32 = VAL + 1;\n+        const VAL_2: i32 = VAL + 2;\n+        m!(0, ..core::i32::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+    fn i64() {\n+        const ALMOST_MAX: i64 = core::i64::MAX - 1;\n+        const ALMOST_MIN: i64 = core::i64::MIN + 1;\n+        const VAL: i64 = 42;\n+        const VAL_1: i64 = VAL + 1;\n+        const VAL_2: i64 = VAL + 2;\n+        m!(0, ..core::i64::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+    fn i128() {\n+        const ALMOST_MAX: i128 = core::i128::MAX - 1;\n+        const ALMOST_MIN: i128 = core::i128::MIN + 1;\n+        const VAL: i128 = 42;\n+        const VAL_1: i128 = VAL + 1;\n+        const VAL_2: i128 = VAL + 2;\n+        m!(0, ..core::i128::MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ALMOST_MIN..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=ALMOST_MAX); //~ ERROR non-exhaustive patterns\n+        m!(0, ..=VAL | VAL_2..); //~ ERROR non-exhaustive patterns\n+        m!(0, ..VAL_1 | VAL_2..); //~ ERROR non-exhaustive patterns\n+    }\n+}"}, {"sha": "26d0cf9e9ecbaa2dd73747eb973355f37618bb0e", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-fail.stderr", "status": "added", "additions": 547, "deletions": 0, "changes": 547, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,547 @@\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:16:8\n+   |\n+LL |     m!(0f32, core::f32::NEG_INFINITY..);\n+   |        ^^^^ pattern `_` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:17:8\n+   |\n+LL |     m!(0f32, ..core::f32::INFINITY);\n+   |        ^^^^ pattern `_` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:26:8\n+   |\n+LL |     m!('a', ..core::char::MAX);\n+   |        ^^^ pattern `'\\u{10ffff}'` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `'\\u{10fffe}'..='\\u{10ffff}'` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:27:8\n+   |\n+LL |     m!('a', ..ALMOST_MAX);\n+   |        ^^^ pattern `'\\u{10fffe}'..='\\u{10ffff}'` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `'\\u{0}'` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:28:8\n+   |\n+LL |     m!('a', ALMOST_MIN..);\n+   |        ^^^ pattern `'\\u{0}'` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:29:8\n+   |\n+LL |     m!('a', ..=ALMOST_MAX);\n+   |        ^^^ pattern `'\\u{10ffff}'` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `'b'` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:30:8\n+   |\n+LL |     m!('a', ..=VAL | VAL_2..);\n+   |        ^^^ pattern `'b'` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `'b'` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:31:8\n+   |\n+LL |     m!('a', ..VAL_1 | VAL_2..);\n+   |        ^^^ pattern `'b'` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u8::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:41:12\n+   |\n+LL |         m!(0, ..core::u8::MAX);\n+   |            ^ pattern `std::u8::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `254u8..=std::u8::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:42:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `254u8..=std::u8::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `0u8` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:43:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `0u8` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u8::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:44:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::u8::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u8` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:45:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43u8` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u8` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:46:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43u8` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u16::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:54:12\n+   |\n+LL |         m!(0, ..core::u16::MAX);\n+   |            ^ pattern `std::u16::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `65534u16..=std::u16::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:55:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `65534u16..=std::u16::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `0u16` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:56:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `0u16` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u16::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:57:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::u16::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u16` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:58:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43u16` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u16` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:59:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43u16` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u32::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:67:12\n+   |\n+LL |         m!(0, ..core::u32::MAX);\n+   |            ^ pattern `std::u32::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `4294967294u32..=std::u32::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:68:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `4294967294u32..=std::u32::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `0u32` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:69:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `0u32` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u32::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:70:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::u32::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u32` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:71:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43u32` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u32` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:72:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43u32` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u64::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:80:12\n+   |\n+LL |         m!(0, ..core::u64::MAX);\n+   |            ^ pattern `std::u64::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `18446744073709551614u64..=std::u64::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:81:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `18446744073709551614u64..=std::u64::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `0u64` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:82:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `0u64` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u64::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:83:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::u64::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u64` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:84:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43u64` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u64` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:85:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43u64` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:93:12\n+   |\n+LL |         m!(0, ..core::u128::MAX);\n+   |            ^ pattern `std::u128::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454u128..=std::u128::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:94:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `340282366920938463463374607431768211454u128..=std::u128::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `0u128` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:95:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `0u128` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:96:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::u128::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u128` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:97:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43u128` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43u128` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:98:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43u128` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i8::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:109:12\n+   |\n+LL |         m!(0, ..core::i8::MAX);\n+   |            ^ pattern `std::i8::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `126i8..=std::i8::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:110:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `126i8..=std::i8::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:111:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `std::i8::MIN` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i8::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:112:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::i8::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i8` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:113:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43i8` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i8` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:114:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43i8` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i16::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:122:12\n+   |\n+LL |         m!(0, ..core::i16::MAX);\n+   |            ^ pattern `std::i16::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `32766i16..=std::i16::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:123:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `32766i16..=std::i16::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i16::MIN` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:124:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `std::i16::MIN` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i16::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:125:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::i16::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i16` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:126:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43i16` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i16` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:127:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43i16` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i32::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:135:12\n+   |\n+LL |         m!(0, ..core::i32::MAX);\n+   |            ^ pattern `std::i32::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `2147483646i32..=std::i32::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:136:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `2147483646i32..=std::i32::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i32::MIN` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:137:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `std::i32::MIN` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i32::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:138:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::i32::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i32` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:139:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43i32` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i32` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:140:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43i32` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i64::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:148:12\n+   |\n+LL |         m!(0, ..core::i64::MAX);\n+   |            ^ pattern `std::i64::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `9223372036854775806i64..=std::i64::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:149:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `9223372036854775806i64..=std::i64::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i64::MIN` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:150:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `std::i64::MIN` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i64::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:151:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::i64::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i64` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:152:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43i64` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i64` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:153:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43i64` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i128::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:161:12\n+   |\n+LL |         m!(0, ..core::i128::MAX);\n+   |            ^ pattern `std::i128::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726i128..=std::i128::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:162:12\n+   |\n+LL |         m!(0, ..ALMOST_MAX);\n+   |            ^ pattern `170141183460469231731687303715884105726i128..=std::i128::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i128::MIN` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:163:12\n+   |\n+LL |         m!(0, ALMOST_MIN..);\n+   |            ^ pattern `std::i128::MIN` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `std::i128::MAX` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:164:12\n+   |\n+LL |         m!(0, ..=ALMOST_MAX);\n+   |            ^ pattern `std::i128::MAX` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i128` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:165:12\n+   |\n+LL |         m!(0, ..=VAL | VAL_2..);\n+   |            ^ pattern `43i128` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `43i128` not covered\n+  --> $DIR/half-open-range-pats-exhaustive-fail.rs:166:12\n+   |\n+LL |         m!(0, ..VAL_1 | VAL_2..);\n+   |            ^ pattern `43i128` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 68 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "efac0df2a430d7ededa0e37862bdaf9619db0df1", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-pass.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-pass.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,49 @@\n+// check-pass\n+\n+// Test various exhaustive matches for `X..`, `..=X` and `..X` ranges.\n+\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {}\n+\n+macro_rules! m {\n+    ($s:expr, $($t:tt)+) => {\n+        match $s { $($t)+ => {} }\n+    }\n+}\n+\n+macro_rules! test_int {\n+    ($s:expr, $min:path, $max:path) => {\n+        m!($s, $min..);\n+        m!($s, $min..5 | 5..);\n+        m!($s, ..5 | 5..);\n+        m!($s, ..=4 | 5..);\n+        m!($s, ..=$max);\n+        m!($s, ..$max | $max);\n+        m!(($s, true), (..5, true) | (5.., true) | ($min.., false));\n+    }\n+}\n+\n+fn unsigned_int() {\n+    test_int!(0u8, core::u8::MIN, core::u8::MAX);\n+    test_int!(0u16, core::u16::MIN, core::u16::MAX);\n+    test_int!(0u32, core::u32::MIN, core::u32::MAX);\n+    test_int!(0u64, core::u64::MIN, core::u64::MAX);\n+    test_int!(0u128, core::u128::MIN, core::u128::MAX);\n+}\n+\n+fn signed_int() {\n+    test_int!(0i8, core::i8::MIN, core::i8::MAX);\n+    test_int!(0i16, core::i16::MIN, core::i16::MAX);\n+    test_int!(0i32, core::i32::MIN, core::i32::MAX);\n+    test_int!(0i64, core::i64::MIN, core::i64::MAX);\n+    test_int!(0i128, core::i128::MIN, core::i128::MAX);\n+}\n+\n+fn khar() {\n+    m!('a', ..=core::char::MAX);\n+    m!('a', '\\u{0}'..);\n+    m!('a', ..='\\u{D7FF}' | '\\u{E000}'..);\n+    m!('a', ..'\\u{D7FF}' | '\\u{D7FF}' | '\\u{E000}'..);\n+}"}, {"sha": "904efda903c693ce5ab5faba16776798b2379cb0", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-hair-lower-empty.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-hair-lower-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-hair-lower-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-hair-lower-empty.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,54 @@\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n+#![allow(illegal_floating_point_literal_pattern)]\n+\n+macro_rules! m {\n+    ($s:expr, $($t:tt)+) => {\n+        match $s { $($t)+ => {} }\n+    }\n+}\n+\n+fn main() {\n+    m!(0, ..core::u8::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0, ..core::u16::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0, ..core::u32::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0, ..core::u64::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0, ..core::u128::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+\n+    m!(0, ..core::i8::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0, ..core::i16::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0, ..core::i32::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0, ..core::i64::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0, ..core::i128::MIN);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+\n+    m!(0f32, ..core::f32::NEG_INFINITY);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+    m!(0f64, ..core::f64::NEG_INFINITY);\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+\n+    m!('a', ..'\\u{0}');\n+    //~^ ERROR lower range bound must be less than upper\n+    //~| ERROR lower range bound must be less than upper\n+}"}, {"sha": "b536e1b5548d0bd81ee781af5012714eaa5febf5", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-hair-lower-empty.stderr", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-hair-lower-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-hair-lower-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-hair-lower-empty.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,159 @@\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:12:11\n+   |\n+LL |     m!(0, ..core::u8::MIN);\n+   |           ^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:15:11\n+   |\n+LL |     m!(0, ..core::u16::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:18:11\n+   |\n+LL |     m!(0, ..core::u32::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:21:11\n+   |\n+LL |     m!(0, ..core::u64::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:24:11\n+   |\n+LL |     m!(0, ..core::u128::MIN);\n+   |           ^^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:28:11\n+   |\n+LL |     m!(0, ..core::i8::MIN);\n+   |           ^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:31:11\n+   |\n+LL |     m!(0, ..core::i16::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:34:11\n+   |\n+LL |     m!(0, ..core::i32::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:37:11\n+   |\n+LL |     m!(0, ..core::i64::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:40:11\n+   |\n+LL |     m!(0, ..core::i128::MIN);\n+   |           ^^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:44:14\n+   |\n+LL |     m!(0f32, ..core::f32::NEG_INFINITY);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:47:14\n+   |\n+LL |     m!(0f64, ..core::f64::NEG_INFINITY);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:51:13\n+   |\n+LL |     m!('a', ..'\\u{0}');\n+   |             ^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:12:11\n+   |\n+LL |     m!(0, ..core::u8::MIN);\n+   |           ^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:15:11\n+   |\n+LL |     m!(0, ..core::u16::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:18:11\n+   |\n+LL |     m!(0, ..core::u32::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:21:11\n+   |\n+LL |     m!(0, ..core::u64::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:24:11\n+   |\n+LL |     m!(0, ..core::u128::MIN);\n+   |           ^^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:28:11\n+   |\n+LL |     m!(0, ..core::i8::MIN);\n+   |           ^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:31:11\n+   |\n+LL |     m!(0, ..core::i16::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:34:11\n+   |\n+LL |     m!(0, ..core::i32::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:37:11\n+   |\n+LL |     m!(0, ..core::i64::MIN);\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:40:11\n+   |\n+LL |     m!(0, ..core::i128::MIN);\n+   |           ^^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:44:14\n+   |\n+LL |     m!(0f32, ..core::f32::NEG_INFINITY);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:47:14\n+   |\n+LL |     m!(0f64, ..core::f64::NEG_INFINITY);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0579]: lower range bound must be less than upper\n+  --> $DIR/half-open-range-pats-hair-lower-empty.rs:51:13\n+   |\n+LL |     m!('a', ..'\\u{0}');\n+   |             ^^^^^^^^^\n+\n+error: aborting due to 26 previous errors\n+\n+For more information about this error, try `rustc --explain E0579`."}, {"sha": "03166e3675571436e47c87ca41d8e0a75fca3526", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-inclusive-no-end.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,15 @@\n+// Test `X...` and `X..=` range patterns not being allowed syntactically.\n+// FIXME(Centril): perhaps these should be semantic restrictions.\n+\n+#![feature(half_open_range_patterns)]\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn foo() {\n+    if let 0... = 1 {} //~ ERROR inclusive range with no end\n+    if let 0..= = 1 {} //~ ERROR inclusive range with no end\n+    const X: u8 = 0;\n+    if let X... = 1 {} //~ ERROR inclusive range with no end\n+    if let X..= = 1 {} //~ ERROR inclusive range with no end\n+}"}, {"sha": "2b4d95f6842846fd904f97fcdca0e9b79068e592", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-inclusive-no-end.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,35 @@\n+error[E0586]: inclusive range with no end\n+  --> $DIR/half-open-range-pats-inclusive-no-end.rs:10:13\n+   |\n+LL |     if let 0... = 1 {}\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error[E0586]: inclusive range with no end\n+  --> $DIR/half-open-range-pats-inclusive-no-end.rs:11:13\n+   |\n+LL |     if let 0..= = 1 {}\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error[E0586]: inclusive range with no end\n+  --> $DIR/half-open-range-pats-inclusive-no-end.rs:13:13\n+   |\n+LL |     if let X... = 1 {}\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error[E0586]: inclusive range with no end\n+  --> $DIR/half-open-range-pats-inclusive-no-end.rs:14:13\n+   |\n+LL |     if let X..= = 1 {}\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0586`."}, {"sha": "e9a5361e63d271b75b10cd343af25df325de5771", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-ref-ambiguous-interp.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,24 @@\n+#![feature(half_open_range_patterns)]\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    match &0 {\n+        &0.. | _ => {}\n+        //~^ ERROR the range pattern here has ambiguous interpretation\n+        &0..= | _ => {}\n+        //~^ ERROR the range pattern here has ambiguous interpretation\n+        //~| ERROR inclusive range with no end\n+        &0... | _ => {}\n+        //~^ ERROR inclusive range with no end\n+    }\n+\n+    match &0 {\n+        &..0 | _ => {}\n+        //~^ ERROR the range pattern here has ambiguous interpretation\n+        &..=0 | _ => {}\n+        //~^ ERROR the range pattern here has ambiguous interpretation\n+        &...0 | _ => {}\n+    }\n+}"}, {"sha": "5d3aded022224c7a75047e070cd513914f1d3de4", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-ref-ambiguous-interp.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,43 @@\n+error: the range pattern here has ambiguous interpretation\n+  --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:8:10\n+   |\n+LL |         &0.. | _ => {}\n+   |          ^^^ help: add parentheses to clarify the precedence: `(0 ..)`\n+\n+error[E0586]: inclusive range with no end\n+  --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:10:11\n+   |\n+LL |         &0..= | _ => {}\n+   |           ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error: the range pattern here has ambiguous interpretation\n+  --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:10:10\n+   |\n+LL |         &0..= | _ => {}\n+   |          ^^^^ help: add parentheses to clarify the precedence: `(0 ..=)`\n+\n+error[E0586]: inclusive range with no end\n+  --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:13:11\n+   |\n+LL |         &0... | _ => {}\n+   |           ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error: the range pattern here has ambiguous interpretation\n+  --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:18:10\n+   |\n+LL |         &..0 | _ => {}\n+   |          ^^^ help: add parentheses to clarify the precedence: `(..0)`\n+\n+error: the range pattern here has ambiguous interpretation\n+  --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:20:10\n+   |\n+LL |         &..=0 | _ => {}\n+   |          ^^^^ help: add parentheses to clarify the precedence: `(..=0)`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0586`."}, {"sha": "416c59af3fd3e58ba13dacc37df80bd88f3e1350", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-semantics.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-semantics.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,160 @@\n+// run-pass\n+\n+// Test half-open range patterns against their expression equivalents\n+// via `.contains(...)` and make sure the dynamic semantics match.\n+\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n+#![allow(illegal_floating_point_literal_pattern)]\n+#![allow(unreachable_patterns)]\n+\n+macro_rules! yes {\n+    ($scrutinee:expr, $($t:tt)+) => {\n+        {\n+            let m = match $scrutinee { $($t)+ => true, _ => false, };\n+            let c = ($($t)+).contains(&$scrutinee);\n+            assert_eq!(m, c);\n+            m\n+        }\n+    }\n+}\n+\n+fn range_to_inclusive() {\n+    // `..=X` (`RangeToInclusive`-equivalent):\n+    //---------------------------------------\n+\n+    // u8; `..=X`\n+    assert!(yes!(core::u8::MIN, ..=core::u8::MIN));\n+    assert!(yes!(core::u8::MIN, ..=5));\n+    assert!(yes!(5u8, ..=5));\n+    assert!(!yes!(6u8, ..=5));\n+\n+    // i16; `..=X`\n+    assert!(yes!(core::i16::MIN, ..=core::i16::MIN));\n+    assert!(yes!(core::i16::MIN, ..=0));\n+    assert!(yes!(core::i16::MIN, ..=-5));\n+    assert!(yes!(-5, ..=-5));\n+    assert!(!yes!(-4, ..=-5));\n+\n+    // char; `..=X`\n+    assert!(yes!('\\u{0}', ..='\\u{0}'));\n+    assert!(yes!('\\u{0}', ..='a'));\n+    assert!(yes!('a', ..='a'));\n+    assert!(!yes!('b', ..='a'));\n+\n+    // f32; `..=X`\n+    assert!(yes!(core::f32::NEG_INFINITY, ..=core::f32::NEG_INFINITY));\n+    assert!(yes!(core::f32::NEG_INFINITY, ..=1.0f32));\n+    assert!(yes!(1.5f32, ..=1.5f32));\n+    assert!(!yes!(1.6f32, ..=-1.5f32));\n+\n+    // f64; `..=X`\n+    assert!(yes!(core::f64::NEG_INFINITY, ..=core::f64::NEG_INFINITY));\n+    assert!(yes!(core::f64::NEG_INFINITY, ..=1.0f64));\n+    assert!(yes!(1.5f64, ..=1.5f64));\n+    assert!(!yes!(1.6f64, ..=-1.5f64));\n+}\n+\n+fn range_to() {\n+    // `..X` (`RangeTo`-equivalent):\n+    //-----------------------------\n+\n+    // u8; `..X`\n+    assert!(yes!(0u8, ..1));\n+    assert!(yes!(0u8, ..5));\n+    assert!(!yes!(5u8, ..5));\n+    assert!(!yes!(6u8, ..5));\n+\n+    // u8; `..X`\n+    const NU8: u8 = core::u8::MIN + 1;\n+    assert!(yes!(core::u8::MIN, ..NU8));\n+    assert!(yes!(0u8, ..5));\n+    assert!(!yes!(5u8, ..5));\n+    assert!(!yes!(6u8, ..5));\n+\n+    // i16; `..X`\n+    const NI16: i16 = core::i16::MIN + 1;\n+    assert!(yes!(core::i16::MIN, ..NI16));\n+    assert!(yes!(core::i16::MIN, ..5));\n+    assert!(yes!(-6, ..-5));\n+    assert!(!yes!(-5, ..-5));\n+\n+    // char; `..X`\n+    assert!(yes!('\\u{0}', ..'\\u{1}'));\n+    assert!(yes!('\\u{0}', ..'a'));\n+    assert!(yes!('a', ..'b'));\n+    assert!(!yes!('a', ..'a'));\n+    assert!(!yes!('b', ..'a'));\n+\n+    // f32; `..X`\n+    assert!(yes!(core::f32::NEG_INFINITY, ..1.0f32));\n+    assert!(!yes!(1.5f32, ..1.5f32));\n+    const E32: f32 = 1.5f32 + core::f32::EPSILON;\n+    assert!(yes!(1.5f32, ..E32));\n+    assert!(!yes!(1.6f32, ..1.5f32));\n+\n+    // f64; `..X`\n+    assert!(yes!(core::f64::NEG_INFINITY, ..1.0f64));\n+    assert!(!yes!(1.5f64, ..1.5f64));\n+    const E64: f64 = 1.5f64 + core::f64::EPSILON;\n+    assert!(yes!(1.5f64, ..E64));\n+    assert!(!yes!(1.6f64, ..1.5f64));\n+}\n+\n+fn range_from() {\n+    // `X..` (`RangeFrom`-equivalent):\n+    //--------------------------------\n+\n+    // u8; `X..`\n+    assert!(yes!(core::u8::MIN, core::u8::MIN..));\n+    assert!(yes!(core::u8::MAX, core::u8::MIN..));\n+    assert!(!yes!(core::u8::MIN, 1..));\n+    assert!(!yes!(4, 5..));\n+    assert!(yes!(5, 5..));\n+    assert!(yes!(6, 5..));\n+    assert!(yes!(core::u8::MAX, core::u8::MAX..));\n+\n+    // i16; `X..`\n+    assert!(yes!(core::i16::MIN, core::i16::MIN..));\n+    assert!(yes!(core::i16::MAX, core::i16::MIN..));\n+    const NI16: i16 = core::i16::MIN + 1;\n+    assert!(!yes!(core::i16::MIN, NI16..));\n+    assert!(!yes!(-4, 5..));\n+    assert!(yes!(-4, -4..));\n+    assert!(yes!(-3, -4..));\n+    assert!(yes!(core::i16::MAX, core::i16::MAX..));\n+\n+    // char; `X..`\n+    assert!(yes!('\\u{0}', '\\u{0}'..));\n+    assert!(yes!(core::char::MAX, '\\u{0}'..));\n+    assert!(yes!('a', 'a'..));\n+    assert!(yes!('b', 'a'..));\n+    assert!(!yes!('a', 'b'..));\n+    assert!(yes!(core::char::MAX, core::char::MAX..));\n+\n+    // f32; `X..`\n+    assert!(yes!(core::f32::NEG_INFINITY, core::f32::NEG_INFINITY..));\n+    assert!(yes!(core::f32::INFINITY, core::f32::NEG_INFINITY..));\n+    assert!(!yes!(core::f32::NEG_INFINITY, 1.0f32..));\n+    assert!(yes!(core::f32::INFINITY, 1.0f32..));\n+    assert!(!yes!(1.0f32 - core::f32::EPSILON, 1.0f32..));\n+    assert!(yes!(1.0f32, 1.0f32..));\n+    assert!(yes!(core::f32::INFINITY, 1.0f32..));\n+    assert!(yes!(core::f32::INFINITY, core::f32::INFINITY..));\n+\n+    // f64; `X..`\n+    assert!(yes!(core::f64::NEG_INFINITY, core::f64::NEG_INFINITY..));\n+    assert!(yes!(core::f64::INFINITY, core::f64::NEG_INFINITY..));\n+    assert!(!yes!(core::f64::NEG_INFINITY, 1.0f64..));\n+    assert!(yes!(core::f64::INFINITY, 1.0f64..));\n+    assert!(!yes!(1.0f64 - core::f64::EPSILON, 1.0f64..));\n+    assert!(yes!(1.0f64, 1.0f64..));\n+    assert!(yes!(core::f64::INFINITY, 1.0f64..));\n+    assert!(yes!(core::f64::INFINITY, core::f64::INFINITY..));\n+}\n+\n+fn main() {\n+    range_to_inclusive();\n+    range_to();\n+    range_from();\n+}"}, {"sha": "a663acd2d191c381313bb11c23d1b0a819a4bfc1", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-syntactic-pass.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-syntactic-pass.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+\n+// Test the parsing of half-open ranges.\n+\n+#![feature(exclusive_range_pattern)]\n+#![feature(half_open_range_patterns)]\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    match scrutinee {\n+        X.. | 0.. | 'a'.. | 0.0f32.. => {}\n+        ..=X | ...X | ..X => {}\n+        ..=0 | ...0 | ..0 => {}\n+        ..='a' | ...'a' | ..'a' => {}\n+        ..=0.0f32 | ...0.0f32 | ..0.0f32 => {}\n+    }\n+\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            let ..$e;\n+            let ...$e;\n+            let ..=$e;\n+            let $e..;\n+            let $e...;\n+            let $e..=;\n+        }\n+    }\n+\n+    mac!(0);\n+}"}, {"sha": "bd795368205fc93cc2e38fcc2ee21e05ac93d020", "filename": "src/test/ui/half-open-range-patterns/pat-tuple-4.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-4.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {\n+    const PAT: u8 = 1;\n+\n+    match 0 {\n+        (.. PAT) => {}\n+        _ => {}\n+    }\n+}"}, {"sha": "613d907cfe329266b2e0f0ee56aa348ea2512dc8", "filename": "src/test/ui/half-open-range-patterns/pat-tuple-5.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-5.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,10 @@\n+#![feature(half_open_range_patterns)]\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {\n+    const PAT: u8 = 1;\n+\n+    match (0, 1) {\n+        (PAT ..) => {} //~ ERROR mismatched types\n+    }\n+}"}, {"sha": "307ad711b74d9f58c988b557ef799556ed6a1482", "filename": "src/test/ui/half-open-range-patterns/pat-tuple-5.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fpat-tuple-5.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/pat-tuple-5.rs:8:10\n+   |\n+LL |     match (0, 1) {\n+   |           ------ this expression has type `({integer}, {integer})`\n+LL |         (PAT ..) => {}\n+   |          ^^^ expected tuple, found `u8`\n+   |\n+   = note: expected tuple `({integer}, {integer})`\n+               found type `u8`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5b95a7379135556a855c37a4d8033f45abc17b96", "filename": "src/test/ui/issues/issue-41255.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fissues%2Fissue-41255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fissues%2Fissue-41255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41255.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,6 +1,7 @@\n // Matching against float literals should result in a linter error\n \n #![feature(exclusive_range_pattern)]\n+#![feature(half_open_range_patterns)]\n #![allow(unused)]\n #![forbid(illegal_floating_point_literal_pattern)]\n \n@@ -35,6 +36,22 @@ fn main() {\n                              //~| WARNING hard error\n                              //~| WARNING hard error\n                              //~| WARNING hard error\n+\n+        ..71.0 => {}\n+        //~^ ERROR floating-point types cannot be used in patterns\n+        //~| ERROR floating-point types cannot be used in patterns\n+        //~| WARNING hard error\n+        //~| WARNING this was previously accepted by the compiler\n+        ..=72.0 => {}\n+        //~^ ERROR floating-point types cannot be used in patterns\n+        //~| ERROR floating-point types cannot be used in patterns\n+        //~| WARNING hard error\n+        //~| WARNING this was previously accepted by the compiler\n+        71.0.. => {}\n+        //~^ ERROR floating-point types cannot be used in patterns\n+        //~| ERROR floating-point types cannot be used in patterns\n+        //~| WARNING hard error\n+        //~| WARNING this was previously accepted by the compiler\n         _ => {},\n     };\n     let y = 5.0;"}, {"sha": "1ff58153c88649fc4fc3a0d257b4208bc5d37332", "filename": "src/test/ui/issues/issue-41255.stderr", "status": "modified", "additions": 74, "deletions": 20, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fissues%2Fissue-41255.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fissues%2Fissue-41255.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41255.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,19 +1,19 @@\n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:10:9\n+  --> $DIR/issue-41255.rs:11:9\n    |\n LL |         5.0 => {},\n    |         ^^^\n    |\n note: lint level defined here\n-  --> $DIR/issue-41255.rs:5:11\n+  --> $DIR/issue-41255.rs:6:11\n    |\n LL | #![forbid(illegal_floating_point_literal_pattern)]\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:14:9\n+  --> $DIR/issue-41255.rs:15:9\n    |\n LL |         5.0f32 => {},\n    |         ^^^^^^\n@@ -22,7 +22,7 @@ LL |         5.0f32 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:18:10\n+  --> $DIR/issue-41255.rs:19:10\n    |\n LL |         -5.0 => {},\n    |          ^^^\n@@ -31,7 +31,7 @@ LL |         -5.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:22:9\n+  --> $DIR/issue-41255.rs:23:9\n    |\n LL |         1.0 .. 33.0 => {},\n    |         ^^^\n@@ -40,7 +40,7 @@ LL |         1.0 .. 33.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:22:16\n+  --> $DIR/issue-41255.rs:23:16\n    |\n LL |         1.0 .. 33.0 => {},\n    |                ^^^^\n@@ -49,7 +49,7 @@ LL |         1.0 .. 33.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:30:9\n+  --> $DIR/issue-41255.rs:31:9\n    |\n LL |         39.0 ..= 70.0 => {},\n    |         ^^^^\n@@ -58,7 +58,7 @@ LL |         39.0 ..= 70.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:30:18\n+  --> $DIR/issue-41255.rs:31:18\n    |\n LL |         39.0 ..= 70.0 => {},\n    |                  ^^^^\n@@ -67,7 +67,34 @@ LL |         39.0 ..= 70.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:43:10\n+  --> $DIR/issue-41255.rs:40:11\n+   |\n+LL |         ..71.0 => {}\n+   |           ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n+\n+error: floating-point types cannot be used in patterns\n+  --> $DIR/issue-41255.rs:45:12\n+   |\n+LL |         ..=72.0 => {}\n+   |            ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n+\n+error: floating-point types cannot be used in patterns\n+  --> $DIR/issue-41255.rs:50:9\n+   |\n+LL |         71.0.. => {}\n+   |         ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n+\n+error: floating-point types cannot be used in patterns\n+  --> $DIR/issue-41255.rs:60:10\n    |\n LL |         (3.14, 1) => {},\n    |          ^^^^\n@@ -76,7 +103,7 @@ LL |         (3.14, 1) => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:52:18\n+  --> $DIR/issue-41255.rs:69:18\n    |\n LL |         Foo { x: 2.0 } => {},\n    |                  ^^^\n@@ -85,7 +112,7 @@ LL |         Foo { x: 2.0 } => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:10:9\n+  --> $DIR/issue-41255.rs:11:9\n    |\n LL |         5.0 => {},\n    |         ^^^\n@@ -94,7 +121,7 @@ LL |         5.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:14:9\n+  --> $DIR/issue-41255.rs:15:9\n    |\n LL |         5.0f32 => {},\n    |         ^^^^^^\n@@ -103,7 +130,7 @@ LL |         5.0f32 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:18:10\n+  --> $DIR/issue-41255.rs:19:10\n    |\n LL |         -5.0 => {},\n    |          ^^^\n@@ -112,7 +139,7 @@ LL |         -5.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:22:9\n+  --> $DIR/issue-41255.rs:23:9\n    |\n LL |         1.0 .. 33.0 => {},\n    |         ^^^\n@@ -121,7 +148,7 @@ LL |         1.0 .. 33.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:22:16\n+  --> $DIR/issue-41255.rs:23:16\n    |\n LL |         1.0 .. 33.0 => {},\n    |                ^^^^\n@@ -130,7 +157,7 @@ LL |         1.0 .. 33.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:30:9\n+  --> $DIR/issue-41255.rs:31:9\n    |\n LL |         39.0 ..= 70.0 => {},\n    |         ^^^^\n@@ -139,7 +166,7 @@ LL |         39.0 ..= 70.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:30:18\n+  --> $DIR/issue-41255.rs:31:18\n    |\n LL |         39.0 ..= 70.0 => {},\n    |                  ^^^^\n@@ -148,7 +175,34 @@ LL |         39.0 ..= 70.0 => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:43:10\n+  --> $DIR/issue-41255.rs:40:11\n+   |\n+LL |         ..71.0 => {}\n+   |           ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n+\n+error: floating-point types cannot be used in patterns\n+  --> $DIR/issue-41255.rs:45:12\n+   |\n+LL |         ..=72.0 => {}\n+   |            ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n+\n+error: floating-point types cannot be used in patterns\n+  --> $DIR/issue-41255.rs:50:9\n+   |\n+LL |         71.0.. => {}\n+   |         ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n+\n+error: floating-point types cannot be used in patterns\n+  --> $DIR/issue-41255.rs:60:10\n    |\n LL |         (3.14, 1) => {},\n    |          ^^^^\n@@ -157,13 +211,13 @@ LL |         (3.14, 1) => {},\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: floating-point types cannot be used in patterns\n-  --> $DIR/issue-41255.rs:52:18\n+  --> $DIR/issue-41255.rs:69:18\n    |\n LL |         Foo { x: 2.0 } => {},\n    |                  ^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "118bff8144c7f6d33d178375eaed8e4d01b0cccb", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,3 +1,5 @@\n+#![feature(half_open_range_patterns)]\n+\n fn main() {}\n \n #[cfg(FALSE)] fn e() { let _ = box #![attr] 0; }\n@@ -90,15 +92,15 @@ fn main() {}\n // note: requires parens in patterns to allow disambiguation\n \n #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n-//~^ ERROR `X..=` range patterns are not supported\n+//~^ ERROR inclusive range with no end\n //~| ERROR expected one of `=>`, `if`, or `|`, found `#`\n #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n-//~^ ERROR `X..=` range patterns are not supported\n+//~^ ERROR inclusive range with no end\n //~| ERROR expected one of `=>`, `if`, or `|`, found `#`\n #[cfg(FALSE)] fn e() { match 0 { 0..=-#[attr] 10 => () } }\n //~^ ERROR unexpected token: `#`\n #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n-//~^ ERROR `X..=` range patterns are not supported\n+//~^ ERROR inclusive range with no end\n //~| ERROR expected one of `=>`, `if`, or `|`, found `#`\n \n #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }"}, {"sha": "654b49ab620229f11f3d5bae376af8c9ed4df998", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 70, "deletions": 63, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,149 +1,149 @@\n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:3:36\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:5:36\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = box #![attr] 0; }\n    |                                    ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected expression, found `]`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:5:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:7:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = [#[attr]]; }\n    |                                        ^ expected expression\n \n error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:7:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:9:35\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = foo#[attr](); }\n    |                                   ^ expected one of 7 possible tokens\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:9:36\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:11:36\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n    |                                    ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected expression, found `)`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:9:44\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:11:44\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n    |                                            ^ expected expression\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:12:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:14:38\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n    |                                      ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected expression, found `)`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:12:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:14:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n    |                                              ^ expected expression\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:15:36\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:17:36\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = 0 + #![attr] 0; }\n    |                                    ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:17:33\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:19:33\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = !#![attr] 0; }\n    |                                 ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:19:33\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:21:33\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = -#![attr] 0; }\n    |                                 ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:21:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:23:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x #![attr] as Y; }\n    |                                  ^ expected one of 7 possible tokens\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:23:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:25:35\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] foo; }\n    |                                   ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:25:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:27:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] foo; }\n    |                                        ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:27:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:29:35\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] {foo}; }\n    |                                   ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:29:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:31:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] {foo}; }\n    |                                        ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected expression, found `..`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:31:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:33:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] ..#[attr] 0; }\n    |                                        ^^ expected expression\n \n error: expected expression, found `..`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:33:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:35:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] ..; }\n    |                                        ^^ expected expression\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:35:41\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:37:41\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &#![attr] 0; }\n    |                                         ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:37:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:39:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n    |                                             ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:39:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:41:32\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] if 0 {}; }\n    |                                ^^^^^^^\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:41:37\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:43:37\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                --   ^       --- help: try placing this code inside a block: `{ {}; }`\n@@ -152,51 +152,51 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:43:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:45:38\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n    |                                      ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:45:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:47:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n    |                                        ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:47:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:49:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n    |                                             ^       --- help: try placing this code inside a block: `{ {}; }`\n    |                                             |\n    |                                             expected `{`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:49:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:51:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n    |                                              ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:51:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:53:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n    |                                             ^^^^^^^\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:51:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:53:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n    |                                             ^       -------- help: try placing this code inside a block: `{ if 0 {}; }`\n    |                                             |\n    |                                             expected `{`\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:54:50\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:56:50\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             --   ^       --- help: try placing this code inside a block: `{ {}; }`\n@@ -205,21 +205,21 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:56:51\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:58:51\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n    |                                                   ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:58:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:60:32\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] if let _ = 0 {}; }\n    |                                ^^^^^^^\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:60:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:62:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                --           ^       --- help: try placing this code inside a block: `{ {}; }`\n@@ -228,51 +228,51 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:62:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:64:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n    |                                              ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:64:48\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:66:48\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n    |                                                ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:66:53\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:68:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n    |                                                     ^       --- help: try placing this code inside a block: `{ {}; }`\n    |                                                     |\n    |                                                     expected `{`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:68:54\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:70:54\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n    |                                                      ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:70:53\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:72:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n    |                                                     ^^^^^^^\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:70:53\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:72:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n    |                                                     ^       ---------------- help: try placing this code inside a block: `{ if let _ = 0 {}; }`\n    |                                                     |\n    |                                                     expected `{`\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:73:66\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:75:66\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n    |                                                     --           ^       --- help: try placing this code inside a block: `{ {}; }`\n@@ -281,15 +281,15 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}\n    |                                                     this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:75:67\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:77:67\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }\n    |                                                                   ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:78:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:80:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attibute\n@@ -299,7 +299,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:80:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:82:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attibute\n@@ -309,7 +309,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:82:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:84:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!(); }\n    |                        ------- ^^^^^^^^ not permitted following an outer attibute\n@@ -319,7 +319,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!(); }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:84:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:86:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo![]; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attibute\n@@ -329,7 +329,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo![]; }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:86:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:88:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!{}; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attibute\n@@ -338,83 +338,90 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!{}; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: `X..=` range patterns are not supported\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:92:34\n+error[E0586]: inclusive range with no end\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:94:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n-   |                                  ^^^^ help: try using the maximum value for the type: `0..=MAX`\n+   |                                   ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:92:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:94:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n-error: `X..=` range patterns are not supported\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:95:34\n+error[E0586]: inclusive range with no end\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:97:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n-   |                                  ^^^^ help: try using the maximum value for the type: `0..=MAX`\n+   |                                   ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:95:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:97:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:98:39\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:100:39\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=-#[attr] 10 => () } }\n    |                                       ^\n \n-error: `X..=` range patterns are not supported\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:100:34\n+error[E0586]: inclusive range with no end\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:102:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n-   |                                  ^^^^ help: try using the maximum value for the type: `0..=MAX`\n+   |                                   ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:100:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:102:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:104:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:106:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^\n \n error: expected one of `.`, `;`, `?`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:104:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:106:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^ expected one of `.`, `;`, `?`, or an operator\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:107:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:109:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^\n \n error: expected one of `.`, `;`, `?`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:107:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:109:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^ expected one of `.`, `;`, `?`, or an operator\n \n error: expected statement after outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:112:44\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:114:44\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n    |                                            ^\n \n error: expected statement after outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:114:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:116:45\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }\n    |                                             ^\n \n error: aborting due to 57 previous errors\n \n+For more information about this error, try `rustc --explain E0586`."}, {"sha": "8efb3c73f034f71a7a169d908854cd068a62508b", "filename": "src/test/ui/parser/issue-63115-range-pat-interpolated.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fissue-63115-range-pat-interpolated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fissue-63115-range-pat-interpolated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63115-range-pat-interpolated.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,6 +1,7 @@\n // check-pass\n \n #![feature(exclusive_range_pattern)]\n+#![feature(half_open_range_patterns)]\n \n #![allow(ellipsis_inclusive_range_patterns)]\n \n@@ -10,6 +11,11 @@ fn main() {\n             if let 2...$e = 3 {}\n             if let 2..=$e = 3 {}\n             if let 2..$e = 3 {}\n+            if let ..$e = 3 {}\n+            if let ..=$e = 3 {}\n+            if let $e.. = 5 {}\n+            if let $e..5 = 4 {}\n+            if let $e..=5 = 4 {}\n         }\n     }\n     mac_expr!(4);"}, {"sha": "5ec143fae234479231dd52c8ff13f4d08a68b958", "filename": "src/test/ui/parser/issue-66357-unexpected-unreachable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-linelength\n+\n // The problem in #66357 was that the call trace:\n //\n // - parse_fn_block_decl\n@@ -11,4 +13,4 @@\n \n fn f() { |[](* }\n //~^ ERROR expected one of `,` or `:`, found `(`\n-//~| ERROR expected one of `)`, `-`, `_`, `box`, `mut`, `ref`, `|`, identifier, or path, found `*`\n+//~| ERROR expected one of `&`, `(`, `)`, `-`, `...`, `..=`, `..`, `[`, `_`, `box`, `mut`, `ref`, `|`, identifier, or path, found `*`"}, {"sha": "c3810999d239509f6100bfbbe04b387e5a94b8ef", "filename": "src/test/ui/parser/issue-66357-unexpected-unreachable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,11 +1,11 @@\n error: expected one of `,` or `:`, found `(`\n-  --> $DIR/issue-66357-unexpected-unreachable.rs:12:13\n+  --> $DIR/issue-66357-unexpected-unreachable.rs:14:13\n    |\n LL | fn f() { |[](* }\n    |             ^ expected one of `,` or `:`\n \n-error: expected one of `)`, `-`, `_`, `box`, `mut`, `ref`, `|`, identifier, or path, found `*`\n-  --> $DIR/issue-66357-unexpected-unreachable.rs:12:14\n+error: expected one of `&`, `(`, `)`, `-`, `...`, `..=`, `..`, `[`, `_`, `box`, `mut`, `ref`, `|`, identifier, or path, found `*`\n+  --> $DIR/issue-66357-unexpected-unreachable.rs:14:14\n    |\n LL | fn f() { |[](* }\n    |             -^ help: `)` may belong here"}, {"sha": "2f03160430a22fa4df6befd3495e0f3a5cab158a", "filename": "src/test/ui/parser/pat-tuple-4.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2dbcf0841a81fbada9a2b3af253b62b30a8318cc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dbcf0841a81fbada9a2b3af253b62b30a8318cc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs?ref=2dbcf0841a81fbada9a2b3af253b62b30a8318cc", "patch": "@@ -1,11 +0,0 @@\n-fn main() {\n-    const PAT: u8 = 0;\n-\n-    match 0 {\n-        (.. PAT) => {}\n-        //~^ ERROR `..X` range patterns are not supported\n-        //~| ERROR exclusive range pattern syntax is experimental\n-    }\n-}\n-\n-const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "6c64290e144c20638c38567baa7531a8c72c2643", "filename": "src/test/ui/parser/pat-tuple-4.stderr", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2dbcf0841a81fbada9a2b3af253b62b30a8318cc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dbcf0841a81fbada9a2b3af253b62b30a8318cc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr?ref=2dbcf0841a81fbada9a2b3af253b62b30a8318cc", "patch": "@@ -1,25 +0,0 @@\n-error: `..X` range patterns are not supported\n-  --> $DIR/pat-tuple-4.rs:5:10\n-   |\n-LL |         (.. PAT) => {}\n-   |          ^^^^^^ help: try using the minimum value for the type: `MIN..PAT`\n-\n-error[E0658]: exclusive range pattern syntax is experimental\n-  --> $DIR/pat-tuple-4.rs:5:10\n-   |\n-LL |         (.. PAT) => {}\n-   |          ^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/37854\n-   = help: add `#![feature(exclusive_range_pattern)]` to the crate attributes to enable\n-\n-error[E0308]: mismatched types\n-  --> $DIR/pat-tuple-4.rs:11:30\n-   |\n-LL | const RECOVERY_WITNESS: () = 0;\n-   |                              ^ expected `()`, found integer\n-\n-error: aborting due to 3 previous errors\n-\n-Some errors have detailed explanations: E0308, E0658.\n-For more information about an error, try `rustc --explain E0308`."}, {"sha": "5334ef93bb3bd1e6c8be8505893dd3bb1065d7fd", "filename": "src/test/ui/parser/pat-tuple-5.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dbcf0841a81fbada9a2b3af253b62b30a8318cc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dbcf0841a81fbada9a2b3af253b62b30a8318cc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs?ref=2dbcf0841a81fbada9a2b3af253b62b30a8318cc", "patch": "@@ -1,10 +0,0 @@\n-fn main() {\n-    const PAT: u8 = 0;\n-\n-    match (0, 1) {\n-        (PAT ..) => {}\n-        //~^ ERROR `X..` range patterns are not supported\n-        //~| ERROR exclusive range pattern syntax is experimental\n-        //~| ERROR mismatched types\n-    }\n-}"}, {"sha": "8ff4f948a05ec5132610e1f5d5d82dca9797906c", "filename": "src/test/ui/parser/pat-tuple-5.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2dbcf0841a81fbada9a2b3af253b62b30a8318cc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dbcf0841a81fbada9a2b3af253b62b30a8318cc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr?ref=2dbcf0841a81fbada9a2b3af253b62b30a8318cc", "patch": "@@ -1,30 +0,0 @@\n-error: `X..` range patterns are not supported\n-  --> $DIR/pat-tuple-5.rs:5:10\n-   |\n-LL |         (PAT ..) => {}\n-   |          ^^^^^^ help: try using the maximum value for the type: `PAT..MAX`\n-\n-error[E0658]: exclusive range pattern syntax is experimental\n-  --> $DIR/pat-tuple-5.rs:5:10\n-   |\n-LL |         (PAT ..) => {}\n-   |          ^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/37854\n-   = help: add `#![feature(exclusive_range_pattern)]` to the crate attributes to enable\n-\n-error[E0308]: mismatched types\n-  --> $DIR/pat-tuple-5.rs:5:10\n-   |\n-LL |     match (0, 1) {\n-   |           ------ this expression has type `({integer}, {integer})`\n-LL |         (PAT ..) => {}\n-   |          ^^^ expected tuple, found `u8`\n-   |\n-   = note: expected tuple `({integer}, {integer})`\n-               found type `u8`\n-\n-error: aborting due to 3 previous errors\n-\n-Some errors have detailed explanations: E0308, E0658.\n-For more information about an error, try `rustc --explain E0308`."}, {"sha": "a5aae2861b282fb4753756765701710380a28fc1", "filename": "src/test/ui/parser/recover-range-pats.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -4,6 +4,7 @@\n // 2. Or at least we have parser recovery if they don't.\n \n #![feature(exclusive_range_pattern)]\n+#![feature(half_open_range_patterns)]\n #![deny(ellipsis_inclusive_range_patterns)]\n \n fn main() {}\n@@ -55,68 +56,64 @@ fn inclusive2_from_to() {\n }\n \n fn exclusive_from() {\n-    if let 0.. = 0 {} //~ ERROR `X..` range patterns are not supported\n-    if let X.. = 0 {} //~ ERROR `X..` range patterns are not supported\n-    if let true.. = 0 {} //~ ERROR `X..` range patterns are not supported\n+    if let 0.. = 0 {}\n+    if let X.. = 0 {}\n+    if let true.. = 0 {}\n     //~^ ERROR only char and numeric types\n-    if let .0.. = 0 {} //~ ERROR `X..` range patterns are not supported\n+    if let .0.. = 0 {}\n     //~^ ERROR float literals must have an integer part\n     //~| ERROR mismatched types\n }\n \n fn inclusive_from() {\n-    if let 0..= = 0 {} //~ ERROR `X..=` range patterns are not supported\n-    if let X..= = 0 {} //~ ERROR `X..=` range patterns are not supported\n-    if let true..= = 0 {} //~ ERROR `X..=` range patterns are not supported\n+    if let 0..= = 0 {} //~ ERROR inclusive range with no end\n+    if let X..= = 0 {} //~ ERROR inclusive range with no end\n+    if let true..= = 0 {} //~ ERROR inclusive range with no end\n     //~| ERROR only char and numeric types\n-    if let .0..= = 0 {} //~ ERROR `X..=` range patterns are not supported\n+    if let .0..= = 0 {} //~ ERROR inclusive range with no end\n     //~^ ERROR float literals must have an integer part\n     //~| ERROR mismatched types\n }\n \n fn inclusive2_from() {\n-    if let 0... = 0 {} //~ ERROR `X...` range patterns are not supported\n-    //~^ ERROR `...` range patterns are deprecated\n-    if let X... = 0 {} //~ ERROR `X...` range patterns are not supported\n-    //~^ ERROR `...` range patterns are deprecated\n-    if let true... = 0 {} //~ ERROR `X...` range patterns are not supported\n-    //~^ ERROR `...` range patterns are deprecated\n+    if let 0... = 0 {} //~ ERROR inclusive range with no end\n+    if let X... = 0 {} //~ ERROR inclusive range with no end\n+    if let true... = 0 {} //~ ERROR inclusive range with no end\n     //~| ERROR only char and numeric types\n-    if let .0... = 0 {} //~ ERROR `X...` range patterns are not supported\n+    if let .0... = 0 {} //~ ERROR inclusive range with no end\n     //~^ ERROR float literals must have an integer part\n-    //~| ERROR `...` range patterns are deprecated\n     //~| ERROR mismatched types\n }\n \n fn exclusive_to() {\n-    if let ..0 = 0 {} //~ ERROR `..X` range patterns are not supported\n-    if let ..Y = 0 {} //~ ERROR `..X` range patterns are not supported\n-    if let ..true = 0 {} //~ ERROR `..X` range patterns are not supported\n-    //~| ERROR only char and numeric types\n-    if let .. .0 = 0 {} //~ ERROR `..X` range patterns are not supported\n+    if let ..0 = 0 {}\n+    if let ..Y = 0 {}\n+    if let ..true = 0 {}\n+    //~^ ERROR only char and numeric types\n+    if let .. .0 = 0 {}\n     //~^ ERROR float literals must have an integer part\n     //~| ERROR mismatched types\n }\n \n fn inclusive_to() {\n-    if let ..=3 = 0 {} //~ ERROR `..=X` range patterns are not supported\n-    if let ..=Y = 0 {} //~ ERROR `..=X` range patterns are not supported\n-    if let ..=true = 0 {} //~ ERROR `..=X` range patterns are not supported\n-    //~| ERROR only char and numeric types\n-    if let ..=.0 = 0 {} //~ ERROR `..=X` range patterns are not supported\n+    if let ..=3 = 0 {}\n+    if let ..=Y = 0 {}\n+    if let ..=true = 0 {}\n+    //~^ ERROR only char and numeric types\n+    if let ..=.0 = 0 {}\n     //~^ ERROR float literals must have an integer part\n     //~| ERROR mismatched types\n }\n \n fn inclusive2_to() {\n-    if let ...3 = 0 {} //~ ERROR `...X` range patterns are not supported\n+    if let ...3 = 0 {}\n     //~^ ERROR `...` range patterns are deprecated\n-    if let ...Y = 0 {} //~ ERROR `...X` range patterns are not supported\n+    if let ...Y = 0 {}\n     //~^ ERROR `...` range patterns are deprecated\n-    if let ...true = 0 {} //~ ERROR `...X` range patterns are not supported\n+    if let ...true = 0 {}\n     //~^ ERROR `...` range patterns are deprecated\n     //~| ERROR only char and numeric types\n-    if let ....3 = 0 {} //~ ERROR `...X` range patterns are not supported\n+    if let ....3 = 0 {}\n     //~^ ERROR float literals must have an integer part\n     //~| ERROR `...` range patterns are deprecated\n     //~| ERROR mismatched types\n@@ -136,14 +133,13 @@ fn with_macro_expr_var() {\n \n     macro_rules! mac {\n         ($e:expr) => {\n-            let ..$e; //~ ERROR `..X` range patterns are not supported\n-            let ...$e; //~ ERROR `...X` range patterns are not supported\n-            //~^ ERROR `...` range patterns are deprecated\n-            let ..=$e; //~ ERROR `..=X` range patterns are not supported\n-            let $e..; //~ ERROR `X..` range patterns are not supported\n-            let $e...; //~ ERROR `X...` range patterns are not supported\n+            let ..$e;\n+            let ...$e;\n             //~^ ERROR `...` range patterns are deprecated\n-            let $e..=; //~ ERROR `X..=` range patterns are not supported\n+            let ..=$e;\n+            let $e..;\n+            let $e...; //~ ERROR inclusive range with no end\n+            let $e..=; //~ ERROR inclusive range with no end\n         }\n     }\n "}, {"sha": "d3d3169022a65bff15d26ce625aa6a73a3ca3d91", "filename": "src/test/ui/parser/recover-range-pats.stderr", "status": "modified", "additions": 102, "deletions": 247, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/793b1be6df51a259477880a45a78fb5b42f1c9b4/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr?ref=793b1be6df51a259477880a45a78fb5b42f1c9b4", "patch": "@@ -1,377 +1,241 @@\n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:21:12\n+  --> $DIR/recover-range-pats.rs:22:12\n    |\n LL |     if let .0..Y = 0 {}\n    |            ^^ help: must have an integer part: `0.0`\n \n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:23:16\n+  --> $DIR/recover-range-pats.rs:24:16\n    |\n LL |     if let X.. .0 = 0 {}\n    |                ^^ help: must have an integer part: `0.0`\n \n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:34:12\n+  --> $DIR/recover-range-pats.rs:35:12\n    |\n LL |     if let .0..=Y = 0 {}\n    |            ^^ help: must have an integer part: `0.0`\n \n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:36:16\n+  --> $DIR/recover-range-pats.rs:37:16\n    |\n LL |     if let X..=.0 = 0 {}\n    |                ^^ help: must have an integer part: `0.0`\n \n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:49:12\n+  --> $DIR/recover-range-pats.rs:50:12\n    |\n LL |     if let .0...Y = 0 {}\n    |            ^^ help: must have an integer part: `0.0`\n \n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:52:17\n+  --> $DIR/recover-range-pats.rs:53:17\n    |\n LL |     if let X... .0 = 0 {}\n    |                 ^^ help: must have an integer part: `0.0`\n \n-error: `X..` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:58:12\n-   |\n-LL |     if let 0.. = 0 {}\n-   |            ^^^ help: try using the maximum value for the type: `0..MAX`\n-\n-error: `X..` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:59:12\n-   |\n-LL |     if let X.. = 0 {}\n-   |            ^^^ help: try using the maximum value for the type: `X..MAX`\n-\n-error: `X..` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:60:12\n-   |\n-LL |     if let true.. = 0 {}\n-   |            ^^^^^^ help: try using the maximum value for the type: `true..MAX`\n-\n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:62:12\n+  --> $DIR/recover-range-pats.rs:63:12\n    |\n LL |     if let .0.. = 0 {}\n    |            ^^ help: must have an integer part: `0.0`\n \n-error: `X..` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:62:12\n-   |\n-LL |     if let .0.. = 0 {}\n-   |            ^^^^ help: try using the maximum value for the type: `0.0..MAX`\n-\n-error: `X..=` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:68:12\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:69:13\n    |\n LL |     if let 0..= = 0 {}\n-   |            ^^^^ help: try using the maximum value for the type: `0..=MAX`\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-error: `X..=` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:69:12\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:70:13\n    |\n LL |     if let X..= = 0 {}\n-   |            ^^^^ help: try using the maximum value for the type: `X..=MAX`\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-error: `X..=` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:70:12\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:71:16\n    |\n LL |     if let true..= = 0 {}\n-   |            ^^^^^^^ help: try using the maximum value for the type: `true..=MAX`\n+   |                ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:72:12\n+  --> $DIR/recover-range-pats.rs:73:12\n    |\n LL |     if let .0..= = 0 {}\n    |            ^^ help: must have an integer part: `0.0`\n \n-error: `X..=` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:72:12\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:73:14\n    |\n LL |     if let .0..= = 0 {}\n-   |            ^^^^^ help: try using the maximum value for the type: `0.0..=MAX`\n+   |              ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-error: `X...` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:78:12\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:79:13\n    |\n LL |     if let 0... = 0 {}\n-   |            ^^^^ help: try using the maximum value for the type: `0...MAX`\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-error: `X...` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:80:12\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:80:13\n    |\n LL |     if let X... = 0 {}\n-   |            ^^^^ help: try using the maximum value for the type: `X...MAX`\n+   |             ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-error: `X...` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:82:12\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:81:16\n    |\n LL |     if let true... = 0 {}\n-   |            ^^^^^^^ help: try using the maximum value for the type: `true...MAX`\n+   |                ^^^\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:85:12\n+  --> $DIR/recover-range-pats.rs:83:12\n    |\n LL |     if let .0... = 0 {}\n    |            ^^ help: must have an integer part: `0.0`\n \n-error: `X...` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:85:12\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:83:14\n    |\n LL |     if let .0... = 0 {}\n-   |            ^^^^^ help: try using the maximum value for the type: `0.0...MAX`\n-\n-error: `..X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:92:12\n-   |\n-LL |     if let ..0 = 0 {}\n-   |            ^^^ help: try using the minimum value for the type: `MIN..0`\n-\n-error: `..X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:93:12\n+   |              ^^^\n    |\n-LL |     if let ..Y = 0 {}\n-   |            ^^^ help: try using the minimum value for the type: `MIN..Y`\n-\n-error: `..X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:94:12\n-   |\n-LL |     if let ..true = 0 {}\n-   |            ^^^^^^ help: try using the minimum value for the type: `MIN..true`\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:96:15\n+  --> $DIR/recover-range-pats.rs:93:15\n    |\n LL |     if let .. .0 = 0 {}\n    |               ^^ help: must have an integer part: `0.0`\n \n-error: `..X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:96:12\n-   |\n-LL |     if let .. .0 = 0 {}\n-   |            ^^^^^ help: try using the minimum value for the type: `MIN..0.0`\n-\n-error: `..=X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:102:12\n-   |\n-LL |     if let ..=3 = 0 {}\n-   |            ^^^^ help: try using the minimum value for the type: `MIN..=3`\n-\n-error: `..=X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:103:12\n-   |\n-LL |     if let ..=Y = 0 {}\n-   |            ^^^^ help: try using the minimum value for the type: `MIN..=Y`\n-\n-error: `..=X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:104:12\n-   |\n-LL |     if let ..=true = 0 {}\n-   |            ^^^^^^^ help: try using the minimum value for the type: `MIN..=true`\n-\n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:106:15\n+  --> $DIR/recover-range-pats.rs:103:15\n    |\n LL |     if let ..=.0 = 0 {}\n    |               ^^ help: must have an integer part: `0.0`\n \n-error: `..=X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:106:12\n-   |\n-LL |     if let ..=.0 = 0 {}\n-   |            ^^^^^ help: try using the minimum value for the type: `MIN..=0.0`\n-\n-error: `...X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:112:12\n-   |\n-LL |     if let ...3 = 0 {}\n-   |            ^^^^ help: try using the minimum value for the type: `MIN...3`\n-\n-error: `...X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:114:12\n-   |\n-LL |     if let ...Y = 0 {}\n-   |            ^^^^ help: try using the minimum value for the type: `MIN...Y`\n-\n-error: `...X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:116:12\n-   |\n-LL |     if let ...true = 0 {}\n-   |            ^^^^^^^ help: try using the minimum value for the type: `MIN...true`\n-\n error: float literals must have an integer part\n-  --> $DIR/recover-range-pats.rs:119:15\n+  --> $DIR/recover-range-pats.rs:116:15\n    |\n LL |     if let ....3 = 0 {}\n    |               ^^ help: must have an integer part: `0.3`\n \n-error: `...X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:119:12\n-   |\n-LL |     if let ....3 = 0 {}\n-   |            ^^^^^ help: try using the minimum value for the type: `MIN...0.3`\n-\n-error: `..X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:139:17\n-   |\n-LL |             let ..$e;\n-   |                 ^^ help: try using the minimum value for the type: `MIN..0`\n-...\n-LL |     mac!(0);\n-   |     -------- in this macro invocation\n-\n-error: `...X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:140:17\n-   |\n-LL |             let ...$e;\n-   |                 ^^^ help: try using the minimum value for the type: `MIN...0`\n-...\n-LL |     mac!(0);\n-   |     -------- in this macro invocation\n-\n-error: `..=X` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:142:17\n-   |\n-LL |             let ..=$e;\n-   |                 ^^^ help: try using the minimum value for the type: `MIN..=0`\n-...\n-LL |     mac!(0);\n-   |     -------- in this macro invocation\n-\n-error: `X..` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:143:19\n-   |\n-LL |             let $e..;\n-   |                   ^^ help: try using the maximum value for the type: `0..MAX`\n-...\n-LL |     mac!(0);\n-   |     -------- in this macro invocation\n-\n-error: `X...` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:144:19\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:141:19\n    |\n LL |             let $e...;\n-   |                   ^^^ help: try using the maximum value for the type: `0...MAX`\n+   |                   ^^^\n ...\n LL |     mac!(0);\n    |     -------- in this macro invocation\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-error: `X..=` range patterns are not supported\n-  --> $DIR/recover-range-pats.rs:146:19\n+error[E0586]: inclusive range with no end\n+  --> $DIR/recover-range-pats.rs:142:19\n    |\n LL |             let $e..=;\n-   |                   ^^^ help: try using the maximum value for the type: `0..=MAX`\n+   |                   ^^^\n ...\n LL |     mac!(0);\n    |     -------- in this macro invocation\n+   |\n+   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:41:13\n+  --> $DIR/recover-range-pats.rs:42:13\n    |\n LL |     if let 0...3 = 0 {}\n    |             ^^^ help: use `..=` for an inclusive range\n    |\n note: lint level defined here\n-  --> $DIR/recover-range-pats.rs:7:9\n+  --> $DIR/recover-range-pats.rs:8:9\n    |\n LL | #![deny(ellipsis_inclusive_range_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:42:13\n+  --> $DIR/recover-range-pats.rs:43:13\n    |\n LL |     if let 0...Y = 0 {}\n    |             ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:43:13\n+  --> $DIR/recover-range-pats.rs:44:13\n    |\n LL |     if let X...3 = 0 {}\n    |             ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:44:13\n+  --> $DIR/recover-range-pats.rs:45:13\n    |\n LL |     if let X...Y = 0 {}\n    |             ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:45:16\n+  --> $DIR/recover-range-pats.rs:46:16\n    |\n LL |     if let true...Y = 0 {}\n    |                ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:47:13\n+  --> $DIR/recover-range-pats.rs:48:13\n    |\n LL |     if let X...true = 0 {}\n    |             ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:49:14\n+  --> $DIR/recover-range-pats.rs:50:14\n    |\n LL |     if let .0...Y = 0 {}\n    |              ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:52:13\n+  --> $DIR/recover-range-pats.rs:53:13\n    |\n LL |     if let X... .0 = 0 {}\n    |             ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:78:13\n-   |\n-LL |     if let 0... = 0 {}\n-   |             ^^^ help: use `..=` for an inclusive range\n-\n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:80:13\n-   |\n-LL |     if let X... = 0 {}\n-   |             ^^^ help: use `..=` for an inclusive range\n-\n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:82:16\n-   |\n-LL |     if let true... = 0 {}\n-   |                ^^^ help: use `..=` for an inclusive range\n-\n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:85:14\n-   |\n-LL |     if let .0... = 0 {}\n-   |              ^^^ help: use `..=` for an inclusive range\n-\n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:112:12\n+  --> $DIR/recover-range-pats.rs:109:12\n    |\n LL |     if let ...3 = 0 {}\n    |            ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:114:12\n+  --> $DIR/recover-range-pats.rs:111:12\n    |\n LL |     if let ...Y = 0 {}\n    |            ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:116:12\n+  --> $DIR/recover-range-pats.rs:113:12\n    |\n LL |     if let ...true = 0 {}\n    |            ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:119:12\n+  --> $DIR/recover-range-pats.rs:116:12\n    |\n LL |     if let ....3 = 0 {}\n    |            ^^^ help: use `..=` for an inclusive range\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:129:20\n+  --> $DIR/recover-range-pats.rs:126:20\n    |\n LL |             let $e1...$e2;\n    |                    ^^^ help: use `..=` for an inclusive range\n@@ -380,49 +244,40 @@ LL |     mac2!(0, 1);\n    |     ------------ in this macro invocation\n \n error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:140:17\n+  --> $DIR/recover-range-pats.rs:137:17\n    |\n LL |             let ...$e;\n    |                 ^^^ help: use `..=` for an inclusive range\n ...\n LL |     mac!(0);\n    |     -------- in this macro invocation\n \n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:144:19\n-   |\n-LL |             let $e...;\n-   |                   ^^^ help: use `..=` for an inclusive range\n-...\n-LL |     mac!(0);\n-   |     -------- in this macro invocation\n-\n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:19:12\n+  --> $DIR/recover-range-pats.rs:20:12\n    |\n LL |     if let true..Y = 0 {}\n    |            ^^^^  - this is of type `u8`\n    |            |\n    |            this is of type `bool` but it should be `char` or numeric\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:20:15\n+  --> $DIR/recover-range-pats.rs:21:15\n    |\n LL |     if let X..true = 0 {}\n    |            -  ^^^^ this is of type `bool` but it should be `char` or numeric\n    |            |\n    |            this is of type `u8`\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:21:12\n+  --> $DIR/recover-range-pats.rs:22:12\n    |\n LL |     if let .0..Y = 0 {}\n    |            ^^  - this is of type `u8`\n    |            |\n    |            expected integer, found floating-point number\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:23:16\n+  --> $DIR/recover-range-pats.rs:24:16\n    |\n LL |     if let X.. .0 = 0 {}\n    |            -   ^^   - this expression has type `u8`\n@@ -431,31 +286,31 @@ LL |     if let X.. .0 = 0 {}\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:32:12\n+  --> $DIR/recover-range-pats.rs:33:12\n    |\n LL |     if let true..=Y = 0 {}\n    |            ^^^^   - this is of type `u8`\n    |            |\n    |            this is of type `bool` but it should be `char` or numeric\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:33:16\n+  --> $DIR/recover-range-pats.rs:34:16\n    |\n LL |     if let X..=true = 0 {}\n    |            -   ^^^^ this is of type `bool` but it should be `char` or numeric\n    |            |\n    |            this is of type `u8`\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:34:12\n+  --> $DIR/recover-range-pats.rs:35:12\n    |\n LL |     if let .0..=Y = 0 {}\n    |            ^^   - this is of type `u8`\n    |            |\n    |            expected integer, found floating-point number\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:36:16\n+  --> $DIR/recover-range-pats.rs:37:16\n    |\n LL |     if let X..=.0 = 0 {}\n    |            -   ^^   - this expression has type `u8`\n@@ -464,31 +319,31 @@ LL |     if let X..=.0 = 0 {}\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:45:12\n+  --> $DIR/recover-range-pats.rs:46:12\n    |\n LL |     if let true...Y = 0 {}\n    |            ^^^^   - this is of type `u8`\n    |            |\n    |            this is of type `bool` but it should be `char` or numeric\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:47:16\n+  --> $DIR/recover-range-pats.rs:48:16\n    |\n LL |     if let X...true = 0 {}\n    |            -   ^^^^ this is of type `bool` but it should be `char` or numeric\n    |            |\n    |            this is of type `u8`\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:49:12\n+  --> $DIR/recover-range-pats.rs:50:12\n    |\n LL |     if let .0...Y = 0 {}\n    |            ^^   - this is of type `u8`\n    |            |\n    |            expected integer, found floating-point number\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:52:17\n+  --> $DIR/recover-range-pats.rs:53:17\n    |\n LL |     if let X... .0 = 0 {}\n    |            -    ^^   - this expression has type `u8`\n@@ -497,78 +352,78 @@ LL |     if let X... .0 = 0 {}\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:60:12\n+  --> $DIR/recover-range-pats.rs:61:12\n    |\n LL |     if let true.. = 0 {}\n    |            ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:62:12\n+  --> $DIR/recover-range-pats.rs:63:12\n    |\n LL |     if let .0.. = 0 {}\n    |            ^^ expected integer, found floating-point number\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:70:12\n+  --> $DIR/recover-range-pats.rs:71:12\n    |\n LL |     if let true..= = 0 {}\n    |            ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:72:12\n+  --> $DIR/recover-range-pats.rs:73:12\n    |\n LL |     if let .0..= = 0 {}\n    |            ^^ expected integer, found floating-point number\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:82:12\n+  --> $DIR/recover-range-pats.rs:81:12\n    |\n LL |     if let true... = 0 {}\n    |            ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:85:12\n+  --> $DIR/recover-range-pats.rs:83:12\n    |\n LL |     if let .0... = 0 {}\n    |            ^^ expected integer, found floating-point number\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:94:14\n+  --> $DIR/recover-range-pats.rs:91:14\n    |\n LL |     if let ..true = 0 {}\n    |              ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:96:15\n+  --> $DIR/recover-range-pats.rs:93:15\n    |\n LL |     if let .. .0 = 0 {}\n    |               ^^ expected integer, found floating-point number\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:104:15\n+  --> $DIR/recover-range-pats.rs:101:15\n    |\n LL |     if let ..=true = 0 {}\n    |               ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:106:15\n+  --> $DIR/recover-range-pats.rs:103:15\n    |\n LL |     if let ..=.0 = 0 {}\n    |               ^^ expected integer, found floating-point number\n \n error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/recover-range-pats.rs:116:15\n+  --> $DIR/recover-range-pats.rs:113:15\n    |\n LL |     if let ...true = 0 {}\n    |               ^^^^ this is of type `bool` but it should be `char` or numeric\n \n error[E0308]: mismatched types\n-  --> $DIR/recover-range-pats.rs:119:15\n+  --> $DIR/recover-range-pats.rs:116:15\n    |\n LL |     if let ....3 = 0 {}\n    |               ^^ expected integer, found floating-point number\n \n-error: aborting due to 85 previous errors\n+error: aborting due to 60 previous errors\n \n-Some errors have detailed explanations: E0029, E0308.\n+Some errors have detailed explanations: E0029, E0308, E0586.\n For more information about an error, try `rustc --explain E0029`."}]}