{"sha": "403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "node_id": "C_kwDOAAsO6NoAKDQwM2IzZjk0YmJiMjcxN2NhN2YwNmNkYzVjZjc5YmRhY2NmNmI1Nzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-11T23:28:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-11T23:28:14Z"}, "message": "Auto merge of #2480 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "03545037140a7a1f93f23008720b325956c26b14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03545037140a7a1f93f23008720b325956c26b14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "html_url": "https://github.com/rust-lang/rust/commit/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39ee5747153bf13324870c4a912acbf1f9bfde3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/39ee5747153bf13324870c4a912acbf1f9bfde3f", "html_url": "https://github.com/rust-lang/rust/commit/39ee5747153bf13324870c4a912acbf1f9bfde3f"}, {"sha": "96049ef88eb38af624134ee465d87eb91717b903", "url": "https://api.github.com/repos/rust-lang/rust/commits/96049ef88eb38af624134ee465d87eb91717b903", "html_url": "https://github.com/rust-lang/rust/commit/96049ef88eb38af624134ee465d87eb91717b903"}], "stats": {"total": 370, "additions": 141, "deletions": 229}, "files": [{"sha": "0bcadc0a366f8fb6a9b4bb563a14f46db50a919c", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -1 +1 @@\n-1603a70f82240ba2d27f72f964e36614d7620ad3\n+20ffea6938b5839c390252e07940b99e3b6a889a"}, {"sha": "c3eb0161c210fcbac0c8a077c0dc1295f4b50b4a", "filename": "src/shims/time.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -15,7 +15,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         clk_id_op: &OpTy<'tcx, Provenance>,\n         tp_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         // This clock support is deliberately minimal because a lot of clock types have fiddly\n         // properties (is it possible for Miri to be suspended independently of the host?). If you\n         // have a use for another clock type, please open an issue.\n@@ -46,15 +46,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else {\n             let einval = this.eval_libc(\"EINVAL\")?;\n             this.set_last_error(einval)?;\n-            return Ok(-1);\n+            return Ok(Scalar::from_i32(-1));\n         };\n \n         let tv_sec = duration.as_secs();\n         let tv_nsec = duration.subsec_nanos();\n \n         this.write_int_fields(&[tv_sec.into(), tv_nsec.into()], &this.deref_operand(tp_op)?)?;\n \n-        Ok(0)\n+        Ok(Scalar::from_i32(0))\n     }\n \n     fn gettimeofday(\n@@ -160,7 +160,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(-1) // Return non-zero on success\n     }\n \n-    fn mach_absolute_time(&self) -> InterpResult<'tcx, u64> {\n+    fn mach_absolute_time(&self) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n \n         this.assert_target_os(\"macos\", \"mach_absolute_time\");\n@@ -169,13 +169,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // This returns a u64, with time units determined dynamically by `mach_timebase_info`.\n         // We return plain nanoseconds.\n         let duration = Instant::now().duration_since(this.machine.time_anchor);\n-        u64::try_from(duration.as_nanos()).map_err(|_| {\n+        let res = u64::try_from(duration.as_nanos()).map_err(|_| {\n             err_unsup_format!(\"programs running longer than 2^64 nanoseconds are not supported\")\n-                .into()\n-        })\n+        })?;\n+        Ok(Scalar::from_u64(res))\n     }\n \n-    fn mach_timebase_info(&mut self, info_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n+    fn mach_timebase_info(\n+        &mut self,\n+        info_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"macos\", \"mach_timebase_info\");\n@@ -188,7 +191,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let (numer, denom) = (1, 1);\n         this.write_int_fields(&[numer.into(), denom.into()], &info)?;\n \n-        Ok(0) // KERN_SUCCESS\n+        Ok(Scalar::from_i32(0)) // KERN_SUCCESS\n     }\n \n     fn nanosleep("}, {"sha": "3dea8f203bb756a1bb75c0d1f7ca7d5b33a94bc2", "filename": "src/shims/unix/foreign_items.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fforeign_items.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -63,7 +63,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"close\" => {\n                 let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.close(fd)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"fcntl\" => {\n                 // `fcntl` is variadic. The argument count is checked based on the first argument\n@@ -128,13 +128,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"lseek64\" => {\n                 let [fd, offset, whence] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.lseek64(fd, offset, whence)?;\n-                this.write_scalar(Scalar::from_i64(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"ftruncate64\" => {\n                 let [fd, length] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.ftruncate64(fd, length)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"fsync\" => {\n                 let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -164,7 +164,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"realpath\" => {\n                 let [path, resolved_path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.realpath(path, resolved_path)?;\n-                this.write_pointer(result, dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"mkstemp\" => {\n                 let [template] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -437,7 +437,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"pthread_self\" => {\n                 let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.pthread_self(dest)?;\n+                let res = this.pthread_self()?;\n+                this.write_scalar(res, dest)?;\n             }\n             \"sched_yield\" => {\n                 let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;"}, {"sha": "2a6499ce999492dda7648542a26ac3d8dbde7f1f", "filename": "src/shims/unix/fs.rs", "status": "modified", "additions": 71, "deletions": 65, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffs.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -664,17 +664,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn close(&mut self, fd_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n+    fn close(&mut self, fd_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n-        if let Some(file_descriptor) = this.machine.file_handler.handles.remove(&fd) {\n-            let result = file_descriptor.close(this.machine.communicate())?;\n-            this.try_unwrap_io_result(result)\n-        } else {\n-            this.handle_not_found()\n-        }\n+        Ok(Scalar::from_i32(\n+            if let Some(file_descriptor) = this.machine.file_handler.handles.remove(&fd) {\n+                let result = file_descriptor.close(this.machine.communicate())?;\n+                this.try_unwrap_io_result(result)?\n+            } else {\n+                this.handle_not_found()?\n+            },\n+        ))\n     }\n \n     fn read(\n@@ -772,7 +774,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         fd_op: &OpTy<'tcx, Provenance>,\n         offset_op: &OpTy<'tcx, Provenance>,\n         whence_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i64> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         // Isolation check is done via `FileDescriptor` trait.\n@@ -790,18 +792,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else {\n             let einval = this.eval_libc(\"EINVAL\")?;\n             this.set_last_error(einval)?;\n-            return Ok(-1);\n+            return Ok(Scalar::from_i64(-1));\n         };\n \n         let communicate = this.machine.communicate();\n-        if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n-            let result = file_descriptor\n-                .seek(communicate, seek_from)?\n-                .map(|offset| i64::try_from(offset).unwrap());\n-            this.try_unwrap_io_result(result)\n-        } else {\n-            this.handle_not_found()\n-        }\n+        Ok(Scalar::from_i64(\n+            if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n+                let result = file_descriptor\n+                    .seek(communicate, seek_from)?\n+                    .map(|offset| i64::try_from(offset).unwrap());\n+                this.try_unwrap_io_result(result)?\n+            } else {\n+                this.handle_not_found()?\n+            },\n+        ))\n     }\n \n     fn unlink(&mut self, path_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n@@ -855,7 +859,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         path_op: &OpTy<'tcx, Provenance>,\n         buf_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"stat\");\n \n@@ -867,24 +871,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.reject_in_isolation(\"`stat`\", reject_with)?;\n             let eacc = this.eval_libc(\"EACCES\")?;\n             this.set_last_error(eacc)?;\n-            return Ok(-1);\n+            return Ok(Scalar::from_i32(-1));\n         }\n \n         // `stat` always follows symlinks.\n         let metadata = match FileMetadata::from_path(this, &path, true)? {\n             Some(metadata) => metadata,\n-            None => return Ok(-1),\n+            None => return Ok(Scalar::from_i32(-1)), // `FileMetadata` has set errno\n         };\n \n-        this.macos_stat_write_buf(metadata, buf_op)\n+        Ok(Scalar::from_i32(this.macos_stat_write_buf(metadata, buf_op)?))\n     }\n \n     // `lstat` is used to get symlink metadata.\n     fn macos_lstat(\n         &mut self,\n         path_op: &OpTy<'tcx, Provenance>,\n         buf_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"lstat\");\n \n@@ -896,22 +900,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.reject_in_isolation(\"`lstat`\", reject_with)?;\n             let eacc = this.eval_libc(\"EACCES\")?;\n             this.set_last_error(eacc)?;\n-            return Ok(-1);\n+            return Ok(Scalar::from_i32(-1));\n         }\n \n         let metadata = match FileMetadata::from_path(this, &path, false)? {\n             Some(metadata) => metadata,\n-            None => return Ok(-1),\n+            None => return Ok(Scalar::from_i32(-1)), // `FileMetadata` has set errno\n         };\n \n-        this.macos_stat_write_buf(metadata, buf_op)\n+        Ok(Scalar::from_i32(this.macos_stat_write_buf(metadata, buf_op)?))\n     }\n \n     fn macos_fstat(\n         &mut self,\n         fd_op: &OpTy<'tcx, Provenance>,\n         buf_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"macos\", \"fstat\");\n@@ -922,14 +926,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`fstat`\", reject_with)?;\n             // Set error code as \"EBADF\" (bad fd)\n-            return this.handle_not_found();\n+            return Ok(Scalar::from_i32(this.handle_not_found()?));\n         }\n \n         let metadata = match FileMetadata::from_fd(this, fd)? {\n             Some(metadata) => metadata,\n-            None => return Ok(-1),\n+            None => return Ok(Scalar::from_i32(-1)),\n         };\n-        this.macos_stat_write_buf(metadata, buf_op)\n+        Ok(Scalar::from_i32(this.macos_stat_write_buf(metadata, buf_op)?))\n     }\n \n     fn linux_statx(\n@@ -1343,7 +1347,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dirp_op: &OpTy<'tcx, Provenance>,\n         entry_op: &OpTy<'tcx, Provenance>,\n         result_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"macos\", \"readdir_r\");\n@@ -1354,13 +1358,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`readdir_r`\", reject_with)?;\n             // Set error code as \"EBADF\" (bad fd)\n-            return this.handle_not_found();\n+            return Ok(Scalar::from_i32(this.handle_not_found()?));\n         }\n \n         let open_dir = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n             err_unsup_format!(\"the DIR pointer passed to readdir_r did not come from opendir\")\n         })?;\n-        match open_dir.read_dir.next() {\n+        Ok(Scalar::from_i32(match open_dir.read_dir.next() {\n             Some(Ok(dir_entry)) => {\n                 // Write into entry, write pointer to result, return 0 on success.\n                 // The name is written with write_os_str_to_c_str, while the rest of the\n@@ -1417,25 +1421,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result_place = this.deref_operand(result_op)?;\n                 this.write_scalar(this.read_scalar(entry_op)?, &result_place.into())?;\n \n-                Ok(0)\n+                0\n             }\n             None => {\n                 // end of stream: return 0, assign *result=NULL\n                 this.write_null(&this.deref_operand(result_op)?.into())?;\n-                Ok(0)\n+                0\n             }\n             Some(Err(e)) =>\n                 match e.raw_os_error() {\n                     // return positive error number on error\n-                    Some(error) => Ok(error),\n+                    Some(error) => error,\n                     None => {\n                         throw_unsup_format!(\n                             \"the error {} couldn't be converted to a return value\",\n                             e\n                         )\n                     }\n                 },\n-        }\n+        }))\n     }\n \n     fn closedir(&mut self, dirp_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n@@ -1463,7 +1467,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         fd_op: &OpTy<'tcx, Provenance>,\n         length_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n@@ -1473,30 +1477,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`ftruncate64`\", reject_with)?;\n             // Set error code as \"EBADF\" (bad fd)\n-            return this.handle_not_found();\n+            return Ok(Scalar::from_i32(this.handle_not_found()?));\n         }\n \n-        if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n-            // FIXME: Support ftruncate64 for all FDs\n-            let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n-            if *writable {\n-                if let Ok(length) = length.try_into() {\n-                    let result = file.set_len(length);\n-                    this.try_unwrap_io_result(result.map(|_| 0i32))\n+        Ok(Scalar::from_i32(\n+            if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n+                // FIXME: Support ftruncate64 for all FDs\n+                let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n+                if *writable {\n+                    if let Ok(length) = length.try_into() {\n+                        let result = file.set_len(length);\n+                        this.try_unwrap_io_result(result.map(|_| 0i32))?\n+                    } else {\n+                        let einval = this.eval_libc(\"EINVAL\")?;\n+                        this.set_last_error(einval)?;\n+                        -1\n+                    }\n                 } else {\n+                    // The file is not writable\n                     let einval = this.eval_libc(\"EINVAL\")?;\n                     this.set_last_error(einval)?;\n-                    Ok(-1)\n+                    -1\n                 }\n             } else {\n-                // The file is not writable\n-                let einval = this.eval_libc(\"EINVAL\")?;\n-                this.set_last_error(einval)?;\n-                Ok(-1)\n-            }\n-        } else {\n-            this.handle_not_found()\n-        }\n+                this.handle_not_found()?\n+            },\n+        ))\n     }\n \n     fn fsync(&mut self, fd_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n@@ -1554,7 +1560,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         offset_op: &OpTy<'tcx, Provenance>,\n         nbytes_op: &OpTy<'tcx, Provenance>,\n         flags_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n@@ -1565,31 +1571,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if offset < 0 || nbytes < 0 {\n             let einval = this.eval_libc(\"EINVAL\")?;\n             this.set_last_error(einval)?;\n-            return Ok(-1);\n+            return Ok(Scalar::from_i32(-1));\n         }\n         let allowed_flags = this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_BEFORE\")?\n             | this.eval_libc_i32(\"SYNC_FILE_RANGE_WRITE\")?\n             | this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_AFTER\")?;\n         if flags & allowed_flags != flags {\n             let einval = this.eval_libc(\"EINVAL\")?;\n             this.set_last_error(einval)?;\n-            return Ok(-1);\n+            return Ok(Scalar::from_i32(-1));\n         }\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`sync_file_range`\", reject_with)?;\n             // Set error code as \"EBADF\" (bad fd)\n-            return this.handle_not_found();\n+            return Ok(Scalar::from_i32(this.handle_not_found()?));\n         }\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             // FIXME: Support sync_data_range for all FDs\n             let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n             let io_result = maybe_sync_file(file, *writable, File::sync_data);\n-            this.try_unwrap_io_result(io_result)\n+            Ok(Scalar::from_i32(this.try_unwrap_io_result(io_result)?))\n         } else {\n-            this.handle_not_found()\n+            Ok(Scalar::from_i32(this.handle_not_found()?))\n         }\n     }\n \n@@ -1674,7 +1680,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         path_op: &OpTy<'tcx, Provenance>,\n         processed_path_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os_is_unix(\"realpath\");\n \n@@ -1686,7 +1692,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.reject_in_isolation(\"`realpath`\", reject_with)?;\n             let eacc = this.eval_libc(\"EACCES\")?;\n             this.set_last_error(eacc)?;\n-            return Ok(Pointer::null());\n+            return Ok(Scalar::from_machine_usize(0, this));\n         }\n \n         let result = std::fs::canonicalize(pathname);\n@@ -1717,16 +1723,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         // seems like a bit of a mess anyway: <https://eklitzke.org/path-max-is-tricky>.\n                         let enametoolong = this.eval_libc(\"ENAMETOOLONG\")?;\n                         this.set_last_error(enametoolong)?;\n-                        return Ok(Pointer::null());\n+                        return Ok(Scalar::from_machine_usize(0, this));\n                     }\n                     processed_ptr\n                 };\n \n-                Ok(dest)\n+                Ok(Scalar::from_maybe_pointer(dest, this))\n             }\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n-                Ok(Pointer::null())\n+                Ok(Scalar::from_machine_usize(0, this))\n             }\n         }\n     }"}, {"sha": "6881d829c150de60d337486111d841fe2d571d3e", "filename": "src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -38,7 +38,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let [fd, offset, nbytes, flags] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n \n             // Time related shims\n@@ -47,27 +47,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let [clk_id, tp] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.clock_gettime(clk_id, tp)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n \n             // Threading\n-            \"prctl\" => {\n-                // prctl is variadic. (It is not documented like that in the manpage, but defined like that in the libc crate.)\n-                this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n-                let result = this.prctl(args)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n-            }\n             \"pthread_condattr_setclock\" => {\n                 let [attr, clock_id] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_setclock(attr, clock_id)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"pthread_condattr_getclock\" => {\n                 let [attr, clock_id] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_getclock(attr, clock_id)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"pthread_setname_np\" => {\n+                let [thread, name] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let res = this.pthread_setname_np(\n+                    this.read_scalar(thread)?.check_init()?,\n+                    this.read_scalar(name)?.check_init()?,\n+                )?;\n+                this.write_scalar(res, dest)?;\n             }\n \n             // Dynamically invoked syscalls"}, {"sha": "fd7d5fb763eef33b7671f9a9322ebb8fcd1adb10", "filename": "src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -29,24 +29,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"close$NOCANCEL\" => {\n                 let [result] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.close(result)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"stat\" | \"stat64\" | \"stat$INODE64\" => {\n                 let [path, buf] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_stat(path, buf)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"lstat\" | \"lstat64\" | \"lstat$INODE64\" => {\n                 let [path, buf] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_lstat(path, buf)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"fstat\" | \"fstat64\" | \"fstat$INODE64\" => {\n                 let [fd, buf] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_fstat(fd, buf)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"opendir$INODE64\" => {\n                 let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -57,27 +57,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let [dirp, entry, result] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_readdir_r(dirp, entry, result)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"lseek\" => {\n                 let [fd, offset, whence] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // macOS is 64bit-only, so this is lseek64\n                 let result = this.lseek64(fd, offset, whence)?;\n-                this.write_scalar(Scalar::from_i64(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"ftruncate\" => {\n                 let [fd, length] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // macOS is 64bit-only, so this is ftruncate64\n                 let result = this.ftruncate64(fd, length)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"realpath$DARWIN_EXTSN\" => {\n                 let [path, resolved_path] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.realpath(path, resolved_path)?;\n-                this.write_pointer(result, dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n \n             // Environment related shims\n@@ -93,13 +93,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"mach_absolute_time\" => {\n                 let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.mach_absolute_time()?;\n-                this.write_scalar(Scalar::from_u64(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n \n             \"mach_timebase_info\" => {\n                 let [info] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.mach_timebase_info(info)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n \n             // Access to command-line arguments\n@@ -173,8 +173,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Threading\n             \"pthread_setname_np\" => {\n                 let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let name = this.read_pointer(name)?;\n-                this.pthread_setname_np(name)?;\n+                let thread = this.pthread_self()?;\n+                this.pthread_setname_np(thread, this.read_scalar(name)?.check_init()?)?;\n             }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work."}, {"sha": "69e632915b170180d212a6e20a3040e469640323", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -723,7 +723,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         attr_op: &OpTy<'tcx, Provenance>,\n         clock_id_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         let clock_id = this.read_scalar(clock_id_op)?.check_init()?;\n@@ -733,23 +733,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             condattr_set_clock_id(this, attr_op, clock_id)?;\n         } else {\n             let einval = this.eval_libc_i32(\"EINVAL\")?;\n-            return Ok(einval);\n+            return Ok(Scalar::from_i32(einval));\n         }\n \n-        Ok(0)\n+        Ok(Scalar::from_i32(0))\n     }\n \n     fn pthread_condattr_getclock(\n         &mut self,\n         attr_op: &OpTy<'tcx, Provenance>,\n         clk_id_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, i32> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         let clock_id = condattr_get_clock_id(this, attr_op)?;\n         this.write_scalar(clock_id, &this.deref_operand(clk_id_op)?.into())?;\n \n-        Ok(0)\n+        Ok(Scalar::from_i32(0))\n     }\n \n     fn pthread_condattr_destroy("}, {"sha": "0df70543fac8895f839a42b0b5bcf92d30b42bf6", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 11, "deletions": 52, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -84,68 +84,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_self(&mut self, dest: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+    fn pthread_self(&mut self) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         let thread_id = this.get_active_thread();\n-        this.write_scalar(Scalar::from_uint(thread_id.to_u32(), dest.layout.size), dest)\n+        Ok(Scalar::from_machine_usize(thread_id.into(), this))\n     }\n \n-    fn prctl(&mut self, args: &[OpTy<'tcx, Provenance>]) -> InterpResult<'tcx, i32> {\n+    fn pthread_setname_np(\n+        &mut self,\n+        thread: Scalar<Provenance>,\n+        name: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        this.assert_target_os(\"linux\", \"prctl\");\n-\n-        if args.is_empty() {\n-            throw_ub_format!(\n-                \"incorrect number of arguments for `prctl`: got {}, expected at least 1\",\n-                args.len()\n-            );\n-        }\n-\n-        let option = this.read_scalar(&args[0])?.to_i32()?;\n-        if option == this.eval_libc_i32(\"PR_SET_NAME\")? {\n-            if args.len() < 2 {\n-                throw_ub_format!(\n-                    \"incorrect number of arguments for `prctl` with `PR_SET_NAME`: got {}, expected at least 2\",\n-                    args.len()\n-                );\n-            }\n-\n-            let address = this.read_pointer(&args[1])?;\n-            let mut name = this.read_c_str(address)?.to_owned();\n-            // The name should be no more than 16 bytes, including the null\n-            // byte. Since `read_c_str` returns the string without the null\n-            // byte, we need to truncate to 15.\n-            name.truncate(15);\n-            this.set_active_thread_name(name);\n-        } else if option == this.eval_libc_i32(\"PR_GET_NAME\")? {\n-            if args.len() < 2 {\n-                throw_ub_format!(\n-                    \"incorrect number of arguments for `prctl` with `PR_SET_NAME`: got {}, expected at least 2\",\n-                    args.len()\n-                );\n-            }\n-\n-            let address = this.read_pointer(&args[1])?;\n-            let mut name = this.get_active_thread_name().to_vec();\n-            name.push(0u8);\n-            assert!(name.len() <= 16);\n-            this.write_bytes_ptr(address, name)?;\n-        } else {\n-            throw_unsup_format!(\"unsupported prctl option {}\", option);\n-        }\n \n-        Ok(0)\n-    }\n-\n-    fn pthread_setname_np(&mut self, name: Pointer<Option<Provenance>>) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        this.assert_target_os(\"macos\", \"pthread_setname_np\");\n+        let thread = ThreadId::try_from(thread.to_machine_usize(this)?).unwrap();\n+        let name = name.to_pointer(this)?;\n \n         let name = this.read_c_str(name)?.to_owned();\n-        this.set_active_thread_name(name);\n+        this.set_thread_name(thread, name);\n \n-        Ok(())\n+        Ok(Scalar::from_u32(0))\n     }\n \n     fn sched_yield(&mut self) -> InterpResult<'tcx, i32> {"}, {"sha": "6f394fa42fc9caddaf96cfc18f7e49d02b924f16", "filename": "src/thread.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -69,9 +69,9 @@ impl From<u32> for ThreadId {\n     }\n }\n \n-impl ThreadId {\n-    pub fn to_u32_scalar(&self) -> Scalar<Provenance> {\n-        Scalar::from_u32(self.0)\n+impl From<ThreadId> for u64 {\n+    fn from(t: ThreadId) -> Self {\n+        t.0.into()\n     }\n }\n \n@@ -394,14 +394,9 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    /// Set the name of the active thread.\n-    fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n-        self.active_thread_mut().thread_name = Some(new_thread_name);\n-    }\n-\n-    /// Get the name of the active thread.\n-    pub fn get_active_thread_name(&self) -> &[u8] {\n-        self.active_thread_ref().thread_name()\n+    /// Set the name of the given thread.\n+    pub fn set_thread_name(&mut self, thread: ThreadId, new_thread_name: Vec<u8>) {\n+        self.threads[thread].thread_name = Some(new_thread_name);\n     }\n \n     /// Get the name of the given thread.\n@@ -704,18 +699,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n+    fn set_thread_name(&mut self, thread: ThreadId, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();\n-        this.machine.threads.set_active_thread_name(new_thread_name);\n+        this.machine.threads.set_thread_name(thread, new_thread_name);\n     }\n \n     #[inline]\n-    fn get_active_thread_name<'c>(&'c self) -> &'c [u8]\n+    fn get_thread_name<'c>(&'c self, thread: ThreadId) -> &'c [u8]\n     where\n         'mir: 'c,\n     {\n         let this = self.eval_context_ref();\n-        this.machine.threads.get_active_thread_name()\n+        this.machine.threads.get_thread_name(thread)\n     }\n \n     #[inline]"}, {"sha": "f3aaccd57411b0eb8a2fcb1bdc33288fdcdf6c85", "filename": "tests/pass/libc.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/tests%2Fpass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577/tests%2Fpass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flibc.rs?ref=403b3f94bbb2717ca7f06cdc5cf79bdaccf6b577", "patch": "@@ -277,58 +277,6 @@ fn test_rwlock_libc_static_initializer() {\n     }\n }\n \n-/// Test whether the `prctl` shim correctly sets the thread name.\n-///\n-/// Note: `prctl` exists only on Linux.\n-#[cfg(any(target_os = \"linux\"))]\n-fn test_prctl_thread_name() {\n-    use libc::c_long;\n-    use std::ffi::CString;\n-    unsafe {\n-        let mut buf = [255; 10];\n-        assert_eq!(\n-            libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long),\n-            0,\n-        );\n-        // Rust runtime might set thread name, so we allow two options here.\n-        assert!(&buf[..10] == b\"<unnamed>\\0\" || &buf[..5] == b\"main\\0\");\n-        let thread_name = CString::new(\"hello\").expect(\"CString::new failed\");\n-        assert_eq!(\n-            libc::prctl(\n-                libc::PR_SET_NAME,\n-                thread_name.as_ptr(),\n-                0 as c_long,\n-                0 as c_long,\n-                0 as c_long,\n-            ),\n-            0,\n-        );\n-        let mut buf = [255; 6];\n-        assert_eq!(\n-            libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long),\n-            0,\n-        );\n-        assert_eq!(b\"hello\\0\", &buf);\n-        let long_thread_name = CString::new(\"01234567890123456789\").expect(\"CString::new failed\");\n-        assert_eq!(\n-            libc::prctl(\n-                libc::PR_SET_NAME,\n-                long_thread_name.as_ptr(),\n-                0 as c_long,\n-                0 as c_long,\n-                0 as c_long,\n-            ),\n-            0,\n-        );\n-        let mut buf = [255; 16];\n-        assert_eq!(\n-            libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long),\n-            0,\n-        );\n-        assert_eq!(b\"012345678901234\\0\", &buf);\n-    }\n-}\n-\n /// Tests whether each thread has its own `__errno_location`.\n fn test_thread_local_errno() {\n     #[cfg(target_os = \"linux\")]\n@@ -473,9 +421,6 @@ fn main() {\n     #[cfg(any(target_os = \"linux\"))]\n     test_mutex_libc_static_initializer_recursive();\n \n-    #[cfg(any(target_os = \"linux\"))]\n-    test_prctl_thread_name();\n-\n     test_thread_local_errno();\n \n     #[cfg(any(target_os = \"linux\"))]"}]}