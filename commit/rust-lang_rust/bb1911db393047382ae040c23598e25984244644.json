{"sha": "bb1911db393047382ae040c23598e25984244644", "node_id": "C_kwDOAAsO6NoAKGJiMTkxMWRiMzkzMDQ3MzgyYWUwNDBjMjM1OThlMjU5ODQyNDQ2NDQ", "commit": {"author": {"name": "Nixon Enraght-Moony", "email": "nixon.emoony@gmail.com", "date": "2022-08-24T18:44:32Z"}, "committer": {"name": "Nixon Enraght-Moony", "email": "nixon.emoony@gmail.com", "date": "2022-09-14T15:14:15Z"}, "message": "jsondoclint: Add `Kind` abstraction", "tree": {"sha": "cfc003bc22a8cbdf54e201e72ca7e6054f77474c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfc003bc22a8cbdf54e201e72ca7e6054f77474c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb1911db393047382ae040c23598e25984244644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb1911db393047382ae040c23598e25984244644", "html_url": "https://github.com/rust-lang/rust/commit/bb1911db393047382ae040c23598e25984244644", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb1911db393047382ae040c23598e25984244644/comments", "author": {"login": "aDotInTheVoid", "id": 28781354, "node_id": "MDQ6VXNlcjI4NzgxMzU0", "avatar_url": "https://avatars.githubusercontent.com/u/28781354?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aDotInTheVoid", "html_url": "https://github.com/aDotInTheVoid", "followers_url": "https://api.github.com/users/aDotInTheVoid/followers", "following_url": "https://api.github.com/users/aDotInTheVoid/following{/other_user}", "gists_url": "https://api.github.com/users/aDotInTheVoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/aDotInTheVoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aDotInTheVoid/subscriptions", "organizations_url": "https://api.github.com/users/aDotInTheVoid/orgs", "repos_url": "https://api.github.com/users/aDotInTheVoid/repos", "events_url": "https://api.github.com/users/aDotInTheVoid/events{/privacy}", "received_events_url": "https://api.github.com/users/aDotInTheVoid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aDotInTheVoid", "id": 28781354, "node_id": "MDQ6VXNlcjI4NzgxMzU0", "avatar_url": "https://avatars.githubusercontent.com/u/28781354?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aDotInTheVoid", "html_url": "https://github.com/aDotInTheVoid", "followers_url": "https://api.github.com/users/aDotInTheVoid/followers", "following_url": "https://api.github.com/users/aDotInTheVoid/following{/other_user}", "gists_url": "https://api.github.com/users/aDotInTheVoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/aDotInTheVoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aDotInTheVoid/subscriptions", "organizations_url": "https://api.github.com/users/aDotInTheVoid/orgs", "repos_url": "https://api.github.com/users/aDotInTheVoid/repos", "events_url": "https://api.github.com/users/aDotInTheVoid/events{/privacy}", "received_events_url": "https://api.github.com/users/aDotInTheVoid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "html_url": "https://github.com/rust-lang/rust/commit/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b"}], "stats": {"total": 279, "additions": 213, "deletions": 66}, "files": [{"sha": "15866ab6950f30543293b0ccb958461f2258ebe4", "filename": "src/tools/jsondoclint/src/item_kind.rs", "status": "modified", "additions": 178, "deletions": 27, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/bb1911db393047382ae040c23598e25984244644/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1911db393047382ae040c23598e25984244644/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs?ref=bb1911db393047382ae040c23598e25984244644", "patch": "@@ -1,29 +1,180 @@\n-use rustdoc_json_types::ItemEnum;\n-\n-pub(crate) fn can_appear_in_mod(kind: &ItemEnum) -> bool {\n-    match kind {\n-        ItemEnum::Module(_) => true,\n-        ItemEnum::ExternCrate { .. } => true,\n-        ItemEnum::Import(_) => true,\n-        ItemEnum::Union(_) => true,\n-        ItemEnum::Struct(_) => true,\n-        ItemEnum::StructField(_) => false, // Only in structs or variants\n-        ItemEnum::Enum(_) => true,\n-        ItemEnum::Variant(_) => false, // Only in enums\n-        ItemEnum::Function(_) => true,\n-        ItemEnum::Trait(_) => true,\n-        ItemEnum::TraitAlias(_) => true,\n-        ItemEnum::Method(_) => false, // Only in traits\n-        ItemEnum::Impl(_) => true,\n-        ItemEnum::Typedef(_) => true,\n-        ItemEnum::OpaqueTy(_) => todo!(\"IDK\"), // On\n-        ItemEnum::Constant(_) => true,\n-        ItemEnum::Static(_) => true,\n-        ItemEnum::ForeignType => todo!(\"IDK\"),\n-        ItemEnum::Macro(_) => true,\n-        ItemEnum::ProcMacro(_) => true,\n-        ItemEnum::PrimitiveType(_) => todo!(\"IDK\"),\n-        ItemEnum::AssocConst { .. } => false, // Trait Only\n-        ItemEnum::AssocType { .. } => false,  // Trait only\n+use rustdoc_json_types::{Item, ItemEnum, ItemKind, ItemSummary};\n+\n+// We want a univeral way to represent an `ItemEnum` or `ItemKind`\n+\n+#[derive(Debug)]\n+pub(crate) enum Kind {\n+    Module,\n+    ExternCrate,\n+    Import,\n+    Struct,\n+    StructField,\n+    Union,\n+    Enum,\n+    Variant,\n+    Function,\n+    Typedef,\n+    OpaqueTy,\n+    Constant,\n+    Trait,\n+    TraitAlias,\n+    Method,\n+    Impl,\n+    Static,\n+    ForeignType,\n+    Macro,\n+    ProcAttribute,\n+    ProcDerive,\n+    AssocConst,\n+    AssocType,\n+    Primitive,\n+    Keyword,\n+    // Not in ItemKind\n+    ProcMacro,\n+    PrimitiveType,\n+}\n+\n+impl Kind {\n+    pub fn can_appear_in_mod(self) -> bool {\n+        use Kind::*;\n+        match self {\n+            Module => true,\n+            ExternCrate => true,\n+            Import => true,\n+            Union => true,\n+            Struct => true,\n+            Enum => true,\n+            Function => true,\n+            Trait => true,\n+            TraitAlias => true,\n+            Impl => true,\n+            Typedef => true,\n+            Constant => true,\n+            Static => true,\n+            Macro => true,\n+            ProcMacro => true,\n+\n+            ForeignType => todo!(\"IDK\"),\n+            Keyword => todo!(\"IDK\"),\n+            OpaqueTy => todo!(\"IDK\"),\n+            Primitive => todo!(\"IDK\"),\n+            PrimitiveType => todo!(\"IDK\"),\n+            ProcAttribute => todo!(\"IDK\"),\n+            ProcDerive => todo!(\"IDK\"),\n+\n+            // Only in traits\n+            AssocConst => false,\n+            AssocType => false,\n+            Method => false,\n+\n+            StructField => false, // Only in structs or variants\n+            Variant => false,     // Only in enums\n+        }\n+    }\n+\n+    pub fn can_appear_in_trait(self) -> bool {\n+        match self {\n+            Kind::AssocConst => true,\n+            Kind::AssocType => true,\n+            Kind::Method => true,\n+\n+            Kind::Module => false,\n+            Kind::ExternCrate => false,\n+            Kind::Import => false,\n+            Kind::Struct => false,\n+            Kind::StructField => false,\n+            Kind::Union => false,\n+            Kind::Enum => false,\n+            Kind::Variant => false,\n+            Kind::Function => false,\n+            Kind::Typedef => false,\n+            Kind::OpaqueTy => false,\n+            Kind::Constant => false,\n+            Kind::Trait => false,\n+            Kind::TraitAlias => false,\n+            Kind::Impl => false,\n+            Kind::Static => false,\n+            Kind::ForeignType => false,\n+            Kind::Macro => false,\n+            Kind::ProcAttribute => false,\n+            Kind::ProcDerive => false,\n+            Kind::Primitive => false,\n+            Kind::Keyword => false,\n+            Kind::ProcMacro => false,\n+            Kind::PrimitiveType => false,\n+        }\n+    }\n+\n+    pub fn is_struct_field(self) -> bool {\n+        matches!(self, Kind::StructField)\n+    }\n+    pub fn is_module(self) -> bool {\n+        matches!(self, Kind::Module)\n+    }\n+    pub fn is_impl(self) -> bool {\n+        matches!(self, Kind::Impl)\n+    }\n+    pub fn is_variant(self) -> bool {\n+        matches!(self, Kind::Variant)\n+    }\n+\n+    pub fn from_item(i: &Item) -> Self {\n+        use Kind::*;\n+        match i.inner {\n+            ItemEnum::Module(_) => Module,\n+            ItemEnum::Import(_) => Import,\n+            ItemEnum::Union(_) => Union,\n+            ItemEnum::Struct(_) => Struct,\n+            ItemEnum::StructField(_) => StructField,\n+            ItemEnum::Enum(_) => Enum,\n+            ItemEnum::Variant(_) => Variant,\n+            ItemEnum::Function(_) => Function,\n+            ItemEnum::Trait(_) => Trait,\n+            ItemEnum::TraitAlias(_) => TraitAlias,\n+            ItemEnum::Method(_) => Method,\n+            ItemEnum::Impl(_) => Impl,\n+            ItemEnum::Typedef(_) => Typedef,\n+            ItemEnum::OpaqueTy(_) => OpaqueTy,\n+            ItemEnum::Constant(_) => Constant,\n+            ItemEnum::Static(_) => Static,\n+            ItemEnum::Macro(_) => Macro,\n+            ItemEnum::ProcMacro(_) => ProcMacro,\n+            ItemEnum::PrimitiveType(_) => PrimitiveType,\n+            ItemEnum::ForeignType => ForeignType,\n+            ItemEnum::ExternCrate { .. } => ExternCrate,\n+            ItemEnum::AssocConst { .. } => AssocConst,\n+            ItemEnum::AssocType { .. } => AssocType,\n+        }\n+    }\n+\n+    pub fn from_summary(s: &ItemSummary) -> Self {\n+        use Kind::*;\n+        match s.kind {\n+            ItemKind::AssocConst => AssocConst,\n+            ItemKind::AssocType => AssocType,\n+            ItemKind::Constant => Constant,\n+            ItemKind::Enum => Enum,\n+            ItemKind::ExternCrate => ExternCrate,\n+            ItemKind::ForeignType => ForeignType,\n+            ItemKind::Function => Function,\n+            ItemKind::Impl => Impl,\n+            ItemKind::Import => Import,\n+            ItemKind::Keyword => Keyword,\n+            ItemKind::Macro => Macro,\n+            ItemKind::Method => Method,\n+            ItemKind::Module => Module,\n+            ItemKind::OpaqueTy => OpaqueTy,\n+            ItemKind::Primitive => Primitive,\n+            ItemKind::ProcAttribute => ProcAttribute,\n+            ItemKind::ProcDerive => ProcDerive,\n+            ItemKind::Static => Static,\n+            ItemKind::Struct => Struct,\n+            ItemKind::StructField => StructField,\n+            ItemKind::Trait => Trait,\n+            ItemKind::TraitAlias => TraitAlias,\n+            ItemKind::Typedef => Typedef,\n+            ItemKind::Union => Union,\n+            ItemKind::Variant => Variant,\n+        }\n     }\n }"}, {"sha": "b0e12479f92c629767afdfbb9aaf234978d266e0", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bb1911db393047382ae040c23598e25984244644/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1911db393047382ae040c23598e25984244644/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=bb1911db393047382ae040c23598e25984244644", "patch": "@@ -8,7 +8,7 @@ use rustdoc_json_types::{\n     TypeBindingKind, Typedef, Union, Variant, WherePredicate,\n };\n \n-use crate::{item_kind::can_appear_in_mod, Error};\n+use crate::{item_kind::Kind, Error};\n \n #[derive(Debug)]\n pub struct Validator<'a> {\n@@ -329,63 +329,59 @@ impl<'a> Validator<'a> {\n         }\n     }\n \n-    fn add_field_id(&mut self, id: &'a Id) {\n-        let item = &self.krate.index[id];\n-        if let ItemEnum::StructField(_) = item.inner {\n-            self.add_id(id);\n+    fn add_id_checked(&mut self, id: &'a Id, valid: fn(Kind) -> bool, expected: &str) {\n+        if let Some(kind) = self.kind_of(id) {\n+            if valid(kind) {\n+                self.add_id(id);\n+            } else {\n+                self.fail_expecting(id, expected);\n+            }\n         } else {\n-            self.fail(id, \"Expecting field\");\n+            self.fail(id, \"Not found\")\n         }\n     }\n \n-    fn add_mod_id(&mut self, id: &'a Id) {\n-        let item = &self.krate.index[id];\n-        if let ItemEnum::Module(_) = item.inner {\n-            self.add_id(id);\n-        } else {\n-            self.fail(id, \"Expecting module\");\n-        }\n+    fn add_field_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_struct_field, \"StructField\");\n     }\n \n+    fn add_mod_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_module, \"Module\");\n+    }\n     fn add_impl_id(&mut self, id: &'a Id) {\n-        let item = &self.krate.index[id];\n-        if let ItemEnum::StructField(_) = item.inner {\n-            self.add_id(id);\n-        } else {\n-            self.fail(id, \"Expecting impl\");\n-        }\n+        self.add_id_checked(id, Kind::is_impl, \"Impl\");\n     }\n \n     fn add_variant_id(&mut self, id: &'a Id) {\n-        let item = &self.krate.index[id];\n-        if let ItemEnum::StructField(_) = item.inner {\n-            self.add_id(id);\n-        } else {\n-            self.fail(id, \"Expecting variant\");\n-        }\n+        self.add_id_checked(id, Kind::is_variant, \"Variant\");\n     }\n \n     /// Add an Id that appeared in a trait\n     fn add_trait_item_id(&mut self, id: &'a Id) {\n-        let item = &self.krate.index[id];\n-        if !can_appear_in_mod(&item.inner) {\n-            self.fail(id, \"Expecting item that can appear in trait\");\n-        } else {\n-            self.add_id(id);\n-        }\n+        self.add_id_checked(id, Kind::can_appear_in_trait, \"Trait inner item\");\n     }\n \n     /// Add an Id that appeared in a mod\n     fn add_mod_item_id(&mut self, id: &'a Id) {\n-        let item = &self.krate.index[id];\n-        if can_appear_in_mod(&item.inner) {\n-            self.add_id(id);\n-        } else {\n-            self.fail(id, \"Expecting item that can appear in trait\");\n-        }\n+        self.add_id_checked(id, Kind::can_appear_in_mod, \"Module inner item\")\n+    }\n+\n+    fn fail_expecting(&mut self, id: &Id, expected: &str) {\n+        let kind = self.kind_of(id).unwrap(); // We know it has a kind, as it's wrong.\n+        self.fail(id, format!(\"Expected {expected} but found {kind:?}\"));\n     }\n \n-    fn fail(&mut self, id: &Id, msg: &str) {\n-        self.errs.push(Error { id: id.clone(), message: msg.to_string() });\n+    fn fail(&mut self, id: &Id, message: impl Into<String>) {\n+        self.errs.push(Error { id: id.clone(), message: message.into() });\n+    }\n+\n+    fn kind_of(&mut self, id: &Id) -> Option<Kind> {\n+        if let Some(item) = self.krate.index.get(id) {\n+            Some(Kind::from_item(item))\n+        } else if let Some(summary) = self.krate.paths.get(id) {\n+            Some(Kind::from_summary(summary))\n+        } else {\n+            None\n+        }\n     }\n }"}]}