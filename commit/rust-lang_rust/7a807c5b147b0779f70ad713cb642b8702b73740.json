{"sha": "7a807c5b147b0779f70ad713cb642b8702b73740", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhODA3YzViMTQ3YjA3NzlmNzBhZDcxM2NiNjQyYjg3MDJiNzM3NDA=", "commit": {"author": {"name": "AnthonyMikh", "email": "anthony.mikh@yandex.ru", "date": "2019-09-30T21:01:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-30T21:01:22Z"}, "message": "Simplify `EmitterWriter::emit_suggestion_default`\n\nMake function return early if source map is not present", "tree": {"sha": "f93a07cff01192ca705ea51c573adc7c6b0f6eeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f93a07cff01192ca705ea51c573adc7c6b0f6eeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a807c5b147b0779f70ad713cb642b8702b73740", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdkm0iCRBK7hj4Ov3rIwAAdHIIAEEMR2R/8mGrJaIlkXKk0k7I\nrP+RWUu5buBOrW9tDRl7cfh2pueggA3CmrDaQRh57yxx99iJ0tsrk93Et0guYs0w\n7IGv/r2Izn2zCBAE1fIkp68CqwZgSri+bhFSZyWUpq5vsabC2fbH2myl9As9y0Ba\nJml4iMQ0cFRpFhKWR2Hf0JVURFa2zm9yacVYeYbqBX+/oaMcGYEq4ZlAj2rv4glz\ng9rsPeqDtVjXi6YxHwNWCuaf9mUTMFJPUjEGS0uUhkxQ6JEL6pttJYGJ2FSfqg6B\njE/9CPY4H3SYN26pgzf0rpEIMn/4mE5deDW9y6Ih4c3MbbHJdFOH9xfZqUccdxI=\n=jLBx\n-----END PGP SIGNATURE-----\n", "payload": "tree f93a07cff01192ca705ea51c573adc7c6b0f6eeb\nparent 21724eda05abd377b23bac160f62664bc2ee0082\nauthor AnthonyMikh <anthony.mikh@yandex.ru> 1569877282 +0300\ncommitter GitHub <noreply@github.com> 1569877282 +0300\n\nSimplify `EmitterWriter::emit_suggestion_default`\n\nMake function return early if source map is not present"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a807c5b147b0779f70ad713cb642b8702b73740", "html_url": "https://github.com/rust-lang/rust/commit/7a807c5b147b0779f70ad713cb642b8702b73740", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a807c5b147b0779f70ad713cb642b8702b73740/comments", "author": {"login": "AnthonyMikh", "id": 19252795, "node_id": "MDQ6VXNlcjE5MjUyNzk1", "avatar_url": "https://avatars.githubusercontent.com/u/19252795?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AnthonyMikh", "html_url": "https://github.com/AnthonyMikh", "followers_url": "https://api.github.com/users/AnthonyMikh/followers", "following_url": "https://api.github.com/users/AnthonyMikh/following{/other_user}", "gists_url": "https://api.github.com/users/AnthonyMikh/gists{/gist_id}", "starred_url": "https://api.github.com/users/AnthonyMikh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AnthonyMikh/subscriptions", "organizations_url": "https://api.github.com/users/AnthonyMikh/orgs", "repos_url": "https://api.github.com/users/AnthonyMikh/repos", "events_url": "https://api.github.com/users/AnthonyMikh/events{/privacy}", "received_events_url": "https://api.github.com/users/AnthonyMikh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21724eda05abd377b23bac160f62664bc2ee0082", "url": "https://api.github.com/repos/rust-lang/rust/commits/21724eda05abd377b23bac160f62664bc2ee0082", "html_url": "https://github.com/rust-lang/rust/commit/21724eda05abd377b23bac160f62664bc2ee0082"}], "stats": {"total": 211, "additions": 107, "deletions": 104}, "files": [{"sha": "cc71a299a73cd33009ac222cdee7183dcfc155a5", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 107, "deletions": 104, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/7a807c5b147b0779f70ad713cb642b8702b73740/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a807c5b147b0779f70ad713cb642b8702b73740/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=7a807c5b147b0779f70ad713cb642b8702b73740", "patch": "@@ -1431,122 +1431,125 @@ impl EmitterWriter {\n         level: &Level,\n         max_line_num_len: usize,\n     ) -> io::Result<()> {\n-        if let Some(ref sm) = self.sm {\n-            let mut buffer = StyledBuffer::new();\n+        let sm = match self.sm {\n+            Some(ref sm) => sm,\n+            None => return Ok(())\n+        };\n \n-            // Render the suggestion message\n-            let level_str = level.to_string();\n-            if !level_str.is_empty() {\n-                buffer.append(0, &level_str, Style::Level(level.clone()));\n-                buffer.append(0, \": \", Style::HeaderMsg);\n+        let mut buffer = StyledBuffer::new();\n+\n+        // Render the suggestion message\n+        let level_str = level.to_string();\n+        if !level_str.is_empty() {\n+            buffer.append(0, &level_str, Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+        }\n+        self.msg_to_buffer(\n+            &mut buffer,\n+            &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+            max_line_num_len,\n+            \"suggestion\",\n+            Some(Style::HeaderMsg),\n+        );\n+\n+        // Render the replacements for each suggestion\n+        let suggestions = suggestion.splice_lines(&**sm);\n+\n+        let mut row_num = 2;\n+        for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+            // Only show underline if the suggestion spans a single line and doesn't cover the\n+            // entirety of the code output. If you have multiple replacements in the same line\n+            // of code, show the underline.\n+            let show_underline = !(parts.len() == 1\n+                && parts[0].snippet.trim() == complete.trim())\n+                && complete.lines().count() == 1;\n+\n+            let lines = sm.span_to_lines(parts[0].span).unwrap();\n+\n+            assert!(!lines.lines.is_empty());\n+\n+            let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n+            draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n+            let mut line_pos = 0;\n+            let mut lines = complete.lines();\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                // Print the span column to avoid confusion\n+                buffer.puts(row_num,\n+                            0,\n+                            &self.maybe_anonymized(line_start + line_pos),\n+                            Style::LineNumber);\n+                // print the suggestion\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                buffer.append(row_num, line, Style::NoStyle);\n+                line_pos += 1;\n+                row_num += 1;\n             }\n-            self.msg_to_buffer(\n-                &mut buffer,\n-                &[(suggestion.msg.to_owned(), Style::NoStyle)],\n-                max_line_num_len,\n-                \"suggestion\",\n-                Some(Style::HeaderMsg),\n-            );\n-\n-            // Render the replacements for each suggestion\n-            let suggestions = suggestion.splice_lines(&**sm);\n-\n-            let mut row_num = 2;\n-            for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n-                // Only show underline if the suggestion spans a single line and doesn't cover the\n-                // entirety of the code output. If you have multiple replacements in the same line\n-                // of code, show the underline.\n-                let show_underline = !(parts.len() == 1\n-                    && parts[0].snippet.trim() == complete.trim())\n-                    && complete.lines().count() == 1;\n-\n-                let lines = sm.span_to_lines(parts[0].span).unwrap();\n-\n-                assert!(!lines.lines.is_empty());\n-\n-                let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n-                draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n-                let mut line_pos = 0;\n-                let mut lines = complete.lines();\n-                for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-                    // Print the span column to avoid confusion\n-                    buffer.puts(row_num,\n-                                0,\n-                                &self.maybe_anonymized(line_start + line_pos),\n-                                Style::LineNumber);\n-                    // print the suggestion\n-                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                    buffer.append(row_num, line, Style::NoStyle);\n-                    line_pos += 1;\n-                    row_num += 1;\n-                }\n \n-                // This offset and the ones below need to be signed to account for replacement code\n-                // that is shorter than the original code.\n-                let mut offset: isize = 0;\n-                // Only show an underline in the suggestions if the suggestion is not the\n-                // entirety of the code being shown and the displayed code is not multiline.\n-                if show_underline {\n-                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                    for part in parts {\n-                        let span_start_pos = sm.lookup_char_pos(part.span.lo()).col_display;\n-                        let span_end_pos = sm.lookup_char_pos(part.span.hi()).col_display;\n-\n-                        // Do not underline the leading...\n-                        let start = part.snippet.len()\n-                            .saturating_sub(part.snippet.trim_start().len());\n-                        // ...or trailing spaces. Account for substitutions containing unicode\n-                        // characters.\n-                        let sub_len = part.snippet.trim().chars()\n-                            .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n-                            .sum();\n-\n-                        let underline_start = (span_start_pos + start) as isize + offset;\n-                        let underline_end = (span_start_pos + start + sub_len) as isize + offset;\n-                        for p in underline_start..underline_end {\n+            // This offset and the ones below need to be signed to account for replacement code\n+            // that is shorter than the original code.\n+            let mut offset: isize = 0;\n+            // Only show an underline in the suggestions if the suggestion is not the\n+            // entirety of the code being shown and the displayed code is not multiline.\n+            if show_underline {\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                for part in parts {\n+                    let span_start_pos = sm.lookup_char_pos(part.span.lo()).col_display;\n+                    let span_end_pos = sm.lookup_char_pos(part.span.hi()).col_display;\n+\n+                    // Do not underline the leading...\n+                    let start = part.snippet.len()\n+                        .saturating_sub(part.snippet.trim_start().len());\n+                    // ...or trailing spaces. Account for substitutions containing unicode\n+                    // characters.\n+                    let sub_len = part.snippet.trim().chars()\n+                        .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+                        .sum();\n+\n+                    let underline_start = (span_start_pos + start) as isize + offset;\n+                    let underline_end = (span_start_pos + start + sub_len) as isize + offset;\n+                    for p in underline_start..underline_end {\n+                        buffer.putc(row_num,\n+                                    max_line_num_len + 3 + p as usize,\n+                                    '^',\n+                                    Style::UnderlinePrimary);\n+                    }\n+                    // underline removals too\n+                    if underline_start == underline_end {\n+                        for p in underline_start-1..underline_start+1 {\n                             buffer.putc(row_num,\n                                         max_line_num_len + 3 + p as usize,\n-                                        '^',\n-                                        Style::UnderlinePrimary);\n-                        }\n-                        // underline removals too\n-                        if underline_start == underline_end {\n-                            for p in underline_start-1..underline_start+1 {\n-                                buffer.putc(row_num,\n-                                            max_line_num_len + 3 + p as usize,\n-                                            '-',\n-                                            Style::UnderlineSecondary);\n-                            }\n+                                        '-',\n+                                        Style::UnderlineSecondary);\n                         }\n-\n-                        // length of the code after substitution\n-                        let full_sub_len = part.snippet.chars()\n-                            .map(|ch| acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n-                            .sum() as isize;\n-\n-                        // length of the code to be substituted\n-                        let snippet_len = span_end_pos as isize - span_start_pos as isize;\n-                        // For multiple substitutions, use the position *after* the previous\n-                        // substitutions have happened.\n-                        offset += full_sub_len - snippet_len;\n                     }\n-                    row_num += 1;\n-                }\n \n-                // if we elided some lines, add an ellipsis\n-                if lines.next().is_some() {\n-                    buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n-                } else if !show_underline {\n-                    draw_col_separator_no_space(&mut buffer, row_num, max_line_num_len + 1);\n-                    row_num += 1;\n+                    // length of the code after substitution\n+                    let full_sub_len = part.snippet.chars()\n+                        .map(|ch| acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+                        .sum() as isize;\n+\n+                    // length of the code to be substituted\n+                    let snippet_len = span_end_pos as isize - span_start_pos as isize;\n+                    // For multiple substitutions, use the position *after* the previous\n+                    // substitutions have happened.\n+                    offset += full_sub_len - snippet_len;\n                 }\n+                row_num += 1;\n             }\n-            if suggestions.len() > MAX_SUGGESTIONS {\n-                let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n-                buffer.puts(row_num, 0, &msg, Style::NoStyle);\n+\n+            // if we elided some lines, add an ellipsis\n+            if lines.next().is_some() {\n+                buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n+            } else if !show_underline {\n+                draw_col_separator_no_space(&mut buffer, row_num, max_line_num_len + 1);\n+                row_num += 1;\n             }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         }\n+        if suggestions.len() > MAX_SUGGESTIONS {\n+            let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n+            buffer.puts(row_num, 0, &msg, Style::NoStyle);\n+        }\n+        emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         Ok(())\n     }\n "}]}