{"sha": "1b90f5efaf46073a7da509a895a0688e1c6300c3", "node_id": "C_kwDOAAsO6NoAKDFiOTBmNWVmYWY0NjA3M2E3ZGE1MDlhODk1YTA2ODhlMWM2MzAwYzM", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-06-02T16:53:04Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-06-08T21:42:58Z"}, "message": "Support float-like tuple indices in offset_of!()\n\nThe tokenizer gives us whole float literal tokens, we have to split them up\nin order to be able to create field access from them.", "tree": {"sha": "1dfa03e86f163a72e16a6d62df81f0aead4684c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dfa03e86f163a72e16a6d62df81f0aead4684c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b90f5efaf46073a7da509a895a0688e1c6300c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b90f5efaf46073a7da509a895a0688e1c6300c3", "html_url": "https://github.com/rust-lang/rust/commit/1b90f5efaf46073a7da509a895a0688e1c6300c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b90f5efaf46073a7da509a895a0688e1c6300c3/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d74ec96e8d334c765e35707f7b7f3c6499a1b43c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d74ec96e8d334c765e35707f7b7f3c6499a1b43c", "html_url": "https://github.com/rust-lang/rust/commit/d74ec96e8d334c765e35707f7b7f3c6499a1b43c"}], "stats": {"total": 363, "additions": 343, "deletions": 20}, "files": [{"sha": "df06115ef3b97f43acadf6d7e0716d39e1661a2f", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1b90f5efaf46073a7da509a895a0688e1c6300c3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b90f5efaf46073a7da509a895a0688e1c6300c3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=1b90f5efaf46073a7da509a895a0688e1c6300c3", "patch": "@@ -1852,10 +1852,53 @@ impl<'a> Parser<'a> {\n         let (fields, _trailing, _recovered) = self.parse_seq_to_before_end(\n             &TokenKind::CloseDelim(Delimiter::Parenthesis),\n             seq_sep,\n-            Parser::parse_field_name,\n+            |this| {\n+                let token::Literal(token::Lit { kind: token::Float, symbol, suffix }) = this.token.kind\n+                else {\n+                    return Ok(thin_vec![this.parse_field_name()?]);\n+                };\n+                let res = match this.break_up_float(symbol) {\n+                    // 1e2\n+                    DestructuredFloat::Single(sym, sp) => {\n+                        this.bump();\n+                        thin_vec![Ident::new(sym, sp)]\n+                    }\n+                    // 1.\n+                    DestructuredFloat::TrailingDot(sym, sym_span, dot_span) => {\n+                        assert!(suffix.is_none());\n+                        // Analogous to Self::break_and_eat\n+                        this.token_cursor.break_last_token = true;\n+                        // This might work, in cases like `1. 2.3`, and might not,\n+                        // in cases like `offset_of!(Ty, 1.)`.\n+                        this.token = Token::new(token::Ident(sym, false), sym_span);\n+                        this.bump_with((Token::new(token::Dot, dot_span), this.token_spacing));\n+                        thin_vec![Ident::new(sym, sym_span)]\n+                    }\n+                    // 1.2 | 1.2e3\n+                    DestructuredFloat::MiddleDot(\n+                        symbol1,\n+                        ident1_span,\n+                        _dot_span,\n+                        symbol2,\n+                        ident2_span,\n+                    ) => {\n+                        this.bump();\n+                        thin_vec![\n+                            Ident::new(symbol1, ident1_span),\n+                            Ident::new(symbol2, ident2_span)\n+                        ]\n+                    }\n+                    DestructuredFloat::Error => {\n+                        this.bump();\n+                        thin_vec![Ident::new(symbol, this.prev_token.span)]\n+                    }\n+                };\n+                Ok(res)\n+            },\n         )?;\n+        let fields = fields.into_iter().flatten().collect::<Vec<_>>();\n         let span = lo.to(self.token.span);\n-        Ok(self.mk_expr(span, ExprKind::OffsetOf(container, fields.to_vec().into())))\n+        Ok(self.mk_expr(span, ExprKind::OffsetOf(container, fields.into())))\n     }\n \n     /// Returns a string literal if the next token is a string literal."}, {"sha": "00fbb6bf8f4077d6886b7a2be609b4768b6b663c", "filename": "tests/ui/offset-of/offset-of-tuple-nested.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1b90f5efaf46073a7da509a895a0688e1c6300c3/tests%2Fui%2Foffset-of%2Foffset-of-tuple-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b90f5efaf46073a7da509a895a0688e1c6300c3/tests%2Fui%2Foffset-of%2Foffset-of-tuple-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-tuple-nested.rs?ref=1b90f5efaf46073a7da509a895a0688e1c6300c3", "patch": "@@ -0,0 +1,32 @@\n+// run-pass\n+// Test for issue #112204 -- make sure this goes through the entire compilation pipeline,\n+// similar to why `offset-of-unsized.rs` is also build-pass\n+\n+#![feature(offset_of)]\n+#![feature(builtin_syntax)]\n+\n+use std::mem::offset_of;\n+\n+type ComplexTup = ((u8, (u8, (u8, u16), u8)), (u8, u32, u16));\n+\n+fn main() {\n+    println!(\"{}\", offset_of!(((u8, u8), u8), 0));\n+    println!(\"{}\", offset_of!(((u8, u8), u8), 1));\n+    println!(\"{}\", offset_of!(((u8, (u8, u8)), (u8, u8, u8)), 0.1.0));\n+\n+    // Complex case: do all combinations of spacings because the spacing determines what gets\n+    // sent to the lexer.\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1.1.1));\n+    println!(\"{}\", builtin # offset_of(ComplexTup, 0. 1.1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0 . 1.1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0 .1.1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1 .1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1 . 1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1. 1.1));\n+    println!(\"{}\", builtin # offset_of(ComplexTup, 0.1.1. 1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1.1 . 1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1.1 .1));\n+\n+    println!(\"{}\", offset_of!(((u8, u16), (u32, u16, u8)), 0.0));\n+    println!(\"{}\", offset_of!(((u8, u16), (u32, u16, u8)), 1.2));\n+}"}, {"sha": "e31b037ee3e01f8002201ee0e04c761dde979b70", "filename": "tests/ui/offset-of/offset-of-tuple.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1b90f5efaf46073a7da509a895a0688e1c6300c3/tests%2Fui%2Foffset-of%2Foffset-of-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b90f5efaf46073a7da509a895a0688e1c6300c3/tests%2Fui%2Foffset-of%2Foffset-of-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-tuple.rs?ref=1b90f5efaf46073a7da509a895a0688e1c6300c3", "patch": "@@ -1,10 +1,54 @@\n #![feature(offset_of)]\n #![feature(builtin_syntax)]\n \n+use std::mem::offset_of;\n+\n fn main() {\n-    core::mem::offset_of!((u8, u8), _0); //~ ERROR no field `_0`\n-    core::mem::offset_of!((u8, u8), +1); //~ ERROR no rules expected\n-    core::mem::offset_of!((u8, u8), -1); //~ ERROR no rules expected\n+    offset_of!((u8, u8), _0); //~ ERROR no field `_0`\n+    offset_of!((u8, u8), 01); //~ ERROR no field `01`\n+    offset_of!((u8, u8), 1e2); //~ ERROR no field `1e2`\n+    offset_of!((u8, u8), 1_u8); //~ ERROR no field `1_`\n+    //~| ERROR suffixes on a tuple index\n+    offset_of!((u8, u8), +1); //~ ERROR no rules expected\n+    offset_of!((u8, u8), -1); //~ ERROR no rules expected\n+    offset_of!((u8, u8), 1.); //~ ERROR expected identifier, found `)`\n+    offset_of!((u8, u8), 1 .); //~ ERROR unexpected end of macro\n+    builtin # offset_of((u8, u8), 1e2); //~ ERROR no field `1e2`\n     builtin # offset_of((u8, u8), _0); //~ ERROR no field `_0`\n-    builtin # offset_of((u8, u8), +1); //~ ERROR expected identifier\n+    builtin # offset_of((u8, u8), 01); //~ ERROR no field `01`\n+    builtin # offset_of((u8, u8), 1_u8); //~ ERROR no field `1_`\n+    //~| ERROR suffixes on a tuple index\n+    // We need to put these into curly braces, otherwise only one of the\n+    // errors will be emitted and the others suppressed.\n+    { builtin # offset_of((u8, u8), +1) }; //~ ERROR expected identifier, found `+`\n+    { builtin # offset_of((u8, u8), 1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of((u8, u8), 1 .) }; //~ ERROR expected identifier, found `)`\n+}\n+\n+type ComplexTup = ((u8, (u8, u8)), u8);\n+\n+fn nested() {\n+    offset_of!(((u8, u16), (u32, u16, u8)), 0.2); //~ ERROR no field `2`\n+    offset_of!(((u8, u16), (u32, u16, u8)), 1.2);\n+    offset_of!(((u8, u16), (u32, u16, u8)), 1.2.0); //~ ERROR no field `0`\n+\n+    // All combinations of spaces (this sends different tokens to the parser)\n+    offset_of!(ComplexTup, 0.0.1.); //~ ERROR expected identifier\n+    offset_of!(ComplexTup, 0 .0.1.); //~ ERROR unexpected end of macro\n+    offset_of!(ComplexTup, 0 . 0.1.); //~ ERROR unexpected end of macro\n+    offset_of!(ComplexTup, 0. 0.1.); //~ ERROR no rules expected\n+    offset_of!(ComplexTup, 0.0 .1.); //~ ERROR expected identifier, found `)`\n+    offset_of!(ComplexTup, 0.0 . 1.); //~ ERROR expected identifier, found `)`\n+    offset_of!(ComplexTup, 0.0. 1.); //~ ERROR expected identifier, found `)`\n+\n+    // Test for builtin too to ensure that the builtin syntax can also handle these cases\n+    // We need to put these into curly braces, otherwise only one of the\n+    // errors will be emitted and the others suppressed.\n+    { builtin # offset_of(ComplexTup, 0.0.1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0 .0.1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0 . 0.1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0. 0.1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0.0 .1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0.0 . 1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0.0. 1.) }; //~ ERROR expected identifier, found `)`\n }"}, {"sha": "954515f80a65ed3a2e090d116065aa6bd1c6950a", "filename": "tests/ui/offset-of/offset-of-tuple.stderr", "status": "modified", "additions": 218, "deletions": 14, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/1b90f5efaf46073a7da509a895a0688e1c6300c3/tests%2Fui%2Foffset-of%2Foffset-of-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b90f5efaf46073a7da509a895a0688e1c6300c3/tests%2Fui%2Foffset-of%2Foffset-of-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-tuple.stderr?ref=1b90f5efaf46073a7da509a895a0688e1c6300c3", "patch": "@@ -1,37 +1,241 @@\n+error: suffixes on a tuple index are invalid\n+  --> $DIR/offset-of-tuple.rs:19:35\n+   |\n+LL |     builtin # offset_of((u8, u8), 1_u8);\n+   |                                   ^^^^ invalid suffix `u8`\n+\n error: expected identifier, found `+`\n-  --> $DIR/offset-of-tuple.rs:9:35\n+  --> $DIR/offset-of-tuple.rs:23:37\n+   |\n+LL |     { builtin # offset_of((u8, u8), +1) };\n+   |                                     ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:24:39\n+   |\n+LL |     { builtin # offset_of((u8, u8), 1.) };\n+   |                                       ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:25:40\n+   |\n+LL |     { builtin # offset_of((u8, u8), 1 .) };\n+   |                                        ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:47:45\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0.0.1.) };\n+   |                                             ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:48:46\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0 .0.1.) };\n+   |                                              ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:49:47\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0 . 0.1.) };\n+   |                                               ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:50:46\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0. 0.1.) };\n+   |                                              ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:51:46\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0.0 .1.) };\n+   |                                              ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:52:47\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0.0 . 1.) };\n+   |                                               ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:53:46\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0.0. 1.) };\n+   |                                              ^ expected identifier\n+\n+error: suffixes on a tuple index are invalid\n+  --> $DIR/offset-of-tuple.rs:10:26\n    |\n-LL |     builtin # offset_of((u8, u8), +1);\n-   |                                   ^ expected identifier\n+LL |     offset_of!((u8, u8), 1_u8);\n+   |                          ^^^^ invalid suffix `u8`\n \n error: no rules expected the token `1`\n-  --> $DIR/offset-of-tuple.rs:6:38\n+  --> $DIR/offset-of-tuple.rs:12:27\n    |\n-LL |     core::mem::offset_of!((u8, u8), +1);\n-   |                                      ^ no rules expected this token in macro call\n+LL |     offset_of!((u8, u8), +1);\n+   |                           ^ no rules expected this token in macro call\n    |\n    = note: while trying to match sequence start\n \n error: no rules expected the token `1`\n-  --> $DIR/offset-of-tuple.rs:7:38\n+  --> $DIR/offset-of-tuple.rs:13:27\n    |\n-LL |     core::mem::offset_of!((u8, u8), -1);\n-   |                                      ^ no rules expected this token in macro call\n+LL |     offset_of!((u8, u8), -1);\n+   |                           ^ no rules expected this token in macro call\n    |\n    = note: while trying to match sequence start\n \n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:14:5\n+   |\n+LL |     offset_of!((u8, u8), 1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-tuple.rs:15:29\n+   |\n+LL |     offset_of!((u8, u8), 1 .);\n+   |                             ^ missing tokens in macro arguments\n+   |\n+note: while trying to match meta-variable `$fields:tt`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:36:5\n+   |\n+LL |     offset_of!(ComplexTup, 0.0.1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-tuple.rs:37:35\n+   |\n+LL |     offset_of!(ComplexTup, 0 .0.1.);\n+   |                                   ^ missing tokens in macro arguments\n+   |\n+note: while trying to match meta-variable `$fields:tt`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-tuple.rs:38:36\n+   |\n+LL |     offset_of!(ComplexTup, 0 . 0.1.);\n+   |                                    ^ missing tokens in macro arguments\n+   |\n+note: while trying to match meta-variable `$fields:tt`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+\n+error: no rules expected the token `0.1`\n+  --> $DIR/offset-of-tuple.rs:39:31\n+   |\n+LL |     offset_of!(ComplexTup, 0. 0.1.);\n+   |                               ^^^ no rules expected this token in macro call\n+   |\n+   = note: while trying to match sequence start\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:40:5\n+   |\n+LL |     offset_of!(ComplexTup, 0.0 .1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:41:5\n+   |\n+LL |     offset_of!(ComplexTup, 0.0 . 1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:42:5\n+   |\n+LL |     offset_of!(ComplexTup, 0.0. 1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error[E0609]: no field `_0` on type `(u8, u8)`\n-  --> $DIR/offset-of-tuple.rs:5:37\n+  --> $DIR/offset-of-tuple.rs:7:26\n    |\n-LL |     core::mem::offset_of!((u8, u8), _0);\n-   |                                     ^^\n+LL |     offset_of!((u8, u8), _0);\n+   |                          ^^\n+\n+error[E0609]: no field `01` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:8:26\n+   |\n+LL |     offset_of!((u8, u8), 01);\n+   |                          ^^\n+\n+error[E0609]: no field `1e2` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:9:26\n+   |\n+LL |     offset_of!((u8, u8), 1e2);\n+   |                          ^^^\n+\n+error[E0609]: no field `1_` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:10:26\n+   |\n+LL |     offset_of!((u8, u8), 1_u8);\n+   |                          ^^^^\n+\n+error[E0609]: no field `1e2` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:16:35\n+   |\n+LL |     builtin # offset_of((u8, u8), 1e2);\n+   |                                   ^^^\n \n error[E0609]: no field `_0` on type `(u8, u8)`\n-  --> $DIR/offset-of-tuple.rs:8:35\n+  --> $DIR/offset-of-tuple.rs:17:35\n    |\n LL |     builtin # offset_of((u8, u8), _0);\n    |                                   ^^\n \n-error: aborting due to 5 previous errors\n+error[E0609]: no field `01` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:18:35\n+   |\n+LL |     builtin # offset_of((u8, u8), 01);\n+   |                                   ^^\n+\n+error[E0609]: no field `1_` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:19:35\n+   |\n+LL |     builtin # offset_of((u8, u8), 1_u8);\n+   |                                   ^^^^\n+\n+error[E0609]: no field `2` on type `(u8, u16)`\n+  --> $DIR/offset-of-tuple.rs:31:47\n+   |\n+LL |     offset_of!(((u8, u16), (u32, u16, u8)), 0.2);\n+   |                                               ^\n+\n+error[E0609]: no field `0` on type `u8`\n+  --> $DIR/offset-of-tuple.rs:33:49\n+   |\n+LL |     offset_of!(((u8, u16), (u32, u16, u8)), 1.2.0);\n+   |                                                 ^\n+\n+error: aborting due to 33 previous errors\n \n For more information about this error, try `rustc --explain E0609`."}]}