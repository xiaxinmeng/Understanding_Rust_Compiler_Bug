{"sha": "0e2989e421b03cb38bed54705783c63e751c3c86", "node_id": "C_kwDOAAsO6NoAKDBlMjk4OWU0MjFiMDNjYjM4YmVkNTQ3MDU3ODNjNjNlNzUxYzNjODY", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2022-03-20T13:45:28Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2022-03-24T08:39:22Z"}, "message": "Support constants in const eval", "tree": {"sha": "861150f6e4a8eb4c6ea1502f97fae0f287408dbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/861150f6e4a8eb4c6ea1502f97fae0f287408dbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2989e421b03cb38bed54705783c63e751c3c86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2989e421b03cb38bed54705783c63e751c3c86", "html_url": "https://github.com/rust-lang/rust/commit/0e2989e421b03cb38bed54705783c63e751c3c86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2989e421b03cb38bed54705783c63e751c3c86/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8e1d09b90fa2d7a0b4668c83ecf6f8dff8e62d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e1d09b90fa2d7a0b4668c83ecf6f8dff8e62d8", "html_url": "https://github.com/rust-lang/rust/commit/b8e1d09b90fa2d7a0b4668c83ecf6f8dff8e62d8"}], "stats": {"total": 248, "additions": 198, "deletions": 50}, "files": [{"sha": "8c3c5fc628e9e1598775f7f2d610ce6c99537d35", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0e2989e421b03cb38bed54705783c63e751c3c86", "patch": "@@ -32,7 +32,7 @@ pub mod symbols;\n \n mod display;\n \n-use std::{collections::HashMap, iter, ops::ControlFlow, sync::Arc};\n+use std::{iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId, ProcMacroKind};\n@@ -58,6 +58,7 @@ use hir_ty::{\n     consteval::{\n         eval_const, unknown_const_as_generic, ComputedExpr, ConstEvalCtx, ConstEvalError, ConstExt,\n     },\n+    could_unify,\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n@@ -1602,20 +1603,7 @@ impl Const {\n     }\n \n     pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n-        let body = db.body(self.id.into());\n-        let root = &body.exprs[body.body_expr];\n-        let infer = db.infer_query(self.id.into());\n-        let infer = infer.as_ref();\n-        let result = eval_const(\n-            root,\n-            &mut ConstEvalCtx {\n-                exprs: &body.exprs,\n-                pats: &body.pats,\n-                local_data: HashMap::default(),\n-                infer: &mut |x| infer[x].clone(),\n-            },\n-        );\n-        result\n+        db.const_eval(self.id)\n     }\n }\n "}, {"sha": "4829482e70b49573e90514f500ee3282884f080c", "filename": "crates/hir_ty/src/consteval.rs", "status": "modified", "additions": 101, "deletions": 31, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs?ref=0e2989e421b03cb38bed54705783c63e751c3c86", "patch": "@@ -8,22 +8,20 @@ use std::{\n \n use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData, IntTy, Scalar};\n use hir_def::{\n-    expr::{ArithOp, BinaryOp, Expr, Literal, Pat},\n+    expr::{ArithOp, BinaryOp, Expr, ExprId, Literal, Pat},\n     path::ModPath,\n-    resolver::{Resolver, ValueNs},\n+    resolver::{resolver_for_expr, ResolveValueResult, Resolver, ValueNs},\n     type_ref::ConstScalar,\n+    ConstId, DefWithBodyId,\n };\n use hir_expand::name::Name;\n use la_arena::{Arena, Idx};\n use stdx::never;\n \n use crate::{\n-    db::HirDatabase,\n-    infer::{Expectation, InferenceContext},\n-    lower::ParamLoweringMode,\n-    to_placeholder_idx,\n-    utils::Generics,\n-    Const, ConstData, ConstValue, GenericArg, Interner, Ty, TyKind,\n+    db::HirDatabase, infer::InferenceContext, lower::ParamLoweringMode, to_placeholder_idx,\n+    utils::Generics, Const, ConstData, ConstValue, GenericArg, InferenceResult, Interner, Ty,\n+    TyKind,\n };\n \n /// Extension trait for [`Const`]\n@@ -55,21 +53,30 @@ impl ConstExt for Const {\n }\n \n pub struct ConstEvalCtx<'a> {\n+    pub db: &'a dyn HirDatabase,\n+    pub owner: DefWithBodyId,\n     pub exprs: &'a Arena<Expr>,\n     pub pats: &'a Arena<Pat>,\n     pub local_data: HashMap<Name, ComputedExpr>,\n-    pub infer: &'a mut dyn FnMut(Idx<Expr>) -> Ty,\n+    infer: &'a InferenceResult,\n }\n \n-#[derive(Debug, Clone)]\n+impl ConstEvalCtx<'_> {\n+    fn expr_ty(&mut self, expr: ExprId) -> Ty {\n+        self.infer[expr].clone()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ConstEvalError {\n     NotSupported(&'static str),\n-    TypeError,\n+    SemanticError(&'static str),\n+    Loop,\n     IncompleteExpr,\n     Panic(String),\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ComputedExpr {\n     Literal(Literal),\n     Tuple(Box<[ComputedExpr]>),\n@@ -143,12 +150,16 @@ fn is_valid(scalar: &Scalar, value: i128) -> bool {\n     }\n }\n \n-pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExpr, ConstEvalError> {\n+pub fn eval_const(\n+    expr_id: ExprId,\n+    ctx: &mut ConstEvalCtx<'_>,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    let expr = &ctx.exprs[expr_id];\n     match expr {\n         Expr::Literal(l) => Ok(ComputedExpr::Literal(l.clone())),\n         &Expr::UnaryOp { expr, op } => {\n-            let ty = &(ctx.infer)(expr);\n-            let ev = eval_const(&ctx.exprs[expr], ctx)?;\n+            let ty = &ctx.expr_ty(expr);\n+            let ev = eval_const(expr, ctx)?;\n             match op {\n                 hir_def::expr::UnaryOp::Deref => Err(ConstEvalError::NotSupported(\"deref\")),\n                 hir_def::expr::UnaryOp::Not => {\n@@ -203,9 +214,9 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n             }\n         }\n         &Expr::BinaryOp { lhs, rhs, op } => {\n-            let ty = &(ctx.infer)(lhs);\n-            let lhs = eval_const(&ctx.exprs[lhs], ctx)?;\n-            let rhs = eval_const(&ctx.exprs[rhs], ctx)?;\n+            let ty = &ctx.expr_ty(lhs);\n+            let lhs = eval_const(lhs, ctx)?;\n+            let rhs = eval_const(rhs, ctx)?;\n             let op = op.ok_or(ConstEvalError::IncompleteExpr)?;\n             let v1 = match lhs {\n                 ComputedExpr::Literal(Literal::Int(v, _)) => v,\n@@ -249,7 +260,7 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n                     }\n                     Ok(ComputedExpr::Literal(Literal::Int(r, None)))\n                 }\n-                BinaryOp::LogicOp(_) => Err(ConstEvalError::TypeError),\n+                BinaryOp::LogicOp(_) => Err(ConstEvalError::SemanticError(\"logic op on numbers\")),\n                 _ => Err(ConstEvalError::NotSupported(\"bin op on this operators\")),\n             }\n         }\n@@ -266,7 +277,7 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n                             }\n                         };\n                         let value = match initializer {\n-                            Some(x) => eval_const(&ctx.exprs[x], ctx)?,\n+                            Some(x) => eval_const(x, ctx)?,\n                             None => continue,\n                         };\n                         if !prev_values.contains_key(&name) {\n@@ -282,7 +293,7 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n                 }\n             }\n             let r = match tail {\n-                &Some(x) => eval_const(&ctx.exprs[x], ctx),\n+                &Some(x) => eval_const(x, ctx),\n                 None => Ok(ComputedExpr::Tuple(Box::new([]))),\n             };\n             // clean up local data, so caller will receive the exact map that passed to us\n@@ -295,19 +306,47 @@ pub fn eval_const(expr: &Expr, ctx: &mut ConstEvalCtx<'_>) -> Result<ComputedExp\n             r\n         }\n         Expr::Path(p) => {\n-            let name = p.mod_path().as_ident().ok_or(ConstEvalError::NotSupported(\"big paths\"))?;\n-            let r = ctx\n-                .local_data\n-                .get(name)\n-                .ok_or(ConstEvalError::NotSupported(\"Non local name resolution\"))?;\n-            Ok(r.clone())\n+            let resolver = resolver_for_expr(ctx.db.upcast(), ctx.owner, expr_id);\n+            let pr = resolver\n+                .resolve_path_in_value_ns(ctx.db.upcast(), p.mod_path())\n+                .ok_or(ConstEvalError::SemanticError(\"unresolved path\"))?;\n+            let pr = match pr {\n+                ResolveValueResult::ValueNs(v) => v,\n+                ResolveValueResult::Partial(..) => {\n+                    return match ctx\n+                        .infer\n+                        .assoc_resolutions_for_expr(expr_id)\n+                        .ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n+                    {\n+                        hir_def::AssocItemId::FunctionId(_) => {\n+                            Err(ConstEvalError::NotSupported(\"assoc function\"))\n+                        }\n+                        hir_def::AssocItemId::ConstId(c) => ctx.db.const_eval(c),\n+                        hir_def::AssocItemId::TypeAliasId(_) => {\n+                            Err(ConstEvalError::NotSupported(\"assoc type alias\"))\n+                        }\n+                    }\n+                }\n+            };\n+            match pr {\n+                ValueNs::LocalBinding(_) => {\n+                    let name =\n+                        p.mod_path().as_ident().ok_or(ConstEvalError::NotSupported(\"big paths\"))?;\n+                    let r = ctx\n+                        .local_data\n+                        .get(name)\n+                        .ok_or(ConstEvalError::NotSupported(\"Unexpected missing local\"))?;\n+                    Ok(r.clone())\n+                }\n+                ValueNs::ConstId(id) => ctx.db.const_eval(id),\n+                _ => Err(ConstEvalError::NotSupported(\"path that are not const or local\")),\n+            }\n         }\n         _ => Err(ConstEvalError::NotSupported(\"This kind of expression\")),\n     }\n }\n \n pub fn eval_usize(expr: Idx<Expr>, mut ctx: ConstEvalCtx<'_>) -> Option<u64> {\n-    let expr = &ctx.exprs[expr];\n     if let Ok(ce) = eval_const(expr, &mut ctx) {\n         match ce {\n             ComputedExpr::Literal(Literal::Int(x, _)) => return x.try_into().ok(),\n@@ -380,10 +419,39 @@ pub fn usize_const(value: Option<u64>) -> Const {\n     .intern(Interner)\n }\n \n-pub(crate) fn eval_to_const(\n+pub(crate) fn const_eval_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &ConstId,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    Err(ConstEvalError::Loop)\n+}\n+\n+pub(crate) fn const_eval_query(\n+    db: &dyn HirDatabase,\n+    const_id: ConstId,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    let def = const_id.into();\n+    let body = db.body(def);\n+    let mut infer = db.infer_query(def);\n+    let result = eval_const(\n+        body.body_expr,\n+        &mut ConstEvalCtx {\n+            db,\n+            owner: const_id.into(),\n+            exprs: &body.exprs,\n+            pats: &body.pats,\n+            local_data: HashMap::default(),\n+            infer: &mut infer,\n+        },\n+    );\n+    result\n+}\n+\n+pub(crate) fn eval_to_const<'a>(\n     expr: Idx<Expr>,\n     mode: ParamLoweringMode,\n-    ctx: &mut InferenceContext,\n+    ctx: &mut InferenceContext<'a>,\n     args: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n ) -> Const {\n@@ -396,10 +464,12 @@ pub(crate) fn eval_to_const(\n     }\n     let body = ctx.body.clone();\n     let ctx = ConstEvalCtx {\n+        db: ctx.db,\n+        owner: ctx.owner,\n         exprs: &body.exprs,\n         pats: &body.pats,\n         local_data: HashMap::default(),\n-        infer: &mut |x| ctx.infer_expr(x, &Expectation::None),\n+        infer: &ctx.result,\n     };\n     usize_const(eval_usize(expr, ctx))\n }"}, {"sha": "467dcfa33ea757f1e2695a75fbf7c381f3fd81c9", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=0e2989e421b03cb38bed54705783c63e751c3c86", "patch": "@@ -5,13 +5,14 @@ use std::sync::Arc;\n \n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase, expr::ExprId, BlockId, ConstParamId, DefWithBodyId, FunctionId, GenericDefId,\n-    ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n+    db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, FunctionId,\n+    GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n \n use crate::{\n     chalk_db,\n+    consteval::{ComputedExpr, ConstEvalError},\n     method_resolution::{InherentImpls, TraitImpls},\n     Binders, CallableDefId, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n     QuantifiedWhereClause, ReturnTypeImplTraits, TraitRef, Ty, TyDefId, ValueTyDefId,\n@@ -41,6 +42,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::const_param_ty_query)]\n     fn const_param_ty(&self, def: ConstParamId) -> Ty;\n \n+    #[salsa::invoke(crate::consteval::const_eval_query)]\n+    #[salsa::cycle(crate::consteval::const_eval_recover)]\n+    fn const_eval(&self, def: ConstId) -> Result<ComputedExpr, ConstEvalError>;\n+\n     #[salsa::invoke(crate::lower::impl_trait_query)]\n     fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;\n "}, {"sha": "9a6795a1c883695a2ea7246949a829c3166ebced", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=0e2989e421b03cb38bed54705783c63e751c3c86", "patch": "@@ -358,12 +358,12 @@ impl Index<PatId> for InferenceResult {\n #[derive(Clone, Debug)]\n pub(crate) struct InferenceContext<'a> {\n     pub(crate) db: &'a dyn HirDatabase,\n-    owner: DefWithBodyId,\n+    pub(crate) owner: DefWithBodyId,\n     pub(crate) body: Arc<Body>,\n     pub(crate) resolver: Resolver,\n     table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n-    result: InferenceResult,\n+    pub(crate) result: InferenceResult,\n     /// The return type of the function being inferred, the closure or async block if we're\n     /// currently within one.\n     ///"}, {"sha": "987e5d15564941880fd866735094933dbb41ef13", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2989e421b03cb38bed54705783c63e751c3c86/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=0e2989e421b03cb38bed54705783c63e751c3c86", "patch": "@@ -3399,6 +3399,7 @@ impl<const LEN: usize> Foo<LEN$0> {}\n     );\n }\n \n+// FIXME: move these tests to consteval module\n #[test]\n fn hover_const_eval() {\n     check(\n@@ -3577,6 +3578,90 @@ const FOO$0: &str = \"bar\";\n             This is a doc\n         \"#]],\n     );\n+    check(\n+        r#\"\n+const F1: i32 = 1;\n+const F$03: i32 = 3 * F2;\n+const F2: i32 = 2 * F1;\n+\"#,\n+        expect![[r#\"\n+            *F3*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const F3: i32 = 6\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+const F1: i32 = 1 * F3;\n+const F2: i32 = 2 * F1;\n+const F$03: i32 = 3 * F2;\n+\"#,\n+        expect![[r#\"\n+            *F3*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const F3: i32 = 3 * F2\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+struct U5;\n+impl U5 {\n+    const VAL: usize = 5;\n+}\n+const X$0X: usize = U5::VAL;\n+\"#,\n+        expect![[r#\"\n+            *XX*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const XX: usize = 5\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+// FIXME: this should evaluate to zero\n+#[test]\n+fn hover_const_eval_broken() {\n+    check(\n+        r#\"\n+struct U0;\n+trait ToConst {\n+    const VAL: usize;\n+}\n+impl ToConst for U0 {\n+    const VAL: usize = 0;\n+}\n+const X$0X: usize = U0::VAL;\n+\"#,\n+        expect![[r#\"\n+            *XX*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const XX: usize = U0::VAL\n+            ```\n+        \"#]],\n+    );\n }\n \n #[test]"}]}