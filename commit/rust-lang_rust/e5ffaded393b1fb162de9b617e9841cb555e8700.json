{"sha": "e5ffaded393b1fb162de9b617e9841cb555e8700", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZmZhZGVkMzkzYjFmYjE2MmRlOWI2MTdlOTg0MWNiNTU1ZTg3MDA=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-07T01:51:53Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-07T13:59:49Z"}, "message": "Avoid some `pat_to_string` calls.\n\n`ty_of_method_or_bare_fn` currently calls `pat_to_string` even when it\ndoesn't need to. Fixing this avoids hundreds of large allocations (e.g.\n171,600 bytes, in `mk_printer`) in several of the rustc-benchmarks.", "tree": {"sha": "50701cf9817657b4b0ef18ed108f9095ccd3054a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50701cf9817657b4b0ef18ed108f9095ccd3054a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5ffaded393b1fb162de9b617e9841cb555e8700", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5ffaded393b1fb162de9b617e9841cb555e8700", "html_url": "https://github.com/rust-lang/rust/commit/e5ffaded393b1fb162de9b617e9841cb555e8700", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5ffaded393b1fb162de9b617e9841cb555e8700/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5dac7a2af3ee444817eb7bfbba3539be8c06cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5dac7a2af3ee444817eb7bfbba3539be8c06cf1", "html_url": "https://github.com/rust-lang/rust/commit/a5dac7a2af3ee444817eb7bfbba3539be8c06cf1"}], "stats": {"total": 35, "additions": 26, "deletions": 9}, "files": [{"sha": "eebb5c6af6f087f06d43f3281b0476e1652fa3eb", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e5ffaded393b1fb162de9b617e9841cb555e8700/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ffaded393b1fb162de9b617e9841cb555e8700/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e5ffaded393b1fb162de9b617e9841cb555e8700", "patch": "@@ -561,15 +561,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// Returns the appropriate lifetime to use for any output lifetimes\n     /// (if one exists) and a vector of the (pattern, number of lifetimes)\n     /// corresponding to each input type/pattern.\n-    fn find_implied_output_region(&self,\n-                                  input_tys: &[Ty<'tcx>],\n-                                  input_pats: Vec<String>) -> ElidedLifetime\n+    fn find_implied_output_region<F>(&self,\n+                                     input_tys: &[Ty<'tcx>],\n+                                     input_pats: F) -> ElidedLifetime\n+        where F: FnOnce() -> Vec<String>\n     {\n         let tcx = self.tcx();\n         let mut lifetimes_for_params = Vec::new();\n         let mut possible_implied_output_region = None;\n \n-        for (input_type, input_pat) in input_tys.iter().zip(input_pats) {\n+        for input_type in input_tys.iter() {\n             let mut regions = FnvHashSet();\n             let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n \n@@ -583,8 +584,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 possible_implied_output_region = regions.iter().cloned().next();\n             }\n \n+            // Use a placeholder for `name` because computing it can be\n+            // expensive and we don't want to do it until we know it's\n+            // necessary.\n             lifetimes_for_params.push(ElisionFailureInfo {\n-                name: input_pat,\n+                name: String::new(),\n                 lifetime_count: regions.len(),\n                 have_bound_regions: have_bound_regions\n             });\n@@ -593,6 +597,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         if lifetimes_for_params.iter().map(|e| e.lifetime_count).sum::<usize>() == 1 {\n             Ok(*possible_implied_output_region.unwrap())\n         } else {\n+            // Fill in the expensive `name` fields now that we know they're\n+            // needed.\n+            for (info, input_pat) in lifetimes_for_params.iter_mut().zip(input_pats()) {\n+                info.name = input_pat;\n+            }\n             Err(Some(lifetimes_for_params))\n         }\n     }\n@@ -629,7 +638,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let inputs: Vec<_> = data.inputs.iter().map(|a_t| {\n             self.ast_ty_arg_to_ty(&binding_rscope, None, region_substs, a_t)\n         }).collect();\n-        let input_params = vec![String::new(); inputs.len()];\n+        let inputs_len = inputs.len();\n+        let input_params = || vec![String::new(); inputs_len];\n         let implied_output_region = self.find_implied_output_region(&inputs, input_params);\n \n         let (output, output_span) = match data.output {\n@@ -1861,15 +1871,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n         let arg_tys: Vec<Ty> =\n             arg_params.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n-        let arg_pats: Vec<String> =\n-            arg_params.iter().map(|a| pprust::pat_to_string(&a.pat)).collect();\n \n         // Second, if there was exactly one lifetime (either a substitution or a\n         // reference) in the arguments, then any anonymous regions in the output\n         // have that lifetime.\n         let implied_output_region = match explicit_self_category {\n             ty::ExplicitSelfCategory::ByReference(region, _) => Ok(*region),\n-            _ => self.find_implied_output_region(&arg_tys, arg_pats)\n+            _ => {\n+                // `pat_to_string` is expensive and\n+                // `find_implied_output_region` only needs its result when\n+                // there's an error. So we wrap it in a closure to avoid\n+                // calling it until necessary.\n+                let arg_pats = || {\n+                    arg_params.iter().map(|a| pprust::pat_to_string(&a.pat)).collect()\n+                };\n+                self.find_implied_output_region(&arg_tys, arg_pats)\n+            }\n         };\n \n         let output_ty = match decl.output {"}]}