{"sha": "67ba6dcf68860d8a20891faad88a33b35ed58df5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3YmE2ZGNmNjg4NjBkOGEyMDg5MWZhYWQ4OGEzM2IzNWVkNThkZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-09T14:56:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-09T14:56:56Z"}, "message": "Auto merge of #24612 - lifthrasiir:flt2dec, r=pnkfelix\n\nThis is a direct port of my prior work on the float formatting. The detailed description is available [here](https://github.com/lifthrasiir/rust-strconv#flt2dec). In brief,\r\n\r\n* This adds a new hidden module `core::num::flt2dec` for testing from `libcoretest`. Why is it in `core::num` instead of `core::fmt`? Because I envision that the table used by `flt2dec` is directly applicable to `dec2flt` (cf. #24557) as well, which exceeds the realm of \"formatting\".\r\n* This contains both Dragon4 algorithm (exact, complete but slow) and Grisu3 algorithm (exact, fast but incomplete).\r\n* The code is accompanied with a large amount of self-tests and some exhaustive tests. In particular, `libcoretest` gets a new dependency on `librand`. For the external interface it relies on the existing test suite.\r\n* It is known that, in the best case, the entire formatting code has about 30 KBs of binary overhead (judged from strconv experiments). Not too bad but there might be a potential room for improvements.\r\n\r\nThis is rather large code. I did my best to comment and annotate the code, but you have been warned.\r\n\r\nFor the maximal availability the original code was licensed in CC0, but I've also dual-licensed it in MIT/Apache as well so there should be no licensing concern.\r\n\r\nThis is [breaking-change] as it changes the float output slightly (and it also affects the casing of `inf` and `nan`). I hope this is not a big deal though :)\r\n\r\nFixes #7030, #18038 and #24556. Also related to #6220 and #20870.\r\n\r\n## Known Issues\r\n\r\n- [x] I've yet to finish `make check-stage1`. It does pass main test suites including `run-pass` but there might be some unknown edges on the doctests.\r\n- [ ] Figure out how this PR affects rustc.\r\n- [ ] Determine which internal routine is mapped to the formatting specifier. Depending on the decision, some internal routine can be safely removed (for instance, currently `to_shortest_str` is unused).", "tree": {"sha": "1793c023e25949a282b8a95ba1ef090070c97a19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1793c023e25949a282b8a95ba1ef090070c97a19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67ba6dcf68860d8a20891faad88a33b35ed58df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67ba6dcf68860d8a20891faad88a33b35ed58df5", "html_url": "https://github.com/rust-lang/rust/commit/67ba6dcf68860d8a20891faad88a33b35ed58df5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67ba6dcf68860d8a20891faad88a33b35ed58df5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497942332f919b1a952310a730349ca1b9524968", "url": "https://api.github.com/repos/rust-lang/rust/commits/497942332f919b1a952310a730349ca1b9524968", "html_url": "https://github.com/rust-lang/rust/commit/497942332f919b1a952310a730349ca1b9524968"}, {"sha": "1aecd17463bb16d03462cf31edb920b9f47ddf2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aecd17463bb16d03462cf31edb920b9f47ddf2c", "html_url": "https://github.com/rust-lang/rust/commit/1aecd17463bb16d03462cf31edb920b9f47ddf2c"}], "stats": {"total": 4388, "additions": 4054, "deletions": 334}, "files": [{"sha": "4b75bd5f67e3d94fd7d07b23a19c4567e0ade186", "filename": "src/libcore/fmt/float.rs", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/497942332f919b1a952310a730349ca1b9524968/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497942332f919b1a952310a730349ca1b9524968/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=497942332f919b1a952310a730349ca1b9524968", "patch": "@@ -1,289 +0,0 @@\n-// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::ExponentFormat::*;\n-pub use self::SignificantDigits::*;\n-\n-use prelude::*;\n-\n-use char;\n-use fmt;\n-use num::Float;\n-use num::FpCategory as Fp;\n-use ops::{Div, Rem, Mul};\n-use slice;\n-use str;\n-\n-/// A flag that specifies whether to use exponential (scientific) notation.\n-pub enum ExponentFormat {\n-    /// Do not use exponential notation.\n-    ExpNone,\n-    /// Use exponential notation with the exponent having a base of 10 and the\n-    /// exponent sign being `e` or `E`. For example, 1000 would be printed\n-    /// 1e3.\n-    ExpDec\n-}\n-\n-/// The number of digits used for emitting the fractional part of a number, if\n-/// any.\n-pub enum SignificantDigits {\n-    /// At most the given number of digits will be printed, truncating any\n-    /// trailing zeroes.\n-    DigMax(usize),\n-\n-    /// Precisely the given number of digits will be printed.\n-    DigExact(usize)\n-}\n-\n-#[doc(hidden)]\n-pub trait MyFloat: Float + PartialEq + PartialOrd + Div<Output=Self> +\n-                   Mul<Output=Self> + Rem<Output=Self> + Copy {\n-    fn from_u32(u: u32) -> Self;\n-    fn to_i32(&self) -> i32;\n-}\n-\n-macro_rules! doit {\n-    ($($t:ident)*) => ($(impl MyFloat for $t {\n-        fn from_u32(u: u32) -> $t { u as $t }\n-        fn to_i32(&self) -> i32 { *self as i32 }\n-    })*)\n-}\n-doit! { f32 f64 }\n-\n-/// Converts a float number to its string representation.\n-/// This is meant to be a common base implementation for various formatting styles.\n-/// The number is assumed to be non-negative, callers use `Formatter::pad_integral`\n-/// to add the right sign, if any.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert (non-negative). Accepts any number that\n-///                     implements the numeric traits.\n-/// - `digits`        - The amount of digits to use for emitting the fractional\n-///                     part, if any. See `SignificantDigits`.\n-/// - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n-///                    See `ExponentFormat`.\n-/// - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n-///                     exponential notation is desired.\n-/// - `f`             - A closure to invoke with the string representing the\n-///                     float.\n-///\n-/// # Panics\n-///\n-/// - Panics if `num` is negative.\n-pub fn float_to_str_bytes_common<T: MyFloat, U, F>(\n-    num: T,\n-    digits: SignificantDigits,\n-    exp_format: ExponentFormat,\n-    exp_upper: bool,\n-    f: F\n-) -> U where\n-    F: FnOnce(&str) -> U,\n-{\n-    let _0: T = T::zero();\n-    let _1: T = T::one();\n-    let radix: u32 = 10;\n-    let radix_f = T::from_u32(radix);\n-\n-    assert!(num.is_nan() || num >= _0, \"float_to_str_bytes_common: number is negative\");\n-\n-    match num.classify() {\n-        Fp::Nan => return f(\"NaN\"),\n-        Fp::Infinite if num > _0 => {\n-            return f(\"inf\");\n-        }\n-        Fp::Infinite if num < _0 => {\n-            return f(\"-inf\");\n-        }\n-        _ => {}\n-    }\n-\n-    // For an f64 the (decimal) exponent is roughly in the range of [-307, 308], so\n-    // we may have up to that many digits. We err on the side of caution and\n-    // add 50% extra wiggle room.\n-    let mut buf = [0; 462];\n-    let mut end = 0;\n-\n-    let (num, exp) = match exp_format {\n-        ExpDec if num != _0 => {\n-            let exp = num.log10().floor();\n-            (num / radix_f.powf(exp), exp.to_i32())\n-        }\n-        _ => (num, 0)\n-    };\n-\n-    // First emit the non-fractional part, looping at least once to make\n-    // sure at least a `0` gets emitted.\n-    let mut deccum = num.trunc();\n-    loop {\n-        let current_digit = deccum % radix_f;\n-\n-        // Decrease the deccumulator one digit at a time\n-        deccum = deccum / radix_f;\n-        deccum = deccum.trunc();\n-\n-        let c = char::from_digit(current_digit.to_i32() as u32, radix);\n-        buf[end] = c.unwrap() as u8;\n-        end += 1;\n-\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // If limited digits, calculate one digit more for rounding.\n-    let (limit_digits, digit_count, exact) = match digits {\n-        DigMax(count)   => (true, count + 1, false),\n-        DigExact(count) => (true, count + 1, true)\n-    };\n-\n-    buf[..end].reverse();\n-\n-    // Remember start of the fractional digits.\n-    // Points one beyond end of buf if none get generated,\n-    // or at the '.' otherwise.\n-    let start_fractional_digits = end;\n-\n-    // Now emit the fractional part, if any\n-    deccum = num.fract();\n-    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf[end] = b'.';\n-        end += 1;\n-        let mut dig = 0;\n-\n-        // calculate new digits while\n-        // - there is no limit and there are digits left\n-        // - or there is a limit, it's not reached yet and\n-        //   - it's exact\n-        //   - or it's a maximum, and there are still digits left\n-        while (!limit_digits && deccum != _0)\n-           || (limit_digits && dig < digit_count && (\n-                   exact\n-                || (!exact && deccum != _0)\n-              )\n-        ) {\n-            // Shift first fractional digit into the integer part\n-            deccum = deccum * radix_f;\n-\n-            let current_digit = deccum.trunc();\n-\n-            let c = char::from_digit(current_digit.to_i32() as u32, radix);\n-            buf[end] = c.unwrap() as u8;\n-            end += 1;\n-\n-            // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fract();\n-            dig += 1;\n-        }\n-\n-        // If digits are limited, and that limit has been reached,\n-        // cut off the one extra digit, and depending on its value\n-        // round the remaining ones.\n-        if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n-                (chr as char).to_digit(radix).unwrap()\n-            };\n-            let value2ascii = |val: u32| {\n-                char::from_digit(val, radix).unwrap() as u8\n-            };\n-\n-            let extra_digit = ascii2value(buf[end - 1]);\n-            end -= 1;\n-            if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: isize = end as isize - 1;\n-                loop {\n-                    // If reached left end of number, have to\n-                    // insert additional digit:\n-                    if i < 0\n-                    || buf[i as usize] == b'-'\n-                    || buf[i as usize] == b'+' {\n-                        for j in ((i + 1) as usize..end).rev() {\n-                            buf[j + 1] = buf[j];\n-                        }\n-                        buf[(i + 1) as usize] = value2ascii(1);\n-                        end += 1;\n-                        break;\n-                    }\n-\n-                    // Skip the '.'\n-                    if buf[i as usize] == b'.' { i -= 1; continue; }\n-\n-                    // Either increment the digit,\n-                    // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as usize]);\n-                    if current_digit < (radix - 1) {\n-                        buf[i as usize] = value2ascii(current_digit+1);\n-                        break;\n-                    } else {\n-                        buf[i as usize] = value2ascii(0);\n-                        i -= 1;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // if number of digits is not exact, remove all trailing '0's up to\n-    // and including the '.'\n-    if !exact {\n-        let buf_max_i = end - 1;\n-\n-        // index to truncate from\n-        let mut i = buf_max_i;\n-\n-        // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == b'0' {\n-            i -= 1;\n-        }\n-\n-        // Only attempt to truncate digits if buf has fractional digits\n-        if i >= start_fractional_digits {\n-            // If buf ends with '.', cut that too.\n-            if buf[i] == b'.' { i -= 1 }\n-\n-            // only resize buf if we actually remove digits\n-            if i < buf_max_i {\n-                end = i + 1;\n-            }\n-        }\n-    } // If exact and trailing '.', just cut that\n-    else {\n-        let max_i = end - 1;\n-        if buf[max_i] == b'.' {\n-            end = max_i;\n-        }\n-    }\n-\n-    match exp_format {\n-        ExpNone => {},\n-        ExpDec => {\n-            buf[end] = if exp_upper { b'E' } else { b'e' };\n-            end += 1;\n-\n-            struct Filler<'a> {\n-                buf: &'a mut [u8],\n-                end: &'a mut usize,\n-            }\n-\n-            impl<'a> fmt::Write for Filler<'a> {\n-                fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    slice::bytes::copy_memory(s.as_bytes(),\n-                                              &mut self.buf[(*self.end)..]);\n-                    *self.end += s.len();\n-                    Ok(())\n-                }\n-            }\n-\n-            let mut filler = Filler { buf: &mut buf, end: &mut end };\n-            let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n-        }\n-    }\n-\n-    f(unsafe { str::from_utf8_unchecked(&buf[..end]) })\n-}"}, {"sha": "a87f6619fe8772e7e36127d9b06f705856e0e8ac", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 125, "deletions": 43, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -17,9 +17,9 @@ use prelude::*;\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use marker::PhantomData;\n use mem;\n+use num::flt2dec;\n use ops::Deref;\n use result;\n-use num::Float;\n use slice;\n use str;\n use self::rt::v1::Alignment;\n@@ -31,7 +31,6 @@ pub use self::num::RadixFmt;\n pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n \n mod num;\n-mod float;\n mod builders;\n \n #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n@@ -604,6 +603,83 @@ impl<'a> Formatter<'a> {\n         Ok(())\n     }\n \n+    /// Takes the formatted parts and applies the padding.\n+    /// Assumes that the caller already has rendered the parts with required precision,\n+    /// so that `self.precision` can be ignored.\n+    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n+        if let Some(mut width) = self.width {\n+            // for the sign-aware zero padding, we render the sign first and\n+            // behave as if we had no sign from the beginning.\n+            let mut formatted = formatted.clone();\n+            let mut align = self.align;\n+            let old_fill = self.fill;\n+            if self.flags & (1 << (FlagV1::SignAwareZeroPad as u32)) != 0 {\n+                // a sign always goes first\n+                let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n+                try!(self.buf.write_str(sign));\n+\n+                // remove the sign from the formatted parts\n+                formatted.sign = b\"\";\n+                width = if width < sign.len() { 0 } else { width - sign.len() };\n+                align = Alignment::Right;\n+                self.fill = '0';\n+            }\n+\n+            // remaining parts go through the ordinary padding process.\n+            let len = formatted.len();\n+            let ret = if width <= len { // no padding\n+                self.write_formatted_parts(&formatted)\n+            } else {\n+                self.with_padding(width - len, align, |f| {\n+                    f.write_formatted_parts(&formatted)\n+                })\n+            };\n+            self.fill = old_fill;\n+            ret\n+        } else {\n+            // this is the common case and we take a shortcut\n+            self.write_formatted_parts(formatted)\n+        }\n+    }\n+\n+    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n+        fn write_bytes(buf: &mut Write, s: &[u8]) -> Result {\n+            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n+        }\n+\n+        if !formatted.sign.is_empty() {\n+            try!(write_bytes(self.buf, formatted.sign));\n+        }\n+        for part in formatted.parts {\n+            match *part {\n+                flt2dec::Part::Zero(mut nzeroes) => {\n+                    const ZEROES: &'static str = // 64 zeroes\n+                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n+                    while nzeroes > ZEROES.len() {\n+                        try!(self.buf.write_str(ZEROES));\n+                        nzeroes -= ZEROES.len();\n+                    }\n+                    if nzeroes > 0 {\n+                        try!(self.buf.write_str(&ZEROES[..nzeroes]));\n+                    }\n+                }\n+                flt2dec::Part::Num(mut v) => {\n+                    let mut s = [0; 5];\n+                    let len = part.len();\n+                    for c in s[..len].iter_mut().rev() {\n+                        *c = b'0' + (v % 10) as u8;\n+                        v /= 10;\n+                    }\n+                    try!(write_bytes(self.buf, &s[..len]));\n+                }\n+                flt2dec::Part::Copy(buf) => {\n+                    try!(write_bytes(self.buf, buf));\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -918,73 +994,79 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_str_common<T: float::MyFloat, F>(num: &T, precision: Option<usize>,\n-                                             post: F) -> Result\n-        where F : FnOnce(&str) -> Result {\n-    let digits = match precision {\n-        Some(i) => float::DigExact(i),\n-        None => float::DigMax(6),\n+fn float_to_decimal_common<T>(fmt: &mut Formatter, num: &T, negative_zero: bool) -> Result\n+    where T: flt2dec::DecodableFloat\n+{\n+    let force_sign = fmt.flags & (1 << (FlagV1::SignPlus as u32)) != 0;\n+    let sign = match (force_sign, negative_zero) {\n+        (false, false) => flt2dec::Sign::Minus,\n+        (false, true)  => flt2dec::Sign::MinusRaw,\n+        (true,  false) => flt2dec::Sign::MinusPlus,\n+        (true,  true)  => flt2dec::Sign::MinusPlusRaw,\n+    };\n+\n+    let mut buf = [0; 1024]; // enough for f32 and f64\n+    let mut parts = [flt2dec::Part::Zero(0); 16];\n+    let formatted = if let Some(precision) = fmt.precision {\n+        flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n+                                    precision, false, &mut buf, &mut parts)\n+    } else {\n+        flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n+                                 0, false, &mut buf, &mut parts)\n+    };\n+    fmt.pad_formatted_parts(&formatted)\n+}\n+\n+// Common code of floating point LowerExp and UpperExp.\n+fn float_to_exponential_common<T>(fmt: &mut Formatter, num: &T, upper: bool) -> Result\n+    where T: flt2dec::DecodableFloat\n+{\n+    let force_sign = fmt.flags & (1 << (FlagV1::SignPlus as u32)) != 0;\n+    let sign = match force_sign {\n+        false => flt2dec::Sign::Minus,\n+        true  => flt2dec::Sign::MinusPlus,\n     };\n-    float::float_to_str_bytes_common(num.abs(),\n-                                     digits,\n-                                     float::ExpNone,\n-                                     false,\n-                                     post)\n+\n+    let mut buf = [0; 1024]; // enough for f32 and f64\n+    let mut parts = [flt2dec::Part::Zero(0); 16];\n+    let formatted = if let Some(precision) = fmt.precision {\n+        // 1 integral digit + `precision` fractional digits = `precision + 1` total digits\n+        flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n+                                  precision + 1, upper, &mut buf, &mut parts)\n+    } else {\n+        flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n+                                     (0, 0), upper, &mut buf, &mut parts)\n+    };\n+    fmt.pad_formatted_parts(&formatted)\n }\n \n macro_rules! floating { ($ty:ident) => {\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Debug for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_str_common(self, fmt.precision, |absolute| {\n-                // is_positive() counts -0.0 as negative\n-                fmt.pad_integral(self.is_nan() || self.is_positive(), \"\", absolute)\n-            })\n+            float_to_decimal_common(fmt, self, true)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Display for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_str_common(self, fmt.precision, |absolute| {\n-                // simple comparison counts -0.0 as positive\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", absolute)\n-            })\n+            float_to_decimal_common(fmt, self, false)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            let digits = match fmt.precision {\n-                Some(i) => float::DigExact(i),\n-                None => float::DigMax(6),\n-            };\n-            float::float_to_str_bytes_common(self.abs(),\n-                                             digits,\n-                                             float::ExpDec,\n-                                             false,\n-                                             |bytes| {\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", bytes)\n-            })\n+            float_to_exponential_common(fmt, self, false)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            let digits = match fmt.precision {\n-                Some(i) => float::DigExact(i),\n-                None => float::DigMax(6),\n-            };\n-            float::float_to_str_bytes_common(self.abs(),\n-                                             digits,\n-                                             float::ExpDec,\n-                                             true,\n-                                             |bytes| {\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", bytes)\n-            })\n+            float_to_exponential_common(fmt, self, true)\n         }\n     }\n } }"}, {"sha": "d6a5e44a1fb00372681874471c27fe5abc034d15", "filename": "src/libcore/num/flt2dec/bignum.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,357 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Custom arbitrary-precision number (bignum) implementation.\n+//!\n+//! This is designed to avoid the heap allocation at expense of stack memory.\n+//! The most used bignum type, `Big32x36`, is limited by 32 \u00d7 36 = 1,152 bits\n+//! and will take at most 152 bytes of stack memory. This is (barely) enough\n+//! for handling all possible finite `f64` values.\n+//!\n+//! In principle it is possible to have multiple bignum types for different\n+//! inputs, but we don't do so to avoid the code bloat. Each bignum is still\n+//! tracked for the actual usages, so it normally doesn't matter.\n+\n+#![macro_use]\n+\n+use prelude::*;\n+use mem;\n+use intrinsics;\n+\n+/// Arithmetic operations required by bignums.\n+pub trait FullOps {\n+    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n+    /// where `W` is the number of bits in `Self`.\n+    fn full_add(self, other: Self, carry: bool) -> (bool /*carry*/, Self);\n+\n+    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n+    /// where `W` is the number of bits in `Self`.\n+    fn full_mul(self, other: Self, carry: Self) -> (Self /*carry*/, Self);\n+\n+    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n+    /// where `W` is the number of bits in `Self`.\n+    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /*carry*/, Self);\n+\n+    /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n+    /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n+    fn full_div_rem(self, other: Self, borrow: Self) -> (Self /*quotient*/, Self /*remainder*/);\n+}\n+\n+macro_rules! impl_full_ops {\n+    ($($ty:ty: add($addfn:path), mul/div($bigty:ident);)*) => (\n+        $(\n+            impl FullOps for $ty {\n+                fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n+                    // this cannot overflow, the output is between 0 and 2*2^nbits - 1\n+                    // FIXME will LLVM optimize this into ADC or similar???\n+                    let (v, carry1) = unsafe { $addfn(self, other) };\n+                    let (v, carry2) = unsafe { $addfn(v, if carry {1} else {0}) };\n+                    (carry1 || carry2, v)\n+                }\n+\n+                fn full_mul(self, other: $ty, carry: $ty) -> ($ty, $ty) {\n+                    // this cannot overflow, the output is between 0 and 2^nbits * (2^nbits - 1)\n+                    let nbits = mem::size_of::<$ty>() * 8;\n+                    let v = (self as $bigty) * (other as $bigty) + (carry as $bigty);\n+                    ((v >> nbits) as $ty, v as $ty)\n+                }\n+\n+                fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n+                    // this cannot overflow, the output is between 0 and 2^(2*nbits) - 1\n+                    let nbits = mem::size_of::<$ty>() * 8;\n+                    let v = (self as $bigty) * (other as $bigty) + (other2 as $bigty) +\n+                            (carry as $bigty);\n+                    ((v >> nbits) as $ty, v as $ty)\n+                }\n+\n+                fn full_div_rem(self, other: $ty, borrow: $ty) -> ($ty, $ty) {\n+                    debug_assert!(borrow < other);\n+                    // this cannot overflow, the dividend is between 0 and other * 2^nbits - 1\n+                    let nbits = mem::size_of::<$ty>() * 8;\n+                    let lhs = ((borrow as $bigty) << nbits) | (self as $bigty);\n+                    let rhs = other as $bigty;\n+                    ((lhs / rhs) as $ty, (lhs % rhs) as $ty)\n+                }\n+            }\n+        )*\n+    )\n+}\n+\n+impl_full_ops! {\n+    u8:  add(intrinsics::u8_add_with_overflow),  mul/div(u16);\n+    u16: add(intrinsics::u16_add_with_overflow), mul/div(u32);\n+    u32: add(intrinsics::u32_add_with_overflow), mul/div(u64);\n+//  u64: add(intrinsics::u64_add_with_overflow), mul/div(u128); // see RFC #521 for enabling this.\n+}\n+\n+macro_rules! define_bignum {\n+    ($name:ident: type=$ty:ty, n=$n:expr) => (\n+        /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n+        ///\n+        /// This is backed by an fixed-size array of given type (\"digit\").\n+        /// While the array is not very large (normally some hundred bytes),\n+        /// copying it recklessly may result in the performance hit.\n+        /// Thus this is intentionally not `Copy`.\n+        ///\n+        /// All operations available to bignums panic in the case of over/underflows.\n+        /// The caller is responsible to use large enough bignum types.\n+        pub struct $name {\n+            /// One plus the offset to the maximum \"digit\" in use.\n+            /// This does not decrease, so be aware of the computation order.\n+            /// `base[size..]` should be zero.\n+            size: usize,\n+            /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n+            /// where `W` is the number of bits in the digit type.\n+            base: [$ty; $n]\n+        }\n+\n+        impl $name {\n+            /// Makes a bignum from one digit.\n+            pub fn from_small(v: $ty) -> $name {\n+                let mut base = [0; $n];\n+                base[0] = v;\n+                $name { size: 1, base: base }\n+            }\n+\n+            /// Makes a bignum from `u64` value.\n+            pub fn from_u64(mut v: u64) -> $name {\n+                use mem;\n+\n+                let mut base = [0; $n];\n+                let mut sz = 0;\n+                while v > 0 {\n+                    base[sz] = v as $ty;\n+                    v >>= mem::size_of::<$ty>() * 8;\n+                    sz += 1;\n+                }\n+                $name { size: sz, base: base }\n+            }\n+\n+            /// Returns true if the bignum is zero.\n+            pub fn is_zero(&self) -> bool {\n+                self.base[..self.size].iter().all(|&v| v == 0)\n+            }\n+\n+            /// Adds `other` to itself and returns its own mutable reference.\n+            pub fn add<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n+                use cmp;\n+                use num::flt2dec::bignum::FullOps;\n+\n+                let mut sz = cmp::max(self.size, other.size);\n+                let mut carry = false;\n+                for (a, b) in self.base[..sz].iter_mut().zip(other.base[..sz].iter()) {\n+                    let (c, v) = (*a).full_add(*b, carry);\n+                    *a = v;\n+                    carry = c;\n+                }\n+                if carry {\n+                    self.base[sz] = 1;\n+                    sz += 1;\n+                }\n+                self.size = sz;\n+                self\n+            }\n+\n+            /// Subtracts `other` from itself and returns its own mutable reference.\n+            pub fn sub<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n+                use cmp;\n+                use num::flt2dec::bignum::FullOps;\n+\n+                let sz = cmp::max(self.size, other.size);\n+                let mut noborrow = true;\n+                for (a, b) in self.base[..sz].iter_mut().zip(other.base[..sz].iter()) {\n+                    let (c, v) = (*a).full_add(!*b, noborrow);\n+                    *a = v;\n+                    noborrow = c;\n+                }\n+                assert!(noborrow);\n+                self.size = sz;\n+                self\n+            }\n+\n+            /// Multiplies itself by a digit-sized `other` and returns its own\n+            /// mutable reference.\n+            pub fn mul_small<'a>(&'a mut self, other: $ty) -> &'a mut $name {\n+                use num::flt2dec::bignum::FullOps;\n+\n+                let mut sz = self.size;\n+                let mut carry = 0;\n+                for a in self.base[..sz].iter_mut() {\n+                    let (c, v) = (*a).full_mul(other, carry);\n+                    *a = v;\n+                    carry = c;\n+                }\n+                if carry > 0 {\n+                    self.base[sz] = carry;\n+                    sz += 1;\n+                }\n+                self.size = sz;\n+                self\n+            }\n+\n+            /// Multiplies itself by `2^bits` and returns its own mutable reference.\n+            pub fn mul_pow2<'a>(&'a mut self, bits: usize) -> &'a mut $name {\n+                use mem;\n+\n+                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digits = bits / digitbits;\n+                let bits = bits % digitbits;\n+\n+                assert!(digits < $n);\n+                debug_assert!(self.base[$n-digits..].iter().all(|&v| v == 0));\n+                debug_assert!(bits == 0 || (self.base[$n-digits-1] >> (digitbits - bits)) == 0);\n+\n+                // shift by `digits * digitbits` bits\n+                for i in (0..self.size).rev() {\n+                    self.base[i+digits] = self.base[i];\n+                }\n+                for i in 0..digits {\n+                    self.base[i] = 0;\n+                }\n+\n+                // shift by `bits` bits\n+                let mut sz = self.size + digits;\n+                if bits > 0 {\n+                    let last = sz;\n+                    let overflow = self.base[last-1] >> (digitbits - bits);\n+                    if overflow > 0 {\n+                        self.base[last] = overflow;\n+                        sz += 1;\n+                    }\n+                    for i in (digits+1..last).rev() {\n+                        self.base[i] = (self.base[i] << bits) |\n+                                       (self.base[i-1] >> (digitbits - bits));\n+                    }\n+                    self.base[digits] <<= bits;\n+                    // self.base[..digits] is zero, no need to shift\n+                }\n+\n+                self.size = sz;\n+                self\n+            }\n+\n+            /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n+            /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n+            /// and returns its own mutable reference.\n+            pub fn mul_digits<'a>(&'a mut self, other: &[$ty]) -> &'a mut $name {\n+                // the internal routine. works best when aa.len() <= bb.len().\n+                fn mul_inner(ret: &mut [$ty; $n], aa: &[$ty], bb: &[$ty]) -> usize {\n+                    use num::flt2dec::bignum::FullOps;\n+\n+                    let mut retsz = 0;\n+                    for (i, &a) in aa.iter().enumerate() {\n+                        if a == 0 { continue; }\n+                        let mut sz = bb.len();\n+                        let mut carry = 0;\n+                        for (j, &b) in bb.iter().enumerate() {\n+                            let (c, v) = a.full_mul_add(b, ret[i + j], carry);\n+                            ret[i + j] = v;\n+                            carry = c;\n+                        }\n+                        if carry > 0 {\n+                            ret[i + sz] = carry;\n+                            sz += 1;\n+                        }\n+                        if retsz < i + sz {\n+                            retsz = i + sz;\n+                        }\n+                    }\n+                    retsz\n+                }\n+\n+                let mut ret = [0; $n];\n+                let retsz = if self.size < other.len() {\n+                    mul_inner(&mut ret, &self.base[..self.size], other)\n+                } else {\n+                    mul_inner(&mut ret, other, &self.base[..self.size])\n+                };\n+                self.base = ret;\n+                self.size = retsz;\n+                self\n+            }\n+\n+            /// Divides itself by a digit-sized `other` and returns its own\n+            /// mutable reference *and* the remainder.\n+            pub fn div_rem_small<'a>(&'a mut self, other: $ty) -> (&'a mut $name, $ty) {\n+                use num::flt2dec::bignum::FullOps;\n+\n+                assert!(other > 0);\n+\n+                let sz = self.size;\n+                let mut borrow = 0;\n+                for a in self.base[..sz].iter_mut().rev() {\n+                    let (q, r) = (*a).full_div_rem(other, borrow);\n+                    *a = q;\n+                    borrow = r;\n+                }\n+                (self, borrow)\n+            }\n+        }\n+\n+        impl ::cmp::PartialEq for $name {\n+            fn eq(&self, other: &$name) -> bool { self.base[..] == other.base[..] }\n+        }\n+\n+        impl ::cmp::Eq for $name {\n+        }\n+\n+        impl ::cmp::PartialOrd for $name {\n+            fn partial_cmp(&self, other: &$name) -> ::option::Option<::cmp::Ordering> {\n+                ::option::Option::Some(self.cmp(other))\n+            }\n+        }\n+\n+        impl ::cmp::Ord for $name {\n+            fn cmp(&self, other: &$name) -> ::cmp::Ordering {\n+                use cmp::max;\n+                use iter::order;\n+\n+                let sz = max(self.size, other.size);\n+                let lhs = self.base[..sz].iter().cloned().rev();\n+                let rhs = other.base[..sz].iter().cloned().rev();\n+                order::cmp(lhs, rhs)\n+            }\n+        }\n+\n+        impl ::clone::Clone for $name {\n+            fn clone(&self) -> $name {\n+                $name { size: self.size, base: self.base }\n+            }\n+        }\n+\n+        impl ::fmt::Debug for $name {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                use mem;\n+\n+                let sz = if self.size < 1 {1} else {self.size};\n+                let digitlen = mem::size_of::<$ty>() * 2;\n+\n+                try!(write!(f, \"{:#x}\", self.base[sz-1]));\n+                for &v in self.base[..sz-1].iter().rev() {\n+                    try!(write!(f, \"_{:01$x}\", v, digitlen));\n+                }\n+                ::result::Result::Ok(())\n+            }\n+        }\n+    )\n+}\n+\n+/// The digit type for `Big32x36`.\n+pub type Digit32 = u32;\n+\n+define_bignum!(Big32x36: type=Digit32, n=36);\n+\n+// this one is used for testing only.\n+#[doc(hidden)]\n+pub mod tests {\n+    use prelude::*;\n+    define_bignum!(Big8x3: type=u8, n=3);\n+}\n+"}, {"sha": "f98bc11a315f0dab50c4e580262652f7e144a9b9", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Decodes a floating-point value into individual parts and error ranges.\n+\n+use prelude::*;\n+\n+use {f32, f64};\n+use num::{Float, FpCategory};\n+\n+/// Decoded unsigned finite value, such that:\n+///\n+/// - The original value equals to `mant * 2^exp`.\n+///\n+/// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n+///   round to the original value. The range is inclusive only when\n+///   `inclusive` is true.\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct Decoded {\n+    /// The scaled mantissa.\n+    pub mant: u64,\n+    /// The lower error range.\n+    pub minus: u64,\n+    /// The upper error range.\n+    pub plus: u64,\n+    /// The shared exponent in base 2.\n+    pub exp: i16,\n+    /// True when the error range is inclusive.\n+    ///\n+    /// In IEEE 754, this is true when the original mantissa was even.\n+    pub inclusive: bool,\n+}\n+\n+/// Decoded unsigned value.\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum FullDecoded {\n+    /// Not-a-number.\n+    Nan,\n+    /// Infinities, either positive or negative.\n+    Infinite,\n+    /// Zero, either positive or negative.\n+    Zero,\n+    /// Finite numbers with further decoded fields.\n+    Finite(Decoded),\n+}\n+\n+/// A floating point type which can be `decode`d.\n+pub trait DecodableFloat: Float + Copy {\n+    /// Returns `x * 2^exp`. Almost same to `std::{f32,f64}::ldexp`.\n+    /// This is used for testing.\n+    fn ldexpi(f: i64, exp: isize) -> Self;\n+    /// The minimum positive normalized value.\n+    fn min_pos_norm_value() -> Self;\n+}\n+\n+impl DecodableFloat for f32 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n+    fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }\n+}\n+\n+impl DecodableFloat for f64 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n+    fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }\n+}\n+\n+/// Returns a sign (true when negative) and `FullDecoded` value\n+/// from given floating point number.\n+pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n+    let (mant, exp, sign) = v.integer_decode();\n+    let even = (mant & 1) == 0;\n+    let decoded = match v.classify() {\n+        FpCategory::Nan => FullDecoded::Nan,\n+        FpCategory::Infinite => FullDecoded::Infinite,\n+        FpCategory::Zero => FullDecoded::Zero,\n+        FpCategory::Subnormal => {\n+            // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n+            // Float::integer_decode always preserves the exponent,\n+            // so the mantissa is scaled for subnormals.\n+            FullDecoded::Finite(Decoded { mant: mant, minus: 1, plus: 1,\n+                                          exp: exp, inclusive: even })\n+        }\n+        FpCategory::Normal => {\n+            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n+            if mant == minnorm.0 {\n+                // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n+                // where maxmant = minnormmant * 2 - 1\n+                FullDecoded::Finite(Decoded { mant: mant << 2, minus: 1, plus: 2,\n+                                              exp: exp - 2, inclusive: even })\n+            } else {\n+                // neighbors: (mant - 1, exp) -- (mant, exp) -- (mant + 1, exp)\n+                FullDecoded::Finite(Decoded { mant: mant << 1, minus: 1, plus: 1,\n+                                              exp: exp - 1, inclusive: even })\n+            }\n+        }\n+    };\n+    (sign < 0, decoded)\n+}\n+"}, {"sha": "d42e05a91f140f2f150c297914a93faf147f4fb9", "filename": "src/libcore/num/flt2dec/estimator.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The exponent estimator.\n+\n+/// Finds `k_0` such that `10^(k_0-1) < mant * 2^exp <= 10^(k_0+1)`.\n+///\n+/// This is used to approximate `k = ceil(log_10 (mant * 2^exp))`;\n+/// the true `k` is either `k_0` or `k_0+1`.\n+#[doc(hidden)]\n+pub fn estimate_scaling_factor(mant: u64, exp: i16) -> i16 {\n+    // 2^(nbits-1) < mant <= 2^nbits if mant > 0\n+    let nbits = 64 - (mant - 1).leading_zeros() as i64;\n+    // 1292913986 = floor(2^32 * log_10 2)\n+    // therefore this always underestimates (or is exact), but not much.\n+    (((nbits + exp as i64) * 1292913986) >> 32) as i16\n+}\n+"}, {"sha": "f51dcf54a19590a812637ca1bc21531f841be32f", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,661 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Floating-point number to decimal conversion routines.\n+\n+# Problem statement\n+\n+We are given the floating-point number `v = f * 2^e` with an integer `f`,\n+and its bounds `minus` and `plus` such that any number between `v - minus` and\n+`v + plus` will be rounded to `v`. For the simplicity we assume that\n+this range is exclusive. Then we would like to get the unique decimal\n+representation `V = 0.d[0..n-1] * 10^k` such that:\n+\n+- `d[0]` is non-zero.\n+\n+- It's correctly rounded when parsed back: `v - minus < V < v + plus`.\n+  Furthermore it is shortest such one, i.e. there is no representation\n+  with less than `n` digits that is correctly rounded.\n+\n+- It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Note that\n+  there might be two representations satisfying this uniqueness requirement,\n+  in which case some tie-breaking mechanism is used.\n+\n+We will call this mode of operation as to the *shortest* mode. This mode is used\n+when there is no additional constraint, and can be thought as a \"natural\" mode\n+as it matches the ordinary intuition (it at least prints `0.1f32` as \"0.1\").\n+\n+We have two more modes of operation closely related to each other. In these modes\n+we are given either the number of significant digits `n` or the last-digit\n+limitation `limit` (which determines the actual `n`), and we would like to get\n+the representation `V = 0.d[0..n-1] * 10^k` such that:\n+\n+- `d[0]` is non-zero, unless `n` was zero in which case only `k` is returned.\n+\n+- It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Again,\n+  there might be some tie-breaking mechanism.\n+\n+When `limit` is given but not `n`, we set `n` such that `k - n = limit`\n+so that the last digit `d[n-1]` is scaled by `10^(k-n) = 10^limit`.\n+If such `n` is negative, we clip it to zero so that we will only get `k`.\n+We are also limited by the supplied buffer. This limitation is used to print\n+the number up to given number of fractional digits without knowing\n+the correct `k` beforehand.\n+\n+We will call the mode of operation requiring `n` as to the *exact* mode,\n+and one requiring `limit` as to the *fixed* mode. The exact mode is a subset of\n+the fixed mode: the sufficiently large last-digit limitation will eventually fill\n+the supplied buffer and let the algorithm to return.\n+\n+# Implementation overview\n+\n+It is easy to get the floating point printing correct but slow (Russ Cox has\n+[demonstrated](http://research.swtch.com/ftoa) how it's easy), or incorrect but\n+fast (na\u00efve division and modulo). But it is surprisingly hard to print\n+floating point numbers correctly *and* efficiently.\n+\n+There are two classes of algorithms widely known to be correct.\n+\n+- The \"Dragon\" family of algorithm is first described by Guy L. Steele Jr. and\n+  Jon L. White. They rely on the fixed-size big integer for their correctness.\n+  A slight improvement was found later, which is posthumously described by\n+  Robert G. Burger and R. Kent Dybvig. David Gay's `dtoa.c` routine is\n+  a popular implementation of this strategy.\n+\n+- The \"Grisu\" family of algorithm is first described by Florian Loitsch.\n+  They use very cheap integer-only procedure to determine the close-to-correct\n+  representation which is at least guaranteed to be shortest. The variant,\n+  Grisu3, actively detects if the resulting representation is incorrect.\n+\n+We implement both algorithms with necessary tweaks to suit our requirements.\n+In particular, published literatures are short of the actual implementation\n+difficulties like how to avoid arithmetic overflows. Each implementation,\n+available in `strategy::dragon` and `strategy::grisu` respectively,\n+extensively describes all necessary justifications and many proofs for them.\n+(It is still difficult to follow though. You have been warned.)\n+\n+Both implementations expose two public functions:\n+\n+- `format_shortest(decoded, buf)`, which always needs at least\n+  `MAX_SIG_DIGITS` digits of buffer. Implements the shortest mode.\n+\n+- `format_exact(decoded, buf, limit)`, which accepts as small as\n+  one digit of buffer. Implements exact and fixed modes.\n+\n+They try to fill the `u8` buffer with digits and returns the number of digits\n+written and the exponent `k`. They are total for all finite `f32` and `f64`\n+inputs (Grisu internally falls back to Dragon if necessary).\n+\n+The rendered digits are formatted into the actual string form with\n+four functions:\n+\n+- `to_shortest_str` prints the shortest representation, which can be padded by\n+  zeroes to make *at least* given number of fractional digits.\n+\n+- `to_shortest_exp_str` prints the shortest representation, which can be\n+  padded by zeroes when its exponent is in the specified ranges,\n+  or can be printed in the exponential form such as `1.23e45`.\n+\n+- `to_exact_exp_str` prints the exact representation with given number of\n+  digits in the exponential form.\n+\n+- `to_exact_fixed_str` prints the fixed representation with *exactly*\n+  given number of fractional digits.\n+\n+They all return a slice of preallocated `Part` array, which corresponds to\n+the individual part of strings: a fixed string, a part of rendered digits,\n+a number of zeroes or a small (`u16`) number. The caller is expected to\n+provide a large enough buffer and `Part` array, and to assemble the final\n+string from resulting `Part`s itself.\n+\n+All algorithms and formatting functions are accompanied by extensive tests\n+in `coretest::num::flt2dec` module. It also shows how to use individual\n+functions.\n+\n+*/\n+\n+// while this is extensively documented, this is in principle private which is\n+// only made public for testing. do not expose us.\n+#![doc(hidden)]\n+\n+use prelude::*;\n+use i16;\n+use num::Float;\n+use slice::bytes;\n+pub use self::decoder::{decode, DecodableFloat, FullDecoded, Decoded};\n+\n+pub mod estimator;\n+pub mod bignum;\n+pub mod decoder;\n+\n+/// Digit-generation algorithms.\n+pub mod strategy {\n+    pub mod dragon;\n+    pub mod grisu;\n+}\n+\n+/// The minimum size of buffer necessary for the shortest mode.\n+///\n+/// It is a bit non-trivial to derive, but this is one plus the maximal number of\n+/// significant decimal digits from formatting algorithms with the shortest result.\n+/// The exact formula is `ceil(# bits in mantissa * log_10 2 + 1)`.\n+pub const MAX_SIG_DIGITS: usize = 17;\n+\n+/// When `d[..n]` contains decimal digits, increase the last digit and propagate carry.\n+/// Returns a next digit when it causes the length change.\n+#[doc(hidden)]\n+pub fn round_up(d: &mut [u8], n: usize) -> Option<u8> {\n+    match d[..n].iter().rposition(|&c| c != b'9') {\n+        Some(i) => { // d[i+1..n] is all nines\n+            d[i] += 1;\n+            for j in i+1..n { d[j] = b'0'; }\n+            None\n+        }\n+        None if n > 0 => { // 999..999 rounds to 1000..000 with an increased exponent\n+            d[0] = b'1';\n+            for j in 1..n { d[j] = b'0'; }\n+            Some(b'0')\n+        }\n+        None => { // an empty buffer rounds up (a bit strange but reasonable)\n+            Some(b'1')\n+        }\n+    }\n+}\n+\n+/// Formatted parts.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Part<'a> {\n+    /// Given number of zero digits.\n+    Zero(usize),\n+    /// A literal number up to 5 digits.\n+    Num(u16),\n+    /// A verbatim copy of given bytes.\n+    Copy(&'a [u8]),\n+}\n+\n+impl<'a> Part<'a> {\n+    /// Returns the exact byte length of given part.\n+    pub fn len(&self) -> usize {\n+        match *self {\n+            Part::Zero(nzeroes) => nzeroes,\n+            Part::Num(v) => if v < 1_000 { if v < 10 { 1 } else if v < 100 { 2 } else { 3 } }\n+                            else { if v < 10_000 { 4 } else { 5 } },\n+            Part::Copy(buf) => buf.len(),\n+        }\n+    }\n+\n+    /// Writes a part into the supplied buffer.\n+    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n+    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n+    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n+        let len = self.len();\n+        if out.len() >= len {\n+            match *self {\n+                Part::Zero(nzeroes) => {\n+                    for c in &mut out[..nzeroes] { *c = b'0'; }\n+                }\n+                Part::Num(mut v) => {\n+                    for c in out[..len].iter_mut().rev() {\n+                        *c = b'0' + (v % 10) as u8;\n+                        v /= 10;\n+                    }\n+                }\n+                Part::Copy(buf) => {\n+                    bytes::copy_memory(buf, out);\n+                }\n+            }\n+            Some(len)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Formatted result containing one or more parts.\n+/// This can be written to the byte buffer or converted to the allocated string.\n+#[derive(Clone)]\n+pub struct Formatted<'a> {\n+    /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n+    pub sign: &'static [u8],\n+    /// Formatted parts to be rendered after a sign and optional zero padding.\n+    pub parts: &'a [Part<'a>],\n+}\n+\n+impl<'a> Formatted<'a> {\n+    /// Returns the exact byte length of combined formatted result.\n+    pub fn len(&self) -> usize {\n+        let mut len = self.sign.len();\n+        for part in self.parts {\n+            len += part.len();\n+        }\n+        len\n+    }\n+\n+    /// Writes all formatted parts into the supplied buffer.\n+    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n+    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n+    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n+        if out.len() < self.sign.len() { return None; }\n+        bytes::copy_memory(self.sign, out);\n+\n+        let mut written = self.sign.len();\n+        for part in self.parts {\n+            match part.write(&mut out[written..]) {\n+                Some(len) => { written += len; }\n+                None => { return None; }\n+            }\n+        }\n+        Some(written)\n+    }\n+}\n+\n+/// Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form\n+/// with at least given number of fractional digits. The result is stored to\n+/// the supplied parts array and a slice of written parts is returned.\n+///\n+/// `frac_digits` can be less than the number of actual fractional digits in `buf`;\n+/// it will be ignored and full digits will be printed. It is only used to print\n+/// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n+/// it will only print given digits and nothing else.\n+fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n+                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+    assert!(!buf.is_empty());\n+    assert!(buf[0] > b'0');\n+    assert!(parts.len() >= 4);\n+\n+    // if there is the restriction on the last digit position, `buf` is assumed to be\n+    // left-padded with the virtual zeroes. the number of virtual zeroes, `nzeroes`,\n+    // equals to `max(0, exp + frac_digits - buf.len())`, so that the position of\n+    // the last digit `exp - buf.len() - nzeroes` is no more than `-frac_digits`:\n+    //\n+    //                       |<-virtual->|\n+    //       |<---- buf ---->|  zeroes   |     exp\n+    //    0. 1 2 3 4 5 6 7 8 9 _ _ _ _ _ _ x 10\n+    //    |                  |           |\n+    // 10^exp    10^(exp-buf.len())   10^(exp-buf.len()-nzeroes)\n+    //\n+    // `nzeroes` is individually calculated for each case in order to avoid overflow.\n+\n+    if exp <= 0 {\n+        // the decimal point is before rendered digits: [0.][000...000][1234][____]\n+        let minus_exp = -(exp as i32) as usize;\n+        parts[0] = Part::Copy(b\"0.\");\n+        parts[1] = Part::Zero(minus_exp);\n+        parts[2] = Part::Copy(buf);\n+        if frac_digits > buf.len() && frac_digits - buf.len() > minus_exp {\n+            parts[3] = Part::Zero((frac_digits - buf.len()) - minus_exp);\n+            &parts[..4]\n+        } else {\n+            &parts[..3]\n+        }\n+    } else {\n+        let exp = exp as usize;\n+        if exp < buf.len() {\n+            // the decimal point is inside rendered digits: [12][.][34][____]\n+            parts[0] = Part::Copy(&buf[..exp]);\n+            parts[1] = Part::Copy(b\".\");\n+            parts[2] = Part::Copy(&buf[exp..]);\n+            if frac_digits > buf.len() - exp {\n+                parts[3] = Part::Zero(frac_digits - (buf.len() - exp));\n+                &parts[..4]\n+            } else {\n+                &parts[..3]\n+            }\n+        } else {\n+            // the decimal point is after rendered digits: [1234][____0000] or [1234][__][.][__].\n+            parts[0] = Part::Copy(buf);\n+            parts[1] = Part::Zero(exp - buf.len());\n+            if frac_digits > 0 {\n+                parts[2] = Part::Copy(b\".\");\n+                parts[3] = Part::Zero(frac_digits);\n+                &parts[..4]\n+            } else {\n+                &parts[..2]\n+            }\n+        }\n+    }\n+}\n+\n+/// Formats given decimal digits `0.<...buf...> * 10^exp` into the exponential form\n+/// with at least given number of significant digits. When `upper` is true,\n+/// the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n+/// stored to the supplied parts array and a slice of written parts is returned.\n+///\n+/// `min_digits` can be less than the number of actual significant digits in `buf`;\n+/// it will be ignored and full digits will be printed. It is only used to print\n+/// additional zeroes after rendered digits. Thus `min_digits` of 0 means that\n+/// it will only print given digits and nothing else.\n+fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,\n+                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+    assert!(!buf.is_empty());\n+    assert!(buf[0] > b'0');\n+    assert!(parts.len() >= 6);\n+\n+    let mut n = 0;\n+\n+    parts[n] = Part::Copy(&buf[..1]);\n+    n += 1;\n+\n+    if buf.len() > 1 || min_ndigits > 1 {\n+        parts[n] = Part::Copy(b\".\");\n+        parts[n + 1] = Part::Copy(&buf[1..]);\n+        n += 2;\n+        if min_ndigits > buf.len() {\n+            parts[n] = Part::Zero(min_ndigits - buf.len());\n+            n += 1;\n+        }\n+    }\n+\n+    // 0.1234 x 10^exp = 1.234 x 10^(exp-1)\n+    let exp = exp as i32 - 1; // avoid underflow when exp is i16::MIN\n+    if exp < 0 {\n+        parts[n] = Part::Copy(if upper { b\"E-\" } else { b\"e-\" });\n+        parts[n + 1] = Part::Num(-exp as u16);\n+    } else {\n+        parts[n] = Part::Copy(if upper { b\"E\" } else { b\"e\" });\n+        parts[n + 1] = Part::Num(exp as u16);\n+    }\n+    &parts[..n + 2]\n+}\n+\n+/// Sign formatting options.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Sign {\n+    /// Prints `-` only for the negative non-zero values.\n+    Minus,        // -inf -1  0  0  1  inf nan\n+    /// Prints `-` only for any negative values (including the negative zero).\n+    MinusRaw,     // -inf -1 -0  0  1  inf nan\n+    /// Prints `-` for the negative non-zero values, or `+` otherwise.\n+    MinusPlus,    // -inf -1 +0 +0 +1 +inf nan\n+    /// Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n+    MinusPlusRaw, // -inf -1 -0 +0 +1 +inf nan\n+}\n+\n+/// Returns the static byte string corresponding to the sign to be formatted.\n+/// It can be either `b\"\"`, `b\"+\"` or `b\"-\"`.\n+fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static [u8] {\n+    match (*decoded, sign) {\n+        (FullDecoded::Nan, _) => b\"\",\n+        (FullDecoded::Zero, Sign::Minus) => b\"\",\n+        (FullDecoded::Zero, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n+        (FullDecoded::Zero, Sign::MinusPlus) => b\"+\",\n+        (FullDecoded::Zero, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n+        (_, Sign::Minus) | (_, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n+        (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n+    }\n+}\n+\n+/// Formats given floating point number into the decimal form with at least\n+/// given number of fractional digits. The result is stored to the supplied parts\n+/// array while utilizing given byte buffer as a scratch. `upper` is currently\n+/// unused but left for the future decision to change the case of non-finite values,\n+/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// (which can be an empty string if no sign is rendered).\n+///\n+/// `format_shortest` should be the underlying digit-generation function.\n+/// You probably would want `strategy::grisu::format_shortest` for this.\n+///\n+/// `frac_digits` can be less than the number of actual fractional digits in `v`;\n+/// it will be ignored and full digits will be printed. It is only used to print\n+/// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n+/// it will only print given digits and nothing else.\n+///\n+/// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n+/// There should be at least 5 parts available, due to the worst case like\n+/// `[+][0.][0000][45][0000]` with `frac_digits = 10`.\n+pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n+                                 sign: Sign, frac_digits: usize, _upper: bool,\n+                                 buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    assert!(parts.len() >= 4);\n+    assert!(buf.len() >= MAX_SIG_DIGITS);\n+\n+    let (negative, full_decoded) = decode(v);\n+    let sign = determine_sign(sign, &full_decoded, negative);\n+    match full_decoded {\n+        FullDecoded::Nan => {\n+            parts[0] = Part::Copy(b\"NaN\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Infinite => {\n+            parts[0] = Part::Copy(b\"inf\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Zero => {\n+            if frac_digits > 0 { // [0.][0000]\n+                parts[0] = Part::Copy(b\"0.\");\n+                parts[1] = Part::Zero(frac_digits);\n+                Formatted { sign: sign, parts: &parts[..2] }\n+            } else {\n+                parts[0] = Part::Copy(b\"0\");\n+                Formatted { sign: sign, parts: &parts[..1] }\n+            }\n+        }\n+        FullDecoded::Finite(ref decoded) => {\n+            let (len, exp) = format_shortest(decoded, buf);\n+            Formatted { sign: sign,\n+                        parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+        }\n+    }\n+}\n+\n+/// Formats given floating point number into the decimal form or\n+/// the exponential form, depending on the resulting exponent. The result is\n+/// stored to the supplied parts array while utilizing given byte buffer\n+/// as a scratch. `upper` is used to determine the case of non-finite values\n+/// (`inf` and `nan`) or the case of the exponent prefix (`e` or `E`).\n+/// The first part to be rendered is always a `Part::Sign` (which can be\n+/// an empty string if no sign is rendered).\n+///\n+/// `format_shortest` should be the underlying digit-generation function.\n+/// You probably would want `strategy::grisu::format_shortest` for this.\n+///\n+/// The `dec_bounds` is a tuple `(lo, hi)` such that the number is formatted\n+/// as decimal only when `10^lo <= V < 10^hi`. Note that this is the *apparant* `V`\n+/// instead of the actual `v`! Thus any printed exponent in the exponential form\n+/// cannot be in this range, avoiding any confusion.\n+///\n+/// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n+/// There should be at least 7 parts available, due to the worst case like\n+/// `[+][1][.][2345][e][-][67]`.\n+pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n+                                     sign: Sign, dec_bounds: (i16, i16), upper: bool,\n+                                     buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    assert!(parts.len() >= 6);\n+    assert!(buf.len() >= MAX_SIG_DIGITS);\n+    assert!(dec_bounds.0 <= dec_bounds.1);\n+\n+    let (negative, full_decoded) = decode(v);\n+    let sign = determine_sign(sign, &full_decoded, negative);\n+    match full_decoded {\n+        FullDecoded::Nan => {\n+            parts[0] = Part::Copy(b\"NaN\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Infinite => {\n+            parts[0] = Part::Copy(b\"inf\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Zero => {\n+            parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n+                Part::Copy(b\"0\")\n+            } else {\n+                Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" })\n+            };\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Finite(ref decoded) => {\n+            let (len, exp) = format_shortest(decoded, buf);\n+            let vis_exp = exp as i32 - 1;\n+            let parts = if dec_bounds.0 as i32 <= vis_exp && vis_exp < dec_bounds.1 as i32 {\n+                digits_to_dec_str(&buf[..len], exp, 0, parts)\n+            } else {\n+                digits_to_exp_str(&buf[..len], exp, 0, upper, parts)\n+            };\n+            Formatted { sign: sign, parts: parts }\n+        }\n+    }\n+}\n+\n+/// Returns rather crude approximation (upper bound) for the maximum buffer size\n+/// calculated from the given decoded exponent.\n+///\n+/// The exact limit is:\n+///\n+/// - when `exp < 0`, the maximum length is `ceil(log_10 (5^-exp * (2^64 - 1)))`.\n+/// - when `exp >= 0`, the maximum length is `ceil(log_10 (2^exp * (2^64 - 1)))`.\n+///\n+/// `ceil(log_10 (x^exp * (2^64 - 1)))` is less than `ceil(log_10 (2^64 - 1)) +\n+/// ceil(exp * log_10 x)`, which is in turn less than `20 + (1 + exp * log_10 x)`.\n+/// We use the facts that `log_10 2 < 5/16` and `log_10 5 < 12/16`, which is\n+/// enough for our purposes.\n+///\n+/// Why do we need this? `format_exact` functions will fill the entire buffer\n+/// unless limited by the last digit restriction, but it is possible that\n+/// the number of digits requested is ridiculously large (say, 30,000 digits).\n+/// The vast majority of buffer will be filled with zeroes, so we don't want to\n+/// allocate all the buffer beforehand. Consequently, for any given arguments,\n+/// 826 bytes of buffer should be sufficient for `f64`. Compare this with\n+/// the actual number for the worst case: 770 bytes (when `exp = -1074`).\n+fn estimate_max_buf_len(exp: i16) -> usize {\n+    21 + ((if exp < 0 { -12 } else { 5 } * exp as i32) as usize >> 4)\n+}\n+\n+/// Formats given floating point number into the exponential form with\n+/// exactly given number of significant digits. The result is stored to\n+/// the supplied parts array while utilizing given byte buffer as a scratch.\n+/// `upper` is used to determine the case of the exponent prefix (`e` or `E`).\n+/// The first part to be rendered is always a `Part::Sign` (which can be\n+/// an empty string if no sign is rendered).\n+///\n+/// `format_exact` should be the underlying digit-generation function.\n+/// You probably would want `strategy::grisu::format_exact` for this.\n+///\n+/// The byte buffer should be at least `ndigits` bytes long unless `ndigits` is\n+/// so large that only the fixed number of digits will be ever written.\n+/// (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n+/// There should be at least 7 parts available, due to the worst case like\n+/// `[+][1][.][2345][e][-][67]`.\n+pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n+                                  sign: Sign, ndigits: usize, upper: bool,\n+                                  buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    assert!(parts.len() >= 6);\n+    assert!(ndigits > 0);\n+\n+    let (negative, full_decoded) = decode(v);\n+    let sign = determine_sign(sign, &full_decoded, negative);\n+    match full_decoded {\n+        FullDecoded::Nan => {\n+            parts[0] = Part::Copy(b\"NaN\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Infinite => {\n+            parts[0] = Part::Copy(b\"inf\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Zero => {\n+            if ndigits > 1 { // [0.][0000][e0]\n+                parts[0] = Part::Copy(b\"0.\");\n+                parts[1] = Part::Zero(ndigits - 1);\n+                parts[2] = Part::Copy(if upper { b\"E0\" } else { b\"e0\" });\n+                Formatted { sign: sign, parts: &parts[..3] }\n+            } else {\n+                parts[0] = Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" });\n+                Formatted { sign: sign, parts: &parts[..1] }\n+            }\n+        }\n+        FullDecoded::Finite(ref decoded) => {\n+            let maxlen = estimate_max_buf_len(decoded.exp);\n+            assert!(buf.len() >= ndigits || buf.len() >= maxlen);\n+\n+            let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n+            let (len, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n+            Formatted { sign: sign,\n+                        parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n+        }\n+    }\n+}\n+\n+/// Formats given floating point number into the decimal form with exactly\n+/// given number of fractional digits. The result is stored to the supplied parts\n+/// array while utilizing given byte buffer as a scratch. `upper` is currently\n+/// unused but left for the future decision to change the case of non-finite values,\n+/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// (which can be an empty string if no sign is rendered).\n+///\n+/// `format_exact` should be the underlying digit-generation function.\n+/// You probably would want `strategy::grisu::format_exact` for this.\n+///\n+/// The byte buffer should be enough for the output unless `frac_digits` is\n+/// so large that only the fixed number of digits will be ever written.\n+/// (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n+/// There should be at least 5 parts available, due to the worst case like\n+/// `[+][0.][0000][45][0000]` with `frac_digits = 10`.\n+pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n+                                    sign: Sign, frac_digits: usize, _upper: bool,\n+                                    buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    assert!(parts.len() >= 4);\n+\n+    let (negative, full_decoded) = decode(v);\n+    let sign = determine_sign(sign, &full_decoded, negative);\n+    match full_decoded {\n+        FullDecoded::Nan => {\n+            parts[0] = Part::Copy(b\"NaN\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Infinite => {\n+            parts[0] = Part::Copy(b\"inf\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Zero => {\n+            if frac_digits > 0 { // [0.][0000]\n+                parts[0] = Part::Copy(b\"0.\");\n+                parts[1] = Part::Zero(frac_digits);\n+                Formatted { sign: sign, parts: &parts[..2] }\n+            } else {\n+                parts[0] = Part::Copy(b\"0\");\n+                Formatted { sign: sign, parts: &parts[..1] }\n+            }\n+        }\n+        FullDecoded::Finite(ref decoded) => {\n+            let maxlen = estimate_max_buf_len(decoded.exp);\n+            assert!(buf.len() >= maxlen);\n+\n+            // it *is* possible that `frac_digits` is ridiculously large.\n+            // `format_exact` will end rendering digits much earlier in this case,\n+            // because we are strictly limited by `maxlen`.\n+            let limit = if frac_digits < 0x8000 { -(frac_digits as i16) } else { i16::MIN };\n+            let (len, exp) = format_exact(decoded, &mut buf[..maxlen], limit);\n+            if exp <= limit {\n+                // the restriction couldn't been met, so this should render like zero no matter\n+                // `exp` was. this does not include the case that the restriction has been met\n+                // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n+                debug_assert_eq!(len, 0);\n+                if frac_digits > 0 { // [0.][0000]\n+                    parts[0] = Part::Copy(b\"0.\");\n+                    parts[1] = Part::Zero(frac_digits);\n+                    Formatted { sign: sign, parts: &parts[..2] }\n+                } else {\n+                    parts[0] = Part::Copy(b\"0\");\n+                    Formatted { sign: sign, parts: &parts[..1] }\n+                }\n+            } else {\n+                Formatted { sign: sign,\n+                            parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "a819932525bd14259559a5c8fb407fbfa9d1bb42", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,331 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Almost direct (but slightly optimized) Rust translation of Figure 3 of [1].\n+\n+[1] Burger, R. G. and Dybvig, R. K. 1996. Printing floating-point numbers\n+    quickly and accurately. SIGPLAN Not. 31, 5 (May. 1996), 108-116.\n+*/\n+\n+use prelude::*;\n+use num::Float;\n+use cmp::Ordering;\n+\n+use num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n+use num::flt2dec::estimator::estimate_scaling_factor;\n+use num::flt2dec::bignum::Digit32 as Digit;\n+use num::flt2dec::bignum::Big32x36 as Big;\n+\n+// FIXME(#22540) const ref to static array seems to ICE\n+static POW10: [Digit; 10] = [1, 10, 100, 1000, 10000, 100000,\n+                             1000000, 10000000, 100000000, 1000000000];\n+static TWOPOW10: [Digit; 10] = [2, 20, 200, 2000, 20000, 200000,\n+                                2000000, 20000000, 200000000, 2000000000];\n+\n+// precalculated arrays of `Digit`s for 10^(2^n)\n+static POW10TO16: [Digit; 2] = [0x6fc10000, 0x2386f2];\n+static POW10TO32: [Digit; 4] = [0, 0x85acef81, 0x2d6d415b, 0x4ee];\n+static POW10TO64: [Digit; 7] = [0, 0, 0xbf6a1f01, 0x6e38ed64, 0xdaa797ed, 0xe93ff9f4, 0x184f03];\n+static POW10TO128: [Digit; 14] =\n+    [0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08,\n+     0xbccdb0da, 0xa6337f19, 0xe91f2603, 0x24e];\n+static POW10TO256: [Digit; 27] =\n+    [0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6,\n+     0xcf4a6e70, 0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e,\n+     0xcc5573c0, 0x65f9ef17, 0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7];\n+\n+#[doc(hidden)]\n+pub fn mul_pow10<'a>(x: &'a mut Big, n: usize) -> &'a mut Big {\n+    debug_assert!(n < 512);\n+    if n &   7 != 0 { x.mul_small(POW10[n & 7]); }\n+    if n &   8 != 0 { x.mul_small(POW10[8]); }\n+    if n &  16 != 0 { x.mul_digits(&POW10TO16); }\n+    if n &  32 != 0 { x.mul_digits(&POW10TO32); }\n+    if n &  64 != 0 { x.mul_digits(&POW10TO64); }\n+    if n & 128 != 0 { x.mul_digits(&POW10TO128); }\n+    if n & 256 != 0 { x.mul_digits(&POW10TO256); }\n+    x\n+}\n+\n+fn div_2pow10<'a>(x: &'a mut Big, mut n: usize) -> &'a mut Big {\n+    let largest = POW10.len() - 1;\n+    while n > largest {\n+        x.div_rem_small(POW10[largest]);\n+        n -= largest;\n+    }\n+    x.div_rem_small(TWOPOW10[n]);\n+    x\n+}\n+\n+// only usable when `x < 16 * scale`; `scaleN` should be `scale.mul_small(N)`\n+fn div_rem_upto_16<'a>(x: &'a mut Big, scale: &Big,\n+                       scale2: &Big, scale4: &Big, scale8: &Big) -> (u8, &'a mut Big) {\n+    let mut d = 0;\n+    if *x >= *scale8 { x.sub(scale8); d += 8; }\n+    if *x >= *scale4 { x.sub(scale4); d += 4; }\n+    if *x >= *scale2 { x.sub(scale2); d += 2; }\n+    if *x >= *scale  { x.sub(scale);  d += 1; }\n+    debug_assert!(*x < *scale);\n+    (d, x)\n+}\n+\n+/// The shortest mode implementation for Dragon.\n+pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp*/ i16) {\n+    // the number `v` to format is known to be:\n+    // - equal to `mant * 2^exp`;\n+    // - preceded by `(mant - 2 * minus) * 2^exp` in the original type; and\n+    // - followed by `(mant + 2 * plus) * 2^exp` in the original type.\n+    //\n+    // obviously, `minus` and `plus` cannot be zero. (for infinities, we use out-of-range values.)\n+    // also we assume that at least one digit is generated, i.e. `mant` cannot be zero too.\n+    //\n+    // this also means that any number between `low = (mant - minus) * 2^exp` and\n+    // `high = (mant + plus) * 2^exp` will map to this exact floating point number,\n+    // with bounds included when the original mantissa was even (i.e. `!mant_was_odd`).\n+\n+    assert!(d.mant > 0);\n+    assert!(d.minus > 0);\n+    assert!(d.plus > 0);\n+    assert!(d.mant.checked_add(d.plus).is_some());\n+    assert!(d.mant.checked_sub(d.minus).is_some());\n+    assert!(buf.len() >= MAX_SIG_DIGITS);\n+\n+    // `a.cmp(&b) < rounding` is `if d.inclusive {a <= b} else {a < b}`\n+    let rounding = if d.inclusive {Ordering::Greater} else {Ordering::Equal};\n+\n+    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < high <= 10^(k_0+1)`.\n+    // the tight bound `k` satisfying `10^(k-1) < high <= 10^k` is calculated later.\n+    let mut k = estimate_scaling_factor(d.mant + d.plus, d.exp);\n+\n+    // convert `{mant, plus, minus} * 2^exp` into the fractional form so that:\n+    // - `v = mant / scale`\n+    // - `low = (mant - minus) / scale`\n+    // - `high = (mant + plus) / scale`\n+    let mut mant = Big::from_u64(d.mant);\n+    let mut minus = Big::from_u64(d.minus);\n+    let mut plus = Big::from_u64(d.plus);\n+    let mut scale = Big::from_small(1);\n+    if d.exp < 0 {\n+        scale.mul_pow2(-d.exp as usize);\n+    } else {\n+        mant.mul_pow2(d.exp as usize);\n+        minus.mul_pow2(d.exp as usize);\n+        plus.mul_pow2(d.exp as usize);\n+    }\n+\n+    // divide `mant` by `10^k`. now `scale / 10 < mant + plus <= scale * 10`.\n+    if k >= 0 {\n+        mul_pow10(&mut scale, k as usize);\n+    } else {\n+        mul_pow10(&mut mant, -k as usize);\n+        mul_pow10(&mut minus, -k as usize);\n+        mul_pow10(&mut plus, -k as usize);\n+    }\n+\n+    // fixup when `mant + plus > scale` (or `>=`).\n+    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n+    // now `scale < mant + plus <= scale * 10` and we are ready to generate digits.\n+    //\n+    // note that `d[0]` *can* be zero, when `scale - plus < mant < scale`.\n+    // in this case rounding-up condition (`up` below) will be triggered immediately.\n+    if scale.cmp(mant.clone().add(&plus)) < rounding {\n+        // equivalent to scaling `scale` by 10\n+        k += 1;\n+    } else {\n+        mant.mul_small(10);\n+        minus.mul_small(10);\n+        plus.mul_small(10);\n+    }\n+\n+    // cache `(2, 4, 8) * scale` for digit generation.\n+    let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n+    let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n+    let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+\n+    let mut down;\n+    let mut up;\n+    let mut i = 0;\n+    loop {\n+        // invariants, where `d[0..n-1]` are digits generated so far:\n+        // - `v = mant / scale * 10^(k-n-1) + d[0..n-1] * 10^(k-n)`\n+        // - `v - low = minus / scale * 10^(k-n-1)`\n+        // - `high - v = plus / scale * 10^(k-n-1)`\n+        // - `(mant + plus) / scale <= 10` (thus `mant / scale < 10`)\n+        // where `d[i..j]` is a shorthand for `d[i] * 10^(j-i) + ... + d[j-1] * 10 + d[j]`.\n+\n+        // generate one digit: `d[n] = floor(mant / scale) < 10`.\n+        let (d, _) = div_rem_upto_16(&mut mant, &scale, &scale2, &scale4, &scale8);\n+        debug_assert!(d < 10);\n+        buf[i] = b'0' + d;\n+        i += 1;\n+\n+        // this is a simplified description of the modified Dragon algorithm.\n+        // many intermediate derivations and completeness arguments are omitted for convenience.\n+        //\n+        // start with modified invariants, as we've updated `n`:\n+        // - `v = mant / scale * 10^(k-n) + d[0..n-1] * 10^(k-n)`\n+        // - `v - low = minus / scale * 10^(k-n)`\n+        // - `high - v = plus / scale * 10^(k-n)`\n+        //\n+        // assume that `d[0..n-1]` is the shortest representation between `low` and `high`,\n+        // i.e. `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n+        // - `low < d[0..n-1] * 10^(k-n) < high` (bijectivity: digits round to `v`); and\n+        // - `abs(v / 10^(k-n) - d[0..n-1]) <= 1/2` (the last digit is correct).\n+        //\n+        // the second condition simplifies to `2 * mant <= scale`.\n+        // solving invariants in terms of `mant`, `low` and `high` yields\n+        // a simpler version of the first condition: `-plus < mant < minus`.\n+        // since `-plus < 0 <= mant`, we have the correct shortest representation\n+        // when `mant < minus` and `2 * mant <= scale`.\n+        // (the former becomes `mant <= minus` when the original mantissa is even.)\n+        //\n+        // when the second doesn't hold (`2 * mant > scale`), we need to increase the last digit.\n+        // this is enough for restoring that condition: we already know that\n+        // the digit generation guarantees `0 <= v / 10^(k-n) - d[0..n-1] < 1`.\n+        // in this case, the first condition becomes `-plus < mant - scale < minus`.\n+        // since `mant < scale` after the generation, we have `scale < mant + plus`.\n+        // (again, this becomes `scale <= mant + plus` when the original mantissa is even.)\n+        //\n+        // in short:\n+        // - stop and round `down` (keep digits as is) when `mant < minus` (or `<=`).\n+        // - stop and round `up` (increase the last digit) when `scale < mant + plus` (or `<=`).\n+        // - keep generating otherwise.\n+        down = mant.cmp(&minus) < rounding;\n+        up = scale.cmp(mant.clone().add(&plus)) < rounding;\n+        if down || up { break; } // we have the shortest representation, proceed to the rounding\n+\n+        // restore the invariants.\n+        // this makes the algorithm always terminating: `minus` and `plus` always increases,\n+        // but `mant` is clipped modulo `scale` and `scale` is fixed.\n+        mant.mul_small(10);\n+        minus.mul_small(10);\n+        plus.mul_small(10);\n+    }\n+\n+    // rounding up happens when\n+    // i) only the rounding-up condition was triggered, or\n+    // ii) both conditions were triggered and tie breaking prefers rounding up.\n+    if up && (!down || *mant.mul_pow2(1) >= scale) {\n+        // if rounding up changes the length, the exponent should also change.\n+        // it seems that this condition is very hard to satisfy (possibly impossible),\n+        // but we are just being safe and consistent here.\n+        if let Some(c) = round_up(buf, i) {\n+            buf[i] = c;\n+            i += 1;\n+            k += 1;\n+        }\n+    }\n+\n+    (i, k)\n+}\n+\n+/// The exact and fixed mode implementation for Dragon.\n+pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usize, /*exp*/ i16) {\n+    assert!(d.mant > 0);\n+    assert!(d.minus > 0);\n+    assert!(d.plus > 0);\n+    assert!(d.mant.checked_add(d.plus).is_some());\n+    assert!(d.mant.checked_sub(d.minus).is_some());\n+\n+    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < v <= 10^(k_0+1)`.\n+    let mut k = estimate_scaling_factor(d.mant, d.exp);\n+\n+    // `v = mant / scale`.\n+    let mut mant = Big::from_u64(d.mant);\n+    let mut scale = Big::from_small(1);\n+    if d.exp < 0 {\n+        scale.mul_pow2(-d.exp as usize);\n+    } else {\n+        mant.mul_pow2(d.exp as usize);\n+    }\n+\n+    // divide `mant` by `10^k`. now `scale / 10 < mant <= scale * 10`.\n+    if k >= 0 {\n+        mul_pow10(&mut scale, k as usize);\n+    } else {\n+        mul_pow10(&mut mant, -k as usize);\n+    }\n+\n+    // fixup when `mant + plus >= scale`, where `plus / scale = 10^-buf.len() / 2`.\n+    // in order to keep the fixed-size bignum, we actually use `mant + floor(plus) >= scale`.\n+    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n+    // again with the shortest algorithm, `d[0]` can be zero but will be eventually rounded up.\n+    if *div_2pow10(&mut scale.clone(), buf.len()).add(&mant) >= scale {\n+        // equivalent to scaling `scale` by 10\n+        k += 1;\n+    } else {\n+        mant.mul_small(10);\n+    }\n+\n+    // if we are working with the last-digit limitation, we need to shorten the buffer\n+    // before the actual rendering in order to avoid double rounding.\n+    // note that we have to enlarge the buffer again when rounding up happens!\n+    let mut len = if k < limit {\n+        // oops, we cannot even produce *one* digit.\n+        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n+        // we return an empty buffer, with an exception of the later rounding-up case\n+        // which occurs when `k == limit` and has to produce exactly one digit.\n+        0\n+    } else if ((k as i32 - limit as i32) as usize) < buf.len() {\n+        (k - limit) as usize\n+    } else {\n+        buf.len()\n+    };\n+\n+    if len > 0 {\n+        // cache `(2, 4, 8) * scale` for digit generation.\n+        // (this can be expensive, so do not calculate them when the buffer is empty.)\n+        let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n+        let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n+        let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+\n+        for i in 0..len {\n+            if mant.is_zero() { // following digits are all zeroes, we stop here\n+                // do *not* try to perform rounding! rather, fill remaining digits.\n+                for c in &mut buf[i..len] { *c = b'0'; }\n+                return (len, k);\n+            }\n+\n+            let mut d = 0;\n+            if mant >= scale8 { mant.sub(&scale8); d += 8; }\n+            if mant >= scale4 { mant.sub(&scale4); d += 4; }\n+            if mant >= scale2 { mant.sub(&scale2); d += 2; }\n+            if mant >= scale  { mant.sub(&scale);  d += 1; }\n+            debug_assert!(mant < scale);\n+            debug_assert!(d < 10);\n+            buf[i] = b'0' + d;\n+            mant.mul_small(10);\n+        }\n+    }\n+\n+    // rounding up if we stop in the middle of digits\n+    // if the following digits are exactly 5000..., check the prior digit and try to\n+    // round to even (i.e. avoid rounding up when the prior digit is even).\n+    let order = mant.cmp(scale.mul_small(5));\n+    if order == Ordering::Greater || (order == Ordering::Equal &&\n+                                      (len == 0 || buf[len-1] & 1 == 1)) {\n+        // if rounding up changes the length, the exponent should also change.\n+        // but we've been requested a fixed number of digits, so do not alter the buffer...\n+        if let Some(c) = round_up(buf, len) {\n+            // ...unless we've been requested the fixed precision instead.\n+            // we also need to check that, if the original buffer was empty,\n+            // the additional digit can only be added when `k == limit` (edge case).\n+            k += 1;\n+            if k > limit && len < buf.len() {\n+                buf[len] = c;\n+                len += 1;\n+            }\n+        }\n+    }\n+\n+    (len, k)\n+}\n+"}, {"sha": "220811e9985c33c8843e3ed78e41c450538ef04f", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "added", "additions": 749, "deletions": 0, "changes": 749, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,749 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Rust adaptation of Grisu3 algorithm described in [1]. It uses about\n+1KB of precomputed table, and in turn, it's very quick for most inputs.\n+\n+[1] Florian Loitsch. 2010. Printing floating-point numbers quickly and\n+    accurately with integers. SIGPLAN Not. 45, 6 (June 2010), 233-243.\n+*/\n+\n+use prelude::*;\n+use num::Float;\n+\n+use num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n+\n+/// A custom 64-bit floating point type, representing `f * 2^e`.\n+#[derive(Copy, Clone, Debug)]\n+#[doc(hidden)]\n+pub struct Fp {\n+    /// The integer mantissa.\n+    pub f: u64,\n+    /// The exponent in base 2.\n+    pub e: i16,\n+}\n+\n+impl Fp {\n+    /// Returns a correctly rounded product of itself and `other`.\n+    fn mul(&self, other: &Fp) -> Fp {\n+        const MASK: u64 = 0xffffffff;\n+        let a = self.f >> 32;\n+        let b = self.f & MASK;\n+        let c = other.f >> 32;\n+        let d = other.f & MASK;\n+        let ac = a * c;\n+        let bc = b * c;\n+        let ad = a * d;\n+        let bd = b * d;\n+        let tmp = (bd >> 32) + (ad & MASK) + (bc & MASK) + (1 << 31) /* round */;\n+        let f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);\n+        let e = self.e + other.e + 64;\n+        Fp { f: f, e: e }\n+    }\n+\n+    /// Normalizes itself so that the resulting mantissa is at least `2^63`.\n+    fn normalize(&self) -> Fp {\n+        let mut f = self.f;\n+        let mut e = self.e;\n+        if f >> (64 - 32) == 0 { f <<= 32; e -= 32; }\n+        if f >> (64 - 16) == 0 { f <<= 16; e -= 16; }\n+        if f >> (64 -  8) == 0 { f <<=  8; e -=  8; }\n+        if f >> (64 -  4) == 0 { f <<=  4; e -=  4; }\n+        if f >> (64 -  2) == 0 { f <<=  2; e -=  2; }\n+        if f >> (64 -  1) == 0 { f <<=  1; e -=  1; }\n+        debug_assert!(f >= (1 >> 63));\n+        Fp { f: f, e: e }\n+    }\n+\n+    /// Normalizes itself to have the shared exponent.\n+    /// It can only decrease the exponent (and thus increase the mantissa).\n+    fn normalize_to(&self, e: i16) -> Fp {\n+        let edelta = self.e - e;\n+        assert!(edelta >= 0);\n+        let edelta = edelta as usize;\n+        assert_eq!(self.f << edelta >> edelta, self.f);\n+        Fp { f: self.f << edelta, e: e }\n+    }\n+}\n+\n+// see the comments in `format_shortest_opt` for the rationale.\n+#[doc(hidden)] pub const ALPHA: i16 = -60;\n+#[doc(hidden)] pub const GAMMA: i16 = -32;\n+\n+/*\n+# the following Python code generates this table:\n+for i in xrange(-308, 333, 8):\n+    if i >= 0: f = 10**i; e = 0\n+    else: f = 2**(80-4*i) // 10**-i; e = 4 * i - 80\n+    l = f.bit_length()\n+    f = ((f << 64 >> (l-1)) + 1) >> 1; e += l - 64\n+    print '    (%#018x, %5d, %4d),' % (f, e, i)\n+*/\n+// FIXME(#22540) const ref to static array seems to ICE\n+#[doc(hidden)]\n+pub static CACHED_POW10: [(u64, i16, i16); 81] = [ // (f, e, k)\n+    (0xe61acf033d1a45df, -1087, -308),\n+    (0xab70fe17c79ac6ca, -1060, -300),\n+    (0xff77b1fcbebcdc4f, -1034, -292),\n+    (0xbe5691ef416bd60c, -1007, -284),\n+    (0x8dd01fad907ffc3c,  -980, -276),\n+    (0xd3515c2831559a83,  -954, -268),\n+    (0x9d71ac8fada6c9b5,  -927, -260),\n+    (0xea9c227723ee8bcb,  -901, -252),\n+    (0xaecc49914078536d,  -874, -244),\n+    (0x823c12795db6ce57,  -847, -236),\n+    (0xc21094364dfb5637,  -821, -228),\n+    (0x9096ea6f3848984f,  -794, -220),\n+    (0xd77485cb25823ac7,  -768, -212),\n+    (0xa086cfcd97bf97f4,  -741, -204),\n+    (0xef340a98172aace5,  -715, -196),\n+    (0xb23867fb2a35b28e,  -688, -188),\n+    (0x84c8d4dfd2c63f3b,  -661, -180),\n+    (0xc5dd44271ad3cdba,  -635, -172),\n+    (0x936b9fcebb25c996,  -608, -164),\n+    (0xdbac6c247d62a584,  -582, -156),\n+    (0xa3ab66580d5fdaf6,  -555, -148),\n+    (0xf3e2f893dec3f126,  -529, -140),\n+    (0xb5b5ada8aaff80b8,  -502, -132),\n+    (0x87625f056c7c4a8b,  -475, -124),\n+    (0xc9bcff6034c13053,  -449, -116),\n+    (0x964e858c91ba2655,  -422, -108),\n+    (0xdff9772470297ebd,  -396, -100),\n+    (0xa6dfbd9fb8e5b88f,  -369,  -92),\n+    (0xf8a95fcf88747d94,  -343,  -84),\n+    (0xb94470938fa89bcf,  -316,  -76),\n+    (0x8a08f0f8bf0f156b,  -289,  -68),\n+    (0xcdb02555653131b6,  -263,  -60),\n+    (0x993fe2c6d07b7fac,  -236,  -52),\n+    (0xe45c10c42a2b3b06,  -210,  -44),\n+    (0xaa242499697392d3,  -183,  -36),\n+    (0xfd87b5f28300ca0e,  -157,  -28),\n+    (0xbce5086492111aeb,  -130,  -20),\n+    (0x8cbccc096f5088cc,  -103,  -12),\n+    (0xd1b71758e219652c,   -77,   -4),\n+    (0x9c40000000000000,   -50,    4),\n+    (0xe8d4a51000000000,   -24,   12),\n+    (0xad78ebc5ac620000,     3,   20),\n+    (0x813f3978f8940984,    30,   28),\n+    (0xc097ce7bc90715b3,    56,   36),\n+    (0x8f7e32ce7bea5c70,    83,   44),\n+    (0xd5d238a4abe98068,   109,   52),\n+    (0x9f4f2726179a2245,   136,   60),\n+    (0xed63a231d4c4fb27,   162,   68),\n+    (0xb0de65388cc8ada8,   189,   76),\n+    (0x83c7088e1aab65db,   216,   84),\n+    (0xc45d1df942711d9a,   242,   92),\n+    (0x924d692ca61be758,   269,  100),\n+    (0xda01ee641a708dea,   295,  108),\n+    (0xa26da3999aef774a,   322,  116),\n+    (0xf209787bb47d6b85,   348,  124),\n+    (0xb454e4a179dd1877,   375,  132),\n+    (0x865b86925b9bc5c2,   402,  140),\n+    (0xc83553c5c8965d3d,   428,  148),\n+    (0x952ab45cfa97a0b3,   455,  156),\n+    (0xde469fbd99a05fe3,   481,  164),\n+    (0xa59bc234db398c25,   508,  172),\n+    (0xf6c69a72a3989f5c,   534,  180),\n+    (0xb7dcbf5354e9bece,   561,  188),\n+    (0x88fcf317f22241e2,   588,  196),\n+    (0xcc20ce9bd35c78a5,   614,  204),\n+    (0x98165af37b2153df,   641,  212),\n+    (0xe2a0b5dc971f303a,   667,  220),\n+    (0xa8d9d1535ce3b396,   694,  228),\n+    (0xfb9b7cd9a4a7443c,   720,  236),\n+    (0xbb764c4ca7a44410,   747,  244),\n+    (0x8bab8eefb6409c1a,   774,  252),\n+    (0xd01fef10a657842c,   800,  260),\n+    (0x9b10a4e5e9913129,   827,  268),\n+    (0xe7109bfba19c0c9d,   853,  276),\n+    (0xac2820d9623bf429,   880,  284),\n+    (0x80444b5e7aa7cf85,   907,  292),\n+    (0xbf21e44003acdd2d,   933,  300),\n+    (0x8e679c2f5e44ff8f,   960,  308),\n+    (0xd433179d9c8cb841,   986,  316),\n+    (0x9e19db92b4e31ba9,  1013,  324),\n+    (0xeb96bf6ebadf77d9,  1039,  332),\n+];\n+\n+#[doc(hidden)] pub const CACHED_POW10_FIRST_E: i16 = -1087;\n+#[doc(hidden)] pub const CACHED_POW10_LAST_E: i16 = 1039;\n+\n+#[doc(hidden)]\n+pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) {\n+    let offset = CACHED_POW10_FIRST_E as i32;\n+    let range = (CACHED_POW10.len() as i32) - 1;\n+    let domain = (CACHED_POW10_LAST_E - CACHED_POW10_FIRST_E) as i32;\n+    let idx = ((gamma as i32) - offset) * range / domain;\n+    let (f, e, k) = CACHED_POW10[idx as usize];\n+    debug_assert!(alpha <= e && e <= gamma);\n+    (k, Fp { f: f, e: e })\n+}\n+\n+/// Given `x > 0`, returns `(k, 10^k)` such that `10^k <= x < 10^(k+1)`.\n+#[doc(hidden)]\n+pub fn max_pow10_no_more_than(x: u32) -> (u8, u32) {\n+    debug_assert!(x > 0);\n+\n+    const X9: u32 = 10_0000_0000;\n+    const X8: u32 =  1_0000_0000;\n+    const X7: u32 =    1000_0000;\n+    const X6: u32 =     100_0000;\n+    const X5: u32 =      10_0000;\n+    const X4: u32 =       1_0000;\n+    const X3: u32 =         1000;\n+    const X2: u32 =          100;\n+    const X1: u32 =           10;\n+\n+    if x < X4 {\n+        if x < X2 { if x < X1 {(0,  1)} else {(1, X1)} }\n+        else      { if x < X3 {(2, X2)} else {(3, X3)} }\n+    } else {\n+        if x < X6      { if x < X5 {(4, X4)} else {(5, X5)} }\n+        else if x < X8 { if x < X7 {(6, X6)} else {(7, X7)} }\n+        else           { if x < X9 {(8, X8)} else {(9, X9)} }\n+    }\n+}\n+\n+/// The shortest mode implementation for Grisu.\n+///\n+/// It returns `None` when it would return an inexact representation otherwise.\n+pub fn format_shortest_opt(d: &Decoded,\n+                           buf: &mut [u8]) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+    assert!(d.mant > 0);\n+    assert!(d.minus > 0);\n+    assert!(d.plus > 0);\n+    assert!(d.mant.checked_add(d.plus).is_some());\n+    assert!(d.mant.checked_sub(d.minus).is_some());\n+    assert!(buf.len() >= MAX_SIG_DIGITS);\n+    assert!(d.mant + d.plus < (1 << 61)); // we need at least three bits of additional precision\n+\n+    // start with the normalized values with the shared exponent\n+    let plus = Fp { f: d.mant + d.plus, e: d.exp }.normalize();\n+    let minus = Fp { f: d.mant - d.minus, e: d.exp }.normalize_to(plus.e);\n+    let v = Fp { f: d.mant, e: d.exp }.normalize_to(plus.e);\n+\n+    // find any `cached = 10^minusk` such that `ALPHA <= minusk + plus.e + 64 <= GAMMA`.\n+    // since `plus` is normalized, this means `2^(62 + ALPHA) <= plus * cached < 2^(64 + GAMMA)`;\n+    // given our choices of `ALPHA` and `GAMMA`, this puts `plus * cached` into `[4, 2^32)`.\n+    //\n+    // it is obviously desirable to maximize `GAMMA - ALPHA`,\n+    // so that we don't need many cached powers of 10, but there are some considerations:\n+    //\n+    // 1. we want to keep `floor(plus * cached)` within `u32` since it needs a costly division.\n+    //    (this is not really avoidable, remainder is required for accuracy estimation.)\n+    // 2. the remainder of `floor(plus * cached)` repeatedly gets multiplied by 10,\n+    //    and it should not overflow.\n+    //\n+    // the first gives `64 + GAMMA <= 32`, while the second gives `10 * 2^-ALPHA <= 2^64`;\n+    // -60 and -32 is the maximal range with this constraint, and V8 also uses them.\n+    let (minusk, cached) = cached_power(ALPHA - plus.e - 64, GAMMA - plus.e - 64);\n+\n+    // scale fps. this gives the maximal error of 1 ulp (proved from Theorem 5.1).\n+    let plus = plus.mul(&cached);\n+    let minus = minus.mul(&cached);\n+    let v = v.mul(&cached);\n+    debug_assert_eq!(plus.e, minus.e);\n+    debug_assert_eq!(plus.e, v.e);\n+\n+    //         +- actual range of minus\n+    //   | <---|---------------------- unsafe region --------------------------> |\n+    //   |     |                                                                 |\n+    //   |  |<--->|  | <--------------- safe region ---------------> |           |\n+    //   |  |     |  |                                               |           |\n+    //   |1 ulp|1 ulp|                 |1 ulp|1 ulp|                 |1 ulp|1 ulp|\n+    //   |<--->|<--->|                 |<--->|<--->|                 |<--->|<--->|\n+    //   |-----|-----|-------...-------|-----|-----|-------...-------|-----|-----|\n+    //   |   minus   |                 |     v     |                 |   plus    |\n+    // minus1     minus0           v - 1 ulp   v + 1 ulp           plus0       plus1\n+    //\n+    // above `minus`, `v` and `plus` are *quantized* approximations (error < 1 ulp).\n+    // as we don't know the error is positive or negative, we use two approximations spaced equally\n+    // and have the maximal error of 2 ulps.\n+    //\n+    // the \"unsafe region\" is a liberal interval which we initially generate.\n+    // the \"safe region\" is a conservative interval which we only accept.\n+    // we start with the correct repr within the unsafe region, and try to find the closest repr\n+    // to `v` which is also within the safe region. if we can't, we give up.\n+    let plus1 = plus.f + 1;\n+//  let plus0 = plus.f - 1; // only for explanation\n+//  let minus0 = minus.f + 1; // only for explanation\n+    let minus1 = minus.f - 1;\n+    let e = -plus.e as usize; // shared exponent\n+\n+    // divide `plus1` into integral and fractional parts.\n+    // integral parts are guaranteed to fit in u32, since cached power guarantees `plus < 2^32`\n+    // and normalized `plus.f` is always less than `2^64 - 2^4` due to the precision requirement.\n+    let plus1int = (plus1 >> e) as u32;\n+    let plus1frac = plus1 & ((1 << e) - 1);\n+\n+    // calculate the largest `10^max_kappa` no more than `plus1` (thus `plus1 < 10^(max_kappa+1)`).\n+    // this is an upper bound of `kappa` below.\n+    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(plus1int);\n+\n+    let mut i = 0;\n+    let exp = max_kappa as i16 - minusk + 1;\n+\n+    // Theorem 6.2: if `k` is the greatest integer s.t. `0 <= y mod 10^k <= y - x`,\n+    //              then `V = floor(y / 10^k) * 10^k` is in `[x, y]` and one of the shortest\n+    //              representations (with the minimal number of significant digits) in that range.\n+    //\n+    // find the digit length `kappa` between `(minus1, plus1)` as per Theorem 6.2.\n+    // Theorem 6.2 can be adopted to exclude `x` by requiring `y mod 10^k < y - x` instead.\n+    // (e.g. `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n+    // the algorithm relies on the later verification phase to exclude `y`.\n+    let delta1 = plus1 - minus1;\n+//  let delta1int = (delta1 >> e) as usize; // only for explanation\n+    let delta1frac = delta1 & ((1 << e) - 1);\n+\n+    // render integral parts, while checking for the accuracy at each step.\n+    let mut kappa = max_kappa as i16;\n+    let mut ten_kappa = max_ten_kappa; // 10^kappa\n+    let mut remainder = plus1int; // digits yet to be rendered\n+    loop { // we always have at least one digit to render, as `plus1 >= 10^kappa`\n+        // invariants:\n+        // - `delta1int <= remainder < 10^(kappa+1)`\n+        // - `plus1int = d[0..n-1] * 10^(kappa+1) + remainder`\n+        //   (it follows that `remainder = plus1int % 10^(kappa+1)`)\n+\n+        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n+        let q = remainder / ten_kappa;\n+        let r = remainder % ten_kappa;\n+        debug_assert!(q < 10);\n+        buf[i] = b'0' + q as u8;\n+        i += 1;\n+\n+        let plus1rem = ((r as u64) << e) + plus1frac; // == (plus1 % 10^kappa) * 2^e\n+        if plus1rem < delta1 {\n+            // `plus1 % 10^kappa < delta1 = plus1 - minus1`; we've found the correct `kappa`.\n+            let ten_kappa = (ten_kappa as u64) << e; // scale 10^kappa back to the shared exponent\n+            return round_and_weed(&mut buf[..i], exp, plus1rem, delta1, plus1 - v.f, ten_kappa, 1);\n+        }\n+\n+        // break the loop when we have rendered all integral digits.\n+        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n+        if i > max_kappa as usize {\n+            debug_assert_eq!(ten_kappa, 1);\n+            debug_assert_eq!(kappa, 0);\n+            break;\n+        }\n+\n+        // restore invariants\n+        kappa -= 1;\n+        ten_kappa /= 10;\n+        remainder = r;\n+    }\n+\n+    // render fractional parts, while checking for the accuracy at each step.\n+    // this time we rely on repeated multiplications, as division will lose the precision.\n+    let mut remainder = plus1frac;\n+    let mut threshold = delta1frac;\n+    let mut ulp = 1;\n+    loop { // the next digit should be significant as we've tested that before breaking out\n+        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n+        // - `remainder < 2^e`\n+        // - `plus1frac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n+\n+        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n+        threshold *= 10;\n+        ulp *= 10;\n+\n+        // divide `remainder` by `10^kappa`.\n+        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n+        let q = remainder >> e;\n+        let r = remainder & ((1 << e) - 1);\n+        debug_assert!(q < 10);\n+        buf[i] = b'0' + q as u8;\n+        i += 1;\n+\n+        if r < threshold {\n+            let ten_kappa = 1 << e; // implicit divisor\n+            return round_and_weed(&mut buf[..i], exp, r, threshold,\n+                                  (plus1 - v.f) * ulp, ten_kappa, ulp);\n+        }\n+\n+        // restore invariants\n+        kappa -= 1;\n+        remainder = r;\n+    }\n+\n+    // we've generated all significant digits of `plus1`, but not sure if it's the optimal one.\n+    // for example, if `minus1` is 3.14153... and `plus1` is 3.14158..., there are 5 different\n+    // shortest representation from 3.14154 to 3.14158 but we only have the greatest one.\n+    // we have to successively decrease the last digit and check if this is the optimal repr.\n+    // there are at most 9 candidates (..1 to ..9), so this is fairly quick. (\"rounding\" phase)\n+    //\n+    // the function checks if this \"optimal\" repr is actually within the ulp ranges,\n+    // and also, it is possible that the \"second-to-optimal\" repr can actually be optimal\n+    // due to the rounding error. in either cases this returns `None`. (\"weeding\" phase)\n+    //\n+    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n+    // - `remainder = (plus1 % 10^kappa) * k`\n+    // - `threshold = (plus1 - minus1) * k` (and also, `remainder < threshold`)\n+    // - `plus1v = (plus1 - v) * k` (and also, `threshold > plus1v` from prior invariants)\n+    // - `ten_kappa = 10^kappa * k`\n+    // - `ulp = 2^-e * k`\n+    fn round_and_weed(buf: &mut [u8], exp: i16, remainder: u64, threshold: u64, plus1v: u64,\n+                      ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+        assert!(!buf.is_empty());\n+\n+        // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n+        // the resulting representation should be the closest representation to both.\n+        //\n+        // here `plus1 - v` is used since calculations are done with respect to `plus1`\n+        // in order to avoid overflow/underflow (hence the seemingly swapped names).\n+        let plus1v_down = plus1v + ulp; // plus1 - (v - 1 ulp)\n+        let plus1v_up = plus1v - ulp; // plus1 - (v + 1 ulp)\n+\n+        // decrease the last digit and stop at the closest representation to `v + 1 ulp`.\n+        let mut plus1w = remainder; // plus1w(n) = plus1 - w(n)\n+        {\n+            let last = buf.last_mut().unwrap();\n+\n+            // we work with the approximated digits `w(n)`, which is initially equal to `plus1 -\n+            // plus1 % 10^kappa`. after running the loop body `n` times, `w(n) = plus1 -\n+            // plus1 % 10^kappa - n * 10^kappa`. we set `plus1w(n) = plus1 - w(n) =\n+            // plus1 % 10^kappa + n * 10^kappa` (thus `remainder = plus1w(0)`) to simplify checks.\n+            // note that `plus1w(n)` is always increasing.\n+            //\n+            // we have three conditions to terminate. any of them will make the loop unable to\n+            // proceed, but we then have at least one valid representation known to be closest to\n+            // `v + 1 ulp` anyway. we will denote them as TC1 through TC3 for brevity.\n+            //\n+            // TC1: `w(n) <= v + 1 ulp`, i.e. this is the last repr that can be the closest one.\n+            // this is equivalent to `plus1 - w(n) = plus1w(n) >= plus1 - (v + 1 ulp) = plus1v_up`.\n+            // combined with TC2 (which checks if `w(n+1)` is valid), this prevents the possible\n+            // overflow on the calculation of `plus1w(n)`.\n+            //\n+            // TC2: `w(n+1) < minus1`, i.e. the next repr definitely does not round to `v`.\n+            // this is equivalent to `plus1 - w(n) + 10^kappa = plus1w(n) + 10^kappa >\n+            // plus1 - minus1 = threshold`. the left hand side can overflow, but we know\n+            // `threshold > plus1v`, so if TC1 is false, `threshold - plus1w(n) >\n+            // threshold - (plus1v - 1 ulp) > 1 ulp` and we can safely test if\n+            // `threshold - plus1w(n) < 10^kappa` instead.\n+            //\n+            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e. the next repr is\n+            // no closer to `v + 1 ulp` than the current repr. given `z(n) = plus1v_up - plus1w(n)`,\n+            // this becomes `abs(z(n)) <= abs(z(n+1))`. again assuming that TC1 is false, we have\n+            // `z(n) > 0`. we have two cases to consider:\n+            //\n+            // - when `z(n+1) >= 0`: TC3 becomes `z(n) <= z(n+1)`. as `plus1w(n)` is increasing,\n+            //   `z(n)` should be decreasing and this is clearly false.\n+            // - when `z(n+1) < 0`:\n+            //   - TC3a: the precondition is `plus1v_up < plus1w(n) + 10^kappa`. assuming TC2 is\n+            //     false, `threshold >= plus1w(n) + 10^kappa` so it cannot overflow.\n+            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e. `plus1v_up - plus1w(n) >=\n+            //     plus1w(n+1) - plus1v_up = plus1w(n) + 10^kappa - plus1v_up`. the negated TC1\n+            //     gives `plus1v_up > plus1w(n)`, so it cannot overflow or underflow when\n+            //     combined with TC3a.\n+            //\n+            // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n+            // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n+            while plus1w < plus1v_up &&\n+                  threshold - plus1w >= ten_kappa &&\n+                  (plus1w + ten_kappa < plus1v_up ||\n+                   plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up) {\n+                *last -= 1;\n+                debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n+                plus1w += ten_kappa;\n+            }\n+        }\n+\n+        // check if this representation is also the closest representation to `v - 1 ulp`.\n+        //\n+        // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n+        // replaced by `plus1v_down` instead. overflow analysis equally holds.\n+        if plus1w < plus1v_down &&\n+           threshold - plus1w >= ten_kappa &&\n+           (plus1w + ten_kappa < plus1v_down ||\n+            plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down) {\n+            return None;\n+        }\n+\n+        // now we have the closest representation to `v` between `plus1` and `minus1`.\n+        // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n+        // i.e. `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n+        // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n+        if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp {\n+            Some((buf.len(), exp))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// The shortest mode implementation for Grisu with Dragon fallback.\n+///\n+/// This should be used for most cases.\n+pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp*/ i16) {\n+    use num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    match format_shortest_opt(d, buf) {\n+        Some(ret) => ret,\n+        None => fallback(d, buf),\n+    }\n+}\n+\n+/// The exact and fixed mode implementation for Grisu.\n+///\n+/// It returns `None` when it would return an inexact representation otherwise.\n+pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n+                                -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+    assert!(d.mant > 0);\n+    assert!(d.mant < (1 << 61)); // we need at least three bits of additional precision\n+    assert!(!buf.is_empty());\n+\n+    // normalize and scale `v`.\n+    let v = Fp { f: d.mant, e: d.exp }.normalize();\n+    let (minusk, cached) = cached_power(ALPHA - v.e - 64, GAMMA - v.e - 64);\n+    let v = v.mul(&cached);\n+\n+    // divide `v` into integral and fractional parts.\n+    let e = -v.e as usize;\n+    let vint = (v.f >> e) as u32;\n+    let vfrac = v.f & ((1 << e) - 1);\n+\n+    // both old `v` and new `v` (scaled by `10^-k`) has an error of < 1 ulp (Theorem 5.1).\n+    // as we don't know the error is positive or negative, we use two approximations\n+    // spaced equally and have the maximal error of 2 ulps (same to the shortest case).\n+    //\n+    // the goal is to find the exactly rounded series of digits that are common to\n+    // both `v - 1 ulp` and `v + 1 ulp`, so that we are maximally confident.\n+    // if this is not possible, we don't know which one is the correct output for `v`,\n+    // so we give up and fall back.\n+    //\n+    // `err` is defined as `1 ulp * 2^e` here (same to the ulp in `vfrac`),\n+    // and we will scale it whenever `v` gets scaled.\n+    let mut err = 1;\n+\n+    // calculate the largest `10^max_kappa` no more than `v` (thus `v < 10^(max_kappa+1)`).\n+    // this is an upper bound of `kappa` below.\n+    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(vint);\n+\n+    let mut i = 0;\n+    let exp = max_kappa as i16 - minusk + 1;\n+\n+    // if we are working with the last-digit limitation, we need to shorten the buffer\n+    // before the actual rendering in order to avoid double rounding.\n+    // note that we have to enlarge the buffer again when rounding up happens!\n+    let len = if exp <= limit {\n+        // oops, we cannot even produce *one* digit.\n+        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n+        //\n+        // in principle we can immediately call `possibly_round` with an empty buffer,\n+        // but scaling `max_ten_kappa << e` by 10 can result in overflow.\n+        // thus we are being sloppy here and widen the error range by a factor of 10.\n+        // this will increase the false negative rate, but only very, *very* slightly;\n+        // it can only matter noticably when the mantissa is bigger than 60 bits.\n+        return possibly_round(buf, 0, exp, limit, v.f / 10, (max_ten_kappa as u64) << e, err << e);\n+    } else if ((exp as i32 - limit as i32) as usize) < buf.len() {\n+        (exp - limit) as usize\n+    } else {\n+        buf.len()\n+    };\n+    debug_assert!(len > 0);\n+\n+    // render integral parts.\n+    // the error is entirely fractional, so we don't need to check it in this part.\n+    let mut kappa = max_kappa as i16;\n+    let mut ten_kappa = max_ten_kappa; // 10^kappa\n+    let mut remainder = vint; // digits yet to be rendered\n+    loop { // we always have at least one digit to render\n+        // invariants:\n+        // - `remainder < 10^(kappa+1)`\n+        // - `vint = d[0..n-1] * 10^(kappa+1) + remainder`\n+        //   (it follows that `remainder = vint % 10^(kappa+1)`)\n+\n+        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n+        let q = remainder / ten_kappa;\n+        let r = remainder % ten_kappa;\n+        debug_assert!(q < 10);\n+        buf[i] = b'0' + q as u8;\n+        i += 1;\n+\n+        // is the buffer full? run the rounding pass with the remainder.\n+        if i == len {\n+            let vrem = ((r as u64) << e) + vfrac; // == (v % 10^kappa) * 2^e\n+            return possibly_round(buf, len, exp, limit, vrem, (ten_kappa as u64) << e, err << e);\n+        }\n+\n+        // break the loop when we have rendered all integral digits.\n+        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n+        if i > max_kappa as usize {\n+            debug_assert_eq!(ten_kappa, 1);\n+            debug_assert_eq!(kappa, 0);\n+            break;\n+        }\n+\n+        // restore invariants\n+        kappa -= 1;\n+        ten_kappa /= 10;\n+        remainder = r;\n+    }\n+\n+    // render fractional parts.\n+    //\n+    // in principle we can continue to the last available digit and check for the accuracy.\n+    // unfortunately we are working with the finite-sized integers, so we need some criterion\n+    // to detect the overflow. V8 uses `remainder > err`, which becomes false when\n+    // the first `i` significant digits of `v - 1 ulp` and `v` differ. however this rejects\n+    // too many otherwise valid input.\n+    //\n+    // since the later phase has a correct overflow detection, we instead use tighter criterion:\n+    // we continue til `err` exceeds `10^kappa / 2`, so that the range between `v - 1 ulp` and\n+    // `v + 1 ulp` definitely contains two or more rounded representations. this is same to\n+    // the first two comparisons from `possibly_round`, for the reference.\n+    let mut remainder = vfrac;\n+    let maxerr = 1 << (e - 1);\n+    while err < maxerr {\n+        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n+        // - `remainder < 2^e`\n+        // - `vfrac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n+        // - `err = 10^(n-m)`\n+\n+        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n+        err *= 10; // won't overflow, `err * 10 < 2^e * 5 < 2^64`\n+\n+        // divide `remainder` by `10^kappa`.\n+        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n+        let q = remainder >> e;\n+        let r = remainder & ((1 << e) - 1);\n+        debug_assert!(q < 10);\n+        buf[i] = b'0' + q as u8;\n+        i += 1;\n+\n+        // is the buffer full? run the rounding pass with the remainder.\n+        if i == len {\n+            return possibly_round(buf, len, exp, limit, r, 1 << e, err);\n+        }\n+\n+        // restore invariants\n+        remainder = r;\n+    }\n+\n+    // further calculation is useless (`possibly_round` definitely fails), so we give up.\n+    return None;\n+\n+    // we've generated all requested digits of `v`, which should be also same to corresponding\n+    // digits of `v - 1 ulp`. now we check if there is a unique representation shared by\n+    // both `v - 1 ulp` and `v + 1 ulp`; this can be either same to generated digits, or\n+    // to the rounded-up version of those digits. if the range contains multiple representations\n+    // of the same length, we cannot be sure and should return `None` instead.\n+    //\n+    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n+    // - `remainder = (v % 10^kappa) * k`\n+    // - `ten_kappa = 10^kappa * k`\n+    // - `ulp = 2^-e * k`\n+    fn possibly_round(buf: &mut [u8], mut len: usize, mut exp: i16, limit: i16,\n+                      remainder: u64, ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+        debug_assert!(remainder < ten_kappa);\n+\n+        //           10^kappa\n+        //    :   :   :<->:   :\n+        //    :   :   :   :   :\n+        //    :|1 ulp|1 ulp|  :\n+        //    :|<--->|<--->|  :\n+        // ----|-----|-----|----\n+        //     |     v     |\n+        // v - 1 ulp   v + 1 ulp\n+        //\n+        // (for the reference, the dotted line indicates the exact value for\n+        // possible representations in given number of digits.)\n+        //\n+        // error is too large that there are at least three possible representations\n+        // between `v - 1 ulp` and `v + 1 ulp`. we cannot determine which one is correct.\n+        if ulp >= ten_kappa { return None; }\n+\n+        //    10^kappa\n+        //   :<------->:\n+        //   :         :\n+        //   : |1 ulp|1 ulp|\n+        //   : |<--->|<--->|\n+        // ----|-----|-----|----\n+        //     |     v     |\n+        // v - 1 ulp   v + 1 ulp\n+        //\n+        // in fact, 1/2 ulp is enough to introduce two possible representations.\n+        // (remember that we need a unique representation for both `v - 1 ulp` and `v + 1 ulp`.)\n+        // this won't overflow, as `ulp < ten_kappa` from the first check.\n+        if ten_kappa - ulp <= ulp { return None; }\n+\n+        //     remainder\n+        //       :<->|                           :\n+        //       :   |                           :\n+        //       :<--------- 10^kappa ---------->:\n+        //     | :   |                           :\n+        //     |1 ulp|1 ulp|                     :\n+        //     |<--->|<--->|                     :\n+        // ----|-----|-----|------------------------\n+        //     |     v     |\n+        // v - 1 ulp   v + 1 ulp\n+        //\n+        // if `v + 1 ulp` is closer to the rounded-down representation (which is already in `buf`),\n+        // then we can safely return. note that `v - 1 ulp` *can* be less than the current\n+        // representation, but as `1 ulp < 10^kappa / 2`, this condition is enough:\n+        // the distance between `v - 1 ulp` and the current representation\n+        // cannot exceed `10^kappa / 2`.\n+        //\n+        // the condition equals to `remainder + ulp < 10^kappa / 2`.\n+        // since this can easily overflow, first check if `remainder < 10^kappa / 2`.\n+        // we've already verified that `ulp < 10^kappa / 2`, so as long as\n+        // `10^kappa` did not overflow after all, the second check is fine.\n+        if ten_kappa - remainder > remainder && ten_kappa - 2 * remainder >= 2 * ulp {\n+            return Some((len, exp));\n+        }\n+\n+        //   :<------- remainder ------>|   :\n+        //   :                          |   :\n+        //   :<--------- 10^kappa --------->:\n+        //   :                    |     |   : |\n+        //   :                    |1 ulp|1 ulp|\n+        //   :                    |<--->|<--->|\n+        // -----------------------|-----|-----|-----\n+        //                        |     v     |\n+        //                    v - 1 ulp   v + 1 ulp\n+        //\n+        // on the other hands, if `v - 1 ulp` is closer to the rounded-up representation,\n+        // we should round up and return. for the same reason we don't need to check `v + 1 ulp`.\n+        //\n+        // the condition equals to `remainder - ulp >= 10^kappa / 2`.\n+        // again we first check if `remainder > ulp` (note that this is not `remainder >= ulp`,\n+        // as `10^kappa` is never zero). also note that `remainder - ulp <= 10^kappa`,\n+        // so the second check does not overflow.\n+        if remainder > ulp && ten_kappa - (remainder - ulp) <= remainder - ulp {\n+            if let Some(c) = round_up(buf, len) {\n+                // only add an additional digit when we've been requested the fixed precision.\n+                // we also need to check that, if the original buffer was empty,\n+                // the additional digit can only be added when `exp == limit` (edge case).\n+                exp += 1;\n+                if exp > limit && len < buf.len() {\n+                    buf[len] = c;\n+                    len += 1;\n+                }\n+            }\n+            return Some((len, exp));\n+        }\n+\n+        // otherwise we are doomed (i.e. some values between `v - 1 ulp` and `v + 1 ulp` are\n+        // rounding down and others are rounding up) and give up.\n+        None\n+    }\n+}\n+\n+/// The exact and fixed mode implementation for Grisu with Dragon fallback.\n+///\n+/// This should be used for most cases.\n+pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usize, /*exp*/ i16) {\n+    use num::flt2dec::strategy::dragon::format_exact as fallback;\n+    match format_exact_opt(d, buf, limit) {\n+        Some(ret) => ret,\n+        None => fallback(d, buf, limit),\n+    }\n+}\n+"}, {"sha": "011830ddb7882d65da98c0c14b481cf6700e32ac", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -44,6 +44,9 @@ pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n #[unstable(feature = \"core\", reason = \"may be removed or relocated\")]\n pub mod wrapping;\n \n+#[unstable(feature = \"core\", reason = \"internal routines only exposed for testing\")]\n+pub mod flt2dec;\n+\n /// Types that have a \"zero\" value.\n ///\n /// This trait is intended for use in conjunction with `Add`, as an identity:"}, {"sha": "90c1e8b132e42be16975d4d66eb6996bd1ec2598", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -30,6 +30,7 @@ extern crate core;\n extern crate test;\n extern crate libc;\n extern crate rustc_unicode;\n+extern crate rand;\n \n mod any;\n mod atomic;"}, {"sha": "09a1ed41dadd17c7f0dcbc244096fd00b62b0e1d", "filename": "src/libcoretest/num/flt2dec/bignum.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::prelude::v1::*;\n+use core::num::flt2dec::bignum::tests::Big8x3 as Big;\n+\n+#[test]\n+#[should_panic]\n+fn test_from_u64_overflow() {\n+    Big::from_u64(0x1000000);\n+}\n+\n+#[test]\n+fn test_add() {\n+    assert_eq!(*Big::from_small(3).add(&Big::from_small(4)), Big::from_small(7));\n+    assert_eq!(*Big::from_small(3).add(&Big::from_small(0)), Big::from_small(3));\n+    assert_eq!(*Big::from_small(0).add(&Big::from_small(3)), Big::from_small(3));\n+    assert_eq!(*Big::from_small(3).add(&Big::from_u64(0xfffe)), Big::from_u64(0x10001));\n+    assert_eq!(*Big::from_u64(0xfedc).add(&Big::from_u64(0x789)), Big::from_u64(0x10665));\n+    assert_eq!(*Big::from_u64(0x789).add(&Big::from_u64(0xfedc)), Big::from_u64(0x10665));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_add_overflow_1() {\n+    Big::from_small(1).add(&Big::from_u64(0xffffff));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_add_overflow_2() {\n+    Big::from_u64(0xffffff).add(&Big::from_small(1));\n+}\n+\n+#[test]\n+fn test_sub() {\n+    assert_eq!(*Big::from_small(7).sub(&Big::from_small(4)), Big::from_small(3));\n+    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x789)), Big::from_u64(0xfedc));\n+    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0xfedc)), Big::from_u64(0x789));\n+    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x10664)), Big::from_small(1));\n+    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x10665)), Big::from_small(0));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_sub_underflow_1() {\n+    Big::from_u64(0x10665).sub(&Big::from_u64(0x10666));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_sub_underflow_2() {\n+    Big::from_small(0).sub(&Big::from_u64(0x123456));\n+}\n+\n+#[test]\n+fn test_mul_small() {\n+    assert_eq!(*Big::from_small(7).mul_small(5), Big::from_small(35));\n+    assert_eq!(*Big::from_small(0xff).mul_small(0xff), Big::from_u64(0xfe01));\n+    assert_eq!(*Big::from_u64(0xffffff/13).mul_small(13), Big::from_u64(0xffffff));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_small_overflow() {\n+    Big::from_u64(0x800000).mul_small(2);\n+}\n+\n+#[test]\n+fn test_mul_pow2() {\n+    assert_eq!(*Big::from_small(0x7).mul_pow2(4), Big::from_small(0x70));\n+    assert_eq!(*Big::from_small(0xff).mul_pow2(1), Big::from_u64(0x1fe));\n+    assert_eq!(*Big::from_small(0xff).mul_pow2(12), Big::from_u64(0xff000));\n+    assert_eq!(*Big::from_small(0x1).mul_pow2(23), Big::from_u64(0x800000));\n+    assert_eq!(*Big::from_u64(0x123).mul_pow2(0), Big::from_u64(0x123));\n+    assert_eq!(*Big::from_u64(0x123).mul_pow2(7), Big::from_u64(0x9180));\n+    assert_eq!(*Big::from_u64(0x123).mul_pow2(15), Big::from_u64(0x918000));\n+    assert_eq!(*Big::from_small(0).mul_pow2(23), Big::from_small(0));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_pow2_overflow_1() {\n+    Big::from_u64(0x1).mul_pow2(24);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_pow2_overflow_2() {\n+    Big::from_u64(0x123).mul_pow2(16);\n+}\n+\n+#[test]\n+fn test_mul_digits() {\n+    assert_eq!(*Big::from_small(3).mul_digits(&[5]), Big::from_small(15));\n+    assert_eq!(*Big::from_small(0xff).mul_digits(&[0xff]), Big::from_u64(0xfe01));\n+    assert_eq!(*Big::from_u64(0x123).mul_digits(&[0x56, 0x4]), Big::from_u64(0x4edc2));\n+    assert_eq!(*Big::from_u64(0x12345).mul_digits(&[0x67]), Big::from_u64(0x7530c3));\n+    assert_eq!(*Big::from_small(0x12).mul_digits(&[0x67, 0x45, 0x3]), Big::from_u64(0x3ae13e));\n+    assert_eq!(*Big::from_u64(0xffffff/13).mul_digits(&[13]), Big::from_u64(0xffffff));\n+    assert_eq!(*Big::from_small(13).mul_digits(&[0x3b, 0xb1, 0x13]), Big::from_u64(0xffffff));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_digits_overflow_1() {\n+    Big::from_u64(0x800000).mul_digits(&[2]);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_digits_overflow_2() {\n+    Big::from_u64(0x1000).mul_digits(&[0, 0x10]);\n+}\n+\n+#[test]\n+fn test_div_rem_small() {\n+    let as_val = |(q, r): (&mut Big, u8)| (q.clone(), r);\n+    assert_eq!(as_val(Big::from_small(0xff).div_rem_small(15)), (Big::from_small(17), 0));\n+    assert_eq!(as_val(Big::from_small(0xff).div_rem_small(16)), (Big::from_small(15), 15));\n+    assert_eq!(as_val(Big::from_small(3).div_rem_small(40)), (Big::from_small(0), 3));\n+    assert_eq!(as_val(Big::from_u64(0xffffff).div_rem_small(123)),\n+               (Big::from_u64(0xffffff / 123), (0xffffffu64 % 123) as u8));\n+    assert_eq!(as_val(Big::from_u64(0x10000).div_rem_small(123)),\n+               (Big::from_u64(0x10000 / 123), (0x10000u64 % 123) as u8));\n+}\n+\n+#[test]\n+fn test_is_zero() {\n+    assert!(Big::from_small(0).is_zero());\n+    assert!(!Big::from_small(3).is_zero());\n+    assert!(!Big::from_u64(0x123).is_zero());\n+    assert!(!Big::from_u64(0xffffff).sub(&Big::from_u64(0xfffffe)).is_zero());\n+    assert!(Big::from_u64(0xffffff).sub(&Big::from_u64(0xffffff)).is_zero());\n+}\n+\n+#[test]\n+fn test_ord() {\n+    assert!(Big::from_u64(0) < Big::from_u64(0xffffff));\n+    assert!(Big::from_u64(0x102) < Big::from_u64(0x201));\n+}\n+\n+#[test]\n+fn test_fmt() {\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0)), \"0x0\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x1)), \"0x1\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x12)), \"0x12\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x123)), \"0x1_23\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x1234)), \"0x12_34\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x12345)), \"0x1_23_45\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x123456)), \"0x12_34_56\");\n+}\n+"}, {"sha": "21260c520f6235e26f0129dd141dec9a07f58146", "filename": "src/libcoretest/num/flt2dec/estimator.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::f64;\n+use core::num::flt2dec::estimator::*;\n+\n+#[test]\n+fn test_estimate_scaling_factor() {\n+    macro_rules! assert_almost_eq {\n+        ($actual:expr, $expected:expr) => ({\n+            let actual = $actual;\n+            let expected = $expected;\n+            println!(\"{} - {} = {} - {} = {}\", stringify!($expected), stringify!($actual),\n+                     expected, actual, expected - actual);\n+            assert!(expected == actual || expected == actual + 1,\n+                    \"expected {}, actual {}\", expected, actual);\n+        })\n+    }\n+\n+    assert_almost_eq!(estimate_scaling_factor(1, 0), 0);\n+    assert_almost_eq!(estimate_scaling_factor(2, 0), 1);\n+    assert_almost_eq!(estimate_scaling_factor(10, 0), 1);\n+    assert_almost_eq!(estimate_scaling_factor(11, 0), 2);\n+    assert_almost_eq!(estimate_scaling_factor(100, 0), 2);\n+    assert_almost_eq!(estimate_scaling_factor(101, 0), 3);\n+    assert_almost_eq!(estimate_scaling_factor(10000000000000000000, 0), 19);\n+    assert_almost_eq!(estimate_scaling_factor(10000000000000000001, 0), 20);\n+\n+    // 1/2^20 = 0.00000095367...\n+    assert_almost_eq!(estimate_scaling_factor(1 * 1048576 / 1000000, -20), -6);\n+    assert_almost_eq!(estimate_scaling_factor(1 * 1048576 / 1000000 + 1, -20), -5);\n+    assert_almost_eq!(estimate_scaling_factor(10 * 1048576 / 1000000, -20), -5);\n+    assert_almost_eq!(estimate_scaling_factor(10 * 1048576 / 1000000 + 1, -20), -4);\n+    assert_almost_eq!(estimate_scaling_factor(100 * 1048576 / 1000000, -20), -4);\n+    assert_almost_eq!(estimate_scaling_factor(100 * 1048576 / 1000000 + 1, -20), -3);\n+    assert_almost_eq!(estimate_scaling_factor(1048575, -20), 0);\n+    assert_almost_eq!(estimate_scaling_factor(1048576, -20), 0);\n+    assert_almost_eq!(estimate_scaling_factor(1048577, -20), 1);\n+    assert_almost_eq!(estimate_scaling_factor(10485759999999999999, -20), 13);\n+    assert_almost_eq!(estimate_scaling_factor(10485760000000000000, -20), 13);\n+    assert_almost_eq!(estimate_scaling_factor(10485760000000000001, -20), 14);\n+\n+    // extreme values:\n+    // 2^-1074 = 4.94065... * 10^-324\n+    // (2^53-1) * 2^971 = 1.79763... * 10^308\n+    assert_almost_eq!(estimate_scaling_factor(1, -1074), -323);\n+    assert_almost_eq!(estimate_scaling_factor(0x1fffffffffffff, 971), 309);\n+\n+    for i in -1074..972 {\n+        let expected = f64::ldexp(1.0, i).log10().ceil();\n+        assert_almost_eq!(estimate_scaling_factor(1, i as i16), expected as i16);\n+    }\n+}\n+"}, {"sha": "488cd3a779ca30e30f94d5f8f7bbf6d3bb1eaa1c", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "added", "additions": 1178, "deletions": 0, "changes": 1178, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,1178 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::prelude::v1::*;\n+use std::{str, mem, i16, f32, f64, fmt};\n+use std::slice::bytes;\n+use std::__rand as rand;\n+use rand::{Rand, XorShiftRng};\n+use rand::distributions::{IndependentSample, Range};\n+\n+use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n+use core::num::flt2dec::{MAX_SIG_DIGITS, round_up, Part, Formatted, Sign};\n+use core::num::flt2dec::{to_shortest_str, to_shortest_exp_str,\n+                         to_exact_exp_str, to_exact_fixed_str};\n+\n+pub use test::Bencher;\n+\n+mod estimator;\n+mod bignum;\n+mod strategy {\n+    mod dragon;\n+    mod grisu;\n+}\n+\n+pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n+    match decode(v).1 {\n+        FullDecoded::Finite(decoded) => decoded,\n+        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded)\n+    }\n+}\n+\n+macro_rules! check_shortest {\n+    ($f:ident($v:expr) => $buf:expr, $exp:expr) => (\n+        check_shortest!($f($v) => $buf, $exp;\n+                        \"shortest mismatch for v={v}: actual {actual:?}, expected {expected:?}\",\n+                        v = stringify!($v))\n+    );\n+\n+    ($f:ident{$($k:ident: $v:expr),+} => $buf:expr, $exp:expr) => (\n+        check_shortest!($f{$($k: $v),+} => $buf, $exp;\n+                        \"shortest mismatch for {v:?}: actual {actual:?}, expected {expected:?}\",\n+                        v = Decoded { $($k: $v),+ })\n+    );\n+\n+    ($f:ident($v:expr) => $buf:expr, $exp:expr; $fmt:expr, $($key:ident = $val:expr),*) => ({\n+        let mut buf = [b'_'; MAX_SIG_DIGITS];\n+        let (len, k) = $f(&decode_finite($v), &mut buf);\n+        assert!((&buf[..len], k) == ($buf, $exp),\n+                $fmt, actual = (str::from_utf8(&buf[..len]).unwrap(), k),\n+                      expected = (str::from_utf8($buf).unwrap(), $exp),\n+                      $($key = $val),*);\n+    });\n+\n+    ($f:ident{$($k:ident: $v:expr),+} => $buf:expr, $exp:expr;\n+                                         $fmt:expr, $($key:ident = $val:expr),*) => ({\n+        let mut buf = [b'_'; MAX_SIG_DIGITS];\n+        let (len, k) = $f(&Decoded { $($k: $v),+ }, &mut buf);\n+        assert!((&buf[..len], k) == ($buf, $exp),\n+                $fmt, actual = (str::from_utf8(&buf[..len]).unwrap(), k),\n+                      expected = (str::from_utf8($buf).unwrap(), $exp),\n+                      $($key = $val),*);\n+    })\n+}\n+\n+macro_rules! try_exact {\n+    ($f:ident($decoded:expr) => $buf:expr, $expected:expr, $expectedk:expr;\n+                                $fmt:expr, $($key:ident = $val:expr),*) => ({\n+        let (len, k) = $f($decoded, &mut $buf[..$expected.len()], i16::MIN);\n+        assert!((&$buf[..len], k) == ($expected, $expectedk),\n+                $fmt, actual = (str::from_utf8(&$buf[..len]).unwrap(), k),\n+                      expected = (str::from_utf8($expected).unwrap(), $expectedk),\n+                      $($key = $val),*);\n+    })\n+}\n+\n+macro_rules! try_fixed {\n+    ($f:ident($decoded:expr) => $buf:expr, $request:expr, $expected:expr, $expectedk:expr;\n+                                $fmt:expr, $($key:ident = $val:expr),*) => ({\n+        let (len, k) = $f($decoded, &mut $buf[..], $request);\n+        assert!((&$buf[..len], k) == ($expected, $expectedk),\n+                $fmt, actual = (str::from_utf8(&$buf[..len]).unwrap(), k),\n+                      expected = (str::from_utf8($expected).unwrap(), $expectedk),\n+                      $($key = $val),*);\n+    })\n+}\n+\n+fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16)\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    // use a large enough buffer\n+    let mut buf = [b'_'; 1024];\n+    let mut expected_ = [b'_'; 1024];\n+\n+    let decoded = decode_finite(v);\n+    let cut = expected.iter().position(|&c| c == b' ');\n+\n+    // check significant digits\n+    for i in 1..cut.unwrap_or(expected.len() - 1) {\n+        bytes::copy_memory(&expected[..i], &mut expected_);\n+        let mut expectedk_ = expectedk;\n+        if expected[i] >= b'5' {\n+            // check if this is a rounding-to-even case.\n+            // we avoid rounding ...x5000... (with infinite zeroes) to ...(x+1) when x is even.\n+            if !(i+1 < expected.len() && expected[i-1] & 1 == 0 &&\n+                                         expected[i] == b'5' &&\n+                                         expected[i+1] == b' ') {\n+                // if this returns true, expected_[..i] is all `9`s and being rounded up.\n+                // we should always return `100..00` (`i` digits) instead, since that's\n+                // what we can came up with `i` digits anyway. `round_up` assumes that\n+                // the adjustment to the length is done by caller, which we simply ignore.\n+                if let Some(_) = round_up(&mut expected_, i) { expectedk_ += 1; }\n+            }\n+        }\n+\n+        try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk_;\n+                   \"exact sigdigit mismatch for v={v}, i={i}: \\\n+                    actual {actual:?}, expected {expected:?}\",\n+                   v = vstr, i = i);\n+        try_fixed!(f(&decoded) => &mut buf, expectedk_ - i as i16, &expected_[..i], expectedk_;\n+                   \"fixed sigdigit mismatch for v={v}, i={i}: \\\n+                    actual {actual:?}, expected {expected:?}\",\n+                   v = vstr, i = i);\n+    }\n+\n+    // check exact rounding for zero- and negative-width cases\n+    let start;\n+    if expected[0] >= b'5' {\n+        try_fixed!(f(&decoded) => &mut buf, expectedk, b\"1\", expectedk + 1;\n+                   \"zero-width rounding-up mismatch for v={v}: \\\n+                    actual {actual:?}, expected {expected:?}\",\n+                   v = vstr);\n+        start = 1;\n+    } else {\n+        start = 0;\n+    }\n+    for i in start..-10 {\n+        try_fixed!(f(&decoded) => &mut buf, expectedk - i, b\"\", expectedk;\n+                   \"rounding-down mismatch for v={v}, i={i}: \\\n+                    actual {actual:?}, expected {expected:?}\",\n+                   v = vstr, i = -i);\n+    }\n+\n+    // check infinite zero digits\n+    if let Some(cut) = cut {\n+        for i in cut..expected.len()-1 {\n+            bytes::copy_memory(&expected[..cut], &mut expected_);\n+            for c in &mut expected_[cut..i] { *c = b'0'; }\n+\n+            try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk;\n+                       \"exact infzero mismatch for v={v}, i={i}: \\\n+                        actual {actual:?}, expected {expected:?}\",\n+                       v = vstr, i = i);\n+            try_fixed!(f(&decoded) => &mut buf, expectedk - i as i16, &expected_[..i], expectedk;\n+                       \"fixed infzero mismatch for v={v}, i={i}: \\\n+                        actual {actual:?}, expected {expected:?}\",\n+                       v = vstr, i = i);\n+        }\n+    }\n+}\n+\n+fn check_exact_one<F, T>(mut f: F, x: i64, e: isize, tstr: &str, expected: &[u8], expectedk: i16)\n+        where T: DecodableFloat + fmt::Display,\n+              F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    // use a large enough buffer\n+    let mut buf = [b'_'; 1024];\n+    let v: T = DecodableFloat::ldexpi(x, e);\n+    let decoded = decode_finite(v);\n+\n+    try_exact!(f(&decoded) => &mut buf, &expected, expectedk;\n+               \"exact mismatch for v={x}p{e}{t}: actual {actual:?}, expected {expected:?}\",\n+               x = x, e = e, t = tstr);\n+    try_fixed!(f(&decoded) => &mut buf, expectedk - expected.len() as i16, &expected, expectedk;\n+               \"fixed mismatch for v={x}p{e}{t}: actual {actual:?}, expected {expected:?}\",\n+               x = x, e = e, t = tstr);\n+}\n+\n+macro_rules! check_exact {\n+    ($f:ident($v:expr) => $buf:expr, $exp:expr) => (\n+        check_exact(|d,b,k| $f(d,b,k), $v, stringify!($v), $buf, $exp)\n+    )\n+}\n+\n+macro_rules! check_exact_one {\n+    ($f:ident($x:expr, $e:expr; $t:ty) => $buf:expr, $exp:expr) => (\n+        check_exact_one::<_, $t>(|d,b,k| $f(d,b,k), $x, $e, stringify!($t), $buf, $exp)\n+    )\n+}\n+\n+// in the following comments, three numbers are spaced by 1 ulp apart,\n+// and the second one is being formatted.\n+//\n+// some tests are derived from [1].\n+//\n+// [1] Vern Paxson, A Program for Testing IEEE Decimal-Binary Conversion\n+//     ftp://ftp.ee.lbl.gov/testbase-report.ps.Z\n+\n+pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    // 0.0999999940395355224609375\n+    // 0.100000001490116119384765625\n+    // 0.10000000894069671630859375\n+    check_shortest!(f(0.1f32) => b\"1\", 0);\n+\n+    // 0.333333313465118408203125\n+    // 0.3333333432674407958984375 (1/3 in the default rounding)\n+    // 0.33333337306976318359375\n+    check_shortest!(f(1.0f32/3.0) => b\"33333334\", 0);\n+\n+    // 10^1 * 0.31415917873382568359375\n+    // 10^1 * 0.31415920257568359375\n+    // 10^1 * 0.31415922641754150390625\n+    check_shortest!(f(3.141592f32) => b\"3141592\", 1);\n+\n+    // 10^18 * 0.31415916243714048\n+    // 10^18 * 0.314159196796878848\n+    // 10^18 * 0.314159231156617216\n+    check_shortest!(f(3.141592e17f32) => b\"3141592\", 18);\n+\n+    // regression test for decoders\n+    // 10^8 * 0.3355443\n+    // 10^8 * 0.33554432\n+    // 10^8 * 0.33554436\n+    check_shortest!(f(f32::ldexp(1.0, 25)) => b\"33554432\", 8);\n+\n+    // 10^39 * 0.340282326356119256160033759537265639424\n+    // 10^39 * 0.34028234663852885981170418348451692544\n+    // 10^39 * 0.340282366920938463463374607431768211456\n+    check_shortest!(f(f32::MAX) => b\"34028235\", 39);\n+\n+    // 10^-37 * 0.1175494210692441075487029444849287348827...\n+    // 10^-37 * 0.1175494350822287507968736537222245677818...\n+    // 10^-37 * 0.1175494490952133940450443629595204006810...\n+    check_shortest!(f(f32::MIN_POSITIVE) => b\"11754944\", -37);\n+\n+    // 10^-44 * 0\n+    // 10^-44 * 0.1401298464324817070923729583289916131280...\n+    // 10^-44 * 0.2802596928649634141847459166579832262560...\n+    let minf32 = f32::ldexp(1.0, -149);\n+    check_shortest!(f(minf32) => b\"1\", -44);\n+}\n+\n+pub fn f32_exact_sanity_test<F>(mut f: F)\n+        where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    let minf32 = f32::ldexp(1.0, -149);\n+\n+    check_exact!(f(0.1f32)            => b\"100000001490116119384765625             \", 0);\n+    check_exact!(f(0.5f32)            => b\"5                                       \", 0);\n+    check_exact!(f(1.0f32/3.0)        => b\"3333333432674407958984375               \", 0);\n+    check_exact!(f(3.141592f32)       => b\"31415920257568359375                    \", 1);\n+    check_exact!(f(3.141592e17f32)    => b\"314159196796878848                      \", 18);\n+    check_exact!(f(f32::MAX)          => b\"34028234663852885981170418348451692544  \", 39);\n+    check_exact!(f(f32::MIN_POSITIVE) => b\"1175494350822287507968736537222245677818\", -37);\n+    check_exact!(f(minf32)            => b\"1401298464324817070923729583289916131280\", -44);\n+\n+    // [1], Table 16: Stress Inputs for Converting 24-bit Binary to Decimal, < 1/2 ULP\n+    check_exact_one!(f(12676506, -102; f32) => b\"2\",            -23);\n+    check_exact_one!(f(12676506, -103; f32) => b\"12\",           -23);\n+    check_exact_one!(f(15445013,   86; f32) => b\"119\",           34);\n+    check_exact_one!(f(13734123, -138; f32) => b\"3941\",         -34);\n+    check_exact_one!(f(12428269, -130; f32) => b\"91308\",        -32);\n+    check_exact_one!(f(15334037, -146; f32) => b\"171900\",       -36);\n+    check_exact_one!(f(11518287,  -41; f32) => b\"5237910\",       -5);\n+    check_exact_one!(f(12584953, -145; f32) => b\"28216440\",     -36);\n+    check_exact_one!(f(15961084, -125; f32) => b\"375243281\",    -30);\n+    check_exact_one!(f(14915817, -146; f32) => b\"1672120916\",   -36);\n+    check_exact_one!(f(10845484, -102; f32) => b\"21388945814\",  -23);\n+    check_exact_one!(f(16431059,  -61; f32) => b\"712583594561\", -11);\n+\n+    // [1], Table 17: Stress Inputs for Converting 24-bit Binary to Decimal, > 1/2 ULP\n+    check_exact_one!(f(16093626,   69; f32) => b\"1\",             29);\n+    check_exact_one!(f( 9983778,   25; f32) => b\"34\",            15);\n+    check_exact_one!(f(12745034,  104; f32) => b\"259\",           39);\n+    check_exact_one!(f(12706553,   72; f32) => b\"6001\",          29);\n+    check_exact_one!(f(11005028,   45; f32) => b\"38721\",         21);\n+    check_exact_one!(f(15059547,   71; f32) => b\"355584\",        29);\n+    check_exact_one!(f(16015691,  -99; f32) => b\"2526831\",      -22);\n+    check_exact_one!(f( 8667859,   56; f32) => b\"62458507\",      24);\n+    check_exact_one!(f(14855922,  -82; f32) => b\"307213267\",    -17);\n+    check_exact_one!(f(14855922,  -83; f32) => b\"1536066333\",   -17);\n+    check_exact_one!(f(10144164, -110; f32) => b\"78147796834\",  -26);\n+    check_exact_one!(f(13248074,   95; f32) => b\"524810279937\",  36);\n+}\n+\n+pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    // 0.0999999999999999777955395074968691915273...\n+    // 0.1000000000000000055511151231257827021181...\n+    // 0.1000000000000000333066907387546962127089...\n+    check_shortest!(f(0.1f64) => b\"1\", 0);\n+\n+    // this example is explicitly mentioned in the paper.\n+    // 10^3 * 0.0999999999999999857891452847979962825775...\n+    // 10^3 * 0.1 (exact)\n+    // 10^3 * 0.1000000000000000142108547152020037174224...\n+    check_shortest!(f(100.0f64) => b\"1\", 3);\n+\n+    // 0.3333333333333332593184650249895639717578...\n+    // 0.3333333333333333148296162562473909929394... (1/3 in the default rounding)\n+    // 0.3333333333333333703407674875052180141210...\n+    check_shortest!(f(1.0f64/3.0) => b\"3333333333333333\", 0);\n+\n+    // explicit test case for equally closest representations.\n+    // Dragon has its own tie-breaking rule; Grisu should fall back.\n+    // 10^1 * 0.1000007629394531027955395074968691915273...\n+    // 10^1 * 0.100000762939453125 (exact)\n+    // 10^1 * 0.1000007629394531472044604925031308084726...\n+    check_shortest!(f(1.00000762939453125f64) => b\"10000076293945313\", 1);\n+\n+    // 10^1 * 0.3141591999999999718085064159822650253772...\n+    // 10^1 * 0.3141592000000000162174274009885266423225...\n+    // 10^1 * 0.3141592000000000606263483859947882592678...\n+    check_shortest!(f(3.141592f64) => b\"3141592\", 1);\n+\n+    // 10^18 * 0.314159199999999936\n+    // 10^18 * 0.3141592 (exact)\n+    // 10^18 * 0.314159200000000064\n+    check_shortest!(f(3.141592e17f64) => b\"3141592\", 18);\n+\n+    // regression test for decoders\n+    // 10^20 * 0.18446744073709549568\n+    // 10^20 * 0.18446744073709551616\n+    // 10^20 * 0.18446744073709555712\n+    check_shortest!(f(f64::ldexp(1.0, 64)) => b\"18446744073709552\", 20);\n+\n+    // pathological case: high = 10^23 (exact). tie breaking should always prefer that.\n+    // 10^24 * 0.099999999999999974834176\n+    // 10^24 * 0.099999999999999991611392\n+    // 10^24 * 0.100000000000000008388608\n+    check_shortest!(f(1.0e23f64) => b\"1\", 24);\n+\n+    // 10^309 * 0.1797693134862315508561243283845062402343...\n+    // 10^309 * 0.1797693134862315708145274237317043567980...\n+    // 10^309 * 0.1797693134862315907729305190789024733617...\n+    check_shortest!(f(f64::MAX) => b\"17976931348623157\", 309);\n+\n+    // 10^-307 * 0.2225073858507200889024586876085859887650...\n+    // 10^-307 * 0.2225073858507201383090232717332404064219...\n+    // 10^-307 * 0.2225073858507201877155878558578948240788...\n+    check_shortest!(f(f64::MIN_POSITIVE) => b\"22250738585072014\", -307);\n+\n+    // 10^-323 * 0\n+    // 10^-323 * 0.4940656458412465441765687928682213723650...\n+    // 10^-323 * 0.9881312916824930883531375857364427447301...\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    check_shortest!(f(minf64) => b\"5\", -323);\n+}\n+\n+pub fn f64_exact_sanity_test<F>(mut f: F)\n+        where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    let minf64 = f64::ldexp(1.0, -1074);\n+\n+    check_exact!(f(0.1f64)            => b\"1000000000000000055511151231257827021181\", 0);\n+    check_exact!(f(0.45f64)           => b\"4500000000000000111022302462515654042363\", 0);\n+    check_exact!(f(0.5f64)            => b\"5                                       \", 0);\n+    check_exact!(f(0.95f64)           => b\"9499999999999999555910790149937383830547\", 0);\n+    check_exact!(f(100.0f64)          => b\"1                                       \", 3);\n+    check_exact!(f(999.5f64)          => b\"9995000000000000000000000000000000000000\", 3);\n+    check_exact!(f(1.0f64/3.0)        => b\"3333333333333333148296162562473909929394\", 0);\n+    check_exact!(f(3.141592f64)       => b\"3141592000000000162174274009885266423225\", 1);\n+    check_exact!(f(3.141592e17f64)    => b\"3141592                                 \", 18);\n+    check_exact!(f(1.0e23f64)         => b\"99999999999999991611392                 \", 23);\n+    check_exact!(f(f64::MAX)          => b\"1797693134862315708145274237317043567980\", 309);\n+    check_exact!(f(f64::MIN_POSITIVE) => b\"2225073858507201383090232717332404064219\", -307);\n+    check_exact!(f(minf64)            => b\"4940656458412465441765687928682213723650\\\n+                                           5980261432476442558568250067550727020875\\\n+                                           1865299836361635992379796564695445717730\\\n+                                           9266567103559397963987747960107818781263\\\n+                                           0071319031140452784581716784898210368871\\\n+                                           8636056998730723050006387409153564984387\\\n+                                           3124733972731696151400317153853980741262\\\n+                                           3856559117102665855668676818703956031062\\\n+                                           4931945271591492455329305456544401127480\\\n+                                           1297099995419319894090804165633245247571\\\n+                                           4786901472678015935523861155013480352649\\\n+                                           3472019379026810710749170333222684475333\\\n+                                           5720832431936092382893458368060106011506\\\n+                                           1698097530783422773183292479049825247307\\\n+                                           7637592724787465608477820373446969953364\\\n+                                           7017972677717585125660551199131504891101\\\n+                                           4510378627381672509558373897335989936648\\\n+                                           0994116420570263709027924276754456522908\\\n+                                           7538682506419718265533447265625         \", -323);\n+\n+    // [1], Table 3: Stress Inputs for Converting 53-bit Binary to Decimal, < 1/2 ULP\n+    check_exact_one!(f(8511030020275656,  -342; f64) => b\"9\",                       -87);\n+    check_exact_one!(f(5201988407066741,  -824; f64) => b\"46\",                     -232);\n+    check_exact_one!(f(6406892948269899,   237; f64) => b\"141\",                      88);\n+    check_exact_one!(f(8431154198732492,    72; f64) => b\"3981\",                     38);\n+    check_exact_one!(f(6475049196144587,    99; f64) => b\"41040\",                    46);\n+    check_exact_one!(f(8274307542972842,   726; f64) => b\"292084\",                  235);\n+    check_exact_one!(f(5381065484265332,  -456; f64) => b\"2891946\",                -121);\n+    check_exact_one!(f(6761728585499734, -1057; f64) => b\"43787718\",               -302);\n+    check_exact_one!(f(7976538478610756,   376; f64) => b\"122770163\",               130);\n+    check_exact_one!(f(5982403858958067,   377; f64) => b\"1841552452\",              130);\n+    check_exact_one!(f(5536995190630837,    93; f64) => b\"54835744350\",              44);\n+    check_exact_one!(f(7225450889282194,   710; f64) => b\"389190181146\",            230);\n+    check_exact_one!(f(7225450889282194,   709; f64) => b\"1945950905732\",           230);\n+    check_exact_one!(f(8703372741147379,   117; f64) => b\"14460958381605\",           52);\n+    check_exact_one!(f(8944262675275217, -1001; f64) => b\"417367747458531\",        -285);\n+    check_exact_one!(f(7459803696087692,  -707; f64) => b\"1107950772878888\",       -196);\n+    check_exact_one!(f(6080469016670379,  -381; f64) => b\"12345501366327440\",       -98);\n+    check_exact_one!(f(8385515147034757,   721; f64) => b\"925031711960365024\",      233);\n+    check_exact_one!(f(7514216811389786,  -828; f64) => b\"4198047150284889840\",    -233);\n+    check_exact_one!(f(8397297803260511,  -345; f64) => b\"11716315319786511046\",    -87);\n+    check_exact_one!(f(6733459239310543,   202; f64) => b\"432810072844612493629\",    77);\n+    check_exact_one!(f(8091450587292794,  -473; f64) => b\"3317710118160031081518\", -126);\n+\n+    // [1], Table 4: Stress Inputs for Converting 53-bit Binary to Decimal, > 1/2 ULP\n+    check_exact_one!(f(6567258882077402,   952; f64) => b\"3\",                       303);\n+    check_exact_one!(f(6712731423444934,   535; f64) => b\"76\",                      177);\n+    check_exact_one!(f(6712731423444934,   534; f64) => b\"378\",                     177);\n+    check_exact_one!(f(5298405411573037,  -957; f64) => b\"4350\",                   -272);\n+    check_exact_one!(f(5137311167659507,  -144; f64) => b\"23037\",                   -27);\n+    check_exact_one!(f(6722280709661868,   363; f64) => b\"126301\",                  126);\n+    check_exact_one!(f(5344436398034927,  -169; f64) => b\"7142211\",                 -35);\n+    check_exact_one!(f(8369123604277281,  -853; f64) => b\"13934574\",               -240);\n+    check_exact_one!(f(8995822108487663,  -780; f64) => b\"141463449\",              -218);\n+    check_exact_one!(f(8942832835564782,  -383; f64) => b\"4539277920\",              -99);\n+    check_exact_one!(f(8942832835564782,  -384; f64) => b\"22696389598\",             -99);\n+    check_exact_one!(f(8942832835564782,  -385; f64) => b\"113481947988\",            -99);\n+    check_exact_one!(f(6965949469487146,  -249; f64) => b\"7700366561890\",           -59);\n+    check_exact_one!(f(6965949469487146,  -250; f64) => b\"38501832809448\",          -59);\n+    check_exact_one!(f(6965949469487146,  -251; f64) => b\"192509164047238\",         -59);\n+    check_exact_one!(f(7487252720986826,   548; f64) => b\"6898586531774201\",        181);\n+    check_exact_one!(f(5592117679628511,   164; f64) => b\"13076622631878654\",        66);\n+    check_exact_one!(f(8887055249355788,   665; f64) => b\"136052020756121240\",      217);\n+    check_exact_one!(f(6994187472632449,   690; f64) => b\"3592810217475959676\",     224);\n+    check_exact_one!(f(8797576579012143,   588; f64) => b\"89125197712484551899\",    193);\n+    check_exact_one!(f(7363326733505337,   272; f64) => b\"558769757362301140950\",    98);\n+    check_exact_one!(f(8549497411294502,  -448; f64) => b\"1176257830728540379990\", -118);\n+}\n+\n+pub fn more_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    check_shortest!(f{mant: 99_999_999_999_999_999, minus: 1, plus: 1,\n+                      exp: 0, inclusive: true} => b\"1\", 18);\n+    check_shortest!(f{mant: 99_999_999_999_999_999, minus: 1, plus: 1,\n+                      exp: 0, inclusive: false} => b\"99999999999999999\", 17);\n+}\n+\n+fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+              V: FnMut(usize) -> Decoded {\n+    assert!(k <= 1024);\n+\n+    let mut npassed = 0; // f(x) = Some(g(x))\n+    let mut nignored = 0; // f(x) = None\n+\n+    for i in 0..n {\n+        if (i & 0xfffff) == 0 {\n+            println!(\"in progress, {:x}/{:x} (ignored={} passed={} failed={})\",\n+                     i, n, nignored, npassed, i - nignored - npassed);\n+        }\n+\n+        let decoded = v(i);\n+        let mut buf1 = [0; 1024];\n+        if let Some((len1, e1)) = f(&decoded, &mut buf1[..k]) {\n+            let mut buf2 = [0; 1024];\n+            let (len2, e2) = g(&decoded, &mut buf2[..k]);\n+            if e1 == e2 && &buf1[..len1] == &buf2[..len2] {\n+                npassed += 1;\n+            } else {\n+                println!(\"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n+                         i, n, decoded, str::from_utf8(&buf1[..len1]).unwrap(), e1,\n+                                        str::from_utf8(&buf2[..len2]).unwrap(), e2);\n+            }\n+        } else {\n+            nignored += 1;\n+        }\n+    }\n+    println!(\"{}({}): done, ignored={} passed={} failed={}\",\n+             func, k, nignored, npassed, n - nignored - npassed);\n+    assert!(nignored + npassed == n,\n+            \"{}({}): {} out of {} values returns an incorrect value!\",\n+            func, k, n - nignored - npassed, n);\n+    (npassed, nignored)\n+}\n+\n+pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n+    let f32_range = Range::new(0x0000_0001u32, 0x7f80_0000);\n+    iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n+        let i: u32 = f32_range.ind_sample(&mut rng);\n+        let x: f32 = unsafe {mem::transmute(i)};\n+        decode_finite(x)\n+    });\n+}\n+\n+pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n+    let f64_range = Range::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n+    iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n+        let i: u64 = f64_range.ind_sample(&mut rng);\n+        let x: f64 = unsafe {mem::transmute(i)};\n+        decode_finite(x)\n+    });\n+}\n+\n+pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    // we have only 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values,\n+    // so why not simply testing all of them?\n+    //\n+    // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n+    // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n+\n+    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e. all finite ranges\n+    let (npassed, nignored) = iterate(\"f32_exhaustive_equivalence_test\",\n+                                      k, 0x7f7f_ffff, f, g, |i: usize| {\n+        let x: f32 = unsafe {mem::transmute(i as u32 + 1)};\n+        decode_finite(x)\n+    });\n+    assert_eq!((npassed, nignored), (2121451881, 17643158));\n+}\n+\n+fn to_string_with_parts<F>(mut f: F) -> String\n+        where F: for<'a> FnMut(&'a mut [u8], &'a mut [Part<'a>]) -> Formatted<'a> {\n+    let mut buf = [0; 1024];\n+    let mut parts = [Part::Zero(0); 16];\n+    let formatted = f(&mut buf, &mut parts);\n+    let mut ret = vec![0; formatted.len()];\n+    assert_eq!(formatted.write(&mut ret), Some(ret.len()));\n+    String::from_utf8(ret).unwrap()\n+}\n+\n+pub fn to_shortest_str_test<F>(mut f_: F)\n+        where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    use core::num::flt2dec::Sign::*;\n+\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+        to_string_with_parts(|buf, parts| to_shortest_str(|d,b| f(d,b), v, sign,\n+                                                          frac_digits, upper, buf, parts))\n+    }\n+\n+    let f = &mut f_;\n+\n+    assert_eq!(to_string(f,  0.0, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     0, false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0, false), \"-0\");\n+    assert_eq!(to_string(f,  0.0, Minus,        1,  true), \"0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     1,  true), \"0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    1,  true), \"+0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 1,  true), \"+0.0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        8,  true), \"0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     8,  true), \"-0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    8,  true), \"+0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8,  true), \"-0.00000000\");\n+\n+    assert_eq!(to_string(f,  1.0/0.0, Minus,         0, false), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      0,  true), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     0, false), \"+inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw,  0,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         0, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      1,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, 64,  true), \"NaN\");\n+    assert_eq!(to_string(f, -1.0/0.0, Minus,         0, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,      1,  true), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlus,     8, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n+\n+    assert_eq!(to_string(f,  3.14, Minus,        0, false), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     0, false), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    0, false), \"+3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 0, false), \"+3.14\");\n+    assert_eq!(to_string(f, -3.14, Minus,        0, false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     0, false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    0, false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0, false), \"-3.14\");\n+    assert_eq!(to_string(f,  3.14, Minus,        1,  true), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     2,  true), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    3,  true), \"+3.140\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 4,  true), \"+3.1400\");\n+    assert_eq!(to_string(f, -3.14, Minus,        8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8,  true), \"-3.14000000\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus,  0, false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus,  3, false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 12, false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 13, false), \"0.0000000000750\");\n+\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 0, false), \"199710000000000000000\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 1, false), \"199710000000000000000.0\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 8, false), \"199710000000000000000.00000000\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus, 0, false), format!(\"34028235{:0>31}\", \"\"));\n+    assert_eq!(to_string(f, f32::MAX, Minus, 1, false), format!(\"34028235{:0>31}.0\", \"\"));\n+    assert_eq!(to_string(f, f32::MAX, Minus, 8, false), format!(\"34028235{:0>31}.00000000\", \"\"));\n+\n+    let minf32 = f32::ldexp(1.0, -149);\n+    assert_eq!(to_string(f, minf32, Minus,  0, false), format!(\"0.{:0>44}1\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 45, false), format!(\"0.{:0>44}1\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 46, false), format!(\"0.{:0>44}10\", \"\"));\n+\n+    assert_eq!(to_string(f, f64::MAX, Minus, 0, false),\n+               format!(\"17976931348623157{:0>292}\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, 1, false),\n+               format!(\"17976931348623157{:0>292}.0\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, 8, false),\n+               format!(\"17976931348623157{:0>292}.00000000\", \"\"));\n+\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    assert_eq!(to_string(f, minf64, Minus,   0, false), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 324, false), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 325, false), format!(\"0.{:0>323}50\", \"\"));\n+\n+    // very large output\n+    assert_eq!(to_string(f, 1.1, Minus, 80000, false), format!(\"1.1{:0>79999}\", \"\"));\n+}\n+\n+pub fn to_shortest_exp_str_test<F>(mut f_: F)\n+        where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    use core::num::flt2dec::Sign::*;\n+\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, exp_bounds: (i16, i16), upper: bool) -> String\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+        to_string_with_parts(|buf, parts| to_shortest_exp_str(|d,b| f(d,b), v, sign,\n+                                                              exp_bounds, upper, buf, parts))\n+    }\n+\n+    let f = &mut f_;\n+\n+    assert_eq!(to_string(f,  0.0, Minus,        (-4, 16), false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     (-4, 16), false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    (-4, 16), false), \"+0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, (-4, 16), false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        (-4, 16), false), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     (-4, 16), false), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    (-4, 16), false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, (-4, 16), false), \"-0\");\n+    assert_eq!(to_string(f,  0.0, Minus,        ( 0,  0),  true), \"0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     ( 0,  0), false), \"0e0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    (-9, -5),  true), \"+0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, ( 5,  9), false), \"+0e0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        ( 0,  0),  true), \"0E0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     ( 0,  0), false), \"-0e0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    (-9, -5),  true), \"+0E0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, ( 5,  9), false), \"-0e0\");\n+\n+    assert_eq!(to_string(f,  1.0/0.0, Minus,        (-4, 16), false), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,     (-4, 16),  true), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlus,    (-4, 16), false), \"+inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw, (-4, 16),  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,        ( 0,  0), false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,     ( 0,  0),  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,    (-9, -5), false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, ( 5,  9),  true), \"NaN\");\n+    assert_eq!(to_string(f, -1.0/0.0, Minus,        ( 0,  0), false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,     ( 0,  0),  true), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlus,    (-9, -5), false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, ( 5,  9),  true), \"-inf\");\n+\n+    assert_eq!(to_string(f,  3.14, Minus,        (-4, 16), false), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     (-4, 16), false), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    (-4, 16), false), \"+3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, (-4, 16), false), \"+3.14\");\n+    assert_eq!(to_string(f, -3.14, Minus,        (-4, 16), false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     (-4, 16), false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    (-4, 16), false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, (-4, 16), false), \"-3.14\");\n+    assert_eq!(to_string(f,  3.14, Minus,        ( 0,  0),  true), \"3.14E0\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     ( 0,  0), false), \"3.14e0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    (-9, -5),  true), \"+3.14E0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, ( 5,  9), false), \"+3.14e0\");\n+    assert_eq!(to_string(f, -3.14, Minus,        ( 0,  0),  true), \"-3.14E0\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     ( 0,  0), false), \"-3.14e0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    (-9, -5),  true), \"-3.14E0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, ( 5,  9), false), \"-3.14e0\");\n+\n+    assert_eq!(to_string(f,  0.1, Minus,        (-4, 16), false), \"0.1\");\n+    assert_eq!(to_string(f,  0.1, MinusRaw,     (-4, 16), false), \"0.1\");\n+    assert_eq!(to_string(f,  0.1, MinusPlus,    (-4, 16), false), \"+0.1\");\n+    assert_eq!(to_string(f,  0.1, MinusPlusRaw, (-4, 16), false), \"+0.1\");\n+    assert_eq!(to_string(f, -0.1, Minus,        (-4, 16), false), \"-0.1\");\n+    assert_eq!(to_string(f, -0.1, MinusRaw,     (-4, 16), false), \"-0.1\");\n+    assert_eq!(to_string(f, -0.1, MinusPlus,    (-4, 16), false), \"-0.1\");\n+    assert_eq!(to_string(f, -0.1, MinusPlusRaw, (-4, 16), false), \"-0.1\");\n+    assert_eq!(to_string(f,  0.1, Minus,        ( 0,  0),  true), \"1E-1\");\n+    assert_eq!(to_string(f,  0.1, MinusRaw,     ( 0,  0), false), \"1e-1\");\n+    assert_eq!(to_string(f,  0.1, MinusPlus,    (-9, -5),  true), \"+1E-1\");\n+    assert_eq!(to_string(f,  0.1, MinusPlusRaw, ( 5,  9), false), \"+1e-1\");\n+    assert_eq!(to_string(f, -0.1, Minus,        ( 0,  0),  true), \"-1E-1\");\n+    assert_eq!(to_string(f, -0.1, MinusRaw,     ( 0,  0), false), \"-1e-1\");\n+    assert_eq!(to_string(f, -0.1, MinusPlus,    (-9, -5),  true), \"-1E-1\");\n+    assert_eq!(to_string(f, -0.1, MinusPlusRaw, ( 5,  9), false), \"-1e-1\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus, ( -4, 16), false), \"7.5e-11\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, (-11, 10), false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, (-10, 11), false), \"7.5e-11\");\n+\n+    assert_eq!(to_string(f, 1.9971e20, Minus, ( -4, 16), false), \"1.9971e20\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, (-20, 21), false), \"199710000000000000000\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, (-21, 20), false), \"1.9971e20\");\n+\n+    // the true value of 1.0e23f64 is less than 10^23, but that shouldn't matter here\n+    assert_eq!(to_string(f, 1.0e23, Minus, (22, 23), false), \"1e23\");\n+    assert_eq!(to_string(f, 1.0e23, Minus, (23, 24), false), \"100000000000000000000000\");\n+    assert_eq!(to_string(f, 1.0e23, Minus, (24, 25), false), \"1e23\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus, ( -4, 16), false), \"3.4028235e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, (-39, 38), false), \"3.4028235e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, (-38, 39), false), format!(\"34028235{:0>31}\", \"\"));\n+\n+    let minf32 = f32::ldexp(1.0, -149);\n+    assert_eq!(to_string(f, minf32, Minus, ( -4, 16), false), \"1e-45\");\n+    assert_eq!(to_string(f, minf32, Minus, (-44, 45), false), \"1e-45\");\n+    assert_eq!(to_string(f, minf32, Minus, (-45, 44), false), format!(\"0.{:0>44}1\", \"\"));\n+\n+    assert_eq!(to_string(f, f64::MAX, Minus, (  -4,  16), false),\n+               \"1.7976931348623157e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, (-308, 309), false),\n+               format!(\"17976931348623157{:0>292}\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, (-309, 308), false),\n+               \"1.7976931348623157e308\");\n+\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    assert_eq!(to_string(f, minf64, Minus, (  -4,  16), false), \"5e-324\");\n+    assert_eq!(to_string(f, minf64, Minus, (-324, 323), false), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, (-323, 324), false), \"5e-324\");\n+\n+    assert_eq!(to_string(f, 1.1, Minus, (i16::MIN, i16::MAX), false), \"1.1\");\n+}\n+\n+pub fn to_exact_exp_str_test<F>(mut f_: F)\n+        where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    use core::num::flt2dec::Sign::*;\n+\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, ndigits: usize, upper: bool) -> String\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+        to_string_with_parts(|buf, parts| to_exact_exp_str(|d,b,l| f(d,b,l), v, sign,\n+                                                           ndigits, upper, buf, parts))\n+    }\n+\n+    let f = &mut f_;\n+\n+    assert_eq!(to_string(f,  0.0, Minus,        1,  true), \"0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     1, false), \"0e0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    1,  true), \"+0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 1, false), \"+0e0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        1,  true), \"0E0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     1, false), \"-0e0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    1,  true), \"+0E0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 1, false), \"-0e0\");\n+    assert_eq!(to_string(f,  0.0, Minus,        2,  true), \"0.0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     2, false), \"0.0e0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    2,  true), \"+0.0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 2, false), \"+0.0e0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        8,  true), \"0.0000000E0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     8, false), \"-0.0000000e0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    8,  true), \"+0.0000000E0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8, false), \"-0.0000000e0\");\n+\n+    assert_eq!(to_string(f,  1.0/0.0, Minus,         1, false), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      1,  true), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     1, false), \"+inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw,  1,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      8,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw,  8,  true), \"NaN\");\n+    assert_eq!(to_string(f, -1.0/0.0, Minus,        64, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,     64,  true), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlus,    64, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n+\n+    assert_eq!(to_string(f,  3.14, Minus,        1,  true), \"3E0\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     1, false), \"3e0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    1,  true), \"+3E0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 1, false), \"+3e0\");\n+    assert_eq!(to_string(f, -3.14, Minus,        2,  true), \"-3.1E0\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     2, false), \"-3.1e0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    2,  true), \"-3.1E0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 2, false), \"-3.1e0\");\n+    assert_eq!(to_string(f,  3.14, Minus,        3,  true), \"3.14E0\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     3, false), \"3.14e0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    3,  true), \"+3.14E0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 3, false), \"+3.14e0\");\n+    assert_eq!(to_string(f, -3.14, Minus,        4,  true), \"-3.140E0\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     4, false), \"-3.140e0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    4,  true), \"-3.140E0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 4, false), \"-3.140e0\");\n+\n+    assert_eq!(to_string(f,  0.195, Minus,        1, false), \"2e-1\");\n+    assert_eq!(to_string(f,  0.195, MinusRaw,     1,  true), \"2E-1\");\n+    assert_eq!(to_string(f,  0.195, MinusPlus,    1, false), \"+2e-1\");\n+    assert_eq!(to_string(f,  0.195, MinusPlusRaw, 1,  true), \"+2E-1\");\n+    assert_eq!(to_string(f, -0.195, Minus,        2, false), \"-2.0e-1\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw,     2,  true), \"-2.0E-1\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus,    2, false), \"-2.0e-1\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 2,  true), \"-2.0E-1\");\n+    assert_eq!(to_string(f,  0.195, Minus,        3, false), \"1.95e-1\");\n+    assert_eq!(to_string(f,  0.195, MinusRaw,     3,  true), \"1.95E-1\");\n+    assert_eq!(to_string(f,  0.195, MinusPlus,    3, false), \"+1.95e-1\");\n+    assert_eq!(to_string(f,  0.195, MinusPlusRaw, 3,  true), \"+1.95E-1\");\n+    assert_eq!(to_string(f, -0.195, Minus,        4, false), \"-1.950e-1\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw,     4,  true), \"-1.950E-1\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus,    4, false), \"-1.950e-1\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 4,  true), \"-1.950E-1\");\n+\n+    assert_eq!(to_string(f, 9.5, Minus,  1, false), \"1e1\");\n+    assert_eq!(to_string(f, 9.5, Minus,  2, false), \"9.5e0\");\n+    assert_eq!(to_string(f, 9.5, Minus,  3, false), \"9.50e0\");\n+    assert_eq!(to_string(f, 9.5, Minus, 30, false), \"9.50000000000000000000000000000e0\");\n+\n+    assert_eq!(to_string(f, 1.0e25, Minus,  1, false), \"1e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus,  2, false), \"1.0e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 15, false), \"1.00000000000000e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 16, false), \"1.000000000000000e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 17, false), \"1.0000000000000001e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 18, false), \"1.00000000000000009e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 19, false), \"1.000000000000000091e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 20, false), \"1.0000000000000000906e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 21, false), \"1.00000000000000009060e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 22, false), \"1.000000000000000090597e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 23, false), \"1.0000000000000000905970e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 24, false), \"1.00000000000000009059697e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 25, false), \"1.000000000000000090596966e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 26, false), \"1.0000000000000000905969664e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 27, false), \"1.00000000000000009059696640e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 30, false), \"1.00000000000000009059696640000e25\");\n+\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  1, false), \"1e-6\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  2, false), \"1.0e-6\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 16, false), \"1.000000000000000e-6\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 17, false), \"9.9999999999999995e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 18, false), \"9.99999999999999955e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 19, false), \"9.999999999999999547e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 20, false), \"9.9999999999999995475e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 30, false), \"9.99999999999999954748111825886e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 40, false),\n+               \"9.999999999999999547481118258862586856139e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 50, false),\n+               \"9.9999999999999995474811182588625868561393872369081e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 60, false),\n+               \"9.99999999999999954748111825886258685613938723690807819366455e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 70, false),\n+               \"9.999999999999999547481118258862586856139387236908078193664550781250000e-7\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus,  1, false), \"3e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus,  2, false), \"3.4e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus,  4, false), \"3.403e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus,  8, false), \"3.4028235e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 16, false), \"3.402823466385289e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 32, false), \"3.4028234663852885981170418348452e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 64, false),\n+               \"3.402823466385288598117041834845169254400000000000000000000000000e38\");\n+\n+    let minf32 = f32::ldexp(1.0, -149);\n+    assert_eq!(to_string(f, minf32, Minus,   1, false), \"1e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,   2, false), \"1.4e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,   4, false), \"1.401e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,   8, false), \"1.4012985e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,  16, false), \"1.401298464324817e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,  32, false), \"1.4012984643248170709237295832899e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,  64, false),\n+               \"1.401298464324817070923729583289916131280261941876515771757068284e-45\");\n+    assert_eq!(to_string(f, minf32, Minus, 128, false),\n+               \"1.401298464324817070923729583289916131280261941876515771757068283\\\n+                 8897910826858606014866381883621215820312500000000000000000000000e-45\");\n+\n+    assert_eq!(to_string(f, f64::MAX, Minus,   1, false), \"2e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,   2, false), \"1.8e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,   4, false), \"1.798e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,   8, false), \"1.7976931e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,  16, false), \"1.797693134862316e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,  32, false), \"1.7976931348623157081452742373170e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,  64, false),\n+               \"1.797693134862315708145274237317043567980705675258449965989174768e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, 128, false),\n+               \"1.797693134862315708145274237317043567980705675258449965989174768\\\n+                 0315726078002853876058955863276687817154045895351438246423432133e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, 256, false),\n+               \"1.797693134862315708145274237317043567980705675258449965989174768\\\n+                 0315726078002853876058955863276687817154045895351438246423432132\\\n+                 6889464182768467546703537516986049910576551282076245490090389328\\\n+                 9440758685084551339423045832369032229481658085593321233482747978e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, 512, false),\n+               \"1.797693134862315708145274237317043567980705675258449965989174768\\\n+                 0315726078002853876058955863276687817154045895351438246423432132\\\n+                 6889464182768467546703537516986049910576551282076245490090389328\\\n+                 9440758685084551339423045832369032229481658085593321233482747978\\\n+                 2620414472316873817718091929988125040402618412485836800000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000e308\");\n+\n+    // okay, this is becoming tough. fortunately for us, this is almost the worst case.\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    assert_eq!(to_string(f, minf64, Minus,    1, false), \"5e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,    2, false), \"4.9e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,    4, false), \"4.941e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,    8, false), \"4.9406565e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,   16, false), \"4.940656458412465e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,   32, false), \"4.9406564584124654417656879286822e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,   64, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,  128, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825\\\n+                 0067550727020875186529983636163599237979656469544571773092665671e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,  256, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825\\\n+                 0067550727020875186529983636163599237979656469544571773092665671\\\n+                 0355939796398774796010781878126300713190311404527845817167848982\\\n+                 1036887186360569987307230500063874091535649843873124733972731696e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,  512, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825\\\n+                 0067550727020875186529983636163599237979656469544571773092665671\\\n+                 0355939796398774796010781878126300713190311404527845817167848982\\\n+                 1036887186360569987307230500063874091535649843873124733972731696\\\n+                 1514003171538539807412623856559117102665855668676818703956031062\\\n+                 4931945271591492455329305456544401127480129709999541931989409080\\\n+                 4165633245247571478690147267801593552386115501348035264934720193\\\n+                 7902681071074917033322268447533357208324319360923828934583680601e-324\");\n+    assert_eq!(to_string(f, minf64, Minus, 1024, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825\\\n+                 0067550727020875186529983636163599237979656469544571773092665671\\\n+                 0355939796398774796010781878126300713190311404527845817167848982\\\n+                 1036887186360569987307230500063874091535649843873124733972731696\\\n+                 1514003171538539807412623856559117102665855668676818703956031062\\\n+                 4931945271591492455329305456544401127480129709999541931989409080\\\n+                 4165633245247571478690147267801593552386115501348035264934720193\\\n+                 7902681071074917033322268447533357208324319360923828934583680601\\\n+                 0601150616980975307834227731832924790498252473077637592724787465\\\n+                 6084778203734469699533647017972677717585125660551199131504891101\\\n+                 4510378627381672509558373897335989936648099411642057026370902792\\\n+                 4276754456522908753868250641971826553344726562500000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000e-324\");\n+\n+    // very large output\n+    assert_eq!(to_string(f, 0.0,     Minus, 80000, false), format!(\"0.{:0>79999}e0\", \"\"));\n+    assert_eq!(to_string(f, 1.0e1,   Minus, 80000, false), format!(\"1.{:0>79999}e1\", \"\"));\n+    assert_eq!(to_string(f, 1.0e0,   Minus, 80000, false), format!(\"1.{:0>79999}e0\", \"\"));\n+    assert_eq!(to_string(f, 1.0e-1,  Minus, 80000, false),\n+               format!(\"1.000000000000000055511151231257827021181583404541015625{:0>79945}\\\n+                        e-1\", \"\"));\n+    assert_eq!(to_string(f, 1.0e-20, Minus, 80000, false),\n+               format!(\"9.999999999999999451532714542095716517295037027873924471077157760\\\n+                         66783064379706047475337982177734375{:0>79901}e-21\", \"\"));\n+}\n+\n+pub fn to_exact_fixed_str_test<F>(mut f_: F)\n+        where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    use core::num::flt2dec::Sign::*;\n+\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+        to_string_with_parts(|buf, parts| to_exact_fixed_str(|d,b,l| f(d,b,l), v, sign,\n+                                                             frac_digits, upper, buf, parts))\n+    }\n+\n+    let f = &mut f_;\n+\n+    assert_eq!(to_string(f,  0.0, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     0, false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0, false), \"-0\");\n+    assert_eq!(to_string(f,  0.0, Minus,        1,  true), \"0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     1,  true), \"0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    1,  true), \"+0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 1,  true), \"+0.0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        8,  true), \"0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     8,  true), \"-0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    8,  true), \"+0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8,  true), \"-0.00000000\");\n+\n+    assert_eq!(to_string(f,  1.0/0.0, Minus,         0, false), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      1,  true), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     8, false), \"+inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw, 64,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         0, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      1,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, 64,  true), \"NaN\");\n+    assert_eq!(to_string(f, -1.0/0.0, Minus,         0, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,      1,  true), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlus,     8, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n+\n+    assert_eq!(to_string(f,  3.14, Minus,        0, false), \"3\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     0, false), \"3\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    0, false), \"+3\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 0, false), \"+3\");\n+    assert_eq!(to_string(f, -3.14, Minus,        0, false), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     0, false), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    0, false), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0, false), \"-3\");\n+    assert_eq!(to_string(f,  3.14, Minus,        1,  true), \"3.1\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     2,  true), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    3,  true), \"+3.140\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 4,  true), \"+3.1400\");\n+    assert_eq!(to_string(f, -3.14, Minus,        8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8,  true), \"-3.14000000\");\n+\n+    assert_eq!(to_string(f,  0.195, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f,  0.195, MinusRaw,     0, false), \"0\");\n+    assert_eq!(to_string(f,  0.195, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f,  0.195, MinusPlusRaw, 0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.195, Minus,        0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw,     0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus,    0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 0, false), \"-0\");\n+    assert_eq!(to_string(f,  0.195, Minus,        1,  true), \"0.2\");\n+    assert_eq!(to_string(f,  0.195, MinusRaw,     2,  true), \"0.20\");\n+    assert_eq!(to_string(f,  0.195, MinusPlus,    3,  true), \"+0.195\");\n+    assert_eq!(to_string(f,  0.195, MinusPlusRaw, 4,  true), \"+0.1950\");\n+    assert_eq!(to_string(f, -0.195, Minus,        5,  true), \"-0.19500\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw,     6,  true), \"-0.195000\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus,    7,  true), \"-0.1950000\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 8,  true), \"-0.19500000\");\n+\n+    assert_eq!(to_string(f, 999.5, Minus,  0, false), \"1000\");\n+    assert_eq!(to_string(f, 999.5, Minus,  1, false), \"999.5\");\n+    assert_eq!(to_string(f, 999.5, Minus,  2, false), \"999.50\");\n+    assert_eq!(to_string(f, 999.5, Minus,  3, false), \"999.500\");\n+    assert_eq!(to_string(f, 999.5, Minus, 30, false), \"999.500000000000000000000000000000\");\n+\n+    assert_eq!(to_string(f, 0.5, Minus, 0, false), \"1\");\n+    assert_eq!(to_string(f, 0.5, Minus, 1, false), \"0.5\");\n+    assert_eq!(to_string(f, 0.5, Minus, 2, false), \"0.50\");\n+    assert_eq!(to_string(f, 0.5, Minus, 3, false), \"0.500\");\n+\n+    assert_eq!(to_string(f, 0.95, Minus,  0, false), \"1\");\n+    assert_eq!(to_string(f, 0.95, Minus,  1, false), \"0.9\"); // because it really is less than 0.95\n+    assert_eq!(to_string(f, 0.95, Minus,  2, false), \"0.95\");\n+    assert_eq!(to_string(f, 0.95, Minus,  3, false), \"0.950\");\n+    assert_eq!(to_string(f, 0.95, Minus, 10, false), \"0.9500000000\");\n+    assert_eq!(to_string(f, 0.95, Minus, 30, false), \"0.949999999999999955591079014994\");\n+\n+    assert_eq!(to_string(f, 0.095, Minus,  0, false), \"0\");\n+    assert_eq!(to_string(f, 0.095, Minus,  1, false), \"0.1\");\n+    assert_eq!(to_string(f, 0.095, Minus,  2, false), \"0.10\");\n+    assert_eq!(to_string(f, 0.095, Minus,  3, false), \"0.095\");\n+    assert_eq!(to_string(f, 0.095, Minus,  4, false), \"0.0950\");\n+    assert_eq!(to_string(f, 0.095, Minus, 10, false), \"0.0950000000\");\n+    assert_eq!(to_string(f, 0.095, Minus, 30, false), \"0.095000000000000001110223024625\");\n+\n+    assert_eq!(to_string(f, 0.0095, Minus,  0, false), \"0\");\n+    assert_eq!(to_string(f, 0.0095, Minus,  1, false), \"0.0\");\n+    assert_eq!(to_string(f, 0.0095, Minus,  2, false), \"0.01\");\n+    assert_eq!(to_string(f, 0.0095, Minus,  3, false), \"0.009\"); // really is less than 0.0095\n+    assert_eq!(to_string(f, 0.0095, Minus,  4, false), \"0.0095\");\n+    assert_eq!(to_string(f, 0.0095, Minus,  5, false), \"0.00950\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 10, false), \"0.0095000000\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 30, false), \"0.009499999999999999764077607267\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus,  0, false), \"0\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus,  3, false), \"0.000\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 10, false), \"0.0000000001\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 11, false), \"0.00000000007\"); // ditto\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 12, false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 13, false), \"0.0000000000750\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 20, false), \"0.00000000007500000000\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 30, false), \"0.000000000074999999999999999501\");\n+\n+    assert_eq!(to_string(f, 1.0e25, Minus, 0, false), \"10000000000000000905969664\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 1, false), \"10000000000000000905969664.0\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 3, false), \"10000000000000000905969664.000\");\n+\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  0, false), \"0\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  3, false), \"0.000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  6, false), \"0.000001\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  9, false), \"0.000001000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 12, false), \"0.000001000000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 22, false), \"0.0000010000000000000000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 23, false), \"0.00000099999999999999995\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 24, false), \"0.000000999999999999999955\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 25, false), \"0.0000009999999999999999547\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 35, false), \"0.00000099999999999999995474811182589\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 45, false),\n+               \"0.000000999999999999999954748111825886258685614\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 55, false),\n+               \"0.0000009999999999999999547481118258862586856139387236908\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 65, false),\n+               \"0.00000099999999999999995474811182588625868561393872369080781936646\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 75, false),\n+               \"0.000000999999999999999954748111825886258685613938723690807819366455078125000\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus, 0, false),\n+               \"340282346638528859811704183484516925440\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 1, false),\n+               \"340282346638528859811704183484516925440.0\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 2, false),\n+               \"340282346638528859811704183484516925440.00\");\n+\n+    let minf32 = f32::ldexp(1.0, -149);\n+    assert_eq!(to_string(f, minf32, Minus,   0, false), \"0\");\n+    assert_eq!(to_string(f, minf32, Minus,   1, false), \"0.0\");\n+    assert_eq!(to_string(f, minf32, Minus,   2, false), \"0.00\");\n+    assert_eq!(to_string(f, minf32, Minus,   4, false), \"0.0000\");\n+    assert_eq!(to_string(f, minf32, Minus,   8, false), \"0.00000000\");\n+    assert_eq!(to_string(f, minf32, Minus,  16, false), \"0.0000000000000000\");\n+    assert_eq!(to_string(f, minf32, Minus,  32, false), \"0.00000000000000000000000000000000\");\n+    assert_eq!(to_string(f, minf32, Minus,  64, false),\n+               \"0.0000000000000000000000000000000000000000000014012984643248170709\");\n+    assert_eq!(to_string(f, minf32, Minus, 128, false),\n+               \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n+                  2372958328991613128026194187651577175706828388979108268586060149\");\n+    assert_eq!(to_string(f, minf32, Minus, 256, false),\n+               \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n+                  2372958328991613128026194187651577175706828388979108268586060148\\\n+                  6638188362121582031250000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\");\n+\n+    assert_eq!(to_string(f, f64::MAX, Minus, 0, false),\n+               \"1797693134862315708145274237317043567980705675258449965989174768\\\n+                0315726078002853876058955863276687817154045895351438246423432132\\\n+                6889464182768467546703537516986049910576551282076245490090389328\\\n+                9440758685084551339423045832369032229481658085593321233482747978\\\n+                26204144723168738177180919299881250404026184124858368\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, 10, false),\n+               \"1797693134862315708145274237317043567980705675258449965989174768\\\n+                0315726078002853876058955863276687817154045895351438246423432132\\\n+                6889464182768467546703537516986049910576551282076245490090389328\\\n+                9440758685084551339423045832369032229481658085593321233482747978\\\n+                26204144723168738177180919299881250404026184124858368.0000000000\");\n+\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    assert_eq!(to_string(f, minf64, Minus, 0, false), \"0\");\n+    assert_eq!(to_string(f, minf64, Minus, 1, false), \"0.0\");\n+    assert_eq!(to_string(f, minf64, Minus, 10, false), \"0.0000000000\");\n+    assert_eq!(to_string(f, minf64, Minus, 100, false),\n+               \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n+                  000000000000000000000000000000000000\");\n+    assert_eq!(to_string(f, minf64, Minus, 1000, false),\n+               \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0004940656458412465441765687928682213723650598026143247644255856\\\n+                  8250067550727020875186529983636163599237979656469544571773092665\\\n+                  6710355939796398774796010781878126300713190311404527845817167848\\\n+                  9821036887186360569987307230500063874091535649843873124733972731\\\n+                  6961514003171538539807412623856559117102665855668676818703956031\\\n+                  0624931945271591492455329305456544401127480129709999541931989409\\\n+                  0804165633245247571478690147267801593552386115501348035264934720\\\n+                  1937902681071074917033322268447533357208324319360923828934583680\\\n+                  6010601150616980975307834227731832924790498252473077637592724787\\\n+                  4656084778203734469699533647017972677717585125660551199131504891\\\n+                  1014510378627381672509558373897335989937\");\n+\n+    // very large output\n+    assert_eq!(to_string(f, 0.0,     Minus, 80000, false), format!(\"0.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e1,   Minus, 80000, false), format!(\"10.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e0,   Minus, 80000, false), format!(\"1.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e-1,  Minus, 80000, false),\n+               format!(\"0.1000000000000000055511151231257827021181583404541015625{:0>79945}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e-20, Minus, 80000, false),\n+               format!(\"0.0000000000000000000099999999999999994515327145420957165172950370\\\n+                          2787392447107715776066783064379706047475337982177734375{:0>79881}\", \"\"));\n+}\n+"}, {"sha": "f2397f6b48037e0311bfb5a257db741b7f1087d9", "filename": "src/libcoretest/num/flt2dec/strategy/dragon.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::prelude::v1::*;\n+use std::{i16, f64};\n+use super::super::*;\n+use core::num::flt2dec::*;\n+use core::num::flt2dec::bignum::Big32x36 as Big;\n+use core::num::flt2dec::strategy::dragon::*;\n+\n+#[test]\n+fn test_mul_pow10() {\n+    let mut prevpow10 = Big::from_small(1);\n+    for i in 1..340 {\n+        let mut curpow10 = Big::from_small(1);\n+        mul_pow10(&mut curpow10, i);\n+        assert_eq!(curpow10, *prevpow10.clone().mul_small(10));\n+        prevpow10 = curpow10;\n+    }\n+}\n+\n+#[test]\n+fn shortest_sanity_test() {\n+    f64_shortest_sanity_test(format_shortest);\n+    f32_shortest_sanity_test(format_shortest);\n+    more_shortest_sanity_test(format_shortest);\n+}\n+\n+#[test]\n+fn exact_sanity_test() {\n+    f64_exact_sanity_test(format_exact);\n+    f32_exact_sanity_test(format_exact);\n+}\n+\n+#[bench]\n+fn bench_small_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_big_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_small_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[test]\n+fn test_to_shortest_str() {\n+    to_shortest_str_test(format_shortest);\n+}\n+\n+#[test]\n+fn test_to_shortest_exp_str() {\n+    to_shortest_exp_str_test(format_shortest);\n+}\n+\n+#[test]\n+fn test_to_exact_exp_str() {\n+    to_exact_exp_str_test(format_exact);\n+}\n+\n+#[test]\n+fn test_to_exact_fixed_str() {\n+    to_exact_fixed_str_test(format_exact);\n+}\n+"}, {"sha": "e5b8a9dcc38fcc9e8b085821dd2ba87d56e55323", "filename": "src/libcoretest/num/flt2dec/strategy/grisu.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{i16, f64};\n+use super::super::*;\n+use core::num::flt2dec::*;\n+use core::num::flt2dec::strategy::grisu::*;\n+\n+#[test]\n+fn test_cached_power() {\n+    assert_eq!(CACHED_POW10.first().unwrap().1, CACHED_POW10_FIRST_E);\n+    assert_eq!(CACHED_POW10.last().unwrap().1, CACHED_POW10_LAST_E);\n+\n+    for e in -1137..961 { // full range for f64\n+        let low = ALPHA - e - 64;\n+        let high = GAMMA - e - 64;\n+        let (_k, cached) = cached_power(low, high);\n+        assert!(low <= cached.e && cached.e <= high,\n+                \"cached_power({}, {}) = {:?} is incorrect\", low, high, cached);\n+    }\n+}\n+\n+#[test]\n+fn test_max_pow10_no_more_than() {\n+    let mut prevtenk = 1;\n+    for k in 1..10 {\n+        let tenk = prevtenk * 10;\n+        assert_eq!(max_pow10_no_more_than(tenk - 1), (k - 1, prevtenk));\n+        assert_eq!(max_pow10_no_more_than(tenk), (k, tenk));\n+        prevtenk = tenk;\n+    }\n+}\n+\n+\n+#[test]\n+fn shortest_sanity_test() {\n+    f64_shortest_sanity_test(format_shortest);\n+    f32_shortest_sanity_test(format_shortest);\n+    more_shortest_sanity_test(format_shortest);\n+}\n+\n+#[test]\n+fn shortest_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n+    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n+}\n+\n+#[test] #[ignore] // it is too expensive\n+fn shortest_f32_exhaustive_equivalence_test() {\n+    // it is hard to directly test the optimality of the output, but we can at least test if\n+    // two different algorithms agree to each other.\n+    //\n+    // this reports the progress and the number of f32 values returned `None`.\n+    // with `--nocapture` (and plenty of time and appropriate rustc flags), this should print:\n+    // `done, ignored=17643158 passed=2121451881 failed=0`.\n+\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f32_exhaustive_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS);\n+}\n+\n+#[test] #[ignore] // it is too expensive\n+fn shortest_f64_hard_random_equivalence_test() {\n+    // this again probably has to use appropriate rustc flags.\n+\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f64_random_equivalence_test(format_shortest_opt, fallback,\n+                                         MAX_SIG_DIGITS, 100_000_000);\n+}\n+\n+#[test]\n+fn exact_sanity_test() {\n+    f64_exact_sanity_test(format_exact);\n+    f32_exact_sanity_test(format_exact);\n+}\n+\n+#[test]\n+fn exact_f32_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n+    for k in 1..21 {\n+        f32_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n+                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n+    }\n+}\n+\n+#[test]\n+fn exact_f64_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n+    for k in 1..21 {\n+        f64_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n+                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n+    }\n+}\n+\n+#[bench]\n+fn bench_small_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_big_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_small_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[test]\n+fn test_to_shortest_str() {\n+    to_shortest_str_test(format_shortest);\n+}\n+\n+#[test]\n+fn test_to_shortest_exp_str() {\n+    to_shortest_exp_str_test(format_shortest);\n+}\n+\n+#[test]\n+fn test_to_exact_exp_str() {\n+    to_exact_exp_str_test(format_exact);\n+}\n+\n+#[test]\n+fn test_to_exact_fixed_str() {\n+    to_exact_fixed_str_test(format_exact);\n+}\n+"}, {"sha": "998f4b21ece7f8f8345ccac81ffcfe8e4fadbba2", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -29,6 +29,8 @@ mod u16;\n mod u32;\n mod u64;\n \n+mod flt2dec;\n+\n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where\n     T: PartialEq"}, {"sha": "adc4f69334f17f0df7f722bdc1d6d6e01966ab7f", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ba6dcf68860d8a20891faad88a33b35ed58df5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=67ba6dcf68860d8a20891faad88a33b35ed58df5", "patch": "@@ -3011,9 +3011,9 @@ mod tests {\n         let v: i64 = super::decode(\"9223372036854775807\").unwrap();\n         assert_eq!(v, i64::MAX);\n \n-        let res: DecodeResult<i64> = super::decode(\"765.25252\");\n+        let res: DecodeResult<i64> = super::decode(\"765.25\");\n         assert_eq!(res, Err(ExpectedError(\"Integer\".to_string(),\n-                                          \"765.25252\".to_string())));\n+                                          \"765.25\".to_string())));\n     }\n \n     #[test]"}]}