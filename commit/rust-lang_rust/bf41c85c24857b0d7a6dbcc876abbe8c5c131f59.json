{"sha": "bf41c85c24857b0d7a6dbcc876abbe8c5c131f59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNDFjODVjMjQ4NTdiMGQ3YTZkYmNjODc2YWJiZThjNWMxMzFmNTk=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-11T07:47:21Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-21T09:21:48Z"}, "message": "Cleanup.", "tree": {"sha": "3c478d2f02fcbfd1ece00eb0e5bd30327e7c43ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c478d2f02fcbfd1ece00eb0e5bd30327e7c43ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59", "html_url": "https://github.com/rust-lang/rust/commit/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4d3df6592a4294afc3d61e512c7bc97b86e6c41", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d3df6592a4294afc3d61e512c7bc97b86e6c41", "html_url": "https://github.com/rust-lang/rust/commit/b4d3df6592a4294afc3d61e512c7bc97b86e6c41"}], "stats": {"total": 82, "additions": 22, "deletions": 60}, "files": [{"sha": "6209f08ef2895116a4c12b4c4be5e711022893d0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bf41c85c24857b0d7a6dbcc876abbe8c5c131f59", "patch": "@@ -582,7 +582,7 @@ impl<'b> Resolver<'b> {\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n+                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n                 if let Success(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n@@ -592,7 +592,7 @@ impl<'b> Resolver<'b> {\n         }\n         for (name, span) in legacy_imports.reexports {\n             self.used_crates.insert(module.def_id().unwrap().krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n+            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n             if let Success(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {"}, {"sha": "2bdfe734cf4173ce4e6ae2d665e2a31415d20909", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bf41c85c24857b0d7a6dbcc876abbe8c5c131f59", "patch": "@@ -1131,7 +1131,6 @@ pub struct Resolver<'a> {\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n-    new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n     use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n@@ -1333,7 +1332,6 @@ impl<'a> Resolver<'a> {\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n-            new_import_semantics: true,\n             use_extern_macros: session.features.borrow().use_extern_macros,\n \n             exported_macros: Vec::new(),\n@@ -1442,7 +1440,7 @@ impl<'a> Resolver<'a> {\n                                      -> ResolveResult<Module<'a>> {\n         fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n                                        -> Option<Module<'a>> {\n-            match this.resolve_name_in_module(module, needle, TypeNS, false, false, None) {\n+            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n                     search_parent_externals(this, needle, parent)\n@@ -1460,7 +1458,7 @@ impl<'a> Resolver<'a> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index].name;\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, false, span) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n                 Failed(_) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n@@ -1617,7 +1615,7 @@ impl<'a> Resolver<'a> {\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n                 let name = ident.name;\n-                let item = self.resolve_name_in_module(module, name, ns, true, false, record_used);\n+                let item = self.resolve_name_in_module(module, name, ns, false, record_used);\n                 if let Success(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1626,7 +1624,7 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, false, None).success()\n+                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -2772,7 +2770,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let name = segments.last().unwrap().identifier.name;\n-        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -2800,7 +2798,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let name = segments.last().unwrap().ident().name;\n-        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, Some(span));\n         result.success().ok_or(false)\n     }\n "}, {"sha": "6b385d549a5b8740bf79b86619de72b5a9979557", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=bf41c85c24857b0d7a6dbcc876abbe8c5c131f59", "patch": "@@ -272,7 +272,7 @@ impl<'a> Resolver<'a> {\n         loop {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n-            match self.resolve_name_in_module(module, name, ns, true, true, record_used) {\n+            match self.resolve_name_in_module(module, name, ns, true, record_used) {\n                 Success(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,"}, {"sha": "47bd1f71084aa3ae24b494b2fd42ffe8cc856b3d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf41c85c24857b0d7a6dbcc876abbe8c5c131f59/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=bf41c85c24857b0d7a6dbcc876abbe8c5c131f59", "patch": "@@ -75,7 +75,6 @@ pub struct NameResolution<'a> {\n     single_imports: SingleImports<'a>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n-    duplicate_globs: Vec<&'a NameBinding<'a>>,\n }\n \n #[derive(Clone, Debug)]\n@@ -141,7 +140,6 @@ impl<'a> Resolver<'a> {\n                                   module: Module<'a>,\n                                   name: Name,\n                                   ns: Namespace,\n-                                  allow_private_imports: bool,\n                                   ignore_unresolved_invocations: bool,\n                                   record_used: Option<Span>)\n                                   -> ResolveResult<&'a NameBinding<'a>> {\n@@ -153,18 +151,8 @@ impl<'a> Resolver<'a> {\n             _ => return Failed(None), // This happens when there is a cycle of imports\n         };\n \n-        let new_import_semantics = self.new_import_semantics;\n-        let is_disallowed_private_import = |binding: &NameBinding| {\n-            !new_import_semantics && !allow_private_imports && // disallowed\n-            binding.vis != ty::Visibility::Public && binding.is_import() && // non-`pub` import\n-            !binding.is_extern_crate() // not an `extern crate`\n-        };\n-\n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n-                if is_disallowed_private_import(binding) {\n-                    return Failed(None);\n-                }\n                 if self.record_use(name, ns, binding, span) {\n                     return Success(self.dummy_binding);\n                 }\n@@ -177,9 +165,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            let usable =\n-                this.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n-                binding.is_extern_crate(); // c.f. issue #37020\n+            // `extern crate` are always usable for backwards compatability, see issue #37020.\n+            let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n             if usable { Success(binding) } else { Failed(None) }\n         };\n \n@@ -202,7 +189,7 @@ impl<'a> Resolver<'a> {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, true, false, None) {\n+                match self.resolve_name_in_module(module, name, ns, false, None) {\n                     Failed(_) => {}\n                     _ => return Indeterminate,\n                 }\n@@ -224,7 +211,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, true, false, None);\n+                    let result = self.resolve_name_in_module(module, name, ns, false, None);\n                     if let Indeterminate = result {\n                         return Indeterminate;\n                     }\n@@ -311,22 +298,17 @@ impl<'a> Resolver<'a> {\n         self.update_resolution(module, name, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n-                    if !this.new_import_semantics {\n-                        resolution.duplicate_globs.push(binding);\n-                    } else if !old_binding.is_glob_import() &&\n-                              !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n+                    if !old_binding.is_glob_import() &&\n+                       !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n                     } else if binding.def() != old_binding.def() {\n                         resolution.binding = Some(this.ambiguity(old_binding, binding));\n                     } else if !old_binding.vis.is_at_least(binding.vis, this) {\n                         // We are glob-importing the same item but with greater visibility.\n                         resolution.binding = Some(binding);\n                     }\n                 } else if old_binding.is_glob_import() {\n-                    if !this.new_import_semantics {\n-                        resolution.duplicate_globs.push(old_binding);\n-                        resolution.binding = Some(binding);\n-                    } else if ns == MacroNS && binding.expansion != Mark::root() &&\n-                              binding.def() != old_binding.def() {\n+                    if ns == MacroNS && binding.expansion != Mark::root() &&\n+                       binding.def() != old_binding.def() {\n                         resolution.binding = Some(this.ambiguity(binding, old_binding));\n                     } else {\n                         resolution.binding = Some(binding);\n@@ -366,7 +348,7 @@ impl<'a> Resolver<'a> {\n             let t = f(self, resolution);\n \n             match resolution.binding() {\n-                _ if !self.new_import_semantics && old_binding.is_some() => return t,\n+                _ if old_binding.is_some() => return t,\n                 None => return t,\n                 Some(binding) => match old_binding {\n                     Some(old_binding) if old_binding as *const _ == binding as *const _ => return t,\n@@ -377,10 +359,7 @@ impl<'a> Resolver<'a> {\n \n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n-            if match self.new_import_semantics {\n-                true => self.is_accessible_from(binding.vis, directive.parent),\n-                false => binding.vis == ty::Visibility::Public,\n-            } {\n+            if self.is_accessible_from(binding.vis, directive.parent) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n@@ -528,7 +507,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n                 result[ns].set({\n-                    match this.resolve_name_in_module(module, source, ns, false, false, None) {\n+                    match this.resolve_name_in_module(module, source, ns, false, None) {\n                         Success(binding) => Ok(binding),\n                         Indeterminate => Err(Undetermined),\n                         Failed(_) => Err(Determined),\n@@ -624,7 +603,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n-                match this.resolve_name_in_module(module, name, ns, false, false, Some(span)) {\n+                match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n                     Success(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n@@ -729,8 +708,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n-            if binding.pseudo_vis() == ty::Visibility::Public ||\n-               self.new_import_semantics && self.is_accessible(binding.vis) {\n+            if binding.pseudo_vis() == ty::Visibility::Public || self.is_accessible(binding.vis) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n@@ -761,20 +739,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 None => continue,\n             };\n \n-            // Report conflicts\n-            if !self.new_import_semantics {\n-                for duplicate_glob in resolution.duplicate_globs.iter() {\n-                    // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n-                    if !binding.is_import() {\n-                        if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n-                            if binding.is_import() { continue }\n-                        }\n-                    }\n-\n-                    self.report_conflict(module, name, ns, duplicate_glob, binding);\n-                }\n-            }\n-\n             if binding.vis == ty::Visibility::Public &&\n                (binding.is_import() || binding.is_extern_crate()) {\n                 let def = binding.def();"}]}